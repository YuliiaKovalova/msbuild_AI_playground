diff --git a/documentation/fancylogger/Opt-In-Mechanism.md b/documentation/fancylogger/Opt-In-Mechanism.md
deleted file mode 100644
index d0df44b69dd..00000000000
--- a/documentation/fancylogger/Opt-In-Mechanism.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# When should we use FancyLogger
-
-The FancyLogger presents the user with the build's most relevant information at the time, automatically hiding all the information that is no longer relevant (as to prevent huge log outputs). However, many users might find this not very useful (or even counterproductive) such as those using a terminal without proper ANSI support or when redirecting the output to a file. For that reason, the users must be able to turn this feature on/off at will.
-
-# Proposal
-Using the `/fancylogger` or `/flg` command line switches, users are able to opt-in and use the FancyLogger, EXCEPT when:
-- The terminal does not support ANSI codes or color
-    - [ ] Detect if terminal does not support ANSI codes or color
- - Output is redirected to a file or pipe
-    - [x] Detect if terminal output is redirected
-
-For early development stages, an environment variable `$MSBUILDFANCYLOGGER` should be enabled to prevent accidental access to an unfinished feature. 
-
-In cases where the FancyLogger should not be enabled, the default ConsoleLogger should be used instead.
-
-# Considerations
-## Should FancyLogger be used with other loggers (eg, BinaryLogger, FileLogger, custom loggers)?
-FancyLogger should only replace the current ConsoleLogger for the aforementioned cases. Additionally, other loggers can be used in conjunction. 
-
-## Should output be ignored with the `/noconsolelogger` flag enabled?
-FancyLogger serves as a replacement for ConsoleLogger, so it should behave similarly. When attaching the `/noconsolelogger` flag, it should not output anything.
\ No newline at end of file
diff --git a/documentation/livelogger/Opt-In-Mechanism.md b/documentation/livelogger/Opt-In-Mechanism.md
new file mode 100644
index 00000000000..ca9c558fde8
--- /dev/null
+++ b/documentation/livelogger/Opt-In-Mechanism.md
@@ -0,0 +1,19 @@
+# When should we use LiveLogger
+
+The LiveLogger presents the user with the build's most relevant information at the time, automatically hiding all the information that is no longer relevant (as to prevent huge log outputs). However, many users might find this not very useful (or even counterproductive) such as those using a terminal without proper ANSI support or when redirecting the output to a file. For that reason, the users must be able to turn this feature on/off at will.
+
+# Proposal
+Using the `/livelogger` or `/ll` command line switches, users are able to opt-in and use the LiveLogger, EXCEPT when:
+- The terminal does not support ANSI codes or color
+ - Output is redirected to a file or pipe
+
+For early development stages, an environment variable `$MSBUILDLIVELOGGER` should be enabled to prevent accidental access to an unfinished feature. 
+
+In cases where the LiveLogger should not be enabled, the default ConsoleLogger should be used instead.
+
+# Considerations
+## Should LiveLogger be used with other loggers (eg, BinaryLogger, FileLogger, custom loggers)?
+LiveLogger should only replace the current ConsoleLogger for the aforementioned cases. Additionally, other loggers can be used in conjunction. 
+
+## Should output be ignored with the `/noconsolelogger` flag enabled?
+LiveLogger serves as a replacement for ConsoleLogger, so it should behave similarly. When attaching the `/noconsolelogger` flag, it should not output anything.
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 7310d68883a..e719ef73e02 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23060.6">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23073.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>74b7648c106865057c78ca1e4b2ffcb5e9bce071</Sha>
+      <Sha>05a8ec6db75694246db7a7b9ab680c9be91bf1d6</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-preview.3.136">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-rc.149">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>743503cb3c7e9ced2602ee2e29c38d63cc339451</Sha>
+      <Sha>ca5029046d7b6e55f322c45abb7b342054543710</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.5.0-3.23062.15">
       <Uri>https://github.com/dotnet/roslyn</Uri>
       <Sha>7061c64ddbd931d55b9a97f95243fcf91d04d7b1</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23060.6">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23073.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>74b7648c106865057c78ca1e4b2ffcb5e9bce071</Sha>
+      <Sha>05a8ec6db75694246db7a7b9ab680c9be91bf1d6</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 84ab06e6da4..e173379e310 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23060.6</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23073.7</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
     <MicrosoftNetCompilersToolsetVersion>4.5.0-3.23062.15</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.5.0-preview.3.136</NuGetBuildTasksVersion>
+    <NuGetBuildTasksVersion>6.5.0-rc.149</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.0</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
diff --git a/global.json b/global.json
index c809c9cec27..12a0dabf951 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.4.1"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23060.6"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23073.7"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index f1311c25d5c..a9edfebe54b 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -22,6 +22,7 @@
 using Shouldly;
 using Xunit;
 using Microsoft.Build.Framework;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -883,11 +884,9 @@ public void ItemsEnumerator()
 
 #if FEATURE_SECURITY_PRINCIPAL_WINDOWS
         /// <summary>
-        /// Build a solution file that can't be accessed
+        /// Build a solution file that can't be accessed.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]  // Security classes are not supported on Unix
-
+        [WindowsOnlyFact(additionalMessage: "Security classes are not supported on Unix.")]
         public void SolutionCanNotBeOpened()
         {
             Assert.Throws<InvalidProjectFileException>(() =>
@@ -930,11 +929,9 @@ public void SolutionCanNotBeOpened()
         }
 
         /// <summary>
-        /// Build a project file that can't be accessed
+        /// Build a project file that can't be accessed.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        // FileSecurity class is not supported on Unix
+        [WindowsOnlyFact(additionalMessage: "FileSecurity class is not supported on Unix.")]
         public void ProjectCanNotBeOpened()
         {
             Assert.Throws<InvalidProjectFileException>(() =>
@@ -1005,8 +1002,7 @@ public void SolutionCorrupt()
         /// <summary>
         /// Open lots of projects concurrently to try to trigger problems
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]  // This test is platform specific for Windows
+        [WindowsOnlyFact]
         public void ConcurrentProjectOpenAndCloseThroughProject()
         {
             int iterations = 500;
diff --git a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
index 1005cc140f2..3b4481b3cfb 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
@@ -1096,7 +1096,6 @@ public void DefaultToolsVersion()
 #else
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/276")]
 #endif
-        [Trait("Category", "mono-osx-failing")]
         public void DefaultToolsVersion2()
         {
             if (ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20) != null)
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 293cdb4ff05..406ad017571 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -16,6 +16,7 @@
 using Shouldly;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -703,8 +704,7 @@ public void ExcludeAndIncludeConsideredAsLiteralsWhenFilespecIsIllegal(string pr
             TestIncludeExclude(projectContents, inputFiles, expectedInclude, includeString, excludeString, normalizeSlashes: true);
         }
 
-        [Theory]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyTheory]
         [InlineData(ItemWithIncludeAndExclude,
             @"src/**/*.cs",
             new[]
@@ -793,8 +793,7 @@ public void ProjectGetterResultsInDriveEnumerationException(string unevaluatedIn
         /// Project getter that renames an item to a drive enumerating wildcard that results in a logged warning.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"z:\**\*.log")]
         [InlineData(@"z:$(empty)\**\*.log")]
         [InlineData(@"z:\**")]
@@ -807,8 +806,7 @@ public void ProjectGetterResultsInWindowsDriveEnumerationWarning(string unevalua
         }
 
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"/**/*.log")]
         [InlineData(@"$(empty)/**/*.log")]
         [InlineData(@"/$(empty)**/*.log")]
@@ -878,8 +876,7 @@ public void ThrowExceptionUponProjectInstanceCreationFromDriveEnumeratingContent
         /// Project instance created from a file that contains a drive enumerating wildcard results in a logged warning on the Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             ImportProjectElement,
             @"z:\**\*.targets",
@@ -903,8 +900,7 @@ public void LogWindowsWarningUponProjectInstanceCreationFromDriveEnumeratingCont
         }
 
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(
             ImportProjectElement,
             @"\**\*.targets",
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index d8ed8d18514..67c6e7cba7d 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -975,7 +975,6 @@ public void ChangeGlobalPropertiesPreexisting()
 #else
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/276")]
 #endif
-        [Trait("Category", "mono-osx-failing")]
         public void ChangeGlobalPropertiesInitiallyFromProjectCollection()
         {
             Dictionary<string, string> initial = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
@@ -1243,7 +1242,6 @@ public void GetSubToolsetVersion()
         /// environment
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetSubToolsetVersion_FromEnvironment()
         {
             string originalVisualStudioVersion = Environment.GetEnvironmentVariable("VisualStudioVersion");
@@ -3855,8 +3853,6 @@ public void ProjectInstanceShouldInitiallyHaveSameEvaluationIdAsTheProjectItCame
         [Fact]
         [Trait("Category", "netcore-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
         [Trait("Category", "netcore-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
         public void ProjectImportedEventFalseCondition()
         {
             using (var env = TestEnvironment.Create(_output))
@@ -3900,8 +3896,6 @@ public void ProjectImportedEventFalseCondition()
         [Fact]
         [Trait("Category", "netcore-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
         [Trait("Category", "netcore-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
         public void ProjectImportedEventNoMatchingFiles()
         {
             using (var env = TestEnvironment.Create(_output))
@@ -4161,8 +4155,6 @@ public void ProjectImportedEventMissingFileNoGlobMatch()
         [Fact]
         [Trait("Category", "netcore-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
         [Trait("Category", "netcore-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
         public void ProjectImportEvent()
         {
             using (var env = TestEnvironment.Create(_output))
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index 3e8f8a63a0e..96bee6d7db8 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -17,6 +17,7 @@
 using Xunit;
 using Shouldly;
 using System.Linq;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -908,8 +909,7 @@ public void ThrowExceptionUponBuildingProjectWithDriveEnumeration(string content
         /// Log warning for drive enumerating wildcards that exist in projects on Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             TargetItemWithIncludeAndExclude,
             @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
@@ -950,8 +950,7 @@ public void LogWindowsWarningUponBuildingProjectWithDriveEnumeration(string cont
         /// Log warning for drive enumerating wildcards that exist in projects on Unix platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
             @"$(Microsoft_WindowsAzure_EngSys)**",
@@ -981,8 +980,7 @@ public void LogUnixWarningUponBuildingProjectWithDriveEnumeration(string content
         /// <summary>
         /// Tests target item evaluation resulting in no build failures.
         /// </summary>
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
             @"$(Microsoft_WindowsAzure_EngSys)*.cs",
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 51d86b2f804..44cc3c47e4e 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -79,6 +79,7 @@
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
     <Compile Include="..\Shared\ProcessExtensions.cs" />
+    <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index e7458cf0a26..c0a00cf572e 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -9,6 +9,7 @@
 using Xunit;
 #endif
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 namespace Microsoft.Build.Engine.OM.UnitTests
 {
@@ -23,8 +24,7 @@ public NugetRestoreTests(ITestOutputHelper output)
         // This NuGet version cannot locate other assemblies when parsing solutions at restore time. This includes localized strings required in debug mode.
         // NuGet version 4.1.0 was somewhat arbitrarily chosen. 3.5 breaks with an unrelated error, and 4.8.2 does not fail when a new dependency is introduced. This is a safe middle point.
 #if !DEBUG
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
-        [Fact]
+        [WindowsFullFrameworkOnlyFact]
         public void TestOldNuget()
         {
             string msbuildExePath = Path.GetDirectoryName(RunnerUtilities.PathToCurrentlyRunningMsBuildExe)!;
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index 8ce02b04836..92362f41ed9 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -430,7 +430,6 @@ public void VerifyMatchingParametersDontLaunchTaskHost()
         /// parameters that explicitly do not match the current process. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyNonmatchingUsingTaskParametersLaunchTaskHost()
         {
             ITask createdTask = null;
@@ -464,7 +463,6 @@ public void VerifyNonmatchingUsingTaskParametersLaunchTaskHost()
         /// parameters that explicitly do not match the current process. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyNonmatchingTaskParametersLaunchTaskHost()
         {
             ITask createdTask = null;
@@ -496,7 +494,6 @@ public void VerifyNonmatchingTaskParametersLaunchTaskHost()
         /// parameters that explicitly do not match the current process. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyNonmatchingParametersLaunchTaskHost()
         {
             ITask createdTask = null;
@@ -561,7 +558,6 @@ public void VerifyExplicitlyLaunchTaskHost()
         /// explicitly instructed to launch the task host. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch1()
         {
             ITask createdTask = null;
@@ -595,7 +591,6 @@ public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch1()
         /// explicitly instructed to launch the task host. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch2()
         {
             ITask createdTask = null;
@@ -629,7 +624,6 @@ public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch2()
         /// explicitly instructed to launch the task host. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifySameFactoryCanGenerateDifferentTaskInstances()
         {
             ITask createdTask = null;
diff --git a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
index 063eb110090..b9d4f98ffcb 100644
--- a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -123,9 +124,7 @@ void TransportDelegate(INodePacket packet)
         /// <summary>
         /// Make sure shutdown will correctly null out the send data delegate
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/282")]
+        [WindowsFullFrameworkOnlyFact("https://github.com/dotnet/msbuild/issues/282")]
         public void TestShutDown()
         {
             SendDataDelegate transportDelegate = new(PacketProcessor);
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index c2d0569cb90..e340aaacdc6 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -2303,7 +2303,6 @@ public void ProjectInstanceLimitedTransferToOOPNode()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void CacheLifetime()
         {
             FileUtilities.ClearCacheDirectory();
@@ -3966,7 +3965,6 @@ public void OutOfProcEvaluationIdsUnique()
         /// Regression test for https://github.com/dotnet/msbuild/issues/3047
         /// </summary>
         [Fact]
-        [SkipOnMono("out-of-proc nodes not working on mono yet")]
         public void MultiProcReentrantProjectWithCallTargetDoesNotFail()
         {
             var a =
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index 3f0b73c8dbb..09c32f3184a 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -417,7 +417,6 @@ public void TestCache()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void WorksCorrectlyWithCurlyBraces()
         {
             string projectBody = ObjectModelHelpers.CleanupFileContents(@"
diff --git a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
index 9ba42506c30..2090f4c4807 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Framework;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -136,8 +137,7 @@ public void TestTranslation()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestTranslationRemoteHostObjects()
         {
diff --git a/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs b/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
index 527c35aa556..32078810707 100644
--- a/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.BackEnd;
@@ -22,31 +23,63 @@ public static IEnumerable<object[]> CacheData
             {
                 var configCache = new ConfigCache();
                 var brq1 = new BuildRequestConfiguration(
-                   1,
-                   new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1" }, null),
-                   Constants.defaultToolsVersion);
+                    1,
+                    new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1", "target2" }, null),
+                    Constants.defaultToolsVersion);
 
                 var brq2 = new BuildRequestConfiguration(
                     2,
                     new BuildRequestData("path2", new Dictionary<string, string> { ["a2"] = "b2" }, Constants.defaultToolsVersion, new[] { "target2" }, null),
                     Constants.defaultToolsVersion);
                 var brq3 = new BuildRequestConfiguration(
-                   3,
-                   new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
-                   Constants.defaultToolsVersion);
+                    3,
+                    new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
+                    Constants.defaultToolsVersion);
 
                 configCache.AddConfiguration(brq1);
                 configCache.AddConfiguration(brq2);
                 configCache.AddConfiguration(brq3);
 
                 var resultsCache = new ResultsCache();
-                var request1 = new BuildRequest(1, 0, 1, new string[] { "target1" }, null, BuildEventContext.Invalid, null);
+                var request1 = new BuildRequest(1, 0, 1, new string[] { "target1", "target2", "target3" }, null, BuildEventContext.Invalid, null);
                 var request2 = new BuildRequest(2, 0, 2, new string[] { "target2" }, null, BuildEventContext.Invalid, null);
                 var request3 = new BuildRequest(3, 0, 3, new string[] { "target3" }, null, BuildEventContext.Invalid, null);
 
-                resultsCache.AddResult(new BuildResult(request1));
-                resultsCache.AddResult(new BuildResult(request2));
-                resultsCache.AddResult(new BuildResult(request3));
+                var buildResult1 = new BuildResult(request1);
+                var buildResult2 = new BuildResult(request2);
+                var buildResult3 = new BuildResult(request3);
+
+                buildResult1.AddResultsForTarget(
+                    "target1",
+                    new TargetResult(
+                        Array.Empty<ProjectItemInstance.TaskItem>(),
+                        new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)));
+                buildResult1.AddResultsForTarget(
+                    "target2",
+                    new TargetResult(
+                        Array.Empty<ProjectItemInstance.TaskItem>(),
+                        new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)));
+                buildResult1.AddResultsForTarget(
+                    "target3",
+                    new TargetResult(
+                        Array.Empty<ProjectItemInstance.TaskItem>(),
+                        new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)));
+
+                buildResult2.AddResultsForTarget(
+                    "target2",
+                    new TargetResult(
+                        Array.Empty<ProjectItemInstance.TaskItem>(),
+                        new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)));
+
+                buildResult3.AddResultsForTarget(
+                    "target3",
+                    new TargetResult(
+                        Array.Empty<ProjectItemInstance.TaskItem>(),
+                        new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)));
+
+                resultsCache.AddResult(buildResult1);
+                resultsCache.AddResult(buildResult2);
+                resultsCache.AddResult(buildResult3);
 
                 return new List<object[]>
                 {
@@ -63,7 +96,11 @@ public void OnlySerializeCacheEntryWithSmallestConfigId(object configCache, obje
             try
             {
                 cacheFile = FileUtilities.GetTemporaryFile("MSBuildResultsCache");
-                Assert.Null(CacheSerialization.SerializeCaches((ConfigCache)configCache, (ResultsCache)resultsCache, cacheFile));
+                Assert.Null(CacheSerialization.SerializeCaches(
+                    (ConfigCache)configCache,
+                    (ResultsCache)resultsCache,
+                    cacheFile,
+                    ProjectIsolationMode.True));
 
                 var result = CacheSerialization.DeserializeCaches(cacheFile);
                 Assert.True(result.ConfigCache.HasConfiguration(1));
@@ -75,5 +112,39 @@ public void OnlySerializeCacheEntryWithSmallestConfigId(object configCache, obje
                 File.Delete(cacheFile);
             }
         }
+
+        [Theory]
+        [MemberData(nameof(CacheData))]
+        public void OnlySerializeResultsForSpecifiedTargets(object configCache, object resultsCache)
+        {
+            // Setup:
+            // 1. Create a config with id 1 whose project is built with top-level targets target1
+            // and target2.
+            // 2. Send a build request and collect the BuildResults for targets target1, target2,
+            // and target3.
+            // 3. Ensure the BuildResult for target3 is excluded from output cache serialization
+            // since it's not a top-level target.
+            string cacheFile = null;
+            try
+            {
+                cacheFile = FileUtilities.GetTemporaryFile("MSBuildResultsCache");
+                Assert.Null(CacheSerialization.SerializeCaches(
+                    (ConfigCache)configCache,
+                    (ResultsCache)resultsCache,
+                    cacheFile,
+                    ProjectIsolationMode.MessageUponIsolationViolation));
+
+                var result = CacheSerialization.DeserializeCaches(cacheFile);
+                Assert.True(result.ConfigCache.HasConfiguration(1));
+                BuildResult buildResult = result.ResultsCache.GetResultsForConfiguration(1);
+                Assert.True(buildResult.HasResultsForTarget("target1"));
+                Assert.True(buildResult.HasResultsForTarget("target2"));
+                Assert.False(buildResult.HasResultsForTarget("target3"));
+            }
+            finally
+            {
+                File.Delete(cacheFile);
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index 25e2ed70e01..3e2a1cb560a 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -3255,7 +3255,6 @@ public void IncludeCheckOnMetadata2()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void IncludeCheckOnMetadata_3()
         {
             MockLogger logger = new MockLogger();
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 5942f8ab8e4..f0619052e66 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -1021,7 +1021,6 @@ public void LogBuildStarted()
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/437")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void LogBuildStartedCriticalOnly()
         {
             ProcessBuildEventHelper service =
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index a948c97234a..4eb2b6a1307 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -1286,7 +1286,6 @@ public void StopOnFirstFailureandBuildInParallelSingleNode()
         /// Verify stopOnFirstFailure with BuildInParallel override message are correctly logged when there are multiple nodes
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void StopOnFirstFailureandBuildInParallelMultipleNode()
         {
             string project1 = ObjectModelHelpers.CreateTempFileOnDisk(@"
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index caae65aa14d..ff6ed17aefe 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -1,9 +1,9 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
-using System;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Engine.UnitTests.BackEnd;
 using Microsoft.Build.Evaluation;
@@ -66,24 +66,47 @@ internal class MockHost : MockLoggingService, IBuildComponentHost, IBuildCompone
         #endregion;
 
         /// <summary>
-        /// Constructor
+        /// Initializes a new instance of the <see cref="MockHost"/> class.
         /// </summary>
-        public MockHost()
-            : this(new BuildParameters())
+        /// <param name="overrideConfigCache">The override config cache.</param>
+        /// <param name="overrideResultsCache">The override results cache.</param>
+        public MockHost(ConfigCache overrideConfigCache = null, ResultsCache overrideResultsCache = null)
+            : this(new BuildParameters(), overrideConfigCache, overrideResultsCache)
         {
         }
 
         /// <summary>
-        /// Constructor
+        /// Initializes a new instance of the <see cref="MockHost"/> class.
         /// </summary>
-        public MockHost(BuildParameters buildParameters)
+        /// <param name="buildParameters">The mock host's build parameters.</param>
+        /// <param name="overrideConfigCache">The override config cache.</param>
+        /// <param name="overrideResultsCache">The override results cache.</param>
+        public MockHost(BuildParameters buildParameters, ConfigCache overrideConfigCache = null, ResultsCache overrideResultsCache = null)
         {
             _buildParameters = buildParameters;
 
             _buildParameters.ProjectRootElementCache = new ProjectRootElementCache(false);
 
-            _configCache = new ConfigCache();
-            ((IBuildComponent)_configCache).InitializeComponent(this);
+            if (overrideConfigCache != null && overrideResultsCache != null)
+            {
+                _configCache = new ConfigCacheWithOverride(overrideConfigCache);
+                _resultsCache = new ResultsCacheWithOverride(overrideResultsCache);
+            }
+            else if (overrideConfigCache == null && overrideResultsCache == null)
+            {
+                _configCache = new ConfigCache();
+                _resultsCache = new ResultsCache();
+            }
+            else if (overrideConfigCache == null)
+            {
+                throw new ArgumentNullException($"Attempted to create an override cache with a null {nameof(overrideConfigCache)}.");
+            }
+            else
+            {
+                throw new ArgumentNullException($"Attempted to create an override cache with a null {nameof(overrideResultsCache)}.");
+            }
+
+            _configCache.InitializeComponent(this);
 
             // We are a logging service
             _loggingService = this;
@@ -93,10 +116,9 @@ public MockHost(BuildParameters buildParameters)
             _requestEngine = new BuildRequestEngine();
             ((IBuildComponent)_requestEngine).InitializeComponent(this);
 
-            _resultsCache = new ResultsCache();
-            ((IBuildComponent)_resultsCache).InitializeComponent(this);
+            _resultsCache.InitializeComponent(this);
 
-            _requestBuilder = new Microsoft.Build.UnitTests.BackEnd.BuildRequestEngine_Tests.MockRequestBuilder();
+            _requestBuilder = new BuildRequestEngine_Tests.MockRequestBuilder();
             ((IBuildComponent)_requestBuilder).InitializeComponent(this);
 
             _targetBuilder = new TestTargetBuilder();
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 7675567e257..4a30daafd4f 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 using Xunit;
 
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index bdab3015c8c..15ad66ee408 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -58,7 +58,6 @@ public void Basic()
         /// Then these items and properties should be visible to the onerror targets.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void FailingTaskStillPublishesOutputs()
         {
             MockLogger l = new MockLogger();
diff --git a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
index 94079fa39f1..d292d13983a 100644
--- a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
@@ -597,6 +597,22 @@ public void VerifyNoOverCreationOfNodesWithBuildLoop()
             Assert.Equal(4, nextNodeId); // 3 nodes
         }
 
+        [Fact]
+        public void BuildResultNotPlacedInCurrentCacheIfConfigExistsInOverrideCache()
+        {
+            ConfigCache overrideConfigCache = new();
+            ResultsCache overrideResultsCache = new();
+            CreateConfiguration(1, "test.csproj", overrideConfigCache);
+            BuildRequest br1 = CreateBuildRequest(1, 1, new string[] { "A" });
+            CacheBuildResult(br1, "A", BuildResultUtilities.GetSuccessResult(), overrideResultsCache);
+            _host = new MockHost(overrideConfigCache, overrideResultsCache);
+            _scheduler = new Scheduler();
+            _scheduler.InitializeComponent(_host);
+            BuildRequest br2 = CreateBuildRequest(1, 1, new string[] { "B" });
+            _scheduler.RecordResultToCurrentCacheIfConfigNotInOverrideCache(CreateBuildResult(br2, "B", BuildResultUtilities.GetSuccessResult()));
+            Assert.Null(((ResultsCacheWithOverride)_host.GetComponent(BuildComponentType.ResultsCache)).CurrentCache.GetResultsForConfiguration(1));
+        }
+
         /// <summary>
         /// Verify that if we get two requests but one of them is a failure, we only get the failure result back.
         /// </summary>
@@ -706,26 +722,48 @@ public void TestDetailedSummary()
         }
 
         /// <summary>
-        /// Creates a configuration and stores it in the cache.
+        /// Creates a configuration to store in the <see cref="ConfigCache"/>.
         /// </summary>
-        private void CreateConfiguration(int configId, string file)
+        /// <param name="configId">The configuration id.</param>
+        /// <param name="projectFullPath">The project's full path.</param>
+        /// <param name="configCache">The config cache in which to place the configuration. If
+        /// <see cref="langword"="null" />, use the host's config cache.</param>
+        private void CreateConfiguration(int configId, string projectFullPath, ConfigCache configCache = null)
         {
-            BuildRequestData data = new BuildRequestData(file, new Dictionary<string, string>(), "4.0", Array.Empty<string>(), null);
-            BuildRequestConfiguration config = new BuildRequestConfiguration(configId, data, "4.0");
-            config.ProjectInitialTargets = new List<string>();
-            config.ProjectDefaultTargets = new List<string>();
-
-            (_host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache).AddConfiguration(config);
+            BuildRequestData data = new(projectFullPath, new Dictionary<string, string>(), "4.0", Array.Empty<string>(), null);
+            BuildRequestConfiguration config = new(configId, data, "4.0") { ProjectInitialTargets = new List<string>(), ProjectDefaultTargets = new List<string>() };
+            if (configCache == null)
+            {
+                (_host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache).AddConfiguration(config);
+            }
+            else
+            {
+                configCache.AddConfiguration(config);
+            }
         }
 
         /// <summary>
-        /// Creates and caches a built result.
+        /// Creates and caches a <see cref="BuildResult"/> in the <see cref="ResultsCache"/>.
         /// </summary>
-        private BuildResult CacheBuildResult(BuildRequest request, string target, WorkUnitResult workUnitResult)
+        /// <param name="request">The build request corresponding to the <see cref="BuildResult"/> to be
+        /// created and cached.</param>
+        /// <param name="target">The target for which there will be a result.</param>
+        /// <param name="workUnitResult">The result of executing the specified target.</param>
+        /// <param name="resultsCache">The results cache to contain the <see cref="BuildResult"/>.
+        /// If <see cref="langword"="null"/>, use the host's results cache.</param>
+        /// <returns>The build result.</returns>
+        private BuildResult CacheBuildResult(BuildRequest request, string target, WorkUnitResult workUnitResult, ResultsCache resultsCache = null)
         {
             BuildResult result = CreateBuildResult(request, target, workUnitResult);
-            IResultsCache resultsCache = _host.GetComponent(BuildComponentType.ResultsCache) as IResultsCache;
-            resultsCache.AddResult(result);
+            if (resultsCache == null)
+            {
+                (_host.GetComponent(BuildComponentType.ResultsCache) as IResultsCache).AddResult(result);
+            }
+            else
+            {
+                resultsCache.AddResult(result);
+            }
+
             return result;
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 09a8655bf48..3b13e37087c 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -527,7 +527,6 @@ public void IllegalFileCharsInItemsOutOfTask()
         /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void NullMetadataOnOutputItems()
         {
             string customTaskPath = Assembly.GetExecutingAssembly().Location;
@@ -552,7 +551,6 @@ public void NullMetadataOnOutputItems()
         /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void NullMetadataOnLegacyOutputItems()
         {
             string customTaskPath = Assembly.GetExecutingAssembly().Location;
@@ -650,7 +648,6 @@ public void NullMetadataOnOutputItems_InlineTask()
         /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/6521")]
-        [Trait("Category", "non-mono-tests")]
         public void NullMetadataOnLegacyOutputItems_InlineTask()
         {
             string projectContents = @"
@@ -706,7 +703,6 @@ public void ValidateDefiningProjectMetadataOnTaskOutputs()
         /// which didn't support the defining project metadata.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ValidateDefiningProjectMetadataOnTaskOutputs_LegacyItems()
         {
             string customTaskPath = Assembly.GetExecutingAssembly().Location;
@@ -718,7 +714,6 @@ public void ValidateDefiningProjectMetadataOnTaskOutputs_LegacyItems()
         /// Tests that putting the RunInSTA attribute on a task causes it to run in the STA thread.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadRequired()
         {
             TestSTATask(true, false, false);
@@ -728,7 +723,6 @@ public void TestSTAThreadRequired()
         /// Tests an STA task with an exception
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadRequiredWithException()
         {
             TestSTATask(true, false, true);
@@ -738,7 +732,6 @@ public void TestSTAThreadRequiredWithException()
         /// Tests an STA task with failure.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadRequiredWithFailure()
         {
             TestSTATask(true, true, false);
@@ -748,7 +741,6 @@ public void TestSTAThreadRequiredWithFailure()
         /// Tests an MTA task.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadNotRequired()
         {
             TestSTATask(false, false, false);
@@ -758,7 +750,6 @@ public void TestSTAThreadNotRequired()
         /// Tests an MTA task with an exception.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadNotRequiredWithException()
         {
             TestSTATask(false, false, true);
@@ -768,7 +759,6 @@ public void TestSTAThreadNotRequiredWithException()
         /// Tests an MTA task with failure.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadNotRequiredWithFailure()
         {
             TestSTATask(false, true, false);
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 6688e687a44..a3226a7df75 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -25,7 +25,6 @@ public TaskHostFactory_Tests(ITestOutputHelper testOutputHelper)
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TaskNodesDieAfterBuild()
         {
             using (TestEnvironment env = TestEnvironment.Create())
diff --git a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
index 1394e76a11b..e1ee00a3515 100644
--- a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
+++ b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -62,9 +63,7 @@ public void FindBuildEnvironmentByEnvironmentVariable()
         /// If MSBUILD_EXE_PATH is explicitly set, we should detect it as a VisualStudio instance even in older scenarios
         /// (for example when the install path is under 15.0).
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void FindVisualStudioEnvironmentByEnvironmentVariable()
         {
             using (var env = new EmptyVSEnviroment())
@@ -90,9 +89,7 @@ public void FindVisualStudioEnvironmentByEnvironmentVariable()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void FindBuildEnvironmentFromCommandLineVisualStudio()
         {
             using (var env = new EmptyVSEnviroment())
@@ -125,9 +122,7 @@ public void FindBuildEnvironmentFromCommandLineStandalone()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void FindBuildEnvironmentFromRunningProcessVisualStudio()
         {
             using (var env = new EmptyVSEnviroment())
@@ -196,9 +191,7 @@ public void FindBuildEnvironmentFromAppContextDirectory()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void FindBuildEnvironmentFromVisualStudioRoot()
         {
             using (var env = new EmptyVSEnviroment())
@@ -215,11 +208,9 @@ public void FindBuildEnvironmentFromVisualStudioRoot()
             }
         }
 
-        [Theory]
+        [WindowsFullFrameworkOnlyTheory(additionalMessage: "No Visual Studio installed for .NET.")]
         [InlineData(MSBuildConstants.CurrentVisualStudioVersion, true)]
         [InlineData("15.0", false)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentDetectsVisualStudioByEnvironment(string visualStudioVersion, bool shouldBeValid)
         {
             using (var env = new EmptyVSEnviroment())
@@ -242,9 +233,7 @@ public void BuildEnvironmentDetectsVisualStudioByEnvironment(string visualStudio
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentDetectsVisualStudioByMSBuildProcess()
         {
             using (var env = new EmptyVSEnviroment())
@@ -257,9 +246,7 @@ public void BuildEnvironmentDetectsVisualStudioByMSBuildProcess()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentDetectsVisualStudioByMSBuildProcessAmd64()
         {
             using (var env = new EmptyVSEnviroment())
@@ -272,9 +259,7 @@ public void BuildEnvironmentDetectsVisualStudioByMSBuildProcessAmd64()
             }
         }
 
-        [Theory]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyTheory(additionalMessage: "No Visual Studio installed for .NET.")]
         [InlineData("17.0", true)]
         [InlineData("17.3", true)]
         [InlineData("16.0", false)]
@@ -325,9 +310,7 @@ public void BuildEnvironmentDetectsRunningTests()
             BuildEnvironmentHelper.Instance.RunningInVisualStudio.ShouldBeFalse();
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentDetectsVisualStudioByProcessName()
         {
             using (var env = new EmptyVSEnviroment())
@@ -340,9 +323,7 @@ public void BuildEnvironmentDetectsVisualStudioByProcessName()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentDetectsVisualStudioByBlendProcess()
         {
             using (var env = new EmptyVSEnviroment())
@@ -355,9 +336,7 @@ public void BuildEnvironmentDetectsVisualStudioByBlendProcess()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentFindsAmd64()
         {
             using (var env = new EmptyVSEnviroment())
@@ -371,9 +350,8 @@ public void BuildEnvironmentFindsAmd64()
             }
         }
 
-        [Fact]
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void BuildEnvironmentFindsAmd64RunningInAmd64NoVS()
         {
             using (var env = new EmptyStandaloneEnviroment(MSBuildExeName, writeFakeFiles: true, includeAmd64Folder: true))
@@ -389,9 +367,8 @@ public void BuildEnvironmentFindsAmd64RunningInAmd64NoVS()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentFindsAmd64NoVS()
         {
             using (var env = new EmptyStandaloneEnviroment(MSBuildExeName, writeFakeFiles: true, includeAmd64Folder: true))
@@ -405,10 +382,8 @@ public void BuildEnvironmentFindsAmd64NoVS()
             }
         }
 
-        [Fact]
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentFindsAmd64RunningInAmd64()
         {
             using (var env = new EmptyVSEnviroment())
@@ -438,9 +413,7 @@ public void BuildEnvironmentNoneWhenNotAvailable()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentVSFromMSBuildAssembly()
         {
             using (var env = new EmptyVSEnviroment())
@@ -457,9 +430,7 @@ public void BuildEnvironmentVSFromMSBuildAssembly()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentVSFromMSBuildAssemblyAmd64()
         {
             using (var env = new EmptyVSEnviroment())
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 622e8c81c88..4f5ba07b009 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -21,6 +21,7 @@
 using Xunit.Abstractions;
 using Microsoft.Build.Execution;
 using System.Runtime.Versioning;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -176,7 +177,6 @@ public void TestEmptyProjectNameForTargetStarted()
         /// started event but there was no target printed out.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestTargetAfterProjectStarted()
         {
             SimulatedConsole sc = new SimulatedConsole();
@@ -321,9 +321,7 @@ public void ErrorMessageWithMultiplePropertiesInMessage(bool includeEvaluationPr
             output.ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + "::Number=2 TargetFramework=netcoreapp2.1]");
         }
 
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/6518")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "Minimal path validation in Core allows expanding path containing quoted slashes.")]
-        [SkipOnMono("Minimal path validation in Mono allows expanding path containing quoted slashes.")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "Minimal path validation in Core allows expanding path containing quoted slashes.", Skip = "https://github.com/dotnet/msbuild/issues/6518")]
         public void TestItemsWithUnexpandableMetadata()
         {
             SimulatedConsole sc = new SimulatedConsole();
@@ -349,7 +347,6 @@ public void TestItemsWithUnexpandableMetadata()
         /// Verify that on minimal verbosity the console logger does not log the target names.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestNoTargetNameOnMinimal()
         {
             SimulatedConsole sc = new SimulatedConsole();
@@ -367,7 +364,6 @@ public void TestNoTargetNameOnMinimal()
         /// Make sure if a target has no messages logged that its started and finished events show up on detailed but not normal.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptyTargetsOnDetailedButNotNormal()
         {
             SimulatedConsole sc = new SimulatedConsole();
@@ -412,7 +408,6 @@ public void EmptyTargetsOnDetailedButNotNormal()
         /// Test a number of cases where difference values from showcommandline are used with normal verbosity
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ShowCommandLineWithNormalVerbosity()
         {
             string command = "echo a";
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index a8f04046ca2..74de8fa1a11 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -49,7 +49,6 @@ public void BasicParseFirstProjectLine()
         /// extension of vcproj is seen as invalid.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void ParseFirstProjectLine_VC()
@@ -498,7 +497,6 @@ public void TestVSAndSolutionVersionParsing()
         /// Test ParseEtpProject function.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void ParseNestedEtpProjectMultipleLevel()
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 4e20b2d9617..b6097d1c35a 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -336,7 +336,6 @@ public void AddNewErrorWarningMessageElement()
         /// on the Solution File Format Version.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void EmitToolsVersionAttributeToInMemoryProject9()
@@ -372,7 +371,6 @@ public void EmitToolsVersionAttributeToInMemoryProject9()
         /// on the Solution File Format Version.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void EmitToolsVersionAttributeToInMemoryProject10()
@@ -485,7 +483,6 @@ public void SubToolsetSetBySolutionVersion()
         /// Test to make sure that even if the solution version corresponds to an existing sub-toolset version,
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SolutionBasedSubToolsetVersionOverriddenByEnvironment()
         {
             Environment.SetEnvironmentVariable("VisualStudioVersion", "ABC");
@@ -1208,7 +1205,6 @@ public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionNo
         /// The repro below has one of each case. WebProjects can't build so they are set as SkipNonexistentProjects='Build'
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void Regress751742_SkipNonexistentProjects()
@@ -1611,7 +1607,6 @@ public void TestConfigurationPlatformDefaults2()
         /// Tests the algorithm for choosing default Venus configuration values for solutions
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void TestVenusConfigurationDefaults()
@@ -1642,7 +1637,6 @@ public void TestVenusConfigurationDefaults()
         /// Tests that the correct value for TargetFrameworkVersion gets set when creating Venus solutions
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void VenusSolutionDefaultTargetFrameworkVersion()
@@ -1682,7 +1676,6 @@ public void VenusSolutionDefaultTargetFrameworkVersion()
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void TestTargetFrameworkPaths0()
@@ -1708,7 +1701,6 @@ public void TestTargetFrameworkPaths0()
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void TestTargetFrameworkPaths1()
@@ -1735,7 +1727,6 @@ public void TestTargetFrameworkPaths1()
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void TestTargetFrameworkPaths2()
@@ -1935,7 +1926,6 @@ public void SolutionGeneratorCanEmitSolutions()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSkipInvalidConfigurationsCase()
         {
             string tmpFileName = FileUtilities.GetTemporaryFileName();
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index 2e9ac12c15f..35e2ad09124 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -18,6 +18,7 @@
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using InternalUtilities = Microsoft.Build.Internal.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -87,8 +88,7 @@ public void OverrideTaskPathIsRelative()
             mockLogger.AssertLogContains(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTasksFileFailure", rootedPathMessage));
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void OverrideTaskPathHasInvalidChars()
         {
             ProjectCollection e = new ProjectCollection();
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
index 4d3962dfa70..70db749fe92 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
@@ -198,7 +198,6 @@ public void MSBuildToolsetsTest_BasicWithOtherConfigEntries()
         /// name attribute is missing from toolset element 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ToolsVersionTest_NameNotSpecified()
         {
             Assert.Throws<ConfigurationErrorsException>(() =>
@@ -255,7 +254,6 @@ public void ToolsVersionTest_MultipleElementsWithSameName()
         /// empty toolset element 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ToolsVersionTest_EmptyElement()
         {
             Assert.Throws<ConfigurationErrorsException>(() =>
@@ -323,7 +321,6 @@ public void ToolsVersionTest_SingleElement()
         ///  name attribute is missing
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyTest_NameNotSpecified()
         {
             Assert.Throws<ConfigurationErrorsException>(() =>
@@ -400,7 +397,6 @@ public void PropertyTest_MultipleElementsWithSameName()
         ///  property element is an empty element
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyTest_EmptyElement()
         {
             Assert.Throws<ConfigurationErrorsException>(() =>
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index f37d6c7329c..8e3ebab9914 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -20,6 +20,7 @@
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 using InternalUtilities = Microsoft.Build.Internal.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -30,7 +31,6 @@ namespace Microsoft.Build.UnitTests.Definition
     /// <summary>
     /// Unit tests for ToolsetReader class and its derived classes
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class ToolsetReaderTests : IDisposable
     {
         // The registry key that is passed as the baseKey parameter to the ToolsetRegistryReader class
@@ -92,14 +92,9 @@ private void DeleteTestRegistryKey()
         /// Test to make sure machine.config file has the section registered
         /// and we are picking it up from there.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "The machine.config is only present on Windows.")]
         public void GetToolsetDataFromConfiguration_SectionNotRegisteredInConfigFile()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "The machine.config is only present on Windows"
-            }
-
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
                  <configuration>
                    <configSections>
@@ -131,7 +126,7 @@ public void GetToolsetDataFromConfiguration_SectionNotRegisteredInConfigFile()
         /// <summary>
         /// Tests that the data is correctly populated using function GetToolsetDataFromConfiguration
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_Basic()
         {
             string v2Folder = NativeMethodsShared.IsWindows
@@ -175,7 +170,7 @@ public void GetToolsetDataFromConfiguration_Basic()
         /// <summary>
         /// Relative paths can be used in a config file value
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void RelativePathInValue()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -216,7 +211,7 @@ public void RelativePathInValue()
         /// <summary>
         /// Invalid relative path in msbuildbinpath value
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidRelativePath()
         {
             if (NativeMethodsShared.IsLinux)
@@ -253,7 +248,7 @@ public void InvalidRelativePath()
         /// <summary>
         /// Tests the case where application configuration file is invalid
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_InvalidXmlFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -272,7 +267,7 @@ public void GetToolsetDataFromConfiguration_InvalidXmlFile()
         /// <summary>
         /// Tests the case where application configuration file is invalid
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_InvalidConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -301,7 +296,7 @@ public void GetToolsetDataFromConfiguration_InvalidConfigFile()
         /// <summary>
         /// Tests the case where application configuration file is empty
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_FileEmpty()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -321,7 +316,7 @@ public void GetToolsetDataFromConfiguration_FileEmpty()
         /// Tests the case when ReadConfiguration throws exception
         /// Make sure that we don't eat it and always throw ConfigurationErrorsException
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ConfigurationExceptionThrown()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -342,7 +337,7 @@ public void GetToolsetDataFromConfiguration_ConfigurationExceptionThrown()
         /// Tests the case when ReadConfiguration throws exception
         /// Make sure that we don't eat it and always throw ConfigurationErrorsException
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ConfigurationErrorsExceptionThrown()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -362,7 +357,7 @@ public void GetToolsetDataFromConfiguration_ConfigurationErrorsExceptionThrown()
         /// <summary>
         /// Tests the case where default attribute is not specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_DefaultAttributeNotSpecified()
         {
             string v2Folder = NativeMethodsShared.IsWindows
@@ -397,7 +392,7 @@ public void GetToolsetDataFromConfiguration_DefaultAttributeNotSpecified()
         /// <summary>
         /// Default toolset has no toolsVersion element definition
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_DefaultToolsetUndefined()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -427,7 +422,7 @@ public void GetToolsetDataFromConfiguration_DefaultToolsetUndefined()
         /// Tests the case where msbuildToolsets is not specified in the config file
         /// Basically in the code we should be checking if config.GetSection("msbuildToolsets") returns a null
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_MSBuildToolsetsNodeNotPresent()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -451,7 +446,7 @@ public void GetToolsetDataFromConfiguration_MSBuildToolsetsNodeNotPresent()
         /// <summary>
         /// Tests that we handle empty MSBuildToolsets element correctly
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_EmptyMSBuildToolsetsNode()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -476,7 +471,7 @@ public void GetToolsetDataFromConfiguration_EmptyMSBuildToolsetsNode()
         /// <summary>
         /// Tests the case where only default ToolsVersion is specified in the application configuration file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_OnlyDefaultSpecified()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -503,7 +498,7 @@ public void GetToolsetDataFromConfiguration_OnlyDefaultSpecified()
         /// <summary>
         /// Tests the case where only one ToolsVersion data is specified in the application configuration file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_OneToolsVersionNode()
         {
             string v2Folder = NativeMethodsShared.IsWindows
@@ -537,7 +532,7 @@ public void GetToolsetDataFromConfiguration_OneToolsVersionNode()
         /// <summary>
         /// Tests the case when an invalid value of ToolsVersion is specified
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ToolsVersionIsEmptyString()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -570,7 +565,7 @@ public void GetToolsetDataFromConfiguration_ToolsVersionIsEmptyString()
         /// <summary>
         /// If both MSBuildToolsPath and MSBuildBinPath are present, they must match
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ToolsPathAndBinPathDiffer()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -600,7 +595,7 @@ public void GetToolsetDataFromConfiguration_ToolsPathAndBinPathDiffer()
         /// <summary>
         /// Tests the case when a blank value of PropertyName is specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyNameInConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -634,7 +629,7 @@ public void BlankPropertyNameInConfigFile()
         /// <summary>
         /// Tests the case when a blank property name is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyNameInRegistry()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -661,7 +656,7 @@ public void BlankPropertyNameInRegistry()
         /// Tests the case when a blank property name is specified in the registry in a
         /// sub-toolset.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyNameInRegistrySubToolset()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -694,7 +689,7 @@ public void BlankPropertyNameInRegistrySubToolset()
         /// <summary>
         /// Tests the case when a blank property value is specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyValueInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -725,7 +720,7 @@ public void BlankPropertyValueInConfigFile()
         /// <summary>
         /// Tests the case when a blank property value is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyValueInRegistry()
         {
             RegistryKey rk = _toolsVersionsRegistryKey.CreateSubKey("2.0");
@@ -749,7 +744,7 @@ public void BlankPropertyValueInRegistry()
         /// <summary>
         /// Tests the case when a blank property value is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyValueInRegistrySubToolset()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"c:\someBinPath" : "/someBinPath";
@@ -783,7 +778,7 @@ public void BlankPropertyValueInRegistrySubToolset()
         /// <summary>
         /// Tests the case when an invalid value of PropertyName is specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidPropertyNameInConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -816,7 +811,7 @@ public void InvalidPropertyNameInConfigFile()
         /// <summary>
         /// Tests the case when an invalid value of PropertyName is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidPropertyNameInRegistry()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -842,7 +837,7 @@ public void InvalidPropertyNameInRegistry()
         /// <summary>
         /// Tests the case when an invalid value of PropertyName is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidPropertyNameInRegistrySubToolset()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -872,7 +867,7 @@ public void InvalidPropertyNameInRegistrySubToolset()
         /// <summary>
         /// Tests that empty string is an invalid value for MSBuildBinPath
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString1()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -901,7 +896,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString1()
         /// <summary>
         /// Tests that empty string is a valid property value for an arbitrary property
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString2()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -935,7 +930,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString2()
         /// Note that this comes for free with the current implementation using the
         /// framework api to access section in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_XmlEscapedCharacters()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -972,7 +967,7 @@ public void GetToolsetDataFromConfiguration_XmlEscapedCharacters()
         /// <summary>
         /// Tests the case where registry and config file contains different toolsVersion
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_NoConflict()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1031,7 +1026,7 @@ public void GetToolsetData_NoConflict()
         /// <summary>
         /// Tests that ToolsetInitialization are respected.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsetInitializationFlagsSetToNone()
         {
             // Set up registry with two tools versions and one property each
@@ -1085,7 +1080,7 @@ public void ToolsetInitializationFlagsSetToNone()
         /// <summary>
         /// Tests that ToolsetInitialization are respected.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsetInitializationFlagsSetToRegistry()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1132,7 +1127,7 @@ public void ToolsetInitializationFlagsSetToRegistry()
             Assert.Equal(binPath2, values["4.0"].ToolsPath);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ThrowOnNonStringRegistryValueTypes()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1157,7 +1152,7 @@ public void ThrowOnNonStringRegistryValueTypes()
                                                                ToolsetDefinitionLocations.Registry);
             });
         }
-        [Fact]
+        [WindowsOnlyFact]
         public void PropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
         {
             string binPath = NativeMethodsShared.IsWindows ? "c:\\x" : "/x";
@@ -1186,7 +1181,7 @@ public void PropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
             Assert.Equal(binPath, values["2.0"].ToolsPath);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SubToolsetPropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
         {
             RegistryKey rk = _toolsVersionsRegistryKey.CreateSubKey("2.0");
@@ -1216,7 +1211,7 @@ public void SubToolsetPropertiesInRegistryCannotReferToOtherPropertiesInRegistry
             Assert.Equal("c:\\x", values["2.0"].SubToolsets["dogfood"].Properties["p3"].EvaluatedValue);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SubToolsetsCannotDefineMSBuildToolsPath()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1246,7 +1241,7 @@ public void SubToolsetsCannotDefineMSBuildToolsPath()
         /// <summary>
         /// Tests that ToolsetInitialization are respected.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsetInitializationFlagsSetToConfigurationFile()
         {
             string v2Dir = NativeMethodsShared.IsWindows ? "D:\\windows\\Microsoft.NET\\Framework\\v2.0.x86ret" : "/windows/Microsoft.NET/Framework/v2.0.x86ret";
@@ -1301,14 +1296,9 @@ public void ToolsetInitializationFlagsSetToConfigurationFile()
         /// "TaskLocation" is the name of the value.  The name of the value and the preceding "@" may be omitted if
         /// the default value is desired.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Registry access is only supported under Windows.")]
         public void PropertyInConfigurationFileReferencesRegistryLocation()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Registry access is only supported under Windows."
-            }
-
             // Registry Read
             RegistryKey key1 = Registry.CurrentUser.CreateSubKey(@"Software\Vendor\Tools");
             key1.SetValue("TaskLocation", @"somePathToTasks");
@@ -1353,7 +1343,7 @@ public void PropertyInConfigurationFileReferencesRegistryLocation()
             Registry.CurrentUser.DeleteSubKeyTree(@"Software\Vendor");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsPathInRegistryHasInvalidPathChars()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1378,7 +1368,7 @@ public void ToolsPathInRegistryHasInvalidPathChars()
         }
 
 #if FEATURE_SYSTEM_CONFIGURATION
-        [Fact]
+        [WindowsOnlyFact]
         public void SamePropertyDefinedMultipleTimesForSingleToolsVersionInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1410,7 +1400,7 @@ public void SamePropertyDefinedMultipleTimesForSingleToolsVersionInConfiguration
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SamePropertyDifferentCaseDefinedMultipleTimesForSingleToolsVersionInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1443,7 +1433,7 @@ public void SamePropertyDifferentCaseDefinedMultipleTimesForSingleToolsVersionIn
         }
 
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SameToolsVersionDefinedMultipleTimesInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1481,7 +1471,7 @@ public void SameToolsVersionDefinedMultipleTimesInConfigurationFile()
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SameToolsVersionDifferentCaseDefinedMultipleTimesInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1519,7 +1509,7 @@ public void SameToolsVersionDifferentCaseDefinedMultipleTimesInConfigurationFile
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void CannotSetReservedPropertyInConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1550,7 +1540,7 @@ public void CannotSetReservedPropertyInConfigFile()
         }
 #endif
 
-        [Fact]
+        [WindowsOnlyFact]
         public void CannotSetReservedPropertyInRegistry()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1574,7 +1564,7 @@ public void CannotSetReservedPropertyInRegistry()
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void CannotSetReservedPropertyInRegistrySubToolset()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1604,7 +1594,7 @@ public void CannotSetReservedPropertyInRegistrySubToolset()
         /// Properties defined in previously processed toolset definitions should
         /// not affect the evaluation of subsequent toolset definitions.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NoInterferenceBetweenToolsetDefinitions()
         {
             string v20Dir = NativeMethodsShared.IsWindows ? @"D:\20\some\folder\on\disk" : "/20/some/folder/on/disk";
@@ -1659,76 +1649,56 @@ public void NoInterferenceBetweenToolsetDefinitions()
         /// "TaskLocation" is the name of the value.  The name of the value and the preceding "@" may be omitted if
         /// the default value is desired.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Access local machine registry is for Windows only.")]
         public void ConfigFileInvalidRegistryExpression1()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Access local machine registry is for Windows only"
-            }
-
             // No location
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Access local machine registry is for Windows only.")]
         public void ConfigFileInvalidRegistryExpression2()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Access local machine registry is for Windows only"
-            }
-
             // Bogus key expression
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:__bogus__)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Access local machine registry is for Windows only.")]
         public void ConfigFileInvalidRegistryExpression3()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Access local machine registry is for Windows only"
-            }
-
             // No registry location just @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:@)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression4()
         {
             // Double @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:HKEY_CURRENT_USER\Software\Vendor\Tools@@TaskLocation)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression5()
         {
             // Trailing @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:HKEY_CURRENT_USER\Software\Vendor\Tools@TaskLocation@)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression6()
         {
             // Leading @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:@HKEY_CURRENT_USER\Software\Vendor\Tools@TaskLocation)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Access registry is for Windows only.")]
         public void ConfigFileInvalidRegistryExpression7()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Access registry is for Windows only"
-            }
-
             // Bogus hive
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:BOGUS_HIVE\Software\Vendor\Tools@TaskLocation)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileStringEmptyRegistryExpression1()
         {
             // Regular undefined property beginning with "Registry"
@@ -1736,7 +1706,7 @@ public void ConfigFileStringEmptyRegistryExpression1()
                                           String.Empty);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileStringEmptyRegistryExpression2()
         {
             // Nonexistent key
@@ -1744,7 +1714,7 @@ public void ConfigFileStringEmptyRegistryExpression2()
                                           String.Empty);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileNonPropertyRegistryExpression1()
         {
             // Property not terminated with paren, does not look like property
@@ -1752,7 +1722,7 @@ public void ConfigFileNonPropertyRegistryExpression1()
                                           @"$(Registry:HKEY_CURRENT_USER\Software\Vendor\Tools@TaskLocation");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileNonPropertyRegistryExpression2()
         {
             // Missing colon, looks like regular property (but with invalid property name chars, we will return blank as a result)
@@ -1760,7 +1730,7 @@ public void ConfigFileNonPropertyRegistryExpression2()
                                           String.Empty);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileItemExpressionsDoNotExpandInConfigurationProperties()
         {
             // Expect that item expressions such as '@(SomeItem)' are not evaluated in any way, e.g., they are treated literally
@@ -1768,19 +1738,14 @@ public void ConfigFileItemExpressionsDoNotExpandInConfigurationProperties()
                                           @"@(SomeItem)");
         }
 
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Access local machine registry is for Windows only.")]
         public void RegistryInvalidRegistryExpression1()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Access local machine registry is for Windows only"
-            }
-
             // Bogus key expression
             RegistryInvalidRegistryExpressionHelper("$(Registry:__bogus__)");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void RegistryValidRegistryExpression1()
         {
             // Regular undefined property beginning with "Registry"
@@ -1890,7 +1855,7 @@ private void ConfigFileValidRegistryExpressionHelper(string propertyExpression,
         /// <summary>
         /// Tests the case where application configuration file overrides a value already specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ConflictingPropertyValuesSameCase()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1935,7 +1900,7 @@ public void GetToolsetData_ConflictingPropertyValuesSameCase()
         /// where that registry value is bogus and would otherwise throw.  However, since the config file also
         /// contains an entry for that toolset, the registry toolset never gets read, and thus never throws.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ConflictingPropertyValuesRegistryThrows()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1979,7 +1944,7 @@ public void GetToolsetData_ConflictingPropertyValuesRegistryThrows()
         /// well as in the config file for the same tools version.
         /// We should not merge them; we should take the config file ones only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_NoMerging()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -2028,7 +1993,7 @@ public void GetToolsetData_NoMerging()
         /// The absence of the ToolsVersion attribute on the main Project element in a project file means
         /// that the engine's default tools version should be used.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsVersionAttributeNotSpecifiedOnProjectElementAndDefaultVersionSpecifiedInRegistry()
         {
             string oldValue = Environment.GetEnvironmentVariable("MSBUILDLEGACYDEFAULTTOOLSVERSION");
@@ -2070,7 +2035,7 @@ public void ToolsVersionAttributeNotSpecifiedOnProjectElementAndDefaultVersionSp
         /// <summary>
         /// Tests the case when no values are specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_RegistryNotPresent()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somedifferentpath" : "/somedifferentpath";
@@ -2110,7 +2075,7 @@ public void GetToolsetData_RegistryNotPresent()
         /// Note that config file not present is same as config file
         /// with no MSBuildToolsets Section
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ConfigFileNotPresent()
         {
             // Registry Read
@@ -2138,7 +2103,7 @@ public void GetToolsetData_ConfigFileNotPresent()
         /// <summary>
         /// Tests the case where nothing is specified in registry and config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_RegistryAndConfigNotPresent()
         {
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
@@ -2168,7 +2133,7 @@ public void GetToolsetData_RegistryAndConfigNotPresent()
         /// <summary>
         /// Tests the case when reading config file throws an exception
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ReadConfigThrowsException()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -2198,7 +2163,7 @@ public void GetToolsetData_ReadConfigThrowsException()
         /// <summary>
         /// Tests the case where reading from registry throws exception
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ReadRegistryOpenSubKeyThrowsException()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -2242,7 +2207,7 @@ public void GetToolsetData_ReadRegistryOpenSubKeyThrowsException()
         /// Tests that the default ToolsVersion is correctly resolved when specified
         /// in registry and config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedInRegistryAndConfigFile()
         {
             // Set up registry with two tools versions and one property each
@@ -2287,7 +2252,7 @@ public void SetDefaultToolsetVersion_SpecifiedInRegistryAndConfigFile()
         /// <summary>
         /// Tests that the default ToolsVersion is correctly resolved when specified in registry only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedOnlyInRegistry()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2330,7 +2295,7 @@ public void SetDefaultToolsetVersion_SpecifiedOnlyInRegistry()
         /// <summary>
         /// Tests that the override task path is correctly resolved when specified in registry only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetOverrideTasks_SpecifiedOnlyInRegistry()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2380,7 +2345,7 @@ public void SetOverrideTasks_SpecifiedOnlyInRegistry()
         /// <summary>
         /// Tests that the override default toolsversion is correctly resolved when specified in registry only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInRegistry()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2427,7 +2392,7 @@ public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInRegistry()
         /// Tests that the default ToolsVersion is correctly resolved
         /// when specified in config file only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedOnlyInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -2466,7 +2431,7 @@ public void SetDefaultToolsetVersion_SpecifiedOnlyInConfigFile()
         /// when specified in config file only.
         /// Also, that MSBuildOverrideTasksPath can be overridden.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetOverrideTaskPath_SpecifiedOnlyInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -2507,7 +2472,7 @@ public void SetOverrideTaskPath_SpecifiedOnlyInConfigFile()
         /// Tests that the override default ToolsVersion is correctly resolved
         /// when specified in config file only.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -2545,7 +2510,7 @@ public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInConfigFile()
         /// <summary>
         /// Tests that the default ToolsVersion is correctly resolved when specified nowhere
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedNowhere()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2592,7 +2557,7 @@ public void SetDefaultToolsetVersion_SpecifiedNowhere()
         /// <summary>
         /// Tests that properties are properly expanded when reading them from the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PropertiesInToolsetsFromConfigFileAreExpanded()
         {
             // $(COMPUTERNAME) is just a convenient env var. $(NUMBER_OF_PROCESSORS) isn't defined on Longhorn
@@ -2632,7 +2597,7 @@ public void PropertiesInToolsetsFromConfigFileAreExpanded()
         /// <summary>
         /// Tests that properties in MSBuildToolsPath are properly expanded when reading them from the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PropertiesInToolsetsFromConfigFileAreExpandedInToolsPath()
         {
             string binPathConfig = NativeMethodsShared.IsWindows ?
@@ -2686,7 +2651,7 @@ public void PropertiesInToolsetsFromConfigFileAreExpandedInToolsPath()
         /// Global properties are available, but they cannot be overwritten by other toolset properties, just as they cannot
         /// be overwritten by project file properties.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GlobalPropertiesInToolsetsAreExpandedButAreNotOverwritten()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
diff --git a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
index a39a6b336b0..213b448ec14 100644
--- a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
@@ -10,10 +10,10 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Shared;
 using Microsoft.Win32;
 
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 
@@ -24,7 +24,6 @@ namespace Microsoft.Build.UnitTests.Definition
     /// <summary>
     /// Unit test for ToolsetRegistryReader class
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class ToolsetRegistryReader_Tests : IDisposable
     {
         // The registry key that is passed as the baseKey parameter to the ToolsetRegistryReader class
@@ -79,7 +78,7 @@ private void DeleteTestRegistryKey()
         /// <summary>
         /// If the base key has been deleted, then we just don't get any information (no exception)
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_DeletedKey()
         {
             DeleteTestRegistryKey();
@@ -119,7 +118,7 @@ public void DefaultValuesInRegistryCreatedBySetup()
         /// <summary>
         /// Tests we handle no default toolset specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void DefaultValueInRegistryDoesNotExist()
         {
             ToolsetReader reader = new ToolsetRegistryReader(new ProjectCollection().EnvironmentProperties, new PropertyDictionary<ProjectPropertyInstance>(), new MockRegistryKey(testRegistryPath, "3.5" /* fail to find subkey 3.5 */));
@@ -138,7 +137,7 @@ public void DefaultValueInRegistryDoesNotExist()
         /// <summary>
         /// The base key exists but contains no subkey or values: this is okay
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_NoSubkeyNoValues()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -155,7 +154,7 @@ public void ReadRegistry_NoSubkeyNoValues()
         /// Here we validate that MSBuild does not fail when there are unrecognized values underneath
         /// the ToolsVersion key.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_NoSubkeysOnlyValues()
         {
             _toolsVersionsRegistryKey.SetValue("Name1", "Value1");
@@ -174,7 +173,7 @@ public void ReadRegistry_NoSubkeysOnlyValues()
         /// <summary>
         /// Basekey has only 1 subkey
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_OnlyOneSubkey()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -197,7 +196,7 @@ public void ReadRegistry_OnlyOneSubkey()
         /// <summary>
         /// Basic case
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_Basic()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -227,7 +226,7 @@ public void ReadRegistry_Basic()
         /// <summary>
         /// baseKey contains some non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -256,7 +255,7 @@ public void ReadRegistry_NonStringData()
         ///        SubKey2
         ///        SubKey3
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_HasSubToolsets()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -312,7 +311,7 @@ public void ReadRegistry_HasSubToolsets()
         ///        SubKey1
         ///            SubSubKey1
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_IgnoreSubToolsetSubKeys()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -347,7 +346,7 @@ public void ReadRegistry_IgnoreSubToolsetSubKeys()
         /// selected subtoolset, the subtoolset value overrides -- even if that
         /// value is empty.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_SubToolsetOverridesBaseToolsetEntries()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -387,7 +386,7 @@ public void ReadRegistry_SubToolsetOverridesBaseToolsetEntries()
         /// selected subtoolset, the subtoolset value overrides -- even if that
         /// value is empty.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_UnselectedSubToolsetIsIgnored()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -416,7 +415,7 @@ public void ReadRegistry_UnselectedSubToolsetIsIgnored()
         /// <summary>
         /// Regular case of getting default tools version
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultToolsVersionFromRegistry_Basic()
         {
             _currentVersionRegistryKey.SetValue("DefaultToolsVersion", "tv1");
@@ -435,7 +434,7 @@ public void GetDefaultToolsVersionFromRegistry_Basic()
         /// <summary>
         /// Default value is not set
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultToolsVersionFromRegistry_DefaultValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -450,7 +449,7 @@ public void GetDefaultToolsVersionFromRegistry_DefaultValueNotSet()
         /// <summary>
         /// "DefaultToolsVersion" has non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultToolsVersionFromRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -473,7 +472,7 @@ private ToolsetRegistryReader GetStandardRegistryReader()
         /// <summary>
         /// Regular case of getting overridetaskspath
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetOverrideTasksPathFromRegistry_Basic()
         {
             if (NativeMethodsShared.IsUnixLike)
@@ -495,7 +494,7 @@ public void GetOverrideTasksPathFromRegistry_Basic()
         /// <summary>
         /// OverrideTasksPath is not set
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetOverrideTasksPathFromRegistry_ValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -510,7 +509,7 @@ public void GetOverrideTasksPathFromRegistry_ValueNotSet()
         /// <summary>
         /// "OverrideTasksPath" has non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetOverrideTasksPathFromRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -527,7 +526,7 @@ public void GetOverrideTasksPathFromRegistry_NonStringData()
         /// <summary>
         /// Regular case of getting the default override toolsversion
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultOverrideToolsVersionFromRegistry_Basic()
         {
             _currentVersionRegistryKey.SetValue("DefaultOverrideToolsVersion", "Current");
@@ -544,7 +543,7 @@ public void GetDefaultOverrideToolsVersionFromRegistry_Basic()
         /// <summary>
         /// DefaultOverrideToolsVersion is not set
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultOverrideToolsVersionFromRegistry_ValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -559,7 +558,7 @@ public void GetDefaultOverrideToolsVersionFromRegistry_ValueNotSet()
         /// <summary>
         /// "DefaultOverrideToolsVersion" has non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultOverrideToolsVersionFromRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -573,7 +572,7 @@ public void GetDefaultOverrideToolsVersionFromRegistry_NonStringData()
                 reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
             });
         }
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadToolsets_NoBinPathOrToolsPath()
         {
             RegistryKey key1 = _toolsVersionsRegistryKey.CreateSubKey("tv1");
diff --git a/src/Build.UnitTests/Definition/Toolset_Tests.cs b/src/Build.UnitTests/Definition/Toolset_Tests.cs
index aaaade0b2b2..2bf6e660b37 100644
--- a/src/Build.UnitTests/Definition/Toolset_Tests.cs
+++ b/src/Build.UnitTests/Definition/Toolset_Tests.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -173,8 +174,7 @@ public void TestDefaultSubToolset()
             Assert.Equal("v13.0", t.DefaultSubToolsetVersion);
         }
 
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/4363")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/4363")]
         public void TestDefaultSubToolsetFor40()
         {
             Toolset t = ProjectCollection.GlobalProjectCollection.GetToolset("4.0");
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index 93a4f449f12..97ce42f1f29 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -107,7 +107,6 @@ public void SemicolonInPropertyPassedIntoStringParam()
         /// a string parameter of a task, in this case the Message task.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SemicolonInPropertyPassedIntoStringParam_UsingTaskHost()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
@@ -160,7 +159,6 @@ public void SemicolonInPropertyPassedIntoITaskItemParam()
         /// an ITaskItem[] task parameter.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SemicolonInPropertyPassedIntoITaskItemParam_UsingTaskHost()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(String.Format(@"
@@ -606,7 +604,6 @@ public void ItemTransformContainingSemicolon()
         /// as an escaped percent sign.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ItemTransformContainingSemicolon_InTaskHost()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
@@ -733,7 +730,6 @@ public void EscapedWildcardsShouldNotBeExpanded()
         /// literally, not as a wildcard
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EscapedWildcardsShouldNotBeExpanded_InTaskHost()
         {
             MockLogger logger = new();
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index c58a0dc6ad7..f215d86d9ec 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -20,7 +20,7 @@
 using Microsoft.Build.Shared.FileSystem;
 using Shouldly;
 using Xunit;
-
+using Xunit.NetCore.Extensions;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
 #nullable disable
@@ -199,7 +199,6 @@ public void VerifyExistsInMemoryProjects()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyConditionsInsideOutsideTargets()
         {
             string testtargets = @"
@@ -2297,7 +2296,6 @@ public void InitialTargetsWithBlanks()
         /// or on a 32-bit machine and "c:\program files (x86)\msbuild" in a 32-bit process on a 64-bit machine.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPathDefault_Legacy()
         {
             string specialPropertyName = "MSBuildExtensionsPath";
@@ -2411,7 +2409,6 @@ public void MSBuildExtensionsPathWithEnvironmentOverride()
         /// should win over whatever MSBuild thinks the default is.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPathWithGlobalOverride()
         {
             Project project = new Project(new ProjectCollection());
@@ -2430,7 +2427,6 @@ public void MSBuildExtensionsPathWithGlobalOverride()
         /// We can't test that unless we are on a 64 bit box, but this test will work on either
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPath32Default()
         {
             // On a 64 bit machine we always want to use the program files x86.  If we are running as a 64 bit process then this variable will be set correctly
@@ -2464,7 +2460,6 @@ public void MSBuildExtensionsPath32Default()
         /// of seeing whether our value wins.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPath32WithEnvironmentOverride()
         {
             string originalMSBuildExtensionsPath32Value = Environment.GetEnvironmentVariable("MSBuildExtensionsPath32");
@@ -2488,7 +2483,6 @@ public void MSBuildExtensionsPath32WithEnvironmentOverride()
         /// of seeing whether our value wins.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPath32WithGlobalOverride()
         {
             Project project = new Project(new ProjectCollection());
@@ -2505,7 +2499,6 @@ public void MSBuildExtensionsPath32WithGlobalOverride()
         /// We can't test that unless we are on a 64 bit box, but this test will work on either
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPath64Default()
         {
             string expected = string.Empty;
@@ -2679,7 +2672,6 @@ public void MSBuildVersion()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ReservedProjectProperties()
         {
             string file = NativeMethodsShared.IsWindows ? @"c:\foo\bar.csproj" : "/foo/bar.csproj";
@@ -2717,14 +2709,9 @@ public void ReservedProjectPropertiesAtRoot()
         /// <summary>
         /// Test standard reserved properties on UNC at root
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("UNC is only available under Windows.")]
         public void ReservedProjectPropertiesOnUNCRoot()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "UNC is only available under Windows"
-            }
-
             string uncFile = @"\\foo\bar\baz.csproj";
             ProjectRootElement xml = ProjectRootElement.Create(uncFile);
             Project project = new Project(xml);
@@ -2740,14 +2727,9 @@ public void ReservedProjectPropertiesOnUNCRoot()
         /// <summary>
         /// Test standard reserved properties on UNC
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("UNC is only available under Windows.")]
         public void ReservedProjectPropertiesOnUNC()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "UNC is only available under Windows"
-            }
-
             string uncFile = @"\\foo\bar\baz\biz.csproj";
             ProjectRootElement xml = ProjectRootElement.Create(uncFile);
             Project project = new Project(xml);
@@ -2765,7 +2747,6 @@ public void ReservedProjectPropertiesOnUNC()
         /// Verify when a node count is passed through on the project collection that the correct number is used to evaluate the msbuildNodeCount
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyMsBuildNodeCountReservedProperty()
         {
             string content = ObjectModelHelpers.CleanupFileContents(@"
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 82aadfa05a2..c30721a2d59 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -32,6 +32,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared.FileSystem;
 using Shouldly;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -259,7 +260,6 @@ public void ExpandItemVectorFunctionsGetDirectoryNameOfMetadataValueDistinct()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ExpandItemVectorFunctionsItemSpecModifier()
         {
             ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
@@ -320,7 +320,6 @@ public void ExpandItemVectorFunctionsInvalid2()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ExpandItemVectorFunctionsChained1()
         {
             ProjectHelpers.CreateEmptyProjectInstance();
@@ -337,7 +336,6 @@ public void ExpandItemVectorFunctionsChained1()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ExpandItemVectorFunctionsChained2()
         {
             ProjectHelpers.CreateEmptyProjectInstance();
@@ -365,7 +363,6 @@ public void ExpandItemVectorFunctionsChained3()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ExpandItemVectorFunctionsChainedProject1()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
@@ -590,9 +587,7 @@ public void ExpandItemVectorFunctionsBuiltIn4()
             log.AssertLogContains("[foo;bar]");
         }
 
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/4363")]
+        [LongPathSupportDisabledFact(fullFrameworkOnly: true, additionalMessage: "https://github.com/dotnet/msbuild/issues/4363")]
         public void ExpandItemVectorFunctionsBuiltIn_PathTooLongError()
         {
             string content = @"
@@ -612,15 +607,9 @@ public void ExpandItemVectorFunctionsBuiltIn_PathTooLongError()
             log.AssertLogContains("MSB4198");
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Cannot have invalid characters in file name on Unix.")]
         public void ExpandItemVectorFunctionsBuiltIn_InvalidCharsError()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Cannot have invalid characters in file name on Unix"
-            }
-
             string content = @"
  <Project DefaultTargets=`t`>
 
@@ -644,7 +633,6 @@ public void ExpandItemVectorFunctionsBuiltIn_InvalidCharsError()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ExpandItemVectorFunctionsItemSpecModifier2()
         {
             ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
@@ -876,8 +864,7 @@ public void ItemIncludeContainsMultipleItemReferences()
         /// <summary>
         /// Bad path when getting metadata through ->Metadata function
         /// </summary>
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [LongPathSupportDisabledFact]
         public void InvalidPathAndMetadataItemFunctionPathTooLong()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -897,9 +884,7 @@ public void InvalidPathAndMetadataItemFunctionPathTooLong()
         /// <summary>
         /// Bad path with illegal windows chars when getting metadata through ->Metadata function
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void InvalidPathAndMetadataItemFunctionInvalidWindowsPathChars()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -938,8 +923,7 @@ public void InvalidMetadataName()
         /// <summary>
         /// Bad path when getting metadata through ->WithMetadataValue function
         /// </summary>
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [LongPathSupportDisabledFact]
         public void InvalidPathAndMetadataItemFunctionPathTooLong2()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -959,9 +943,7 @@ public void InvalidPathAndMetadataItemFunctionPathTooLong2()
         /// <summary>
         /// Bad path with illegal windows chars when getting metadata through ->WithMetadataValue function
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void InvalidPathAndMetadataItemFunctionInvalidWindowsPathChars2()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -1000,8 +982,7 @@ public void InvalidMetadataName2()
         /// <summary>
         /// Bad path when getting metadata through ->AnyHaveMetadataValue function
         /// </summary>
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [LongPathSupportDisabledFact]
         public void InvalidPathAndMetadataItemFunctionPathTooLong3()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -1021,9 +1002,7 @@ public void InvalidPathAndMetadataItemFunctionPathTooLong3()
         /// <summary>
         /// Bad path with illegal windows chars when getting metadata through ->AnyHaveMetadataValue function
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void InvalidPathAndMetadataItemInvalidWindowsPathChars3()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -1039,9 +1018,7 @@ public void InvalidPathAndMetadataItemInvalidWindowsPathChars3()
             logger.AssertLogContains("MSB4023");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void InvalidPathInDirectMetadata()
         {
             var logger = Helpers.BuildProjectContentUsingBuildManagerExpectResult(
@@ -1057,9 +1034,7 @@ public void InvalidPathInDirectMetadata()
             logger.AssertLogContains("MSB4248");
         }
 
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "new enough dotnet.exe transparently opts into long paths")]
+        [LongPathSupportDisabledFact(fullFrameworkOnly: true, additionalMessage: "new enough dotnet.exe transparently opts into long paths")]
         public void PathTooLongInDirectMetadata()
         {
             var logger = Helpers.BuildProjectContentUsingBuildManagerExpectResult(
@@ -1710,8 +1685,7 @@ public void RegistryPropertyInvalidPrefixError2()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyString()
         {
@@ -1733,8 +1707,7 @@ public void RegistryPropertyString()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyBinary()
         {
@@ -1759,8 +1732,7 @@ public void RegistryPropertyBinary()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyDWord()
         {
@@ -1782,8 +1754,7 @@ public void RegistryPropertyDWord()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyExpandString()
         {
@@ -1806,8 +1777,7 @@ public void RegistryPropertyExpandString()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyQWord()
         {
@@ -1829,8 +1799,7 @@ public void RegistryPropertyQWord()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyMultiString()
         {
@@ -1879,7 +1848,6 @@ public void TestItemSpecModiferEscaping()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestGetPathToReferenceAssembliesAsFunction()
         {
             if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) == null)
@@ -2212,7 +2180,6 @@ public void PropertyFunctionArrayReturn()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyFunctionDictionaryReturn()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
@@ -2521,8 +2488,7 @@ public void PropertyFunctionConstructor2()
         /// <summary>
         /// Expand property function that is only available when MSBUILDENABLEALLPROPERTYFUNCTIONS=1
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/coreclr/issues/15662")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "https://github.com/dotnet/coreclr/issues/15662")]
         public void PropertyStaticFunctionAllEnabled()
         {
             using (var env = TestEnvironment.Create())
@@ -3228,7 +3194,6 @@ public void PropertyFunctionValueOrDefaultFromEnvironment()
         /// Expand property function that tests for existence of the task host
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyFunctionDoesTaskHostExist()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
@@ -3245,7 +3210,6 @@ public void PropertyFunctionDoesTaskHostExist()
         /// Expand property function that tests for existence of the task host
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyFunctionDoesTaskHostExist_Whitespace()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
@@ -3301,7 +3265,6 @@ public void PropertyFunctionDoesTaskHostExist_Error()
         /// Expand property function that tests for existence of the task host
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyFunctionDoesTaskHostExist_Evaluated()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
@@ -3354,7 +3317,6 @@ public void PropertyFunctionDoesTaskHostExist_NonexistentTaskHost()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyFunctionStaticMethodFileAttributes()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
@@ -3466,8 +3428,7 @@ public void PropertySimpleSpaced()
             Assert.Equal(String.Empty, result);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValue()
         {
@@ -3491,8 +3452,7 @@ public void PropertyFunctionGetRegitryValue()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValueDefault()
         {
@@ -3516,8 +3476,7 @@ public void PropertyFunctionGetRegitryValueDefault()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView1()
         {
@@ -3541,8 +3500,7 @@ public void PropertyFunctionGetRegistryValueFromView1()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView2()
         {
diff --git a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
index b39f50cd243..4e478ab372e 100644
--- a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 
 
@@ -79,10 +80,7 @@ public void AddEntry()
         /// <summary>
         /// Tests that a strong reference is held to a single item
         /// </summary>
-        [Fact]
-        // This test fails on .NET Core and Mono: https://github.com/dotnet/msbuild/issues/282
-        [Trait("Category", "non-mono-tests")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/282")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "This test fails on .NET Core and Mono: https://github.com/dotnet/msbuild/issues/282")]
         public void AddEntryStrongReference()
         {
             string projectPath = NativeMethodsShared.IsUnixLike ? "/foo" : "c:\\foo";
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 729864e9b1c..06d4883bfed 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -80,7 +80,6 @@ public void BasicNoExistingFile()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void InvalidFile()
         {
             Assert.Throws<LoggerException>(() =>
diff --git a/src/Build.UnitTests/FixPathOnUnix_Tests.cs b/src/Build.UnitTests/FixPathOnUnix_Tests.cs
index e74cfd7b14e..f3f635df854 100644
--- a/src/Build.UnitTests/FixPathOnUnix_Tests.cs
+++ b/src/Build.UnitTests/FixPathOnUnix_Tests.cs
@@ -6,15 +6,15 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
 namespace Microsoft.Build.UnitTests
 {
-    [PlatformSpecific(TestPlatforms.AnyUnix)]
     public class FixPathOnUnixTests
     {
-        [Fact]
+        [UnixOnlyFact]
         public void TestPathFixupInMetadata()
         {
             string buildProjectContents = @"
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 78e73980389..2623dfa5e8f 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -7,11 +7,14 @@
 using System.Linq;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using ExpectedNodeBuildOutput = System.Collections.Generic.Dictionary<Microsoft.Build.Graph.ProjectGraphNode, string[]>;
+using OutputCacheDictionary = System.Collections.Generic.Dictionary<Microsoft.Build.Graph.ProjectGraphNode, string>;
 
 #nullable disable
 
@@ -146,7 +149,7 @@ public IsolateProjectsTests(ITestOutputHelper testOutput)
             _buildParametersPrototype = new BuildParameters
             {
                 EnableNodeReuse = false,
-                IsolateProjects = true,
+                ProjectIsolationMode = ProjectIsolationMode.True,
                 DisableInProcNode = disableInProcNode
             };
         }
@@ -239,7 +242,130 @@ public void IsolationRelatedMessagesShouldNotBePresentInNonIsolatedBuilds()
                     logger.AssertLogDoesntContain("MSB4260");
                 },
                 excludeReferencesFromConstraints: true,
-                isolateProjects: false);
+                isolateProjects: ProjectIsolationMode.False);
+        }
+
+        [Fact]
+        public void IsolationRelatedMessageShouldBePresentInIsolatedBuildsWithMessaging()
+        {
+            AssertBuild(
+                new[] { "BuildDeclaredReference", "BuildUndeclaredReference" },
+                (result, logger) =>
+                {
+                    result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+                    logger.ErrorCount.ShouldBe(0);
+                    logger.Errors.ShouldBeEmpty();
+
+                    // The references got built because the isolation mode is set to ProjectIsolationMode.MessageUponIsolationViolation.
+                    logger.AssertMessageCount("Message from reference", 2);
+                    logger.AllBuildEvents.OfType<ProjectStartedEventArgs>().Count().ShouldBe(3);
+
+                    logger.AssertMessageCount("MSB4260", 2);
+                },
+                isolateProjects: ProjectIsolationMode.MessageUponIsolationViolation);
+        }
+
+        [Fact]
+        public void UndeclaredReferenceBuildResultNotPresentInOutputCache()
+        {
+            // Create the graph 1 -> 2 -> 3, where 2 is a declared project reference
+            // and 3 is an undeclared project reference.
+            // 3 outputs an item UndeclaredReferenceTargetItem that 2 outputs.
+            // Run under ProjectIsolationMode.MessageUponIsolationViolation mode
+            // and verify that 3's build result is not present in 2's output results
+            // cache since, under this mode, only the results of the project
+            // to build under isolation (2) should be serialized.
+            // See CacheSerialization.SerializeCaches for more info.
+            string undeclaredReferenceFile = GraphTestingUtilities.CreateProjectFile(
+                _env,
+                3,
+                extraContent: @"
+                    <Target Name='UndeclaredReferenceTarget' Outputs='@(UndeclaredReferenceTargetItem)'>
+                        <ItemGroup>
+                            <UndeclaredReferenceTargetItem Include='Foo.cs' />
+                        </ItemGroup>
+                        <Message Text='Message from undeclared reference' Importance='High' />
+                    </Target>",
+                defaultTargets: "UndeclaredReferenceTarget").Path;
+            string declaredReferenceContents = string.Format(
+                @"
+                <Target Name='DeclaredReferenceTarget' Outputs='@(UndeclaredReferenceTargetItem)'>
+                    <MSBuild
+                        Projects='{0}'
+                        Targets='UndeclaredReferenceTarget'>
+                        <Output TaskParameter='TargetOutputs' ItemName='UndeclaredReferenceTargetItem' />
+                    </MSBuild>
+                </Target>".Cleanup(),
+                undeclaredReferenceFile).Cleanup();
+            string declaredReferenceFile = GraphTestingUtilities.CreateProjectFile(
+                _env,
+                2,
+                extraContent: declaredReferenceContents,
+                defaultTargets: "DeclaredReferenceTarget").Path;
+            string rootProjectContents = string.Format(
+                @"
+                <ItemGroup>
+                    <ProjectReference Include='{0}' />
+                </ItemGroup>
+                <Target Name='BuildDeclaredReference'>
+                    <MSBuild
+                        Projects='{1}'
+                        Targets='DeclaredReferenceTarget'
+                    />
+                </Target>".Cleanup(),
+                declaredReferenceFile,
+                declaredReferenceFile).Cleanup();
+            string rootFile = GraphTestingUtilities.CreateProjectFile(
+                _env,
+                1,
+                extraContent: rootProjectContents,
+                defaultTargets: "BuildDeclaredReference").Path;
+            var projectGraph = new ProjectGraph(
+                rootFile,
+                new Dictionary<string, string>(),
+                _env.CreateProjectCollection().Collection);
+            var expectedOutput = new ExpectedNodeBuildOutput();
+            var outputCaches = new OutputCacheDictionary();
+            ProjectGraphNode[] topoSortedProjectGraphNodes = projectGraph.ProjectNodesTopologicallySorted.ToArray();
+            Dictionary<string, (BuildResult Result, MockLogger Logger)> results = ResultCacheBasedBuilds_Tests.BuildUsingCaches(
+                _env,
+                topoSortedProjectGraphNodes,
+                expectedOutput,
+                outputCaches,
+                generateCacheFiles: true,
+                assertBuildResults: false,
+                projectIsolationMode: ProjectIsolationMode.MessageUponIsolationViolation);
+            var deserializedOutputCacheDeclaredReference = CacheSerialization.DeserializeCaches(outputCaches[topoSortedProjectGraphNodes[0]]);
+            var deserializedOutputCacheRoot = CacheSerialization.DeserializeCaches(outputCaches[topoSortedProjectGraphNodes[1]]);
+            deserializedOutputCacheDeclaredReference.exception.ShouldBeNull();
+            deserializedOutputCacheRoot.exception.ShouldBeNull();
+            BuildResult[] declaredReferenceBuildResults = deserializedOutputCacheDeclaredReference.ResultsCache.GetEnumerator().ToArray();
+            BuildResult[] rootBuildResults = deserializedOutputCacheRoot.ResultsCache.GetEnumerator().ToArray();
+
+            // Both the root and declared reference projects should only have one build result.
+            declaredReferenceBuildResults.Length.ShouldBe(1);
+            rootBuildResults.Length.ShouldBe(1);
+            declaredReferenceBuildResults[0].OverallResult.ShouldBe(BuildResultCode.Success);
+            rootBuildResults[0].OverallResult.ShouldBe(BuildResultCode.Success);
+            MockLogger rootLogger = results["1"].Logger;
+            MockLogger declaredReferenceLogger = results["2"].Logger;
+            rootLogger.ErrorCount.ShouldBe(0);
+            declaredReferenceLogger.ErrorCount.ShouldBe(0);
+            rootLogger.Errors.ShouldBeEmpty();
+            declaredReferenceLogger.Errors.ShouldBeEmpty();
+            rootLogger.AllBuildEvents.OfType<ProjectStartedEventArgs>().Count().ShouldBe(2);
+            declaredReferenceLogger.AllBuildEvents.OfType<ProjectStartedEventArgs>().Count().ShouldBe(2);
+
+            // One undeclared reference was built in isolation violation.
+            declaredReferenceLogger.AssertMessageCount("Message from undeclared reference", 1);
+            declaredReferenceLogger.AssertMessageCount("MSB4260", 1);
+
+            // The declared reference project's output item is that of the undeclared reference
+            // project.
+            declaredReferenceBuildResults[0]["DeclaredReferenceTarget"].Items.Length.ShouldBe(1);
+            declaredReferenceBuildResults[0]["DeclaredReferenceTarget"].Items[0].ItemSpec.ShouldBe("Foo.cs");
+            rootBuildResults[0]["BuildDeclaredReference"].Items.Length.ShouldBe(0);
         }
 
         [Theory]
@@ -385,7 +511,7 @@ private void AssertBuild(
             bool buildUndeclaredReference = false,
             bool addContinueOnError = false,
             bool excludeReferencesFromConstraints = false,
-            bool isolateProjects = true,
+            ProjectIsolationMode isolateProjects = ProjectIsolationMode.True,
             Func<string, string> projectReferenceModifier = null,
             Func<string, string> msbuildOnDeclaredReferenceModifier = null)
         {
@@ -411,7 +537,7 @@ private void AssertBuild(
             File.WriteAllText(undeclaredReferenceFile, _undeclaredReference);
 
             var buildParameters = _buildParametersPrototype.Clone();
-            buildParameters.IsolateProjects = isolateProjects;
+            buildParameters.ProjectIsolationMode = isolateProjects;
 
             using (var buildManagerSession = new Helpers.BuildManagerSession(_env, buildParameters))
             {
@@ -474,7 +600,7 @@ public void SkippedTargetsShouldNotTriggerCacheMissEnforcement()
 </Project>
 ".Cleanup()).Path;
 
-            _buildParametersPrototype.IsolateProjects.ShouldBeTrue();
+            _buildParametersPrototype.ProjectIsolationMode.ShouldBe(ProjectIsolationMode.True);
             var buildParameters = _buildParametersPrototype.Clone();
 
             using (var buildManagerSession = new Helpers.BuildManagerSession(_env, buildParameters))
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index 4f46ed838d4..65ab4706791 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -410,7 +410,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
         /// When it is false, it uses the filled in <param name="outputCaches"/> and <param name="expectedNodeBuildOutput"/> to simulate a fully cached build.
         /// 
         /// </summary>
-        /// <param name="env">The test environment.</param>
+        /// <param name="env">The test environment under which to run.</param>
         /// <param name="topoSortedNodes"></param>
         /// <param name="expectedNodeBuildOutput"></param>
         /// <param name="outputCaches"></param>
@@ -418,6 +418,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
         /// <param name="assertBuildResults"></param>
         /// <param name="expectedOutputProducer"></param>
         /// <param name="targetListsPerNode">The list of targets to build per node.</param>
+        /// <param name="projectIsolationMode">The isolation mode under which to run.</param>
         /// <returns></returns>
         internal static Dictionary<string, (BuildResult Result, MockLogger Logger)> BuildUsingCaches(
             TestEnvironment env,
@@ -428,7 +429,8 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
             bool assertBuildResults = true,
             // (current node, expected output dictionary) -> actual expected output for current node
             Func<ProjectGraphNode, ExpectedNodeBuildOutput, string[]> expectedOutputProducer = null,
-            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetListsPerNode = null)
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetListsPerNode = null,
+            ProjectIsolationMode projectIsolationMode = ProjectIsolationMode.False)
         {
             expectedOutputProducer ??= ((node, expectedOutputs) => expectedOutputs[node]);
 
@@ -451,7 +453,8 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
 
                 var buildParameters = new BuildParameters
                 {
-                    InputResultsCacheFiles = cacheFilesForReferences
+                    InputResultsCacheFiles = cacheFilesForReferences,
+                    ProjectIsolationMode = projectIsolationMode,
                 };
 
                 if (generateCacheFiles)
@@ -468,7 +471,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
                     node.ProjectInstance.FullPath,
                     null,
                     buildParameters,
-                    targetListsPerNode?[node].ToArray());
+                    targetListsPerNode?[node] != null ? targetListsPerNode?[node] : node.ProjectInstance.DefaultTargets);
 
                 results[ProjectNumber(node)] = (result, logger);
 
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index 3a9ebdb07c2..cab5c0b40e1 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.UnitTests.BackEnd;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -241,8 +242,7 @@ public void TestContradictoryAffinityCausesException_Any()
         /// <summary>
         /// Test which ensures that setting an Any affinity for a project with a remote host object does not throws.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestNoContradictoryRemoteHostObjectAffinity()
         {
@@ -295,8 +295,7 @@ public void TestNonContraditcoryHostObjectAllowed_Any()
         /// <summary>
         /// Test which ensures the remote host object cannot affect a project which has the Any affinity specifically set.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestRegisterRemoteHostObjectNoAffect_Any2()
         {
@@ -334,8 +333,7 @@ public void TestNonContraditcoryHostObjectAllowed_InProc()
         /// <summary>
         /// Test which ensures the affinity for a project can be changed once the in process host object is registered
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestAffinityChangeAfterRegisterInprocessHostObject()
         {
@@ -444,8 +442,7 @@ public void UnloadedProjectDiscardsHostServices()
         /// <summary>
         /// Tests that register overrides existing reigsted remote host object.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestRegisterOverrideExistingRegisted()
         {
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index a12c2382a58..546c42c9432 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -340,7 +340,6 @@ public void GetSubToolsetVersion()
         /// environment
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetSubToolsetVersion_FromEnvironment()
         {
             string originalVisualStudioVersion = Environment.GetEnvironmentVariable("VisualStudioVersion");
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index d017ffbe1cc..05d920b732b 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -76,6 +76,7 @@
     <Compile Include="..\Shared\UnitTests\ResourceUtilities_Tests.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -118,6 +119,9 @@
     <Compile Include="..\Shared\UnitTests\ImmutableDictionary_Tests.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' == 'Full' and '$(MonoBuild)' != 'true'">
       <Link>Collections\ImmutableDictionary_Tests.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\UnitTests\LongPathSupportDisabledFactAttribute.cs">
+      <Link>Shared\LongPathSupportDisabledFactAttribute.cs</Link>
+    </Compile>
 
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 1aaf405007d..0c828f621ff 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -525,9 +525,14 @@ public void BeginBuild(BuildParameters parameters)
                 // Initialize additional build parameters.
                 _buildParameters.BuildId = GetNextBuildId();
 
-                if (_buildParameters.UsesCachedResults())
+                if (_buildParameters.UsesCachedResults() && parameters.ProjectIsolationMode == ProjectIsolationMode.False)
                 {
-                    _buildParameters.IsolateProjects = true;
+                    // If input or output caches are used and the project isolation mode is set to
+                    // ProjectIsolationMode.False, then set it to ProjectIsolationMode.True. The explicit
+                    // condition on ProjectIsolationMode is necessary to ensure that, if we're using input
+                    // or output caches and ProjectIsolationMode is set to ProjectIsolationMode.MessageUponIsolationViolation,
+                    // ProjectIsolationMode isn't changed to ProjectIsolationMode.True.
+                    _buildParameters.ProjectIsolationMode = ProjectIsolationMode.True;
                 }
 
                 if (_buildParameters.UsesOutputCache() && string.IsNullOrWhiteSpace(_buildParameters.OutputResultsCacheFile))
@@ -1053,8 +1058,11 @@ public void EndBuild()
 
             void SerializeCaches()
             {
-                var errorMessage = CacheSerialization.SerializeCaches(_configCache, _resultsCache, _buildParameters.OutputResultsCacheFile);
-
+                string errorMessage = CacheSerialization.SerializeCaches(
+                    _configCache,
+                    _resultsCache,
+                    _buildParameters.OutputResultsCacheFile,
+                    _buildParameters.ProjectIsolationMode);
                 if (!string.IsNullOrEmpty(errorMessage))
                 {
                     LogErrorAndShutdown(errorMessage);
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index a91ec457ef8..459814decca 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -212,7 +212,7 @@ public class BuildParameters : ITranslatable
 
         private bool _interactive;
 
-        private bool _isolateProjects;
+        private ProjectIsolationMode _projectIsolationMode;
 
         private string[] _inputResultsCacheFiles;
 
@@ -298,7 +298,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             WarningsAsMessages = other.WarningsAsMessages == null ? null : new HashSet<string>(other.WarningsAsMessages, StringComparer.OrdinalIgnoreCase);
             _projectLoadSettings = other._projectLoadSettings;
             _interactive = other._interactive;
-            _isolateProjects = other._isolateProjects;
+            _projectIsolationMode = other.ProjectIsolationMode;
             _inputResultsCacheFiles = other._inputResultsCacheFiles;
             _outputResultsCacheFile = other._outputResultsCacheFile;
             DiscardBuildResults = other.DiscardBuildResults;
@@ -760,17 +760,26 @@ public bool Interactive
         }
 
         /// <summary>
-        /// Gets or sets a value indicating whether projects should build in isolation.
+        /// Gets or sets a value indicating the isolation mode to use.
         /// </summary>
+        /// <remarks>
+        /// Kept for API backwards compatibility.
+        /// </remarks>
         public bool IsolateProjects
         {
-            get => _isolateProjects;
-            set => _isolateProjects = value;
+            get => ProjectIsolationMode == ProjectIsolationMode.True;
+            set => ProjectIsolationMode = value ? ProjectIsolationMode.True : ProjectIsolationMode.False;
         }
 
+        /// <summary>
+        /// Gets or sets a value indicating the isolation mode to use.
+        /// </summary>
+        public ProjectIsolationMode ProjectIsolationMode { get => _projectIsolationMode; set => _projectIsolationMode = value; }
+
         /// <summary>
         /// Input cache files that MSBuild will use to read build results from.
-        /// Setting this also turns on isolated builds.
+        /// If the isolation mode is set to <see cref="ProjectIsolationMode.False"/>,
+        /// this sets the isolation mode to <see cref="ProjectIsolationMode.True"/>.
         /// </summary>
         public string[] InputResultsCacheFiles
         {
@@ -780,7 +789,8 @@ public string[] InputResultsCacheFiles
 
         /// <summary>
         /// Output cache file where MSBuild will write the contents of its build result caches during EndBuild.
-        /// Setting this also turns on isolated builds.
+        /// If the isolation mode is set to <see cref="ProjectIsolationMode.False"/>,
+        /// this sets the isolation mode to <see cref="ProjectIsolationMode.True"/>.
         /// </summary>
         public string OutputResultsCacheFile
         {
@@ -828,7 +838,7 @@ public BuildParameters Clone()
 
         internal bool UsesInputCaches() => InputResultsCacheFiles != null;
 
-        internal bool SkippedResultsDoNotCauseCacheMiss() => IsolateProjects;
+        internal bool SkippedResultsDoNotCauseCacheMiss() => ProjectIsolationMode == ProjectIsolationMode.True;
 
         /// <summary>
         /// Implementation of the serialization mechanism.
@@ -861,7 +871,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _logInitialPropertiesAndItems);
             translator.TranslateEnum(ref _projectLoadSettings, (int)_projectLoadSettings);
             translator.Translate(ref _interactive);
-            translator.Translate(ref _isolateProjects);
+            translator.TranslateEnum(ref _projectIsolationMode, (int)_projectIsolationMode);
 
             // ProjectRootElementCache is not transmitted.
             // ResetCaches is not transmitted.
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index d1864fef845..3fa59bfe28b 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -13,7 +13,11 @@ namespace Microsoft.Build.Execution
 {
     internal static class CacheSerialization
     {
-        public static string SerializeCaches(IConfigCache configCache, IResultsCache resultsCache, string outputCacheFile)
+        public static string SerializeCaches(
+            IConfigCache configCache,
+            IResultsCache resultsCache,
+            string outputCacheFile,
+            ProjectIsolationMode projectIsolationMode)
         {
             ErrorUtilities.VerifyThrowInternalNull(outputCacheFile, nameof(outputCacheFile));
 
@@ -83,6 +87,19 @@ public static string SerializeCaches(IConfigCache configCache, IResultsCache res
                         resultsCacheToSerialize = tempResultsCacheToSerialize;
                     }
 
+                    if (projectIsolationMode == ProjectIsolationMode.MessageUponIsolationViolation)
+                    {
+                        int smallestConfigId = configCacheToSerialize.GetSmallestConfigId();
+
+                        // In MessageUponIsolationViolation mode, only keep the TargetResults for
+                        // top-level targets to mitigate the chances of an isolation-
+                        // violating target on a dependency project using incorrect state
+                        // due to its dependency on a cached target whose side effects would
+                        // not be taken into account. (E.g., the definition of a property.)
+                        resultsCacheToSerialize.GetResultsForConfiguration(smallestConfigId)
+                            .KeepSpecificTargetResults(configCacheToSerialize[smallestConfigId].RequestedTargets);
+                    }
+
                     translator.Translate(ref configCacheToSerialize);
                     translator.Translate(ref resultsCacheToSerialize);
                 }
diff --git a/src/Build/BackEnd/BuildManager/ProjectIsolationMode.cs b/src/Build/BackEnd/BuildManager/ProjectIsolationMode.cs
new file mode 100644
index 00000000000..31d5273b51b
--- /dev/null
+++ b/src/Build/BackEnd/BuildManager/ProjectIsolationMode.cs
@@ -0,0 +1,34 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// The isolation mode to use.
+    /// </summary>
+    public enum ProjectIsolationMode
+    {
+        /// <summary>
+        /// Do not enable isolation.
+        /// </summary>
+        False,
+
+        /// <summary>
+        /// Enable isolation and log isolation violations as messages.
+        /// </summary>
+        /// <remarks>
+        /// Under this mode, only the results from top-level targets
+        /// are serialized if the -orc switch is supplied to mitigate
+        /// the chances of an isolation-violating target on a
+        /// dependency project using incorrect state due to its
+        /// dependency on a cached target whose side effects would
+        /// not be taken into account. (E.g., the definition of a property.)
+        /// </remarks>
+        MessageUponIsolationViolation,
+
+        /// <summary>
+        /// Enable isolation and log isolation violations as errors.
+        /// </summary>
+        True,
+    }
+}
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs b/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs
index ce4d7e531a0..a0dcaa0c89f 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs
@@ -50,7 +50,7 @@ public BuildRequestConfiguration this[int configId]
         {
             get
             {
-                if (_override.HasConfiguration(configId))
+                if (HasConfigurationInOverrideCache(configId))
                 {
 #if DEBUG
                     ErrorUtilities.VerifyThrow(!CurrentCache.HasConfiguration(configId), "caches should not overlap");
@@ -115,7 +115,7 @@ public BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata
 
         public bool HasConfiguration(int configId)
         {
-            var overrideHasConfiguration = _override.HasConfiguration(configId);
+            bool overrideHasConfiguration = HasConfigurationInOverrideCache(configId);
 
             if (overrideHasConfiguration)
             {
@@ -125,7 +125,12 @@ public bool HasConfiguration(int configId)
                 return overrideHasConfiguration;
             }
 
-            return _override.HasConfiguration(configId) || CurrentCache.HasConfiguration(configId);
+            return overrideHasConfiguration || CurrentCache.HasConfiguration(configId);
+        }
+
+        public bool HasConfigurationInOverrideCache(int configId)
+        {
+            return _override.HasConfiguration(configId);
         }
 
         public void ClearConfigurations()
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 607e0f576e4..5e2cac8e282 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -362,12 +362,14 @@ public async Task<BuildResult[]> BuildProjects(string[] projectFiles, PropertyDi
                 BuildRequestData data = new BuildRequestData(projectFiles[i], properties[i].ToDictionary(), explicitToolsVersion, targets, null);
 
                 BuildRequestConfiguration config = new BuildRequestConfiguration(data, _componentHost.BuildParameters.DefaultToolsVersion);
-
+                ProjectIsolationMode isolateProjects = _componentHost.BuildParameters.ProjectIsolationMode;
+                bool skipStaticGraphIsolationConstraints = (isolateProjects != ProjectIsolationMode.False && _requestEntry.RequestConfiguration.ShouldSkipIsolationConstraintsForReference(config.ProjectFullPath))
+                    || isolateProjects == ProjectIsolationMode.MessageUponIsolationViolation;
                 requests[i] = new FullyQualifiedBuildRequest(
                     config: config,
                     targets: targets,
                     resultsNeeded: waitForResults,
-                    skipStaticGraphIsolationConstraints: _componentHost.BuildParameters.IsolateProjects && _requestEntry.RequestConfiguration.ShouldSkipIsolationConstraintsForReference(config.ProjectFullPath),
+                    skipStaticGraphIsolationConstraints: skipStaticGraphIsolationConstraints,
                     flags: skipNonexistentTargets
                         ? BuildRequestDataFlags.SkipNonexistentTargets
                         : BuildRequestDataFlags.None);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 2fbe1580634..f90ce5d8024 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -1024,7 +1024,8 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
 
         private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
         {
-            if (!_componentHost.BuildParameters.IsolateProjects)
+            ProjectIsolationMode isolateProjects = _componentHost.BuildParameters.ProjectIsolationMode;
+            if (isolateProjects == ProjectIsolationMode.False || isolateProjects == ProjectIsolationMode.MessageUponIsolationViolation)
             {
                 return null;
             }
@@ -1051,11 +1052,7 @@ private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
                     !(declaredProjects.Contains(normalizedMSBuildProject)
                       || _buildRequestEntry.RequestConfiguration.ShouldSkipIsolationConstraintsForReference(normalizedMSBuildProject)))
                 {
-                    if (undeclaredProjects == null)
-                    {
-                        undeclaredProjects = new List<string>(projectReferenceItems.Count);
-                    }
-
+                    undeclaredProjects ??= new List<string>(projectReferenceItems.Count);
                     undeclaredProjects.Add(normalizedMSBuildProject);
                 }
             }
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 9f2049d598c..0c11f731cb5 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -364,9 +364,7 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
             _schedulingData.EventTime = DateTime.UtcNow;
             List<ScheduleResponse> responses = new List<ScheduleResponse>();
             TraceScheduler("Reporting result from node {0} for request {1}, parent {2}.", nodeId, result.GlobalRequestId, result.ParentGlobalRequestId);
-
-            // Record these results to the cache.
-            _resultsCache.AddResult(result);
+            RecordResultToCurrentCacheIfConfigNotInOverrideCache(result);
 
             if (result.NodeRequestId == BuildRequest.ResultsTransferNodeRequestId)
             {
@@ -1961,14 +1959,15 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF
         {
             emitNonErrorLogs = _ => { };
 
-            var isIsolatedBuild = _componentHost.BuildParameters.IsolateProjects;
+            ProjectIsolationMode isolateProjects = _componentHost.BuildParameters.ProjectIsolationMode;
             var configCache = (IConfigCache)_componentHost.GetComponent(BuildComponentType.ConfigCache);
 
             // do not check root requests as nothing depends on them
-            if (!isIsolatedBuild || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints
+            if (isolateProjects == ProjectIsolationMode.False || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints
                 || SkipNonexistentTargetsIfExistentTargetsHaveResults(request))
             {
-                if (isIsolatedBuild && request.SkipStaticGraphIsolationConstraints)
+                bool logComment = ((isolateProjects == ProjectIsolationMode.True || isolateProjects == ProjectIsolationMode.MessageUponIsolationViolation) && request.SkipStaticGraphIsolationConstraints);
+                if (logComment)
                 {
                     // retrieving the configs is not quite free, so avoid computing them eagerly
                     var configs = GetConfigurations();
@@ -2080,6 +2079,23 @@ bool SkipNonexistentTargetsIfExistentTargetsHaveResults(BuildRequest buildReques
             }
         }
 
+        /// <summary>
+        /// Records the result to the current cache if its config isn't in the override cache.
+        /// </summary>
+        /// <param name="result">The result to potentially record in the current cache.</param>
+        internal void RecordResultToCurrentCacheIfConfigNotInOverrideCache(BuildResult result)
+        {
+            // Record these results to the current cache only if their config isn't in the
+            // override cache, which can happen if we are building in the project isolation mode
+            // ProjectIsolationMode.MessageUponIsolationViolation, and the received result was built by an
+            // isolation-violating dependency project.
+            if (_configCache is not ConfigCacheWithOverride configCacheWithOverride
+                || !configCacheWithOverride.HasConfigurationInOverrideCache(result.ConfigurationId))
+            {
+                _resultsCache.AddResult(result);
+            }
+        }
+
         /// <summary>
         /// Gets the appropriate ScheduleResponse for a result, either to complete a submission or to report to a node.
         /// </summary>
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 906d12d347d..ca443451880 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -5,6 +5,7 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -495,6 +496,25 @@ public void AddResultsForTarget(string target, TargetResult result)
             _resultsByTarget[target] = result;
         }
 
+        /// <summary>
+        /// Keep the results only for targets in <paramref name="targetsToKeep"/>.
+        /// </summary>
+        /// <param name="targetsToKeep">The targets whose results to keep.</param>
+        internal void KeepSpecificTargetResults(IReadOnlyCollection<string> targetsToKeep)
+        {
+            ErrorUtilities.VerifyThrow(
+                targetsToKeep.Count > 0,
+                $"{nameof(targetsToKeep)} should contain at least one target.");
+
+            foreach (string target in _resultsByTarget.Keys)
+            {
+                if (!targetsToKeep.Contains(target))
+                {
+                    _ = _resultsByTarget.TryRemove(target, out _);
+                }
+            }
+        }
+
         /// <summary>
         /// Merges the specified results with the results contained herein.
         /// </summary>
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 389f8c6459b..eed1d5872a3 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -152,7 +152,8 @@ internal TaskExecutionHost(IBuildComponentHost host)
         }
 
         /// <summary>
-        /// Constructor, for unit testing only.  
+        /// Initializes a new instance of the <see cref="TaskExecutionHost"/> class
+        /// for unit testing only.
         /// </summary>
         internal TaskExecutionHost()
         {
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 35780421fb1..fe944b6e87f 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -65,6 +65,7 @@ public sealed class BinaryLogger : ILogger
         private ProjectImportsCollector projectImportsCollector;
         private string _initialTargetOutputLogging;
         private bool _initialLogImports;
+        private string _initialIsBinaryLoggerEnabled;
 
         /// <summary>
         /// Describes whether to collect the project files (including imported project files) used during the build.
@@ -114,9 +115,12 @@ public void Initialize(IEventSource eventSource)
         {
             _initialTargetOutputLogging = Environment.GetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING");
             _initialLogImports = Traits.Instance.EscapeHatches.LogProjectImports;
+            _initialIsBinaryLoggerEnabled = Environment.GetEnvironmentVariable("MSBUILDBINARYLOGGERENABLED");
 
             Environment.SetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING", "true");
             Environment.SetEnvironmentVariable("MSBUILDLOGIMPORTS", "1");
+            Environment.SetEnvironmentVariable("MSBUILDBINARYLOGGERENABLED", bool.TrueString);
+
             Traits.Instance.EscapeHatches.LogProjectImports = true;
             bool logPropertiesAndItemsAfterEvaluation = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
 
@@ -214,6 +218,8 @@ public void Shutdown()
         {
             Environment.SetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING", _initialTargetOutputLogging);
             Environment.SetEnvironmentVariable("MSBUILDLOGIMPORTS", _initialLogImports ? "1" : "");
+            Environment.SetEnvironmentVariable("MSBUILDBINARYLOGGERENABLED", _initialIsBinaryLoggerEnabled);
+
             Traits.Instance.EscapeHatches.LogProjectImports = _initialLogImports;
 
             if (projectImportsCollector != null)
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 6e13af19356..f2bd969073c 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -148,6 +148,7 @@
     <Compile Include="BackEnd\BuildManager\BuildParameters.cs" />
     <Compile Include="BackEnd\BuildManager\CacheSerialization.cs" />
     <Compile Include="BackEnd\BuildManager\CacheAggregator.cs" />
+    <Compile Include="BackEnd\BuildManager\ProjectIsolationMode.cs" />
     <Compile Include="BackEnd\Client\MSBuildClientPacketPump.cs" />
     <Compile Include="BackEnd\Client\MSBuildClientExitType.cs" />
     <Compile Include="BackEnd\Client\MSBuildClientExitResult.cs" />
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index b5bdead5c07..bdf84b30922 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -195,6 +195,21 @@ internal enum ProcessorArchitectures
         // ARM64
         ARM64,
 
+        // WebAssembly
+        WASM,
+
+        // S390x
+        S390X,
+
+        // LongAarch64
+        LOONGARCH64,
+
+        // 32-bit ARMv6
+        ARMV6,
+
+        // PowerPC 64-bit (little-endian) 
+        PPC64LE,
+
         // Who knows
         Unknown
     }
@@ -435,7 +450,8 @@ public SystemInformationData()
             else
             {
                 ProcessorArchitectures processorArchitecture = ProcessorArchitectures.Unknown;
-#if !NET35
+
+#if NETCOREAPP || NETSTANDARD1_1_OR_GREATER
                 // Get the architecture from the runtime.
                 processorArchitecture = RuntimeInformation.OSArchitecture switch
                 {
@@ -443,64 +459,21 @@ public SystemInformationData()
                     Architecture.Arm64 => ProcessorArchitectures.ARM64,
                     Architecture.X64 => ProcessorArchitectures.X64,
                     Architecture.X86 => ProcessorArchitectures.X86,
+#if NET5_0_OR_GREATER
+                    Architecture.Wasm => ProcessorArchitectures.WASM,
+#endif
+#if NET6_0_OR_GREATER
+                    Architecture.S390x => ProcessorArchitectures.S390X,
+#endif
+#if NET7_0_OR_GREATER
+                    Architecture.LoongArch64 => ProcessorArchitectures.LOONGARCH64,
+                    Architecture.Armv6 => ProcessorArchitectures.ARMV6,
+                    Architecture.Ppc64le => ProcessorArchitectures.PPC64LE,
+#endif
                     _ => ProcessorArchitectures.Unknown,
                 };
-#endif
-                // Fall back to 'uname -m' to get the architecture.
-                if (processorArchitecture == ProcessorArchitectures.Unknown)
-                {
-                    try
-                    {
-                        // On Unix run 'uname -m' to get the architecture. It's common for Linux and Mac
-                        using (
-                            var proc =
-                                Process.Start(
-                                    new ProcessStartInfo("uname")
-                                    {
-                                        Arguments = "-m",
-                                        UseShellExecute = false,
-                                        RedirectStandardOutput = true,
-                                        CreateNoWindow = true
-                                    }))
-                        {
-                            string arch = null;
-                            if (proc != null)
-                            {
-                                arch = proc.StandardOutput.ReadLine();
-                                proc.WaitForExit();
-                            }
 
-                            if (!string.IsNullOrEmpty(arch))
-                            {
-                                if (arch.StartsWith("x86_64", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.X64;
-                                }
-                                else if (arch.StartsWith("ia64", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.IA64;
-                                }
-                                else if (arch.StartsWith("arm", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.ARM;
-                                }
-                                else if (arch.StartsWith("aarch64", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.ARM64;
-                                }
-                                else if (arch.StartsWith("i", StringComparison.OrdinalIgnoreCase)
-                                        && arch.EndsWith("86", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.X86;
-                                }
-                            }
-                        }
-                    }
-                    catch
-                    {
-                        // Best effort: fall back to Unknown
-                    }
-                }
+#endif
 
                 ProcessorArchitectureTypeNative = ProcessorArchitectureType = processorArchitecture;
             }
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index e3233cff927..ca52d2e3156 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -10,11 +10,13 @@
 using System.Resources;
 using Microsoft.Build.CommandLine;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -1018,7 +1020,7 @@ public void InvalidToolsVersionErrors()
                                         profilerLogger: null,
                                         enableProfiler: false,
                                         interactive: false,
-                                        isolateProjects: false,
+                                        isolateProjects: ProjectIsolationMode.False,
                                         graphBuildOptions: null,
                                         lowPriority: false,
                                         inputResultsCaches: null,
@@ -1345,8 +1347,7 @@ public void ProcessGraphBuildSwitch(string[] parameters, GraphBuildOptions expec
         /// Verifies that when the /profileevaluation switch is used with invalid filenames an error is shown.
         /// </summary>
         [MemberData(nameof(GetInvalidFilenames))]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
-        [Theory]
+        [WindowsFullFrameworkOnlyTheory(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void ProcessProfileEvaluationInvalidFilename(string filename)
         {
             bool enableProfiler = false;
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index ea90a86c84e..61f2c68c312 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -42,6 +42,7 @@
     <Compile Include="..\Shared\UnitTests\MockEngine.cs" />
     <Compile Include="..\Shared\UnitTests\MockLogger.cs" />
     <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs" />
+    <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
     <EmbeddedResource Include="..\MSBuild\MSBuild\Microsoft.Build.Core.xsd">
diff --git a/src/MSBuild.UnitTests/PerfLog_Tests.cs b/src/MSBuild.UnitTests/PerfLog_Tests.cs
index 0f747122ec8..9927e43e78c 100644
--- a/src/MSBuild.UnitTests/PerfLog_Tests.cs
+++ b/src/MSBuild.UnitTests/PerfLog_Tests.cs
@@ -22,7 +22,6 @@ public PerfLogTests(ITestOutputHelper output)
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")] // Disable on Mono OSX, since Mono doesn't implement EventSource.
         public void TestPerfLogEnabledProducedLogFile()
         {
             using (TestEnvironment testEnv = TestEnvironment.Create(_output))
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index c9785c3b3fe..9a7d968a673 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -47,7 +47,7 @@ internal enum ParameterlessSwitch
             FileLogger8,
             FileLogger9,
             DistributedFileLogger,
-            FancyLogger,
+            LiveLogger,
 #if DEBUG
             WaitForDebugger,
 #endif
@@ -201,25 +201,25 @@ internal ParameterizedSwitchInfo(
             //---------------------------------------------------------------------------------------------------------------------------------------------------
             //                                          Switch Names                        Switch Id                             Dup Error  Light up key
             //---------------------------------------------------------------------------------------------------------------------------------------------------
-            new ParameterlessSwitchInfo(  new string[] { "help", "h", "?" },                ParameterlessSwitch.Help,                  null),
-            new ParameterlessSwitchInfo(  new string[] { "version", "ver" },                ParameterlessSwitch.Version,               null),
-            new ParameterlessSwitchInfo(  new string[] { "nologo" },                        ParameterlessSwitch.NoLogo,                null),
-            new ParameterlessSwitchInfo(  new string[] { "noautoresponse", "noautorsp" },   ParameterlessSwitch.NoAutoResponse,        null),
-            new ParameterlessSwitchInfo(  new string[] { "noconsolelogger", "noconlog" },   ParameterlessSwitch.NoConsoleLogger,       null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger", "fl" },              ParameterlessSwitch.FileLogger,            null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger1", "fl1" },            ParameterlessSwitch.FileLogger1,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger2", "fl2" },            ParameterlessSwitch.FileLogger2,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger3", "fl3" },            ParameterlessSwitch.FileLogger3,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger4", "fl4" },            ParameterlessSwitch.FileLogger4,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger5", "fl5" },            ParameterlessSwitch.FileLogger5,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger6", "fl6" },            ParameterlessSwitch.FileLogger6,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger7", "fl7" },            ParameterlessSwitch.FileLogger7,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },            ParameterlessSwitch.FileLogger8,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },            ParameterlessSwitch.FileLogger9,           null),
-            new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },  ParameterlessSwitch.DistributedFileLogger, null),
-            new ParameterlessSwitchInfo(  new string[] { "fancylogger", "flg" },            ParameterlessSwitch.FancyLogger,           null),
+            new ParameterlessSwitchInfo(  new string[] { "help", "h", "?" },                         ParameterlessSwitch.Help,                  null),
+            new ParameterlessSwitchInfo(  new string[] { "version", "ver" },                         ParameterlessSwitch.Version,               null),
+            new ParameterlessSwitchInfo(  new string[] { "nologo" },                                 ParameterlessSwitch.NoLogo,                null),
+            new ParameterlessSwitchInfo(  new string[] { "noautoresponse", "noautorsp" },            ParameterlessSwitch.NoAutoResponse,        null),
+            new ParameterlessSwitchInfo(  new string[] { "noconsolelogger", "noconlog" },            ParameterlessSwitch.NoConsoleLogger,       null),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger", "fl" },                       ParameterlessSwitch.FileLogger,            null),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger1", "fl1" },                     ParameterlessSwitch.FileLogger1,           null),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger2", "fl2" },                     ParameterlessSwitch.FileLogger2,           null),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger3", "fl3" },                     ParameterlessSwitch.FileLogger3,           null),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger4", "fl4" },                     ParameterlessSwitch.FileLogger4,           null),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger5", "fl5" },                     ParameterlessSwitch.FileLogger5,           null),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger6", "fl6" },                     ParameterlessSwitch.FileLogger6,           null),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger7", "fl7" },                     ParameterlessSwitch.FileLogger7,           null),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },                     ParameterlessSwitch.FileLogger8,           null),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },                     ParameterlessSwitch.FileLogger9,           null),
+            new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },           ParameterlessSwitch.DistributedFileLogger, null),
+            new ParameterlessSwitchInfo(  new string[] { "livelogger", "ll", "fancylogger", "flg" }, ParameterlessSwitch.LiveLogger,            null),
 #if DEBUG
-            new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },        ParameterlessSwitch.WaitForDebugger,       null),
+            new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },                 ParameterlessSwitch.WaitForDebugger,       null),
 #endif
         };
 
diff --git a/src/MSBuild/FancyLogger/ANSIBuilder.cs b/src/MSBuild/LiveLogger/ANSIBuilder.cs
similarity index 99%
rename from src/MSBuild/FancyLogger/ANSIBuilder.cs
rename to src/MSBuild/LiveLogger/ANSIBuilder.cs
index b735859d666..b34ae90bc33 100644
--- a/src/MSBuild/FancyLogger/ANSIBuilder.cs
+++ b/src/MSBuild/LiveLogger/ANSIBuilder.cs
@@ -5,12 +5,12 @@
 using System.Collections.Generic;
 using System.Text.RegularExpressions;
 
-namespace Microsoft.Build.Logging.FancyLogger
+namespace Microsoft.Build.Logging.LiveLogger
 {
     internal static class ANSIBuilder
     {
         public static string ANSIRegex = @"\x1b(?:[@-Z\-_]|\[[0-?]*[ -\/]*[@-~])";
-        // TODO: This should replace ANSIRegex once FancyLogger's API is internal
+        // TODO: This should replace ANSIRegex once LiveLogger's API is internal
         public static Regex ANSIRegexRegex = new Regex(ANSIRegex);
         public static string ANSIRemove(string text)
         {
diff --git a/src/MSBuild/FancyLogger/FancyLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
similarity index 80%
rename from src/MSBuild/FancyLogger/FancyLogger.cs
rename to src/MSBuild/LiveLogger/LiveLogger.cs
index 28008e2699b..80504c45443 100644
--- a/src/MSBuild/FancyLogger/FancyLogger.cs
+++ b/src/MSBuild/LiveLogger/LiveLogger.cs
@@ -6,22 +6,19 @@
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.Logging.FancyLogger
+namespace Microsoft.Build.Logging.LiveLogger
 {
-    internal class FancyLogger : ILogger
+    internal class LiveLogger : ILogger
     {
-        private Dictionary<int, FancyLoggerProjectNode> projects = new Dictionary<int, FancyLoggerProjectNode>();
+        private Dictionary<int, ProjectNode> projects = new Dictionary<int, ProjectNode>();
 
         private bool Succeeded;
-
-        private float existingTasks = 1;
-        private float completedTasks = 0;
-
         public string Parameters { get; set; }
-
+        public int StartedProjects = 0;
+        public int FinishedProjects = 0;
         public LoggerVerbosity Verbosity { get; set; }
 
-        public FancyLogger()
+        public LiveLogger()
         {
             Parameters = "";
         }
@@ -54,15 +51,15 @@ public void Initialize(IEventSource eventSource)
 
         private void Render()
         {
-            // Initialize FancyLoggerBuffer
-            FancyLoggerBuffer.Initialize();
+            // Initialize LiveLoggerBuffer
+            TerminalBuffer.Initialize();
             // TODO: Fix. First line does not appear at top. Leaving empty line for now
-            FancyLoggerBuffer.WriteNewLine(string.Empty);
+            TerminalBuffer.WriteNewLine(string.Empty);
             // First render
-            FancyLoggerBuffer.Render();
+            TerminalBuffer.Render();
             int i = 0;
             // Rerender periodically
-            while (!FancyLoggerBuffer.IsTerminated)
+            while (!TerminalBuffer.IsTerminated)
             {
                 i++;
                 // Delay by 1/60 seconds
@@ -75,7 +72,7 @@ private void Render()
                         project.Value.Log();
                     }
                     // Rerender buffer
-                    FancyLoggerBuffer.Render();
+                    TerminalBuffer.Render();
                 });
                 // Handle keyboard input
                 if (Console.KeyAvailable)
@@ -84,15 +81,15 @@ private void Render()
                     switch (key)
                     {
                         case ConsoleKey.UpArrow:
-                            if (FancyLoggerBuffer.TopLineIndex > 0)
+                            if (TerminalBuffer.TopLineIndex > 0)
                             {
-                                FancyLoggerBuffer.TopLineIndex--;
+                                TerminalBuffer.TopLineIndex--;
                             }
-                            FancyLoggerBuffer.ShouldRerender = true;
+                            TerminalBuffer.ShouldRerender = true;
                             break;
                         case ConsoleKey.DownArrow:
-                            FancyLoggerBuffer.TopLineIndex++;
-                            FancyLoggerBuffer.ShouldRerender = true;
+                            TerminalBuffer.TopLineIndex++;
+                            TerminalBuffer.ShouldRerender = true;
                             break;
                         default:
                             break;
@@ -101,6 +98,15 @@ private void Render()
             }
         }
 
+        private void UpdateFooter()
+        {
+            float percentage = (float)FinishedProjects / StartedProjects;
+            TerminalBuffer.FooterText = ANSIBuilder.Alignment.SpaceBetween(
+                $"Build progress (approx.) [{ANSIBuilder.Graphics.ProgressBar(percentage)}]",
+                ANSIBuilder.Formatting.Italic(ANSIBuilder.Formatting.Dim("[Up][Down] Scroll")),
+                Console.BufferWidth);
+        }
+
         // Build
         private void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
         {
@@ -114,6 +120,7 @@ private void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
         // Project
         private void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
         {
+            StartedProjects++;
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
             // If id already exists...
@@ -122,9 +129,11 @@ private void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e
                 return;
             }
             // Add project
-            FancyLoggerProjectNode node = new FancyLoggerProjectNode(e);
+            ProjectNode node = new ProjectNode(e);
             projects[id] = node;
             // Log
+            // Update footer
+            UpdateFooter();
             node.ShouldRerender = true;
         }
 
@@ -132,13 +141,14 @@ private void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            if (!projects.TryGetValue(id, out ProjectNode? node))
             {
                 return;
             }
             // Update line
             node.Finished = true;
-            // Log
+            FinishedProjects++;
+            UpdateFooter();
             node.ShouldRerender = true;
         }
 
@@ -147,7 +157,7 @@ private void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            if (!projects.TryGetValue(id, out ProjectNode? node))
             {
                 return;
             }
@@ -161,7 +171,7 @@ private void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            if (!projects.TryGetValue(id, out ProjectNode? node))
             {
                 return;
             }
@@ -176,20 +186,18 @@ private void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            if (!projects.TryGetValue(id, out ProjectNode? node))
             {
                 return;
             }
             // Update
             node.AddTask(e);
-            existingTasks++;
             // Log
             node.ShouldRerender = true;
         }
 
         private void eventSource_TaskFinished(object sender, TaskFinishedEventArgs e)
         {
-            completedTasks++;
         }
 
         // Raised messages, warnings and errors
@@ -201,7 +209,7 @@ private void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
             }
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            if (!projects.TryGetValue(id, out ProjectNode? node))
             {
                 return;
             }
@@ -215,7 +223,7 @@ private void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            if (!projects.TryGetValue(id, out ProjectNode? node))
             {
                 return;
             }
@@ -229,7 +237,7 @@ private void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            if (!projects.TryGetValue(id, out ProjectNode? node))
             {
                 return;
             }
@@ -247,7 +255,7 @@ private void console_CancelKeyPressed(object? sender, ConsoleCancelEventArgs eve
 
         public void Shutdown()
         {
-            FancyLoggerBuffer.Terminate();
+            TerminalBuffer.Terminate();
             // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer
             Console.Clear();
             int errorCount = 0;
diff --git a/src/MSBuild/FancyLogger/FancyLoggerMessageNode.cs b/src/MSBuild/LiveLogger/MessageNode.cs
similarity index 90%
rename from src/MSBuild/FancyLogger/FancyLoggerMessageNode.cs
rename to src/MSBuild/LiveLogger/MessageNode.cs
index 73ce25f47d2..0d969a61774 100644
--- a/src/MSBuild/FancyLogger/FancyLoggerMessageNode.cs
+++ b/src/MSBuild/LiveLogger/MessageNode.cs
@@ -4,10 +4,10 @@
 using System;
 using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.Logging.FancyLogger
+namespace Microsoft.Build.Logging.LiveLogger
 {
 
-    internal class FancyLoggerMessageNode
+    internal class MessageNode
     {
         // Use this to change the max lenngth (relative to screen size) of messages
         private static int MAX_LENGTH = 3 * Console.BufferWidth;
@@ -18,13 +18,13 @@ public enum MessageType
             Error
         }
         public string Message;
-        public FancyLoggerBufferLine? Line;
+        public TerminalBufferLine? Line;
         public MessageType Type;
         public string? Code;
         public string? FilePath;
         public int? LineNumber;
         public int? ColumnNumber;
-        public FancyLoggerMessageNode(LazyFormattedBuildEventArgs args)
+        public MessageNode(LazyFormattedBuildEventArgs args)
         {
             Message = args.Message ?? string.Empty;
             if (Message.Length > MAX_LENGTH)
@@ -72,7 +72,7 @@ public string ToANSIString()
             }
         }
 
-        // TODO: Rename to Log after FancyLogger's API becomes internal
+        // TODO: Rename to Log after LiveLogger's API becomes internal
         public void Log()
         {
             if (Line == null)
diff --git a/src/MSBuild/FancyLogger/FancyLoggerProjectNode.cs b/src/MSBuild/LiveLogger/ProjectNode.cs
similarity index 72%
rename from src/MSBuild/FancyLogger/FancyLoggerProjectNode.cs
rename to src/MSBuild/LiveLogger/ProjectNode.cs
index 00e1cd8090a..ce66c2d21b9 100644
--- a/src/MSBuild/FancyLogger/FancyLoggerProjectNode.cs
+++ b/src/MSBuild/LiveLogger/ProjectNode.cs
@@ -7,9 +7,9 @@
 using System.Linq;
 using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.Logging.FancyLogger
+namespace Microsoft.Build.Logging.LiveLogger
 {
-    internal class FancyLoggerProjectNode
+    internal class ProjectNode
     {
         /// <summary>
         /// Given a list of paths, this method will get the shortest not ambiguous path for a project.
@@ -26,20 +26,20 @@ private static string GetUnambiguousPath(string path)
         public string TargetFramework;
         public bool Finished;
         // Line to display project info
-        public FancyLoggerBufferLine? Line;
+        public TerminalBufferLine? Line;
         // Targets
         public int FinishedTargets;
-        public FancyLoggerBufferLine? CurrentTargetLine;
-        public FancyLoggerTargetNode? CurrentTargetNode;
+        public TerminalBufferLine? CurrentTargetLine;
+        public TargetNode? CurrentTargetNode;
         // Messages, errors and warnings
-        public List<FancyLoggerMessageNode> AdditionalDetails = new();
+        public List<MessageNode> AdditionalDetails = new();
         // Count messages, warnings and errors
         public int MessageCount = 0;
         public int WarningCount = 0;
         public int ErrorCount = 0;
         // Bool if node should rerender
         internal bool ShouldRerender = true;
-        public FancyLoggerProjectNode(ProjectStartedEventArgs args)
+        public ProjectNode(ProjectStartedEventArgs args)
         {
             Id = args.ProjectId;
             ProjectPath = args.ProjectFile!;
@@ -55,7 +55,7 @@ public FancyLoggerProjectNode(ProjectStartedEventArgs args)
             }
         }
 
-        // TODO: Rename to Render() after FancyLogger's API becomes internal
+        // TODO: Rename to Render() after LiveLogger's API becomes internal
         public void Log()
         {
             if (!ShouldRerender)
@@ -78,7 +78,7 @@ public void Log()
             // Create or update line
             if (Line is null)
             {
-                Line = FancyLoggerBuffer.WriteNewLine(lineContents, false);
+                Line = TerminalBuffer.WriteNewLine(lineContents, false);
             }
             else
             {
@@ -90,20 +90,20 @@ public void Log()
             {
                 if (CurrentTargetLine is not null)
                 {
-                    FancyLoggerBuffer.DeleteLine(CurrentTargetLine.Id);
+                    TerminalBuffer.DeleteLine(CurrentTargetLine.Id);
                 }
 
-                foreach (FancyLoggerMessageNode node in AdditionalDetails.ToList())
+                foreach (MessageNode node in AdditionalDetails.ToList())
                 {
                     // Only delete high priority messages
-                    if (node.Type != FancyLoggerMessageNode.MessageType.HighPriorityMessage)
+                    if (node.Type != MessageNode.MessageType.HighPriorityMessage)
                     {
                         continue;
                     }
 
                     if (node.Line is not null)
                     {
-                        FancyLoggerBuffer.DeleteLine(node.Line.Id);
+                        TerminalBuffer.DeleteLine(node.Line.Id);
                     }
                 }
             }
@@ -117,7 +117,7 @@ public void Log()
             string currentTargetLineContents = $"    └── {CurrentTargetNode.TargetName} : {CurrentTargetNode.CurrentTaskNode?.TaskName ?? String.Empty}";
             if (CurrentTargetLine is null)
             {
-                CurrentTargetLine = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
+                CurrentTargetLine = TerminalBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
             }
             else
             {
@@ -125,28 +125,28 @@ public void Log()
             }
 
             // Messages, warnings and errors
-            foreach (FancyLoggerMessageNode node in AdditionalDetails)
+            foreach (MessageNode node in AdditionalDetails)
             {
-                if (Finished && node.Type == FancyLoggerMessageNode.MessageType.HighPriorityMessage)
+                if (Finished && node.Type == MessageNode.MessageType.HighPriorityMessage)
                 {
                     continue;
                 }
 
                 if (node.Line is null)
                 {
-                    node.Line = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, "Message");
+                    node.Line = TerminalBuffer.WriteNewLineAfter(Line!.Id, "Message");
                 }
 
                 node.Log();
             }
         }
 
-        public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)
+        public TargetNode AddTarget(TargetStartedEventArgs args)
         {
-            CurrentTargetNode = new FancyLoggerTargetNode(args);
+            CurrentTargetNode = new TargetNode(args);
             return CurrentTargetNode;
         }
-        public FancyLoggerTaskNode? AddTask(TaskStartedEventArgs args)
+        public TaskNode? AddTask(TaskStartedEventArgs args)
         {
             // Get target id
             int targetId = args.BuildEventContext!.TargetId;
@@ -159,7 +159,7 @@ public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)
                 return null;
             }
         }
-        public FancyLoggerMessageNode? AddMessage(BuildMessageEventArgs args)
+        public MessageNode? AddMessage(BuildMessageEventArgs args)
         {
             if (args.Importance != MessageImportance.High)
             {
@@ -167,21 +167,21 @@ public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)
             }
 
             MessageCount++;
-            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            MessageNode node = new MessageNode(args);
             AdditionalDetails.Add(node);
             return node;
         }
-        public FancyLoggerMessageNode? AddWarning(BuildWarningEventArgs args)
+        public MessageNode? AddWarning(BuildWarningEventArgs args)
         {
             WarningCount++;
-            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            MessageNode node = new MessageNode(args);
             AdditionalDetails.Add(node);
             return node;
         }
-        public FancyLoggerMessageNode? AddError(BuildErrorEventArgs args)
+        public MessageNode? AddError(BuildErrorEventArgs args)
         {
             ErrorCount++;
-            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            MessageNode node = new MessageNode(args);
             AdditionalDetails.Add(node);
             return node;
         }
diff --git a/src/MSBuild/FancyLogger/FancyLoggerTargetNode.cs b/src/MSBuild/LiveLogger/TargetNode.cs
similarity index 55%
rename from src/MSBuild/FancyLogger/FancyLoggerTargetNode.cs
rename to src/MSBuild/LiveLogger/TargetNode.cs
index 21430209d83..06d61dd431a 100644
--- a/src/MSBuild/FancyLogger/FancyLoggerTargetNode.cs
+++ b/src/MSBuild/LiveLogger/TargetNode.cs
@@ -3,22 +3,22 @@
 
 using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.Logging.FancyLogger
+namespace Microsoft.Build.Logging.LiveLogger
 {
 
-    internal class FancyLoggerTargetNode
+    internal class TargetNode
     {
         public int Id;
         public string TargetName;
-        public FancyLoggerTaskNode? CurrentTaskNode;
-        public FancyLoggerTargetNode(TargetStartedEventArgs args)
+        public TaskNode? CurrentTaskNode;
+        public TargetNode(TargetStartedEventArgs args)
         {
             Id = args.BuildEventContext!.TargetId;
             TargetName = args.TargetName;
         }
-        public FancyLoggerTaskNode AddTask(TaskStartedEventArgs args)
+        public TaskNode AddTask(TaskStartedEventArgs args)
         {
-            CurrentTaskNode = new FancyLoggerTaskNode(args);
+            CurrentTaskNode = new TaskNode(args);
             return CurrentTaskNode;
         }
     }
diff --git a/src/MSBuild/FancyLogger/FancyLoggerTaskNode.cs b/src/MSBuild/LiveLogger/TaskNode.cs
similarity index 70%
rename from src/MSBuild/FancyLogger/FancyLoggerTaskNode.cs
rename to src/MSBuild/LiveLogger/TaskNode.cs
index 7ad82beca4a..4e8d8118675 100644
--- a/src/MSBuild/FancyLogger/FancyLoggerTaskNode.cs
+++ b/src/MSBuild/LiveLogger/TaskNode.cs
@@ -3,14 +3,14 @@
 
 using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.Logging.FancyLogger
+namespace Microsoft.Build.Logging.LiveLogger
 {
 
-    internal class FancyLoggerTaskNode
+    internal class TaskNode
     {
         public int Id;
         public string TaskName;
-        public FancyLoggerTaskNode(TaskStartedEventArgs args)
+        public TaskNode(TaskStartedEventArgs args)
         {
             Id = args.BuildEventContext!.TaskId;
             TaskName = args.TaskName;
diff --git a/src/MSBuild/FancyLogger/FancyLoggerBuffer.cs b/src/MSBuild/LiveLogger/TerminalBuffer.cs
similarity index 79%
rename from src/MSBuild/FancyLogger/FancyLoggerBuffer.cs
rename to src/MSBuild/LiveLogger/TerminalBuffer.cs
index 95f4283b8fd..b4268af4c8b 100644
--- a/src/MSBuild/FancyLogger/FancyLoggerBuffer.cs
+++ b/src/MSBuild/LiveLogger/TerminalBuffer.cs
@@ -6,9 +6,9 @@
 using System.Linq;
 using System.Text;
 
-namespace Microsoft.Build.Logging.FancyLogger
+namespace Microsoft.Build.Logging.LiveLogger
 {
-    internal class FancyLoggerBufferLine
+    internal class TerminalBufferLine
     {
         private static int Counter = 0;
         private string _text = string.Empty;
@@ -31,22 +31,22 @@ public string Text
                     WrappedText = new List<string> { value };
                 }
                 // Buffer should rerender
-                FancyLoggerBuffer.ShouldRerender = true;
+                TerminalBuffer.ShouldRerender = true;
             }
         }
 
-        public FancyLoggerBufferLine()
+        public TerminalBufferLine()
         {
             Id = Counter++;
             Text = string.Empty;
             ShouldWrapLines = false;
         }
-        public FancyLoggerBufferLine(string text)
+        public TerminalBufferLine(string text)
             : this()
         {
             Text = text;
         }
-        public FancyLoggerBufferLine(string text, bool shouldWrapLines)
+        public TerminalBufferLine(string text, bool shouldWrapLines)
             : this()
         {
             ShouldWrapLines = shouldWrapLines;
@@ -54,9 +54,10 @@ public FancyLoggerBufferLine(string text, bool shouldWrapLines)
         }
     }
 
-    internal class FancyLoggerBuffer
+    internal class TerminalBuffer
     {
-        private static List<FancyLoggerBufferLine> Lines = new();
+        private static List<TerminalBufferLine> Lines = new();
+        public static string FooterText = string.Empty;
         public static int TopLineIndex = 0;
         public static string Footer = string.Empty;
         internal static bool IsTerminated = false;
@@ -102,9 +103,8 @@ public static void Render()
                 ANSIBuilder.Cursor.Home() +
                 ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center("MSBuild - Build in progress")) +
                 // Write footer
-                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
-                // TODO: Remove and replace with actual footer
-                new string('-', Console.BufferWidth) + $"\nBuild progress: XX%\tTopLineIndex={TopLineIndex}");
+                ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) + ANSIBuilder.Eraser.LineCursorToEnd() +
+                new string('-', Console.BufferWidth) + '\n' + FooterText);
 
             if (Lines.Count == 0)
             {
@@ -115,7 +115,7 @@ public static void Render()
             string contents = string.Empty;
             int accumulatedLineCount = 0;
             int lineIndex = 0;
-            foreach (FancyLoggerBufferLine line in Lines)
+            foreach (TerminalBufferLine line in Lines)
             {
                 // Continue if accum line count + next lines < scrolling area
                 if (accumulatedLineCount + line.WrappedText.Count < TopLineIndex)
@@ -157,7 +157,7 @@ public static int GetLineIndexById(int lineId)
             return Lines.FindIndex(x => x.Id == lineId);
         }
 
-        public static FancyLoggerBufferLine? GetLineById(int lineId)
+        public static TerminalBufferLine? GetLineById(int lineId)
         {
             int index = GetLineIndexById(lineId);
             if (index == -1)
@@ -171,16 +171,16 @@ public static int GetLineIndexById(int lineId)
 
         #region Line create, update and delete
         // Write new line
-        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, string text)
+        public static TerminalBufferLine? WriteNewLineAfter(int lineId, string text)
         {
             return WriteNewLineAfter(lineId, text, true);
         }
-        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, string text, bool shouldWrapLines)
+        public static TerminalBufferLine? WriteNewLineAfter(int lineId, string text, bool shouldWrapLines)
         {
-            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text, shouldWrapLines);
+            TerminalBufferLine line = new TerminalBufferLine(text, shouldWrapLines);
             return WriteNewLineAfter(lineId, line);
         }
-        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, FancyLoggerBufferLine line)
+        public static TerminalBufferLine? WriteNewLineAfter(int lineId, TerminalBufferLine line)
         {
             if (lineId != -1)
             {
@@ -200,23 +200,23 @@ public static int GetLineIndexById(int lineId)
             return line;
         }
 
-        public static FancyLoggerBufferLine? WriteNewLine(string text)
+        public static TerminalBufferLine? WriteNewLine(string text)
         {
             return WriteNewLine(text, true);
         }
-        public static FancyLoggerBufferLine? WriteNewLine(string text, bool shouldWrapLines)
+        public static TerminalBufferLine? WriteNewLine(string text, bool shouldWrapLines)
         {
-            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text, shouldWrapLines);
+            TerminalBufferLine line = new TerminalBufferLine(text, shouldWrapLines);
             return WriteNewLine(line);
         }
-        public static FancyLoggerBufferLine? WriteNewLine(FancyLoggerBufferLine line)
+        public static TerminalBufferLine? WriteNewLine(TerminalBufferLine line)
         {
             return WriteNewLineAfter(Lines.Count > 0 ? Lines.Last().Id : -1, line);
         }
 
         // Update line
         // TODO: Remove. Use line.Text instead
-        public static FancyLoggerBufferLine? UpdateLine(int lineId, string text)
+        public static TerminalBufferLine? UpdateLine(int lineId, string text)
         {
             return null;
         }
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index e3d5d6b9589..345d27ecf51 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -172,7 +172,7 @@
     <Compile Include="DistributedLoggerRecord.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="FancyLogger\*.cs" />
+    <Compile Include="LiveLogger\*.cs" />
     <Compile Include="InitializationException.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -243,13 +243,8 @@
   </ItemGroup>
 
   <!-- Xsds are not TF or arch-specific so copy once them in the outer build -->
-  <Target Name="CopyXsds"
-          BeforeTargets="Build"
-          Condition="'$(IsInnerBuild)' != 'true'">
-    <Copy SourceFiles="@(XsdsForVS)"
-          DestinationFiles="@(XsdsForVS->'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')"
-          SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
-          />
+  <Target Name="CopyXsds" BeforeTargets="Build" Condition="'$(IsInnerBuild)' != 'true'">
+    <Copy SourceFiles="@(XsdsForVS)" DestinationFiles="@(XsdsForVS-&gt;'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" />
   </Target>
 
   <!-- Include MSBuild.deps.json and MSBuild.runtimeconfig.json in ContentWithTargetPath so they will be copied to the output folder of projects
@@ -270,10 +265,7 @@
        in resolving references using them instead of the correct build-time references.
        Instead, add them just afterward, before assigning target paths/copying to
        the bin folder. -->
-  <Target Name="AddRefAssemblies"
-          DependsOnTargets="ResolveAssemblyReferences"
-          BeforeTargets="AssignTargetPaths"
-          Condition="'$(MonoBuild)' != 'true'">
+  <Target Name="AddRefAssemblies" DependsOnTargets="ResolveAssemblyReferences" BeforeTargets="AssignTargetPaths" Condition="'$(MonoBuild)' != 'true'">
     <ItemGroup>
       <Content Include="$(NuGetPackageRoot)\netstandard.library\2.0.3\build\netstandard2.0\ref\netstandard.dll" Link="ref\netstandard.dll" CopyToOutputDirectory="PreserveNewest" />
       <Content Include="$(NuGetPackageRoot)\netstandard.library\2.0.3\build\netstandard2.0\ref\mscorlib.dll" Link="ref\mscorlib.dll" CopyToOutputDirectory="PreserveNewest" />
@@ -354,7 +346,7 @@
     </Task>
   </UsingTask>
 
-  <Target Name="ValidateMSBuildPackageDependencyVersions" BeforeTargets="AfterBuild" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" >
+  <Target Name="ValidateMSBuildPackageDependencyVersions" BeforeTargets="AfterBuild" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <ValidateMSBuildPackageDependencyVersions AppConfig="@(AppConfigWithTargetPath)" AssemblyPath="$(OutputPath)" />
   </Target>
 
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 5701c2d3cc9..3cea4a096b1 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -470,7 +470,7 @@
    <value>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </value>
     <comment>
@@ -482,9 +482,8 @@
   <data name="HelpMessage_InputCachesFiles" UESanitized="false" Visibility="Public">
    <value>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </value>
     <comment>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -756,9 +755,18 @@
     </comment>
   </data>
   <data name="HelpMessage_35_IsolateProjectsSwitch" UESanitized="false" Visibility="Public">
-    <value>  -isolateProjects[:True|False]
+    <value>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -1187,7 +1195,8 @@
     <comment>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 629795762ae..827a5cd91a3 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Způsobí, že MSBuild sestaví jednotlivé projekty izolovaně.
 
                      Jde o omezenější režim nástroje MSBuild, protože vyžaduje,
@@ -336,9 +345,9 @@
         <target state="translated">  @&lt;soubor&gt;            Vložení nastavení příkazového řádku z textového souboru. Chcete-li zadat
                      více souborů odpovědí, uveďte každý soubor
                      odpovědí zvlášť.
-                     
-                     Automaticky jsou použity všechny soubory s názvem msbuild.rsp 
-                     nacházející se v následujících umístěních: 
+
+                     Automaticky jsou použity všechny soubory s názvem msbuild.rsp
+                     nacházející se v následujících umístěních:
                      (1) adresář nástroje msbuild.exe
                      (2) adresář prvního sestaveného projektu nebo řešení
 </target>
@@ -399,7 +408,7 @@
 </source>
         <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Nastavení nebo potlačení daných vlastností na úrovni
                      projektu. &lt;n&gt; je název vlastnosti a &lt;v&gt; je její hodnota. Více
-                     vlastností oddělte středníkem či čárkou nebo zadejte 
+                     vlastností oddělte středníkem či čárkou nebo zadejte
                      každou vlastnost zvlášť. (Krátký tvar: -p)
                      Příklad:
                        -property:WarningLevel=2;OutDir=bin\Debug\
@@ -440,7 +449,7 @@
                      Syntaxe hodnoty &lt;sestavení_protok_nást&gt;:
                         {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
-                     Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se 
+                     Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se
                      protokolovacímu nástroji přesně v tom tvaru, v jakém
                      byly zadány. (Krátký tvar: -l)
                      Příklady:
@@ -587,10 +596,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate          Ověřit projekt podle výchozího schématu. 
+        <target state="translated">  -validate          Ověřit projekt podle výchozího schématu.
                      (Krátký tvar: -val)
 
-  -validate:&lt;schéma&gt; Ověřit projekt podle zadaného schématu. 
+  -validate:&lt;schéma&gt; Ověřit projekt podle zadaného schématu.
                      (Krátký tvar: -val)
                      Příklad:
                        -validate:MyExtendedBuildSchema.xsd
@@ -647,11 +656,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
                      Seznam středníkem oddělených vstupních souborů mezipaměti, ze kterých
                      MSBuild přečte výsledky sestavení.
                      Nastavení tohoto atributu zároveň zapne izolované buildy (-isolate).
@@ -666,10 +674,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[souborMezipaměti]...
+        <target state="needs-review-translation">  -outputResultsCache:[souborMezipaměti]...
                      Výstupní soubor mezipaměti, do něhož bude MSBuild
                      zapisovat obsah svých mezipamětí výsledků sestavení.
                      Nastavením této možnosti zapnete také izolované buildy (-isolate).
@@ -705,11 +713,11 @@
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedlogger:&lt;centr_protok_nást&gt;*&lt;předáv_protok_nást&gt;                     
+        <target state="translated">  -distributedlogger:&lt;centr_protok_nást&gt;*&lt;předáv_protok_nást&gt;
                      Použít zadaný protokolovací nástroj pro protokolování událostí
-                     z nástroje MSBuild; ke každému uzlu připojit jinou instanci 
-                     protokolovacího nástroje. Chcete-li zadat více 
-                     protokolovacích nástrojů, uveďte je jednotlivě. 
+                     z nástroje MSBuild; ke každému uzlu připojit jinou instanci
+                     protokolovacího nástroje. Chcete-li zadat více
+                     protokolovacích nástrojů, uveďte je jednotlivě.
                      (Krátký tvar: -dl)
                      Syntaxe hodnoty &lt;protok_nást&gt;:
                         [&lt;třída_protok_nást&gt;,]&lt;sestav_protok_nást&gt;
@@ -773,7 +781,7 @@
         <target state="translated">  -toolsversion:&lt;verze&gt;
                      Verze sady nástrojů MSBuild (úloh, cílů apod.), která má být
                      použita při sestavení. Tato verze má přednost před verzemi
-                     uvedenými v jednotlivých projektech. 
+                     uvedenými v jednotlivých projektech.
                      (Krátký tvar: -tv)
                      Příklad:
                        -toolsversion:3.5
@@ -891,25 +899,25 @@
                      popis přepínače -distributedFileLogger.
                      (Krátký tvar: -flp[n])
                      K dispozici jsou stejné parametry jako ty,
-                     které jsou uvedeny u protokolovacího nástroje 
+                     které jsou uvedeny u protokolovacího nástroje
                      konzoly. Některé další dostupné parametry:
                        LogFile – cesta k souboru protokolu, do nějž bude zapsán
-                                  protokol sestavení 
+                                  protokol sestavení
                        Append  – určuje, zda bude protokol sestavení připojen
-                                  k souboru protokolu, nebo jej přepíše. Při nastavení 
+                                  k souboru protokolu, nebo jej přepíše. Při nastavení
                                   přepínače bude protokol sestavení připojen k souboru
-                                  protokolu. Není-li přepínač nastaven, bude obsah 
-                                  existujícího souboru protokolu přepsán. 
+                                  protokolu. Není-li přepínač nastaven, bude obsah
+                                  existujícího souboru protokolu přepsán.
                                   Podle výchozího nastavení je soubor protokolu přepsán.
-                       Encoding – určuje kódování souboru, například 
+                       Encoding – určuje kódování souboru, například
                      UTF-8, Unicode nebo ASCII.
                        Výchozí úroveň podrobností je Detailed.
                      Příklady:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                              Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1032,11 +1040,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: Hodnota izolace projektů není platná. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: Hodnota izolace projektů není platná. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 3c0965cfed9..a48f6fd867d 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -116,7 +116,7 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     Weist darauf hin, dass für Aktionen im Build eine 
+                     Weist darauf hin, dass für Aktionen im Build eine
                      Interaktion mit dem Benutzer zugelassen ist. Verwenden Sie dieses Argument
                      in einem automatisierten Szenario, in dem keine Interaktivität
                      erwartet wird.
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,11 +150,11 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Führt dazu, dass MSBuild jedes Projekt isoliert erstellt.
 
                      Dies ist ein restriktiverer Modus von MSBuild, da er erfordert, dass
-                     der Projektgraph zur Auswertungszeit statisch ermittelbar ist. Er kann jedoch 
+                     der Projektgraph zur Auswertungszeit statisch ermittelbar ist. Er kann jedoch
                      die Planung verbessern und den Speichermehraufwand
                      beim Erstellen einer großen Anzahl von Projekten verringern.
                      (Kurzform: -isolate)
@@ -337,8 +346,8 @@ Beispiel:
                      Antwortdateien anzugeben, geben Sie jede Antwortdatei
                      gesondert an.
 
-                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch 
-                     in den folgenden Speicherorten verwendet: 
+                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch
+                     in den folgenden Speicherorten verwendet:
                      (1) Verzeichnis von "msbuild.exe"
                      (2) Verzeichnis des ersten erstellten Projekts oder Projektmappe
 </target>
@@ -429,7 +438,7 @@ Beispiel:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben, 
+        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben,
                      wird jede Protokollierung gesondert angegeben.
                      Die Syntax für die &lt;Protokollierung&gt; lautet:
                        [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
@@ -438,7 +447,7 @@ Beispiel:
                      Die Syntax für die &lt;Protokollierungsassembly&gt; lautet:
                        {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
                      so an die Protokollierung übergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -644,11 +653,10 @@ Beispiel:
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
                      Durch Semikolons getrennte Liste von Eingabecachedateien, aus denen MSBuild
                      Buildergebnisse liest.
                      Durch Festlegen dieser Option werden auch isolierte Builds aktiviert (-isolate).
@@ -663,10 +671,10 @@ Beispiel:
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[Cachedatei]
+        <target state="needs-review-translation">  -outputResultsCache:[Cachedatei]
                      Ausgabecachedateien, in die MSBuild am Ende des Buildvorgangs die Inhalte
                      der zugehörigen Caches mit Buildergebnissen schreibt.
                      Durch Festlegung dieser Option werden außerdem isolierte Builds aktiviert (-isolate).
@@ -703,8 +711,8 @@ Beispiel:
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
         <target state="translated">  -distributedlogger:&lt;Zentrale Protokollierung&gt;*&lt;Weiterleitende Protokollierung&gt;
-                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere 
-                     Protokollierungsinstanz angefügt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung 
+                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere
+                     Protokollierungsinstanz angefügt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung
                      gesondert angegeben.
                      (Kurzform -dl)
                      Die Syntax für die &lt;Protokollierung&gt; lautet:
@@ -714,7 +722,7 @@ Beispiel:
                      Die Syntax für die &lt;Protokollierungsassembly&gt; lautet:
                        {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
                      so an die Protokollierung übergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -739,8 +747,8 @@ Beispiel:
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreprojectextensions:&lt;Erweiterungen&gt;
-                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende 
-                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma, 
+                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende
+                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma,
                      um mehrere Erweiterungen voneinander zu trennen.
                      (Kurzform: -ignore)
                      Beispiel:
@@ -766,8 +774,8 @@ Beispiel:
    </source>
         <target state="translated">  -toolsversion:&lt;Version&gt;
                      Die Version des MSBuild-Toolsets (Aufgaben, Ziele usw.),
-                     die während des Erstellens zu verwenden ist. Diese Version überschreibt die 
-                     von einzelnen Projekten angegebenen Versionen. (Kurzform: 
+                     die während des Erstellens zu verwenden ist. Diese Version überschreibt die
+                     von einzelnen Projekten angegebenen Versionen. (Kurzform:
                      -tv)
                      Beispiel:
                        -toolsversion:3.5
@@ -826,14 +834,14 @@ Beispiel:
         <target state="translated">  -distributedFileLogger
                      Protokolliert die Erstellungsausgabe in mehrere Dateien, eine Protokolldatei
                      pro MSBuild-Knoten. Der anfängliche Speicherort für diese Dateien ist
-                     das aktuelle Verzeichnis. Standardmäßig werden die Dateien 
+                     das aktuelle Verzeichnis. Standardmäßig werden die Dateien
                      "MSBuild&lt;Knoten-ID&gt;.log" benannt. Der Speicherort der Datei und
-                     andere Parameter für fileLogger können durch das Hinzufügen 
+                     andere Parameter für fileLogger können durch das Hinzufügen
                      des Schalters "-fileLoggerParameters" angegeben werden.
 
                      Wenn mithilfe des fileLoggerParameters-Parameters ein Protokolldateiname festgelegt wurde,
-                     verwendet die verteilte Protokollierung den Dateinamen als 
-                     Vorlage und fügt die Knoten-ID an diesen Dateinamen an, 
+                     verwendet die verteilte Protokollierung den Dateinamen als
+                     Vorlage und fügt die Knoten-ID an diesen Dateinamen an,
                      um für jeden Knoten eine Protokolldatei zu erstellen.
     </target>
         <note>
@@ -877,31 +885,31 @@ Beispiel:
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;Parameter&gt;
                      Gibt zusätzliche Parameter für Dateiprotokollierungen an.
-                     Dieser Schalter bedeutet, dass der entsprechende 
+                     Dieser Schalter bedeutet, dass der entsprechende
                      Schalter "-fileLogger[n]" ebenfalls vorhanden ist.
                      "n" (optional) kann eine Zahl von 1–9 sein.
-                     "-fileLoggerParameters" wird auch von verteilten 
+                     "-fileLoggerParameters" wird auch von verteilten
                      Dateiprotokollierungen verwendet (siehe Beschreibung zu "-distributedFileLogger").
                      (Kurzform: -flp[n])
                      Es sind dieselben Parameter wie für die Konsolenprotokollierung
                      verfügbar. Einige zusätzliche Parameter:
-                        LogFile: Pfad der Protokolldatei, in die das 
+                        LogFile: Pfad der Protokolldatei, in die das
                             Buildprotokoll geschrieben wird.
-                        Append: Gibt an, ob das Buildprotokoll erweitert oder 
+                        Append: Gibt an, ob das Buildprotokoll erweitert oder
                             oder überschrieben wird. Mit diesem Schalter
                             wird das Buildprotokoll an die Protokolldatei angefügt;
-                            Ohne diesen Schalter wird der Inhalt 
-                            der vorhandenen Protokolldatei überschrieben. 
+                            Ohne diesen Schalter wird der Inhalt
+                            der vorhandenen Protokolldatei überschrieben.
                             Standardmäßig wird die Protokolldatei nicht erweitert.
-                        Encoding: Gibt die Codierung der Datei an, 
+                        Encoding: Gibt die Codierung der Datei an,
                             z. B. UTF-8, Unicode oder ASCII.
                      Die Standardeinstellung für "verbosity" ist "Detailed".
                      Beispiele:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -927,7 +935,7 @@ Beispiel:
         <target state="translated">  -nodeReuse:&lt;Parameter&gt;
                      Aktiviert oder deaktiviert die Wiederverwendung von MSBuild-Knoten.
                      Die Parameter lauten:
-                     True: Knoten bleiben nach dem Abschluss der Erstellung 
+                     True: Knoten bleiben nach dem Abschluss der Erstellung
                      erhalten und werden bei folgenden Erstellungen wiederverwendet (Standardeinstellung).
                      False: Knoten bleiben nach dem Abschluss der Erstellung nicht erhalten.
                      (Kurzform: -nr)
@@ -1024,11 +1032,12 @@ Beispiel:
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: Der Wert für das Isolieren von Projekten ist nicht gültig. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: Der Wert für das Isolieren von Projekten ist nicht gültig. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 061121dec63..bf8d89e1c84 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Hace que MSBuild compile cada proyecto en aislamiento.
 
                      Este es un modo de MSBuild más restrictivo ya que requiere
@@ -648,11 +657,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;archivoCaché&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;archivoCaché&gt;...
                      Lista de archivos de caché de entrada, separados por punto y coma, de la que MSBuild
                      leerá los resultados de la compilación.
                      Si se establece esta opción, se activan también las compilaciones aisladas (-isolate).
@@ -667,10 +675,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[archivo-de-caché]
+        <target state="needs-review-translation">  -outputResultsCache:[archivo-de-caché]
                      Archivo de caché de salida donde MSBuild escribe
                      el contenido de las memorias caché de resultados
                      de compilación cuando esta acaba.
@@ -748,8 +756,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensiones&gt;
-                     Lista de extensiones que se omiten al determinar el 
-                     archivo del proyecto que se va a compilar. Use el carácter de 
+                     Lista de extensiones que se omiten al determinar el
+                     archivo del proyecto que se va a compilar. Use el carácter de
                      punto y coma o coma para separar varias extensiones.
                     (Forma corta: -ignore)
                      Ejemplo:
@@ -900,9 +908,9 @@
                             sobrescribirá el archivo de registro. Si se establece el
                             modificador, se adjunta el registro de compilación al archivo de registro;
                             Si no se especifica el modificador, se sobrescribe
-                            el contenido del archivo de registro existente. 
+                            el contenido del archivo de registro existente.
                             El valor predeterminado es adjuntar el archivo de registro.
-                        Encoding: especifica la codificación del archivo, 
+                        Encoding: especifica la codificación del archivo,
                             por ejemplo, UTF-8, Unicode o ASCII
                      El nivel de detalle predeterminado es Detailed.
                      Ejemplos:
@@ -1033,11 +1041,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: El valor de los proyectos aislados no es válido. {0}.</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: El valor de los proyectos aislados no es válido. {0}.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index cbe9a27f313..572e704317d 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Force MSBuild à générer chaque projet de manière isolée.
 
                      Ce mode de MSBuild est plus restrictif car il nécessite
@@ -644,11 +653,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;fichierCache&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;fichierCache&gt;...
          Liste de fichiers cache d'entrée séparés par des points-virgules, à
          partir desquels MSBuild va lire les résultats de la build.
          Ce paramètre active également les builds isolées (-isolate).
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      Fichier cache de sortie dans lequel MSBuild écrit le contenu de
                      ses caches de résultats de la build à la fin de la build.
                      Ce paramètre active également les builds isolées (-isolate).
@@ -1024,11 +1032,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: La valeur d’isolation des projets n'est pas valide. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: La valeur d’isolation des projets n'est pas valide. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1752,7 +1761,7 @@ fois plus petit que le journal
         <target state="translated">  -profileEvaluation:&lt;fichier&gt;
          Profile l'évaluation MSBuild et écrit le résultat
          dans le fichier spécifié. Si l'extension du fichier spécifié
-         est '.md', le résultat est généré au format Markdown. 
+         est '.md', le résultat est généré au format Markdown.
          Sinon, un fichier de valeurs séparées par des tabulations est généré.
     </target>
         <note />
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index c222fdf2e2e..d97eee21a68 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -131,9 +131,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -142,9 +151,9 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Fa in modo che MSBuild compili ogni progetto in modalità
-                     isolamento. 
+                     isolamento.
 
                      Si tratta di una modalità più restrittiva di
                      MSBuild perché richiede che il grafico del progetto sia
@@ -348,7 +357,7 @@ Esempio:
                      separatamente.
 
                      Qualsiasi file di risposta denominato "msbuild.rsp" viene usato
-                     automaticamente dai percorsi seguenti: 
+                     automaticamente dai percorsi seguenti:
                      (1) la directory di msbuild.exe
                      (2) la directory della prima compilazione di soluzione o progetto
 </target>
@@ -654,11 +663,10 @@ Esempio:
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;fileCache&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;fileCache&gt;...
                      Elenco di file di cache di input delimitati da punto e virgola da cui MSBuild
                      leggerà i risultati della compilazione.
                      Se si imposta questa opzione, si attivano anche le compilazioni isolate (-isolate).
@@ -673,10 +681,10 @@ Esempio:
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[fileCache]
+        <target state="needs-review-translation">  -outputResultsCache:[fileCache]
                      File di cache di output in cui MSBuild scriverà il contenuto delle
                      cache dei risultati della compilazione al termine della compilazione.
                      Se si imposta questa opzione, si attivano anche le compilazioni isolate (-isolate).
@@ -1038,11 +1046,12 @@ Esempio:
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: il valore di isolateProjects non è valido. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: il valore di isolateProjects non è valido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index b43a24ea5b0..c590ae60203 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      MSBuild は、各プロジェクトを分離してビルドします。
 
                      これは MSBuild のより制限的なモードです。
@@ -205,7 +214,7 @@
     </source>
         <target state="translated">  -targets[:file]
                      使用可能なターゲットの一覧を、実際のビルド処理を
-                     実行せずに出力します。既定では、出力はコンソール 
+                     実行せずに出力します。既定では、出力はコンソール
                      ウィンドウに書き込まれます。出力ファイルへのパスを
                      指定した場合は、代わりにそのファイルが使用されます。
                      (短い形式:-ts)
@@ -644,11 +653,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
                      MSBuild がビルド結果を読み込む、入力キャッシュ ファイルの
                      セミコロンで区切られたリスト。
                      これを設定すると、分離されたビルド (-isolate) も有効になります。
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      MSBuild がビルドの最後にビルド結果キャッシュの
                      内容を書き込む出力キャッシュ ファイル。
                      設定すると、分離されたビルドも有効になります (-isolate)。
@@ -1024,11 +1032,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: Isolate projects 値が無効です。{0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: Isolate projects 値が無効です。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1691,7 +1700,7 @@
                      (Short form: -r)
     </source>
         <target state="translated">  -restore[:True|False]
-                     他のターゲットをビルドする前に Restore 
+                     他のターゲットをビルドする前に Restore
                      という名前のターゲットを実行し、これらのターゲットのビルドが
                      最新の復元ビルド ロジックを使用するようにします。
                      これは、パッケージ ツリーでパッケージをビルド
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 212687577a1..e136d34da21 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -116,12 +116,12 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     빌드의 작업이 사용자와 상호 작용할 수 
-                     있음을 나타냅니다. 상호 작용이 필요하지 
-                     않은 자동화된 시나리오에서는 이 인수를 
+                     빌드의 작업이 사용자와 상호 작용할 수
+                     있음을 나타냅니다. 상호 작용이 필요하지
+                     않은 자동화된 시나리오에서는 이 인수를
                      사용하지 마세요.
                      -interactive를 지정하는 것은 -interactive:true를
-                     지정하는 것과 같습니다. 매개 변수를 
+                     지정하는 것과 같습니다. 매개 변수를
                      사용하여 지시 파일에서 가져오는 값을 재정의합니다.
     </target>
         <note>
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,12 +150,12 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      MSBuild가 격리 모드에서 각 프로젝트를 빌드하도록 합니다.
 
-                     이 모드는 프로젝트 그래프가 평가 시간에 정적으로 
-                     검색 가능해야 하므로 더 제한적인 MSBuild 모드이나, 
-                     대규모 프로젝트를 빌드할 경우 예약을 개선하고 
+                     이 모드는 프로젝트 그래프가 평가 시간에 정적으로
+                     검색 가능해야 하므로 더 제한적인 MSBuild 모드이나,
+                     대규모 프로젝트를 빌드할 경우 예약을 개선하고
                      메모리 오버헤드를 줄일 수 있습니다.
                      (약식: -isolate)
 
@@ -173,9 +182,9 @@
         <target state="translated">  -graphBuild[:True|False]
                      MSBuild가 프로젝트 그래프를 생성 및 빌드하도록 합니다.
 
-                     그래프 생성에는 종속성을 형성하기 위한 프로젝트 
-                     참조 식별이 관련됩니다. 해당 그래프 빌드에는 프로젝트 
-                     참조를 참조하는 프로젝트 전에 프로젝트 참조를 
+                     그래프 생성에는 종속성을 형성하기 위한 프로젝트
+                     참조 식별이 관련됩니다. 해당 그래프 빌드에는 프로젝트
+                     참조를 참조하는 프로젝트 전에 프로젝트 참조를
                      빌드하는 시도가 관련되며, 이는 기존 MSBuild
                      예약과 다릅니다.
                      (약식: -graph)
@@ -229,7 +238,7 @@
         <target state="translated">  -lowPriority[:True|False]
                      MSBuild가 낮은 프로세스 우선 순위로 실행됩니다.
 
-                     -lowPriority를 지정하는 것은 
+                     -lowPriority를 지정하는 것은
                      -lowPriority:True를 지정하는 것과 같습니다.
                      (약식: -low)
     </target>
@@ -333,11 +342,11 @@
                      (1) the directory of msbuild.exe
                      (2) the directory of the first project or solution built
 </source>
-        <target state="translated">  @&lt;file&gt;            텍스트 파일에서 명령줄 설정을 삽입합니다. 
-                     여러 지시 파일을 지정하려면 각 지시 파일을 개별적으로 
+        <target state="translated">  @&lt;file&gt;            텍스트 파일에서 명령줄 설정을 삽입합니다.
+                     여러 지시 파일을 지정하려면 각 지시 파일을 개별적으로
                      지정합니다.
 
-                     "msbuild.rsp"라는 지시 파일이 다음 위치에서 
+                     "msbuild.rsp"라는 지시 파일이 다음 위치에서
                      자동으로 사용됩니다.
                      (1) msbuild.exe의 디렉터리
                      (2) 빌드된 첫 번째 프로젝트 또는 솔루션의 디렉터리
@@ -374,8 +383,8 @@
                      Example:
                        -target:Resources;Compile
 </source>
-        <target state="translated">  -target:&lt;targets&gt;  이 프로젝트에서 대상을 빌드합니다. 세미콜론 또는 쉼표를 사용하여 
-                     여러 대상을 구분하거나, 각 대상을 
+        <target state="translated">  -target:&lt;targets&gt;  이 프로젝트에서 대상을 빌드합니다. 세미콜론 또는 쉼표를 사용하여
+                     여러 대상을 구분하거나, 각 대상을
                      개별적으로 지정합니다. (약식: -t)
                      예:
                        -target:Resources;Compile
@@ -397,9 +406,9 @@
                      Example:
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
-        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  프로젝트 수준 속성을 설정하거나 재정의합니다. &lt;n&gt;은 
-                     속성 이름이고 &lt;v&gt;는 속성 값입니다. 
-                     세미콜론 또는 쉼표를 사용하여 여러 속성을 구분하거나, 
+        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  프로젝트 수준 속성을 설정하거나 재정의합니다. &lt;n&gt;은
+                     속성 이름이고 &lt;v&gt;는 속성 값입니다.
+                     세미콜론 또는 쉼표를 사용하여 여러 속성을 구분하거나,
                      각 속성을 개별적으로 지정합니다. (약식: -p)
                      예:
                        -property:WarningLevel=2;OutDir=bin\Debug\
@@ -584,10 +593,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate          기본 스키마를 기준으로 프로젝트의 유효성을 검사합니다. 
+        <target state="translated">  -validate          기본 스키마를 기준으로 프로젝트의 유효성을 검사합니다.
                      (약식: -val)
 
-  -validate:&lt;schema&gt; 지정된 스키마를 기준으로 프로젝트의 유효성을 검사합니다. 
+  -validate:&lt;schema&gt; 지정된 스키마를 기준으로 프로젝트의 유효성을 검사합니다.
                      (약식: -val)
                      예:
                        -validate:MyExtendedBuildSchema.xsd
@@ -644,12 +653,11 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     MSBuild가 빌드 결과를 읽는 소스 입력 캐시 파일의 
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     MSBuild가 빌드 결과를 읽는 소스 입력 캐시 파일의
                      세미콜론으로 구분된 목록입니다.
                      이 스위치를 설정하면 격리된 빌드(-isolate)도 켜집니다.
                      (약식: -irc)
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      MSBuild에서 빌드 마지막에 빌드 결과 캐시의
                      콘텐츠를 쓰는 출력 캐시 파일입니다.
                      설정하면 격리된 빌드에서도 설정됩니다(-isolate).
@@ -739,8 +747,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensions&gt;
-                     빌드할 프로젝트 파일을 결정할 때 
-                     무시할 확장 목록입니다. 여러 확장을 구분하는 데는 
+                     빌드할 프로젝트 파일을 결정할 때
+                     무시할 확장 목록입니다. 여러 확장을 구분하는 데는
                      세미콜론 또는 쉼표를 사용합니다.
                      (약식: -ignore)
                      예:
@@ -766,7 +774,7 @@
    </source>
         <target state="translated">  -toolsVersion:&lt;version&gt;
                      빌드 중에 사용할 MSBuild 도구 세트(작업, 대상 등)의 버전입니다.
-                     이 버전은 개별 프로젝트에서 지정한 버전을 
+                     이 버전은 개별 프로젝트에서 지정한 버전을
                      재정의합니다. (약식:
                      -tv)
                      예:
@@ -795,9 +803,9 @@
                      파일은 현재 디렉터리에 있고
                      "msbuild[n].log"로 이름이 지정되어 있습니다. 모든 노드의 이벤트는 단일 로그로
                      결합됩니다. 파일의 위치 및 fileLogger의
-                     다른 매개 변수는 "-fileLoggerParameters[n]" 스위치를 
+                     다른 매개 변수는 "-fileLoggerParameters[n]" 스위치를
                      추가하여 지정할 수 있습니다.
-                     "n"은 1-9 사이의 숫자일 수 있으며 최대 10개의 
+                     "n"은 1-9 사이의 숫자일 수 있으며 최대 10개의
                      파일 로거가 추가될 수 있습니다. (약식: -fl[n])
     </target>
         <note>
@@ -824,16 +832,16 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     MSBuild 노드당 로그 파일 하나씩, 여러 로그 파일에 빌드 출력을 
-                     기록합니다. 해당 파일의 초기 위치는 
-                     현재 디렉터리입니다. 기본적으로 해당 파일을 
-                     "MSBuild&lt;nodeid&gt;.log"라고 합니다. 파일 위치 및 fileLogger의 기타 매개 변수는 
-                     "-fileLoggerParameters" 스위치를 추가해서 
+                     MSBuild 노드당 로그 파일 하나씩, 여러 로그 파일에 빌드 출력을
+                     기록합니다. 해당 파일의 초기 위치는
+                     현재 디렉터리입니다. 기본적으로 해당 파일을
+                     "MSBuild&lt;nodeid&gt;.log"라고 합니다. 파일 위치 및 fileLogger의 기타 매개 변수는
+                     "-fileLoggerParameters" 스위치를 추가해서
                      지정할 수 있습니다.
 
-                     로그 파일 이름이 fileLoggerParameters 스위치를 통해 설정되면 
-                     배포된 로거가 fileName을 템플릿으로 사용하고 
-                     노드 ID를 이 fileName에 추가하여 
+                     로그 파일 이름이 fileLoggerParameters 스위치를 통해 설정되면
+                     배포된 로거가 fileName을 템플릿으로 사용하고
+                     노드 ID를 이 fileName에 추가하여
                      각 노드의 로그 파일을 만듭니다.
     </target>
         <note>
@@ -877,20 +885,20 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parameters&gt;
                      파일 로거의 추가 매개 변수를 제공합니다.
-                     이 스위치가 있다는 것은 
+                     이 스위치가 있다는 것은
                      해당 fileLogger[n] 스위치를 의미합니다.
                      "n"(있는 경우)은 1~9의 숫자일 수 있습니다.
-                     -fileLoggerParameters는 배포된 파일 로거에서도 
+                     -fileLoggerParameters는 배포된 파일 로거에서도
                      사용됩니다. -distributedFileLogger에 대한 설명을 참조하세요.
                      (약식: -flp[n])
                      콘솔 로거용으로 나열된 동일한 매개 변수를 사용할 수 있습니다.
                      다음과 같은 몇 가지 추가 매개 변수를 사용할 수 있습니다.
-                        LogFile--빌드 로그가 기록되는 
+                        LogFile--빌드 로그가 기록되는
                             로그 파일의 경로입니다.
-                        Append--빌드 로그가 로그 파일에 추가되는지, 
-                            아니면 로그 파일을 덮어쓰는지 여부를 결정합니다. 
+                        Append--빌드 로그가 로그 파일에 추가되는지,
+                            아니면 로그 파일을 덮어쓰는지 여부를 결정합니다.
                             스위치를 설정하면 빌드 로그가 로그 파일에 추가됩니다.
-                            스위치를 설정하지 않으면 기존 로그 파일의 
+                            스위치를 설정하지 않으면 기존 로그 파일의
                             콘텐츠를 덮어씁니다.
                             기본값은 로그 파일에 추가하지 않는 것입니다.
                         Encoding--파일의 인코딩을 지정합니다
@@ -927,7 +935,7 @@
         <target state="translated">  -nodeReuse:&lt;parameters&gt;
                      MSBuild 노드를 다시 사용하거나 다시 사용하지 않도록 설정합니다.
                      매개 변수는 다음가 같습니다.
-                     True --빌드 완료 후 노드가 유지되고 
+                     True --빌드 완료 후 노드가 유지되고
                             후속 빌드에서 다시 사용됩니다(기본값).
                      False--빌드 완료 후 노드가 유지되지 않습니다.
                      (약식: -nr)
@@ -1024,11 +1032,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: 프로젝트 격리 값이 유효하지 않습니다. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: 프로젝트 격리 값이 유효하지 않습니다. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1692,10 +1701,10 @@
     </source>
         <target state="translated">  -restore[:True|False]
                      다른 대상을 빌드하기 전에 Restore라는 대상을
-                     실행하고 이러한 대상의 빌드에 최신 복원된 
-                     빌드 논리가 사용되는지 확인합니다. 
-                     프로젝트 트리를 빌드하기 전에 
-                     프로젝트 트리에서 패키지를 복원해야 하는 
+                     실행하고 이러한 대상의 빌드에 최신 복원된
+                     빌드 논리가 사용되는지 확인합니다.
+                     프로젝트 트리를 빌드하기 전에
+                     프로젝트 트리에서 패키지를 복원해야 하는
                      경우에 유용합니다. -restore를 지정하는 것은
                      -restore:True를 지정하는 것과 동일합니다. 이 매개 변수를 사용하여
                      지시 파일에서 가져오는 값을 재정의할 수 있습니다.
@@ -1733,7 +1742,7 @@
     </source>
         <target state="translated">  -profileEvaluation:&lt;file&gt;
                      MSBuild 평가를 프로파일링하고 결과를 지정된 파일에 기록합니다.
-                     지정된 파일의 확장명이 '.md'이면 
+                     지정된 파일의 확장명이 '.md'이면
                      결과가 Markdown 형식으로 생성됩니다.
                      그렇지 않으면 탭으로 구분된 파일이 생성됩니다.
     </target>
@@ -1752,9 +1761,9 @@
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                     복원하는 동안 프로젝트 수준 속성만 설정하거나 
-                     재정의하고, -property 인수로 지정된 속성을 
-                     사용하지 않습니다. &lt;n&gt;은 속성 이름이고 
+                     복원하는 동안 프로젝트 수준 속성만 설정하거나
+                     재정의하고, -property 인수로 지정된 속성을
+                     사용하지 않습니다. &lt;n&gt;은 속성 이름이고
                      &lt;v&gt;는 속성 값입니다.
                      세미콜론 또는 쉼표를 사용하여 여러 속성을 구분하거나,
                      각 속성을 개별적으로 지정합니다.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index b25931898c2..acd8432703f 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -122,7 +122,7 @@
                      interakcyjność nie jest oczekiwana.
                      Podanie parametru -interactive jest równoznaczne
                      z podaniem parametru -interactive:true. Użyj tego
-                     parametru, aby przesłonić wartość pochodzącą z pliku 
+                     parametru, aby przesłonić wartość pochodzącą z pliku
                      odpowiedzi.
     </target>
         <note>
@@ -131,9 +131,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -142,8 +151,8 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
-                     Powoduje, że program MSBuild kompiluje każdy projekt                        
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
+                     Powoduje, że program MSBuild kompiluje każdy projekt
                      w sposób izolowany.
 
                      Jest to bardziej restrykcyjny tryb programu MSBuild, ponieważ
@@ -175,7 +184,7 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -graphBuild[:True|False]
-                     Powoduje, że program MSBuild tworzy i kompiluje graf                 
+                     Powoduje, że program MSBuild tworzy i kompiluje graf
                      projektu.
 
                      Tworzenie grafu obejmuje identyfikowanie odwołań do
@@ -275,7 +284,7 @@
     </source>
         <target state="translated">
  -warnNotAsError[:code[;code2]]
- Lista kodów ostrzeżeń, które mają być traktowane jako błędy. 
+ Lista kodów ostrzeżeń, które mają być traktowane jako błędy.
  Rozdziel średnik lub przecinek
  wiele kodów ostrzeżeń. Nie ma żadnego efektu, jeśli przełącznik -warnaserror
                      switch is not set.
@@ -345,7 +354,7 @@
                      osobno.
 
                      Wszelkie pliki odpowiedzi o nazwie „msbuild.rsp” będą automatycznie
-                     wykorzystywane z następujących lokalizacji: 
+                     wykorzystywane z następujących lokalizacji:
                      (1) katalog programu msbuild.exe
                      (2) katalog pierwszej kompilacji projektu lub rozwiązania
 </target>
@@ -654,11 +663,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;plik pamięci podręcznej&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;plik pamięci podręcznej&gt;...
                      Rozdzielana średnikami lista wejściowych plików pamięci podręcznej, z których program MSBuild
                      będzie odczytywać wyniki kompilacji.
                      Ustawienie tej opcji włącza też kompilacje izolowane (-isolate).
@@ -673,10 +681,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[plik pamięci podręcznej]
+        <target state="needs-review-translation">  -outputResultsCache:[plik pamięci podręcznej]
                      Plik pamięci podręcznej, w którym program MSBuild zapisze zawartość
                      swoich pamięci podręcznych wyników kompilacji po zakończeniu kompilacji.
                      Ustawienie tej opcji włącza też kompilacje izolowane (-isolate).
@@ -898,7 +906,7 @@
                      Dostępne są parametry takie same, jak podane dla rejestratora
                      konsoli. Dostępne są również dodatkowe parametry:
                        LogFile — ścieżka do pliku dziennika, w którym będzie
-                                 zapisywany dziennik kompilacji. 
+                                 zapisywany dziennik kompilacji.
                        Append — określa, czy plik dziennika kompilacji zostanie
                                 dołączony do pliku dziennika, czy go zastąpi.
                                 Ustawienie tego przełącznika powoduje dołączenie dziennika kompilacji
@@ -912,8 +920,8 @@
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1036,11 +1044,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: Wartość projektów izolacji jest nieprawidłowa. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: Wartość projektów izolacji jest nieprawidłowa. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1704,10 +1713,10 @@ dzienników                     tekstowych i wykorzystać w innych narzędziach
     </source>
         <target state="translated">  -restore[:True|False]
                      Uruchamia element docelowy o nazwie Restore przed skompilowaniem
-                     innych elementów docelowych i zapewnia, że kompilacja tych 
-                     elementów docelowych korzysta z najnowszej logiki przywróconej 
-                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga 
-                     przywrócenia pakietów przed ich skompilowaniem. Podanie parametru 
+                     innych elementów docelowych i zapewnia, że kompilacja tych
+                     elementów docelowych korzysta z najnowszej logiki przywróconej
+                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga
+                     przywrócenia pakietów przed ich skompilowaniem. Podanie parametru
                      -restore jest równoznaczne z podaniem parametru -restore:True.
                      Za pomocą tego parametru można przesłonić wartość pochodzącą
                      z pliku odpowiedzi.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 690d79cd062..8ef4d8c30d2 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -131,9 +131,18 @@ arquivo de resposta.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -142,8 +151,8 @@ arquivo de resposta.
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
-                     Faz o MSBuild compilar cada projeto 
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
+                     Faz o MSBuild compilar cada projeto
 isoladamente.
                      Esse é um modo mais restritivo do MSBuild, pois requer
                      que o gráfico do projeto seja estatisticamente detectável no
@@ -609,10 +618,10 @@ isoladamente.
                      MSBuild will use up to the number of processors on the
                      computer. (Short form: -m[:n])
       </source>
-        <target state="translated">  -maxCpuCount[:n] Especifica o número máximo de processos simultâneos a serem 
+        <target state="translated">  -maxCpuCount[:n] Especifica o número máximo de processos simultâneos a serem
                      compilados. Se a opção não for usada, o valor padrão
                      usado será 1. Se a opção for usada sem um valor, o
-                     MSBuild usará o número de processadores do 
+                     MSBuild usará o número de processadores do
                      computador. (Forma abreviada: -m[:n])
       </target>
         <note>
@@ -630,7 +639,7 @@ isoladamente.
         <target state="translated">Exemplos:
 
         MSBuild MyApp.sln -t:Rebuild -p:Configuration=Release
-        MSBuild MyApp.csproj -t:Clean 
+        MSBuild MyApp.csproj -t:Clean
                              -p:Configuration=Debug;TargetFrameworkVersion=v3.5
     </target>
         <note>
@@ -645,11 +654,10 @@ isoladamente.
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
                      Lista separada por ponto e vírgula de arquivos de cache de entrada dos quais o MSBuild
                      lerá os resultados do build.
                      A definição dessa opção também habilita os builds isolados (-isolate).
@@ -664,10 +672,10 @@ isoladamente.
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      Arquivo de cache de saída no qual o MSBuild gravará o conteúdo
                      dos caches de resultado do build no final do build.
                      A configuração dessa opção também habilita builds isolado (-isolate).
@@ -793,12 +801,12 @@ isoladamente.
                      10 file loggers to be attached. (Short form: -fl[n])
     </source>
         <target state="translated">  -fileLogger[n] Registra a saída do build em um arquivo. Por padrão,
-                     o arquivo está no diretório atual e tem o nome 
+                     o arquivo está no diretório atual e tem o nome
                      "msbuild[n].log". Os eventos de todos os nós são combinados em
                      um único log. A localização do arquivo e outros
-                     parâmetros do fileLogger pode ser especificada por meio 
+                     parâmetros do fileLogger pode ser especificada por meio
                      do acréscimo da opção "-fileLoggerParameters[n]".
-                     "n", se presente, pode ser um dígito de 1 a 9, permitindo que até 
+                     "n", se presente, pode ser um dígito de 1 a 9, permitindo que até
                      10 agentes de arquivo sejam anexados. (Forma abreviada: -fl[n])
     </target>
         <note>
@@ -951,14 +959,14 @@ isoladamente.
                      Example:
                        -pp:out.txt
     </source>
-        <target state="translated">  -preprocess[:arquivo] 
+        <target state="translated">  -preprocess[:arquivo]
                      Cria um arquivo de projeto único e agregado
                      embutindo todos os arquivos que poderiam ser importados durante um
                      build, com seus limites marcados. Isso pode ser
                      útil para descobrir quais arquivos são importados,
                      de qual localização e como contribuirão para
                      o build. Por padrão, a saída é gravada na
-                     janela do console. Se o caminho de um arquivo de saída 
+                     janela do console. Se o caminho de um arquivo de saída
                      for fornecido, ele será usado.
                      (Forma abreviada: -pp)
                      Exemplo:
@@ -1025,11 +1033,12 @@ isoladamente.
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: O valor de projetos isolados não é válido. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: O valor de projetos isolados não é válido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1538,7 +1547,7 @@ isoladamente.
                        -warnAsError:MSB4130
 
                      Quando um aviso for tratado como um erro, o destino continuará
-                     a ser executado como se ele fosse um aviso, mas o 
+                     a ser executado como se ele fosse um aviso, mas o
                      build geral falhará.
     </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 3e778b63862..252b68b4885 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -129,9 +129,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -140,7 +149,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Сообщает MSBuild, что нужно собирать каждый проект по отдельности.
 
                      Это более строгий режим MSBuild, так как он требует,
@@ -643,11 +652,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;файл_кэша&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;файл_кэша&gt;...
                      Разделенный точкам с запятой список входных файлов кэша, откуда MSBuild
                      будет считывать результаты.
                      Задание этого параметра также включает изолированные сборки (-isolate).
@@ -662,10 +670,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[файл_кэша]
+        <target state="needs-review-translation">  -outputResultsCache:[файл_кэша]
                      Выходной файл кэша, где MSBuild будет записывать содержимое
                      результата кэша сборки в конце.
                      При задании этого параметра также включаются изолированные сборки (-isolate).
@@ -1023,11 +1031,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: значение изолирования проектов является недопустимым. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: значение изолирования проектов является недопустимым. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index acbff27d93c..4ff9206f999 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -120,7 +120,7 @@
                      izin verildiğini gösterir.  Etkileşimin beklenmediği
                      otomatik bir senaryoda bu bağımsız değişkeni
                      kullanmayın.
-                     -interactive değerinin belirtilmesi, -interactive:true 
+                     -interactive değerinin belirtilmesi, -interactive:true
                      değerinin belirtilmesiyle aynıdır.  Parametreyi, yanıt
                      dosyasından gelen bir değeri geçersiz kılmak için kullanın.
     </target>
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      MSBuild tarafından her projenin yalıtılmış olarak oluşturulmasına yol açar.
 
                      Bu mod, değerlendirme sırasında proje grafiğinin
@@ -397,7 +406,7 @@
                      Example:
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
-        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Bu proje düzeyi özellikleri ayarlayın veya geçersiz kılın. &lt;n&gt; 
+        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Bu proje düzeyi özellikleri ayarlayın veya geçersiz kılın. &lt;n&gt;
                      özelliğin adı ve &lt;v&gt; özelliğin değeridir. Birden çok
                      özelliği birbirinden ayırmak için noktalı virgül veya virgül
                      kullanın veya her özelliği ayrı ayrı belirtin. (Kısa biçim: -p)
@@ -438,7 +447,7 @@
                      &lt;günlükçü derlemesi&gt; söz dizimi şöyledir:
                        {&lt;derleme adı&gt;[,&lt;strong name&gt;] | &lt;derleme dosyası&gt;}
                      Günlükçü seçenekleri, MSBuild'in günlükçüyü oluşturma biçimini belirtir.
-                     &lt;günlükçü parametreleri &gt; isteğe bağlıdır ve tam olarak 
+                     &lt;günlükçü parametreleri &gt; isteğe bağlıdır ve tam olarak
                      yazdığınız şekliyle günlükçüye geçirilir. (Kısa biçim: -l)
                      Örnekler:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -644,11 +653,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;önbellekDosyası&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;önbellekDosyası&gt;...
                      MSBuild'in derleme sonuçlarını okuyacağı giriş
                      önbellek dosyalarının noktalı virgülle ayrılmış listesi.
                      Ayarlandığında yalıtılmış derlemeler de açılır (-isolate).
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[önbellekDosyası]
+        <target state="needs-review-translation">  -outputResultsCache:[önbellekDosyası]
                      MSBuild’in derleme sonunda derleme sonucu önbelleklerinin
                      içeriğini yazacağı çıkış önbellek dosyası.
                      Bu açıldığında yalıtılmış derlemeler (-isolate) de açılır.
@@ -739,9 +747,9 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantılar&gt;
-                     Hangi proje dosyasının oluşturulacağı belirlenirken 
-                     yoksayılacak uzantıların listesi. Birden çok uzantıyı 
-                     birbirinden ayırmak için noktalı virgül veya 
+                     Hangi proje dosyasının oluşturulacağı belirlenirken
+                     yoksayılacak uzantıların listesi. Birden çok uzantıyı
+                     birbirinden ayırmak için noktalı virgül veya
                      virgül kullanın.
                      (Kısa biçim: -ignore)
                      Örnek:
@@ -767,8 +775,8 @@
    </source>
         <target state="translated">  -toolsVersion:&lt;sürüm&gt;
                      Derleme sırasında kullanılacak MSBuild Araç Kümesinin
-                     (görevler, hedefler vb.) sürümü. Bu sürüm, tek tek projelerde 
-                     belirtilen sürümleri geçersiz kılar. (Kısa biçim: 
+                     (görevler, hedefler vb.) sürümü. Bu sürüm, tek tek projelerde
+                     belirtilen sürümleri geçersiz kılar. (Kısa biçim:
                      -tv)
                      Örnek:
                        -toolsVersion:3.5
@@ -827,14 +835,14 @@
         <target state="translated">  -distributedFileLogger
                      Derleme çıkışını, her MSBuild düğümü için bir günlük
                      dosyası olmak üzere birden çok günlük dosyasına kaydeder. Bu
-                     dosyaların ilk konumu geçerli dizindir. Dosyaların 
-                     varsayılan adı "MSBuild&lt;düğümkimliği&gt;.log"dur. 
-                     Dosyaların konumu ve fileLogger'ın diğer parametreleri 
+                     dosyaların ilk konumu geçerli dizindir. Dosyaların
+                     varsayılan adı "MSBuild&lt;düğümkimliği&gt;.log"dur.
+                     Dosyaların konumu ve fileLogger'ın diğer parametreleri
                      "/fileLoggerParameters" anahtarının eklenmesi yoluyla
                      belirtilebilir.
 
                      Günlük dosyası adı fileLoggerParameters anahtarı
-                     aracılığıyla ayarlanırsa dağıtılmış günlükçü fileName 
+                     aracılığıyla ayarlanırsa dağıtılmış günlükçü fileName
                      değerini şablon olarak kullanıp her düğümün günlük dosyasını
                      oluşturmak için bu fileName değerine düğüm kimliğini ekler.
     </target>
@@ -879,32 +887,32 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya günlükçüleri için ek parametreler sağlar.
-                     Bu anahtarın olması karşılık gelen -fileLogger[n] 
+                     Bu anahtarın olması karşılık gelen -fileLogger[n]
                      anahtarının olduğu anlamına gelir.
                      "n" varsa, 1-9 arasında bir rakam olabilir.
-                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters 
-                     bunlar tarafından da kullanılır; -distributedFileLogger 
+                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters
+                     bunlar tarafından da kullanılır; -distributedFileLogger
                      açıklamasına bakın.
                      (Kısa biçim: -flp[n])
-                     Konsol günlükçüsü için listelenenlerle aynı parametreler 
+                     Konsol günlükçüsü için listelenenlerle aynı parametreler
                      kullanılabilir. Kullanılabilecek bazı ek parametreler:
-                        LogFile--Oluşturma günlüğünün yazılacağı günlük 
+                        LogFile--Oluşturma günlüğünün yazılacağı günlük
                             dosyasının yolu.
-                        Append--Derleme günlüğünün gün dosyasının sonuna mı 
-                            ekleneceğini yoksa üzerine mi yazılacağını 
-                            belirler. Anahtar ayarlandığında oluşturma günlüğü 
-                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında 
-                            varolan günlük dosyasının üzerine yazılır. 
+                        Append--Derleme günlüğünün gün dosyasının sonuna mı
+                            ekleneceğini yoksa üzerine mi yazılacağını
+                            belirler. Anahtar ayarlandığında oluşturma günlüğü
+                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında
+                            varolan günlük dosyasının üzerine yazılır.
                             Varsayılan: günlük dosyasının sonuna eklenmez.
-                        Encoding--Dosyanın kodlamasını belirtir; örneğin, 
+                        Encoding--Dosyanın kodlamasını belirtir; örneğin,
                             UTF-8, Unicode veya ASCII
                      Varsayılan ayrıntı düzeyi ayarı Detailed'dır.
                      Örnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1028,11 +1036,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: Projeleri yalıtma değeri geçerli değil. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: Projeleri yalıtma değeri geçerli değil. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index ac8ff48e194..a5ec18908f5 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      使 MSBuild 独立生成每个项目。
 
                      这是 MSBuild 更具限制性的模式，因为它要求
@@ -584,10 +593,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate     依据默认架构验证项目。(缩写: 
+        <target state="translated">  -validate     依据默认架构验证项目。(缩写:
            -val)
 
- -validate:&lt;schema&gt; 依据指定的架构验证项目。(缩写: 
+ -validate:&lt;schema&gt; 依据指定的架构验证项目。(缩写:
            -val)
            示例:
             -validate:MyExtendedBuildSchema.xsd
@@ -644,11 +653,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
                      输入缓存文件的分号分隔列表，MSBuild
                      将从这些文件中读取生成结果。
                      设置此列表还将打开分隔的生成(-isolate)。
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      输出缓存文件，MSBuild 将在
                      生成结束时写入其生成结果缓存的内容。
                      设置它也会打开隔离的生成 (-isolate).
@@ -767,7 +775,7 @@
         <target state="translated">  -toolsversion:&lt;version&gt;
            要在生成过程中使用的 MSBuild 工具集
            (任务、目标等)的版本。此版本将重写
-           各个项目指定的版本。(缩写: 
+           各个项目指定的版本。(缩写:
            -tv)
            示例:
             -toolsversion:3.5
@@ -823,17 +831,17 @@
                      template and append the node id to this fileName to
                      create a log file for each node.
     </source>
-        <target state="translated">  -distributedFileLogger                            
+        <target state="translated">  -distributedFileLogger
            将生成输出记录到多个日志文件，每个 MSBuild 节点
            一个日志文件。这些文件的初始位置为
            当前目录。默认情况下，这些文件名为
            “MSBuild&lt;nodeid&gt;.log”。可通过添加
-           “-fileLoggerParameters”开关来指定 
+           “-fileLoggerParameters”开关来指定
            这些文件的位置和 fileLogger 的其他参数。
 
            如果日志文件名是通过 fileLoggerParameters
            开关设置的，分布式记录器将使用 fileName 作为
-           模板并将节点 ID 附加到此 fileName 
+           模板并将节点 ID 附加到此 fileName
            以便为每个节点创建一个日志文件。
     </target>
         <note>
@@ -875,12 +883,12 @@
                        -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </source>
-        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;                
+        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;
            为文件记录器提供任何额外的参数。
            存在此开关意味着
            存在对应的 -filelogger[n] 开关。
           “n”(如果存在)可以为 1-9 的数字。
-           任何分布式文件记录器也可以使用 
+           任何分布式文件记录器也可以使用
            -fileloggerparameters，具体可参阅 -distributedFileLogger 的说明。
            (缩写: -flp[n])
            为控制台记录器列出的相同参数
@@ -900,8 +908,8 @@
             -fileLoggerParameters:LogFile=MyLog.log;Append;
                       Verbosity=diagnostic;Encoding=UTF-8
 
-            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-            -flp1:warningsonly;logfile=msbuild.wrn 
+            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+            -flp1:warningsonly;logfile=msbuild.wrn
             -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1024,11 +1032,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: 独立项目值无效。{0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: 独立项目值无效。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index b2f5a5a0110..521bc7fb13b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      引發 MSBuild 獨立建置各個專案。
 
                      這是限制度較高的 MSBuild 模式，因為
@@ -644,11 +653,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;快取檔案&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;快取檔案&gt;...
                      以分號分隔的輸入快取檔案
                       (MSBuild 將會從此檔案讀取建置結果) 清單。
                      設定此項目也會開啟隔離式建置 (-isolate)。
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      MSBuild 要在組建結束時寫入
                      其組建結果快取內容的目標輸出快取檔案。
                      設定此項也會開啟隔離組建 (-isolate)。
@@ -766,8 +774,8 @@
    </source>
         <target state="translated">  -toolsversion:&lt;版本&gt;
                      建置期間所使用的 MSBuild 工具組 (工作、目標等)
-                      版本。此版本將會覆寫 
-                     個別專案所指定的版本。(簡短形式: 
+                      版本。此版本將會覆寫
+                     個別專案所指定的版本。(簡短形式:
                      -tv)
                      範例:
                        -toolsVersion:3.5
@@ -1024,11 +1032,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: 獨立式專案值無效。{0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: 獨立式專案值無效。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index f2ef7143789..92d64fc8401 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -38,7 +38,7 @@
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Logging.FancyLogger;
+using Microsoft.Build.Logging.LiveLogger;
 using System.Runtime.InteropServices;
 
 #nullable disable
@@ -701,7 +701,7 @@ public static ExitType Execute(
                 ProfilerLogger profilerLogger = null;
                 bool enableProfiler = false;
                 bool interactive = false;
-                bool isolateProjects = false;
+                ProjectIsolationMode isolateProjects = ProjectIsolationMode.False;
                 GraphBuildOptions graphBuildOptions = null;
                 bool lowPriority = false;
                 string[] inputResultsCaches = null;
@@ -1118,7 +1118,7 @@ internal static bool BuildProject(
             ProfilerLogger profilerLogger,
             bool enableProfiler,
             bool interactive,
-            bool isolateProjects,
+            ProjectIsolationMode isolateProjects,
             GraphBuildOptions graphBuildOptions,
             bool lowPriority,
             string[] inputResultsCaches,
@@ -1289,7 +1289,7 @@ internal static bool BuildProject(
                     parameters.WarningsNotAsErrors = warningsNotAsErrors;
                     parameters.WarningsAsMessages = warningsAsMessages;
                     parameters.Interactive = interactive;
-                    parameters.IsolateProjects = isolateProjects;
+                    parameters.ProjectIsolationMode = isolateProjects;
                     parameters.InputResultsCacheFiles = inputResultsCaches;
                     parameters.OutputResultsCacheFile = outputResultsCache;
 
@@ -2210,7 +2210,7 @@ private static bool ProcessCommandLineSwitches(
             ref ProfilerLogger profilerLogger,
             ref bool enableProfiler,
             ref Dictionary<string, string> restoreProperties,
-            ref bool isolateProjects,
+            ref ProjectIsolationMode isolateProjects,
             ref GraphBuildOptions graphBuild,
             ref string[] inputResultsCaches,
             ref string outputResultsCache,
@@ -2385,7 +2385,7 @@ private static bool ProcessCommandLineSwitches(
 
                     if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.IsolateProjects))
                     {
-                        isolateProjects = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.IsolateProjects], defaultValue: true, resourceName: "InvalidIsolateProjectsValue");
+                        isolateProjects = ProcessIsolateProjectsSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.IsolateProjects]);
                     }
 
                     if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GraphBuild))
@@ -2406,7 +2406,7 @@ private static bool ProcessCommandLineSwitches(
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
-                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.FancyLogger],
+                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.LiveLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
@@ -2526,6 +2526,39 @@ private static bool WarningsAsErrorsSwitchIsEmpty(CommandLineSwitches commandLin
             return indexOfColon < 0 || indexOfColon == val.Length - 1;
         }
 
+        internal static ProjectIsolationMode ProcessIsolateProjectsSwitch(string[] parameters)
+        {
+
+            // Before /isolate had parameters, it was treated as a boolean switch.
+            // Preserve that in case anyone is using /isolate:{false|true}
+            if (parameters.Length == 1 && bool.TryParse(parameters[0], out bool boolValue))
+            {
+                return boolValue ? ProjectIsolationMode.True : ProjectIsolationMode.False;
+            }
+
+            ProjectIsolationMode isolateProjects = ProjectIsolationMode.True;
+            foreach (string parameter in parameters)
+            {
+                if (string.IsNullOrWhiteSpace(parameter))
+                {
+                    continue;
+                }
+
+                string trimmedParameter = parameter.Trim();
+                if (trimmedParameter.Equals(nameof(ProjectIsolationMode.MessageUponIsolationViolation), StringComparison.OrdinalIgnoreCase)
+                    || trimmedParameter.Equals("Message", StringComparison.OrdinalIgnoreCase))
+                {
+                    isolateProjects = ProjectIsolationMode.MessageUponIsolationViolation;
+                }
+                else
+                {
+                    CommandLineSwitchException.Throw("InvalidIsolateProjectsValue", parameter);
+                }
+            }
+
+            return isolateProjects;
+        }
+
         internal static GraphBuildOptions ProcessGraphBuildSwitch(string[] parameters)
         {
             var options = new GraphBuildOptions();
@@ -3187,7 +3220,7 @@ private static ILogger[] ProcessLoggingSwitches(
             string[] verbositySwitchParameters,
             bool noConsoleLogger,
             bool distributedFileLogger,
-            bool fancyLoggerCommandLineOptIn,
+            bool liveLoggerCommandLineOptIn,
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
@@ -3217,9 +3250,11 @@ private static ILogger[] ProcessLoggingSwitches(
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
 
             // Choose default console logger
-            if ((fancyLoggerCommandLineOptIn || Environment.GetEnvironmentVariable("MSBUILDFANCYLOGGER") == "true") && DoesEnvironmentSupportFancyLogger())
+            if (
+                (liveLoggerCommandLineOptIn || Environment.GetEnvironmentVariable("MSBUILDFANCYLOGGER") == "true" || Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER") == "true")
+                && DoesEnvironmentSupportLiveLogger())
             {
-                ProcessFancyLogger(noConsoleLogger, loggers);
+                ProcessLiveLogger(noConsoleLogger, loggers);
             }
             else
             {
@@ -3233,7 +3268,7 @@ private static ILogger[] ProcessLoggingSwitches(
             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref verbosity);
 
             // TOOD: Review
-            // ProcessFancyLogger(noConsoleLogger, loggers);
+            // ProcessLiveLogger(noConsoleLogger, loggers);
 
             profilerLogger = ProcessProfileEvaluationSwitch(profileEvaluationParameters, loggers, out enableProfiler);
 
@@ -3398,13 +3433,13 @@ internal static void ProcessConsoleLoggerSwitch(
             }
         }
 
-        private static bool DoesEnvironmentSupportFancyLogger()
+        private static bool DoesEnvironmentSupportLiveLogger()
         {
             // If output is redirected
             if (Console.IsOutputRedirected)
             {
                 messagesToLogInBuildLoggers.Add(
-                    new BuildManager.DeferredBuildMessage("FancyLogger was not used because the output is being redirected to a file.", MessageImportance.Low));
+                    new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is being redirected to a file.", MessageImportance.Low));
                 return false;
             }
             // If terminal is dumb
@@ -3413,20 +3448,20 @@ private static bool DoesEnvironmentSupportFancyLogger()
                 || Environment.GetEnvironmentVariable("TERM") == "dumb")
             {
                 messagesToLogInBuildLoggers.Add(
-                    new BuildManager.DeferredBuildMessage("FancyLogger was not used because the output is not supported.", MessageImportance.Low));
+                    new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is not supported.", MessageImportance.Low));
                 return false;
             }
             return true;
         }
 
-        private static void ProcessFancyLogger(
+        private static void ProcessLiveLogger(
             bool noConsoleLogger,
             List<ILogger> loggers)
         {
             // Check for flags and env variables
             if (!noConsoleLogger)
             {
-                FancyLogger l = new FancyLogger();
+                LiveLogger l = new LiveLogger();
                 loggers.Add(l);
             }
         }
diff --git a/src/Samples/Directory.Build.props b/src/Samples/Directory.Build.props
index 69f108f98e7..f04411fb004 100644
--- a/src/Samples/Directory.Build.props
+++ b/src/Samples/Directory.Build.props
@@ -1,9 +1,15 @@
 ﻿<Project>
 
+  <!--This should be before importing parent properties, as it affects the output directory (defined in arcade SDK) -->
   <PropertyGroup>
     <!-- Use Samples subdirectory for samples in output folder -->
     <OutDirName>Samples\$(MSBuildProjectName)</OutDirName>
+  </PropertyGroup>
+
+  <!-- Import parent props -->
+  <Import Project="..\Directory.Build.props"/>
 
+  <PropertyGroup>
     <!-- Don't regulate package versions for samples -->
     <ManagePackageVersionsCentrally>false</ManagePackageVersionsCentrally>
     <ImportDirectoryPackagesProps>false</ImportDirectoryPackagesProps>
@@ -12,7 +18,4 @@
     <ExcludeFromSourceBuild>true</ExcludeFromSourceBuild>
   </PropertyGroup>
 
-  <!-- Import parent props -->
-  <Import Project="..\Directory.Build.props"/>
-
 </Project>
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index b29b4238e8e..b8c1416aa96 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Shared.FileSystem;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -822,14 +823,9 @@ public void Regress162390()
         * Convert a short local path to a long path.
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForShortLocalPath()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"D:\LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -859,14 +855,9 @@ public void GetLongFileNameForLongLocalPath()
         * Convert a short UNC path to a long path.
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForShortUncPath()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"\\server\share\LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -896,14 +887,9 @@ public void GetLongFileNameForLongUncPath()
         * Convert a short relative path to a long path
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForRelativePath()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -917,14 +903,9 @@ public void GetLongFileNameForRelativePath()
         * Convert a short relative path with a trailing backslash to a long path
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForRelativePathPreservesTrailingSlash()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"LONGDI~1\LONGSU~1\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -938,14 +919,9 @@ public void GetLongFileNameForRelativePathPreservesTrailingSlash()
         * Convert a short relative path with doubled embedded backslashes to a long path
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForRelativePathPreservesExtraSlashes()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"LONGDI~1\\LONGSU~1\\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -959,14 +935,9 @@ public void GetLongFileNameForRelativePathPreservesExtraSlashes()
         * Only part of the path might be short.
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForMixedLongAndShort()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"c:\apple\banana\tomato\pomegr~1\orange\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -981,14 +952,9 @@ public void GetLongFileNameForMixedLongAndShort()
         * as if they were already a long file name.
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameWherePartOfThePathDoesntExist()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"c:\apple\banana\tomato\pomegr~1\orange\chocol~1\vanila~1",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -1338,7 +1304,6 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
             }
         }
 
-        [PlatformSpecific(TestPlatforms.Any)]
         [Theory]
         [InlineData(@"\", "**")]
         [InlineData(@"\\", "**")]
@@ -1350,8 +1315,7 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
         public void DriveEnumeratingWildcardIsObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
             DriveEnumeratingWildcardIsObserved(directoryPart, wildcardPart);
 
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"\", "**")]
         [InlineData(@"c:\", "**")]
         [InlineData(@"c:\\", "**")]
@@ -1366,8 +1330,7 @@ public void DriveEnumeratingWildcardIsObservedOnWindows(string directoryPart, st
         private void DriveEnumeratingWildcardIsObserved(string directoryPart, string wildcardPart) =>
             FileMatcher.IsDriveEnumeratingWildcardPattern(directoryPart, wildcardPart).ShouldBeTrue();
 
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"\", "**")]
         [InlineData("/", "**/*.cs")]
         [InlineData("/", "**")]
@@ -1415,8 +1378,7 @@ private void DriveEnumeratingWildcardFailsAndReturns(string directoryPart, strin
         }
 
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"z:\**")]
         [InlineData(@"z:\\**")]
         [InlineData(@"z:\\\\\\\\**")]
@@ -1453,7 +1415,6 @@ public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWil
             }
         }
 
-        [PlatformSpecific(TestPlatforms.Any)]
         [Theory]
         [InlineData(@"\", @"*\*.cs")]
         [InlineData(@"\\", @"*\*.cs")]
@@ -1464,8 +1425,7 @@ public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWil
         public void DriveEnumeratingWildcardIsNotObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
             DriveEnumeratingWildcardIsNotObserved(directoryPart, wildcardPart);
 
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"c:\", "**")]
         [InlineData(@"c:\\", "**")]
         [InlineData(@"c:\\\\\\\\", "**")]
@@ -1899,8 +1859,7 @@ public void GetFileSpecInfoCommon(
                 expectedIsLegalFileSpec);
         }
 
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         // Escape pecial regex characters valid in Windows paths
         [InlineData(
             @"$()+.[^{\?$()+.[^{\$()+.[^{",
@@ -1938,8 +1897,7 @@ public void GetFileSpecInfoWindows(
                 expectedIsLegalFileSpec);
         }
 
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         // Escape regex characters valid in Unix paths
         [InlineData(
             @"$()+.[^{|\?$()+.[^{|\$()+.[^{|",
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 199b46c85f1..86f2028956c 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -20,7 +21,6 @@ public class FileUtilities_Tests
         /// Exercises FileUtilities.ItemSpecModifiers.GetItemSpecModifier
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void GetItemSpecModifier()
@@ -150,9 +150,7 @@ public void MakeRelativeTests()
         /// <summary>
         /// Exercises FileUtilities.ItemSpecModifiers.GetItemSpecModifier on a bad path.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // On Unix there no invalid file name characters
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void GetItemSpecModifierOnBadPath()
         {
             Assert.Throws<InvalidOperationException>(() =>
@@ -163,9 +161,7 @@ public void GetItemSpecModifierOnBadPath()
         /// <summary>
         /// Exercises FileUtilities.ItemSpecModifiers.GetItemSpecModifier on a bad path.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // On Unix there no invalid file name characters
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void GetItemSpecModifierOnBadPath2()
         {
             Assert.Throws<InvalidOperationException>(() =>
@@ -219,7 +215,6 @@ public void GetFileInfoNoThrowNonexistent()
         /// Exercises FileUtilities.EndsWithSlash
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void EndsWithSlash()
@@ -244,7 +239,6 @@ public void EndsWithSlash()
         /// Exercises FileUtilities.GetDirectory
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void GetDirectoryWithTrailingSlash()
@@ -294,9 +288,7 @@ public void HasExtension_WhenFileNameDoesNotHaveExtension_ReturnsFalse(string fi
             Assert.False(result);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void HasExtension_WhenInvalidFileName_ThrowsArgumentException()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -417,8 +409,7 @@ public void CheckDerivableItemSpecModifiers()
             Assert.False(FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier("recursivedir"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void NormalizePathThatFitsIntoMaxPath()
         {
             string currentDirectory = @"c:\aardvark\aardvark\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890";
@@ -428,9 +419,7 @@ public void NormalizePathThatFitsIntoMaxPath()
             Assert.Equal(fullPath, FileUtilities.NormalizePath(Path.Combine(currentDirectory, filePath)));
         }
 
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/4363")]
+        [LongPathSupportDisabledFact(fullFrameworkOnly: true, additionalMessage: "https://github.com/dotnet/msbuild/issues/4363")]
         public void NormalizePathThatDoesntFitIntoMaxPath()
         {
             Assert.Throws<PathTooLongException>(() =>
@@ -445,8 +434,7 @@ public void NormalizePathThatDoesntFitIntoMaxPath()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetItemSpecModifierRootDirThatFitsIntoMaxPath()
         {
             string currentDirectory = @"c:\aardvark\aardvark\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890";
@@ -474,9 +462,7 @@ public void NormalizePathEmpty()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void NormalizePathBadUNC1()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -485,9 +471,7 @@ public void NormalizePathBadUNC1()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void NormalizePathBadUNC2()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -496,9 +480,7 @@ public void NormalizePathBadUNC2()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void NormalizePathBadUNC3()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -507,15 +489,13 @@ public void NormalizePathBadUNC3()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void NormalizePathGoodUNC()
         {
             Assert.Equal(@"\\localhost\share", FileUtilities.NormalizePath(@"\\localhost\share"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void NormalizePathTooLongWithDots()
         {
             string longPart = new string('x', 300);
@@ -523,8 +503,7 @@ public void NormalizePathTooLongWithDots()
         }
 
 #if FEATURE_LEGACY_GETFULLPATH
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/4205")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/4205")]
         public void NormalizePathBadGlobalroot()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -542,9 +521,7 @@ From Path.cs
         }
 #endif
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void NormalizePathInvalid()
         {
             string filePath = @"c:\aardvark\|||";
@@ -555,8 +532,7 @@ public void NormalizePathInvalid()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void CannotNormalizePathWithNewLineAndSpace()
         {
             string filePath = "\r\n      C:\\work\\sdk3\\artifacts\\tmp\\Debug\\SimpleNamesWi---6143883E\\NETFrameworkLibrary\\bin\\Debug\\net462\\NETFrameworkLibrary.dll\r\n      ";
@@ -595,7 +571,6 @@ public void FileOrDirectoryExistsNoThrow()
         // These tests will need to be redesigned for Linux
 
         [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
-        [Trait("Category", "mono-osx-failing")]
         public void FileOrDirectoryExistsNoThrowTooLongWithDots()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3)).Length;
@@ -611,7 +586,6 @@ public void FileOrDirectoryExistsNoThrowTooLongWithDots()
         }
 
         [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
-        [Trait("Category", "mono-osx-failing")]
         public void FileOrDirectoryExistsNoThrowTooLongWithDotsRelative()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3)).Length;
@@ -665,7 +639,6 @@ public void DirectoryExistsNoThrowTooLongWithDots()
         }
 
         [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
-        [Trait("Category", "mono-osx-failing")]
         public void DirectoryExistsNoThrowTooLongWithDotsRelative()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3)).Length;
@@ -702,7 +675,6 @@ public static bool RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241()
         }
 
         [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
-        [Trait("Category", "mono-osx-failing")]
         public void FileExistsNoThrowTooLongWithDots()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3) + @"\..\explorer.exe").Length;
@@ -718,7 +690,6 @@ public void FileExistsNoThrowTooLongWithDots()
         }
 
         [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
-        [Trait("Category", "mono-osx-failing")]
         public void FileExistsNoThrowTooLongWithDotsRelative()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3) + @"\..\explorer.exe").Length;
@@ -746,7 +717,6 @@ public void FileExistsNoThrowTooLongWithDotsRelative()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetFileInfoNoThrowTooLongWithDots()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3) + @"\..\explorer.exe").Length;
@@ -762,7 +732,6 @@ public void GetFileInfoNoThrowTooLongWithDots()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetFileInfoNoThrowTooLongWithDotsRelative()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3) + @"\..\explorer.exe").Length;
@@ -884,7 +853,6 @@ public void GenerateTempFileNameWithExtensionNoPeriod()
         /// Extension is invalid
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void GenerateTempBatchFileWithBadExtension()
@@ -899,7 +867,6 @@ public void GenerateTempBatchFileWithBadExtension()
         /// Directory is invalid
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void GenerateTempBatchFileWithBadDirectory()
@@ -910,8 +877,7 @@ public void GenerateTempBatchFileWithBadDirectory()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void AbsolutePathLooksLikeUnixPathOnUnix()
         {
             var secondSlash = SystemSpecificAbsolutePath.Substring(1).IndexOf(Path.DirectorySeparatorChar) + 1;
@@ -921,8 +887,7 @@ public void AbsolutePathLooksLikeUnixPathOnUnix()
             Assert.True(FileUtilities.LooksLikeUnixFilePath(rootLevelPath));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void PathDoesNotLookLikeUnixPathOnWindows()
         {
             Assert.False(FileUtilities.LooksLikeUnixFilePath(SystemSpecificAbsolutePath));
@@ -930,8 +895,7 @@ public void PathDoesNotLookLikeUnixPathOnWindows()
             Assert.False(FileUtilities.LooksLikeUnixFilePath("/root"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void RelativePathLooksLikeUnixPathOnUnixWithBaseDirectory()
         {
             string filePath = ObjectModelHelpers.CreateFileInTempProjectDirectory("first/second/file.txt", String.Empty);
@@ -961,8 +925,7 @@ public void RelativePathLooksLikeUnixPathOnUnixWithBaseDirectory()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void RelativePathMaybeAdjustFilePathWithBaseDirectory()
         {
             // <tmp_dir>/first/second/file.txt
diff --git a/src/Shared/UnitTests/LongPathSupportDisabledFactAttribute.cs b/src/Shared/UnitTests/LongPathSupportDisabledFactAttribute.cs
new file mode 100644
index 00000000000..7a14d49dd74
--- /dev/null
+++ b/src/Shared/UnitTests/LongPathSupportDisabledFactAttribute.cs
@@ -0,0 +1,41 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+using Xunit;
+using Xunit.NetCore.Extensions;
+
+namespace Microsoft.Build.UnitTests
+{
+    /// <summary>
+    ///  This test should be run only on Windows, and when long path support is enabled.
+    ///  It is possible to conditionally restrict the fact to be run only on full .NET Framework.
+    /// </summary>
+    public class LongPathSupportDisabledFactAttribute : FactAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="LongPathSupportDisabledFactAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        /// <param name="fullFrameworkOnly"><see langword="true"/> if the test can be run only on full framework. The default value is <see langword="false"/>.</param>
+        public LongPathSupportDisabledFactAttribute(string? additionalMessage = null, bool fullFrameworkOnly = false)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test only runs on Windows and when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
+                return;
+            }
+
+            if (fullFrameworkOnly && !CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
+            {
+                this.Skip = "This test only runs on full .NET Framework and when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
+                return;
+            }
+
+            if (!NativeMethodsShared.IsMaxPathLegacyWindows())
+            {
+                this.Skip = "This test only runs when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
index e93424bcca7..fc4c92ed88b 100644
--- a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
+++ b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
@@ -5,9 +5,10 @@
 using System.Diagnostics;
 using System.IO;
 using System.Runtime.InteropServices;
-
+using System.Runtime.Versioning;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 
 
@@ -30,14 +31,10 @@ public sealed class NativeMethodsShared_Tests
         /// Verify that getProcAddress works, bug previously was due to a bug in the attributes used to pinvoke the method
         /// when that bug was in play this test would fail.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("No Kernel32.dll except on Windows.")]
+        [SupportedOSPlatform("windows")] // bypass CA1416: Validate platform compatibility
         public void TestGetProcAddress()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "No Kernel32.dll except on Windows"
-            }
-
             IntPtr kernel32Dll = NativeMethodsShared.LoadLibrary("kernel32.dll");
             try
             {
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 847942706a4..68d24c68b48 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1360,7 +1360,11 @@ public static BuildResult BuildProjectContentUsingBuildManager(string content, M
             }
         }
 
-        public static BuildResult BuildProjectFileUsingBuildManager(string projectFile, MockLogger logger = null, BuildParameters parameters = null, string[] targetsToBuild = null)
+        public static BuildResult BuildProjectFileUsingBuildManager(
+            string projectFile,
+            MockLogger logger = null,
+            BuildParameters parameters = null,
+            IList<string> targetsToBuild = null)
         {
             using (var buildManager = new BuildManager())
             {
@@ -1377,7 +1381,7 @@ public static BuildResult BuildProjectFileUsingBuildManager(string projectFile,
                     projectFile,
                     new Dictionary<string, string>(),
                     MSBuildConstants.CurrentToolsVersion,
-                    targetsToBuild ?? Array.Empty<string>(),
+                    targetsToBuild?.ToArray() ?? Array.Empty<string>(),
                     null);
 
                 var result = buildManager.Build(
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index 7f6c1016f2e..25e7cb3a50d 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -5,6 +5,7 @@
 
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -93,9 +94,7 @@ public void TestMergeRuntimeValuesAnyAcceptsCurrent()
             mergedRuntime.ShouldBe(XMakeAttributes.GetCurrentMSBuildRuntime());
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp,
-            "Tests whether 'current' merges with 'clr4' which is true only on Framework")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "Tests whether 'current' merges with 'clr4' which is true only on Framework.")]
         public void TestMergeRuntimeValuesCurrentToClr4()
         {
             XMakeAttributes.TryMergeRuntimeValues(
@@ -111,9 +110,7 @@ public void TestMergeRuntimeValuesCurrentToClr4()
             mergedRuntime.ShouldBeNull();
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework,
-            "Tests whether 'current' merges with 'net' which is true only on core")]
+        [DotNetOnlyFact(additionalMessage: "Tests whether 'current' merges with 'net' which is true only on core.")]
         public void TestMergeRuntimeValuesCurrentToCore()
         {
             XMakeAttributes.TryMergeRuntimeValues(
diff --git a/src/StringTools.UnitTests/WeakStringCache_Tests.cs b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
index 75c418f48ca..41990c59396 100644
--- a/src/StringTools.UnitTests/WeakStringCache_Tests.cs
+++ b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
@@ -125,7 +125,6 @@ private void AddStringsWithSameHashCode(int numberOfStrings)
         /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
         /// </remarks>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RetainsStringUntilCollected()
         {
             // Add a string to the cache using a non-inlinable method to make sure it's not reachable from a GC root.
@@ -167,7 +166,6 @@ public void RetainsStringUntilCollected()
         /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
         /// </remarks>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RetainsLastStringWithGivenHashCode()
         {
             // Add 3 strings with the same hash code.
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
index cffe45afc46..57789ab0700 100644
--- a/src/StringTools/InternableString.Simple.cs
+++ b/src/StringTools/InternableString.Simple.cs
@@ -200,29 +200,45 @@ public override unsafe string ToString()
         /// <returns>A stable hashcode of the string represented by this instance.</returns>
         public override int GetHashCode()
         {
-            int hashCode = 5381;
+            uint hash = (5381 << 16) + 5381;
+            bool isOddIndex = false;
 
             if (_firstString != null)
             {
                 foreach (char ch in _firstString)
                 {
-                    unchecked
-                    {
-                        hashCode = hashCode * 33 ^ ch;
-                    }
+                    hash = HashOneCharacter(hash, ch, isOddIndex);
+                    isOddIndex = !isOddIndex;
                 }
             }
             else if (_builder != null)
             {
                 for (int i = 0; i < _builder.Length; i++)
                 {
-                    unchecked
-                    {
-                        hashCode = hashCode * 33 ^ _builder[i];
-                    }
+                    hash = HashOneCharacter(hash, _builder[i], isOddIndex);
+                    isOddIndex = !isOddIndex;
                 }
             }
-            return hashCode;
+            return (int)hash;
+        }
+
+        /// <summary>
+        /// A helper to hash one character.
+        /// </summary>
+        /// <param name="hash">The running hash code.</param>
+        /// <param name="ch">The character to hash.</param>
+        /// <param name="isOddIndex">True if the index of the character in the string is odd.</param>
+        /// <returns></returns>
+        private static uint HashOneCharacter(uint hash, char ch, bool isOddIndex)
+        {
+            if (isOddIndex)
+            {
+                // The hash code was rotated for the previous character, just xor.
+                return hash ^ ((uint)ch << 16);
+            }
+
+            uint rotatedHash = (hash << 5) | (hash >> (32 - 5));
+            return (rotatedHash + hash) ^ ch;
         }
     }
 }
diff --git a/src/Tasks.UnitTests/AspNetCompiler_Tests.cs b/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
index 0b3829c05e4..61b899f3c1a 100644
--- a/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
+++ b/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
@@ -243,7 +243,6 @@ public void AllParameters()
         /// the project files don't exist, but we only care about the events anyway.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestExternalProjectEvents()
         {
             string projectFileContents = @"
diff --git a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
index fc611cfbcda..afea57b3a14 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
@@ -219,7 +219,6 @@ public void VerifyNullPublicKeyspecificVersion()
         /// this was causing the GAC (api's) to crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyProcessorArchitectureDoesNotCrash()
         {
             AssemblyNameExtension fusionName = new AssemblyNameExtension("System, PublicKeyToken=b77a5c561934e089, ProcessorArchitecture=MSIL");
@@ -232,7 +231,6 @@ public void VerifyProcessorArchitectureDoesNotCrash()
         /// this was causing the GAC (api's) to crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyProcessorArchitectureDoesNotCrashSpecificVersion()
         {
             AssemblyNameExtension fusionName = new AssemblyNameExtension("System, PublicKeyToken=b77a5c561934e089, ProcessorArchitecture=MSIL");
@@ -405,7 +403,6 @@ public void SystemRuntimeDepends_Yes()
 
         // Indirect dependency
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SystemRuntimeDepends_Yes_Indirect()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
diff --git a/src/Tasks.UnitTests/AssemblyDependency/InstalledSDKResolverFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/InstalledSDKResolverFixture.cs
index d502a4a7486..cdacfae192e 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/InstalledSDKResolverFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/InstalledSDKResolverFixture.cs
@@ -53,7 +53,6 @@ public void SDkNameNotInResolvedSDKListButOnSearchPath()
         /// Verify when we are trying to match a name which is the reference assembly directory
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SDkNameMatchInRADirectory()
         {
             ResolveSDKFromRefereneAssemblyLocation("DebugX86SDKWinMD", @"C:\FakeSDK\References\Debug\X86\DebugX86SDKWinMD.Winmd", _output);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 750c73b673e..5dd2309309b 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -18,6 +18,7 @@
 using Xunit.Abstractions;
 using Shouldly;
 using Microsoft.Build.UnitTests.Shared;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -126,7 +127,6 @@ public void VerifyPrimaryReferenceToBadImageDoesNotThrow()
         /// Since copyLocalDependenciesWhenParentReferenceInGac is set to false and the parent of Z is in the GAC
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalDependenciesWhenParentReferenceInGacFalseAllParentsInGac()
         {
             // Create the engine.
@@ -202,7 +202,6 @@ public void ValidateFrameworkNameError()
         /// Since copyLocalDependenciesWhenParentReferenceInGac is set to false but one of the parents of Z is not in the GAC and Z is not in the gac we should be copy local
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalDependenciesWhenParentReferenceInGacFalseSomeParentsInGac()
         {
             // Create the engine.
@@ -265,7 +264,6 @@ public void TestSetRuntimeVersion()
         /// Since copyLocalDependenciesWhenParentReferenceInGac is set to true and Z is not in the GAC it will be copy local true
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalDependenciesWhenParentReferenceInGacTrueAllParentsInGac()
         {
             // Create the engine.
@@ -314,7 +312,6 @@ public void CopyLocalDependenciesWhenParentReferenceInGacTrueAllParentsInGac()
         /// Since copyLocalDependenciesWhenParentReferenceInGac is set to true and Z is not in the GAC it will be copy local true
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalDependenciesWhenParentReferenceInGacTrueSomeParentsInGac()
         {
             // Create the engine.
@@ -355,7 +352,6 @@ public void CopyLocalDependenciesWhenParentReferenceInGacTrueSomeParentsInGac()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalDependenciesWhenParentReferenceNotInGac()
         {
             // Create the engine.
@@ -392,7 +388,6 @@ public void CopyLocalDependenciesWhenParentReferenceNotInGac()
         /// where it was actually resolved). Sets DoNotCopyLocalIfInGac = true
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalLegacyBehavior()
         {
             // Create the engine.
@@ -430,8 +425,6 @@ public void CopyLocalLegacyBehavior()
         /// Very basic test.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void Basic()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -661,7 +654,6 @@ private enum EmbedInteropTypes_Indices
         /// Make sure the imageruntime is correctly returned.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestGetImageRuntimeVersion()
         {
             string imageRuntimeReportedByAsssembly = this.GetType().Assembly.ImageRuntimeVersion;
@@ -1042,7 +1034,6 @@ public void SimulateCreateProjectAgainstWhidbeyWithTrailingSlash()
         /// Invalid candidate assembly files should not crash
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress286699_InvalidCandidateAssemblyFiles()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1063,7 +1054,6 @@ public void Regress286699_InvalidCandidateAssemblyFiles()
         /// Invalid assembly files should not crash
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress286699_InvalidAssemblyFiles()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1104,7 +1094,6 @@ public void Regress286699_InvalidAssembliesParameter()
         /// Target framework path with a newline should not crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress286699_InvalidTargetFrameworkDirectory()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1129,7 +1118,6 @@ public void Regress286699_InvalidTargetFrameworkDirectory()
         /// Invalid search path should not crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress286699_InvalidSearchPath()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1200,7 +1188,6 @@ public void NonExistentReference()
         /// that we don't find a strongly named assembly.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void StrongWeakMismatchInDependency()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1247,7 +1234,6 @@ public void DependenciesOfExternallyResolvedReferencesAreNotSearched()
         /// property, then the task should be able to resolve an assembly there.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UseSuppliedHintPath()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1303,8 +1289,7 @@ public void Regress200872()
         /// <summary>
         /// Do the most basic AssemblyFoldersEx resolve.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExBasic()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1324,8 +1309,7 @@ public void AssemblyFoldersExBasic()
         /// <summary>
         /// Verify that higher alphabetical values for a component are chosen over lower alphabetic values of a component.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExVerifyComponentFolderSorting()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1346,8 +1330,7 @@ public void AssemblyFoldersExVerifyComponentFolderSorting()
         /// If the target framework version provided by the targets file doesn't begin
         /// with the letter "v", we should tolerate it and treat it as if it does.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExTargetFrameworkVersionDoesNotBeginWithV()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1371,8 +1354,7 @@ public void AssemblyFoldersExTargetFrameworkVersionDoesNotBeginWithV()
         /// Expect it not to resolve and get a message on the console
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchDoesNotMatch()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1397,8 +1379,7 @@ public void AssemblyFoldersExProcessorArchDoesNotMatch()
         /// Target MSIL and get an assembly out of the X86 directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMSILX86()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1420,9 +1401,7 @@ public void AssemblyFoldersExProcessorArchMSILX86()
         /// <summary>
         /// Verify if there is a mismatch between what the project targets and the architecture of the resolved primary reference log a warning.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Trait("Category", "mono-windows-failing")]
+        [WindowsOnlyFact]
         public void VerifyProcessArchitectureMismatchWarning()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1446,9 +1425,7 @@ public void VerifyProcessArchitectureMismatchWarning()
         /// <summary>
         /// Verify if there is a mismatch between what the project targets and the architecture of the resolved primary reference log a warning.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Trait("Category", "mono-windows-failing")]
+        [WindowsOnlyFact]
         public void VerifyProcessArchitectureMismatchWarningDefault()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1471,9 +1448,7 @@ public void VerifyProcessArchitectureMismatchWarningDefault()
         /// <summary>
         /// Verify if there is a mismatch between what the project targets and the architecture of the resolved primary reference log a error.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Trait("Category", "mono-windows-failing")]
+        [WindowsOnlyFact]
         public void VerifyProcessArchitectureMismatchError()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1500,8 +1475,7 @@ public void VerifyProcessArchitectureMismatchError()
         /// Target None and get an assembly out of the X86 directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneX86()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1521,8 +1495,7 @@ public void AssemblyFoldersExProcessorArchNoneX86()
         /// If we are targeting NONE and there are two assemblies with the same name then we want to pick the first one rather than look for an assembly which
         /// has a MSIL architecture or a NONE architecture. NONE means you do not care what architecture is picked.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneMix()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1550,8 +1523,7 @@ public void AssemblyFoldersExProcessorArchNoneMix()
         /// Target MSIL and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMSILLastFolder()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1576,8 +1548,7 @@ public void AssemblyFoldersExProcessorArchMSILLastFolder()
         /// Target None and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneLastFolder()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1601,8 +1572,7 @@ public void AssemblyFoldersExProcessorArchNoneLastFolder()
         /// Target MSIL and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchX86FirstFolder()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1625,8 +1595,7 @@ public void AssemblyFoldersExProcessorArchX86FirstFolder()
         /// Target X86 and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchX86MSIL()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1648,8 +1617,7 @@ public void AssemblyFoldersExProcessorArchX86MSIL()
         /// Target X86 and get an assembly out of the None directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchX86None()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1671,8 +1639,7 @@ public void AssemblyFoldersExProcessorArchX86None()
         /// Target None and get an assembly out of the None directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneNone()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1693,8 +1660,7 @@ public void AssemblyFoldersExProcessorArchNoneNone()
         /// Target MSIL and get an assembly out of the None directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArcMSILNone()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1715,8 +1681,7 @@ public void AssemblyFoldersExProcessorArcMSILNone()
         /// Target None and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneMSIL()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1738,8 +1703,7 @@ public void AssemblyFoldersExProcessorArchNoneMSIL()
         /// Target MSIL and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMSILMSIL()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1761,8 +1725,7 @@ public void AssemblyFoldersExProcessorArchMSILMSIL()
         /// Target X86 and get an assembly out of the X86 directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMatches()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1786,8 +1749,7 @@ public void AssemblyFoldersExProcessorArchMatches()
         /// This means if there are remaining search paths to inspect, we should
         /// carry on and inspect those.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExTargetFrameworkVersionBogusValue()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1808,8 +1770,7 @@ public void AssemblyFoldersExTargetFrameworkVersionBogusValue()
         /// <summary>
         /// Tolerate keys like v2.0.x86chk.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void Regress357227_AssemblyFoldersExAgainstRawDrop()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1829,8 +1790,7 @@ public void Regress357227_AssemblyFoldersExAgainstRawDrop()
         /// <summary>
         /// Matches that exist only in the HKLM hive.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExHKLM()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1849,8 +1809,7 @@ public void AssemblyFoldersExHKLM()
         /// <summary>
         /// Matches that exist in both HKLM and HKCU should favor HKCU
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExHKCUTrumpsHKLM()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1874,8 +1833,7 @@ public void AssemblyFoldersExHKCUTrumpsHKLM()
         /// <summary>
         /// When matches that have v3.0 (future) and v2.0 (current) versions, the 2.0 version wins.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExFutureTargetNDPVersionsDontMatch()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1894,8 +1852,7 @@ public void AssemblyFoldersExFutureTargetNDPVersionsDontMatch()
         /// <summary>
         /// If there is no v2.0 (current target NDP) match, then v1.0 should match.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExMatchBackVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1914,8 +1871,7 @@ public void AssemblyFoldersExMatchBackVersion()
         /// <summary>
         /// If there is a 2.0 and a 1.0 then match 2.0.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExCurrentTargetVersionTrumpsPastTargetVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1934,8 +1890,7 @@ public void AssemblyFoldersExCurrentTargetVersionTrumpsPastTargetVersion()
         /// <summary>
         /// If a control has a service pack then that wins over the control itself
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExServicePackTrumpsBaseVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1955,8 +1910,7 @@ public void AssemblyFoldersExServicePackTrumpsBaseVersion()
         /// Conditions (OSVersion/Platform) can be passed in SearchPaths to filter the result.
         /// Test MaxOSVersion condition
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExConditionFilterMaxOS()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1999,8 +1953,7 @@ public void AssemblyFoldersExConditionFilterMaxOS()
         /// Conditions (OSVersion/Platform) can be passed in SearchPaths to filter the result.
         /// Test MinOSVersion condition
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExConditionFilterMinOS()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -2313,8 +2266,7 @@ public void GatherVersions35x86chkDotNet()
         /// Conditions (OSVersion/Platform) can be passed in SearchPaths to filter the result.
         /// Test Platform condition
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExConditionFilterPlatform()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -2986,7 +2938,6 @@ public void ToElementButNoFrom()
         /// then try to resolve directly to that file name and make it a full path.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RawFileNameRelative()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -3023,7 +2974,6 @@ public void RawFileNameRelative()
         /// then try to resolve the file but make sure it is a full name
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RelativeDirectoryResolver()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -3059,7 +3009,6 @@ public void RelativeDirectoryResolver()
         /// If a relative file name is passed in through the HintPath then try to resolve directly to that file name and make it a full path.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void HintPathRelative()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -3176,7 +3125,6 @@ public void Regress363340_RawFileNameMissing()
         /// because assemblyName was null and we were comparing the assemblyName from the hintPath to the null assemblyName.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress444793()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -3206,7 +3154,6 @@ public void Regress444793()
         /// then try to resolve directly to that file name.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RawFileNameDoesntExist()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -3286,7 +3233,6 @@ public void ResolveToGACSpecificVersion()
         /// instead we want to let the assembly be resolved normally so that the GAC and AF checks will work.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ParentAssemblyResolvedFromAForGac()
         {
             var parentReferenceFolders = new List<string>();
@@ -3402,7 +3348,6 @@ public void ResolveBadImageInPrimary()
         /// no reference. We don't want an exception.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ResolveBadImageInSecondary()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4089,7 +4034,6 @@ public void Regress199998()
         /// The user browsed to an .exe, so that's what we should give them.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ExecutableExtensionEXE()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4207,7 +4151,6 @@ public void ExecutableExtensionDefaultDLLFirst()
         /// Without an ExecutableExtension the first assembly out of .dll,.exe wins.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ExecutableExtensionDefaultEXEFirst()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4287,7 +4230,6 @@ public void SimpleNameWithSpecificVersionTrue()
         /// If specific version is false, then we should match the first "A" that we find.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SimpleNameWithSpecificVersionFalse()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4541,7 +4483,6 @@ public void Regress312873_UnresolvedPrimaryWithResolveDependency()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress275161_ScatterAssemblies()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4594,7 +4535,6 @@ public void Regress275161_ScatterAssemblies()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress317975_LeftoverLowerVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4688,7 +4628,6 @@ public void Regress313086_Part1_MscorlibAsRawFilename()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress313086_Part2_MscorlibAsRawFilename()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4748,7 +4687,6 @@ public void Regress284466_DirectoryIntoAssemblyFiles()
         /// If a relative assemblyFile is passed in resolve it as a full path.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RelativeAssemblyFiles()
         {
             string testPath = Path.Combine(Path.GetTempPath(), @"RelativeAssemblyFiles");
@@ -4915,7 +4853,6 @@ public void Regress269704_MissingRegistryElements()
         /// this reference, especially given the fact that the HintPath was provided in the project file.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress276548_AssemblyNameDifferentThanFusionName()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4986,7 +4923,6 @@ public void Regress314573_VeryLongPaths()
         /// Need to be robust in the face of assembly names with special characters.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress265003_EscapedCharactersInFusionName()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5023,7 +4959,6 @@ public void Regress265003_EscapedCharactersInFusionName()
         /// have a hintpath, then go ahead and resolve anyway because we know what the path should be.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress284081_UnescapedCharactersInFusionNameWithHintPath()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5199,7 +5134,6 @@ public void Regress354669_HintPathWithTrailingSlash()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress339786_CrossVersionsWithAppConfig()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5268,7 +5202,6 @@ public void Regress_DogfoodCLRThrowsFileLoadException()
         /// but became false when Crystal Reports started putting their assemblies in this table.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress407623_RedistListDoesNotImplyPresenceInFrameworks()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5352,7 +5285,6 @@ public void InvalidCharsInInstalledAssemblyTable()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress435487_FxFileResolvedByHintPathShouldByCopyLocal()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5454,8 +5386,6 @@ public void PartialNameMatchingFromRedist()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void Regress46599_BogusInGACValueForAssemblyInRedistList()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5507,8 +5437,6 @@ public void Regress46599_BogusInGACValueForAssemblyInRedistList()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void VerifyFrameworkFileMetadataFiles()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -6302,7 +6230,6 @@ public void SubsetListFinderNullSubsetExistsButNotXml()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void IgnoreDefaultInstalledAssemblyTables()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -7211,7 +7138,6 @@ private static void GenerateNewReferences(out Reference enginePrimaryReference,
         /// way to specify a TargetFrameworkSubset is to pass one to the InstalledAssemblySubsetTables property.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void IgnoreDefaultInstalledSubsetTables()
         {
             string redistListPath = CreateGenericRedistList();
@@ -7298,7 +7224,6 @@ private bool GenerateHelperDelegatesAndExecuteTask(ResolveAssemblyReference t, s
         /// is passed in. We expect to use that.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void NoClientSubsetButInstalledSubTables()
         {
             string redistListPath = CreateGenericRedistList();
@@ -7380,7 +7305,6 @@ public void NullFullTargetFrameworkSubsetNames()
         /// Test the case where a non existent subset list path is used and no additional subsets are passed in.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void FakeSubsetListPathsNoAdditionalSubsets()
         {
             string redistListPath = CreateGenericRedistList();
@@ -7590,7 +7514,6 @@ private bool GenerateHelperDelegatesAndExecuteTask(ResolveAssemblyReference t)
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void DoNotAssumeFilesDescribedByRedistListExistOnDisk()
         {
             string redistListPath = CreateGenericRedistList();
@@ -7776,7 +7699,6 @@ public void ByDesignRelatedTo454863_PrimaryReferencesDontResolveToParentFolders(
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress393931_AllowAlternateAssemblyExtensions_Case1()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -7808,7 +7730,6 @@ public void Regress393931_AllowAlternateAssemblyExtensions_Case1()
         /// Allow alternate extension values to be passed in.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress393931_AllowAlternateAssemblyExtensions()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -7837,7 +7758,6 @@ public void Regress393931_AllowAlternateAssemblyExtensions()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SGenDependeicies()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -7881,7 +7801,6 @@ public void SGenDependeicies()
         /// These two project references have different versions. Important: PKT is null.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress315619_TwoWeaklyNamedPrimariesIsInsoluble()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -7922,7 +7841,6 @@ public void Regress315619_TwoWeaklyNamedPrimariesIsInsoluble()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ForwardRedistRoot()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8048,7 +7966,6 @@ public void ReverseAssemblyNameExtensionComparer()
         /// Check the Filtering based on Target Framework.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TargetFrameworkFiltering()
         {
             int resultSet = RunTargetFrameworkFilteringTest("3.0");
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
index 7564fe66bff..6e875773019 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
@@ -25,8 +25,6 @@ public Perf(ITestOutputHelper output) : base(output)
         }
 
         [Theory]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         [InlineData(RARSimulationMode.LoadProject, 1)]
         [InlineData(RARSimulationMode.BuildProject, 2)]
         public void AutoUnifyUsesMinimumIO(RARSimulationMode rarSimulationMode, int ioThreshold)
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
index e845e40d540..1f29749f3b3 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
@@ -9,6 +9,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -35,8 +36,7 @@ public SpecificVersionPrimary(ITestOutputHelper output) : base(output)
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void Exists()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -106,7 +106,6 @@ public void Exists()
         /// </list>
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ExistsDifferentName()
         {
             // Create the engine.
@@ -159,7 +158,6 @@ public void ExistsDifferentName()
         ///     perf hit when loading large solutions.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ExistsOldVersionRange()
         {
             // Create the engine.
@@ -212,7 +210,6 @@ public void ExistsOldVersionRange()
         ///     perf hit when loading large solutions.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void HighVersionDoesntExist()
         {
             // Create the engine.
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
index 6c39feba98b..1960dba7a0b 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
@@ -44,7 +44,6 @@ public StronglyNamedDependency(ITestOutputHelper output) : base(output)
         /// We automatically unify FX dependencies.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Exists()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
index 9df8866c63a..e7219ac8973 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
@@ -308,7 +308,6 @@ public void Regress313747_FalseSuggestedRedirectsWhenAssembliesDifferOnlyByPkt()
         /// there and there won't be a binding redirect to point it at 2.0.0.0.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void Regress442570_MissingBackVersionShouldWarn()
@@ -388,7 +387,6 @@ public void RedirectsAreSuggestedInExternallyResolvedGraph()
         /// binding redirects.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void Regress387218_UnificationRequiresStrongName()
@@ -432,7 +430,6 @@ public void Regress387218_UnificationRequiresStrongName()
         /// There should be no suggested redirect because assemblies with different cultures cannot unify.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void Regress390219_UnificationRequiresSameCulture()
diff --git a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
index ba882c518f0..7d92fe9e630 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
@@ -352,7 +352,6 @@ public void HigherVersionDirect()
         /// which has dependencies set to false.  A regular build or design time build has this set to true so we do the correct check.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void HigherVersionDirectDependenciesFalse()
         {
             MockEngine e = new MockEngine(_output);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
index 99483aec16d..6435b8cddaa 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
@@ -128,7 +128,6 @@ public void HigherThanHighestInRedistList()
         /// not warn -- this is a hack until we figure out how to properly deal with .NET assemblies being removed from the framework.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void HigherThanHighestInRedistListForMSBuildAssembly()
         {
             MockEngine e = new MockEngine(_output);
@@ -265,7 +264,6 @@ public void DependenciesHigherThanHighestInRedistList()
         /// not warn -- this is a hack until we figure out how to properly deal with .NET assemblies being removed from the framework.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void DependenciesHigherThanHighestInRedistListForMSBuildAssembly()
         {
             MockEngine e = new MockEngine(_output);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
index 84859e9d33f..285438b8181 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
@@ -18,7 +18,6 @@ namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
     /// <summary>
     /// Unit tests for the ResolveAssemblyReference task.
     /// </summary>
-    [Trait("Category", "non-mono-tests")]
     public sealed class WinMDTests : ResolveAssemblyReferenceTestFixture
     {
         public WinMDTests(ITestOutputHelper output) : base(output)
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index e6ddc3e2dd3..915bf102943 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -241,8 +242,7 @@ public void SupportAliasedCultures(string culture)
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        [Theory]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework, "These cultures are not returned via Culture api on net472.")]
+        [DotNetOnlyTheory(additionalMessage: "These cultures are not returned via Culture api on net472.")]
         [InlineData("sh-BA")]
         [InlineData("shi-MA")]
         public void AliasedCultures_SupportedOnNetCore(string culture)
@@ -260,8 +260,7 @@ public void AliasedCultures_SupportedOnNetCore(string culture)
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework, "Pseudoloc is special-cased in .NET relative to Framework.")]
+        [DotNetOnlyFact(additionalMessage: "Pseudoloc is special-cased in .NET relative to Framework.")]
         public void Pseudolocales_CaseInsensitive()
         {
             string culture = "qps-Ploc";
diff --git a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
index 899517b56d0..68ae84b67c6 100644
--- a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
+++ b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
@@ -61,7 +61,6 @@ public void InvalidItemPath()
         /// Test basic function of the AssignLinkMetadata task
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Basic()
         {
             ITaskItem item = GetParentedTaskItem(_defaultItemSpec);
@@ -88,7 +87,6 @@ public void Basic()
         /// output any items that aren't problematic.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void InvalidItemPathWithOtherValidItem()
         {
             ITaskItem item1 = GetParentedTaskItem(itemSpec: "|||");
diff --git a/src/Tasks.UnitTests/AxImp_Tests.cs b/src/Tasks.UnitTests/AxImp_Tests.cs
index 77a7674dd7d..932661cdbbd 100644
--- a/src/Tasks.UnitTests/AxImp_Tests.cs
+++ b/src/Tasks.UnitTests/AxImp_Tests.cs
@@ -5,6 +5,7 @@
 using Microsoft.Build.Tasks;
 
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -32,7 +33,6 @@ public void ActiveXControlName()
         /// Tests that the assembly being imported is passed to the command line
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ActiveXControlNameWithSpaces()
         {
             var t = new ResolveComReference.AxImp();
@@ -70,14 +70,9 @@ public void GenerateSource()
         /// <summary>
         /// Tests the /nologo switch
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("The /nologo switch is not available on Mono.")]
         public void NoLogo()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "The /nologo switch is not available on Mono"
-            }
-
             var t = new ResolveComReference.AxImp();
 
             Assert.False(t.NoLogo); // "NoLogo should be false by default"
diff --git a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
index 9d33db3278f..da0e6a9097a 100644
--- a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
+++ b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Runtime.Hosting;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -40,14 +41,9 @@ public void DelaySign()
         /// <summary>
         /// Tests the /keycontainer: switch
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("Key container is not supported, except under Windows.")]
         public void KeyContainer()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Key container is not supported, except under Windows"
-            }
-
             var t = new ResolveComReference.TlbImp();
             t.TypeLibName = "FakeTlb.tlb";
             string badParameterValue = "badKeyContainer";
@@ -267,14 +263,9 @@ public void ToolPath()
         /// Tests that strong name sign-related parameters are validated properly, causing the task
         /// to fail if they are incorrectly set up.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("Key container is not supported, except under Windows.")]
         public void TaskFailsWhenImproperlySigned()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Key container is not supported, except under Windows"
-            }
-
             var t = new ResolveComReference.TlbImp();
             t.TypeLibName = "Blah.tlb";
             string tempKeyContainer = null;
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index 538e51342f3..4837636b510 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -199,7 +199,6 @@ public void RuntimeException()
         /// Verify we get an error if a the languages attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptyLanguage()
         {
             string projectFileContents = @"
@@ -228,7 +227,6 @@ public void EmptyLanguage()
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptyType()
         {
             string projectFileContents = @"
@@ -257,7 +255,6 @@ public void EmptyType()
         /// Verify we get an error if a the source attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptySource()
         {
             string projectFileContents = @"
@@ -286,7 +283,6 @@ public void EmptySource()
         /// Verify we get an error if a reference is missing an include attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptyReferenceInclude()
         {
             string projectFileContents = @"
@@ -316,7 +312,6 @@ public void EmptyReferenceInclude()
         /// Verify we get an error if a Using statement is missing an namespace attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptyUsingNamespace()
         {
             string projectFileContents = @"
@@ -374,7 +369,6 @@ public void ReferenceNotPath()
         /// Verify we get an error a reference has strange chars
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ReferenceInvalidChars()
         {
             string projectFileContents = @"
@@ -404,7 +398,6 @@ public void ReferenceInvalidChars()
         /// Verify we get an error if a using has invalid chars
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UsingInvalidChars()
         {
             string projectFileContents = @"
@@ -462,7 +455,6 @@ public void SourcesInvalidFile()
         /// Verify we get an error if a the code element is missing
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MissingCodeElement()
         {
             string projectFileContents = @"
@@ -683,7 +675,6 @@ public void BuildTaskSimpleCodeFactoryTestExtraReferenceCS()
         /// jscript .net works
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MethodImplementationJScriptNet()
         {
             if (!CodeDomProvider.IsDefinedLanguage("js"))
@@ -879,7 +870,6 @@ public bool Execute()
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MultipleCodeElements()
         {
             string projectFileContents = @"
@@ -911,7 +901,6 @@ public void MultipleCodeElements()
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ReferenceNestedInCode()
         {
             string projectFileContents = @"
@@ -945,7 +934,6 @@ public void ReferenceNestedInCode()
         /// Verify we get an error if there is an unknown element in the task tag
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UnknownElementInTask()
         {
             string projectFileContents = @"
@@ -1057,7 +1045,6 @@ public override bool Execute()
         /// See https://github.com/dotnet/msbuild/issues/328 for details.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void BuildTaskSimpleCodeFactoryTempDirectoryDoesntExist()
         {
             string projectFileContents = @"
diff --git a/src/Tasks.UnitTests/ComReference_Tests.cs b/src/Tasks.UnitTests/ComReference_Tests.cs
index 09a21f0bb38..d30c3552c9f 100644
--- a/src/Tasks.UnitTests/ComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ComReference_Tests.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -39,14 +40,9 @@ private static bool FileExistsMock(string filepath)
             return ExistingFilesDictionary.ContainsKey(filepath);
         }
 
-        [Fact]
+        [WindowsOnlyFact("COM is only found on Windows.")]
         public void TestStripTypeLibNumber()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "COM is only found on Windows"
-            }
-
             Assert.Null(ComReference.StripTypeLibNumberFromPath(null, new FileExists(FileExistsMock)));
             Assert.Equal("", ComReference.StripTypeLibNumberFromPath("", new FileExists(FileExistsMock)));
             Assert.Equal(@"C:\test\typelib1.dll", ComReference.StripTypeLibNumberFromPath(@"C:\test\typelib1.dll", new FileExists(FileExistsMock)));
diff --git a/src/Tasks.UnitTests/CombinePath_Tests.cs b/src/Tasks.UnitTests/CombinePath_Tests.cs
index cee148bb2c5..a719717e07e 100644
--- a/src/Tasks.UnitTests/CombinePath_Tests.cs
+++ b/src/Tasks.UnitTests/CombinePath_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -203,9 +204,7 @@ public void BlankPath()
         /// <summary>
         /// Specified paths contain invalid characters.  Task should continue processing remaining items.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // No invalid characters on Unix
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No invalid characters on Unix.")]
         public void InvalidPath()
         {
             CombinePath t = new CombinePath();
diff --git a/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs b/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs
index 3e7b7c32d9d..e359b2c289b 100644
--- a/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs
+++ b/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs
@@ -98,8 +98,6 @@ public sealed class CommandLineGenerator_Tests
         /// Tests a command line generated from all of the specified switch values.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void BasicCommandLine()
         {
             CommandLineGenerator generator = CreateGenerator();
@@ -111,8 +109,6 @@ public void BasicCommandLine()
         /// Tests a command line generated from a specific template
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void TemplatedCommandLine()
         {
             CommandLineGenerator generator = CreateGenerator();
@@ -125,8 +121,6 @@ public void TemplatedCommandLine()
         /// Tests a command line generated from a specific template is not case sensitive on the parameter names.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void TemplateParametersAreCaseInsensitive()
         {
             CommandLineGenerator generator = CreateGenerator();
diff --git a/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs b/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs
index 73c43d16a92..fd15e069f96 100644
--- a/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs
+++ b/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs
@@ -20,7 +20,6 @@ public sealed class ConvertToAbsolutePath_Tests
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void RelativePath()
         {
             string fileName = ObjectModelHelpers.CreateFileInTempProjectDirectory("file.temp", "foo");
@@ -53,7 +52,6 @@ public void RelativePath()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void RelativePathWithEscaping()
         {
             string fileName = ObjectModelHelpers.CreateFileInTempProjectDirectory("file%3A.temp", "foo");
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 49a635d1385..eac251335ed 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -19,6 +19,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -131,7 +132,6 @@ public void DontCopyOverSameFile()
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void DoNotNormallyCopyOverReadOnlyFile()
@@ -194,7 +194,6 @@ public void DoNotNormallyCopyOverReadOnlyFile()
         /// OverwriteReadOnlyFiles is false
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void CopyOverReadOnlyFileEnvironmentOverride()
@@ -260,7 +259,6 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
         /// If MSBUILDALWAYSRETRY is set, keep retrying the copy.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void AlwaysRetryCopyEnvironmentOverride()
@@ -332,7 +330,6 @@ public void AlwaysRetryCopyEnvironmentOverride()
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void CopyOverReadOnlyFileParameterIsSet()
@@ -651,16 +648,9 @@ public void DoCopyOverNonExistentFile()
         /// <summary>
         /// Make sure we do not retry when the source file has a misplaced colon
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Colon is special only on Windows.")]
         public void DoNotRetryCopyNotSupportedException()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                // Colon is special only on Windows
-                return;
-            }
-
             string sourceFile = FileUtilities.GetTemporaryFile();
             string destinationFile = "foobar:";
 
@@ -790,7 +780,6 @@ public void DoNotRetryCopyWhenSourceIsFolder()
         /// Most important case is when destination is locked
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void DoRetryWhenDestinationLocked()
@@ -1019,9 +1008,7 @@ internal class CopyMonitor
         /// CopiedFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "Under Unix all filenames are valid and this test is not useful"
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Under Unix all filenames are valid and this test is not useful.")]
         public void OutputsOnlyIncludeSuccessfulCopies()
         {
             string temp = Path.GetTempPath();
@@ -1177,8 +1164,7 @@ public void CopyFileOnItself()
         /// Copying a file on top of itself should be a success (no-op) whether
         /// or not skipUnchangedFiles is true or false. Variation with different casing/relativeness.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "File names under Unix are case-sensitive and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "File names under Unix are case-sensitive and this test is not useful.")]
         public void CopyFileOnItself2()
         {
             string currdir = Directory.GetCurrentDirectory();
@@ -1229,7 +1215,6 @@ public void CopyFileOnItself2()
         /// or not skipUnchangedFiles is true or false. Variation with a second copy failure.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void CopyFileOnItselfAndFailACopy()
@@ -1613,8 +1598,7 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
         /// If the destination path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
@@ -1657,8 +1641,7 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         /// If the source path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
         {
             const string sourceFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
@@ -1936,7 +1919,6 @@ public void TooFewRetriesThrows()
             engine.AssertLogContains("MSB3027");
         }
 
-        [PlatformSpecific(TestPlatforms.Windows)]
         internal virtual void ErrorIfLinkFailedCheck()
         {
             using (var env = TestEnvironment.Create())
@@ -2189,8 +2171,7 @@ public void CopyToDestinationFolderWithHardLinkCheck()
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // SMB share paths only work on Windows
+        [WindowsOnlyFact(additionalMessage: "SMB share paths only work on Windows.")]
         public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
         {
             // Workaround: For some reason when this test runs with all other tests we are getting
@@ -2295,8 +2276,7 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // Only Windows has a (small) link limit, and this tests for an HRESULT
+        [WindowsOnlyFact(additionalMessage: "Only Windows has a (small) link limit, and this tests for an HRESULT.")]
         public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
         {
             // Workaround: For some reason when this test runs with all other tests we are getting
@@ -2382,7 +2362,7 @@ public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         internal override void ErrorIfLinkFailedCheck()
         {
             base.ErrorIfLinkFailedCheck();
@@ -2463,7 +2443,7 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         internal override void ErrorIfLinkFailedCheck()
         {
             base.ErrorIfLinkFailedCheck();
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index 25daf87a34e..ab9c9fbc182 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -56,7 +56,6 @@ public void Basic()
 #else
         [Fact]
 #endif
-        [Trait("Category", "mono-osx-failing")]
         public void Regress172107()
         {
             // Can't embed the 'Ã' directly because the string is Unicode already and the Unicode<-->ANSI transform
@@ -102,7 +101,6 @@ public void Regress172107()
 #else
         [Fact]
 #endif
-        [Trait("Category", "mono-osx-failing")]
         public void Regress249540()
         {
             // Special character is 'Ä' in UTF8: 0xC3 84
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 44ac891a76d..c9edcec199b 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -13,6 +13,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using Shouldly;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -313,8 +314,7 @@ public void WildcardDriveEnumerationTaskItemLogsError(string itemSpec)
         /// Logs warning when encountering wildcard drive enumeration during task item creation on Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"z:\**")]
         [InlineData(@"z:\**\*.log")]
         [InlineData(@"z:\\\\**\*.log")]
@@ -327,8 +327,7 @@ public void LogWindowsWarningUponCreateItemExecution(string itemSpec)
         /// Logs warning when encountering wildcard drive enumeration during task item creation on Unix platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"\**")]
         [InlineData(@"\**\*.log")]
         public void LogUnixWarningUponCreateItemExecution(string itemSpec)
@@ -393,8 +392,7 @@ public void ThrowExceptionUponItemCreationWithDriveEnumeration(string content, s
         /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             CreateItemWithInclude,
             @"z:\**")]
@@ -421,8 +419,7 @@ public void LogWindowsWarningUponItemCreationWithDriveEnumeration(string content
         /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Unix platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(
             CreateItemWithInclude,
             @"\**")]
diff --git a/src/Tasks.UnitTests/Delete_Tests.cs b/src/Tasks.UnitTests/Delete_Tests.cs
index b752d309728..d404c63246f 100644
--- a/src/Tasks.UnitTests/Delete_Tests.cs
+++ b/src/Tasks.UnitTests/Delete_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -41,8 +42,7 @@ public void AttributeForwarding()
         /// <summary>
         /// Retry Delete. Specify windows since readonly not working on others
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void DeleteWithRetries()
         {
             string source = FileUtilities.GetTemporaryFile();
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 5c78ff468a7..52e2c3e4bcf 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -15,6 +15,7 @@
 using Xunit.Abstractions;
 using System.Collections.Generic;
 using Microsoft.Build.Evaluation;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -51,7 +52,6 @@ private ExecWrapper PrepareExecWrapper(string command)
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile()
@@ -74,7 +74,6 @@ public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile()
         /// lying around.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void NoTempFileLeaks()
         {
             using (var testEnvironment = TestEnvironment.Create())
@@ -168,8 +167,7 @@ public void TimeoutFailsEvenWhenExitCodeIsIgnored()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void WindowsNewLineCharactersInCommandOnUnix()
         {
             var exec = PrepareExec("echo hello\r\n\r\n");
@@ -246,8 +244,7 @@ public void NonUNCWorkingDirectoryUsed()
             ((MockEngine)exec.BuildEngine).AssertLogContains("[" + working + "]");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]   // UNC is Windows-Only
+        [WindowsOnlyFact(additionalMessage: "UNC is Windows-Only.")]
         public void UNCWorkingDirectoryUsed()
         {
             Exec exec = PrepareExec("echo [%cd%]");
@@ -475,10 +472,9 @@ public void ExecTaskUtf8AlwaysWithAnsi()
         /// Exec task will NOT use UTF8 when UTF8 Never is specified and non-ANSI characters are in the Command
         /// <remarks>Exec task will fail as the cmd processor will not be able to run the command.</remarks>
         /// </summary>
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData("Never")]
         [InlineData("System")]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void ExecTaskUtf8NeverWithNonAnsi(string useUtf8)
         {
             RunExec(true, EncodingUtilities.CurrentSystemOemEncoding.EncodingName, useUtf8, false);
@@ -903,8 +899,7 @@ public void ConsoleToMSBuild()
         /// Test the CanEncode method with and without ANSI characters to determine if they can be encoded 
         /// in the current system encoding.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void CanEncodeTest()
         {
             var defaultEncoding = EncodingUtilities.CurrentSystemOemEncoding;
@@ -968,7 +963,6 @@ echo line 3"" />
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void EndToEndMultilineExec_EscapeSpecialCharacters()
diff --git a/src/Tasks.UnitTests/FileStateTests.cs b/src/Tasks.UnitTests/FileStateTests.cs
index da2d3ab4266..1048fc95358 100644
--- a/src/Tasks.UnitTests/FileStateTests.cs
+++ b/src/Tasks.UnitTests/FileStateTests.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -36,17 +37,14 @@ public void BadTooLongCtorOK()
             new FileState(new String('x', 5000));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // On Unix there no invalid file name characters
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. On Unix there is no invalid file name characters.")]
         public void BadChars()
         {
             var state = new FileState("|");
             Assert.Throws<ArgumentException>(() => { var time = state.LastWriteTime; });
         }
 
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [LongPathSupportDisabledFact]
         public void BadTooLongLastWriteTime()
         {
             Helpers.VerifyAssertThrowsSameWay(
@@ -229,7 +227,6 @@ public void NameReset()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void LastWriteTimeReset()
         {
             string file = null;
@@ -256,7 +253,6 @@ public void LastWriteTimeReset()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void LastWriteTimeUtcReset()
         {
             string file = null;
@@ -285,7 +281,6 @@ public void LastWriteTimeUtcReset()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void LengthReset()
         {
             string file = null;
@@ -341,7 +336,6 @@ public void ExistsButDirectory()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ReadOnlyOnDirectory()
         {
             Assert.Equal(new FileInfo(Path.GetTempPath()).IsReadOnly, new FileState(Path.GetTempPath()).IsReadOnly);
diff --git a/src/Tasks.UnitTests/FindUnderPath_Tests.cs b/src/Tasks.UnitTests/FindUnderPath_Tests.cs
index 62cba40c5fd..ce0be31a183 100644
--- a/src/Tasks.UnitTests/FindUnderPath_Tests.cs
+++ b/src/Tasks.UnitTests/FindUnderPath_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 
 
@@ -35,9 +36,7 @@ public void BasicFilter()
             Assert.Equal(FileUtilities.FixFilePath(@"C:\SomeoneElsesProject\File2.txt"), t.OutOfPath[0].ItemSpec);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // On Unix there no invalid file name characters
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. On Unix there is no invalid file name characters.")]
         public void InvalidFile()
         {
             FindUnderPath t = new FindUnderPath();
@@ -53,9 +52,7 @@ public void InvalidFile()
             // Don't crash
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // On Unix there no invalid file name characters
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. On Unix there is no invalid file name characters.")]
         public void InvalidPath()
         {
             FindUnderPath t = new FindUnderPath();
@@ -97,7 +94,6 @@ private static void RunTask(FindUnderPath t, out FileInfo testFile, out bool suc
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyFullPath()
         {
             FindUnderPath t = new FindUnderPath();
@@ -120,7 +116,6 @@ public void VerifyFullPath()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyFullPathNegative()
         {
             FindUnderPath t = new FindUnderPath();
diff --git a/src/Tasks.UnitTests/FormatUrl_Tests.cs b/src/Tasks.UnitTests/FormatUrl_Tests.cs
index de622591d23..5260d22e642 100644
--- a/src/Tasks.UnitTests/FormatUrl_Tests.cs
+++ b/src/Tasks.UnitTests/FormatUrl_Tests.cs
@@ -7,6 +7,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -66,8 +67,7 @@ public void NoInputTest()
         /// From the documentation, Path.GetFullPath(" ") should throw an ArgumentException, but it doesn't on macOS and Linux
         /// where whitespace characters are valid characters for filenames.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void WhitespaceTestOnUnix()
         {
             var t = new FormatUrl();
@@ -81,8 +81,7 @@ public void WhitespaceTestOnUnix()
         /// <summary>
         /// The URL to format is white space.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void WhitespaceTestOnWindows()
         {
             var t = new FormatUrl();
@@ -139,8 +138,7 @@ public void LocalRelativePathTest()
         /// <summary>
         /// The URL to format is a *nix-style (macOS, Linux) local absolute file path.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void LocalUnixAbsolutePathTest()
         {
             var t = new FormatUrl();
@@ -154,8 +152,7 @@ public void LocalUnixAbsolutePathTest()
         /// <summary>
         /// The URL to format is a Windows-style local absolute file path.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void LocalWindowsAbsolutePathTest()
         {
             var t = new FormatUrl();
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index fc0e1104856..8f07ce0c623 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -42,7 +42,6 @@ public void Dispose()
         /// - The only goal for <see cref="GenerateBindingRedirects"/> task is to add specified redirects to the output app.config.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TargetAppConfigShouldContainsBindingRedirects()
         {
             // Arrange
@@ -68,7 +67,6 @@ public void TargetAppConfigShouldContainsBindingRedirects()
         /// - The only goal for <see cref="GenerateBindingRedirects"/> task is to add specified redirects to the output app.config.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TargetAppConfigShouldContainsBindingRedirectsFromAppConfig()
         {
             // Arrange
@@ -103,7 +101,6 @@ public void TargetAppConfigShouldContainsBindingRedirectsFromAppConfig()
         ///   should respect that.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GenerateBindingRedirectsFromTwoDependentAssemblySections()
         {
             // Arrange
@@ -163,7 +160,6 @@ public void GenerateBindingRedirectsFromTwoDependentAssemblySections()
         ///   But due to MSDN documentation, dependentAssembly could have only probing element without any other elements inside.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void AppConfigWithProbingPathAndWithoutDependentAssemblyShouldNotProduceWarningsBug1161241()
         {
             // Arrange
@@ -191,7 +187,6 @@ public void AppConfigWithProbingPathAndWithoutDependentAssemblyShouldNotProduceW
         ///   But due to MSDN documentation, dependentAssembly could have only probing element without any other elements inside.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void AppConfigWithEmptyAssemblyBindingShouldNotProduceWarnings()
         {
             // Arrange
@@ -217,7 +212,6 @@ public void AppConfigWithEmptyAssemblyBindingShouldNotProduceWarnings()
         /// - Due to app.config xsd schema this is a valid configuration.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void DependentAssemblySectionWithoutBindingRedirectShouldNotProduceWarnings()
         {
             // Arrange
diff --git a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
index 0763674cfd8..f4c311c11ce 100644
--- a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
+++ b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Shared;
 using Xunit;
 using Microsoft.Build.Tasks;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -148,8 +149,7 @@ private static string MakeFakeSDKStructure2()
 
     /// <summary>
     /// Test the GetInstalledSDKLocations task
-    /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
+    /// </summary>W
     public class GetInstalledSDKLocationsTestFixture : IClassFixture<FakeSDKStructure>
     {
         private readonly string _fakeSDKStructureRoot;
@@ -165,7 +165,7 @@ public GetInstalledSDKLocationsTestFixture(FakeSDKStructure fakeSDKStructure)
         /// <summary>
         /// Make sure we get a ArgumentException if null is passed into the target platform version.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullTargetPlatformVersion()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -179,7 +179,7 @@ public void NullTargetPlatformVersion()
         /// <summary>
         /// Make sure we get a ArgumentException if null is passed into the target platform version.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullTargetPlatformIdentifier()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -193,7 +193,7 @@ public void NullTargetPlatformIdentifier()
         /// <summary>
         /// Make sure we get an error message if an empty platform identifier is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptyTargetPlatformIdentifier()
         {
             MockEngine engine = new MockEngine();
@@ -211,7 +211,7 @@ public void EmptyTargetPlatformIdentifier()
         /// <summary>
         /// Make sure we get an error message if an empty platform Version is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptyTargetPlatformVersion()
         {
             MockEngine engine = new MockEngine();
@@ -230,7 +230,7 @@ public void EmptyTargetPlatformVersion()
         /// <summary>
         /// Make sure we get an error message if an empty platform Version is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BadTargetPlatformVersion()
         {
             MockEngine engine = new MockEngine();
@@ -249,7 +249,7 @@ public void BadTargetPlatformVersion()
         /// <summary>
         /// Make sure we get an Warning if no SDKs were found.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NoSDKsFound()
         {
             MockEngine engine = new MockEngine();
@@ -267,7 +267,7 @@ public void NoSDKsFound()
         /// <summary>
         /// Get a good set of SDKS installed on the machine from the fake SDK location.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetSDKVersions()
         {
             try
@@ -314,7 +314,7 @@ public void GetSDKVersions()
         /// <summary>
         /// Get a good set of SDKS installed on the machine from the fake SDK location.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetGoodSDKs()
         {
             try
@@ -388,7 +388,7 @@ public void GetGoodSDKs()
         /// <summary>
         /// Get a good set of SDKS installed on the machine from the fake SDK location.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetGoodSDKs2()
         {
             try
diff --git a/src/Tasks.UnitTests/GetSDKReference_Tests.cs b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
index cd5316b3e03..851300230cd 100644
--- a/src/Tasks.UnitTests/GetSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -14,6 +13,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -180,7 +180,6 @@ private static string CreateFakeSDKReferenceAssemblyDirectory2(out string sdkDir
     /// <summary>
     /// Test the expansion of sdk reference assemblies.
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class GetSDKReferenceFilesTestFixture : IDisposable, IClassFixture<FakeSdkStructure>
     {
         private readonly ITestOutputHelper _output;
@@ -223,7 +222,7 @@ public void Dispose()
         /// <summary>
         /// Make sure there are no outputs if no resolved sdk files are passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassReferenceWithNoReferenceDirectory()
         {
             var engine = new MockEngine(_output);
@@ -253,8 +252,7 @@ public void PassReferenceWithNoReferenceDirectory()
         /// <summary>
         /// Make sure we get the correct folder list when asking for it.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void GetSDKReferenceFolders()
         {
             var getReferenceFolders = new GetSDKFolders(ToolLocationHelper.GetSDKReferenceFolders);
@@ -263,7 +261,7 @@ public void GetSDKReferenceFolders()
             VerifySDKFolders(getReferenceFolders, getReferenceFolders2, "References", _sdkDirectory);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyGetSdkReferenceTranslator()
         {
             Dictionary<string, GetSDKReferenceFiles.SdkReferenceInfo> pathToReferenceMetadata = new();
@@ -321,8 +319,7 @@ private static void VerifySDKFolders(GetSDKFolders singleParamDelegate, GetSDKFo
         /// <summary>
         /// Make sure we get the correct folder list when asking for it.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void GetSDKRedistFolders()
         {
             var getRedistFolders = new GetSDKFolders(ToolLocationHelper.GetSDKRedistFolders);
@@ -334,8 +331,7 @@ public void GetSDKRedistFolders()
         /// <summary>
         /// Make sure we get the correct folder list when asking for it.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void GetSDKDesignTimeFolders()
         {
             var getDesignTimeFolders = new GetSDKFolders(ToolLocationHelper.GetSDKDesignTimeFolders);
@@ -347,7 +343,7 @@ public void GetSDKDesignTimeFolders()
         /// <summary>
         /// Make sure there are no outputs if an sdk which does not exist is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassNoSDKReferences()
         {
             var engine = new MockEngine(_output);
@@ -365,7 +361,7 @@ public void PassNoSDKReferences()
         /// <summary>
         /// Make sure there are no outputs if expand sdks is not true.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassReferenceWithExpandFalse()
         {
             var engine = new MockEngine(_output);
@@ -390,7 +386,7 @@ public void PassReferenceWithExpandFalse()
         /// <summary>
         /// Make sure there are no redist outputs if CopyRedist is false
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassReferenceWithCopyRedistFalse()
         {
             var engine = new MockEngine(_output);
@@ -416,8 +412,7 @@ public void PassReferenceWithCopyRedistFalse()
         /// <summary>
         /// Verify we get the correct set of reference assemblies and copy local files when the CopyLocal flag is true
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void GetReferenceAssembliesWhenExpandTrueCopyLocalTrue()
         {
             var engine = new MockEngine(_output);
@@ -482,8 +477,7 @@ public void GetReferenceAssembliesWhenExpandTrueCopyLocalTrue()
         /// <summary>
         /// Verify reference is not processed by GetSDKReferenceFiles when "ReferenceOnly" metadata is set.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyNoCopyWhenReferenceOnlyIsTrue()
         {
             var engine = new MockEngine(_output);
@@ -539,9 +533,7 @@ public void VerifyNoCopyWhenReferenceOnlyIsTrue()
         /// <summary>
         /// Verify we get the correct set of reference assemblies and copy local files when the CopyLocal flag is false
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
+        [WindowsOnlyFact]
         public void GetReferenceAssembliesWhenExpandTrueCopyLocalFalse()
         {
             var engine = new MockEngine(_output);
@@ -596,7 +588,7 @@ public void GetReferenceAssembliesWhenExpandTrueCopyLocalFalse()
         /// Verify that different cache files are created and used correctly for assemblies with the same identity but with files in different directories
         /// Also verifies that when
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyCacheFileNames()
         {
             var engine = new MockEngine(_output);
@@ -662,8 +654,7 @@ public void VerifyCacheFileNames()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyReferencesLogged()
         {
             var engine = new MockEngine(_output);
@@ -711,8 +702,7 @@ public void VerifyReferencesLogged()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyReferencesLoggedFilterOutWinmd()
         {
             var engine = new MockEngine(_output);
@@ -757,8 +747,7 @@ public void VerifyReferencesLoggedFilterOutWinmd()
         /// <summary>
         /// Verify we log an error if no configuration is on the sdk reference
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogErrorWhenNoConfiguration()
         {
             var engine = new MockEngine(_output);
@@ -781,8 +770,7 @@ public void LogErrorWhenNoConfiguration()
         /// <summary>
         /// Verify we log an error if no configuration is on the sdk reference
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogErrorWhenNoArchitecture()
         {
             var engine = new MockEngine(_output);
@@ -807,8 +795,7 @@ public void LogErrorWhenNoArchitecture()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyReferencesLoggedAmd64()
         {
             var engine = new MockEngine(_output);
@@ -859,8 +846,7 @@ public void VerifyReferencesLoggedAmd64()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyReferencesLoggedX64()
         {
             var engine = new MockEngine(_output);
@@ -911,8 +897,7 @@ public void VerifyReferencesLoggedX64()
         /// <summary>
         /// Verify the correct reference files are found and that if we do not want to log them we can set a property to do so.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyLogReferencesFalse()
         {
             var engine = new MockEngine(_output);
@@ -947,8 +932,7 @@ public void VerifyLogReferencesFalse()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyRedistFilesLogRedistFalse()
         {
             var engine = new MockEngine(_output);
@@ -1013,8 +997,7 @@ public void VerifyRedistFilesLogRedistFalse()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyRedistFilesLogRedistTrue()
         {
             var engine = new MockEngine(_output);
@@ -1045,8 +1028,7 @@ public void VerifyRedistFilesLogRedistTrue()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyRedistFilesLogRedistTrueX64()
         {
             var engine = new MockEngine(_output);
@@ -1078,8 +1060,7 @@ public void VerifyRedistFilesLogRedistTrueX64()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyRedistFilesLogRedistTrueAmd64()
         {
             var engine = new MockEngine(_output);
@@ -1110,8 +1091,7 @@ public void VerifyRedistFilesLogRedistTrueAmd64()
         /// <summary>
         /// Make sure by default conflicts between references are logged as a comment if they are within the sdk itself
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogNoWarningForReferenceConflictWithinSDK()
         {
             var engine = new MockEngine(_output);
@@ -1139,8 +1119,7 @@ public void LogNoWarningForReferenceConflictWithinSDK()
         /// <summary>
         /// Make sure that if the LogReferenceConflictsWithinSDKAsWarning is set log a warning for conflicts within an SDK for references.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogWarningForReferenceConflictWithinSDK()
         {
             var engine = new MockEngine(_output);
@@ -1169,8 +1148,7 @@ public void LogWarningForReferenceConflictWithinSDK()
         /// <summary>
         /// Make sure by default conflicts between references are logged as a comment if they are within the sdk itself
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogNoWarningForRedistConflictWithinSDK()
         {
             var engine = new MockEngine(_output);
@@ -1197,8 +1175,7 @@ public void LogNoWarningForRedistConflictWithinSDK()
         /// <summary>
         /// Make sure that if the LogRedistConflictsWithinSDKAsWarning is set log a warning for conflicts within an SDK for redist files.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogWarningForRedistConflictWithinSDK()
         {
             var engine = new MockEngine(_output);
@@ -1226,8 +1203,7 @@ public void LogWarningForRedistConflictWithinSDK()
         /// <summary>
         /// Verify if there are conflicts between references or redist files between sdks that we log a warning by default.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogReferenceAndRedistConflictBetweenSdks()
         {
             var engine = new MockEngine(_output);
@@ -1272,8 +1248,7 @@ public void LogReferenceAndRedistConflictBetweenSdks()
         /// <summary>
         /// If a user create a target path that causes a conflict between two sdks then we want to warn
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogReferenceAndRedistConflictBetweenSdksDueToCustomTargetPath()
         {
             var engine = new MockEngine(_output);
@@ -1315,8 +1290,7 @@ public void LogReferenceAndRedistConflictBetweenSdksDueToCustomTargetPath()
         /// <summary>
         /// Verify if there are conflicts between references or redist files between sdks that we do not log a warning if a certain property (LogxxxConflictBetweenSDKsAsWarning is set to false.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogReferenceAndRedistConflictBetweenSdksNowarning()
         {
             var engine = new MockEngine(_output);
@@ -1362,8 +1336,7 @@ public void LogReferenceAndRedistConflictBetweenSdksNowarning()
         /// <summary>
         /// If there are conflicting redist files between two sdks but their target paths are different then we should copy both to the appx
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void TwoSDKSConflictRedistButDifferentTargetPaths()
         {
             var engine = new MockEngine(_output);
diff --git a/src/Tasks.UnitTests/HintPathResolver_Tests.cs b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
index eb80da45cf8..a62b711cf18 100644
--- a/src/Tasks.UnitTests/HintPathResolver_Tests.cs
+++ b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
@@ -8,6 +8,7 @@
 using System.Collections.Generic;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -36,8 +37,7 @@ public void CanResolveHintPath()
             result.ShouldBe(true);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void CanResolveLongNonNormalizedHintPath()
         {
             var tempfolder = _env.DefaultTestDirectory.CreateDirectory("tempfolder_for_CanResolveLongHintPath");
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index eb267ef08e7..f8dcf89bbfe 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -391,7 +391,6 @@ public void LogErrorWhenBuildingVCProj()
 #else
         [Fact]
 #endif
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyOverridesContainSemicolon()
         {
             ObjectModelHelpers.DeleteTempProjectDirectory();
diff --git a/src/Tasks.UnitTests/MakeDir_Tests.cs b/src/Tasks.UnitTests/MakeDir_Tests.cs
index b05bd654604..2eb1c473196 100644
--- a/src/Tasks.UnitTests/MakeDir_Tests.cs
+++ b/src/Tasks.UnitTests/MakeDir_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -59,8 +60,7 @@ public void AttributeForwarding()
         /// Check that if we fail to create a folder, we don't pass
         /// through the input.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "Under Unix all filenames are valid and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "Under Unix all filenames are valid and this test is not useful.")]
         public void SomeInputsFailToCreate()
         {
             string temp = Path.GetTempPath();
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 3acd8c56824..e8e1b49e6ba 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -57,7 +57,12 @@
       <Link>TestEnvironment.cs</Link>
     </Compile>
     <Compile Include="..\Shared\ProcessExtensions.cs" />
+    <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
+    
+    <Compile Include="..\Shared\UnitTests\LongPathSupportDisabledFactAttribute.cs">
+      <Link>Shared\LongPathSupportDisabledFactAttribute.cs</Link>
+    </Compile>
 
     <EmbeddedResource Include="SampleResx" />
     <EmbeddedResource Include="AssemblyDependency\CacheFileSamples\Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache" />
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index d76e34bd350..eff307187e2 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -413,8 +414,7 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
         /// MovedFiles should only include files that were successfully moved 
         /// (or skipped), not files for which there was an error.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "Under Unix all filenames are valid and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "Under Unix all filenames are valid and this test is not useful.")]
         public void OutputsOnlyIncludeSuccessfulMoves()
         {
             string temp = Path.GetTempPath();
@@ -493,8 +493,7 @@ public void OutputsOnlyIncludeSuccessfulMoves()
         /// <summary>
         /// Moving a locked file will fail
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "File locking Unix differs significantly from Windows"
+        [WindowsOnlyFact(additionalMessage: "File locking Unix differs significantly from Windows.")]
         public void MoveLockedFile()
         {
             string file = null;
@@ -588,8 +587,7 @@ public void SourceFileIsDirectory()
         /// Moving a file on top of itself should be a success (no-op).
         /// Variation with different casing/relativeness.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "File names under Unix are case-sensitive and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "File names under Unix are case-sensitive and this test is not useful.")]
         public void MoveFileOnItself2()
         {
             string currdir = Directory.GetCurrentDirectory();
@@ -781,8 +779,7 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
         /// If the destination path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException 
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
@@ -818,8 +815,7 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         /// If the source path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException 
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
         {
             string sourceFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
diff --git a/src/Tasks.UnitTests/OutputPathTests.cs b/src/Tasks.UnitTests/OutputPathTests.cs
index ddfd43951b7..af1d3902804 100644
--- a/src/Tasks.UnitTests/OutputPathTests.cs
+++ b/src/Tasks.UnitTests/OutputPathTests.cs
@@ -12,6 +12,7 @@
 
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -151,7 +152,7 @@ public void BothBaseOutputPathAndOutputPathWereSpecified()
         /// <summary>
         /// Test for [MSBuild]::NormalizePath and [MSBuild]::NormalizeDirectory returning current directory instead of current Project directory.
         /// </summary>
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsWindows), Skip = "Skipping this test for now until we have a consensus about this issue.")]
+        [WindowsOnlyFact(Skip = "Skipping this test for now until we have a consensus about this issue.")]
         public void MSBuildNormalizePathShouldReturnProjectDirectory()
         {
             // Arrange
diff --git a/src/Tasks.UnitTests/PortableTasks_Tests.cs b/src/Tasks.UnitTests/PortableTasks_Tests.cs
index 38457261232..e409d1f61bd 100644
--- a/src/Tasks.UnitTests/PortableTasks_Tests.cs
+++ b/src/Tasks.UnitTests/PortableTasks_Tests.cs
@@ -9,6 +9,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -29,9 +30,7 @@ public PortableTasks_Tests(ITestOutputHelper outputHelper)
             _outputHelper = outputHelper;
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio install for .NET.")]
         public void TestDesktopMSBuildShouldRunPortableTask()
         {
             RunMSBuildOnProjectWithPortableTaskAndAssertOutput(true);
diff --git a/src/Tasks.UnitTests/RegressionTests.cs b/src/Tasks.UnitTests/RegressionTests.cs
index 6ca6b081557..a92f5e148dc 100644
--- a/src/Tasks.UnitTests/RegressionTests.cs
+++ b/src/Tasks.UnitTests/RegressionTests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.UnitTests;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -51,7 +52,7 @@ public void OverrideBaseIntermediateOutputPathSucceeds()
         /// <summary>
         /// Tests fix for https://github.com/dotnet/msbuild/issues/1479.
         /// </summary>
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsWindows))]
+        [WindowsOnlyFact]
         public void AssemblyAttributesLocation()
         {
             var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.8.AssemblyAttributes.cs");
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 0768fb9ea36..afc8048fea0 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -475,7 +475,6 @@ public void DelaySignWithoutEitherKeyFileOrKeyContainer()
         /// Test if assemblies located in the gac get their CopyLocal attribute set to False
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CheckSetCopyLocalToFalseOnEmbedInteropTypesAssemblies()
         {
             string gacPath = @"C:\windows\gac";
@@ -564,7 +563,6 @@ public void CheckSetCopyLocalToFalseOnEmbedInteropTypesAssemblies()
         /// Test if assemblies located in the gac get their CopyLocal attribute set to False
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CheckSetCopyLocalToFalseOnGacAssemblies()
         {
             string gacPath = @"C:\windows\gac";
diff --git a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
index 9948b29d469..3cf283c5a6b 100644
--- a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
@@ -125,7 +125,6 @@ private void TestResolveHelper(string itemSpec, string projectGuid, string packa
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestResolve()
         {
             // empty pre-generated string
@@ -209,7 +208,6 @@ private void TestUnresolvedReferencesHelper(ArrayList projectRefs, Hashtable pre
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestManagedCheck()
         {
             Hashtable unresolvedOutputs = null;
@@ -239,7 +237,6 @@ public void TestManagedCheck()
         /// Verifies that the UnresolvedProjectReferences output parameter is populated correctly.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestUnresolvedReferences()
         {
             ArrayList projectRefs = new ArrayList();
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index 8fd537d5c4f..d9a11b3e2d1 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -8,20 +8,17 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
-
-
-
 using SDKReference = Microsoft.Build.Tasks.ResolveSDKReference.SDKReference;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Xunit;
+using Xunit.NetCore.Extensions;
 using Shouldly;
 
 #nullable disable
 
 namespace Microsoft.Build.UnitTests.ResolveSDKReference_Tests
 {
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class ResolveSDKReferenceTestFixture
     {
         private Microsoft.Build.UnitTests.MockEngine.GetStringDelegate _resourceDelegate = new Microsoft.Build.UnitTests.MockEngine.GetStringDelegate(AssemblyResources.GetString);
@@ -35,7 +32,7 @@ public class ResolveSDKReferenceTestFixture
         /// <summary>
         /// Make sure that SDK reference which should be good are parsed correctly.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ParseItemSpecGood()
         {
             TestGoodSDKReferenceIncludes(new TaskItem("Cat, Version=8.0"), "Cat", "8.0");
@@ -51,7 +48,7 @@ public void ParseItemSpecGood()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct error.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ParseItemSpecBadNames()
         {
             // These should all be bad the format must be   <SDKName>, Version=<SDKVersion>.
@@ -72,7 +69,7 @@ public void ParseItemSpecBadNames()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct error.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ParseDependsOnString()
         {
             Assert.Empty(ResolveSDKReference.ParseDependsOnSDK(null));
@@ -93,7 +90,7 @@ public void ParseDependsOnString()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct error.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetUnResolvedDependentSDKs()
         {
             HashSet<SDKReference> resolvedSDKsEmpty = new HashSet<SDKReference>();
@@ -121,7 +118,7 @@ public void GetUnResolvedDependentSDKs()
             Assert.Equal("\"baz, Version=2.0\"", result[1]);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyBuildWarningForESDKWithoutMaxPlatformVersionOnBlueOrAbove()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "TestMaxPlatformVersionWithTargetFrameworkVersion");
@@ -312,7 +309,7 @@ public void VerifyBuildWarningForESDKWithoutMaxPlatformVersionOnBlueOrAbove()
         /// <summary>
         /// Verify "RuntimeReferenceOnly" equals to "true" is set for specified references
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyAddMetadataToReferences()
         {
             MockEngine engine = new MockEngine();
@@ -354,7 +351,7 @@ public void VerifyAddMetadataToReferences()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct warning.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyUnResolvedSDKMessage()
         {
             MockEngine engine = new MockEngine();
@@ -429,7 +426,7 @@ public void VerifyUnResolvedSDKMessage()
         /// <summary>
         /// Verify if the DependsOn metadata is set on the reference item and that dependency is not resolved then cause the warning to happen.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyDependencyWarningFromMetadata()
         {
             // Create the engine.
@@ -460,7 +457,7 @@ public void VerifyDependencyWarningFromMetadata()
         /// <summary>
         /// Verify we get the correct dependson warning
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyDependsOnWarningFromManifest()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "VerifyDependsOnWarningFromManifest");
@@ -527,7 +524,7 @@ public void VerifyDependsOnWarningFromManifest()
         /// <summary>
         /// Make sure the equals works on the SDKReference.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void TestSDkReferenceEquals()
         {
             ITaskItem dummyItem = new TaskItem();
@@ -575,7 +572,7 @@ private static void TestBadSDKReferenceIncludes(ITaskItem referenceInclude)
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:true Target:msil Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit1()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit1");
@@ -630,7 +627,7 @@ public void Prefer32bit1()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:false Target:AnyCPU Expect: error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit2()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit2");
@@ -688,7 +685,7 @@ public void Prefer32bit2()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:false Target:x86 Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit3()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit3");
@@ -743,7 +740,7 @@ public void Prefer32bit3()
         /// <summary>
         /// Project: Prefer32bit false  Manifest:SupportPrefer32Bit:false Target:msil Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit4()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit4");
@@ -798,7 +795,7 @@ public void Prefer32bit4()
         /// <summary>
         /// Project: Prefer32bit false  Manifest:SupportPrefer32Bit:false Target:x86 Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit5()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit5");
@@ -853,7 +850,7 @@ public void Prefer32bit5()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:FOO Target:msil Expect: error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit6()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit6");
@@ -910,7 +907,7 @@ public void Prefer32bit6()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:empty Target:msil Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit7()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit7");
@@ -965,7 +962,7 @@ public void Prefer32bit7()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:missing Target:msil Expect: No Error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit8()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit8");
@@ -1019,7 +1016,7 @@ public void Prefer32bit8()
         /// <summary>
         /// Project: Prefer32bit false  Manifest:SupportPrefer32Bit:true Target:msil Expect: No Error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit9()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit9");
@@ -1075,7 +1072,7 @@ public void Prefer32bit9()
         /// Resolve from an SDK which exists and is not a framework SDK. This means there is no frameworkIdentity or APPXLocation.
         /// Also since no configuration or architecture were passed in we expect the defaults.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ResolveFromNonFrameworkNoManifest()
         {
             // Create the engine.
@@ -1112,7 +1109,7 @@ public void ResolveFromNonFrameworkNoManifest()
         /// Resolve from an SDK which exists and is not a framework SDK. This means there is no frameworkIdentity or APPXLocation.
         /// Also since no configuration or architecture were passed in we expect the defaults.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ResolveFromNonFrameworkPassInConfigAndArch()
         {
             // Create the engine.
@@ -1150,7 +1147,7 @@ public void ResolveFromNonFrameworkPassInConfigAndArch()
         /// Resolve from an SDK which exists and is not a framework SDK. This means there is no frameworkIdentity or APPXLocation.
         /// Also since no configuration or architecture were passed in we expect the defaults.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ResolveFromNonFrameworkPassInConfigAndArchOverrideByMetadata()
         {
             // Create the engine.
@@ -1191,7 +1188,7 @@ public void ResolveFromNonFrameworkPassInConfigAndArchOverrideByMetadata()
         /// <summary>
         /// When duplicate references are passed in we only want the first one.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void DuplicateSDKReferences()
         {
             // Create the engine.
@@ -1227,7 +1224,7 @@ public void DuplicateSDKReferences()
         /// Verify that if references have SDKName metadata on them that matches a resolved SDK then that SDK should
         /// not have its reference assemblies expanded.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void DoNotExpandSDKsWhichAreAlsoTargetedByReferences()
         {
             // Create the engine.
@@ -1299,7 +1296,7 @@ public void DoNotExpandSDKsWhichAreAlsoTargetedByReferences()
         /// <summary>
         /// When InstalledSDK is empty we should log a message and succeed.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InstalledSDKEmpty()
         {
             // Create the engine.
@@ -1323,7 +1320,7 @@ public void InstalledSDKEmpty()
         /// <summary>
         /// Lets have a mix of install sdk items, some are good, some are bad (missing item spec) others are bad (missing SDKName)
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MixOfInstalledSDKItemsGoodDuplicateAndBad()
         {
             // Create the engine.
@@ -1373,7 +1370,7 @@ public void MixOfInstalledSDKItemsGoodDuplicateAndBad()
         /// <summary>
         /// Make sure when no sdks are resolved there are no problems and that the names of the sdks which were not resolved are logged.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NOSDKResolved()
         {
             // Create the engine.
@@ -1401,7 +1398,7 @@ public void NOSDKResolved()
         /// When there is a mix of resolved and unresolved SDKs make sure that the resolved ones are correctly found
         /// and the unresolved ones are logged.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MixOfResolvedAndUnResolved()
         {
             // Create the engine.
@@ -1432,7 +1429,7 @@ public void MixOfResolvedAndUnResolved()
         /// <summary>
         /// When a null is passed into the SDKReferences property make sure we get the correct exception out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullSDKReferences()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -1448,7 +1445,7 @@ public void NullSDKReferences()
         /// <summary>
         /// When a null is passed into the set of InstalledSDKS property make sure we get the correct exception out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullInstalledSDKs()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -1465,7 +1462,7 @@ public void NullInstalledSDKs()
         /// <summary>
         /// If no SDKReferences are passed in then we should get nothing out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptySDKReferencesList()
         {
             // Create the engine.
@@ -1489,7 +1486,7 @@ public void EmptySDKReferencesList()
         /// When we find the SDKManifest it may be poorly formatted. If that happens we need to log the error
         /// and not resolve the SDK. We also add a good one as well to make sure resolution continues.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SDKFoundButBadlyFormattedSDKManifestWarnings()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SDKFoundButBadlyFormattedSDKManifestWarnings");
@@ -1548,8 +1545,7 @@ public void SDKFoundButBadlyFormattedSDKManifestWarnings()
         /// When we find the SDKManifest it may be poorly formatted. If that happens we need to log the error
         /// and not resolve the SDK. We also add a good one as well to make sure resolution continues.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void SDKFoundButBadlyFormattedSDKManifestErrors()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SDKFoundButBadlyFormattedSDKManifestErrors");
@@ -1600,7 +1596,7 @@ public void SDKFoundButBadlyFormattedSDKManifestErrors()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void TestMaxPlatformVersionWithTargetFrameworkVersion()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "TestMaxPlatformVersionWithTargetFrameworkVersion");
@@ -1706,7 +1702,7 @@ public void TestMaxPlatformVersionWithTargetFrameworkVersion()
         /// <summary>
         /// Test the case where the manifest attributes are empty.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptySDKManifestAttributes()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "EmptySDKManifestAttributes");
@@ -1791,7 +1787,7 @@ public void EmptySDKManifestAttributes()
         /// <summary>
         /// Test the case where we override ALL of the manifest properties with ones on the metadata
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void OverrideManifestAttributes()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestAttributes");
@@ -1889,7 +1885,7 @@ public void OverrideManifestAttributes()
         /// <summary>
         /// Test the case where we Have a good manifest that had framework and appx locations that exactly match the targeted sdk configuration and architecture.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GoodManifestMatchingConfigAndArch()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GoodManifestMatchingConfigAndArch");
@@ -1962,7 +1958,7 @@ public void GoodManifestMatchingConfigAndArch()
         /// <summary>
         /// Test the case where we Have a good manifest that had framework and appx locations that only match the targeted sdk configuration.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GoodManifestMatchingConfigOnly()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GoodManifestMatchingConfigOnly");
@@ -2031,7 +2027,7 @@ public void GoodManifestMatchingConfigOnly()
         /// <summary>
         /// TVerify that when a platform identity is found that we do not copy the references or redist
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NoCopyOnPlatformIdentityFound()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "NoCopyOnPlatformIdentityFound");
@@ -2098,7 +2094,7 @@ public void NoCopyOnPlatformIdentityFound()
         /// Test the case where we Have a good manifest that had framework and appx locations that does not match any of the config arch combinations but does match
         /// and entry name simply FrameworkIdentity or APPX
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GoodManifestMatchingBaseNameOnly()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GoodManifestMatchingConfigOnly");
@@ -2172,7 +2168,7 @@ public void GoodManifestMatchingBaseNameOnly()
         /// <summary>
         /// Test the case where we only have the arm APPX and it can be found
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ManifestOnlyHasArmLocation()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ManifestOnlyHasArmLocation");
@@ -2240,7 +2236,7 @@ public void ManifestOnlyHasArmLocation()
         /// <summary>
         /// Test the case where we have a number of locations and arm APPX and can be found
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ManifestArmLocationWithOthers()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ManifestArmLocationWithOthers");
@@ -2311,7 +2307,7 @@ public void ManifestArmLocationWithOthers()
         /// Test the case where there are framework identity attributes but none of the match and there is no base FrameworkIdentity, the
         /// same is true for APPX.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MatchNoNamesButNamesExistWarning()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MatchNoNamesButNamesExistWarning");
@@ -2383,7 +2379,7 @@ public void MatchNoNamesButNamesExistWarning()
         /// Test the case where there are framework identity attributes but none of the match and there is no base FrameworkIdentity, the
         /// same is true for APPX.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MatchNoNamesButNamesExistError()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MatchNoNamesButNamesExistError");
@@ -2452,7 +2448,7 @@ public void MatchNoNamesButNamesExistError()
         /// <summary>
         /// Test the case where there is a single supported architecture and the project targets that architecture
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SingleSupportedArchitectureMatchesProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SingleSupportedArchitectureMatchesProject");
@@ -2525,7 +2521,7 @@ public void SingleSupportedArchitectureMatchesProject()
         /// <summary>
         /// Test the case where the productfamily is set in the manifest and not as metadata on the reference item.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ProductFamilySetInManifest()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ProductFamilySetInManifest");
@@ -2590,7 +2586,7 @@ public void ProductFamilySetInManifest()
         /// <summary>
         /// Test the case where the productfamily is set in the manifest and as metadata on the reference item. Expect the metadata to win.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ProductFamilySetInManifestAndMetadata()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ProductFamilySetInManifestAndMetadata");
@@ -2657,7 +2653,7 @@ public void ProductFamilySetInManifestAndMetadata()
         /// <summary>
         /// Test the case where the SupportsMultipleVersions is NOT in the manifest or on metadata
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SupportsMultipleVersionsNotInManifest()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SupportsMultipleVersionsNotInManifest");
@@ -2721,7 +2717,7 @@ public void SupportsMultipleVersionsNotInManifest()
         /// <summary>
         /// Test the case where metadata on the item is bad, we should then read from the manifest.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SupportsMultipleVersionsBadMetadata()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SupportsMultipleVersionsBadMetadata");
@@ -2789,7 +2785,7 @@ public void SupportsMultipleVersionsBadMetadata()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same product family
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenSameProductFamilySameName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameProductFamilySameName");
@@ -2887,7 +2883,7 @@ public void ConflictsBetweenSameProductFamilySameName()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same product family
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenSameProductFamilyDiffName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameProductFamilyDiffName");
@@ -2985,7 +2981,7 @@ public void ConflictsBetweenSameProductFamilyDiffName()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same product family
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenMIXPFAndName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameProductFamilyDiffName");
@@ -3098,7 +3094,7 @@ public void ConflictsBetweenMIXPFAndName()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same SDK Name
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenSameSDKName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameSDKName");
@@ -3196,7 +3192,7 @@ public void ConflictsBetweenSameSDKName()
         /// <summary>
         /// Test the case where metadata on the item is bad, we should then read from the manifest.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SupportsMultipleVersionsReadManifest()
         {
             SupportsMultipleVersionsVerifyManifestReading("Error");
@@ -3278,7 +3274,7 @@ private void SupportsMultipleVersionsVerifyManifestReading(string manifestEntry)
         /// <summary>
         /// Test the case where the supportedArchitectures are empty
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptyArchitectures()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestWithMetadata");
@@ -3355,7 +3351,7 @@ public void EmptyArchitectures()
         /// <summary>
         /// Test the case where the metadata on the reference overrides what is in the manifest but it does not match what is being targeted
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void OverrideManifestWithMetadataButMetadataDoesNotMatch()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestWithMetadataButMetadataDoesNotMatch");
@@ -3421,7 +3417,7 @@ public void OverrideManifestWithMetadataButMetadataDoesNotMatch()
         /// <summary>
         /// Test the case where the metadata on the reference overrides what is in the manifest
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void OverrideManifestWithMetadata()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestWithMetadata");
@@ -3499,7 +3495,7 @@ public void OverrideManifestWithMetadata()
         /// <summary>
         /// Test the case where there is a single supported architecture and the project does not target that architecture
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SingleSupportedArchitectureDoesNotMatchProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SingleSupportedArchitectureDoesNotMatchProject");
@@ -3563,7 +3559,7 @@ public void SingleSupportedArchitectureDoesNotMatchProject()
         /// <summary>
         /// Test the case where there is are multiple supported architecture and the project targets one of those architectures
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MultipleSupportedArchitectureMatchesProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MultipleSupportedArchitectureMatchesProject");
@@ -3635,7 +3631,7 @@ public void MultipleSupportedArchitectureMatchesProject()
         /// <summary>
         /// Test the case where there is are multiple supported architecture and the project does not match one of those architectures
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MultipleSupportedArchitectureDoesNotMatchProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MultipleSupportedArchitectureMatchesProject");
@@ -3701,11 +3697,9 @@ public void MultipleSupportedArchitectureDoesNotMatchProject()
     /// <summary>
     /// Test the output groups which will be used to generate the recipe fileGatherSDKOutputGroups
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class GatherSDKOutputGroupsTestFixture
     {
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void GatherSDKOutputGroupsTargetArchitectureExists()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GatherSDKOutputGroupsWithFramework");
@@ -3848,8 +3842,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void GatherSDKOutputGroupsTargetArchitectureExists2()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GatherSDKOutputGroupsWithFramework");
@@ -3993,8 +3986,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists2()
         }
 
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void GatherSDKOutputGroupsTargetArchitectureDoesNotExists()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GatherSDKOutputGroupsTargetArchitectureDoesNotExists");
@@ -4103,8 +4095,7 @@ public void GatherSDKOutputGroupsTargetArchitectureDoesNotExists()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void CheckDefaultingOfTargetConfigAndArchitecture()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "CheckDefaultingOfTargetConfigAndArchitecture");
@@ -4201,8 +4192,7 @@ public void CheckDefaultingOfTargetConfigAndArchitecture()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyPlatformAliasesWork()
         {
             // This verifies that UAP is an alias for windows, so verifying the target platforms align. Other parts of the reference don't matter here.
@@ -4224,8 +4214,7 @@ public void VerifyPlatformAliasesWork()
             reference.TargetPlatform.ShouldBe("UAP");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void CheckAttributesFromManifestArePassedToResolvedAssemblies()
         {
             /* \Microsoft SDKs\Windows\v8.0\ExtensionSDKs */
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index f2c6b9d0524..4a2dcdac485 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Shared;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 using System.IO;
 using System.Threading;
 using Shouldly;
@@ -17,8 +18,6 @@
 
 namespace Microsoft.Build.UnitTests.GenerateResource_Tests.OutOfProc
 {
-    [Trait("Category", "mono-osx-failing")]
-    [Trait("Category", "mono-windows-failing")]
     public sealed class RequiredTransformations
     {
         private readonly ITestOutputHelper _output;
@@ -491,7 +490,6 @@ public void AllowLinkedNoGenerate()
         ///  Allow the task to skip processing based on having nothing out of date
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void NothingOutOfDate()
         {
             string resxFile = null;
@@ -571,8 +569,6 @@ public void NothingOutOfDate()
         /// </summary>
         /// <remarks>System dll is not locked because it forces a new app domain</remarks>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void NothingOutOfDateExceptReference()
         {
             string resxFile = null;
@@ -973,7 +969,6 @@ public void StronglyTypedResourcesUpToDate()
         /// STR class file is out of date, but resources are up to date. Should still generate it.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void StronglyTypedResourcesOutOfDate()
         {
             string resxFile = null;
@@ -1245,7 +1240,6 @@ public void StronglyTypedResourcesWithoutNamespaceOrClassOrFilename()
         ///  STR with resource namespace yields proper output, message (CS)
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void STRWithResourcesNamespaceCS()
         {
             Utilities.STRNamespaceTestHelper("CSharp", "MyResourcesNamespace", null, _output);
@@ -1273,7 +1267,6 @@ public void STRWithResourcesNamespaceAndSTRNamespaceCS()
         ///  STR with resource namespace and STR namespace yields proper output, message (CS)
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void STRWithResourcesNamespaceAndSTRNamespaceVB()
         {
             Utilities.STRNamespaceTestHelper("VB", "MyResourcesNamespace", "MySTClassNamespace", _output);
@@ -1293,7 +1286,6 @@ public TransformationErrors(ITestOutputHelper output)
         ///  Text input failures, no name, no '=', 'strings' token, invalid token, invalid escape
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TextToResourcesBadFormat()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1359,8 +1351,6 @@ public void TextToResourcesBadFormat()
         ///  Cause failures in ResXResourceReader
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void FailedResXReader()
         {
             string resxFile1 = null;
@@ -1427,8 +1417,6 @@ public void FailedResXReader()
         ///  Cause failures in ResXResourceReader, different codepath
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void FailedResXReaderWithAllOutputResourcesSpecified()
         {
             string resxFile1 = null;
@@ -1502,7 +1490,6 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
         ///  Duplicate resource names
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void DuplicateResourceNames()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1528,7 +1515,6 @@ public void DuplicateResourceNames()
         ///  Non-string resource with text output
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UnsupportedTextType()
         {
             string bitmap = Utilities.CreateWorldsSmallestBitmap();
@@ -1596,7 +1582,6 @@ public void InvalidStateFile()
         ///  Cause failures in ResourceReader
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void FailedResourceReader()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1630,7 +1615,6 @@ public void FailedResourceReader()
         ///  Invalid STR Class name
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void FailedSTRProperty()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1818,8 +1802,6 @@ public void OutputFilesNotSpecified()
         ///  FilesWritten contains OutputResources + StateFile
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void FilesWrittenSet()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1860,8 +1842,6 @@ public void FilesWrittenSet()
         ///  Resource transformation fails on 3rd of 4 inputs, inputs 1 & 2 & 4 are in outputs and fileswritten.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void OutputFilesPartialInputs()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1928,8 +1908,6 @@ public void OutputFilesPartialInputs()
         ///  STR class name derived from output file transformation
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void StronglyTypedClassName()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1971,8 +1949,6 @@ public void StronglyTypedClassName()
         ///  STR class file name derived from class name transformation
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void StronglyTypedFileName()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -2081,7 +2057,6 @@ public void ReferencesToBadAssemblies()
         ///  Source item not found
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SourceItemMissing()
         {
             string txtFile = null;
@@ -2123,9 +2098,7 @@ public void SourceItemMissing()
         /// <summary>
         ///  Non-existent StateFile yields message
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-windows-failing")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void StateFileUnwritable()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -2165,7 +2138,6 @@ public void StateFileUnwritable()
         ///  Bad file extension on input
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void InputFileExtension()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -2199,7 +2171,6 @@ public void InputFileExtension()
         ///  Bad file extension on output
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void OutputFileExtension()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -2265,7 +2236,6 @@ public void SourcesMatchesOutputResources()
         ///  Invalid StronglyTypedLanguage yields CodeDOM exception
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UnknownStronglyTypedLanguage()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -2349,8 +2319,6 @@ public void StronglyTypedResourceWithMoreThanOneInputResourceFile()
         ///  STR class name derived from output file transformation
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void BadStronglyTypedFilename()
         {
             string txtFile = null;
@@ -2506,7 +2474,6 @@ public void StronglyTypedResourceFilenameWithoutLanguage()
         /// Verify that passing a STR language with more than 1 sources errors
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void StronglyTypedResourceFileIsExistingDirectory()
         {
             string dir = null;
@@ -2602,7 +2569,6 @@ public References(ITestOutputHelper output)
         [Fact]
         // FIXME: mono: looks for csc.exe
         // https://github.com/dotnet/msbuild/issues/677
-        [Trait("Category", "mono-osx-failing")]
         public void DontLockP2PReferenceWhenResolvingSystemTypes()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -2780,7 +2746,6 @@ public class Class1
         [Fact]
         // FIXME: mono: looks for csc.exe
         // https://github.com/dotnet/msbuild/issues/677
-        [Trait("Category", "mono-osx-failing")]
         public void ReferencedAssemblySpecifiedUsingRelativePath()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 1a62accb608..b63883cf855 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -16,13 +16,12 @@
 using Xunit.Abstractions;
 using System.Collections.Generic;
 using System.Text.RegularExpressions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
 namespace Microsoft.Build.UnitTests.GenerateResource_Tests.InProc
 {
-    [Trait("Category", "mono-osx-failing")]
-    [Trait("Category", "mono-windows-failing")]
     public sealed class RequiredTransformations : IDisposable
     {
         private readonly TestEnvironment _env;
@@ -1523,8 +1522,7 @@ public void StronglyTypedResourcesWithoutNamespaceOrClassOrFilename()
         /// <remarks>
         /// Regression test for legacy-codepath-resources case of https://github.com/dotnet/msbuild/issues/4582
         /// </remarks>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/2272")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "https://github.com/dotnet/msbuild/issues/2272")]
         public void StronglyTypedResourcesEmitTypeIntoClass()
         {
             string bitmap = Utilities.CreateWorldsSmallestBitmap();
@@ -1946,8 +1944,7 @@ public void InvalidStateFile()
         /// <summary>
         ///  Cause failures in ResourceReader
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core MSBuild doesn't try to read binary input resources")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core MSBuild doesn't try to read binary input resources.")]
         public void FailedResourceReader()
         {
             GenerateResource t = Utilities.CreateTask(_output);
@@ -1976,10 +1973,9 @@ public void FailedResourceReader()
             }
         }
 
-        [Theory]
+        [DotNetOnlyTheory(additionalMessage: "This error is .NET Core only.")]
         [InlineData(".resources")]
         [InlineData(".dll")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework, "This error is .NET Core only")]
         public void ResourceReaderRejectsNonCoreCompatFormats(string inputExtension)
         {
             using var env = TestEnvironment.Create(_output);
@@ -2037,9 +2033,7 @@ public void FailedSTRProperty()
         /// <summary>
         /// Reference passed in that can't be loaded should error
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp,
-            reason: ".NET Core MSBuild doesn't load refs so it pushes this failure to runtime")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core MSBuild doesn't load refs so it pushes this failure to runtime.")]
         public void InvalidReference()
         {
             string txtFile = null;
@@ -2319,8 +2313,7 @@ public void OutputFilesPartialInputs()
         ///  STR class name derived from output file transformation
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
+
         public void StronglyTypedClassName()
         {
             GenerateResource t = Utilities.CreateTask(_output);
@@ -2366,8 +2359,6 @@ public void StronglyTypedClassName()
         ///  STR class file name derived from class name transformation
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void StronglyTypedFileName()
         {
             GenerateResource t = Utilities.CreateTask(_output);
@@ -2520,8 +2511,7 @@ public void SourceItemMissing()
         /// <summary>
         ///  Read-only StateFile yields message
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void StateFileUnwritable()
         {
             GenerateResource t = Utilities.CreateTask(_output);
@@ -2657,7 +2647,6 @@ public void SourcesMatchesOutputResources()
         ///  Invalid StronglyTypedLanguage yields CodeDOM exception
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UnknownStronglyTypedLanguage()
         {
             GenerateResource t = Utilities.CreateTask(_output);
@@ -2942,9 +2931,7 @@ public void StronglyTypedResourceFileIsExistingDirectory()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
         public void Regress25163_OutputResourcesContainsInvalidPathCharacters()
         {
             string resourcesFile = null;
@@ -2982,9 +2969,7 @@ public References(ITestOutputHelper output)
             _output = output;
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "Linked resources not supported on Core: https://github.com/dotnet/msbuild/issues/4094")]
-        [SkipOnMono("https://github.com/dotnet/msbuild/issues/677")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "Linked resources not supported on Core: https://github.com/dotnet/msbuild/issues/4094")]
         public void DontLockP2PReferenceWhenResolvingSystemTypes()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -3160,9 +3145,7 @@ public class Class1
         /// which fails (LoadFile requires an absolute path).  The fix was to use
         /// Assembly.LoadFrom instead.
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "Linked resources not supported on Core: https://github.com/dotnet/msbuild/issues/4094")]
-        [SkipOnMono("https://github.com/dotnet/msbuild/issues/677")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "Linked resources not supported on Core: https://github.com/dotnet/msbuild/issues/4094")]
         public void ReferencedAssemblySpecifiedUsingRelativePath()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
index 35138733840..6b99bca8e7d 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
@@ -25,7 +25,6 @@ public class ResGen_Tests
         ///  - Verify that OutputFiles defaults appropriately
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void InputFiles()
         {
             ResGen t = new ResGen();
@@ -87,7 +86,6 @@ public void InputFiles()
         ///  - Verify that if OutputFiles are set explicitly, they map and show up on the command line as expected
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void OutputFiles()
         {
             ResGen t = new ResGen();
@@ -164,7 +162,6 @@ public void OutputFiles()
         /// Tests ResGen's /publicClass switch
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PublicClass()
         {
             ResGen t = new ResGen();
@@ -185,7 +182,6 @@ public void PublicClass()
         /// Tests the /r: parameter (passing in reference assemblies)
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void References()
         {
             ResGen t = new ResGen();
@@ -469,7 +465,6 @@ public void ToolPath()
         /// Tests ResGen's /useSourcePath switch
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UseSourcePath()
         {
             ResGen t = new ResGen();
diff --git a/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs b/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
index a381e987783..0fd3095dd12 100644
--- a/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
+++ b/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using Microsoft.Build.Tasks;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -181,14 +182,9 @@ public void GeneratePathToToolX86DoesNotExistAnywhere()
         /// <summary>
         /// Test the case where there are illegal chars in the sdktoolspath and Path.combine has a problem.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("No invalid path characters under Unix.")]
         public void VerifyErrorWithIllegalChars()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "No invalid path characters under Unix"
-            }
-
             string toolPath = SdkToolsPathUtility.GeneratePathToTool(_mockExists.MockFileDoesNotExist, ProcessorArchitecture.X86, "./?><;)(*&^%$#@!", _toolName, _log, true);
             Assert.Null(toolPath);
             _mockEngine.AssertLogContains("MSB3666");
diff --git a/src/Tasks.UnitTests/TlbImp_Tests.cs b/src/Tasks.UnitTests/TlbImp_Tests.cs
index da394bbb651..0827599cb35 100644
--- a/src/Tasks.UnitTests/TlbImp_Tests.cs
+++ b/src/Tasks.UnitTests/TlbImp_Tests.cs
@@ -68,7 +68,6 @@ public void TypeLibName()
         /// Tests that the assembly being imported is passed to the command line
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TypeLibNameWithSpaces()
         {
             var t = new ResolveComReference.TlbImp();
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index 3e74d5ef77c..26de13ddc87 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -110,8 +111,7 @@ public void CanUnzip_ExplicitDirectoryEntries()
             }
         }
 
-        [PlatformSpecific(TestPlatforms.Windows)] // Can't figure out how to make CreateDirectory throw on non-Windows
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Can't figure out how to make CreateDirectory throw on non-Windows.")]
         public void LogsErrorIfDirectoryCannotBeCreated()
         {
             Unzip unzip = new Unzip
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index 962dd1ec0a4..2d52b6f8855 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -10,6 +10,7 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 using Shouldly;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -24,7 +25,6 @@ public class WriteCodeFragment_Tests
         /// Need an available language
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void InvalidLanguage()
         {
             WriteCodeFragment task = new WriteCodeFragment();
@@ -194,8 +194,7 @@ public void InvalidFilePath()
         /// <summary>
         /// Bad directory path
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "No invalid characters on Unix"
+        [WindowsOnlyFact(additionalMessage: "No invalid characters on Unix.")]
         public void InvalidDirectoryPath()
         {
             WriteCodeFragment task = new WriteCodeFragment();
@@ -247,7 +246,6 @@ public void OneAttributeNoParams()
         /// Test with the VB language
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void OneAttributeNoParamsVb()
         {
             WriteCodeFragment task = new WriteCodeFragment();
@@ -493,7 +491,6 @@ public void MultilineAttributeCSharp()
         /// Multi line argument values should cause a verbatim string to be used
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MultilineAttributeVB()
         {
             var lines = new[] { "line 1", "line 2", "line 3" };
@@ -632,7 +629,6 @@ public void OneAttributePositionalAndNamedParams()
         /// These can also be combined with named params.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void OneAttributePositionalAndNamedParamsVisualBasic()
         {
             WriteCodeFragment task = new WriteCodeFragment();
diff --git a/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs b/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
index c8f2f37161a..cefb96e614a 100644
--- a/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
+++ b/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
@@ -29,7 +29,6 @@ public GeneratedTask()
         /// Test to see whether all of the correct boolean switches are appended.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestDefaultFlags()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -41,7 +40,6 @@ public void TestDefaultFlags()
         /// This test case leaves the default flags the way they are
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestReversibleFlagsWithDefaults()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -55,7 +53,6 @@ public void TestReversibleFlagsWithDefaults()
         /// This test case explicitly sets the ComplexReversible to be false
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestReversibleFlagsWithoutDefaults()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -69,7 +66,6 @@ public void TestReversibleFlagsWithoutDefaults()
         /// Tests to make sure enums are working well.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestBasicString()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -79,7 +75,6 @@ public void TestBasicString()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestDynamicEnum()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -92,7 +87,6 @@ public void TestDynamicEnum()
         /// Tests the basic string array type
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestBasicStringArray()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -107,7 +101,6 @@ public void TestBasicStringArray()
         /// Tests the basic string array type, with an array that contains multiple values.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestBasicStringArray_MultipleValues()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -124,7 +117,6 @@ public void TestBasicStringArray_MultipleValues()
         /// Tests to see whether the integer appears correctly on the command line
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestInteger()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -138,7 +130,6 @@ public void TestInteger()
         /// Tests the (full) functionality of a reversible property
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexReversible()
         {
             // When flag is set to false
@@ -155,7 +146,6 @@ public void TestComplexReversible()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexString()
         {
             // check to see that the resulting value is good
@@ -169,7 +159,6 @@ public void TestComplexString()
         /// Tests the functionality of a string type property
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexStringArray()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -180,7 +169,6 @@ public void TestComplexStringArray()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexIntegerLessThanMin()
         {
             Assert.Throws<InvalidOperationException>(() =>
@@ -191,7 +179,6 @@ public void TestComplexIntegerLessThanMin()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexIntegerGreaterThanMax()
         {
             Assert.Throws<InvalidOperationException>(() =>
@@ -203,7 +190,6 @@ public void TestComplexIntegerGreaterThanMax()
             });
         }
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexIntegerWithinRange()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -248,7 +234,6 @@ public class ProjectFileTests
         /// Tests that when a call to a XamlDataDrivenTask fails, the commandline is reported in the error message.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CommandLineErrorsReportFullCommandlineAmpersandTemp()
         {
             string projectFile = @"
@@ -305,7 +290,6 @@ public void CommandLineErrorsReportFullCommandlineAmpersandTemp()
         /// Tests that when a call to a XamlDataDrivenTask fails, the commandline is reported in the error message.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CommandLineErrorsReportFullCommandline()
         {
             string projectFile = @"
@@ -342,7 +326,6 @@ public void CommandLineErrorsReportFullCommandline()
         /// Tests that when a call to a XamlDataDrivenTask fails, the commandline is reported in the error message.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SquareBracketEscaping()
         {
             string projectFile = @"
diff --git a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
index a2ae014d062..cdcee567020 100644
--- a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
@@ -25,7 +25,6 @@ namespace Microsoft.Build.UnitTests.XamlTaskFactory_Tests
     /// The text fixture to unit test the task generator.
     /// Creates a new TaskGenerator object and tests the various methods
     /// </summary>
-    [Trait("Category", "mono-osx-failing")]
     public sealed class LoadAndParseTests
     {
         /// <summary>
@@ -450,7 +449,6 @@ public class CompilationTests
         /// Code must be compilable on its own.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestGenerateCodeToStream()
         {
             string xmlContents = @"<ProjectSchemaDefinitions xmlns=`clr-namespace:Microsoft.Build.Framework.XamlTypes;assembly=Microsoft.Build.Framework` xmlns:x=`http://schemas.microsoft.com/winfx/2006/xaml` xmlns:sys=`clr-namespace:System;assembly=mscorlib` xmlns:impl=`clr-namespace:Microsoft.VisualStudio.Project.Contracts.Implementation;assembly=Microsoft.VisualStudio.Project.Contracts.Implementation`>
@@ -503,7 +501,6 @@ public void TestGenerateCodeToStream()
         /// Tests to make sure the file generated compiles
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestGenerateToFile()
         {
             string xml = @"<ProjectSchemaDefinitions xmlns=`clr-namespace:Microsoft.Build.Framework.XamlTypes;assembly=Microsoft.Build.Framework` xmlns:x=`http://schemas.microsoft.com/winfx/2006/xaml` xmlns:sys=`clr-namespace:System;assembly=mscorlib` xmlns:impl=`clr-namespace:Microsoft.VisualStudio.Project.Contracts.Implementation;assembly=Microsoft.VisualStudio.Project.Contracts.Implementation`>
@@ -565,7 +562,6 @@ public void TestGenerateToFile()
     #endregion
 
     #region Tests Generated code based on one xml file
-    [Trait("Category", "mono-osx-failing")]
     public sealed class GeneratedTaskTests
     {
         private Assembly _fakeTaskDll;
diff --git a/src/Tasks.UnitTests/XmlPoke_Tests.cs b/src/Tasks.UnitTests/XmlPoke_Tests.cs
index fba347fb692..d78bbcad622 100644
--- a/src/Tasks.UnitTests/XmlPoke_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPoke_Tests.cs
@@ -60,7 +60,6 @@ public void PokeWithNamespace()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PokeNoNamespace()
         {
             const string query = "//variable/@Name";
@@ -271,7 +270,6 @@ public void MissingNamespaceParameters()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PokeElement()
         {
             const string query = "//variable/.";
diff --git a/src/UnitTests.Shared/EnvironmentProvider.cs b/src/UnitTests.Shared/EnvironmentProvider.cs
new file mode 100644
index 00000000000..4ca3c276867
--- /dev/null
+++ b/src/UnitTests.Shared/EnvironmentProvider.cs
@@ -0,0 +1,137 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+#if !NET6_0_OR_GREATER
+using System.Diagnostics;
+#endif
+using System.IO;
+using System.Linq;
+using System.Runtime.InteropServices;
+
+namespace Microsoft.Build.UnitTests.Shared
+{
+    public class EnvironmentProvider
+    {
+        private static class Constants
+        {
+            public const string DotNet = "dotnet";
+            public const string Path = "PATH";
+            public const string DotnetMsbuildSdkResolverCliDir = "DOTNET_MSBUILD_SDK_RESOLVER_CLI_DIR";
+            public static readonly bool RunningOnWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
+            public static readonly string ExeSuffix = RunningOnWindows ? ".exe" : string.Empty;
+        }
+
+        private IEnumerable<string>? _searchPaths;
+
+        private readonly Func<string, string?> _getEnvironmentVariable;
+        private readonly Func<string?> _getCurrentProcessPath;
+
+        public EnvironmentProvider(Func<string, string?> getEnvironmentVariable)
+            : this(getEnvironmentVariable, GetCurrentProcessPath)
+        { }
+
+        public EnvironmentProvider(Func<string, string?> getEnvironmentVariable, Func<string?> getCurrentProcessPath)
+        {
+            _getEnvironmentVariable = getEnvironmentVariable;
+            _getCurrentProcessPath = getCurrentProcessPath;
+        }
+
+        private IEnumerable<string> SearchPaths
+        {
+            get
+            {
+                if (_searchPaths == null)
+                {
+                    var searchPaths = new List<string>();
+
+                    searchPaths.AddRange(
+                        (_getEnvironmentVariable(Constants.Path) ?? string.Empty)
+                        .Split(new char[] { Path.PathSeparator }, options: StringSplitOptions.RemoveEmptyEntries)
+                        .Select(p => p.Trim('"')));
+
+                    _searchPaths = searchPaths;
+                }
+
+                return _searchPaths;
+            }
+        }
+
+        public string? GetCommandPath(string commandName)
+        {
+            var commandNameWithExtension = commandName + Constants.ExeSuffix;
+            var commandPath = SearchPaths
+                .Where(p => !Path.GetInvalidPathChars().Any(p.Contains))
+                .Select(p => Path.Combine(p, commandNameWithExtension))
+                .FirstOrDefault(File.Exists);
+
+            return commandPath;
+        }
+
+        public string? GetDotnetExePath()
+        {
+            string? environmentOverride = _getEnvironmentVariable(Constants.DotnetMsbuildSdkResolverCliDir);
+            if (!string.IsNullOrEmpty(environmentOverride))
+            {
+                return Path.Combine(environmentOverride, Constants.DotNet + Constants.ExeSuffix);
+            }
+
+            string? dotnetExe = _getCurrentProcessPath();
+
+            if (string.IsNullOrEmpty(dotnetExe) || !Path.GetFileNameWithoutExtension(dotnetExe)
+                    .Equals(Constants.DotNet, StringComparison.InvariantCultureIgnoreCase))
+            {
+                string? dotnetExeFromPath = GetCommandPath(Constants.DotNet);
+#if NET
+                if (dotnetExeFromPath != null && !Constants.RunningOnWindows)
+                {
+                    // on Linux the 'dotnet' command from PATH is a symlink so we need to
+                    // resolve it to get the actual path to the binary
+                    FileInfo fi = new FileInfo(dotnetExeFromPath);
+                    while (fi.LinkTarget != null)
+                    {
+                        dotnetExeFromPath = fi.LinkTarget;
+                        fi = new FileInfo(dotnetExeFromPath);
+                    }
+                }
+#endif
+                if (!string.IsNullOrWhiteSpace(dotnetExeFromPath))
+                {
+                    dotnetExe = dotnetExeFromPath;
+                }
+            }
+
+            return dotnetExe;
+        }
+
+        public static string? GetDotnetExePath(Func<string, string?>? getEnvironmentVariable = null)
+        {
+            if (getEnvironmentVariable == null)
+            {
+                getEnvironmentVariable = Environment.GetEnvironmentVariable;
+            }
+            var environmentProvider = new EnvironmentProvider(getEnvironmentVariable);
+            return environmentProvider.GetDotnetExePath();
+        }
+
+        public static string? GetDotnetExePath(Func<string, string?> getEnvironmentVariable, Func<string?> getCurrentProcessPath)
+        {
+            getEnvironmentVariable ??= Environment.GetEnvironmentVariable;
+            getCurrentProcessPath ??= GetCurrentProcessPath;
+            var environmentProvider = new EnvironmentProvider(getEnvironmentVariable, getCurrentProcessPath);
+            return environmentProvider.GetDotnetExePath();
+        }
+
+        private static string? GetCurrentProcessPath()
+        {
+            string? currentProcessPath;
+#if NET6_0_OR_GREATER
+            currentProcessPath = Environment.ProcessPath;
+#else
+            currentProcessPath = Process.GetCurrentProcess().MainModule.FileName;
+#endif
+            return currentProcessPath;
+        }
+    }
+}
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 78b694d815d..4e60b742a8d 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -13,6 +13,9 @@ namespace Microsoft.Build.UnitTests.Shared
     public static class RunnerUtilities
     {
         public static string PathToCurrentlyRunningMsBuildExe => BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+#if !FEATURE_RUN_EXE_IN_TESTS
+        private static readonly string s_dotnetExePath = EnvironmentProvider.GetDotnetExePath();
+#endif
 
         /// <summary>
         /// Invoke the currently running msbuild and return the stdout, stderr, and process exit status.
@@ -32,7 +35,7 @@ public static string ExecMSBuild(string pathToMsBuildExe, string msbuildParamete
 #if FEATURE_RUN_EXE_IN_TESTS
             var pathToExecutable = pathToMsBuildExe;
 #else
-            var pathToExecutable = ResolveRuntimeExecutableName();
+            var pathToExecutable = s_dotnetExePath;
             msbuildParameters = FileUtilities.EnsureDoubleQuotes(pathToMsBuildExe) + " " + msbuildParameters;
 #endif
 
@@ -55,20 +58,6 @@ private static void AdjustForShellExecution(ref string pathToExecutable, ref str
             }
         }
 
-#if !FEATURE_RUN_EXE_IN_TESTS
-        /// <summary>
-        /// Resolve the platform specific path to the runtime executable that msbuild.exe needs to be run in (unix-mono, {unix, windows}-corerun).
-        /// </summary>
-        private static string ResolveRuntimeExecutableName()
-        {
-            // Run the child process with the same host as the currently-running process.
-            using (Process currentProcess = Process.GetCurrentProcess())
-            {
-                return currentProcess.MainModule.FileName;
-            }
-        }
-#endif
-
         /// <summary>
         /// Run the process and get stdout and stderr
         /// </summary>
diff --git a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
index f46e35ee4e3..ff9c8243fea 100644
--- a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
+++ b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
@@ -22,6 +22,11 @@ internal static string ProcessorArchitectureIntToString()
                 NativeMethodsShared.ProcessorArchitectures.IA64 => ProcessorArchitecture.IA64,
                 NativeMethodsShared.ProcessorArchitectures.ARM => ProcessorArchitecture.ARM,
                 NativeMethodsShared.ProcessorArchitectures.ARM64 => ProcessorArchitecture.ARM64,
+                NativeMethodsShared.ProcessorArchitectures.WASM => ProcessorArchitecture.WASM,
+                NativeMethodsShared.ProcessorArchitectures.S390X => ProcessorArchitecture.S390X,
+                NativeMethodsShared.ProcessorArchitectures.LOONGARCH64 => ProcessorArchitecture.LOONGARCH64,
+                NativeMethodsShared.ProcessorArchitectures.ARMV6 => ProcessorArchitecture.ARMV6,
+                NativeMethodsShared.ProcessorArchitectures.PPC64LE => ProcessorArchitecture.PPC64LE,
                 // unknown architecture? return null
                 _ => null,
             };
@@ -37,6 +42,11 @@ public void ValidateProcessorArchitectureStrings()
             ProcessorArchitecture.MSIL.ShouldBe("MSIL"); // "MSIL ProcessorArchitecture isn't correct"
             ProcessorArchitecture.ARM.ShouldBe("ARM"); // "ARM ProcessorArchitecture isn't correct"
             ProcessorArchitecture.ARM64.ShouldBe("ARM64"); // "ARM ProcessorArchitecture isn't correct"
+            ProcessorArchitecture.WASM.ShouldBe("WASM"); // "WASM ProcessorArchitecture isn't correct"
+            ProcessorArchitecture.S390X.ShouldBe("S390X"); // "S390X ProcessorArchitecture isn't correct"
+            ProcessorArchitecture.LOONGARCH64.ShouldBe("LOONGARCH64"); // "LOONGARCH64 ProcessorArchitecture isn't correct"
+            ProcessorArchitecture.ARMV6.ShouldBe("ARMV6"); // "ARMV6 ProcessorArchitecture isn't correct"
+            ProcessorArchitecture.PPC64LE.ShouldBe("PPC64LE"); // "PPC64LE ProcessorArchitecture isn't correct"
         }
 
         [Fact]
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index f774fdfc69e..2c81395c138 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #pragma warning disable 0219
 
@@ -227,14 +228,9 @@ public void NonexistentRequestDirectory()
             from.GetMetadata(FileUtilities.ItemSpecModifiers.Directory).ShouldBe(NativeMethodsShared.IsWindows ? @"subdir\" : "subdir/");
         }
 
-        [Fact]
+        [WindowsOnlyFact("UNC is not implemented except under Windows.")]
         public void NonexistentRequestDirectoryUNC()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "UNC is not implemented except under Windows"
-            }
-
             TaskItem from = new TaskItem();
             from.ItemSpec = @"\\local\share\subdir\Monkey.txt";
             from.GetMetadata(FileUtilities.ItemSpecModifiers.Directory).ShouldBe(@"subdir\");
@@ -333,8 +329,6 @@ public void SetNullMetadataValue()
         /// Test that task items can be successfully constructed based on a task item from another appdomain.  
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void RemoteTaskItem()
         {
             AppDomain appDomain = null;
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index 8c961c597f1..f4e18fa61b7 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -23,6 +23,7 @@
 using SharedDotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -68,8 +69,7 @@ public void GetApiContractReferencesHandlesNonExistingLocation()
             returnValue.Length.ShouldBe(0);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetApiContractReferencesFindsWinMDs()
         {
             string tempDirectory = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
@@ -93,8 +93,7 @@ public void GetApiContractReferencesFindsWinMDs()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetApiContractReferencesFindsVersionedWinMDs()
         {
             string tempDirectory = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
@@ -117,8 +116,7 @@ public void GetApiContractReferencesFindsVersionedWinMDs()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetWinBlueSDKLocation()
         {
             string sdkRootPath = ToolLocationHelper.GetPlatformSDKLocation("Windows", "8.1");
@@ -127,8 +125,7 @@ public void GetWinBlueSDKLocation()
             returnValue.ShouldBe(sdkRootPath);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetWinBlueContentFolderPath()
         {
             string sdkRootPath = ToolLocationHelper.GetPlatformSDKLocation("Windows", "8.1");
@@ -137,8 +134,7 @@ public void GetWinBlueContentFolderPath()
             returnValue.ShouldBe(Path.Combine(sdkRootPath, @"DesignTime\CommonConfiguration\Neutral"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetSDKRootLocation()
         {
             string expectedValue = ToolLocationHelper.GetPlatformSDKLocation("Windows", "10.0");
@@ -151,11 +147,10 @@ public void GetSDKRootLocation()
         }
 
 #if RUNTIME_TYPE_NETCORE
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1250")]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/1250")]
 #else
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/2569")]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/2569")]
 #endif
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void GetUnversionedSDKUnionMetadataLocation()
         {
             string sdkRootPath = ToolLocationHelper.GetPlatformSDKLocation("Windows", "10.0");
@@ -165,8 +160,7 @@ public void GetUnversionedSDKUnionMetadataLocation()
             returnValue.ShouldBe(Path.Combine(sdkRootPath, "UnionMetadata"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetVersionedSDKUnionMetadataLocation()
         {
             // Create manifest file
@@ -533,8 +527,7 @@ public void FindFrameworksPathRunningThisTest()
          *
          * Search for a whidbey when whidbey is the current version.
          */
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void FindFrameworksPathRunningUnderWhidbey()
         {
             string path = FrameworkLocationHelper.FindDotNetFrameworkPath(
@@ -551,8 +544,7 @@ public void FindFrameworksPathRunningUnderWhidbey()
         *
         * Search for a whidbey when orcas is the current version.
         */
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void FindFrameworksPathRunningUnderOrcas()
         {
             string path = FrameworkLocationHelper.FindDotNetFrameworkPath(
@@ -569,8 +561,7 @@ public void FindFrameworksPathRunningUnderOrcas()
         *
         * Search for a whidbey when orcas is the current version.
         */
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void FindFrameworksPathRunningUnderEverett()
         {
             string path = FrameworkLocationHelper.FindDotNetFrameworkPath(
@@ -626,7 +617,6 @@ public void FindPathForEverettThatIsntProperlyInstalled()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void ExerciseMiscToolLocationHelperMethods()
@@ -687,7 +677,6 @@ public void ExerciseMiscToolLocationHelperMethods()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestGetPathToBuildToolsFile()
         {
             string net20Path = ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version20);
@@ -710,7 +699,6 @@ public void TestGetPathToBuildToolsFile()
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/722")]
 #else
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
 #endif
         public void TestGetPathToBuildToolsFile_32Bit()
         {
@@ -907,11 +895,10 @@ public void TestGetDotNetFrameworkSdkInstallKeyValue()
         }
 
 #if FEATURE_REGISTRY_SDKS
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/995")]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/995")]
 #else
-        [Fact(Skip = "Registry SDKs not supported")]
+        [WindowsOnlyFact(Skip = "Registry SDKs not supported")]
 #endif
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void GetPathToDotNetFrameworkSdk()
         {
             // Test out of range .net version.
@@ -990,8 +977,7 @@ public void GetPathToDotNetFrameworkSdk()
 
 #pragma warning disable 618 //The test below tests a deprecated API. We disable the warning for obsolete methods for this particular test
 #if FEATURE_WIN32_REGISTRY
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetPathToWindowsSdk()
         {
             // Test out of range .net version.
@@ -1134,7 +1120,6 @@ public void VerifyToolsetAndToolLocationHelperAgree()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIsEmpty()
         {
             string projectContents = @"
@@ -1176,7 +1161,6 @@ public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIsEmpt
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIs10()
         {
             string projectContents = @"
@@ -1219,8 +1203,7 @@ public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIs10()
             success.ShouldBeTrue(); // "Build Failed.  See Std Out for details."
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIs11()
         {
             string projectContents = @"
@@ -1358,9 +1341,7 @@ public void GenerateReferencAssemblyInvalidIdentifier()
         /// Make sure if the moniker and the root make a too long path that an InvalidOperationException is raised
         /// which indicates there was a problem generating the reference assembly path.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void GenerateReferencAssemblyPathTooLong()
         {
             Should.Throw<InvalidOperationException>(() =>
@@ -1388,7 +1369,6 @@ public void GenerateReferencAssemblyPathTooLong()
         /// do not have anything to chain with.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ChainReferenceAssembliesRedistExistsNoRedistList()
         {
             string path = ToolLocationHelper.ChainReferenceAssemblyPath(@"PathDoesNotExistSoICannotChain");
@@ -1632,9 +1612,7 @@ public void ChainReferenceAssembliesRedistInvalidPathChars()
         /// <summary>
         /// Make sure we get the correct exception when the xml file points to an included framework which has invalid path chars.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void ChainReferenceAssembliesRedistPathTooLong()
         {
             Should.Throw<InvalidOperationException>(() =>
@@ -1937,7 +1915,6 @@ public void GetPathToReferenceAssembliesDefaultLocationNullFrameworkName()
         /// place, which means it just looks for a folder starting with v4.0 in the right spot for any higher version.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetPathToReferenceAssembliesDefaultLocation48()
         {
             if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) != null)
@@ -1971,8 +1948,7 @@ public void GetPathToReferenceAssembliesDefaultLocation99()
         /// <summary>
         /// Make sure we choose the correct path for program files based on the operating system
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void TestGenerateProgramFiles32()
         {
             Environment.SpecialFolder folder = Environment.Is64BitOperatingSystem ? Environment.SpecialFolder.ProgramFilesX86 : Environment.SpecialFolder.ProgramFiles;
@@ -1987,8 +1963,7 @@ public void TestGenerateProgramFiles32()
         /// <summary>
         /// Verify we get the correct reference assembly path out of the framework location helper
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "No ProgramFiles known location outside Windows"
+        [WindowsOnlyFact(additionalMessage: "No ProgramFiles known location outside Windows.")]
         public void TestGeneratedReferenceAssemblyPath()
         {
             string programFiles32 = FrameworkLocationHelper.GenerateProgramFiles32();
@@ -2209,7 +2184,6 @@ public void GetPathToStandardLibraries64Bit35()
         /// We expect to always get the same path which is returned by GetPathToReferenceAssemblies.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetPathToStandardLibraries64Bit40()
         {
             IList<string> referencePaths = ToolLocationHelper.GetPathToReferenceAssemblies(new FrameworkNameVersioning(".NETFramework", new Version("4.0")));
@@ -2476,8 +2450,7 @@ public void GetAssemblyFoldersExInfoTestNullTargetRuntimeVersion()
         /// <summary>
         /// Verify we can get a list of directories out of the public API.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetAssemblyFoldersExInfoTest()
         {
             SetupAssemblyFoldersExTestConditionRegistryKey();
@@ -3113,9 +3086,7 @@ public void TestGetExtensionSDKLocation()
         /// Verify we do not get any resolved paths when we pass in a root which is too long
         ///
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void ResolveFromDirectoryPathTooLong()
         {
             Should.Throw<PathTooLongException>(() =>
@@ -3135,9 +3106,7 @@ public void ResolveFromDirectoryPathTooLong()
         /// <summary>
         /// Verify we get no resolved paths when we pass in a root with invalid chars
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // No invalid characters on Unix
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. No invalid characters on Unix.")]
         public void ResolveFromDirectoryInvalidChar()
         {
             var targetPlatform = new Dictionary<TargetPlatformSDK, TargetPlatformSDK>();
@@ -3175,8 +3144,7 @@ public void VerifySDKManifestWithNullOrEmptyParameter()
         /// Verify SDKManifest defaults values for MaxPlatformVersion, MinOSVersion, MaxOSVersion when these are not
         /// present in the manifest and the SDK is a framework extension SDK
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyFrameworkSdkWithOldManifest()
         {
             string tmpRootDirectory = Path.GetTempPath();
@@ -3732,7 +3700,6 @@ public void VerifyGetInstalledSDKLocations2()
         /// Setup some fake entries in the registry and verify we get the correct sdk from there.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyGetInstalledSDKLocations3()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "VerifyGetInstalledSDKLocations3");
@@ -3835,7 +3802,6 @@ public void VerifyGetInstalledSDKLocations3()
         /// get the expected set out.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ResolveSDKFromDirectory()
         {
             var paths = new List<string> { _fakeStructureRoot, _fakeStructureRoot2 };
@@ -3907,14 +3873,9 @@ public void ResolveSDKFromDirectory()
         /// Verify based on a fake directory structure with some good directories and some invalid ones at each level that we
         /// get the expected set out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("No registry unless under Windows.")]
         public void ResolveSDKFromRegistry()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "No registry unless under Windows"
-            }
-
             var targetPlatforms = new Dictionary<TargetPlatformSDK, TargetPlatformSDK>();
 
             ToolLocationHelper.GatherSDKsFromRegistryImpl(targetPlatforms, "Software\\Microsoft\\MicrosoftSDks", RegistryView.Registry32, RegistryHive.CurrentUser, getRegistrySubKeyNames, getRegistrySubKeyDefaultValue, _openBaseKey, File.Exists);
@@ -3962,7 +3923,6 @@ public void ResolveSDKFromRegistry()
         /// and make sure we get the expected results.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ResolveSDKFromRegistryAndDisk()
         {
             var targetPlatforms = new Dictionary<TargetPlatformSDK, TargetPlatformSDK>();
@@ -4147,15 +4107,13 @@ public void GetALLTargetPlatformSDKs()
         /// <summary>
         /// Verify that the list of platforms is empty if we ask for an sdk that is not installed.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void VerifyGetFoldersInVSInstalls_Unix()
         {
             ToolLocationHelper.GetFoldersInVSInstalls(null, null, "relativePath").Count().ShouldBe(0);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyFindRootFolderWhereAllFilesExist()
         {
             // create directories and files in them
@@ -4195,7 +4153,6 @@ public void VerifyFindRootFolderWhereAllFilesExist()
         /// Verify that the GetPlatformSDKPropsFileLocation method can be correctly called for pre-OneCore SDKs during evaluation time as a msbuild function.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyGetPreOneCoreSDKPropsLocation()
         {
             // This is the mockup layout for SDKs before One Core SDK.
@@ -4271,7 +4228,6 @@ public void VerifyGetPreOneCoreSDKPropsLocation()
         /// Verify that the GetPlatformSDKPropsFileLocation method can be correctly called for OneCore SDK during evaluation time as a msbuild function.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyGetOneCoreSDKPropsLocation()
         {
             // This is the mockup layout for One Core SDK.
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index b36c5d2ba11..c8f9fe6e4a0 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -203,7 +203,6 @@ public void HandleExecutionErrorsWhenToolDoesntLogError()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void HandleExecutionErrorsWhenToolLogsError()
         {
             using (MyTool t = new MyTool())
@@ -340,7 +339,6 @@ public void ToolExeWinsOverToolName()
         /// of the regular tool name
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ToolExeIsFoundOnToolPath()
         {
             string shellName = NativeMethodsShared.IsWindows ? "cmd.exe" : "sh";
@@ -390,7 +388,6 @@ public void TaskNotFoundOnPath()
         /// Task is found on path.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TaskFoundOnPath()
         {
             using (MyTool t = new MyTool())
@@ -510,7 +507,6 @@ public void ToolTaskCanChangeCanonicalErrorFormat()
         /// Passing env vars through the tooltask public property
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EnvironmentVariablesToToolTask()
         {
             MyTool task = new MyTool();
@@ -542,7 +538,6 @@ public void EnvironmentVariablesToToolTask()
         /// Equals sign in value
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EnvironmentVariablesToToolTaskEqualsSign()
         {
             MyTool task = new MyTool();
@@ -603,7 +598,6 @@ public void EnvironmentVariablesToToolTaskInvalid3()
         /// Not set should not wipe out other env vars
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EnvironmentVariablesToToolTaskNotSet()
         {
             MyTool task = new MyTool();
diff --git a/src/Utilities/ProcessorArchitecture.cs b/src/Utilities/ProcessorArchitecture.cs
index 962ef126ff0..88946934b37 100644
--- a/src/Utilities/ProcessorArchitecture.cs
+++ b/src/Utilities/ProcessorArchitecture.cs
@@ -45,6 +45,31 @@ public static class ProcessorArchitecture
         [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ARM64", Justification = "This is the correct casing for ProcessorArchitecture")]
         public const string ARM64 = nameof(ARM64);
 
+        /// <summary>
+        /// Represents the WebAssembly platform.
+        /// </summary>
+        public const string WASM = nameof(WASM);
+
+        /// <summary>
+        /// Represents the S390x processor architecture.
+        /// </summary>
+        public const string S390X = nameof(S390X);
+
+        /// <summary>
+        /// Represents the LoongAarch64 processor architecture.
+        /// </summary>
+        public const string LOONGARCH64 = nameof(LOONGARCH64);
+
+        /// <summary>
+        /// Represents the 32-bit ARMv6 processor architecture.
+        /// </summary>
+        public const string ARMV6 = nameof(ARMV6);
+
+        /// <summary>
+        /// Represents the PowerPC 64-bit (little-endian) processor architecture.
+        /// </summary>
+        public const string PPC64LE = nameof(PPC64LE);
+
         /// <summary>
         /// Lazy-initted property for getting the architecture of the currently running process
         /// </summary>
@@ -63,6 +88,11 @@ private static string GetCurrentProcessArchitecture()
                 NativeMethodsShared.ProcessorArchitectures.IA64 => IA64,
                 NativeMethodsShared.ProcessorArchitectures.ARM => ARM,
                 NativeMethodsShared.ProcessorArchitectures.ARM64 => ARM64,
+                NativeMethodsShared.ProcessorArchitectures.WASM => WASM,
+                NativeMethodsShared.ProcessorArchitectures.S390X => S390X,
+                NativeMethodsShared.ProcessorArchitectures.LOONGARCH64 => LOONGARCH64,
+                NativeMethodsShared.ProcessorArchitectures.ARMV6 => ARMV6,
+                NativeMethodsShared.ProcessorArchitectures.PPC64LE => PPC64LE,
                 // unknown architecture? return null
                 _ => null,
             };
diff --git a/src/Xunit.NetCore.Extensions/CustomXunitAttributesUtilities.cs b/src/Xunit.NetCore.Extensions/CustomXunitAttributesUtilities.cs
new file mode 100644
index 00000000000..5be9624189f
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/CustomXunitAttributesUtilities.cs
@@ -0,0 +1,21 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Xunit.NetCore.Extensions
+{
+    public static class CustomXunitAttributesUtilities
+    {
+#if NETFRAMEWORK
+        public static bool IsBuiltAgainstDotNet => false;
+
+        public static bool IsBuiltAgainstNetFramework => true;
+#elif NET
+        public static bool IsBuiltAgainstDotNet => true;
+
+        public static bool IsBuiltAgainstNetFramework => false;
+#endif
+
+        public static string AppendAdditionalMessage(this string message, string? additionalMessage)
+            => !string.IsNullOrWhiteSpace(additionalMessage) ? $"{message} {additionalMessage}" : message;
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs
new file mode 100644
index 00000000000..b1b0fb8baa4
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs
@@ -0,0 +1,23 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    ///  This test should be run only on .NET (or .NET Core).
+    /// </summary>
+    public class DotNetOnlyFactAttribute : FactAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="DotNetOnlyFactAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public DotNetOnlyFactAttribute(string? additionalMessage = null)
+        {
+            if (!CustomXunitAttributesUtilities.IsBuiltAgainstDotNet)
+            {
+                this.Skip = "This test only runs on .NET.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs
new file mode 100644
index 00000000000..b6ee768534b
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs
@@ -0,0 +1,23 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    ///  This test should be run only on .NET (or .NET Core).
+    /// </summary>
+    public class DotNetOnlyTheoryAttribute : TheoryAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="DotNetOnlyTheoryAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public DotNetOnlyTheoryAttribute(string? additionalMessage = null)
+        {
+            if (!CustomXunitAttributesUtilities.IsBuiltAgainstDotNet)
+            {
+                this.Skip = "This test only runs on .NET.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs
new file mode 100644
index 00000000000..f3878ef0de3
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Unix (Linux, OSX platforms).
+    /// </summary>
+    public class UnixOnlyFactAttribute : FactAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="UnixOnlyFactAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public UnixOnlyFactAttribute(string? additionalMessage = null)
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Unix to run.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs
new file mode 100644
index 00000000000..f0a1769882e
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Unix (Linux, OSX platforms).
+    /// </summary>
+    public class UnixOnlyTheoryAttribute : TheoryAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="UnixOnlyTheoryAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public UnixOnlyTheoryAttribute(string? additionalMessage = null)
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Unix to run.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs
new file mode 100644
index 00000000000..4caa40a3198
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs
@@ -0,0 +1,30 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    ///  This test should be run only on Windows on full .NET Framework.
+    /// </summary>
+    public class WindowsFullFrameworkOnlyFactAttribute : FactAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="WindowsFullFrameworkOnlyFactAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public WindowsFullFrameworkOnlyFactAttribute(string? additionalMessage = null)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test only runs on Windows on full framework.".AppendAdditionalMessage(additionalMessage);
+                return;
+            }
+            if (!CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
+            {
+                this.Skip = "This test only runs on full framework.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs
new file mode 100644
index 00000000000..952bf0d7250
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs
@@ -0,0 +1,31 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    ///  This test should be run only on Windows on full .NET Framework.
+    /// </summary>
+    public class WindowsFullFrameworkOnlyTheoryAttribute : TheoryAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="WindowsFullFrameworkOnlyTheoryAttribute"/> class.
+        /// Creates the attribute.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public WindowsFullFrameworkOnlyTheoryAttribute(string? additionalMessage = null)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test only runs on Windows on full framework.".AppendAdditionalMessage(additionalMessage);
+                return;
+            }
+            if (!CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
+            {
+                this.Skip = "This test only runs on full framework.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs
new file mode 100644
index 00000000000..72f2378ad02
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Windows.
+    /// </summary>
+    public class WindowsOnlyFactAttribute : FactAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="WindowsOnlyFactAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public WindowsOnlyFactAttribute(string? additionalMessage = null)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Windows to run.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs
new file mode 100644
index 00000000000..dfc2be0b220
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Windows.
+    /// </summary>
+    public class WindowsOnlyTheoryAttribute : TheoryAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="WindowsOnlyTheoryAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public WindowsOnlyTheoryAttribute(string? additionalMessage = null)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Windows to run.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
