diff --git a/src/UnitTests.Shared/AssemblyInfo.cs b/src/UnitTests.Shared/AssemblyInfo.cs
index 6e9c159a486..3b5d7bbb185 100644
--- a/src/UnitTests.Shared/AssemblyInfo.cs
+++ b/src/UnitTests.Shared/AssemblyInfo.cs
@@ -2,10 +2,3 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
-
-using System.Runtime.CompilerServices;
-[assembly: InternalsVisibleTo("Microsoft.Build.Engine.OM.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Utilities.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("Microsoft.Build.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/UnitTests.Shared/BuildEventArgsExtension.cs b/src/UnitTests.Shared/BuildEventArgsExtension.cs
index 4ccf2f47b5c..ad52cea6b50 100644
--- a/src/UnitTests.Shared/BuildEventArgsExtension.cs
+++ b/src/UnitTests.Shared/BuildEventArgsExtension.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.UnitTests
     /// <summary>
     /// A class containing an extension to BuildEventArgs
     /// </summary>
-    internal static class BuildEventArgsExtension
+    public static class BuildEventArgsExtension
     {
         /// <summary>
         /// Extension method to help our tests without adding shipping code.
diff --git a/src/UnitTests.Shared/DummyMappedDriveUtils.cs b/src/UnitTests.Shared/DummyMappedDriveUtils.cs
index c2c28c8f0e5..90f596858d3 100644
--- a/src/UnitTests.Shared/DummyMappedDriveUtils.cs
+++ b/src/UnitTests.Shared/DummyMappedDriveUtils.cs
@@ -8,7 +8,7 @@
 
 namespace Microsoft.Build.UnitTests.Shared;
 
-internal static class DummyMappedDriveUtils
+public static class DummyMappedDriveUtils
 {
     public static string UpdatePathToMappedDrive(string path, char driveLetter)
     {
diff --git a/src/UnitTests.Shared/EngineTestEnvironment.cs b/src/UnitTests.Shared/EngineTestEnvironment.cs
index 87be4933bc4..12953a61178 100644
--- a/src/UnitTests.Shared/EngineTestEnvironment.cs
+++ b/src/UnitTests.Shared/EngineTestEnvironment.cs
@@ -30,7 +30,7 @@ public partial class TestEnvironment
 
         private sealed class ResetDefaultBuildManager
         {
-            internal static FieldInfo SingletonField;
+            public static FieldInfo SingletonField;
 
             public ResetDefaultBuildManager()
             {
@@ -132,13 +132,13 @@ public TransientTestProjectWithFiles(
             CreatedFiles = Helpers.CreateFilesInDirectory(TestRoot, files);
         }
 
-        internal MockLogger BuildProjectExpectFailure(IDictionary<string, string> globalProperties = null, string toolsVersion = null, bool validateLoggerRoundtrip = true)
+        public MockLogger BuildProjectExpectFailure(IDictionary<string, string> globalProperties = null, string toolsVersion = null, bool validateLoggerRoundtrip = true)
         {
             BuildProject(globalProperties, toolsVersion, out MockLogger logger, validateLoggerRoundtrip).ShouldBeFalse();
             return logger;
         }
 
-        internal MockLogger BuildProjectExpectSuccess(IDictionary<string, string> globalProperties = null, string toolsVersion = null, bool validateLoggerRoundtrip = true)
+        public MockLogger BuildProjectExpectSuccess(IDictionary<string, string> globalProperties = null, string toolsVersion = null, bool validateLoggerRoundtrip = true)
         {
             BuildProject(globalProperties, toolsVersion, out MockLogger logger, validateLoggerRoundtrip).ShouldBeTrue();
             return logger;
diff --git a/src/UnitTests.Shared/MockEngine.cs b/src/UnitTests.Shared/MockEngine.cs
index a0dfb0c644e..2e3894d4562 100644
--- a/src/UnitTests.Shared/MockEngine.cs
+++ b/src/UnitTests.Shared/MockEngine.cs
@@ -32,7 +32,7 @@ namespace Microsoft.Build.UnitTests
      * is somewhat of a no-no for task assemblies.
      *
      **************************************************************************/
-    internal sealed class MockEngine : IBuildEngine7
+    public sealed class MockEngine : IBuildEngine7
     {
         private readonly object _lockObj = new object();  // Protects _log, _output
         private readonly ITestOutputHelper _output;
@@ -43,15 +43,15 @@ internal sealed class MockEngine : IBuildEngine7
         private readonly ConcurrentQueue<BuildErrorEventArgs> _errorEvents = new ConcurrentQueue<BuildErrorEventArgs>();
         private readonly ConcurrentQueue<BuildWarningEventArgs> _warningEvents = new ConcurrentQueue<BuildWarningEventArgs>();
 
-        internal MockEngine() : this(false)
+        public MockEngine() : this(false)
         {
         }
 
-        internal int Messages { get; set; }
+        public int Messages { get; set; }
 
-        internal int Warnings { get; set; }
+        public int Warnings { get; set; }
 
-        internal int Errors { get; set; }
+        public int Errors { get; set; }
 
         public bool AllowFailureWithoutError { get; set; } = false;
 
@@ -60,7 +60,7 @@ internal MockEngine() : this(false)
 
         public Dictionary<string, string> GlobalProperties { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-        internal MockLogger MockLogger { get; }
+        public MockLogger MockLogger { get; }
 
         public MockEngine(bool logToConsole)
         {
@@ -192,7 +192,7 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
 
         public int ColumnNumberOfTaskNode => 0;
 
-        internal string Log
+        public string Log
         {
             get
             {
@@ -373,7 +373,7 @@ public void UnloadAllProjects()
         /// <summary>
         /// Assert that the mock log in the engine doesn't contain a certain message based on a resource string and some parameters
         /// </summary>
-        internal void AssertLogDoesntContainMessageFromResource(GetStringDelegate getString, string resourceName, params string[] parameters)
+        public void AssertLogDoesntContainMessageFromResource(GetStringDelegate getString, string resourceName, params string[] parameters)
         {
             string resource = getString(resourceName);
             string stringToSearchFor = String.Format(resource, parameters);
@@ -383,7 +383,7 @@ internal void AssertLogDoesntContainMessageFromResource(GetStringDelegate getStr
         /// <summary>
         /// Assert that the mock log in the engine contains a certain message based on a resource string and some parameters
         /// </summary>
-        internal void AssertLogContainsMessageFromResource(GetStringDelegate getString, string resourceName, params string[] parameters)
+        public void AssertLogContainsMessageFromResource(GetStringDelegate getString, string resourceName, params string[] parameters)
         {
             string resource = getString(resourceName);
             string stringToSearchFor = String.Format(resource, parameters);
@@ -396,7 +396,7 @@ internal void AssertLogContainsMessageFromResource(GetStringDelegate getString,
         /// First check if the string is in the log string. If not
         /// than make sure it is also check the MockLogger
         /// </summary>
-        internal void AssertLogContains(string contains)
+        public void AssertLogContains(string contains)
         {
             // If we do not contain this string than pass it to
             // MockLogger. Since MockLogger is also registered as
@@ -426,7 +426,7 @@ internal void AssertLogContains(string contains)
         /// First check if the string is in the log string. If not
         /// than make sure it is also not in the MockLogger
         /// </summary>
-        internal void AssertLogDoesntContain(string contains)
+        public void AssertLogDoesntContain(string contains)
         {
             string logText;
             lock (_lockObj)
diff --git a/src/UnitTests.Shared/MockLogger.cs b/src/UnitTests.Shared/MockLogger.cs
index 38ac661d845..dab6b5e32d0 100644
--- a/src/UnitTests.Shared/MockLogger.cs
+++ b/src/UnitTests.Shared/MockLogger.cs
@@ -40,7 +40,7 @@ public sealed class MockLogger : ILogger
         /// Should the build finished event be logged in the log file. This is to work around the fact we have different
         /// localized strings between env and xmake for the build finished event.
         /// </summary>
-        internal bool LogBuildFinished { get; set; } = true;
+        public bool LogBuildFinished { get; set; } = true;
 
         /*
          * Method:  ErrorCount
@@ -48,7 +48,7 @@ public sealed class MockLogger : ILogger
          * The count of all errors seen so far.
          *
          */
-        internal int ErrorCount { get; private set; }
+        public int ErrorCount { get; private set; }
 
         /*
          * Method:  WarningCount
@@ -56,94 +56,94 @@ public sealed class MockLogger : ILogger
          * The count of all warnings seen so far.
          *
          */
-        internal int WarningCount { get; private set; }
+        public int WarningCount { get; private set; }
 
         /// <summary>
         /// Return the list of logged errors
         /// </summary>
-        internal List<BuildErrorEventArgs> Errors { get; } = new List<BuildErrorEventArgs>();
+        public List<BuildErrorEventArgs> Errors { get; } = new List<BuildErrorEventArgs>();
 
         /// <summary>
         /// Returns the list of logged warnings
         /// </summary>
-        internal List<BuildWarningEventArgs> Warnings { get; } = new List<BuildWarningEventArgs>();
+        public List<BuildWarningEventArgs> Warnings { get; } = new List<BuildWarningEventArgs>();
 
         /// <summary>
         /// When set to true, allows task crashes to be logged without causing an assert.
         /// </summary>
-        internal bool AllowTaskCrashes { get; set; }
+        public bool AllowTaskCrashes { get; set; }
 
         /// <summary>
         /// List of ExternalProjectStarted events
         /// </summary>
-        internal List<ExternalProjectStartedEventArgs> ExternalProjectStartedEvents { get; } = new List<ExternalProjectStartedEventArgs>();
+        public List<ExternalProjectStartedEventArgs> ExternalProjectStartedEvents { get; } = new List<ExternalProjectStartedEventArgs>();
 
         /// <summary>
         /// List of ExternalProjectFinished events
         /// </summary>
-        internal List<ExternalProjectFinishedEventArgs> ExternalProjectFinishedEvents { get; } = new List<ExternalProjectFinishedEventArgs>();
+        public List<ExternalProjectFinishedEventArgs> ExternalProjectFinishedEvents { get; } = new List<ExternalProjectFinishedEventArgs>();
 
         /// <summary>
         /// List of ProjectStarted events
         /// </summary>
-        internal List<ProjectEvaluationStartedEventArgs> EvaluationStartedEvents { get; } = new List<ProjectEvaluationStartedEventArgs>();
+        public List<ProjectEvaluationStartedEventArgs> EvaluationStartedEvents { get; } = new List<ProjectEvaluationStartedEventArgs>();
 
         /// <summary>
         /// List of ProjectFinished events
         /// </summary>
-        internal List<ProjectEvaluationFinishedEventArgs> EvaluationFinishedEvents { get; } = new List<ProjectEvaluationFinishedEventArgs>();
+        public List<ProjectEvaluationFinishedEventArgs> EvaluationFinishedEvents { get; } = new List<ProjectEvaluationFinishedEventArgs>();
 
         /// <summary>
         /// List of ProjectStarted events
         /// </summary>
-        internal List<ProjectStartedEventArgs> ProjectStartedEvents { get; } = new List<ProjectStartedEventArgs>();
+        public List<ProjectStartedEventArgs> ProjectStartedEvents { get; } = new List<ProjectStartedEventArgs>();
 
         /// <summary>
         /// List of ProjectFinished events
         /// </summary>
-        internal List<ProjectFinishedEventArgs> ProjectFinishedEvents { get; } = new List<ProjectFinishedEventArgs>();
+        public List<ProjectFinishedEventArgs> ProjectFinishedEvents { get; } = new List<ProjectFinishedEventArgs>();
 
         /// <summary>
         /// List of TargetStarted events
         /// </summary>
-        internal List<TargetStartedEventArgs> TargetStartedEvents { get; } = new List<TargetStartedEventArgs>();
+        public List<TargetStartedEventArgs> TargetStartedEvents { get; } = new List<TargetStartedEventArgs>();
 
         /// <summary>
         /// List of TargetFinished events
         /// </summary>
-        internal List<TargetFinishedEventArgs> TargetFinishedEvents { get; } = new List<TargetFinishedEventArgs>();
+        public List<TargetFinishedEventArgs> TargetFinishedEvents { get; } = new List<TargetFinishedEventArgs>();
 
         /// <summary>
         /// List of TaskStarted events
         /// </summary>
-        internal List<TaskStartedEventArgs> TaskStartedEvents { get; } = new List<TaskStartedEventArgs>();
+        public List<TaskStartedEventArgs> TaskStartedEvents { get; } = new List<TaskStartedEventArgs>();
 
         /// <summary>
         /// List of TaskFinished events
         /// </summary>
-        internal List<TaskFinishedEventArgs> TaskFinishedEvents { get; } = new List<TaskFinishedEventArgs>();
+        public List<TaskFinishedEventArgs> TaskFinishedEvents { get; } = new List<TaskFinishedEventArgs>();
 
         /// <summary>
         /// List of BuildMessage events
         /// </summary>
-        internal List<BuildMessageEventArgs> BuildMessageEvents { get; } = new List<BuildMessageEventArgs>();
+        public List<BuildMessageEventArgs> BuildMessageEvents { get; } = new List<BuildMessageEventArgs>();
 
         /// <summary>
         /// List of BuildStarted events, thought we expect there to only be one, a valid check is to make sure this list is length 1
         /// </summary>
-        internal List<BuildStartedEventArgs> BuildStartedEvents { get; } = new List<BuildStartedEventArgs>();
+        public List<BuildStartedEventArgs> BuildStartedEvents { get; } = new List<BuildStartedEventArgs>();
 
         /// <summary>
         /// List of BuildFinished events, thought we expect there to only be one, a valid check is to make sure this list is length 1
         /// </summary>
-        internal List<BuildFinishedEventArgs> BuildFinishedEvents { get; } = new List<BuildFinishedEventArgs>();
+        public List<BuildFinishedEventArgs> BuildFinishedEvents { get; } = new List<BuildFinishedEventArgs>();
 
         /// <summary>
         /// List of Telemetry events
         /// </summary>
-        internal List<TelemetryEventArgs> TelemetryEvents { get; } = new();
+        public List<TelemetryEventArgs> TelemetryEvents { get; } = new();
 
-        internal List<BuildEventArgs> AllBuildEvents { get; } = new List<BuildEventArgs>();
+        public List<BuildEventArgs> AllBuildEvents { get; } = new List<BuildEventArgs>();
 
         /*
          * Method:  FullLog
@@ -151,7 +151,7 @@ public sealed class MockLogger : ILogger
          * The raw concatenation of all messages, errors and warnings seen so far.
          *
          */
-        internal string FullLog
+        public string FullLog
         {
             get
             {
@@ -253,7 +253,7 @@ public MockLogger(ITestOutputHelper testOutputHelper = null, bool profileEvaluat
          * Receives build events and logs them the way we like.
          *
          */
-        internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
+        public void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
         {
             lock (_lockObj)
             {
@@ -398,7 +398,7 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
             }
         }
 
-        internal void TelemetryEventHandler(object sender, BuildEventArgs eventArgs)
+        public void TelemetryEventHandler(object sender, BuildEventArgs eventArgs)
         {
             lock (_lockObj)
             {
@@ -442,14 +442,14 @@ private void PrintFullLog()
         /// Assert that the log file contains the given strings, in order.
         /// </summary>
         /// <param name="contains"></param>
-        internal void AssertLogContains(params string[] contains) => AssertLogContains(true, contains);
+        public void AssertLogContains(params string[] contains) => AssertLogContains(true, contains);
 
         /// <summary>
         /// Assert that the log file contains the given string, in order. Includes the option of case invariance
         /// </summary>
         /// <param name="isCaseSensitive">False if we do not care about case sensitivity</param>
         /// <param name="contains"></param>
-        internal void AssertLogContains(bool isCaseSensitive, params string[] contains)
+        public void AssertLogContains(bool isCaseSensitive, params string[] contains)
         {
             lock (_lockObj)
             {
@@ -508,7 +508,7 @@ internal void AssertLogContains(bool isCaseSensitive, params string[] contains)
         /// Assert that the log file does not contain the given string.
         /// </summary>
         /// <param name="contains"></param>
-        internal void AssertLogDoesntContain(string contains)
+        public void AssertLogDoesntContain(string contains)
         {
             lock (_lockObj)
             {
@@ -531,14 +531,14 @@ internal void AssertLogDoesntContain(string contains)
         /// <summary>
         /// Assert that no errors were logged
         /// </summary>
-        internal void AssertNoErrors() => Assert.Equal(0, ErrorCount);
+        public void AssertNoErrors() => Assert.Equal(0, ErrorCount);
 
         /// <summary>
         /// Assert that no warnings were logged
         /// </summary>
-        internal void AssertNoWarnings() => Assert.Equal(0, WarningCount);
+        public void AssertNoWarnings() => Assert.Equal(0, WarningCount);
 
-        internal void AssertMessageCount(string message, int expectedCount, bool regexSearch = true)
+        public void AssertMessageCount(string message, int expectedCount, bool regexSearch = true)
         {
             var matches = Regex.Matches(FullLog, regexSearch ? message : Regex.Escape(message));
             matches.Count.ShouldBe(expectedCount);
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index 5b6f8b43cec..d7d1dd4ce00 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -38,7 +38,7 @@ namespace Microsoft.Build.UnitTests
      * Utility methods for unit tests that work through the object model.
      *
      */
-    internal static class ObjectModelHelpers
+    public static class ObjectModelHelpers
     {
         private const string msbuildNamespace = "http://schemas.microsoft.com/developer/msbuild/2003";
         private static string s_msbuildDefaultToolsVersion = MSBuildConstants.CurrentToolsVersion;
@@ -48,7 +48,7 @@ internal static class ObjectModelHelpers
         /// <summary>
         /// Return the current Visual Studio version
         /// </summary>
-        internal static string CurrentVisualStudioVersion
+        public static string CurrentVisualStudioVersion
         {
             get
             {
@@ -59,7 +59,7 @@ internal static string CurrentVisualStudioVersion
         /// <summary>
         /// Return the default tools version
         /// </summary>
-        internal static string MSBuildDefaultToolsVersion
+        public static string MSBuildDefaultToolsVersion
         {
             get
             {
@@ -70,7 +70,7 @@ internal static string MSBuildDefaultToolsVersion
         /// <summary>
         /// Return the current assembly version
         /// </summary>
-        internal static string MSBuildAssemblyVersion
+        public static string MSBuildAssemblyVersion
         {
             get
             {
@@ -103,7 +103,7 @@ private static bool IsBuiltInItemMetadataName(string metadataName)
         /// Gets an item list from the project and assert that it contains
         /// exactly one item with the supplied name.
         /// </summary>
-        internal static ProjectItem AssertSingleItem(Project p, string type, string itemInclude)
+        public static ProjectItem AssertSingleItem(Project p, string type, string itemInclude)
         {
             ProjectItem[] items = p.GetItems(type).ToArray();
             int count = 0;
@@ -118,7 +118,7 @@ internal static ProjectItem AssertSingleItem(Project p, string type, string item
             return items[0];
         }
 
-        internal static void AssertItemEvaluationFromProject(string projectContents, string[] inputFiles, string[] expectedInclude, Dictionary<string, string>[] expectedMetadataPerItem = null, bool normalizeSlashes = false, bool makeExpectedIncludeAbsolute = false)
+        public static void AssertItemEvaluationFromProject(string projectContents, string[] inputFiles, string[] expectedInclude, Dictionary<string, string>[] expectedMetadataPerItem = null, bool normalizeSlashes = false, bool makeExpectedIncludeAbsolute = false)
         {
             AssertItemEvaluationFromGenericItemEvaluator((p, c) =>
                 {
@@ -135,7 +135,7 @@ internal static void AssertItemEvaluationFromProject(string projectContents, str
             normalizeSlashes);
         }
 
-        internal static void AssertItemEvaluationFromGenericItemEvaluator(Func<string, ProjectCollection, IList<ITestItem>> itemEvaluator, string projectContents, string[] inputFiles, string[] expectedInclude, bool makeExpectedIncludeAbsolute = false, Dictionary<string, string>[] expectedMetadataPerItem = null, bool normalizeSlashes = false)
+        public static void AssertItemEvaluationFromGenericItemEvaluator(Func<string, ProjectCollection, IList<ITestItem>> itemEvaluator, string projectContents, string[] inputFiles, string[] expectedInclude, bool makeExpectedIncludeAbsolute = false, Dictionary<string, string>[] expectedMetadataPerItem = null, bool normalizeSlashes = false)
         {
             using (var env = TestEnvironment.Create())
             using (var collection = new ProjectCollection())
@@ -159,21 +159,21 @@ internal static void AssertItemEvaluationFromGenericItemEvaluator(Func<string, P
             }
         }
 
-        internal static void ShouldHaveSucceeded(this BuildResult result)
+        public static void ShouldHaveSucceeded(this BuildResult result)
         {
             result.OverallResult.ShouldBe(
                 BuildResultCode.Success,
                 customMessage: result.Exception is not null ? result.Exception.ToString() : string.Empty);
         }
 
-        internal static void ShouldHaveSucceeded(this GraphBuildResult result)
+        public static void ShouldHaveSucceeded(this GraphBuildResult result)
         {
             result.OverallResult.ShouldBe(
                 BuildResultCode.Success,
                 customMessage: result.Exception is not null ? result.Exception.ToString() : string.Empty);
         }
 
-        internal static void ShouldHaveFailed(this BuildResult result, string exceptionMessageSubstring = null)
+        public static void ShouldHaveFailed(this BuildResult result, string exceptionMessageSubstring = null)
         {
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
 
@@ -183,7 +183,7 @@ internal static void ShouldHaveFailed(this BuildResult result, string exceptionM
             }
         }
 
-        internal static void ShouldHaveFailed(this GraphBuildResult result, string exceptionMessageSubstring = null)
+        public static void ShouldHaveFailed(this GraphBuildResult result, string exceptionMessageSubstring = null)
         {
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
 
@@ -193,20 +193,20 @@ internal static void ShouldHaveFailed(this GraphBuildResult result, string excep
             }
         }
 
-        internal static string NormalizeSlashes(string path)
+        public static string NormalizeSlashes(string path)
         {
             return path.Replace('/', Path.DirectorySeparatorChar).Replace('\\', Path.DirectorySeparatorChar);
         }
 
         // todo Make IItem<M> public and add these new members to it.
-        internal interface ITestItem
+        public interface ITestItem
         {
             string EvaluatedInclude { get; }
             int DirectMetadataCount { get; }
             string GetMetadataValue(string key);
         }
 
-        internal sealed class ProjectItemTestItemAdapter : ITestItem
+        public sealed class ProjectItemTestItemAdapter : ITestItem
         {
             private readonly ProjectItem _projectInstance;
 
@@ -225,7 +225,7 @@ public static implicit operator ProjectItemTestItemAdapter(ProjectItem pi)
             }
         }
 
-        internal sealed class ProjectItemInstanceTestItemAdapter : ITestItem
+        public sealed class ProjectItemInstanceTestItemAdapter : ITestItem
         {
             private readonly ProjectItemInstance _projectInstance;
 
@@ -244,7 +244,7 @@ public static implicit operator ProjectItemInstanceTestItemAdapter(ProjectItemIn
             }
         }
 
-        internal static void AssertItems(string[] expectedItems, ICollection<ProjectItem> items, Dictionary<string, string> expectedDirectMetadata = null, bool normalizeSlashes = false)
+        public static void AssertItems(string[] expectedItems, ICollection<ProjectItem> items, Dictionary<string, string> expectedDirectMetadata = null, bool normalizeSlashes = false)
         {
             var converteditems = items.Select(i => (ITestItem)new ProjectItemTestItemAdapter(i)).ToList();
             AssertItems(expectedItems, converteditems, expectedDirectMetadata, normalizeSlashes);
@@ -253,7 +253,7 @@ internal static void AssertItems(string[] expectedItems, ICollection<ProjectItem
         /// <summary>
         /// Asserts that the list of items has the specified evaluated includes.
         /// </summary>
-        internal static void AssertItems(string[] expectedItems, IList<ITestItem> items, Dictionary<string, string> expectedDirectMetadata = null, bool normalizeSlashes = false)
+        public static void AssertItems(string[] expectedItems, IList<ITestItem> items, Dictionary<string, string> expectedDirectMetadata = null, bool normalizeSlashes = false)
         {
             if (expectedDirectMetadata == null)
             {
@@ -325,7 +325,7 @@ public static void AssertItems(string[] expectedItems, IList<ITestItem> items, D
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
-        internal static void AssertItemsMatch(string expectedItemsString, ITaskItem[] actualItems)
+        public static void AssertItemsMatch(string expectedItemsString, ITaskItem[] actualItems)
         {
             AssertItemsMatch(expectedItemsString, actualItems, true);
         }
@@ -348,7 +348,7 @@ internal static void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
         /// <param name="orderOfItemsShouldMatch"></param>
-        internal static void AssertItemsMatch(string expectedItemsString, ITaskItem[] actualItems, bool orderOfItemsShouldMatch)
+        public static void AssertItemsMatch(string expectedItemsString, ITaskItem[] actualItems, bool orderOfItemsShouldMatch)
         {
             List<ITaskItem> expectedItems = ParseExpectedItemsString(expectedItemsString);
 
@@ -454,18 +454,18 @@ internal static void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
             }
         }
 
-        internal static void AssertItemHasMetadata(Dictionary<string, string> expected, ProjectItem item)
+        public static void AssertItemHasMetadata(Dictionary<string, string> expected, ProjectItem item)
         {
             AssertItemHasMetadata(expected, new ProjectItemTestItemAdapter(item));
         }
 
-        internal static void AssertItemHasMetadata(string key, string value, ProjectItem item)
+        public static void AssertItemHasMetadata(string key, string value, ProjectItem item)
         {
             item.DirectMetadataCount.ShouldBe(1, customMessage: $"Expected 1 metadata, ({key}), got {item.DirectMetadataCount}");
             item.GetMetadataValue(key).ShouldBe(value);
         }
 
-        internal static void AssertItemHasMetadata(Dictionary<string, string> expected, ITestItem item)
+        public static void AssertItemHasMetadata(Dictionary<string, string> expected, ITestItem item)
         {
             expected ??= new Dictionary<string, string>();
 
@@ -480,7 +480,7 @@ internal static void AssertItemHasMetadata(Dictionary<string, string> expected,
         /// <summary>
         /// Used to compare the contents of two arrays.
         /// </summary>
-        internal static void AssertArrayContentsMatch(object[] expected, object[] actual)
+        public static void AssertArrayContentsMatch(object[] expected, object[] actual)
         {
             if (expected == null)
             {
@@ -560,7 +560,7 @@ private static List<ITaskItem> ParseExpectedItemsString(string expectedItemsStri
         /// Assert that a given file exists within the temp project directory.
         /// </summary>
         /// <param name="fileRelativePath"></param>
-        internal static void AssertFileExistsInTempProjectDirectory(string fileRelativePath)
+        public static void AssertFileExistsInTempProjectDirectory(string fileRelativePath)
         {
             AssertFileExistsInTempProjectDirectory(fileRelativePath, null);
         }
@@ -570,7 +570,7 @@ internal static void AssertFileExistsInTempProjectDirectory(string fileRelativeP
         /// </summary>
         /// <param name="fileRelativePath"></param>
         /// <param name="message">Can be null.</param>
-        internal static void AssertFileExistsInTempProjectDirectory(string fileRelativePath, string message)
+        public static void AssertFileExistsInTempProjectDirectory(string fileRelativePath, string message)
         {
             if (message == null)
             {
@@ -587,7 +587,7 @@ internal static void AssertFileExistsInTempProjectDirectory(string fileRelativeP
         /// </summary>
         /// <param name="projectFileContents"></param>
         /// <returns></returns>
-        internal static string CleanupFileContents(string projectFileContents)
+        public static string CleanupFileContents(string projectFileContents)
         {
             // Replace reverse-single-quotes with double-quotes.
             projectFileContents = projectFileContents.Replace("`", "\"");
@@ -609,7 +609,7 @@ public static string Cleanup(this string aString)
         /// Normalizes all the whitespace in an xml string so that two documents that
         /// differ only in whitespace can be easily compared to each other for sameness.
         /// </summary>
-        internal static string NormalizeXmlWhitespace(string xml)
+        public static string NormalizeXmlWhitespace(string xml)
         {
             XmlDocument xmldoc = new XmlDocument();
             xmldoc.LoadXml(xml);
@@ -639,7 +639,7 @@ internal static string NormalizeXmlWhitespace(string xml)
         /// </summary>
         /// <param name="xml"></param>
         /// <returns></returns>
-        internal static string CreateTempFileOnDisk(string fileContents, params object[] args)
+        public static string CreateTempFileOnDisk(string fileContents, params object[] args)
         {
             return CreateTempFileOnDiskNoFormat(string.Format(fileContents, args));
         }
@@ -649,7 +649,7 @@ internal static string CreateTempFileOnDisk(string fileContents, params object[]
         /// </summary>
         /// <param name="xml"></param>
         /// <returns></returns>
-        internal static string CreateTempFileOnDiskNoFormat(string fileContents)
+        public static string CreateTempFileOnDiskNoFormat(string fileContents)
         {
             string projectFilePath = FileUtilities.GetTemporaryFile();
 
@@ -658,7 +658,7 @@ internal static string CreateTempFileOnDiskNoFormat(string fileContents)
             return projectFilePath;
         }
 
-        internal static ProjectRootElement CreateInMemoryProjectRootElement(string projectContents, ProjectCollection collection = null, bool preserveFormatting = true)
+        public static ProjectRootElement CreateInMemoryProjectRootElement(string projectContents, ProjectCollection collection = null, bool preserveFormatting = true)
         {
             var cleanedProject = CleanupFileContents(projectContents);
 
@@ -673,7 +673,7 @@ internal static ProjectRootElement CreateInMemoryProjectRootElement(string proje
         /// </summary>
         /// <param name="xml">the project to be created in string format.</param>
         /// <returns>Returns created <see cref="Project"/>.</returns>
-        internal static Project CreateInMemoryProject(string xml)
+        public static Project CreateInMemoryProject(string xml)
         {
             return CreateInMemoryProject(xml, new ConsoleLogger());
         }
@@ -684,7 +684,7 @@ internal static Project CreateInMemoryProject(string xml)
         /// <param name="xml">the project to be created in string format.</param>
         /// <param name="loggers">The array of loggers to attach on project evaluation.</param>
         /// <returns>Returns created <see cref="Project"/>.</returns>
-        internal static Project CreateInMemoryProject(string xml, params ILogger[] loggers)
+        public static Project CreateInMemoryProject(string xml, params ILogger[] loggers)
         {
             return CreateInMemoryProject(new ProjectCollection(), xml, loggers);
         }
@@ -696,7 +696,7 @@ internal static Project CreateInMemoryProject(string xml, params ILogger[] logge
         /// <param name="xml">the project to be created in string format.</param>
         /// <param name="loggers">The array of loggers to attach on project evaluation. May be null.</param>
         /// <returns>Returns created <see cref="Project"/>.</returns>
-        internal static Project CreateInMemoryProject(ProjectCollection projectCollection, string xml, params ILogger[] loggers)
+        public static Project CreateInMemoryProject(ProjectCollection projectCollection, string xml, params ILogger[] loggers)
         {
             return CreateInMemoryProject(projectCollection, xml, null, loggers);
         }
@@ -709,7 +709,7 @@ internal static Project CreateInMemoryProject(ProjectCollection projectCollectio
         /// <param name="toolsVersion">The tools version to use on project creation. May be null.</param>
         /// <param name="loggers">The array of loggers to attach to project collection before evaluation. May be null.</param>
         /// <returns>Returns created <see cref="Project"/>.</returns>
-        internal static Project CreateInMemoryProject(
+        public static Project CreateInMemoryProject(
             ProjectCollection projectCollection,
             string xml,
             string toolsVersion /* may be null */,
@@ -745,7 +745,7 @@ internal static Project CreateInMemoryProject(
         /// <param name="testOutputHelper"><see cref="ITestOutputHelper"/> to log to.</param>
         /// <param name="loggerVerbosity">The required logging verbosity.</param>
         /// <returns>The <see cref="MockLogger"/> that was used during evaluation and build.</returns>
-        internal static MockLogger BuildProjectExpectSuccess(
+        public static MockLogger BuildProjectExpectSuccess(
             string projectContents,
             ITestOutputHelper testOutputHelper = null,
             LoggerVerbosity loggerVerbosity = LoggerVerbosity.Normal)
@@ -761,7 +761,7 @@ internal static MockLogger BuildProjectExpectSuccess(
         /// </summary>
         /// <param name="projectContents">The project file content in string format.</param>
         /// <param name="loggers">The array of loggers to use.</param>
-        internal static void BuildProjectExpectSuccess(
+        public static void BuildProjectExpectSuccess(
             string projectContents,
             params ILogger[] loggers)
         {
@@ -776,7 +776,7 @@ internal static void BuildProjectExpectSuccess(
         /// </summary>
         /// <param name="projectContents">The project file content in string format.</param>
         /// <returns>The <see cref="MockLogger"/> that was used during evaluation and build.</returns>
-        internal static MockLogger BuildProjectExpectFailure(string projectContents)
+        public static MockLogger BuildProjectExpectFailure(string projectContents)
         {
             MockLogger logger = new MockLogger();
             BuildProjectExpectFailure(projectContents, logger);
@@ -789,7 +789,7 @@ internal static MockLogger BuildProjectExpectFailure(string projectContents)
         /// </summary>
         /// <param name="projectContents">The project file content in string format.</param>
         /// <param name="loggers">The array of loggers to use.</param>
-        internal static void BuildProjectExpectFailure(
+        public static void BuildProjectExpectFailure(
             string projectContents,
             params ILogger[] loggers)
         {
@@ -804,7 +804,7 @@ internal static void BuildProjectExpectFailure(
         /// </summary>
         /// <param name="project"></param>
         /// <param name="newExpectedProjectContents"></param>
-        internal static void CompareProjectContents(
+        public static void CompareProjectContents(
             Project project,
             string newExpectedProjectContents)
         {
@@ -829,7 +829,7 @@ internal static void CompareProjectContents(
         /// <summary>
         /// Creates and returns a unique path under temp
         /// </summary>
-        internal static string TempProjectDir
+        public static string TempProjectDir
         {
             get
             {
@@ -847,7 +847,7 @@ internal static string TempProjectDir
         /// <summary>
         /// Deletes the directory %TEMP%\TempDirForMSBuildUnitTests, and all its contents.
         /// </summary>
-        internal static void DeleteTempProjectDirectory()
+        public static void DeleteTempProjectDirectory()
         {
             DeleteDirectory(TempProjectDir);
         }
@@ -855,7 +855,7 @@ internal static void DeleteTempProjectDirectory()
         /// <summary>
         /// Deletes the directory and all its contents.
         /// </summary>
-        internal static void DeleteDirectory(string dir)
+        public static void DeleteDirectory(string dir)
         {
             // Manually deleting all children, but intentionally leaving the
             // Temp project directory behind due to locking issues which were causing
@@ -894,7 +894,7 @@ internal static void DeleteDirectory(string dir)
         /// up the file contents (replacing single-back-quote with double-quote, etc.).
         /// Silently OVERWRITES existing file.
         /// </summary>
-        internal static string CreateFileInTempProjectDirectory(string fileRelativePath, string fileContents, Encoding encoding = null)
+        public static string CreateFileInTempProjectDirectory(string fileRelativePath, string fileContents, Encoding encoding = null)
         {
             Assert.False(string.IsNullOrEmpty(fileRelativePath));
             string fullFilePath = Path.Combine(TempProjectDir, fileRelativePath);
@@ -934,7 +934,7 @@ internal static string CreateFileInTempProjectDirectory(string fileRelativePath,
         /// </summary>
         /// <param name="projectFileRelativePath"></param>
         /// <returns></returns>
-        internal static void BuildTempProjectFileExpectSuccess(string projectFileRelativePath, MockLogger logger)
+        public static void BuildTempProjectFileExpectSuccess(string projectFileRelativePath, MockLogger logger)
         {
             BuildTempProjectFileWithTargetsExpectSuccess(projectFileRelativePath, null, null, logger);
         }
@@ -942,7 +942,7 @@ internal static void BuildTempProjectFileExpectSuccess(string projectFileRelativ
         /// <summary>
         /// Builds a project file from disk, and asserts if the build does not succeed.
         /// </summary>
-        internal static void BuildTempProjectFileWithTargetsExpectSuccess(string projectFileRelativePath, string[] targets, IDictionary<string, string> additionalProperties, MockLogger logger)
+        public static void BuildTempProjectFileWithTargetsExpectSuccess(string projectFileRelativePath, string[] targets, IDictionary<string, string> additionalProperties, MockLogger logger)
         {
             BuildTempProjectFileWithTargets(projectFileRelativePath, targets, additionalProperties, logger)
                 .ShouldBeTrue("Build failed.  See test output (Attachments in Azure Pipelines) for details");
@@ -951,7 +951,7 @@ internal static void BuildTempProjectFileWithTargetsExpectSuccess(string project
         /// <summary>
         /// Builds a project file from disk, and asserts if the build succeeds.
         /// </summary>
-        internal static void BuildTempProjectFileExpectFailure(string projectFileRelativePath, MockLogger logger)
+        public static void BuildTempProjectFileExpectFailure(string projectFileRelativePath, MockLogger logger)
         {
             BuildTempProjectFileWithTargets(projectFileRelativePath, null, null, logger)
                 .ShouldBeFalse("Build unexpectedly succeeded.  See test output (Attachments in Azure Pipelines) for details");
@@ -962,7 +962,7 @@ internal static void BuildTempProjectFileExpectFailure(string projectFileRelativ
         /// </summary>
         /// <param name="fileRelativePath"></param>
         /// <returns></returns>
-        internal static Project LoadProjectFileInTempProjectDirectory(string projectFileRelativePath)
+        public static Project LoadProjectFileInTempProjectDirectory(string projectFileRelativePath)
         {
             return LoadProjectFileInTempProjectDirectory(projectFileRelativePath, false /* don't touch project*/);
         }
@@ -972,7 +972,7 @@ internal static Project LoadProjectFileInTempProjectDirectory(string projectFile
         /// </summary>
         /// <param name="fileRelativePath"></param>
         /// <returns></returns>
-        internal static Project LoadProjectFileInTempProjectDirectory(string projectFileRelativePath, bool touchProject)
+        public static Project LoadProjectFileInTempProjectDirectory(string projectFileRelativePath, bool touchProject)
         {
             string projectFileFullPath = Path.Combine(TempProjectDir, projectFileRelativePath);
 
@@ -996,7 +996,7 @@ internal static Project LoadProjectFileInTempProjectDirectory(string projectFile
         /// <param name="additionalProperties">Can be null.</param>
         /// <param name="logger"></param>
         /// <returns></returns>
-        internal static bool BuildTempProjectFileWithTargets(
+        public static bool BuildTempProjectFileWithTargets(
             string projectFileRelativePath,
             string[] targets,
             IDictionary<string, string> globalProperties,
@@ -1036,7 +1036,7 @@ internal static bool BuildTempProjectFileWithTargets(
         /// Delete any files in the list that currently exist.
         /// </summary>
         /// <param name="files"></param>
-        internal static void DeleteTempFiles(string[] files)
+        public static void DeleteTempFiles(string[] files)
         {
             for (int i = 0; i < files.Length; i++)
             {
@@ -1050,7 +1050,7 @@ internal static void DeleteTempFiles(string[] files)
         /// <summary>
         /// Returns the requested number of temporary files.
         /// </summary>
-        internal static string[] GetTempFiles(int number)
+        public static string[] GetTempFiles(int number)
         {
             return GetTempFiles(number, DateTime.Now);
         }
@@ -1058,7 +1058,7 @@ internal static string[] GetTempFiles(int number)
         /// <summary>
         /// Returns the requested number of temporary files, with the requested write time.
         /// </summary>
-        internal static string[] GetTempFiles(int number, DateTime lastWriteTime)
+        public static string[] GetTempFiles(int number, DateTime lastWriteTime)
         {
             string[] files = new string[number];
 
@@ -1073,7 +1073,7 @@ internal static string[] GetTempFiles(int number, DateTime lastWriteTime)
         /// <summary>
         /// Get items of item type "i" with using the item xml fragment passed in
         /// </summary>
-        internal static IList<ProjectItem> GetItemsFromFragment(string fragment, bool allItems = false, bool ignoreCondition = false)
+        public static IList<ProjectItem> GetItemsFromFragment(string fragment, bool allItems = false, bool ignoreCondition = false)
         {
             string content = FormatProjectContentsWithItemGroupFragment(fragment);
 
@@ -1081,7 +1081,7 @@ internal static IList<ProjectItem> GetItemsFromFragment(string fragment, bool al
             return items;
         }
 
-        internal static string GetConcatenatedItemsOfType(this Project project, string itemType, string itemSeparator = ";")
+        public static string GetConcatenatedItemsOfType(this Project project, string itemType, string itemSeparator = ";")
         {
             return string.Join(itemSeparator, project.Items.Where(i => i.ItemType.Equals(itemType)).Select(i => i.EvaluatedInclude));
         }
@@ -1089,7 +1089,7 @@ internal static IList<ProjectItem> GetItemsFromFragment(string fragment, bool al
         /// <summary>
         /// Get the items of type "i" in the project provided
         /// </summary>
-        internal static IList<ProjectItem> GetItems(string content, bool allItems = false, bool ignoreCondition = false)
+        public static IList<ProjectItem> GetItems(string content, bool allItems = false, bool ignoreCondition = false)
         {
             var projectXml = ProjectRootElement.Create(XmlReader.Create(new StringReader(CleanupFileContents(content))));
             Project project = new Project(projectXml);
@@ -1101,7 +1101,7 @@ internal static IList<ProjectItem> GetItems(string content, bool allItems = fals
             return item;
         }
 
-        internal static string FormatProjectContentsWithItemGroupFragment(string fragment)
+        public static string FormatProjectContentsWithItemGroupFragment(string fragment)
         {
             return
                 $@"
@@ -1117,16 +1117,16 @@ internal static string FormatProjectContentsWithItemGroupFragment(string fragmen
     /// <summary>
     /// Various generic unit test helper methods
     /// </summary>
-    internal static partial class Helpers
+    public static partial class Helpers
     {
-        internal static string Format(this string s, params object[] formatItems)
+        public static string Format(this string s, params object[] formatItems)
         {
             ErrorUtilities.VerifyThrowArgumentNull(s, nameof(s));
 
             return string.Format(s, formatItems);
         }
 
-        internal static string GetOSPlatformAsString()
+        public static string GetOSPlatformAsString()
         {
             var currentPlatformString = string.Empty;
 
@@ -1153,7 +1153,7 @@ internal static string GetOSPlatformAsString()
         /// <summary>
         /// Returns the count of objects returned by an enumerator
         /// </summary>
-        internal static int Count(IEnumerable enumerable)
+        public static int Count(IEnumerable enumerable)
         {
             if (enumerable is ICollection c)
             {
@@ -1172,7 +1172,7 @@ internal static int Count(IEnumerable enumerable)
         /// <summary>
         /// Makes a temporary list out of an enumerable
         /// </summary>
-        internal static List<T> MakeList<T>(IEnumerable<T> enumerable)
+        public static List<T> MakeList<T>(IEnumerable<T> enumerable)
         {
             List<T> list = new List<T>();
             foreach (T item in enumerable)
@@ -1185,7 +1185,7 @@ internal static List<T> MakeList<T>(IEnumerable<T> enumerable)
         /// <summary>
         /// Gets the first element in the enumeration, or null if there are none
         /// </summary>
-        internal static T GetFirst<T>(IEnumerable<T> enumerable)
+        public static T GetFirst<T>(IEnumerable<T> enumerable)
             where T : class
         {
             T first = null;
@@ -1202,7 +1202,7 @@ internal static T GetFirst<T>(IEnumerable<T> enumerable)
         /// <summary>
         /// Gets the last element in the enumeration, or null if there are none
         /// </summary>
-        internal static T GetLast<T>(IEnumerable<T> enumerable)
+        public static T GetLast<T>(IEnumerable<T> enumerable)
             where T : class
         {
             T last = null;
@@ -1218,7 +1218,7 @@ internal static T GetLast<T>(IEnumerable<T> enumerable)
         /// <summary>
         /// Makes a temporary dictionary out of an enumerable of keyvaluepairs.
         /// </summary>
-        internal static Dictionary<string, V> MakeDictionary<V>(IEnumerable<KeyValuePair<string, V>> enumerable)
+        public static Dictionary<string, V> MakeDictionary<V>(IEnumerable<KeyValuePair<string, V>> enumerable)
         {
             Dictionary<string, V> dictionary = new Dictionary<string, V>(StringComparer.OrdinalIgnoreCase);
             foreach (KeyValuePair<string, V> item in enumerable)
@@ -1231,7 +1231,7 @@ internal static Dictionary<string, V> MakeDictionary<V>(IEnumerable<KeyValuePair
         /// <summary>
         /// Verify that the two lists are value identical
         /// </summary>
-        internal static void AssertListsValueEqual<T>(IList<T> one, IList<T> two)
+        public static void AssertListsValueEqual<T>(IList<T> one, IList<T> two)
         {
             Assert.Equal(one.Count, two.Count);
 
@@ -1244,7 +1244,7 @@ internal static void AssertListsValueEqual<T>(IList<T> one, IList<T> two)
         /// <summary>
         /// Verify that the two collections are value identical
         /// </summary>
-        internal static void AssertCollectionsValueEqual<T>(ICollection<T> one, ICollection<T> two)
+        public static void AssertCollectionsValueEqual<T>(ICollection<T> one, ICollection<T> two)
         {
             Assert.Equal(one.Count, two.Count);
 
@@ -1259,7 +1259,7 @@ internal static void AssertCollectionsValueEqual<T>(ICollection<T> one, ICollect
             }
         }
 
-        internal static void AssertDictionariesEqual<K, V>(IDictionary<K, V> x, IDictionary<K, V> y, Action<KeyValuePair<K, V>, KeyValuePair<K, V>> assertPairsEqual)
+        public static void AssertDictionariesEqual<K, V>(IDictionary<K, V> x, IDictionary<K, V> y, Action<KeyValuePair<K, V>, KeyValuePair<K, V>> assertPairsEqual)
         {
             if (x == null || y == null)
             {
@@ -1278,7 +1278,7 @@ internal static void AssertDictionariesEqual<K, V>(IDictionary<K, V> x, IDiction
             }
         }
 
-        internal static void AssertDictionariesEqual(IDictionary<string, string> x, IDictionary<string, string> y)
+        public static void AssertDictionariesEqual(IDictionary<string, string> x, IDictionary<string, string> y)
         {
             AssertDictionariesEqual(x, y,
                 (xPair, yPair) =>
@@ -1288,21 +1288,21 @@ internal static void AssertDictionariesEqual(IDictionary<string, string> x, IDic
                 });
         }
 
-        internal static void ShouldBeSameIgnoringOrder<K, V>(this IDictionary<K, V> a, IReadOnlyDictionary<K, V> b)
+        public static void ShouldBeSameIgnoringOrder<K, V>(this IDictionary<K, V> a, IReadOnlyDictionary<K, V> b)
         {
             a.ShouldBeSubsetOf(b);
             b.ShouldBeSubsetOf(a);
             a.Count.ShouldBe(b.Count);
         }
 
-        internal static void ShouldBeSameIgnoringOrder<K>(this IEnumerable<K> a, IEnumerable<K> b)
+        public static void ShouldBeSameIgnoringOrder<K>(this IEnumerable<K> a, IEnumerable<K> b)
         {
             a.ShouldBeSubsetOf(b);
             b.ShouldBeSubsetOf(a);
             a.Count().ShouldBe(b.Count());
         }
 
-        internal static void ShouldBeSetEquivalentTo<K>(this IEnumerable<K> a, IEnumerable<K> b)
+        public static void ShouldBeSetEquivalentTo<K>(this IEnumerable<K> a, IEnumerable<K> b)
         {
             a.ShouldBeSubsetOf(b);
             b.ShouldBeSubsetOf(a);
@@ -1311,7 +1311,7 @@ internal static void ShouldBeSetEquivalentTo<K>(this IEnumerable<K> a, IEnumerab
         /// <summary>
         /// Verify that the two enumerables are value identical
         /// </summary>
-        internal static void AssertEnumerationsValueEqual<T>(IEnumerable<T> one, IEnumerable<T> two)
+        public static void AssertEnumerationsValueEqual<T>(IEnumerable<T> one, IEnumerable<T> two)
         {
             List<T> listOne = new List<T>();
             List<T> listTwo = new List<T>();
@@ -1333,7 +1333,7 @@ internal static void AssertEnumerationsValueEqual<T>(IEnumerable<T> one, IEnumer
         /// Build a project with the provided content in memory.
         /// Assert that it succeeded, and return the mock logger with the output.
         /// </summary>
-        internal static MockLogger BuildProjectWithNewOMExpectSuccess(string content, Dictionary<string, string> globalProperties = null, MockLogger logger = null)
+        public static MockLogger BuildProjectWithNewOMExpectSuccess(string content, Dictionary<string, string> globalProperties = null, MockLogger logger = null)
         {
             BuildProjectWithNewOM(content, ref logger, out bool result, false, globalProperties);
             Assert.True(result);
@@ -1415,7 +1415,7 @@ public static BuildResult BuildProjectFileUsingBuildManager(
             }
         }
 
-        internal enum ExpectedBuildResult
+        public enum ExpectedBuildResult
         {
             // The build should fail with a logged error upon drive enumerationg wildcard detection and setting of environment variable.
             FailWithError,
@@ -1428,7 +1428,7 @@ internal enum ExpectedBuildResult
         /// <summary>
         /// Verify that a drive enumerating wildcard warning is logged or exception is thrown.
         /// </summary>
-        internal static void CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(string content, string failOnDriveEnumerationEnvVar, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
+        public static void CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(string content, string failOnDriveEnumerationEnvVar, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
         {
             using (var env = TestEnvironment.Create(testOutput))
             {
@@ -1444,14 +1444,14 @@ internal static void CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(str
             }
         }
 
-        internal static void ResetStateForDriveEnumeratingWildcardTests(TestEnvironment env, string setEnvVar)
+        public static void ResetStateForDriveEnumeratingWildcardTests(TestEnvironment env, string setEnvVar)
         {
             ChangeWaves.ResetStateForTests();
             env.SetEnvironmentVariable("MSBUILDFAILONDRIVEENUMERATINGWILDCARD", setEnvVar);
             BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
         }
 
-        internal static void BuildTargetWithDriveEnumeratingWildcardUsingBuildManager(TestEnvironment env, string testProjectFile, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
+        public static void BuildTargetWithDriveEnumeratingWildcardUsingBuildManager(TestEnvironment env, string testProjectFile, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
         {
             try
             {
@@ -1522,7 +1522,7 @@ private static void VerifySuccessOfBuildAndTargetResults(BuildResult buildResult
         /// Build a project with the provided content in memory.
         /// Assert that it fails, and return the mock logger with the output.
         /// </summary>
-        internal static MockLogger BuildProjectWithNewOMExpectFailure(string content, bool allowTaskCrash, MockLogger logger = null)
+        public static MockLogger BuildProjectWithNewOMExpectFailure(string content, bool allowTaskCrash, MockLogger logger = null)
         {
             bool result;
             BuildProjectWithNewOM(content, ref logger, out result, allowTaskCrash);
@@ -1536,7 +1536,7 @@ internal static MockLogger BuildProjectWithNewOMExpectFailure(string content, bo
         /// </summary>
         /// <param name="newExpectedProjectContents"></param>
         /// <param name="newActualProjectContents"></param>
-        internal static void CompareProjectXml(string newExpectedProjectContents, string newActualProjectContents)
+        public static void CompareProjectXml(string newExpectedProjectContents, string newActualProjectContents)
         {
             // Replace single-quotes with double-quotes, and normalize whitespace.
             newExpectedProjectContents =
@@ -1559,7 +1559,7 @@ internal static void CompareProjectXml(string newExpectedProjectContents, string
         /// <summary>
         /// Verify that the saved project content matches the provided content
         /// </summary>
-        internal static void VerifyAssertProjectContent(string expected, Project project)
+        public static void VerifyAssertProjectContent(string expected, Project project)
         {
             VerifyAssertProjectContent(expected, project.Xml);
         }
@@ -1567,7 +1567,7 @@ internal static void VerifyAssertProjectContent(string expected, Project project
         /// <summary>
         /// Verify that the saved project content matches the provided content
         /// </summary>
-        internal static void VerifyAssertProjectContent(string expected, ProjectRootElement project, bool ignoreFirstLineOfActual = true)
+        public static void VerifyAssertProjectContent(string expected, ProjectRootElement project, bool ignoreFirstLineOfActual = true)
         {
             VerifyAssertLineByLine(expected, project.RawXml, ignoreFirstLineOfActual);
         }
@@ -1575,7 +1575,7 @@ internal static void VerifyAssertProjectContent(string expected, ProjectRootElem
         /// <summary>
         /// Verify that the expected content matches the actual content
         /// </summary>
-        internal static void VerifyAssertLineByLine(string expected, string actual)
+        public static void VerifyAssertLineByLine(string expected, string actual)
         {
             VerifyAssertLineByLine(expected, actual, false /* do not ignore first line */);
         }
@@ -1584,7 +1584,7 @@ internal static void VerifyAssertLineByLine(string expected, string actual)
         /// Write the given <see cref="projectContents"/> in a new temp directory and create the given <see cref="files"/> relative to the project
         /// </summary>
         /// <returns>the path to the temp root directory that contains the project and files</returns>
-        internal static string CreateProjectInTempDirectoryWithFiles(string projectContents, string[] files, out string createdProjectFile, out string[] createdFiles, string relativePathFromRootToProject = ".")
+        public static string CreateProjectInTempDirectoryWithFiles(string projectContents, string[] files, out string createdProjectFile, out string[] createdFiles, string relativePathFromRootToProject = ".")
         {
             var root = GetTempDirectoryWithGuid();
             Directory.CreateDirectory(root);
@@ -1609,7 +1609,7 @@ private static string GetTempDirectoryWithGuid()
         /// Creates a bunch of temporary files with the specified names and returns
         /// their full paths (so they can ultimately be cleaned up)
         /// </summary>
-        internal static string[] CreateFiles(params string[] files)
+        public static string[] CreateFiles(params string[] files)
         {
             string directory = GetTempDirectoryWithGuid();
             Directory.CreateDirectory(directory);
@@ -1621,7 +1621,7 @@ internal static string[] CreateFiles(params string[] files)
         /// Creates a bunch of temporary files in the given directory with the specified names and returns
         /// their full paths (so they can ultimately be cleaned up)
         /// </summary>
-        internal static string[] CreateFilesInDirectory(string rootDirectory, params string[] files)
+        public static string[] CreateFilesInDirectory(string rootDirectory, params string[] files)
         {
             if (files == null)
             {
@@ -1656,7 +1656,7 @@ internal static string[] CreateFilesInDirectory(string rootDirectory, params str
             return result;
         }
 
-        internal delegate TransientTestFile CreateProjectFileDelegate(
+        public delegate TransientTestFile CreateProjectFileDelegate(
             TestEnvironment env,
             int projectNumber,
             int[] projectReferences = null,
@@ -1664,7 +1664,7 @@ internal delegate TransientTestFile CreateProjectFileDelegate(
             string defaultTargets = null,
             string extraContent = null);
 
-        internal static TransientTestFile CreateProjectFile(
+        public static TransientTestFile CreateProjectFile(
             TestEnvironment env,
             int projectNumber,
             int[] projectReferences = null,
@@ -1712,7 +1712,7 @@ internal static TransientTestFile CreateProjectFile(
             return env.CreateFile(projectNumber + ".proj", sb.ToString());
         }
 
-        internal static ProjectGraph CreateProjectGraph(
+        public static ProjectGraph CreateProjectGraph(
             TestEnvironment env,
             // direct dependencies that the kvp.key node has on the nodes represented by kvp.value
             IDictionary<int, int[]> dependencyEdges,
@@ -1823,7 +1823,7 @@ private static string[] SplitPathIntoFragments(string path)
         /// Deletes a bunch of files, including their containing directories
         /// if they become empty
         /// </summary>
-        internal static void DeleteFiles(params string[] paths)
+        public static void DeleteFiles(params string[] paths)
         {
             // When we delete the file directory which has the sub folder/file firstly, it will not be deleted since not empty.
             // So sort paths descendingly by file directory length, it will delete sub folder/file at first.
@@ -1848,7 +1848,7 @@ internal static void DeleteFiles(params string[] paths)
         /// Given two methods accepting no parameters and returning none, verifies they
         /// both throw, and throw the same exception type.
         /// </summary>
-        internal static void VerifyAssertThrowsSameWay(Action method1, Action method2)
+        public static void VerifyAssertThrowsSameWay(Action method1, Action method2)
         {
             Exception ex1 = null;
             Exception ex2 = null;
@@ -1886,7 +1886,7 @@ internal static void VerifyAssertThrowsSameWay(Action method1, Action method2)
         /// <summary>
         /// Verify method throws invalid operation exception.
         /// </summary>
-        internal static void VerifyAssertThrowsInvalidOperation(Action method)
+        public static void VerifyAssertThrowsInvalidOperation(Action method)
         {
             Assert.Throws<InvalidOperationException>(method);
         }
@@ -1894,7 +1894,7 @@ internal static void VerifyAssertThrowsInvalidOperation(Action method)
         /// <summary>
         /// Verify that the expected content matches the actual content
         /// </summary>
-        internal static void VerifyAssertLineByLine(string expected, string actual, bool ignoreFirstLineOfActual, ITestOutputHelper testOutput = null)
+        public static void VerifyAssertLineByLine(string expected, string actual, bool ignoreFirstLineOfActual, ITestOutputHelper testOutput = null)
         {
             Action<string> LogLine = testOutput == null ? (Action<string>)Console.WriteLine : testOutput.WriteLine;
 
@@ -1953,7 +1953,7 @@ internal static void VerifyAssertLineByLine(string expected, string actual, bool
         /// <summary>
         /// Clear the dirty flag of a ProjectRootElement by saving to a dummy writer.
         /// </summary>
-        internal static void ClearDirtyFlag(ProjectRootElement project)
+        public static void ClearDirtyFlag(ProjectRootElement project)
         {
             project.Save(new StringWriter());
             Assert.False(project.HasUnsavedChanges);
@@ -1963,7 +1963,7 @@ internal static void ClearDirtyFlag(ProjectRootElement project)
         /// Gets a command that can be used by an Exec task to sleep for the specified amount of time.
         /// </summary>
         /// <param name="timeSpan">A <see cref="TimeSpan"/> representing the amount of time to sleep.</param>
-        internal static string GetSleepCommand(TimeSpan timeSpan)
+        public static string GetSleepCommand(TimeSpan timeSpan)
         {
             return string.Format(
                 GetSleepCommandTemplate(),
@@ -1975,7 +1975,7 @@ internal static string GetSleepCommand(TimeSpan timeSpan)
         /// <summary>
         /// Gets a command template that can be used by an Exec task to sleep for the specified amount of time. The string has to be formatted with the number of seconds to sleep
         /// </summary>
-        internal static string GetSleepCommandTemplate()
+        public static string GetSleepCommandTemplate()
         {
             return
                 NativeMethodsShared.IsWindows
@@ -1997,12 +1997,12 @@ private static string[] SplitIntoLines(string content)
         /// Used for file matching tests
         /// MSBuild does not accept forward slashes on rooted paths, so those are returned unchanged
         /// </summary>
-        internal static string ToForwardSlash(string path) =>
+        public static string ToForwardSlash(string path) =>
             Path.IsPathRooted(path)
                 ? path
                 : path.ToSlash();
 
-        internal sealed class ElementLocationComparerIgnoringType : IEqualityComparer<ElementLocation>
+        public sealed class ElementLocationComparerIgnoringType : IEqualityComparer<ElementLocation>
         {
             public bool Equals(ElementLocation x, ElementLocation y)
             {
@@ -2030,7 +2030,7 @@ public int GetHashCode(ElementLocation obj)
             }
         }
 
-        internal sealed class BuildManagerSession : IDisposable
+        public sealed class BuildManagerSession : IDisposable
         {
             private readonly TestEnvironment _env;
             private readonly BuildManager _buildManager;
@@ -2118,7 +2118,7 @@ public void Dispose()
             }
         }
 
-        internal sealed class LoggingDirectoryCacheFactory : IDirectoryCacheFactory
+        public sealed class LoggingDirectoryCacheFactory : IDirectoryCacheFactory
         {
             public List<LoggingDirectoryCache> DirectoryCaches { get; } = new();
 
@@ -2130,9 +2130,9 @@ public IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId)
             }
         }
 
-        internal sealed class LoggingDirectoryCache : IDirectoryCache
+        public sealed class LoggingDirectoryCache : IDirectoryCache
         {
-            internal int EvaluationId { get; }
+            public int EvaluationId { get; }
 
             public ConcurrentDictionary<string, int> ExistenceChecks { get; } = new();
             public ConcurrentDictionary<string, int> Enumerations { get; } = new();
@@ -2177,7 +2177,7 @@ private void IncrementEnumerations(string path)
             }
         }
 
-        internal sealed class LoggingFileSystem : MSBuildFileSystemBase
+        public sealed class LoggingFileSystem : MSBuildFileSystemBase
         {
             private int _fileSystemCalls;
 
diff --git a/src/UnitTests.Shared/StreamHelpers.cs b/src/UnitTests.Shared/StreamHelpers.cs
index 10df70aac9b..e28bf080fd3 100644
--- a/src/UnitTests.Shared/StreamHelpers.cs
+++ b/src/UnitTests.Shared/StreamHelpers.cs
@@ -7,14 +7,14 @@
 
 namespace Microsoft.Build.UnitTests
 {
-    internal sealed class StreamHelpers
+    public sealed class StreamHelpers
     {
         /// <summary>
         /// Take a string and convert it to a StreamReader.
         /// </summary>
         /// <param name="value"></param>
         /// <returns></returns>
-        internal static StreamReader StringToStreamReader(string value)
+        public static StreamReader StringToStreamReader(string value)
         {
             MemoryStream m = new MemoryStream();
 #if FEATURE_ENCODING_DEFAULT
@@ -36,7 +36,7 @@ internal static StreamReader StringToStreamReader(string value)
          * Take a string and convert it into a Stream.
          * Use the default encoding which means this machine's ANSI codepage.
          */
-        internal static Stream StringToStream(string value)
+        public static Stream StringToStream(string value)
         {
 #if FEATURE_ENCODING_DEFAULT
             return StringToStream(value, System.Text.Encoding.Default); // We want this to be Default which is ANSI
@@ -51,7 +51,7 @@ internal static Stream StringToStream(string value)
          * Take a string and convert it into a Stream.
          * Takes an alternate encoding type
          */
-        internal static Stream StringToStream(string value, System.Text.Encoding encoding)
+        public static Stream StringToStream(string value, System.Text.Encoding encoding)
         {
             MemoryStream m = new MemoryStream();
             TextWriter w = new StreamWriter(m, encoding); // HIGHCHAR: StringToStream helper accepts encoding from caller.
