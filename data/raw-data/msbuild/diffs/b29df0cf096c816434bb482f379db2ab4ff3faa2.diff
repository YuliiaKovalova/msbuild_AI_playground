diff --git a/.config/1espt/PipelineAutobaseliningConfig.yml b/.config/1espt/PipelineAutobaseliningConfig.yml
index 1901db1b137..e2d487e929a 100644
--- a/.config/1espt/PipelineAutobaseliningConfig.yml
+++ b/.config/1espt/PipelineAutobaseliningConfig.yml
@@ -12,6 +12,8 @@ pipelines:
           lastModifiedDate: 2024-03-14
         armory:
           lastModifiedDate: 2024-03-14
+        policheck:
+          lastModifiedDate: 2024-10-09
       binary:
         credscan:
           lastModifiedDate: 2024-03-14
diff --git a/.config/tsaoptions.json b/.config/tsaoptions.json
new file mode 100644
index 00000000000..4069463a23e
--- /dev/null
+++ b/.config/tsaoptions.json
@@ -0,0 +1,10 @@
+{
+    "instanceUrl": "https://devdiv.visualstudio.com/",
+    "template": "TFSDEVDIV",
+    "projectName": "DEVDIV",
+    "areaPath": "DevDiv\\NET Tools\\MSBuild",
+    "iterationPath": "DevDiv",
+    "notificationAliases": [ "msbtm@microsoft.com" ],
+    "repositoryName": "MSBuild",
+    "codebaseName": "MSBuild"
+}
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE/01_bugreport.yml b/.github/ISSUE_TEMPLATE/01_bugreport.yml
index 35d55437a5a..d38fe76e2e6 100644
--- a/.github/ISSUE_TEMPLATE/01_bugreport.yml
+++ b/.github/ISSUE_TEMPLATE/01_bugreport.yml
@@ -1,7 +1,6 @@
 name: üêû Bug Report
 description: Report a bug to help us improve MSBuild.
-title: "[Bug]: "
-labels: ["bug"]
+type: 'Bug'
 body:
   - type: textarea
     attributes:
@@ -12,17 +11,17 @@ body:
   - type: textarea
     attributes:
       label: Steps to Reproduce
-      description:  | 
-        Include as much of the following as possible: 
-          * a minimal sample project that reproduces the issue, 
-          * your zipped project, 
-          * IDE / CLI steps to create the project and reproduce the behaviour, 
+      description:  |
+        Include as much of the following as possible:
+          * a minimal sample project that reproduces the issue,
+          * your zipped project,
+          * IDE / CLI steps to create the project and reproduce the behaviour,
           * your command line invocation.
-          
+
           If providing steps to reproduce the issue proves difficult, consider attaching a binlog:
           * [Details on sharing binary logs](https://aka.ms/msbuild/binlog)
           * [More information on binary logs](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md)
-          
+
           NOTE: Binary logs capture environment information. Ensure it does not include any information you don't want to be public before you attach one.
           If you want to share one just with Microsoft, you can [report a problem through Visual Studio](https://developercommunity.visualstudio.com/report) and share it privately with Microsoft.
     validations:
@@ -49,4 +48,4 @@ body:
       description: |
         In a Visual Studio developer command prompt, run `msbuild -version` and paste the output here.
         If applicable, include the version of the tool that invokes MSBuild (Visual Studio, dotnet CLI, etc).
-        Post any other relevant configuration settings here: OS, architecture, etc.
\ No newline at end of file
+        Post any other relevant configuration settings here: OS, architecture, etc.
diff --git a/.github/ISSUE_TEMPLATE/02_performanceissue.yml b/.github/ISSUE_TEMPLATE/02_performanceissue.yml
index 7cca706981f..b9dc50d4b42 100644
--- a/.github/ISSUE_TEMPLATE/02_performanceissue.yml
+++ b/.github/ISSUE_TEMPLATE/02_performanceissue.yml
@@ -2,6 +2,7 @@ name: üìâ Performance Issue
 description: Report a performance issue or regression.
 title: "[Performance]: "
 labels: ["performance"]
+type: 'Bug'
 body:
   - type: textarea
     attributes:
@@ -12,17 +13,17 @@ body:
   - type: textarea
     attributes:
       label: Steps to Reproduce
-      description:  | 
-        Include as much of the following as possible: 
-        * a minimal sample project that reproduces the issue, 
-        * your zipped project, 
-        * IDE / CLI steps to create the project and reproduce the behaviour, 
+      description:  |
+        Include as much of the following as possible:
+        * a minimal sample project that reproduces the issue,
+        * your zipped project,
+        * IDE / CLI steps to create the project and reproduce the behaviour,
         * your command line invocation.
-        
+
         If providing steps to reproduce the issue proves difficult, consider attaching a binlog:
         * [Details on sharing binary logs](https://aka.ms/msbuild/binlog)
         * [More information on binary logs](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md)
-        
+
         NOTE: Binary logs capture environment information. Ensure it does not include any information you don't want to be public before you attach one.
         If you want to share one just with Microsoft, you can [report a problem through Visual Studio](https://developercommunity.visualstudio.com/report) and share it privately with Microsoft.
     validations:
@@ -64,4 +65,4 @@ body:
     attributes:
       label: Regression Details
       description: |
-        Please provide details on regression: what version of MSBuild or VS were you using before the regression?
\ No newline at end of file
+        Please provide details on regression: what version of MSBuild or VS were you using before the regression?
diff --git a/.github/ISSUE_TEMPLATE/05_unhandledexception.yml b/.github/ISSUE_TEMPLATE/05_unhandledexception.yml
index 12388e79503..a55d4336d14 100644
--- a/.github/ISSUE_TEMPLATE/05_unhandledexception.yml
+++ b/.github/ISSUE_TEMPLATE/05_unhandledexception.yml
@@ -1,7 +1,7 @@
 name: üò± Unhandled Exception
 description: Reporting holes in our bug reporting system
 title: "[Unhandled Exception]: "
-labels: ["bug"]
+type: 'Bug'
 body:
   - type: textarea
     attributes:
@@ -12,17 +12,17 @@ body:
   - type: textarea
     attributes:
       label: Steps to Reproduce
-      description:  | 
-        Include as much of the following as possible: 
-        * a minimal sample project that reproduces the issue, 
-        * your zipped project, 
-        * IDE / CLI steps to create the project and reproduce the behaviour, 
+      description:  |
+        Include as much of the following as possible:
+        * a minimal sample project that reproduces the issue,
+        * your zipped project,
+        * IDE / CLI steps to create the project and reproduce the behaviour,
         * your command line invocation.
-        
+
         If providing steps to reproduce the issue proves difficult, consider attaching a binlog:
         * [Details on sharing binary logs](https://aka.ms/msbuild/binlog)
         * [More information on binary logs](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md)
-        
+
         NOTE: Binary logs capture environment information. Ensure it does not include any information you don't want to be public before you attach one.
         If you want to share one just with Microsoft, you can [report a problem through Visual Studio](https://developercommunity.visualstudio.com/report) and share it privately with Microsoft.
     validations:
@@ -44,4 +44,4 @@ body:
       description: |
         In a Visual Studio developer command prompt, run `msbuild -version` and paste the output here.
         If applicable, include the version of the tool that invokes MSBuild (Visual Studio, dotnet CLI, etc).
-        Post any other relevant configuration settings here: OS, architecture, etc.
\ No newline at end of file
+        Post any other relevant configuration settings here: OS, architecture, etc.
diff --git a/.github/ISSUE_TEMPLATE/06_feature_request.yml b/.github/ISSUE_TEMPLATE/06_feature_request.yml
index 15a628ffe1b..5ca2069f1ad 100644
--- a/.github/ISSUE_TEMPLATE/06_feature_request.yml
+++ b/.github/ISSUE_TEMPLATE/06_feature_request.yml
@@ -1,7 +1,6 @@
 name: üí° Feature  Request
 description: Suggest an idea for this project.
-title: "[Feature Request]: "
-labels: ["Feature Request"]
+type: 'Feature'
 body:
   - type: textarea
     attributes:
diff --git a/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml b/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml
index 7af03649c5e..c728e10acba 100644
--- a/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml
+++ b/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml
@@ -2,6 +2,7 @@ name: üí° BuildCheck Suggestion
 description: Suggesting a diagnostic check (AKA [BuildCheck](https://github.com/dotnet/msbuild/blob/main/documentation/specs/BuildCheck/BuildCheck.md)) that MSBuild could provide.
 title: "[BuildCheck Suggestion]: "
 labels: ["BuildCheck Suggestion", "Area: BuildCheck"]
+type: 'Feature'
 body:
   - type: textarea
     attributes:
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index f48e7b71850..1444313d595 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -37,7 +37,6 @@ variables:
     value: true # Enable loc for vs17.13
   - name: Codeql.Enabled
     value: true
-  - group: DotNet-MSBuild-SDLValidation-Params
 
 resources:
   repositories:
@@ -54,6 +53,11 @@ extends:
       name: VSEngSS-MicroBuild2022-1ES
       os: windows
     sdl:
+      policheck:
+        enabled: true
+        exclusionsFile: $(Build.SourcesDirectory)\eng\policheck_exclusions.xml
+      tsa:
+        enabled: true
       # We generate SBOM ourselves, so don't need steps injected by 1ES.
       sbom:
         enabled: false
@@ -306,18 +310,3 @@ extends:
         enableSymbolValidation: true
         enableSourceLinkValidation: false
         enableNugetValidation: false
-        SDLValidationParameters:
-          enable: true
-          continueOnError: false
-          params: ' -SourceToolsList @("policheck","credscan")
-          -TsaInstanceURL "$(_TsaInstanceURL)"
-          -TsaProjectName "$(_TsaProjectName)"
-          -TsaNotificationEmail "$(_TsaNotificationEmail)"
-          -TsaCodebaseAdmin "$(_TsaCodebaseAdmin)"
-          -TsaBugAreaPath "$(_TsaBugAreaPath)"
-          -TsaIterationPath "$(_TsaIterationPath)"
-          -TsaRepositoryName "dotnet-msbuild"
-          -TsaCodebaseName "dotnet-msbuild"
-          -TsaPublish $True
-          -CrScanAdditionalRunConfigParams @("SuppressionsPath < $(Build.SourcesDirectory)\eng\CredScanSuppressions.json")
-          -PoliCheckAdditionalRunConfigParams @("UserExclusionPath < $(Build.SourcesDirectory)\eng\policheck_exclusions.xml")'
diff --git a/NuGet.config b/NuGet.config
index 28add67a226..659ab421680 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -18,7 +18,6 @@
     <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
     <add key="dotnet9" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json" />
-    <add key="BuildXL" value="https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json" />
     <add key="msbuild17.12" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/darc-pub-DotNet-msbuild-Trusted-95c7bf01-1/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources>
@@ -32,10 +31,8 @@
     <!--  End: Package sources from dotnet-runtime -->
     <!--End: Package sources managed by Dependency Flow automation. Do not edit the sources above.-->
   </disabledPackageSources>
-
   <auditSources>
     <clear />
     <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
   </auditSources>
-
 </configuration>
diff --git a/documentation/Deploy-MSBuild.md b/documentation/Deploy-MSBuild.md
index db8d3b53f65..541a87c11c8 100644
--- a/documentation/Deploy-MSBuild.md
+++ b/documentation/Deploy-MSBuild.md
@@ -5,7 +5,7 @@
 [Deploy-MSBuild](https://github.com/dotnet/msbuild/blob/deploy-msbuild/scripts/Deploy-MSBuild.ps1) is a way to conveniently take private bits and install them into Visual Studio (VS) for testing. To use it:
 
 - If you haven't already, clone [MSBuild](https://github.com/dotnet/msbuild) and make the changes you want.
-- Build MSBuild with the changes you want using `build.cmd /p:CreateBootstrap=true`.
+- Build MSBuild with the changes you want using `build.cmd`.
 - In an administrator powershell window, navigate to the msbuild folder.
 - Run `scripts\Deploy-MSBuild.ps1 -destination {destination} -configuration {configuration}`.
   - Specify the Bin folder of MSBuild in your VS install as the destination. This is somewhere like `"C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin"`.
diff --git a/documentation/wiki/Adding-Events.md b/documentation/wiki/Adding-Events.md
new file mode 100644
index 00000000000..708c0ba101d
--- /dev/null
+++ b/documentation/wiki/Adding-Events.md
@@ -0,0 +1,54 @@
+# Adding Custom Events to MSBuild
+
+MSBuild has many built-in event types, but often you may need to add a new custom one. 
+
+## Steps for Binary Logger Compatibility
+This guide outlines the steps to ensure the BinaryLogger can work with your new event.
+
+### Changes in MSBuild
+
+1. **Add the `NewEventArgs` to `src/Framework` folder**
+2. **Update [BinaryLogRecordKind.cs](../../src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs)**
+   - Append the new event to the enum
+3. **Modify [BinaryLogger.cs](../../src/Build/Logging/BinaryLogger/BinaryLogger.cs)**
+   - Update `FileFormatVersion`
+4. **Update [BuildEventArgsReader.cs](../../src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs)**
+   - Add a new case in the `ReadBuildEventArgs` switch
+   - Implement a method for the added event (imitate other `ReadXYZEventArgs` methods)
+5. **Modify [BuildEventArgsWriter.cs](../../src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs)**
+   - Add a new case in `WriteCore`
+   - Document the change above the method
+6. **Update [LogMessagePacketBase.cs](../../src/Shared/LogMessagePacketBase.cs)**
+   - Add to `LoggingEventType`
+   - Add case in `GetBuildEventArgFromId` and `GetLoggingEventId`
+7. **Create a new test file**
+   - Add `Framework.UnitTests/NewEventArgs_Tests.cs`
+   - Use [BuildSubmissionStartedEventArgs_Tests.cs](../../src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs) as a reference
+8. **Update [NodePackets_Tests.cs](../../src/Build.UnitTests/BackEnd/NodePackets_Tests.cs)**
+   - Add relevant test cases
+
+### Changes in [MSBuildStructuredLog](https://github.com/KirillOsenkov/MSBuildStructuredLog)
+
+1. **Update [BinaryLogRecordKind.cs](https://github.com/KirillOsenkov/MSBuildStructuredLog/blob/master/src/StructuredLogger/BinaryLogger/BinaryLogRecordKind.cs)**
+   - Append the new event to the enum
+
+2. **Modify [BinaryLogger.cs](https://github.com/KirillOsenkov/MSBuildStructuredLog/blob/master/src/StructuredLogger/BinaryLogger/BinaryLogger.cs)**
+   - Increment version
+   - Document the change
+
+3. **Create `src/StructuredLogger/BinaryLogger/XXXEventArgs.cs`**
+   - Implement the class for the new event (copy from MSBuild)
+
+4. **Update [BuildEventArgsReader.cs](https://github.com/KirillOsenkov/MSBuildStructuredLog/blob/master/src/StructuredLogger/BinaryLogger/BuildEventArgsReader.cs)**
+   - Add a new case in `ReadBuildEventArgs`
+
+5. **Modify [BuildEventArgsWriter.cs](https://github.com/KirillOsenkov/MSBuildStructuredLog/blob/master/src/StructuredLogger/BinaryLogger/BuildEventArgsWriter.cs)**
+   - Add a new case in `WriteCore`
+
+### Example Pull Requests adding and serializing events
+
+1. [Add Buildcheck events support + BuildSubmissionStarted](https://github.com/KirillOsenkov/MSBuildStructuredLog/pull/797) (MSBuildStructuredLog)
+   - Corresponding [MSBuild PR](https://github.com/dotnet/msbuild/pull/10424)
+
+2. [Add Binary Logger Support for BuildCanceled](https://github.com/dotnet/msbuild/pull/10755) (MSBuild)
+   - Corresponding [MSBuildStructuredLog PR](https://github.com/KirillOsenkov/MSBuildStructuredLog/pull/824)
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 765f504dee0..ceff18cb3c1 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -15,8 +15,10 @@
     <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*8.0.4*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*8.0.5*" />
     <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
+	  <UsagePattern IdentityGlob="Microsoft.VisualStudio.SolutionPersistence/*1.0.9*" />
   </IgnorePatterns>
   <Usages>
   </Usages>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index ebcf20d46e9..8c0560aeb32 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -53,9 +53,9 @@
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
       <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
-    <Dependency Name="System.Text.Json" Version="8.0.4">
+    <Dependency Name="System.Text.Json" Version="8.0.5">
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>2aade6beb02ea367fd97c4070a4198802fe61c03</Sha>
+      <Sha>81cabf2857a01351e5ab578947c7403a5b128ad1</Sha>
     </Dependency>
     <Dependency Name="System.Threading.Tasks.Dataflow" Version="8.0.0">
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
@@ -71,36 +71,36 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24473.1">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24516.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1230437de1ab7b3e15fe7cdfe7ffce2f65449959</Sha>
+      <Sha>3c393bbd85ae16ddddba20d0b75035b0c6f1a52d</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.24473.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.24516.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1230437de1ab7b3e15fe7cdfe7ffce2f65449959</Sha>
+      <Sha>3c393bbd85ae16ddddba20d0b75035b0c6f1a52d</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.24473.1">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.24516.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1230437de1ab7b3e15fe7cdfe7ffce2f65449959</Sha>
+      <Sha>3c393bbd85ae16ddddba20d0b75035b0c6f1a52d</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.12.0-rc.120">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.12.0-rc.127">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>675e8a81acb53958e40dc21be5f562d00239a449</Sha>
+      <Sha>19756345139c45de23bd196e9b4be01d48e84fdd</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.12.0-3.24479.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.12.0-3.24510.2">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>ba2f19abe63a267dc9b2d082d0e1904cd91c1947</Sha>
+      <Sha>3fd39c8f6c8db918e3184050599c2046997160f1</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.12.0-3.24479.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.12.0-3.24510.2">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>ba2f19abe63a267dc9b2d082d0e1904cd91c1947</Sha>
+      <Sha>3fd39c8f6c8db918e3184050599c2046997160f1</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.24473.1">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.24516.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1230437de1ab7b3e15fe7cdfe7ffce2f65449959</Sha>
+      <Sha>3c393bbd85ae16ddddba20d0b75035b0c6f1a52d</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 31df63da22b..6429eb36519 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -40,7 +40,7 @@
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
     <SystemTextRegularExpressionsVersion>4.3.1</SystemTextRegularExpressionsVersion>
-    <SystemTextJsonVersion>8.0.4</SystemTextJsonVersion>
+    <SystemTextJsonVersion>8.0.5</SystemTextJsonVersion>
     <SystemThreadingChannelsVersion>8.0.0</SystemThreadingChannelsVersion>
     <SystemThreadingTasksDataflowVersion>8.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
@@ -50,15 +50,15 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.24473.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.24516.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.12.0-3.24479.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.12.0-rc.120</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.12.0-3.24510.2</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.12.0-rc.127</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
-    <BootstrapSdkVersion>9.0.100-rc.1.24452.12</BootstrapSdkVersion>
+    <BootstrapSdkVersion>9.0.100-rc.2.24474.11</BootstrapSdkVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
@@ -76,4 +76,8 @@
       <FileVersion>$(VersionPrefix).$(FileVersion.Split('.')[3])</FileVersion>
     </PropertyGroup>
   </Target>
+   <!-- SolutionPersistence -->
+  <PropertyGroup>
+	  <MicrosoftVisualStudioSolutionPersistenceVersion>1.0.9</MicrosoftVisualStudioSolutionPersistenceVersion>
+  </PropertyGroup>
 </Project>
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index e6699b3e106..6175fbc44f6 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -86,7 +86,7 @@ try {
   {
     $buildToolPath = Join-Path $bootstrapRoot "core\dotnet.exe"
     # The version must be consistent with BootstrapSdkVersion
-    $buildToolCommand = Join-Path $bootstrapRoot "core\sdk\9.0.100-rc.1.24452.12\MSBuild.dll"
+    $buildToolCommand = Join-Path $bootstrapRoot "core\sdk\9.0.100-rc.2.24474.11\MSBuild.dll"
     $buildToolFramework = "net9.0"
   }
 
@@ -121,7 +121,7 @@ try {
     & $PSScriptRoot\Common\Build.ps1 -restore -build -ci /p:CreateBootstrap=false /nr:false @properties
   }
   else {
-    & $PSScriptRoot\Common\Build.ps1 -restore -build -test -ci /p:CreateBootstrap=true /nr:false @properties
+    & $PSScriptRoot\Common\Build.ps1 -restore -build -test -ci /nr:false @properties
   }
 
   exit $lastExitCode
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 14c406f4b77..2926b7e75be 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -51,7 +51,7 @@ InitializeDotNetCli true
 
 if [[ $build_stage1 == true ]];
 then
-	/bin/bash "$ScriptRoot/common/build.sh" --restore --build --ci --configuration $configuration /p:CreateBootstrap=true $properties $extra_properties || exit $?
+	/bin/bash "$ScriptRoot/common/build.sh" --restore --build --ci --configuration $configuration $properties $extra_properties || exit $?
 fi
 
 bootstrapRoot="$Stage1Dir/bin/bootstrap"
@@ -60,7 +60,7 @@ if [ $host_type = "core" ]
 then
   _InitializeBuildTool="$bootstrapRoot/core/dotnet"
   # The version must be consistent with BootstrapSdkVersion
-  _InitializeBuildToolCommand="$bootstrapRoot/core/sdk/9.0.100-rc.1.24452.12/MSBuild.dll"
+  _InitializeBuildToolCommand="$bootstrapRoot/core/sdk/9.0.100-rc.2.24474.11/MSBuild.dll"
   _InitializeBuildToolFramework="net9.0"
 else
   echo "Unsupported hostType ($host_type)"
@@ -84,7 +84,7 @@ export DOTNET_HOST_PATH="$_InitializeDotNetCli/dotnet"
 # - Create bootstrap environment as it's required when also running tests
 if [ $onlyDocChanged = 0 ]
 then
-    . "$ScriptRoot/common/build.sh" --restore --build --test --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=true $properties $extra_properties
+    . "$ScriptRoot/common/build.sh" --restore --build --test --ci --nodereuse false --configuration $configuration $properties $extra_properties
 
 else
     . "$ScriptRoot/common/build.sh" --restore --build --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=false $properties $extra_properties
diff --git a/eng/common/core-templates/steps/get-delegation-sas.yml b/eng/common/core-templates/steps/get-delegation-sas.yml
index d2901470a7f..9db5617ea7d 100644
--- a/eng/common/core-templates/steps/get-delegation-sas.yml
+++ b/eng/common/core-templates/steps/get-delegation-sas.yml
@@ -31,7 +31,16 @@ steps:
       # Calculate the expiration of the SAS token and convert to UTC
       $expiry = (Get-Date).AddHours(${{ parameters.expiryInHours }}).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
 
-      $sas = az storage container generate-sas --account-name ${{ parameters.storageAccount }} --name ${{ parameters.container }} --permissions ${{ parameters.permissions }} --expiry $expiry --auth-mode login --as-user -o tsv
+      # Temporarily work around a helix issue where SAS tokens with / in them will cause incorrect downloads
+      # of correlation payloads. https://github.com/dotnet/dnceng/issues/3484
+      $sas = ""
+      do {
+        $sas = az storage container generate-sas --account-name ${{ parameters.storageAccount }} --name ${{ parameters.container }} --permissions ${{ parameters.permissions }} --expiry $expiry --auth-mode login --as-user -o tsv
+        if ($LASTEXITCODE -ne 0) {
+          Write-Error "Failed to generate SAS token."
+          exit 1
+        }
+      } while($sas.IndexOf('/') -ne -1)
 
       if ($LASTEXITCODE -ne 0) {
         Write-Error "Failed to generate SAS token."
diff --git a/eng/common/sdl/NuGet.config b/eng/common/sdl/NuGet.config
index 3849bdb3cf5..5bfbb02ef04 100644
--- a/eng/common/sdl/NuGet.config
+++ b/eng/common/sdl/NuGet.config
@@ -5,11 +5,11 @@
   </solution>
   <packageSources>
     <clear />
-    <add key="guardian" value="https://securitytools.pkgs.visualstudio.com/_packaging/Guardian/nuget/v3/index.json" />
+    <add key="guardian" value="https://pkgs.dev.azure.com/dnceng/_packaging/Guardian1ESPTUpstreamOrgFeed/nuget/v3/index.json" />
   </packageSources>
   <packageSourceMapping>
     <packageSource key="guardian">
-      <package pattern="microsoft.guardian.cli" />
+      <package pattern="Microsoft.Guardian.Cli.win-x64" />
     </packageSource>
   </packageSourceMapping>
   <disabledPackageSources>
diff --git a/eng/common/sdl/execute-all-sdl-tools.ps1 b/eng/common/sdl/execute-all-sdl-tools.ps1
index 4715d75e974..81ded5b7f47 100644
--- a/eng/common/sdl/execute-all-sdl-tools.ps1
+++ b/eng/common/sdl/execute-all-sdl-tools.ps1
@@ -6,7 +6,6 @@ Param(
   [string] $BranchName=$env:BUILD_SOURCEBRANCH,                                                  # Optional: name of branch or version of gdn settings; defaults to master
   [string] $SourceDirectory=$env:BUILD_SOURCESDIRECTORY,                                         # Required: the directory where source files are located
   [string] $ArtifactsDirectory = (Join-Path $env:BUILD_ARTIFACTSTAGINGDIRECTORY ('artifacts')),  # Required: the directory where build artifacts are located
-  [string] $AzureDevOpsAccessToken,                                                              # Required: access token for dnceng; should be provided via KeyVault
 
   # Optional: list of SDL tools to run on source code. See 'configure-sdl-tool.ps1' for tools list
   # format.
@@ -75,7 +74,7 @@ try {
   }
 
   Exec-BlockVerbosely {
-    & $(Join-Path $PSScriptRoot 'init-sdl.ps1') -GuardianCliLocation $guardianCliLocation -Repository $RepoName -BranchName $BranchName -WorkingDirectory $workingDirectory -AzureDevOpsAccessToken $AzureDevOpsAccessToken -GuardianLoggerLevel $GuardianLoggerLevel
+    & $(Join-Path $PSScriptRoot 'init-sdl.ps1') -GuardianCliLocation $guardianCliLocation -Repository $RepoName -BranchName $BranchName -WorkingDirectory $workingDirectory -GuardianLoggerLevel $GuardianLoggerLevel
   }
   $gdnFolder = Join-Path $workingDirectory '.gdn'
 
@@ -104,7 +103,6 @@ try {
           -TargetDirectory $targetDirectory `
           -GdnFolder $gdnFolder `
           -ToolsList $tools `
-          -AzureDevOpsAccessToken $AzureDevOpsAccessToken `
           -GuardianLoggerLevel $GuardianLoggerLevel `
           -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams `
           -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams `
diff --git a/eng/common/sdl/init-sdl.ps1 b/eng/common/sdl/init-sdl.ps1
index 3ac1d92b370..588ff8e22fb 100644
--- a/eng/common/sdl/init-sdl.ps1
+++ b/eng/common/sdl/init-sdl.ps1
@@ -3,7 +3,6 @@ Param(
   [string] $Repository,
   [string] $BranchName='master',
   [string] $WorkingDirectory,
-  [string] $AzureDevOpsAccessToken,
   [string] $GuardianLoggerLevel='Standard'
 )
 
@@ -21,14 +20,7 @@ $ci = $true
 # Don't display the console progress UI - it's a huge perf hit
 $ProgressPreference = 'SilentlyContinue'
 
-# Construct basic auth from AzDO access token; construct URI to the repository's gdn folder stored in that repository; construct location of zip file
-$encodedPat = [Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes(":$AzureDevOpsAccessToken"))
-$escapedRepository = [Uri]::EscapeDataString("/$Repository/$BranchName/.gdn")
-$uri = "https://dev.azure.com/dnceng/internal/_apis/git/repositories/sdl-tool-cfg/Items?path=$escapedRepository&versionDescriptor[versionOptions]=0&`$format=zip&api-version=5.0"
-$zipFile = "$WorkingDirectory/gdn.zip"
-
 Add-Type -AssemblyName System.IO.Compression.FileSystem
-$gdnFolder = (Join-Path $WorkingDirectory '.gdn')
 
 try {
   # if the folder does not exist, we'll do a guardian init and push it to the remote repository
diff --git a/eng/common/sdl/sdl.ps1 b/eng/common/sdl/sdl.ps1
index 648c5068d7d..7fe603fe995 100644
--- a/eng/common/sdl/sdl.ps1
+++ b/eng/common/sdl/sdl.ps1
@@ -4,6 +4,8 @@ function Install-Gdn {
         [Parameter(Mandatory=$true)]
         [string]$Path,
 
+        [string]$Source = "https://pkgs.dev.azure.com/dnceng/_packaging/Guardian1ESPTUpstreamOrgFeed/nuget/v3/index.json",
+
         # If omitted, install the latest version of Guardian, otherwise install that specific version.
         [string]$Version
     )
@@ -19,7 +21,7 @@ function Install-Gdn {
     $ci = $true
     . $PSScriptRoot\..\tools.ps1
 
-    $argumentList = @("install", "Microsoft.Guardian.Cli", "-Source https://securitytools.pkgs.visualstudio.com/_packaging/Guardian/nuget/v3/index.json", "-OutputDirectory $Path", "-NonInteractive", "-NoCache")
+    $argumentList = @("install", "Microsoft.Guardian.Cli.win-x64", "-Source $Source", "-OutputDirectory $Path", "-NonInteractive", "-NoCache")
 
     if ($Version) {
         $argumentList += "-Version $Version"
diff --git a/eng/common/templates-official/job/job.yml b/eng/common/templates-official/job/job.yml
index 3d16b41c78c..605692d2fb7 100644
--- a/eng/common/templates-official/job/job.yml
+++ b/eng/common/templates-official/job/job.yml
@@ -1,6 +1,7 @@
 parameters:
 # Sbom related params
   enableSbom: true
+  runAsPublic: false
   PackageVersion: 9.0.0
   BuildDropPath: '$(Build.SourcesDirectory)/artifacts'
 
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index 07d317bf8f9..d1aeb92fcea 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -4,6 +4,7 @@ parameters:
   componentGovernanceIgnoreDirectories: ''
 # Sbom related params
   enableSbom: true
+  runAsPublic: false
   PackageVersion: 9.0.0
   BuildDropPath: '$(Build.SourcesDirectory)/artifacts'
 
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 9574f4eb9df..22954477a57 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -900,7 +900,7 @@ function IsWindowsPlatform() {
 }
 
 function Get-Darc($version) {
-  $darcPath  = "$TempDir\darc\$(New-Guid)"
+  $darcPath  = "$TempDir\darc\$([guid]::NewGuid())"
   if ($version -ne $null) {
     & $PSScriptRoot\darc-init.ps1 -toolpath $darcPath -darcVersion $version | Out-Host
   } else {
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 1672382b7c3..4aab28833bb 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -60,6 +60,8 @@
 
     <PackageVersion Include="Verify.Xunit" Version="19.14.1" />
     <PackageVersion Update="Verify.XUnit" Condition="'$(VerifyXUnitVersion)' != ''" Version="$(VerifyXUnitVersion)" />
+	
+	<PackageVersion Include="Microsoft.VisualStudio.SolutionPersistence" Version="$(MicrosoftVisualStudioSolutionPersistenceVersion)" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildSourceOnly)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
diff --git a/global.json b/global.json
index 20a7d304435..03cd1994123 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "9.0.100-rc.1.24452.12",
+    "dotnet": "9.0.100-rc.2.24474.11",
     "vs": {
       "version": "17.10.0"
     },
     "xcopy-msbuild": "17.10.0-pre.4.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.24473.1"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.24516.2"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index 84d703d22e8..d6abd900521 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -4,10 +4,15 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Text;
+using System.Threading;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
+using Microsoft.VisualStudio.SolutionPersistence;
+using Microsoft.VisualStudio.SolutionPersistence.Model;
+using Microsoft.VisualStudio.SolutionPersistence.Serializer;
 using Shouldly;
 using Xunit;
 
@@ -59,11 +64,13 @@ public void ParseSolution_VC()
         /// Test that a project with the C++ project guid and an arbitrary extension is seen as valid --
         /// we assume that all C++ projects except .vcproj are MSBuild format.
         /// </summary>
-        [Fact]
-        public void ParseSolution_VC2()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolution_VC2(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}') = 'Project name.myvctype', 'Relative path\to\Project name.myvctype', '{0ABED153-9451-483C-8140-9E8D7306B216}'
@@ -83,13 +90,18 @@ public void ParseSolution_VC2()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
-            Assert.Equal("Project name.myvctype", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal("Relative path\\to\\Project name.myvctype", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
+            string expectedProjectName = convertToSlnx ? "Project name" : "Project name.myvctype";
+            Assert.Equal(expectedProjectName, solution.ProjectsInOrder[0].ProjectName);
+            Assert.Equal(ConvertToUnixPathIfNeeded("Relative path\\to\\Project name.myvctype", convertToSlnx), solution.ProjectsInOrder[0].RelativePath);
+            if (!convertToSlnx)
+            {
+                // When converting to SLNX, the project GUID is not preserved.
+                Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
+            }
         }
 
         /// <summary>
@@ -280,11 +292,13 @@ public void ParseSolutionFileWithDescriptionInformation()
         /// <summary>
         /// Tests the parsing of a very basic .SLN file with three independent projects.
         /// </summary>
-        [Fact]
-        public void BasicSolution()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void BasicSolution(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', 'ConsoleApplication1\ConsoleApplication1.vbproj', '{AB3413A6-D689-486D-B7F0-A095371B3F13}'
@@ -316,34 +330,40 @@ public void BasicSolution()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
-            Assert.Equal("ConsoleApplication1", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal(@"ConsoleApplication1\ConsoleApplication1.vbproj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{AB3413A6-D689-486D-B7F0-A095371B3F13}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
+            // When converting to slnx, the order of the projects is not preserved.
+            ProjectInSolution consoleApplication1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ConsoleApplication1");
+            Assert.Equal(ConvertToUnixPathIfNeeded("ConsoleApplication1\\ConsoleApplication1.vbproj", convertToSlnx), consoleApplication1.RelativePath);
+            Assert.Empty(consoleApplication1.Dependencies);
+            Assert.Null(consoleApplication1.ParentProjectGuid);
 
-            Assert.Equal("vbClassLibrary", solution.ProjectsInOrder[1].ProjectName);
-            Assert.Equal(@"vbClassLibrary\vbClassLibrary.vbproj", solution.ProjectsInOrder[1].RelativePath);
-            Assert.Equal("{BA333A76-4511-47B8-8DF4-CA51C303AD0B}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[1].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
+            ProjectInSolution vbClassLibrary = solution.ProjectsInOrder.First(p => p.ProjectName == "vbClassLibrary");
+            Assert.Equal(ConvertToUnixPathIfNeeded("vbClassLibrary\\vbClassLibrary.vbproj", convertToSlnx), vbClassLibrary.RelativePath);
+            Assert.Empty(vbClassLibrary.Dependencies);
+            Assert.Null(vbClassLibrary.ParentProjectGuid);
 
-            Assert.Equal("ClassLibrary1", solution.ProjectsInOrder[2].ProjectName);
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{DEBCE986-61B9-435E-8018-44B9EF751655}", solution.ProjectsInOrder[2].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
+            ProjectInSolution classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", convertToSlnx), classLibrary1.RelativePath);
+            Assert.Empty(classLibrary1.Dependencies);
+            Assert.Null(classLibrary1.ParentProjectGuid);
+
+            if (!convertToSlnx)
+            {
+                Assert.Equal("{AB3413A6-D689-486D-B7F0-A095371B3F13}", consoleApplication1.ProjectGuid);
+                Assert.Equal("{BA333A76-4511-47B8-8DF4-CA51C303AD0B}", vbClassLibrary.ProjectGuid);
+                Assert.Equal("{DEBCE986-61B9-435E-8018-44B9EF751655}", classLibrary1.ProjectGuid);
+            }
         }
 
         /// <summary>
         /// Exercises solution folders, and makes sure that samely named projects in different
         /// solution folders will get correctly uniquified.
+        /// For the new parser, solution folders are not included to ProjectsInOrder or ProjectsByGuid.
         /// </summary>
         [Fact]
         public void SolutionFolders()
@@ -396,7 +416,7 @@ public void SolutionFolders()
 
             Assert.Equal(5, solution.ProjectsInOrder.Count);
 
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[0].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", false), solution.ProjectsInOrder[0].RelativePath);
             Assert.Equal("{34E0D07D-CF8F-459D-9449-C4188D8C5564}", solution.ProjectsInOrder[0].ProjectGuid);
             Assert.Empty(solution.ProjectsInOrder[0].Dependencies);
             Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
@@ -405,7 +425,7 @@ public void SolutionFolders()
             Assert.Empty(solution.ProjectsInOrder[1].Dependencies);
             Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
 
-            Assert.Equal(@"MyPhysicalFolder\ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[2].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", false), solution.ProjectsInOrder[2].RelativePath);
             Assert.Equal("{A5EE8128-B08E-4533-86C5-E46714981680}", solution.ProjectsInOrder[2].ProjectGuid);
             Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
             Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[2].ParentProjectGuid);
@@ -414,12 +434,90 @@ public void SolutionFolders()
             Assert.Empty(solution.ProjectsInOrder[3].Dependencies);
             Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[3].ParentProjectGuid);
 
-            Assert.Equal(@"ClassLibrary2\ClassLibrary2.csproj", solution.ProjectsInOrder[4].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", false), solution.ProjectsInOrder[4].RelativePath);
             Assert.Equal("{6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}", solution.ProjectsInOrder[4].ProjectGuid);
             Assert.Empty(solution.ProjectsInOrder[4].Dependencies);
             Assert.Equal("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", solution.ProjectsInOrder[4].ParentProjectGuid);
         }
 
+        /// <summary>
+        /// Exercises solution folders, and makes sure that samely named projects in different
+        /// solution folders will get correctly uniquified.
+        /// For the new parser, solution folders are not included to ProjectsInOrder or ProjectsByGuid.
+        /// </summary>
+        [Fact]
+        public void SolutionFoldersSlnx()
+        {
+            string solutionFileContents =
+                """
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{34E0D07D-CF8F-459D-9449-C4188D8C5564}'
+                EndProject
+                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySlnFolder', 'MySlnFolder', '{E0F97730-25D2-418A-A7BD-02CAFDC6E470}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'MyPhysicalFolder\ClassLibrary1\ClassLibrary1.csproj', '{A5EE8128-B08E-4533-86C5-E46714981680}'
+                EndProject
+                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySubSlnFolder', 'MySubSlnFolder', '{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary2', 'ClassLibrary2\ClassLibrary2.csproj', '{6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(NestedProjects) = preSolution
+                        {A5EE8128-B08E-4533-86C5-E46714981680} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
+                        {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
+                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4} = {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}
+                    EndGlobalSection
+                EndGlobal
+                """;
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, true);
+
+            Assert.Equal(3, solution.ProjectsInOrder.Count);
+
+            var classLibrary1 = solution.ProjectsInOrder
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", true));
+            Assert.NotNull(classLibrary1);
+            Assert.Empty(classLibrary1.Dependencies);
+            Assert.Null(classLibrary1.ParentProjectGuid);
+
+            var myPhysicalFolderClassLibrary1 = solution.ProjectsInOrder
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", true));
+            Assert.NotNull(myPhysicalFolderClassLibrary1);
+            Assert.Empty(myPhysicalFolderClassLibrary1.Dependencies);
+
+            var classLibrary2 = solution.ProjectsInOrder
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", true));
+            Assert.NotNull(classLibrary2);
+            Assert.Empty(classLibrary2.Dependencies);
+
+            // When converting to slnx, the guids are not preserved.
+            // try at list assert not null
+            Assert.NotNull(myPhysicalFolderClassLibrary1.ParentProjectGuid);
+            Assert.NotNull(classLibrary2.ParentProjectGuid);
+        }
+
         /// <summary>
         /// Exercises shared projects.
         /// </summary>
@@ -556,13 +654,15 @@ public void MissingNestedProject()
 
         /// <summary>
         /// Verifies that hand-coded project-to-project dependencies listed in the .SLN file
-        /// are correctly recognized by our solution parser.
+        /// are correctly recognized by the solution parser.
         /// </summary>
-        [Fact]
-        public void SolutionDependencies()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionDependencies(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{05A5AD00-71B5-4612-AF2F-9EA9121C4111}'
@@ -601,27 +701,29 @@ public void SolutionDependencies()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{05A5AD00-71B5-4612-AF2F-9EA9121C4111}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Single(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Equal("{FAB4EE06-6E01-495A-8926-5514599E3DD9}", (string)solution.ProjectsInOrder[0].Dependencies[0]);
+            var classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
+            var classLibrary2 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary2");
+            var classLibrary3 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary3");
+
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", convertToSlnx), classLibrary1.RelativePath);
+            Assert.Single(classLibrary1.Dependencies);
+            Assert.Equal(classLibrary3.ProjectGuid, classLibrary1.Dependencies[0]);
             Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
 
-            Assert.Equal(@"ClassLibrary2\ClassLibrary2.csproj", solution.ProjectsInOrder[1].RelativePath);
-            Assert.Equal("{7F316407-AE3E-4F26-BE61-2C50D30DA158}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Equal(2, solution.ProjectsInOrder[1].Dependencies.Count);
-            Assert.Equal("{FAB4EE06-6E01-495A-8926-5514599E3DD9}", (string)solution.ProjectsInOrder[1].Dependencies[0]);
-            Assert.Equal("{05A5AD00-71B5-4612-AF2F-9EA9121C4111}", (string)solution.ProjectsInOrder[1].Dependencies[1]);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", convertToSlnx), classLibrary2.RelativePath);
+            Assert.Equal(2, classLibrary2.Dependencies.Count);
+            // When converting to SLNX, the projects dependencies order is not preserved.
+            Assert.Contains(classLibrary3.ProjectGuid, classLibrary2.Dependencies);
+            Assert.Contains(classLibrary1.ProjectGuid, classLibrary2.Dependencies);
             Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
 
-            Assert.Equal(@"ClassLibrary3\ClassLibrary3.csproj", solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{FAB4EE06-6E01-495A-8926-5514599E3DD9}", solution.ProjectsInOrder[2].ProjectGuid);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary3\\ClassLibrary3.csproj", convertToSlnx), solution.ProjectsInOrder[2].RelativePath);
             Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
             Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
         }
@@ -629,11 +731,13 @@ public void SolutionDependencies()
         /// <summary>
         /// Make sure the solution configurations get parsed correctly for a simple mixed C#/VC solution
         /// </summary>
-        [Fact]
-        public void ParseSolutionConfigurations()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolutionConfigurations(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -678,9 +782,9 @@ public void ParseSolutionConfigurations()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
             Assert.Equal(7, solution.SolutionConfigurations.Count);
 
@@ -704,11 +808,13 @@ public void ParseSolutionConfigurations()
         /// <summary>
         /// Make sure the solution configurations get parsed correctly for a simple C# application
         /// </summary>
-        [Fact]
-        public void ParseSolutionConfigurationsNoMixedPlatform()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -733,14 +839,14 @@ public void ParseSolutionConfigurationsNoMixedPlatform()
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|ARM.ActiveCfg = Release|Any CPU
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|ARM.Build.0 = Release|Any CPU
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|x86.ActiveCfg = Release|Any CPU
-                   EndGlobalSection
+                    EndGlobalSection
                     GlobalSection(SolutionProperties) = preSolution
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
             Assert.Equal(6, solution.SolutionConfigurations.Count);
 
@@ -839,15 +945,18 @@ public void ParseInvalidSolutionConfigurations3()
                 ParseSolutionHelper(solutionFileContents);
             });
         }
+
         /// <summary>
         /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a simple mixed C#/VC solution
         /// </summary>
-        [Fact]
-        public void ParseProjectConfigurationsInSolutionConfigurations1()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -889,12 +998,12 @@ public void ParseProjectConfigurationsInSolutionConfigurations1()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
-            ProjectInSolution csharpProject = (ProjectInSolution)solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
-            ProjectInSolution vcProject = (ProjectInSolution)solution.ProjectsByGuid["{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}"];
+            ProjectInSolution csharpProject = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
+            ProjectInSolution vcProject = solution.ProjectsInOrder.First(p => p.ProjectName == "MainApp");
 
             Assert.Equal(6, csharpProject.ProjectConfigurations.Count);
 
@@ -998,6 +1107,65 @@ public void ParseProjectConfigurationsInSolutionConfigurations2()
             Assert.Equal(".NET", solution.GetDefaultPlatformName()); // "Default solution platform"
         }
 
+        [Fact]
+        public void ParseProjectConfigurationsInSolutionConfigurationsSlnx()
+        {
+            string solutionFileContents =
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio Version 17
+                VisualStudioVersion = 17.11.35111.106
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""WinFormsApp1"", ""WinFormsApp1\WinFormsApp1.csproj"", ""{3B592A6A-6215-4675-9237-7FEB36BDB4F1}""
+                EndProject
+                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1\ClassLibrary1.csproj"", ""{C25056E0-405C-4476-9B22-839264A8530C}""
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Win32 = Debug|Win32
+                        Release|Win32 = Release|Win32
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {3B592A6A-6215-4675-9237-7FEB36BDB4F1}.Debug|Win32.ActiveCfg = Debug|x86
+                        {3B592A6A-6215-4675-9237-7FEB36BDB4F1}.Debug|Win32.Build.0 = Debug|x86
+                        {3B592A6A-6215-4675-9237-7FEB36BDB4F1}.Release|Win32.ActiveCfg = Release|x86
+                        {3B592A6A-6215-4675-9237-7FEB36BDB4F1}.Release|Win32.Build.0 = Release|x86
+                        {C25056E0-405C-4476-9B22-839264A8530C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {C25056E0-405C-4476-9B22-839264A8530C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(ExtensibilityGlobals) = postSolution
+                        SolutionGuid = {AA62B7C4-C703-4DBC-A7AD-D183666ECC20}
+                    EndGlobalSection
+                EndGlobal
+                """;
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, true);
+
+            ProjectInSolution winFormsApp1 = solution.ProjectsInOrder.First(p => p.ProjectName == "WinFormsApp1");
+            ProjectInSolution classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
+
+            Assert.Equal(2, winFormsApp1.ProjectConfigurations.Count);
+
+            Assert.Equal("Debug|x86", winFormsApp1.ProjectConfigurations["Debug|Win32"].FullName);
+            Assert.True(winFormsApp1.ProjectConfigurations["Debug|Win32"].IncludeInBuild);
+
+            Assert.Equal("Release|x86", winFormsApp1.ProjectConfigurations["Release|Win32"].FullName);
+            Assert.True(winFormsApp1.ProjectConfigurations["Debug|Win32"].IncludeInBuild);
+
+            Assert.Equal(2, classLibrary1.ProjectConfigurations.Count);
+
+            Assert.Equal("Debug|AnyCPU", classLibrary1.ProjectConfigurations["Debug|Any CPU"].FullName);
+            Assert.False(classLibrary1.ProjectConfigurations["Debug|Any CPU"].IncludeInBuild);
+
+            Assert.Equal("Release|AnyCPU", classLibrary1.ProjectConfigurations["Release|Any CPU"].FullName);
+            Assert.False(classLibrary1.ProjectConfigurations["Release|Any CPU"].IncludeInBuild);
+        }
+
         /// <summary>
         /// Parse solution file with comments
         /// </summary>
@@ -1053,23 +1221,36 @@ public void ParseSolutionWithComments()
 
         /// <summary>
         /// Helper method to create a SolutionFile object, and call it to parse the SLN file
-        /// represented by the string contents passed in.
+        /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.
         /// </summary>
-        private static SolutionFile ParseSolutionHelper(string solutionFileContents)
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-            string solutionPath = FileUtilities.GetTemporaryFileName(".sln");
 
-            try
-            {
-                File.WriteAllText(solutionPath, solutionFileContents);
-                SolutionFile sp = SolutionFile.Parse(solutionPath);
-                return sp;
-            }
-            finally
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
-                File.Delete(solutionPath);
+                TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
+
+                string solutionPath = convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path;
+
+                return SolutionFile.Parse(solutionPath);
             }
         }
+
+        private static string ConvertToSlnx(string slnPath)
+        {
+            string slnxPath = slnPath + "x";
+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(slnPath).ShouldNotBeNull();
+            SolutionModel solutionModel = serializer.OpenAsync(slnPath, CancellationToken.None).Result;
+            SolutionSerializers.SlnXml.SaveAsync(slnxPath, solutionModel, CancellationToken.None).Wait();
+            return slnxPath;
+        }
+
+        private static string ConvertToUnixPathIfNeeded(string path, bool isConvertedToSlnx)
+        {
+            // In the new parser, ProjectModel.FilePath is converted to Unix-style.
+            // we are using the new parser only for slnx files.
+            return !NativeMethodsShared.IsWindows && isConvertedToSlnx ? path.Replace('\\', '/') : path;
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index f609a693cba..c249a953174 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -79,6 +79,7 @@ public void VerifyEventType()
             GeneratedFileUsedEventArgs generatedFileUsed = new GeneratedFileUsedEventArgs("path", "some content");
             BuildSubmissionStartedEventArgs buildSubmissionStarted = new(new Dictionary<string, string> { { "Value1", "Value2" } }, ["Path1"], ["TargetName"], BuildRequestDataFlags.ReplaceExistingProjectInstance, 123);
             BuildCheckTracingEventArgs buildCheckTracing = new();
+            BuildCanceledEventArgs buildCanceled = new("message", DateTime.UtcNow);
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -114,6 +115,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(generatedFileUsed, LoggingEventType.GeneratedFileUsedEvent);
             VerifyLoggingPacket(buildSubmissionStarted, LoggingEventType.BuildSubmissionStartedEvent);
             VerifyLoggingPacket(buildCheckTracing, LoggingEventType.BuildCheckTracingEvent);
+            VerifyLoggingPacket(buildCanceled, LoggingEventType.BuildCanceledEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index bf2af7ca1fc..c45baa49e1e 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -97,6 +97,18 @@ public void RoundtripBuildFinishedEventArgs()
                 e => e.Succeeded.ToString());
         }
 
+        [Fact]
+        public void RoundtripBuildCanceledEventArgs()
+        {
+            var args = new BuildCanceledEventArgs(
+                "Message",
+                eventTimestamp: DateTime.Parse("12/12/2015 06:11:56 PM"));
+
+            Roundtrip(args,
+                e => e.Message,
+                e => e.Timestamp.ToString());
+        }
+
         [Fact]
         public void RoundtripBuildSubmissionStartedEventArgs()
         {
diff --git a/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
new file mode 100644
index 00000000000..7f56b600dca
--- /dev/null
+++ b/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
@@ -0,0 +1,163 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.Threading;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Shared;
+using Microsoft.VisualStudio.SolutionPersistence;
+using Microsoft.VisualStudio.SolutionPersistence.Model;
+using Microsoft.VisualStudio.SolutionPersistence.Serializer;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+#nullable disable
+
+namespace Microsoft.Build.UnitTests.Construction
+{
+    public class SolutionFile_NewParser_Tests
+    {
+        public ITestOutputHelper TestOutputHelper { get; }
+
+        public SolutionFile_NewParser_Tests(ITestOutputHelper testOutputHelper)
+        {
+            TestOutputHelper = testOutputHelper;
+        }
+
+        /// <summary>
+        /// Tests to see that all the data/properties are correctly parsed out of a Venus
+        /// project in a .SLN. This can be checked only here because of AspNetConfigurations protection level.
+        /// </summary>
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ProjectWithWebsiteProperties(bool convertToSlnx)
+        {
+            string solutionFileContents =
+                """
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project(`{E24C65DC-7377-472B-9ABA-BC803B73C61A}`) = `C:\WebSites\WebApplication3\`, `C:\WebSites\WebApplication3\`, `{464FD0B9-E335-4677-BE1E-6B2F982F4D86}`
+                    ProjectSection(WebsiteProperties) = preProject
+                        ProjectReferences = `{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSCla;ssLibra;ry1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;`
+                        Frontpage = false
+                            Debug.AspNetCompiler.VirtualPath = `/publishfirst`
+                            Debug.AspNetCompiler.PhysicalPath = `..\rajeev\temp\websites\myfirstwebsite\`
+                            Debug.AspNetCompiler.TargetPath = `..\rajeev\temp\publishfirst\`
+                            Debug.AspNetCompiler.ForceOverwrite = `true`
+                            Debug.AspNetCompiler.Updateable = `false`
+                            Debug.AspNetCompiler.Debug = `true`
+                            Debug.AspNetCompiler.KeyFile = `debugkeyfile.snk`
+                            Debug.AspNetCompiler.KeyContainer = `12345.container`
+                            Debug.AspNetCompiler.DelaySign = `true`
+                            Debug.AspNetCompiler.AllowPartiallyTrustedCallers = `false`
+                            Debug.AspNetCompiler.FixedNames = `debugfixednames`
+                            Release.AspNetCompiler.VirtualPath = `/publishfirst_release`
+                            Release.AspNetCompiler.PhysicalPath = `..\rajeev\temp\websites\myfirstwebsite_release\`
+                            Release.AspNetCompiler.TargetPath = `..\rajeev\temp\publishfirst_release\`
+                            Release.AspNetCompiler.ForceOverwrite = `true`
+                            Release.AspNetCompiler.Updateable = `true`
+                            Release.AspNetCompiler.Debug = `false`
+                        VWDPort = 63496
+                    EndProjectSection
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|.NET = Debug|.NET
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {464FD0B9-E335-4677-BE1E-6B2F982F4D86}.Debug|.NET.ActiveCfg = Debug|.NET
+                        {464FD0B9-E335-4677-BE1E-6B2F982F4D86}.Debug|.NET.Build.0 = Debug|.NET
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                """;
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents.Replace('`', '"'), convertToSlnx);
+
+            solution.ProjectsInOrder.ShouldHaveSingleItem();
+
+            solution.ProjectsInOrder[0].ProjectType.ShouldBe(SolutionProjectType.WebProject);
+            solution.ProjectsInOrder[0].ProjectName.ShouldBe(@"C:\WebSites\WebApplication3\");
+            solution.ProjectsInOrder[0].RelativePath.ShouldBe(ConvertToUnixPathIfNeeded(@"C:\WebSites\WebApplication3\"));
+            solution.ProjectsInOrder[0].Dependencies.Count.ShouldBe(2);
+            solution.ProjectsInOrder[0].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[0].GetUniqueProjectName().ShouldBe(@"C:\WebSites\WebApplication3\");
+
+            Hashtable aspNetCompilerParameters = solution.ProjectsInOrder[0].AspNetConfigurations;
+            AspNetCompilerParameters debugAspNetCompilerParameters = (AspNetCompilerParameters)aspNetCompilerParameters["Debug"];
+            AspNetCompilerParameters releaseAspNetCompilerParameters = (AspNetCompilerParameters)aspNetCompilerParameters["Release"];
+
+            debugAspNetCompilerParameters.aspNetVirtualPath.ShouldBe(@"/publishfirst");
+            debugAspNetCompilerParameters.aspNetPhysicalPath.ShouldBe(@"..\rajeev\temp\websites\myfirstwebsite\");
+            debugAspNetCompilerParameters.aspNetTargetPath.ShouldBe(@"..\rajeev\temp\publishfirst\");
+            debugAspNetCompilerParameters.aspNetForce.ShouldBe(@"true");
+            debugAspNetCompilerParameters.aspNetUpdateable.ShouldBe(@"false");
+            debugAspNetCompilerParameters.aspNetDebug.ShouldBe(@"true");
+            debugAspNetCompilerParameters.aspNetKeyFile.ShouldBe(@"debugkeyfile.snk");
+            debugAspNetCompilerParameters.aspNetKeyContainer.ShouldBe(@"12345.container");
+            debugAspNetCompilerParameters.aspNetDelaySign.ShouldBe(@"true");
+            debugAspNetCompilerParameters.aspNetAPTCA.ShouldBe(@"false");
+            debugAspNetCompilerParameters.aspNetFixedNames.ShouldBe(@"debugfixednames");
+
+            releaseAspNetCompilerParameters.aspNetVirtualPath.ShouldBe(@"/publishfirst_release");
+            releaseAspNetCompilerParameters.aspNetPhysicalPath.ShouldBe(@"..\rajeev\temp\websites\myfirstwebsite_release\");
+            releaseAspNetCompilerParameters.aspNetTargetPath.ShouldBe(@"..\rajeev\temp\publishfirst_release\");
+            releaseAspNetCompilerParameters.aspNetForce.ShouldBe(@"true");
+            releaseAspNetCompilerParameters.aspNetUpdateable.ShouldBe(@"true");
+            releaseAspNetCompilerParameters.aspNetDebug.ShouldBe(@"false");
+            releaseAspNetCompilerParameters.aspNetKeyFile.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetKeyContainer.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetDelaySign.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetAPTCA.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetFixedNames.ShouldBe("");
+
+            List<string> aspNetProjectReferences = solution.ProjectsInOrder[0].ProjectReferences;
+            aspNetProjectReferences.Count.ShouldBe(2);
+            aspNetProjectReferences[0].ShouldBe("{FD705688-88D1-4C22-9BFF-86235D89C2FC}");
+            aspNetProjectReferences[1].ShouldBe("{F0726D09-042B-4A7A-8A01-6BED2422BD5D}");
+        }
+
+        /// <summary>
+        /// Helper method to create a SolutionFile object, and call it to parse the SLN file
+        /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.
+        /// </summary>
+        internal static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
+        {
+            solutionFileContents = solutionFileContents.Replace('\'', '"');
+
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
+
+                string solutionPath = convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path;
+
+                SolutionFile solutionFile = new SolutionFile { FullPath = solutionPath };
+                solutionFile.ParseUsingNewParser();
+                return solutionFile;
+            }
+        }
+
+        private static string ConvertToSlnx(string slnPath)
+        {
+            string slnxPath = slnPath + "x";
+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(slnPath).ShouldNotBeNull();
+            SolutionModel solutionModel = serializer.OpenAsync(slnPath, CancellationToken.None).Result;
+            SolutionSerializers.SlnXml.SaveAsync(slnxPath, solutionModel, CancellationToken.None).Wait();
+            return slnxPath;
+        }
+
+        private static string ConvertToUnixPathIfNeeded(string path)
+        {
+            // In the new parser, ProjectModel.FilePath is converted to Unix-style.
+            return !NativeMethodsShared.IsWindows ? path.Replace('\\', '/') : path;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
index 400c3f6af52..e173c47c640 100644
--- a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Threading;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
@@ -13,6 +14,9 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.UnitTests;
+using Microsoft.VisualStudio.SolutionPersistence.Model;
+using Microsoft.VisualStudio.SolutionPersistence.Serializer;
+using Microsoft.VisualStudio.SolutionPersistence;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -215,8 +219,10 @@ public void InvalidSolutionFilters(string slnfValue, string exceptionReason)
         /// <summary>
         /// Test that a solution filter file is parsed correctly, and it can accurately respond as to whether a project should be filtered out.
         /// </summary>
-        [Fact]
-        public void ParseSolutionFilter()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolutionFilter(bool convertToSlnx)
         {
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
@@ -229,35 +235,35 @@ public void ParseSolutionFilter()
                 // The important part of this .sln is that it has references to each of the four projects we just created.
                 TransientTestFile sln = testEnvironment.CreateFile(folder, "Microsoft.Build.Dev.sln",
                     @"
-                    Microsoft Visual Studio Solution File, Format Version 12.00
-                    # Visual Studio 15
-                    VisualStudioVersion = 15.0.27004.2009
-                    MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build"", """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)) + @""", ""{69BE05E2-CBDA-4D27-9733-44E12B0F5627}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""MSBuild"", """ + Path.Combine("src", Path.GetFileName(msbuild.Path)) + @""", ""{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.CommandLine.UnitTests"", """ + Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)) + @""", ""{0ADDBC02-0076-4159-B351-2BF33FAA46B2}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.Tasks.UnitTests"", """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)) + @""", ""{CF999BDE-02B3-431B-95E6-E88D621D9CBF}""
-                    EndProject
-                    Global
-                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        EndGlobalSection
-                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(ExtensibilityGlobals) = postSolution
-                    EndGlobalSection
-                    EndGlobal
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 15
+VisualStudioVersion = 15.0.27004.2009
+MinimumVisualStudioVersion = 10.0.40219.1
+Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build"", """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)) + @""", ""{69BE05E2-CBDA-4D27-9733-44E12B0F5627}""
+EndProject
+Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""MSBuild"", """ + Path.Combine("src", Path.GetFileName(msbuild.Path)) + @""", ""{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}""
+EndProject
+Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.CommandLine.UnitTests"", """ + Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)) + @""", ""{0ADDBC02-0076-4159-B351-2BF33FAA46B2}""
+EndProject
+Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.Tasks.UnitTests"", """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)) + @""", ""{CF999BDE-02B3-431B-95E6-E88D621D9CBF}""
+EndProject
+Global
+    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+    EndGlobalSection
+    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+EndGlobalSection
+GlobalSection(SolutionProperties) = preSolution
+    HideSolutionNode = FALSE
+EndGlobalSection
+GlobalSection(ExtensibilityGlobals) = postSolution
+EndGlobalSection
+EndGlobal
                     ");
                 TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf",
                     @"
                     {
                       ""solution"": {
-                        ""path"": """ + sln.Path.Replace("\\", "\\\\") + @""",
+                        ""path"": """ + (convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path).Replace("\\", "\\\\") + @""",
                         ""projects"": [
                           """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)!).Replace("\\", "\\\\") + @""",
                           """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)!).Replace("\\", "\\\\") + @"""
@@ -276,6 +282,15 @@ public void ParseSolutionFilter()
             }
         }
 
+        private static string ConvertToSlnx(string slnPath)
+        {
+            string slnxPath = slnPath + "x";
+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(slnPath).ShouldNotBeNull();
+            SolutionModel solutionModel = serializer.OpenAsync(slnPath, CancellationToken.None).Result;
+            SolutionSerializers.SlnXml.SaveAsync(slnxPath, solutionModel, CancellationToken.None).Wait();
+            return slnxPath;
+        }
+
         private ILoggingService CreateMockLoggingService()
         {
             ILoggingService loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 0);
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index f4c85d3285e..1da44037bef 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1292,6 +1292,55 @@ public void StaticMethodErrorMessageHaveMethodName1()
 
             Assert.Fail();
         }
+
+        [Fact]
+        public void StaticMethodWithThrowawayParameterSupported()
+        {
+            MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
+<Project>
+  <PropertyGroup>
+    <MyProperty>Value is $([System.Int32]::TryParse(""3"", out _))</MyProperty>
+  </PropertyGroup>
+  <Target Name='Build'>
+    <Message Text='$(MyProperty)' />
+  </Target>
+</Project>");
+
+            logger.FullLog.ShouldContain("Value is True");
+        }
+
+        [Fact]
+        public void StaticMethodWithThrowawayParameterSupported2()
+        {
+            MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
+<Project>
+  <PropertyGroup>
+    <MyProperty>Value is $([System.Int32]::TryParse(""notANumber"", out _))</MyProperty>
+  </PropertyGroup>
+  <Target Name='Build'>
+    <Message Text='$(MyProperty)' />
+  </Target>
+</Project>");
+
+            logger.FullLog.ShouldContain("Value is False");
+        }
+
+        [Fact]
+        public void StaticMethodWithUnderscoreNotConfusedWithThrowaway()
+        {
+            MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
+<Project>
+  <PropertyGroup>
+    <MyProperty>Value is $([System.String]::Join('_', 'asdf', 'jkl'))</MyProperty>
+  </PropertyGroup>
+  <Target Name='Build'>
+    <Message Text='$(MyProperty)' />
+  </Target>
+</Project>");
+
+            logger.FullLog.ShouldContain("Value is asdf_jkl");
+        }
+
         /// <summary>
         /// Creates a set of complicated item metadata and properties, and items to exercise
         /// the Expander class.  The data here contains escaped characters, metadata that
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 199c39ff7f6..3d8ccf424fb 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -668,7 +668,7 @@ IEnumerable<ILogger> AppendDebuggingLoggers(IEnumerable<ILogger> loggers)
 
                 var logger = new BinaryLogger { Parameters = binlogPath };
 
-                return (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[] { logger });
+                return (loggers ?? [logger]);
             }
 
             void InitializeCaches()
@@ -1522,7 +1522,7 @@ private BuildRequestConfiguration CreateConfiguration(Project project, BuildRequ
 
             if (existingConfiguration == null)
             {
-                existingConfiguration = new BuildRequestConfiguration(GetNewConfigurationId(), new BuildRequestData(newInstance, Array.Empty<string>()), null /* use the instance's tools version */);
+                existingConfiguration = new BuildRequestConfiguration(GetNewConfigurationId(), new BuildRequestData(newInstance, []), null /* use the instance's tools version */);
             }
             else
             {
@@ -1830,7 +1830,7 @@ void IssueBuildSubmissionToSchedulerImpl(BuildSubmission submission, bool allowM
                             }
                         }
 
-                        BuildRequestBlocker blocker = new BuildRequestBlocker(-1, Array.Empty<string>(), new[] { submission.BuildRequest });
+                        BuildRequestBlocker blocker = new BuildRequestBlocker(-1, [], [submission.BuildRequest]);
 
                         HandleNewRequest(Scheduler.VirtualNode, blocker);
                     }
@@ -3110,48 +3110,51 @@ private void ShutdownLoggingService(ILoggingService? loggingService)
         /// </summary>
         private void Dispose(bool disposing)
         {
-            if (!_disposed)
+            if (disposing && !_disposed)
             {
-                if (disposing)
+                lock (_syncLock)
                 {
-                    lock (_syncLock)
+                    if (_disposed)
                     {
-                        // We should always have finished cleaning up before calling Dispose.
-                        RequireState(BuildManagerState.Idle, "ShouldNotDisposeWhenBuildManagerActive");
+                        // Multiple caller raced for enter into the lock
+                        return;
+                    }
 
-                        _componentFactories?.ShutdownComponents();
+                    // We should always have finished cleaning up before calling Dispose.
+                    RequireState(BuildManagerState.Idle, "ShouldNotDisposeWhenBuildManagerActive");
 
-                        if (_workQueue != null)
-                        {
-                            _workQueue.Complete();
-                            _workQueue = null;
-                        }
+                    _componentFactories?.ShutdownComponents();
 
-                        if (_executionCancellationTokenSource != null)
-                        {
-                            _executionCancellationTokenSource.Cancel();
-                            _executionCancellationTokenSource = null;
-                        }
+                    if (_workQueue != null)
+                    {
+                        _workQueue.Complete();
+                        _workQueue = null;
+                    }
 
-                        if (_noActiveSubmissionsEvent != null)
-                        {
-                            _noActiveSubmissionsEvent.Dispose();
-                            _noActiveSubmissionsEvent = null;
-                        }
+                    if (_executionCancellationTokenSource != null)
+                    {
+                        _executionCancellationTokenSource.Cancel();
+                        _executionCancellationTokenSource = null;
+                    }
 
-                        if (_noNodesActiveEvent != null)
-                        {
-                            _noNodesActiveEvent.Dispose();
-                            _noNodesActiveEvent = null;
-                        }
+                    if (_noActiveSubmissionsEvent != null)
+                    {
+                        _noActiveSubmissionsEvent.Dispose();
+                        _noActiveSubmissionsEvent = null;
+                    }
 
-                        if (ReferenceEquals(this, s_singletonInstance))
-                        {
-                            s_singletonInstance = null;
-                        }
+                    if (_noNodesActiveEvent != null)
+                    {
+                        _noNodesActiveEvent.Dispose();
+                        _noNodesActiveEvent = null;
+                    }
 
-                        _disposed = true;
+                    if (ReferenceEquals(this, s_singletonInstance))
+                    {
+                        s_singletonInstance = null;
                     }
+
+                    _disposed = true;
                 }
             }
         }
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index 1dba5f10f78..7ef719402d2 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -187,7 +187,7 @@ public override BuildResult Execute()
             ExecuteAsync(null, null, _legacyThreadingSemantics);
             if (_legacyThreadingSemantics)
             {
-                RequestBuilder.WaitWithBuilderThreadStart(new[] { WaitHandle }, false, legacyThreadingData, SubmissionId);
+                RequestBuilder.WaitWithBuilderThreadStart([WaitHandle], false, legacyThreadingData, SubmissionId);
             }
             else
             {
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 642f1b1b024..c23b5134407 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -467,10 +467,11 @@ private bool TryLaunchServer()
 
             try
             {
-                string[] msBuildServerOptions = new string[] {
+                string[] msBuildServerOptions =
+                [
                     "/nologo",
                     "/nodemode:8"
-                };
+                ];
                 NodeLauncher nodeLauncher = new NodeLauncher();
                 CommunicationsUtilities.Trace("Starting Server...");
                 Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions), nodeId: 0);
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 4c2be1f5a97..9e9ee1d0bf8 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -205,14 +205,15 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                     // will be returned by WaitAny if multiple wait handles are signalled. We prefer to have the
                     // terminate event triggered so that we cannot get into a situation where packets are being
                     // spammed to the client and it never gets an opportunity to shutdown.
-                    WaitHandle[] handles = new WaitHandle[] {
-                    localPacketPumpShutdownEvent,
+                    WaitHandle[] handles =
+                    [
+                        localPacketPumpShutdownEvent,
 #if FEATURE_APM
-                    result.AsyncWaitHandle
+                        result.AsyncWaitHandle
 #else
-                    ((IAsyncResult)readTask).AsyncWaitHandle
+                        ((IAsyncResult)readTask).AsyncWaitHandle
 #endif
-                    };
+                    ];
                     int waitId = WaitHandle.WaitAny(handles);
                     switch (waitId)
                     {
diff --git a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
index 8bfb43b1ecb..3defd87986c 100644
--- a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
@@ -107,14 +107,14 @@ public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
                 FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);
 
             // Support shared compilation
-            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = new BreakawayChildProcess[]
-            {
+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox =
+            [
 #if RUNTIME_TYPE_NETCORE
                 new BreakawayChildProcess(NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet", "vbcscompiler.dll", CommandLineArgsSubstringContainmentIgnoreCase: true)
 #else
                 new BreakawayChildProcess(NativeMethodsShared.IsWindows ? "VBCSCompiler.exe" : "VBCSCompiler")
 #endif
-            };
+            ];
             info.FileAccessManifest.MonitorChildProcesses = true;
             info.FileAccessManifest.IgnoreReparsePoints = true;
             info.FileAccessManifest.UseExtraThreadToDrainNtClose = false;
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 68843247305..70ec3d41487 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -420,7 +420,7 @@ private void PacketPumpProc()
                 // will be returned by WaitAny if multiple wait handles are signalled.  We prefer to have the
                 // terminate event triggered so that we cannot get into a situation where packets are being
                 // spammed to the endpoint and it never gets an opportunity to shutdown.
-                WaitHandle[] handles = new WaitHandle[] { _terminatePacketPump, _packetAvailable };
+                WaitHandle[] handles = [_terminatePacketPump, _packetAvailable];
 
                 bool exitLoop = false;
                 do
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 8804918dbc0..1d42c48cd14 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -9,8 +9,6 @@
 
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
 
-#nullable disable
-
 namespace Microsoft.Build.BackEnd.Logging
 {
     /// <summary>
@@ -27,84 +25,84 @@ internal sealed class EventSourceSink :
         /// <summary>
         /// This event is raised to log a message.
         /// </summary>
-        public event BuildMessageEventHandler MessageRaised;
+        public event BuildMessageEventHandler? MessageRaised;
 
         /// <summary>
         /// This event is raised to log an error.
         /// </summary>
-        public event BuildErrorEventHandler ErrorRaised;
+        public event BuildErrorEventHandler? ErrorRaised;
 
         /// <summary>
         /// This event is raised to log a warning.
         /// </summary>
-        public event BuildWarningEventHandler WarningRaised;
+        public event BuildWarningEventHandler? WarningRaised;
 
         /// <summary>
         /// this event is raised to log the start of a build
         /// </summary>
-        public event BuildStartedEventHandler BuildStarted;
+        public event BuildStartedEventHandler? BuildStarted;
 
         /// <summary>
         /// this event is raised to log the end of a build
         /// </summary>
-        public event BuildFinishedEventHandler BuildFinished;
+        public event BuildFinishedEventHandler? BuildFinished;
 
         /// <summary>
         /// this event is raised to log the start of a project build
         /// </summary>
-        public event ProjectStartedEventHandler ProjectStarted;
+        public event ProjectStartedEventHandler? ProjectStarted;
 
         /// <summary>
         /// this event is raised to log the end of a project build
         /// </summary>
-        public event ProjectFinishedEventHandler ProjectFinished;
+        public event ProjectFinishedEventHandler? ProjectFinished;
 
         /// <summary>
         /// this event is raised to log the start of a target build
         /// </summary>
-        public event TargetStartedEventHandler TargetStarted;
+        public event TargetStartedEventHandler? TargetStarted;
 
         /// <summary>
         /// this event is raised to log the end of a target build
         /// </summary>
-        public event TargetFinishedEventHandler TargetFinished;
+        public event TargetFinishedEventHandler? TargetFinished;
 
         /// <summary>
         /// this event is raised to log the start of task execution
         /// </summary>
-        public event TaskStartedEventHandler TaskStarted;
+        public event TaskStartedEventHandler? TaskStarted;
 
         /// <summary>
         /// this event is raised to log the end of task execution
         /// </summary>
-        public event TaskFinishedEventHandler TaskFinished;
+        public event TaskFinishedEventHandler? TaskFinished;
 
         /// <summary>
         /// this event is raised to log a custom event
         /// </summary>
-        public event CustomBuildEventHandler CustomEventRaised;
+        public event CustomBuildEventHandler? CustomEventRaised;
 
         /// <summary>
         /// this event is raised to log build status events, such as
         /// build/project/target/task started/stopped
         /// </summary>
-        public event BuildStatusEventHandler StatusEventRaised;
+        public event BuildStatusEventHandler? StatusEventRaised;
 
         /// <summary>
         /// This event is raised to log that some event has
         /// occurred.  It is raised on every event.
         /// </summary>
-        public event AnyEventHandler AnyEventRaised;
+        public event AnyEventHandler? AnyEventRaised;
 
         /// <summary>
         /// This event is raised to log telemetry.
         /// </summary>
-        public event TelemetryEventHandler TelemetryLogged;
+        public event TelemetryEventHandler? TelemetryLogged;
 
         /// <summary>
         /// This event is raised to log BuildCheck events.
         /// </summary>
-        internal event BuildCheckEventHandler BuildCheckEventRaised;
+        internal event BuildCheckEventHandler? BuildCheckEventRaised;
         #endregion
 
         #region Properties
@@ -112,7 +110,7 @@ internal sealed class EventSourceSink :
         /// Provide a friendly name for the sink to make it easier to differentiate during
         /// debugging and display
         /// </summary>
-        public string Name
+        public string? Name
         {
             get;
             set;
@@ -224,57 +222,67 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)
         /// </summary>
         public void Consume(BuildEventArgs buildEvent)
         {
+
             switch (buildEvent)
             {
                 case BuildMessageEventArgs buildMessageEvent:
-                    RaiseMessageEvent(null, buildMessageEvent);
+                    RaiseEvent(buildMessageEvent, args => MessageRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case TaskStartedEventArgs taskStartedEvent:
-                    RaiseTaskStartedEvent(null, taskStartedEvent);
+                    ArgsHandler<TaskStartedEventArgs> taskStartedFollowUp = args => RaiseEvent(args, args=> StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(taskStartedEvent, args => TaskStarted?.Invoke(null, args), taskStartedFollowUp);
                     break;
                 case TaskFinishedEventArgs taskFinishedEvent:
-                    RaiseTaskFinishedEvent(null, taskFinishedEvent);
+                    ArgsHandler<TaskFinishedEventArgs> taskFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(taskFinishedEvent, args => TaskFinished?.Invoke(null, args), taskFinishedFollowUp);
                     break;
                 case TargetStartedEventArgs targetStartedEvent:
-                    RaiseTargetStartedEvent(null, targetStartedEvent);
+                    ArgsHandler<TargetStartedEventArgs> targetStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(targetStartedEvent, args => TargetStarted?.Invoke(null, args), targetStartedFollowUp);
                     break;
                 case TargetFinishedEventArgs targetFinishedEvent:
-                    RaiseTargetFinishedEvent(null, targetFinishedEvent);
+                    ArgsHandler<TargetFinishedEventArgs> targetFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(targetFinishedEvent, args => TargetFinished?.Invoke(null, args), targetFinishedFollowUp);
                     break;
                 case ProjectStartedEventArgs projectStartedEvent:
-                    RaiseProjectStartedEvent(null, projectStartedEvent);
+                    ArgsHandler<ProjectStartedEventArgs> projectStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(projectStartedEvent, args => ProjectStarted?.Invoke(null, args), projectStartedFollowUp);
                     break;
                 case ProjectFinishedEventArgs projectFinishedEvent:
-                    RaiseProjectFinishedEvent(null, projectFinishedEvent);
+                    ArgsHandler<ProjectFinishedEventArgs> projectFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(projectFinishedEvent, args => ProjectFinished?.Invoke(null, args), projectFinishedFollowUp);
                     break;
                 case BuildStartedEventArgs buildStartedEvent:
                     HaveLoggedBuildStartedEvent = true;
-                    RaiseBuildStartedEvent(null, buildStartedEvent);
+                    ArgsHandler<BuildStartedEventArgs> BuildStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(buildStartedEvent, args => BuildStarted?.Invoke(null, args), BuildStartedFollowUp);
                     break;
                 case BuildFinishedEventArgs buildFinishedEvent:
                     HaveLoggedBuildFinishedEvent = true;
-                    RaiseBuildFinishedEvent(null, buildFinishedEvent);
+                    ArgsHandler<BuildFinishedEventArgs> BuildFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(buildFinishedEvent, args => BuildFinished?.Invoke(null, args), BuildFinishedFollowUp);
                     break;
                 case BuildCanceledEventArgs buildCanceledEvent:
-                    RaiseStatusEvent(null, buildCanceledEvent);
+
+                    RaiseEvent(buildCanceledEvent, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case CustomBuildEventArgs customBuildEvent:
-                    RaiseCustomEvent(null, customBuildEvent);
+                    RaiseEvent(customBuildEvent, args => CustomEventRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case BuildStatusEventArgs buildStatusEvent:
-                    RaiseStatusEvent(null, buildStatusEvent);
+                    RaiseEvent(buildStatusEvent, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case BuildWarningEventArgs buildWarningEvent:
-                    RaiseWarningEvent(null, buildWarningEvent);
+                    RaiseEvent(buildWarningEvent, args => WarningRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case BuildErrorEventArgs buildErrorEvent:
-                    RaiseErrorEvent(null, buildErrorEvent);
+                    RaiseEvent(buildErrorEvent, args => ErrorRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case TelemetryEventArgs telemetryEvent:
-                    RaiseTelemetryEvent(null, telemetryEvent);
+                    RaiseEvent(telemetryEvent, args => TelemetryLogged?.Invoke(null, args), null);
                     break;
                 case BuildCheckEventArgs buildCheckEvent:
-                    RaiseBuildCheckEvent(null, buildCheckEvent);
+                    RaiseEvent(buildCheckEvent, args => BuildCheckEventRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
 
                 default:
@@ -288,7 +296,7 @@ public void Consume(BuildEventArgs buildEvent)
         /// </summary>
         public void ShutDown()
         {
-            this.UnregisterAllEventHandlers();
+            UnregisterAllEventHandlers();
         }
         #endregion
 
@@ -321,611 +329,80 @@ internal void UnregisterAllEventHandlers()
 
         #region Private Methods
 
-        /// <summary>
-        /// Raises a message event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildMessageEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseMessageEvent(object sender, BuildMessageEventArgs buildEvent)
-        {
-            if (MessageRaised != null)
-            {
-                try
-                {
-                    MessageRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseAnyEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises an error event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildErrorEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseErrorEvent(object sender, BuildErrorEventArgs buildEvent)
-        {
-            if (ErrorRaised != null)
-            {
-                try
-                {
-                    ErrorRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseAnyEvent(sender, buildEvent);
-        }
+        public delegate void ArgsHandler<in TArgs>(TArgs e) where TArgs : BuildEventArgs;
 
         /// <summary>
-        /// Raises a warning event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildWarningEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseWarningEvent(object sender, BuildWarningEventArgs buildEvent)
-        {
-            if (WarningRaised != null)
-            {
-                try
-                {
-                    WarningRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseAnyEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "build started" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildStartedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseBuildStartedEvent(object sender, BuildStartedEventArgs buildEvent)
-        {
-            if (BuildStarted != null)
-            {
-                try
-                {
-                    BuildStarted(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "build finished" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildFinishedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseBuildFinishedEvent(object sender, BuildFinishedEventArgs buildEvent)
-        {
-            if (BuildFinished != null)
-            {
-                try
-                {
-                    BuildFinished(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "project build started" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">ProjectStartedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs buildEvent)
-        {
-            if (ProjectStarted != null)
-            {
-                try
-                {
-                    ProjectStarted(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "project build finished" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">ProjectFinishedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseProjectFinishedEvent(object sender, ProjectFinishedEventArgs buildEvent)
-        {
-            if (ProjectFinished != null)
-            {
-                try
-                {
-                    ProjectFinished(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "target build started" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">TargetStartedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseTargetStartedEvent(object sender, TargetStartedEventArgs buildEvent)
-        {
-            if (TargetStarted != null)
-            {
-                try
-                {
-                    TargetStarted(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "target build finished" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">TargetFinishedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseTargetFinishedEvent(object sender, TargetFinishedEventArgs buildEvent)
-        {
-            if (TargetFinished != null)
-            {
-                try
-                {
-                    TargetFinished(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "task execution started" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">TaskStartedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseTaskStartedEvent(object sender, TaskStartedEventArgs buildEvent)
-        {
-            if (TaskStarted != null)
-            {
-                try
-                {
-                    TaskStarted(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "task finished executing" event to all registered loggers.
+        /// Raises a message event to all registered loggers.
         /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">TaskFinishedEventArgs</param>
+        /// <param name="buildEvent">event args</param>
+        /// <param name="handler">argument handler that invokes the respective event</param>
+        /// <param name="followUpHandler"> either anyEvent or statusEvent, it is invoked after the Event has been processed</param>
         /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
         /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
         /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseTaskFinishedEvent(object sender, TaskFinishedEventArgs buildEvent)
+        private void RaiseEvent<TArgs>(TArgs buildEvent, ArgsHandler<TArgs> handler, ArgsHandler<TArgs>? followUpHandler)
+            where TArgs : BuildEventArgs
         {
-            if (TaskFinished != null)
+            try
             {
-                try
-                {
-                    TaskFinished(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
+                handler(buildEvent);
             }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a custom event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">CustomBuildEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseCustomEvent(object sender, CustomBuildEventArgs buildEvent)
-        {
-            if (CustomEventRaised != null)
+            catch (LoggerException)
             {
-                try
-                {
-                    CustomEventRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
+                // if a logger has failed politely, abort immediately
+                // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
+                // if a fellow logger is throwing in an event handler.
+                UnregisterAllEventHandlers();
+                throw;
             }
-
-            RaiseAnyEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a catch-all build status event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildStatusEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseStatusEvent(object sender, BuildStatusEventArgs buildEvent)
-        {
-            if (StatusEventRaised != null)
+            catch (Exception exception)
             {
-                try
-                {
-                    StatusEventRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
+                // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
+                // if a fellow logger is throwing in an event handler.
+                UnregisterAllEventHandlers();
 
-            RaiseAnyEvent(sender, buildEvent);
-        }
-
-        private void RaiseBuildCheckEvent(object sender, BuildCheckEventArgs buildEvent)
-        {
-            if (BuildCheckEventRaised != null)
-            {
-                try
-                {
-                    BuildCheckEventRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
+                if (ExceptionHandling.IsCriticalException(exception))
                 {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
                     throw;
                 }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
 
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
+                InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
             }
-
-            RaiseAnyEvent(sender, buildEvent);
+            followUpHandler?.Invoke(buildEvent);
         }
 
         /// <summary>
         /// Raises a catch-all build event to all registered loggers.
+        /// Keeping it separate since it also dumps the Exception to file as opposed to all other events.
         /// </summary>
-        /// <param name="sender">sender of the event</param>
         /// <param name="buildEvent">Build EventArgs</param>
         /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
         /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
         /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
+        private void RaiseAnyEvent(BuildEventArgs buildEvent)
         {
             if (AnyEventRaised != null)
             {
                 try
                 {
-                    AnyEventRaised(sender, buildEvent);
+                    AnyEventRaised(null, buildEvent);
                 }
                 catch (LoggerException exception)
                 {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    UnregisterAllEventHandlers();
+                    if (ExceptionHandling.IsCriticalException(exception))
+                    {
+                        // if a logger has failed politely, abort immediately
+                        // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
+                        // if a fellow logger is throwing in an event handler.
+                        UnregisterAllEventHandlers();
 
-                    // We ought to dump this further up the stack, but if for example a task is logging an event within a
-                    // catch(Exception) block and not rethrowing it, there's the possibility that this exception could
-                    // just get silently eaten.  So better to have duplicates than to not log the problem at all. :)
-                    ExceptionHandling.DumpExceptionToFile(exception);
+                        // We ought to dump this further up the stack, but if for example a task is logging an event within a
+                        // catch(Exception) block and not rethrowing it, there's the possibility that this exception could
+                        // just get silently eaten.  So better to have duplicates than to not log the problem at all. :)
+                        ExceptionHandling.DumpExceptionToFile(exception);
 
-                    throw;
+                        throw;
+                    }
                 }
                 catch (Exception exception)
                 {
@@ -944,41 +421,6 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
             }
         }
 
-        /// <summary>
-        /// Raises the a telemetry event to all registered loggers.
-        /// </summary>
-        private void RaiseTelemetryEvent(object sender, TelemetryEventArgs buildEvent)
-        {
-            if (TelemetryLogged != null)
-            {
-                try
-                {
-                    TelemetryLogged(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-        }
-
         #endregion
         #endregion
     }
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 69e796772b4..22687557135 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -207,7 +207,7 @@ private static ProjectStartedEventArgs CreateProjectStarted(
             {
                 if (projectProperties is null)
                 {
-                    properties = Enumerable.Empty<DictionaryEntry>();
+                    properties = [];
                 }
                 else if (Traits.LogAllEnvironmentVariables)
                 {
@@ -218,7 +218,7 @@ private static ProjectStartedEventArgs CreateProjectStarted(
                     properties = projectProperties.Filter(p => p is not EnvironmentDerivedProjectPropertyInstance || EnvironmentUtilities.IsWellKnownEnvironmentDerivedProperty(p.Name), p => new DictionaryEntry(p.Name, p.EvaluatedValue));
                 }
 
-                items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? Enumerable.Empty<DictionaryEntry>();
+                items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? [];
             }
 
             if (projectProperties != null &&
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
index d7b5ea98cca..5f3ff599c99 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
@@ -30,7 +30,7 @@ public CacheContext(
             MSBuildFileSystemBase fileSystem,
             ProjectGraph? graph = null,
             IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)
-            : this(pluginSettings, fileSystem, requestedTargets: Array.Empty<string>(), graph, graphEntryPoints)
+            : this(pluginSettings, fileSystem, requestedTargets: [], graph, graphEntryPoints)
         {
         }
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index d573f4bdc74..43192499a9e 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -454,7 +454,7 @@ public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancel
 
                 BuildRequestData buildRequest = new BuildRequestData(
                     cacheRequest.Configuration.Project,
-                    cacheRequest.Submission.BuildRequestData?.TargetNames.ToArray() ?? Array.Empty<string>());
+                    cacheRequest.Submission.BuildRequestData?.TargetNames.ToArray() ?? []);
                 BuildEventContext buildEventContext = _loggingService.CreateProjectCacheBuildEventContext(
                     cacheRequest.Submission.SubmissionId,
                     evaluationId: cacheRequest.Configuration.Project.EvaluationId,
@@ -650,7 +650,7 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildReq
             }
             else
             {
-                return new[] { new ProjectGraphEntryPoint(configuration.ProjectFullPath, globalProperties) };
+                return [new ProjectGraphEntryPoint(configuration.ProjectFullPath, globalProperties)];
             }
 
             static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index b072bdbe462..73f84dd94a0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -504,7 +504,7 @@ internal static List<string[]> CreateTargetLists(
                 // Separate target invocations for each individual target.
                 foreach (string targetName in targets)
                 {
-                    targetLists.Add(new[] { targetName });
+                    targetLists.Add([targetName]);
                 }
             }
             else
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 5df61cc392b..0d9b660b451 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -402,7 +402,7 @@ public async Task BlockOnTargetInProgress(int blockingGlobalRequestId, string bl
 
             RaiseOnBlockedRequest(blockingGlobalRequestId, blockingTarget, partialBuildResult);
 
-            WaitHandle[] handles = new WaitHandle[] { _terminateEvent, _continueEvent };
+            WaitHandle[] handles = [_terminateEvent, _continueEvent];
 
             int handle;
             if (IsBuilderUsingLegacyThreadingSemantics(_componentHost, _requestEntry))
@@ -448,7 +448,7 @@ public void Reacquire()
             VerifyIsNotZombie();
             RaiseOnBlockedRequest(_requestEntry.Request.GlobalRequestId, String.Empty);
 
-            WaitHandle[] handles = new WaitHandle[] { _terminateEvent, _continueEvent };
+            WaitHandle[] handles = [_terminateEvent, _continueEvent];
 
             int handle = WaitHandle.WaitAny(handles);
 
@@ -506,7 +506,7 @@ public int RequestCores(object monitorLockObject, int requestedCores, bool waitF
             RaiseResourceRequest(ResourceRequest.CreateAcquireRequest(_requestEntry.Request.GlobalRequestId, requestedCores, waitForCores));
 
             // Wait for one of two events to be signaled: 1) The build was canceled, 2) The response to our request was received.
-            WaitHandle[] waitHandles = new WaitHandle[] { _terminateEvent, responseEvent };
+            WaitHandle[] waitHandles = [_terminateEvent, responseEvent];
             int waitResult;
 
             // Drop the lock so that the same task can call ReleaseCores from other threads to unblock itself.
@@ -957,7 +957,7 @@ private async Task<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildReque
             BuildResult[] results;
             if (waitForResults)
             {
-                WaitHandle[] handles = new WaitHandle[] { _terminateEvent, _continueEvent };
+                WaitHandle[] handles = [_terminateEvent, _continueEvent];
 
                 int handle;
                 if (IsBuilderUsingLegacyThreadingSemantics(_componentHost, _requestEntry))
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index e9e1bf575a2..09567c2370f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -261,11 +261,11 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, Syste
         {
             VerifyActiveProxy();
             return BuildProjectFilesInParallel(
-                new string[] { projectFileName },
+                [projectFileName],
                 targetNames,
-                new IDictionary[] { globalProperties },
-                new IDictionary[] { targetOutputs },
-                new string[] { toolsVersion },
+                [globalProperties],
+                [targetOutputs],
+                [toolsVersion],
                 true,
                 false);
         }
@@ -1205,8 +1205,8 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                     BuildResult[] results = await builderCallback.BuildProjects(
                         projectFileNames,
                         propertyDictionaries,
-                        toolsVersion ?? Array.Empty<string>(),
-                        targetNames ?? Array.Empty<string>(),
+                        toolsVersion ?? [],
+                        targetNames ?? [],
                         waitForResults: true,
                         skipNonexistentTargets: skipNonexistentTargets);
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 4d7abb22231..246f6b591b6 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -187,7 +187,7 @@ public IEnumerable<string> ActiveTargets
         {
             get
             {
-                VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Executing });
+                VerifyOneOfStates([SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Executing]);
                 return _activeTargetsWhenBlocked;
             }
         }
@@ -334,7 +334,7 @@ public void Reacquire()
         /// <param name="blockingTarget">Target that we are blocked on which is being built by <paramref name="blockingRequest"/></param>
         public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTargets, string blockingTarget = null)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Executing });
+            VerifyOneOfStates([SchedulableRequestState.Blocked, SchedulableRequestState.Executing]);
             ErrorUtilities.VerifyThrowArgumentNull(blockingRequest, nameof(blockingRequest));
             ErrorUtilities.VerifyThrowArgumentNull(activeTargets, nameof(activeTargets));
             ErrorUtilities.VerifyThrow(BlockingTarget == null, "Cannot block again if we're already blocked on a target");
@@ -350,7 +350,7 @@ public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTa
             // to also execute, then that request is not unscheduled (because it was running on the node) and it is not executing (because this condition
             // can only occur against requests which are executing on the same node and since the request which called this method is the one currently
             // executing on that node, that means the request it is blocked by must either be itself blocked or ready.)
-            blockingRequest.VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled });
+            blockingRequest.VerifyOneOfStates([SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled]);
 
             // Update our list of active targets.  This has to be done before we detect circular dependencies because we use this information to detect
             // re-entrancy circular dependencies.
@@ -371,7 +371,7 @@ public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTa
         /// </summary>
         public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
@@ -384,7 +384,7 @@ public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         /// </summary>
         public void UnblockWithResult(BuildResult result)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
@@ -400,7 +400,7 @@ public void ResumeExecution(int nodeId)
         {
             ErrorUtilities.VerifyThrow(_assignedNodeId == Scheduler.InvalidNodeId || _assignedNodeId == nodeId, "Request must always resume on the same node on which it was started.");
 
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrow((_state == SchedulableRequestState.Ready) || !_schedulingData.IsRequestScheduled(this), "Another instance of request {0} is already scheduled.", _request.GlobalRequestId);
             ErrorUtilities.VerifyThrow(!_schedulingData.IsNodeWorking(nodeId), "Cannot resume execution of request {0} because node {1} is already working.", _request.GlobalRequestId, nodeId);
 
@@ -416,7 +416,7 @@ public void ResumeExecution(int nodeId)
         /// </summary>
         public void Complete(BuildResult result)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Ready, SchedulableRequestState.Executing, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Ready, SchedulableRequestState.Executing, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrow(_state != SchedulableRequestState.Ready || result.CircularDependency, "Request can only be Completed from the Ready state if the result indicates a circular dependency occurred.");
             ErrorUtilities.VerifyThrow(_requestsWeAreBlockedBy.Count == 0, "We can't be complete if we are still blocked on requests.");
 
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 4bffd2f0cf4..5fedb8c7ac9 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1627,7 +1627,7 @@ private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRe
 
             // The request we blocked on couldn't have been executing (because we are) so it must either be yielding (which is ok because
             // it isn't modifying its own state, just running a background process), ready, or still blocked.
-            blockingRequest.VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Yielding, SchedulableRequestState.Ready, SchedulableRequestState.Blocked });
+            blockingRequest.VerifyOneOfStates([SchedulableRequestState.Yielding, SchedulableRequestState.Ready, SchedulableRequestState.Blocked]);
 
             // detect the case for https://github.com/dotnet/msbuild/issues/3047
             // if we have partial results AND blocked and blocking share the same configuration AND are blocked on each other
@@ -1651,7 +1651,7 @@ private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRe
         private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequest, List<ScheduleResponse> responses)
         {
             // Create the new request which will go to the configuration's results node.
-            BuildRequest newRequest = new BuildRequest(parentRequest.BuildRequest.SubmissionId, BuildRequest.ResultsTransferNodeRequestId, parentRequest.BuildRequest.ConfigurationId, Array.Empty<string>(), null, parentRequest.BuildRequest.BuildEventContext, parentRequest.BuildRequest, parentRequest.BuildRequest.BuildRequestDataFlags);
+            BuildRequest newRequest = new BuildRequest(parentRequest.BuildRequest.SubmissionId, BuildRequest.ResultsTransferNodeRequestId, parentRequest.BuildRequest.ConfigurationId, [], null, parentRequest.BuildRequest.BuildEventContext, parentRequest.BuildRequest, parentRequest.BuildRequest.BuildRequestDataFlags);
 
             // Assign a new global request id - always different from any other.
             newRequest.GlobalRequestId = _nextGlobalRequestId;
diff --git a/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs b/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
index 8ce9065b9d0..6e49ea9d18d 100644
--- a/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
@@ -34,7 +34,7 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase c
 
             return FileUtilities.DirectoryExistsNoThrow(sdkPath)
                 ? factory.IndicateSuccess(sdkPath, string.Empty)
-                : factory.IndicateFailure(new string[] { ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DefaultSDKResolverError", sdk.Name, sdkPath) }, null);
+                : factory.IndicateFailure([ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DefaultSDKResolverError", sdk.Name, sdkPath)], null);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 5241e228c2f..fbd4a2ba24a 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -126,7 +126,7 @@ private SdkResult RequestSdkPathFromMainNode(int submissionId, SdkReference sdk,
             SendPacket(packet);
 
             // Wait for either the response or a shutdown event.  Either event means this thread should return
-            WaitHandle.WaitAny(new WaitHandle[] { _responseReceivedEvent, ShutdownEvent });
+            WaitHandle.WaitAny([_responseReceivedEvent, ShutdownEvent]);
 
             // Keep track of the element location of the reference
             _lastResponse.ElementLocation = sdkReferenceLocation;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 252bf62ab14..cf2f12b58a2 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -349,7 +349,7 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
 
                 SetResolverState(submissionId, sdkResolver, context.State);
 
-                result ??= (SdkResult)resultFactory.IndicateFailure(new string[] { ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", sdkResolver.Name) }, Array.Empty<string>());
+                result ??= (SdkResult)resultFactory.IndicateFailure([ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", sdkResolver.Name)], []);
 
                 if (result.Success)
                 {
@@ -380,8 +380,8 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
                 results.Add(result);
             }
 
-            warnings = results.SelectMany(r => r.Warnings ?? Array.Empty<string>());
-            errors = results.SelectMany(r => r.Errors ?? Array.Empty<string>());
+            warnings = results.SelectMany(r => r.Warnings ?? []);
+            errors = results.SelectMany(r => r.Errors ?? []);
 
             sdkResult = new SdkResult(sdk, null, null);
             return false;
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 927d696f2e9..7b4049f8905 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -137,7 +137,7 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
                 _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
                 _nodeEndpoint.Listen(this);
 
-                var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+                WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent];
 
                 // Get the current directory before doing work. We need this so we can restore the directory when the node shuts down.
                 _savedCurrentDirectory = NativeMethodsShared.GetCurrentDirectory();
diff --git a/src/Build/BackEnd/Node/NodeConfiguration.cs b/src/Build/BackEnd/Node/NodeConfiguration.cs
index 2caec69b11d..99ab53e2e70 100644
--- a/src/Build/BackEnd/Node/NodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/NodeConfiguration.cs
@@ -162,27 +162,20 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _buildParameters, BuildParameters.FactoryForDeserialization);
             translator.TranslateArray(ref _forwardingLoggers, LoggerDescription.FactoryForTranslation);
 #if FEATURE_APPDOMAIN
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
-            {
-                byte[] appDomainConfigBytes = null;
+            byte[] appDomainConfigBytes = null;
 
-                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
-                if (translator.Mode == TranslationDirection.WriteToStream)
-                {
-                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
-                }
+            // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+            }
 
-                translator.Translate(ref appDomainConfigBytes);
+            translator.Translate(ref appDomainConfigBytes);
 
-                if (translator.Mode == TranslationDirection.ReadFromStream)
-                {
-                    _appDomainSetup = new AppDomainSetup();
-                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
-                }
-            }
-            else
+            if (translator.Mode == TranslationDirection.ReadFromStream)
             {
-                translator.TranslateDotNet(ref _appDomainSetup);
+                _appDomainSetup = new AppDomainSetup();
+                _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
             }
 #endif
             translator.Translate(ref _loggingNodeConfiguration);
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index af13beb079d..5148f89be9f 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -250,7 +250,7 @@ public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exce
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
-            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+            WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent];
 
             // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
             while (true)
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index d409d52d057..ab17e3b7ce1 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -139,7 +139,7 @@ private NodeEngineShutdownReason RunInternal(out Exception? shutdownException, S
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
-            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+            WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent];
 
             // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
             while (true)
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 537998947d3..b3ce3e8eafd 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -380,7 +380,7 @@ public override BuildResultCode OverallResult
                     return BuildResultCode.Failure;
                 }
 
-                foreach (KeyValuePair<string, TargetResult> result in _resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
+                foreach (KeyValuePair<string, TargetResult> result in _resultsByTarget ?? [])
                 {
                     if ((result.Value.ResultCode == TargetResultCode.Failure && !result.Value.TargetFailureDoesntCauseBuildFailure)
                         || result.Value.AfterTargetsHaveFailed)
@@ -549,7 +549,7 @@ internal void KeepSpecificTargetResults(IReadOnlyCollection<string> targetsToKee
                 targetsToKeep.Count > 0,
                 $"{nameof(targetsToKeep)} should contain at least one target.");
 
-            foreach (string target in _resultsByTarget?.Keys ?? Enumerable.Empty<string>())
+            foreach (string target in _resultsByTarget?.Keys ?? [])
             {
                 if (!targetsToKeep.Contains(target))
                 {
@@ -574,7 +574,7 @@ public void MergeResults(BuildResult results)
             }
 
             // Merge in the results
-            foreach (KeyValuePair<string, TargetResult> targetResult in results._resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
+            foreach (KeyValuePair<string, TargetResult> targetResult in results._resultsByTarget ?? [])
             {
                 // NOTE: I believe that because we only allow results for a given target to be produced and cached once for a given configuration,
                 // we can never receive conflicting results for that target, since the cache and build request manager would always return the
@@ -696,7 +696,7 @@ internal static BuildResult FactoryForDeserialization(ITranslator translator)
         /// </summary>
         internal void CacheIfPossible()
         {
-            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
+            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget ?? [])
             {
                 targetResultPair.Value.CacheItems(ConfigurationId, targetResultPair.Key);
             }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 1a2ba345658..e3a33a5e641 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -804,7 +804,7 @@ private ITaskItem[] GetItemOutputs(TaskPropertyInfo parameter)
 
             if (!(outputs is ITaskItem[] taskItemOutputs))
             {
-                taskItemOutputs = new[] { (ITaskItem)outputs };
+                taskItemOutputs = [(ITaskItem)outputs];
             }
 
             return taskItemOutputs;
@@ -1325,7 +1325,7 @@ private bool InternalSetTaskParameter(
                             parameterName: parameter.Name,
                             propertyName: null,
                             itemType: parameter.Name,
-                            parameterValueAsList ?? new object[] { parameterValue },
+                            parameterValueAsList ?? (object[])[parameterValue],
                             parameter.LogItemMetadata);
                     }
                 }
@@ -1486,7 +1486,7 @@ static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary c
                                     parameterName: parameter.Name,
                                     propertyName: outputTargetName,
                                     itemType: outputTargetName,
-                                    new object[] { outputString },
+                                    (object[])[outputString],
                                     parameter.LogItemMetadata);
                             }
                             else
@@ -1573,7 +1573,7 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                                     parameterName: parameter.Name,
                                     propertyName: outputTargetName,
                                     itemType: outputTargetName,
-                                    new object[] { outputString },
+                                    (object[])[outputString],
                                     parameter.LogItemMetadata);
                             }
                             else
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 4d1ddbfc907..5e25c3e0a48 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -196,7 +196,7 @@ private void RunRegisteredActions<T>(
                     return;
                 }
 
-                configPerRule = new[] { commonConfig };
+                configPerRule = [commonConfig];
             }
             else
             {
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
index e0417966263..8dfbf7aa944 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -81,7 +81,7 @@ internal static EditorConfigFile Parse(string text)
         // dictionary, but we also use a case-insensitive key comparer when doing lookups
         var activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>(StringComparer.OrdinalIgnoreCase);
         string activeSectionName = "";
-        var lines = string.IsNullOrEmpty(text) ? Array.Empty<string>() : text.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);
+        var lines = string.IsNullOrEmpty(text) ? [] : text.Split(["\r\n", "\n"], StringSplitOptions.None);
 
         foreach(var line in lines)
         {
@@ -177,7 +177,7 @@ public Section(string name, ImmutableDictionary<string, string> properties)
 
         /// <summary>
         /// Keys and values for this section. All keys are lower-cased according to the
-        /// EditorConfig specification and keys are compared case-insensitively. 
+        /// EditorConfig specification and keys are compared case-insensitively.
         /// </summary>
         public ImmutableDictionary<string, string> Properties { get; }
     }
diff --git a/src/Build/Construction/ProjectChooseElement.cs b/src/Build/Construction/ProjectChooseElement.cs
index 0ef3acca430..5977dde4d30 100644
--- a/src/Build/Construction/ProjectChooseElement.cs
+++ b/src/Build/Construction/ProjectChooseElement.cs
@@ -92,7 +92,7 @@ public override ElementLocation ConditionLocation
         /// </summary>
         internal static ProjectChooseElement CreateDisconnected(ProjectRootElement containingProject)
         {
-            ErrorUtilities.VerifyThrow(containingProject.Link == null, "External project");
+            ErrorUtilities.VerifyThrow(containingProject.Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.choose);
             return new ProjectChooseElement(element, containingProject);
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index a8619b746fc..a21992f0caa 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -164,7 +164,7 @@ public ProjectElementContainer Parent
 
             internal set
             {
-                ErrorUtilities.VerifyThrow(Link == null, "External project");
+                ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
                 if (value == null)
                 {
                     // We're about to lose the parent. Hijack the field to store the owning PRE.
@@ -261,7 +261,7 @@ public ProjectRootElement ContainingProject
             // ContainingProject is set ONLY when an element is first constructed.
             internal set
             {
-                ErrorUtilities.VerifyThrow(Link == null, "External project");
+                ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
                 ErrorUtilities.VerifyThrowArgumentNull(value, "ContainingProject");
 
                 if (_parent == null)
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 72390d44565..5cf6937f14d 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -388,7 +388,7 @@ internal void AppendParentedChildNoChecks(ProjectElement child)
         {
             ErrorUtilities.VerifyThrow(child.Parent == this, "Expected parent already set");
             ErrorUtilities.VerifyThrow(child.PreviousSibling == null && child.NextSibling == null, "Invalid structure");
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             if (LastChild == null)
             {
@@ -438,7 +438,7 @@ internal static ProjectElementContainer DeepClone(ProjectElementContainer xml, P
 
         private void SetElementAsAttributeValue(ProjectElement child)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             // Assumes that child.ExpressedAsAttribute is true
             Debug.Assert(child.ExpressedAsAttribute, nameof(SetElementAsAttributeValue) + " method requires that " +
@@ -455,7 +455,7 @@ private void SetElementAsAttributeValue(ProjectElement child)
         /// <param name="oldName">The old name for the child element</param>
         internal void UpdateElementName(ProjectElement child, string oldName)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             if (child.ExpressedAsAttribute)
             {
@@ -471,7 +471,7 @@ internal void UpdateElementName(ProjectElement child, string oldName)
         /// <param name="child">A child element which might be represented as an attribute</param>
         internal void UpdateElementValue(ProjectElement child)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             if (child.ExpressedAsAttribute)
             {
@@ -491,7 +491,7 @@ internal void UpdateElementValue(ProjectElement child)
         /// </remarks>
         internal void AddToXml(ProjectElement child)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             if (child.ExpressedAsAttribute)
             {
@@ -597,7 +597,7 @@ private static string GetElementIndentation(XmlElementWithLocation xmlElement)
 
         internal void RemoveFromXml(ProjectElement child)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             if (child.ExpressedAsAttribute)
             {
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 2ab9a1a53d4..0dfb5c1e3fa 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1791,7 +1791,7 @@ internal ProjectMetadataElement CreateMetadataElement(XmlAttributeWithLocation a
         /// </summary>
         internal XmlElementWithLocation CreateElement(string name, ElementLocation location = null)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
             return (XmlElementWithLocation)XmlDocument.CreateElement(name, XmlNamespace, location);
         }
 
@@ -1848,7 +1848,7 @@ internal sealed override void MarkDirty(string reason, string param)
         internal void MarkProjectDirty(Project project)
         {
             ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             // Only bubble this event up if the cache knows about this PRE, which is equivalent to
             // whether this PRE has a path.
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index 984ffe33b31..24118a3ae03 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -212,7 +212,7 @@ public IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations
         {
             get
             {
-                ErrorUtilities.VerifyThrow(Link == null, "External project");
+                ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
                 lock (_locker)
                 {
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 97c8e269da4..1343cf51914 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -406,13 +406,18 @@ internal string GetUniqueProjectName()
 
                     if (ParentProjectGuid != null)
                     {
-                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out ProjectInSolution proj))
+                        ProjectInSolution proj = null;
+                        ProjectInSolution solutionFolder = null;
+
+                        // For the new parser, solution folders are not saved in ProjectsByGuid but in the SolutionFoldersByGuid.
+                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out proj) &&
+                            !ParentSolution.SolutionFoldersByGuid.TryGetValue(ParentProjectGuid, out solutionFolder))
                         {
-                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null, "SubCategoryForSolutionParsingErrors",
+                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null || solutionFolder != null, "SubCategoryForSolutionParsingErrors",
                                 new BuildEventFileInfo(ParentSolution.FullPath), "SolutionParseNestedProjectErrorWithNameAndGuid", ProjectName, ProjectGuid, ParentProjectGuid);
                         }
 
-                        uniqueName = proj.GetUniqueProjectName() + "\\";
+                        uniqueName = (proj != null ? proj.GetUniqueProjectName() : solutionFolder.GetUniqueProjectName()) + "\\";
                     }
 
                     // Now tack on our own project name, and cache it in the ProjectInSolution object for future quick access.
@@ -442,16 +447,19 @@ internal string GetOriginalProjectName()
                     // If this project has a parent SLN folder, first get the full project name for the SLN folder,
                     // and tack on trailing backslash.
                     string projectName = String.Empty;
+                    ProjectInSolution proj = null;
+                    ProjectInSolution solutionFolder = null;
 
                     if (ParentProjectGuid != null)
                     {
-                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out ProjectInSolution parent))
+                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out proj) &&
+                            !ParentSolution.SolutionFoldersByGuid.TryGetValue(ParentProjectGuid, out solutionFolder))
                         {
-                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(parent != null, "SubCategoryForSolutionParsingErrors",
+                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null || solutionFolder != null, "SubCategoryForSolutionParsingErrors",
                                 new BuildEventFileInfo(ParentSolution.FullPath), "SolutionParseNestedProjectErrorWithNameAndGuid", ProjectName, ProjectGuid, ParentProjectGuid);
                         }
 
-                        projectName = parent.GetOriginalProjectName() + "\\";
+                        projectName = (proj != null ? proj.GetOriginalProjectName() : solutionFolder.GetOriginalProjectName()) + "\\";
                     }
 
                     // Now tack on our own project name, and cache it in the ProjectInSolution object for future quick access.
@@ -469,7 +477,7 @@ internal string GetProjectGuidWithoutCurlyBrackets()
                 return null;
             }
 
-            return ProjectGuid.Trim(new char[] { '{', '}' });
+            return ProjectGuid.Trim(['{', '}']);
         }
 
         /// <summary>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 7c8a7dcc867..983cd691d0d 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -6,14 +6,20 @@
 using System.Collections.ObjectModel;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Runtime.InteropServices;
 using System.Security;
 using System.Text;
 using System.Text.Json;
 using System.Text.RegularExpressions;
+using System.Threading;
 using System.Xml;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.VisualStudio.SolutionPersistence;
+using Microsoft.VisualStudio.SolutionPersistence.Model;
+using Microsoft.VisualStudio.SolutionPersistence.Serializer;
 using BuildEventFileInfo = Microsoft.Build.Shared.BuildEventFileInfo;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 using ExceptionUtilities = Microsoft.Build.Shared.ExceptionHandling;
@@ -92,13 +98,16 @@ public sealed class SolutionFile
                                                      // conversion, or in preparation for actually building the solution?
 
         // The list of projects in this SLN, keyed by the project GUID.
-        private Dictionary<string, ProjectInSolution> _projects;
+        private Dictionary<string, ProjectInSolution> _projectsByGuid;
+
+        // The list of solution folders in this SLN, keyed by the folder's GUID.
+        private Dictionary<string, ProjectInSolution> _solutionFoldersByGuid;
 
         // The list of projects in the SLN, in order of their appearance in the SLN.
         private List<ProjectInSolution> _projectsInOrder;
 
         // The list of solution configurations in the solution
-        private List<SolutionConfigurationInSolution> _solutionConfigurations;
+        private Dictionary<string, SolutionConfigurationInSolution> _solutionConfigurationsByFullName;
 
         // cached default configuration name for GetDefaultConfigurationName
         private string _defaultConfigurationName;
@@ -147,13 +156,15 @@ internal SolutionFile()
         internal List<string> SolutionParserErrorCodes { get; } = new List<string>();
 
         /// <summary>
-        /// Returns the actual major version of the parsed solution file
+        /// Returns the actual major version of the parsed solution file.
         /// </summary>
+        /// <remarks>This will return 0 for the new parser because Version is not available.</remarks>
         internal int Version { get; private set; }
 
         /// <summary>
-        /// Returns Visual Studio major version
+        /// Returns Visual Studio major version.
         /// </summary>
+        /// <remarks>This might not be available for the new parser and returns -1.</remarks>
         internal int VisualStudioVersion
         {
             get
@@ -180,16 +191,24 @@ internal int VisualStudioVersion
         /// </summary>
         internal bool ContainsWebDeploymentProjects { get; private set; }
 
+        internal bool UseNewParser => ShouldUseNewParser(_solutionFile);
+
+        internal static bool ShouldUseNewParser(string solutionFile) => FileUtilities.IsSolutionXFilename(solutionFile);
+
         /// <summary>
         /// All projects in this solution, in the order they appeared in the solution file
         /// </summary>
+        /// <remarks>For the new parser, solution folders are no longer included.</remarks>
         public IReadOnlyList<ProjectInSolution> ProjectsInOrder => _projectsInOrder.AsReadOnly();
 
         /// <summary>
         /// The collection of projects in this solution, accessible by their guids as a
         /// string in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form
         /// </summary>
-        public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_projects);
+        /// <remarks>For the new parser, solution folders are no longer included.</remarks>
+        public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_projectsByGuid);
+
+        internal IReadOnlyDictionary<string, ProjectInSolution> SolutionFoldersByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_solutionFoldersByGuid);
 
         /// <summary>
         /// This is the read/write accessor for the solution file which we will parse.  This
@@ -239,7 +258,7 @@ internal string SolutionFileDirectory
         /// <summary>
         /// The list of all full solution configurations (configuration + platform) in this solution
         /// </summary>
-        public IReadOnlyList<SolutionConfigurationInSolution> SolutionConfigurations => _solutionConfigurations.AsReadOnly();
+        public IReadOnlyList<SolutionConfigurationInSolution> SolutionConfigurations => _solutionConfigurationsByFullName.Values.ToList().AsReadOnly();
 
         #endregion
 
@@ -257,11 +276,227 @@ internal bool ProjectShouldBuild(string projectFile)
         /// </summary>
         public static SolutionFile Parse(string solutionFile)
         {
-            var parser = new SolutionFile { FullPath = solutionFile };
-            parser.ParseSolutionFile();
-            return parser;
+            var solution = new SolutionFile { FullPath = solutionFile };
+
+            if (solution.UseNewParser)
+            {
+                solution.ParseUsingNewParser();
+            }
+            else
+            {
+                // Parse the solution file using the old parser
+                solution.ParseSolutionFile();
+            }
+
+            return solution;
+        }
+
+        /// <summary>
+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.
+        /// </summary>
+        internal void ParseUsingNewParser()
+        {
+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);
+
+            if (serializer != null)
+            {
+                try
+                {
+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;
+                    ReadSolutionModel(solutionModel);
+                }
+                catch (Exception ex)
+                {
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(
+                            new BuildEventFileInfo(FullPath),
+                            $"InvalidProjectFile",
+                            ex.ToString());
+                }
+            }
+            else if (serializer == null)
+            {
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(
+                    new BuildEventFileInfo(FullPath),
+                    $"InvalidProjectFile",
+                    $"No solution serializer was found for {FullPath}");
+            }
+        }
+
+        /// <summary>
+        /// Maps <see cref="SolutionModel"/> to <see cref="SolutionFile" />.
+        /// <see cref="SolutionModel"/> is a result of parsing solution using the new parser.
+        /// </summary>
+        /// <param name="solutionModel"></param>
+        private void ReadSolutionModel(SolutionModel solutionModel)
+        {
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), "ReadSolutionModel() got a null or empty solution file.");
+            ErrorUtilities.VerifyThrowInternalRooted(_solutionFile);
+
+            _projectsByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
+            _solutionFoldersByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
+            _projectsInOrder = new List<ProjectInSolution>();
+            ContainsWebProjects = false;
+            Version = 0;
+            _currentLineNumber = 0;
+            _solutionConfigurationsByFullName = new Dictionary<string, SolutionConfigurationInSolution>();
+            _defaultConfigurationName = null;
+            _defaultPlatformName = null;
+
+            _currentVisualStudioVersion = solutionModel.VisualStudioProperties.Version;
+
+            ReadProjects(solutionModel);
+
+            // We need to save the solution folders in order to cache the unique project names and check for duplicates.
+            ReadSolutionFolders(solutionModel);
+
+            if (_solutionFilter != null)
+            {
+                ValidateProjectsInSolutionFilter();
+            }
+
+            CacheUniqueProjectNamesAndCheckForDuplicates();
+        }
+
+        private void ReadProjects(SolutionModel solutionModel)
+        {
+            foreach (SolutionProjectModel projectModel in solutionModel.SolutionProjects)
+            {
+                var proj = new ProjectInSolution(this)
+                {
+                    ProjectName = GetProjectName(projectModel),
+                    RelativePath = projectModel.FilePath,
+                    ProjectGuid = ToProjectGuidFormat(projectModel.Id),
+                };
+
+                // If the project name is empty the new parser throws an error.
+
+                // Validate project relative path
+                ValidateProjectRelativePath(proj);
+
+                SetProjectType(proj, ToProjectGuidFormat(projectModel.TypeId));
+
+                SetProjectDependencies(proj, projectModel);
+
+                SetWebsiteProperties(proj, projectModel);
+
+                // Note: This is corresponds to GlobalSection(NestedProjects) section in sln files.
+                if (projectModel.Parent != null)
+                {
+                    proj.ParentProjectGuid = ToProjectGuidFormat(projectModel.Parent.Id);
+                }
+
+                SetProjectConfigurations(proj, projectModel, solutionModel.BuildTypes, solutionModel.Platforms);
+
+                // Add the project to the collection
+                AddProjectToSolution(proj);
+
+                // If the project is an etp project then parse the etp project file
+                // to get the projects contained in it.
+                if (IsEtpProjectFile(proj.RelativePath))
+                {
+                    ParseEtpProject(proj);
+                }
+            }
+        }
+
+        private string GetProjectName(SolutionProjectModel projectModel)
+            => !string.IsNullOrEmpty(projectModel.DisplayName) ? projectModel.DisplayName : projectModel.ActualDisplayName;
+
+        /// <summary>
+        /// Returns a string from Guid in the format that the old MSBuild solution parser returned.
+        /// </summary>
+        private static string ToProjectGuidFormat(Guid id) => id.ToString("B").ToUpper();
+
+        private void SetProjectDependencies(ProjectInSolution proj, SolutionProjectModel projectModel)
+        {
+            if (projectModel.Dependencies == null)
+            {
+                return;
+            }
+
+            foreach (var dependency in projectModel.Dependencies)
+            {
+                proj.AddDependency(ToProjectGuidFormat(dependency.Id));
+            }
+        }
+
+        private void SetWebsiteProperties(ProjectInSolution proj, SolutionProjectModel projectModel)
+        {
+            SolutionPropertyBag websiteProperties = projectModel?.Properties.FirstOrDefault(p => p.Id == "WebsiteProperties");
+
+            if (websiteProperties is null)
+            {
+                return;
+            }
+
+            foreach (var property in websiteProperties)
+            {
+                ParseAspNetCompilerProperty(proj, property.Key, property.Value);
+            }
+        }
+
+        private void SetProjectConfigurations(
+            ProjectInSolution proj,
+            SolutionProjectModel projectModel,
+            IReadOnlyList<string> buildTypes,
+            IReadOnlyList<string> platforms)
+        {
+            foreach (string solutionBuildType in buildTypes)
+            {
+                foreach (string solutionPlatform in platforms)
+                {
+                    // isBuild represents Build.0. The "Build.0" entry tells us whether to build the project configuration in the given solution configuration
+                    // _ argument represents Deploy.0 which we do not use in the old parser
+                    (string projectBuildType, string projectPlatform, bool isBuild, bool _) = projectModel.GetProjectConfiguration(solutionBuildType, solutionPlatform);
+
+                    if (projectBuildType == null || projectPlatform == null)
+                    {
+                        continue;
+                    }
+
+                    var projectConfiguration = new ProjectConfigurationInSolution(
+                                projectBuildType,
+                                projectPlatform,
+                                isBuild);
+
+                    string configurationName = SolutionConfigurationInSolution.ComputeFullName(solutionBuildType, solutionPlatform);
+
+                    proj.SetProjectConfiguration(configurationName, projectConfiguration);
+
+                    // There are no solution configurations in the new parser. Instead we collect them from each project's configurations.
+                    AddSolutionConfiguration(solutionBuildType, solutionPlatform);
+                }
+            }
         }
 
+        private void ReadSolutionFolders(SolutionModel solutionModel)
+        {
+            foreach (SolutionFolderModel solutionFolderModel in solutionModel.SolutionFolders)
+            {
+                var proj = new ProjectInSolution(this)
+                {
+                    ProjectName = GetSolutionFolderName(solutionFolderModel),
+                    ProjectGuid = ToProjectGuidFormat(solutionFolderModel.Id),
+                    ProjectType = SolutionProjectType.SolutionFolder,
+                };
+
+                // If the project name is empty the new parser throws an error. 
+
+                if (solutionFolderModel.Parent != null)
+                {
+                    proj.ParentProjectGuid = ToProjectGuidFormat(solutionFolderModel.Parent.Id);
+                }
+
+                if (!string.IsNullOrEmpty(proj.ProjectGuid))
+                {
+                    _solutionFoldersByGuid[proj.ProjectGuid] = proj;
+                }
+            }
+        }
+
+        private string GetSolutionFolderName(SolutionFolderModel solutionFolderModel)
+            => !string.IsNullOrEmpty(solutionFolderModel.Name) ? solutionFolderModel.Name : solutionFolderModel.ActualDisplayName;
+
         /// <summary>
         /// Returns "true" if it's a project that's expected to be buildable, or false if it's
         /// not (e.g. a solution folder)
@@ -432,7 +667,12 @@ internal static string ParseSolutionFromSolutionFilter(string solutionFilterFile
         /// </summary>
         internal void AddSolutionConfiguration(string configurationName, string platformName)
         {
-            _solutionConfigurations.Add(new SolutionConfigurationInSolution(configurationName, platformName));
+            var solutionConfiguration = new SolutionConfigurationInSolution(configurationName, platformName);
+
+            if (!_solutionConfigurationsByFullName.ContainsKey(solutionConfiguration.FullName))
+            {
+                _solutionConfigurationsByFullName[solutionConfiguration.FullName] = solutionConfiguration;
+            }
         }
 
         /// <summary>
@@ -497,12 +737,13 @@ internal void ParseSolutionFile()
         /// </summary>
         internal void ParseSolution()
         {
-            _projects = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
+            _projectsByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
+            _solutionFoldersByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
             _projectsInOrder = new List<ProjectInSolution>();
             ContainsWebProjects = false;
             Version = 0;
             _currentLineNumber = 0;
-            _solutionConfigurations = new List<SolutionConfigurationInSolution>();
+            _solutionConfigurationsByFullName = new Dictionary<string, SolutionConfigurationInSolution>();
             _defaultConfigurationName = null;
             _defaultPlatformName = null;
 
@@ -543,24 +784,7 @@ internal void ParseSolution()
 
             if (_solutionFilter != null)
             {
-                HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, _pathComparer);
-                foreach (ProjectInSolution project in _projectsInOrder)
-                {
-                    projectPaths.Add(FileUtilities.FixFilePath(project.RelativePath));
-                }
-                foreach (string project in _solutionFilter)
-                {
-                    if (!projectPaths.Contains(project))
-                    {
-                        ProjectFileErrorUtilities.ThrowInvalidProjectFile(
-                            "SubCategoryForSolutionParsingErrors",
-                            new BuildEventFileInfo(FileUtilities.GetFullPath(project, Path.GetDirectoryName(_solutionFile))),
-                            "SolutionFilterFilterContainsProjectNotInSolution",
-                            _solutionFilterFile,
-                            project,
-                            _solutionFile);
-                    }
-                }
+                ValidateProjectsInSolutionFilter();
             }
 
             if (rawProjectConfigurationsEntries != null)
@@ -568,13 +792,18 @@ internal void ParseSolution()
                 ProcessProjectConfigurationSection(rawProjectConfigurationsEntries);
             }
 
+            CacheUniqueProjectNamesAndCheckForDuplicates();
+        }
+
+        private void CacheUniqueProjectNamesAndCheckForDuplicates()
+        {
             // Cache the unique name of each project, and check that we don't have any duplicates.
             var projectsByUniqueName = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
             var projectsByOriginalName = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (ProjectInSolution proj in _projectsInOrder)
             {
-                // Find the unique name for the project.  This method also caches the unique name,
+                // Find the unique name for the project. This method also caches the unique name,
                 // so it doesn't have to be recomputed later.
                 string uniqueName = proj.GetUniqueProjectName();
 
@@ -645,7 +874,31 @@ internal void ParseSolution()
                     "SolutionParseDuplicateProject",
                     uniqueNameExists ? uniqueName : proj.ProjectName);
             }
-        } // ParseSolutionFile()
+        }
+
+        private void ValidateProjectsInSolutionFilter()
+        {
+            HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, _pathComparer);
+
+            foreach (ProjectInSolution project in _projectsInOrder)
+            {
+                projectPaths.Add(FileUtilities.FixFilePath(project.RelativePath));
+            }
+
+            foreach (string project in _solutionFilter)
+            {
+                if (!projectPaths.Contains(project))
+                {
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(
+                        "SubCategoryForSolutionParsingErrors",
+                        new BuildEventFileInfo(FileUtilities.GetFullPath(project, Path.GetDirectoryName(_solutionFile))),
+                        "SolutionFilterFilterContainsProjectNotInSolution",
+                        _solutionFilterFile,
+                        project,
+                        _solutionFile);
+                }
+            }
+        }
 
         /// <summary>
         /// This method searches the first two lines of the solution file opened by the specified
@@ -1000,7 +1253,7 @@ private void AddProjectToSolution(ProjectInSolution proj)
         {
             if (!String.IsNullOrEmpty(proj.ProjectGuid))
             {
-                _projects[proj.ProjectGuid] = proj;
+                _projectsByGuid[proj.ProjectGuid] = proj;
             }
             _projectsInOrder.Add(proj);
         }
@@ -1179,7 +1432,7 @@ private static void ParseAspNetCompilerProperty(
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
                 if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
-                    string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                    string[] projectReferenceEntries = propertyValue.Split([';'], StringSplitOptions.RemoveEmptyEntries);
 
                     foreach (string projectReferenceEntry in projectReferenceEntries)
                     {
@@ -1264,6 +1517,11 @@ internal void ParseFirstProjectLine(
             // Validate project relative path
             ValidateProjectRelativePath(proj);
 
+            SetProjectType(proj, projectTypeGuid);
+        }
+
+        private void SetProjectType(ProjectInSolution proj, string projectTypeGuid)
+        {
             // Figure out what type of project this is.
             if ((String.Equals(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
                 (String.Equals(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
@@ -1347,7 +1605,7 @@ internal void ParseNestedProjects()
                 string projectGuid = match.Groups["PROPERTYNAME"].Value.Trim();
                 string parentProjectGuid = match.Groups["PROPERTYVALUE"].Value.Trim();
 
-                if (!_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
+                if (!_projectsByGuid.TryGetValue(projectGuid, out ProjectInSolution proj))
                 {
                     ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null, "SubCategoryForSolutionParsingErrors",
                        new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseNestedProjectUndefinedError", projectGuid, parentProjectGuid);
@@ -1407,7 +1665,7 @@ internal void ParseSolutionConfigurations()
 
                 var (configuration, platform) = ParseConfigurationName(fullConfigurationName, FullPath, _currentLineNumber, str);
 
-                _solutionConfigurations.Add(new SolutionConfigurationInSolution(configuration, platform));
+                AddSolutionConfiguration(configuration, platform);
             } while (true);
         }
 
@@ -1495,7 +1753,7 @@ internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawP
                 // Solution folders don't have configurations
                 if (project.ProjectType != SolutionProjectType.SolutionFolder)
                 {
-                    foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionConfigurations)
+                    foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionConfigurationsByFullName.Values)
                     {
                         // The "ActiveCfg" entry defines the active project configuration in the given solution configuration
                         // This entry must be present for every possible solution configuration/project combination.
@@ -1610,7 +1868,7 @@ public string GetDefaultPlatformName()
         /// <returns></returns>
         internal string GetProjectUniqueNameByGuid(string projectGuid)
         {
-            if (_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
+            if (_projectsByGuid.TryGetValue(projectGuid, out ProjectInSolution proj))
             {
                 return proj.GetUniqueProjectName();
             }
@@ -1626,7 +1884,7 @@ internal string GetProjectUniqueNameByGuid(string projectGuid)
         /// <returns></returns>
         internal string GetProjectRelativePathByGuid(string projectGuid)
         {
-            if (_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
+            if (_projectsByGuid.TryGetValue(projectGuid, out ProjectInSolution proj))
             {
                 return proj.RelativePath;
             }
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 33e382771f6..760fcb390f3 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -189,7 +189,7 @@ private SolutionProjectGenerator(
 
             if (targetNames != null)
             {
-                _targetNames = targetNames.Select(i => i.Split(new char[] { ':' }, 2, StringSplitOptions.RemoveEmptyEntries).Last()).ToList();
+                _targetNames = targetNames.Select(i => i.Split([':'], 2, StringSplitOptions.RemoveEmptyEntries).Last()).ToList();
             }
         }
 
@@ -691,12 +691,16 @@ internal static bool WouldProjectBuild(SolutionFile solutionFile, string selecte
         /// </summary>
         private ProjectInstance[] Generate()
         {
-            // Validate against our minimum for upgradable projects
-            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                _solutionFile.Version >= SolutionFile.slnFileMinVersion,
-                "SubCategoryForSolutionParsingErrors",
-                new BuildEventFileInfo(_solutionFile.FullPath),
-                "SolutionParseUpgradeNeeded");
+            // The Version is not available in the new parser.
+            if (!_solutionFile.UseNewParser)
+            {
+                // Validate against our minimum for upgradable projects
+                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
+                    _solutionFile.Version >= SolutionFile.slnFileMinVersion,
+                    "SubCategoryForSolutionParsingErrors",
+                    new BuildEventFileInfo(_solutionFile.FullPath),
+                    "SolutionParseUpgradeNeeded");
+            }
 
             // This is needed in order to make decisions about tools versions such as whether to put a
             // ToolsVersion parameter on <MSBuild> task tags and what MSBuildToolsPath to use when
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 031ce7a01a9..3998a51002f 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -1574,7 +1574,7 @@ public bool Build(string target, IEnumerable<ILogger> loggers)
         public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             // targets may be null, but not an entry within it
-            string[] targets = (target == null) ? null : new[] { target };
+            string[] targets = (target == null) ? null : [target];
 
             return Build(targets, loggers, remoteLoggers);
         }
@@ -2627,7 +2627,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 ImmutableArray<string> includeGlobStrings = includeGlobFragments.Select(f => f.TextFragment).ToImmutableArray();
                 var includeGlob = CompositeGlob.Create(includeGlobFragments.Select(f => f.ToMSBuildGlob()));
 
-                IEnumerable<string> excludeFragmentStrings = Enumerable.Empty<string>();
+                IEnumerable<string> excludeFragmentStrings = [];
                 IMSBuildGlob excludeGlob = null;
 
                 if (!string.IsNullOrEmpty(itemElement.Exclude))
@@ -2638,7 +2638,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                     excludeGlob = excludeItemspec.ToMSBuildGlob();
                 }
 
-                IEnumerable<string> removeFragmentStrings = Enumerable.Empty<string>();
+                IEnumerable<string> removeFragmentStrings = [];
                 IMSBuildGlob removeGlob = null;
 
                 if (removeElementCache.TryGetValue(itemElement.ItemType, out CumulativeRemoveElementData removeItemElement))
@@ -2763,7 +2763,7 @@ private static IEnumerable<ProjectItemElement> GetItemElementsThatMightAffectIte
                         itemElement.RemoveLocation == null);
 
                 // add the include operation that created the project item element
-                return new[] { item.Xml }.Concat(relevantElementsAfterInclude);
+                return [item.Xml, ..relevantElementsAfterInclude];
             }
 
             private static List<ProjectItemElement> GetItemElementsByType(IEnumerable<ProjectItemElement> itemElements, string itemType)
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index d3d70ef98de..8aabe516dc8 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -94,7 +94,7 @@ public string ItemType
         /// This is a read-only collection.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
-        public IEnumerable<ProjectMetadata> Metadata => Link != null ? Link.Metadata : _metadata ?? Enumerable.Empty<ProjectMetadata>();
+        public IEnumerable<ProjectMetadata> Metadata => Link != null ? Link.Metadata : _metadata ?? [];
 
         /// <summary>
         /// Count of metadata on the item definition.
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index eee61cb02f5..cd1c1317069 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -730,7 +730,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, LoggingContext
                 Array.Sort<string>(defaultTasksFiles, StringComparer.OrdinalIgnoreCase);
                 return defaultTasksFiles;
             }
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
diff --git a/src/Build/Definition/ToolsetLocalReader.cs b/src/Build/Definition/ToolsetLocalReader.cs
index 33feee94720..dacbbb6e8b0 100644
--- a/src/Build/Definition/ToolsetLocalReader.cs
+++ b/src/Build/Definition/ToolsetLocalReader.cs
@@ -46,7 +46,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
 
         protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion)
         {
-            return Enumerable.Empty<ToolsetPropertyDefinition>();
+            return [];
         }
 
         protected override Dictionary<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os)
@@ -56,7 +56,7 @@ protected override Dictionary<string, ProjectImportPathMatch> GetProjectImportSe
 
         protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion)
         {
-            return Enumerable.Empty<string>();
+            return [];
         }
     }
 }
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index 0cc16709f31..d81133f3a58 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -11,7 +11,6 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Constants = Microsoft.Build.Internal.Constants;
-using error = Microsoft.Build.Shared.ErrorUtilities;
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 using RegistryException = Microsoft.Build.Exceptions.RegistryException;
 using RegistryKeyWrapper = Microsoft.Build.Internal.RegistryKeyWrapper;
@@ -63,7 +62,7 @@ internal ToolsetRegistryReader(PropertyDictionary<ProjectPropertyInstance> envir
         internal ToolsetRegistryReader(PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, RegistryKeyWrapper msbuildRegistryWrapper)
             : base(environmentProperties, globalProperties)
         {
-            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, nameof(msbuildRegistryWrapper));
+            ErrorUtilities.VerifyThrowArgumentNull(msbuildRegistryWrapper, nameof(msbuildRegistryWrapper));
 
             _msbuildRegistryWrapper = msbuildRegistryWrapper;
         }
@@ -75,7 +74,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> ToolsVersions
         {
             get
             {
-                string[] toolsVersionNames = Array.Empty<string>();
+                string[] toolsVersionNames = [];
                 try
                 {
                     RegistryKeyWrapper subKey = null;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 3152d850174..b1d25946256 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -2152,7 +2152,7 @@ private static Stack<TransformFunction<S>> PrepareTransformStackFromMatch<S>(IEl
                     if (functionName == null)
                     {
                         functionName = "ExpandQuotedExpressionFunction";
-                        arguments = new string[] { function };
+                        arguments = [function];
                     }
                     else if (argumentsExpression != null)
                     {
@@ -3283,7 +3283,7 @@ internal Function(
                 _methodMethodName = methodName;
                 if (arguments == null)
                 {
-                    _arguments = Array.Empty<string>();
+                    _arguments = [];
                 }
                 else
                 {
@@ -3548,11 +3548,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             // include $(MSBuildThisFileDirectory) as a parameter.
                             string startingDirectory = String.IsNullOrWhiteSpace(elementLocation.File) ? String.Empty : Path.GetDirectoryName(elementLocation.File);
 
-                            args = new[]
-                            {
-                                args[0],
-                                startingDirectory,
-                            };
+                            args = [args[0], startingDirectory];
                         }
                     }
 
@@ -3600,8 +3596,17 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             // otherwise there is the potential of running a function twice!
                             try
                             {
-                                // First use InvokeMember using the standard binder - this will match and coerce as needed
-                                functionResult = _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture);
+                                // If there are any out parameters, try to figure out their type and create defaults for them as appropriate before calling the method.
+                                if (args.Any(a => "out _".Equals(a)))
+                                {
+                                    IEnumerable<MethodInfo> methods = _receiverType.GetMethods(_bindingFlags).Where(m => m.Name.Equals(_methodMethodName) && m.GetParameters().Length == args.Length);
+                                    functionResult = GetMethodResult(objectInstance, methods, args, 0);
+                                }
+                                else
+                                {
+                                    // If there are no out parameters, use InvokeMember using the standard binder - this will match and coerce as needed
+                                    functionResult = _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture);
+                                }
                             }
                             // If we're invoking a method, then there are deeper attempts that can be made to invoke the method.
                             // If not, we were asked to get a property or field but found that we cannot locate it. No further argument coercion is possible, so throw.
@@ -3697,6 +3702,48 @@ private bool TryExecuteWellKnownFunctionWithPropertiesParam(IPropertyProvider<T>
                 return false;
             }
 
+            private object GetMethodResult(object objectInstance, IEnumerable<MethodInfo> methods, object[] args, int index)
+            {
+                for (int i = index; i < args.Length; i++)
+                {
+                    if (args[i].Equals("out _"))
+                    {
+                        object toReturn = null;
+                        foreach (MethodInfo method in methods)
+                        {
+                            Type t = method.GetParameters()[i].ParameterType;
+                            args[i] = t.IsValueType ? Activator.CreateInstance(t) : null;
+                            object currentReturnValue = GetMethodResult(objectInstance, methods, args, i + 1);
+                            if (currentReturnValue is not null)
+                            {
+                                if (toReturn is null)
+                                {
+                                    toReturn = currentReturnValue;
+                                }
+                                else if (!toReturn.Equals(currentReturnValue))
+                                {
+                                    // There were multiple methods that seemed viable and gave different results. We can't differentiate between them so throw.
+                                    ErrorUtilities.ThrowArgument("CouldNotDifferentiateBetweenCompatibleMethods", _methodMethodName, args.Length);
+                                    return null;
+                                }
+                            }
+                        }
+
+                        return toReturn;
+                    }
+                }
+
+                try
+                {
+                    return _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture) ?? "null";
+                }
+                catch (Exception)
+                {
+                    // This isn't a viable option, but perhaps another set of parameters will work.
+                    return null;
+                }
+            }
+
             /// <summary>
             /// Shortcut to avoid calling into binding if we recognize some most common functions.
             /// Binding is expensive and throws first-chance MissingMethodExceptions, which is
@@ -5157,7 +5204,7 @@ private static void ConstructIndexerFunction(string expressionFunction, IElement
                 // If there are no arguments, then just create an empty array
                 if (String.IsNullOrEmpty(argumentsContent))
                 {
-                    functionArguments = Array.Empty<string>();
+                    functionArguments = [];
                 }
                 else
                 {
@@ -5231,7 +5278,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                     // It may be that there are '()' but no actual arguments content
                     if (argumentStartIndex == expressionFunction.Length - 1)
                     {
-                        functionArguments = Array.Empty<string>();
+                        functionArguments = [];
                     }
                     else
                     {
@@ -5241,7 +5288,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                         // If there are no arguments, then just create an empty array
                         if (string.IsNullOrEmpty(argumentsContent))
                         {
-                            functionArguments = Array.Empty<string>();
+                            functionArguments = [];
                         }
                         else
                         {
@@ -5264,7 +5311,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                         nextMethodIndex = indexerIndex;
                     }
 
-                    functionArguments = Array.Empty<string>();
+                    functionArguments = [];
 
                     if (nextMethodIndex > 0)
                     {
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 4a4a183d24f..da988bfdeaf 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -34,7 +34,7 @@ namespace Microsoft.Build.Evaluation
     internal static class IntrinsicFunctions
     {
 #pragma warning disable CA1416 // Platform compatibility: we'll only use this on Windows
-        private static readonly object[] DefaultRegistryViews = new object[] { RegistryView.Default };
+        private static readonly object[] DefaultRegistryViews = [RegistryView.Default];
 #pragma warning restore CA1416
 
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index ce2c28494ff..30400c410f6 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -369,7 +369,7 @@ public IList<string> IntersectsWith(IReadOnlyDictionary<string, ItemDataCollecti
                 }
             }
 
-            return matches ?? Array.Empty<string>();
+            return matches ?? [];
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
index cdca2c31156..a1e8dc7f30d 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
@@ -65,7 +65,7 @@ protected static string GetElementOrConditionText(string description, Evaluation
             var outerXml = description;
             outerXml = outerXml.Replace(@"xmlns=""http://schemas.microsoft.com/developer/msbuild/2003""", "");
 
-            var newLineIndex = outerXml.IndexOfAny(new[] { '\r', '\n' });
+            var newLineIndex = outerXml.IndexOfAny(['\r', '\n']);
             return newLineIndex == -1 ? outerXml : outerXml.Remove(newLineIndex);
         }
 
@@ -75,12 +75,8 @@ protected static string GetElementOrConditionText(string description, Evaluation
         protected void AppendDefaultHeaderWithSeparator(StringBuilder stringBuilder, string separator)
         {
             stringBuilder.AppendLine(
-                string.Join(separator,
-                    new[]
-                    {
-                        "Id", "ParentId", "Pass", "File", "Line #", "Expression", "Inc (ms)", "Inc (%)", "Exc (ms)",
-                        "Exc (%)", "#", "Kind", "Bug"
-                    }));
+                string.Join(separator, "Id", "ParentId", "Pass", "File", "Line #", "Expression", "Inc (ms)", "Inc (%)", "Exc (ms)",
+                        "Exc (%)", "#", "Kind", "Bug"));
         }
 
         /// <summary>
diff --git a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
index d4b6a316964..9d259bda8c6 100644
--- a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
+++ b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
@@ -95,10 +95,10 @@ private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string sea
 #endif
             IEnumerable<string> directories = includeDirectories
                 ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)
-                : Enumerable.Empty<string>();
+                : [];
             IEnumerable<string> files = includeFiles
                 ? _directoryCache.EnumerateFiles(path, searchPattern, predicate, transform)
-                : Enumerable.Empty<string>();
+                : [];
 
             return Enumerable.Concat(directories, files);
         }
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index da261545e94..e1173e46681 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -44,11 +44,7 @@ internal sealed class ProjectInterpretation
 
         public static ProjectInterpretation Instance = new ProjectInterpretation();
 
-        private ProjectInterpretation()
-        {
-        }
-
-        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] { (GlobalPropertiesModifier)ProjectReferenceGlobalPropertiesModifier }.ToImmutableList();
+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = [(GlobalPropertiesModifier)ProjectReferenceGlobalPropertiesModifier];
 
         internal enum ProjectType
         {
@@ -298,7 +294,7 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
                     project: outerBuild,
                     itemType: InnerBuildReferenceItemName,
                     includeEscaped: outerBuild.FullPath,
-                    directMetadata: new[] { new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}") },
+                    directMetadata: [new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")],
                     definingFileEscaped: outerBuild.FullPath);
             }
         }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 29b00d51996..1eacb69a5d0 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -2151,7 +2151,7 @@ public bool Build(string target, IEnumerable<ILogger> loggers)
         /// </remarks>
         public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
-            string[] targets = (target == null) ? Array.Empty<string>() : new string[] { target };
+            string[] targets = (target == null) ? [] : [target];
 
             return Build(targets, loggers, remoteLoggers);
         }
@@ -2574,45 +2574,82 @@ internal static ProjectInstance[] LoadSolutionForBuild(
             // we should be generating a 4.0+ or a 3.5-style wrapper project based on the version of the solution.
             else
             {
-                string solutionFile = projectFile;
-                if (FileUtilities.IsSolutionFilterFilename(projectFile))
-                {
-                    solutionFile = SolutionFile.ParseSolutionFromSolutionFilter(projectFile, out _);
-                }
-                SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFile, out int solutionVersion, out int visualStudioVersion);
+                projectInstances = CalculateToolsVersionAndGenerateSolutionWrapper(
+                    projectFile,
+                    buildParameters,
+                    loggingService,
+                    projectBuildEventContext,
+                    globalProperties,
+                    isExplicitlyLoaded,
+                    targetNames,
+                    sdkResolverService,
+                    submissionId);
+            }
+
+            return projectInstances;
+        }
+
+        private static ProjectInstance[] CalculateToolsVersionAndGenerateSolutionWrapper(
+            string projectFile,
+            BuildParameters buildParameters,
+            ILoggingService loggingService,
+            BuildEventContext projectBuildEventContext,
+            Dictionary<string, string> globalProperties,
+            bool isExplicitlyLoaded,
+            IReadOnlyCollection<string> targetNames,
+            ISdkResolverService sdkResolverService,
+            int submissionId)
+        {
+            string solutionFileName = projectFile;
+
+            if (FileUtilities.IsSolutionFilterFilename(projectFile))
+            {
+                solutionFileName = SolutionFile.ParseSolutionFromSolutionFilter(projectFile, out _);
+            }
 
-                // If we get to this point, it's because it's a valid version.  Map the solution version
-                // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old
-                // engine to generate the solution wrapper.
-                if (solutionVersion <= 9) /* Whidbey or before */
+            if (SolutionFile.ShouldUseNewParser(solutionFileName))
+            {
+                // For the new parser we use Current tools version.
+                return GenerateSolutionWrapper(projectFile, globalProperties, "Current", loggingService, projectBuildEventContext, targetNames, sdkResolverService, submissionId);
+            }
+
+            // For the old parser we try to make a best-effort guess based on the version of the solution.
+            string toolsVersion = null;
+            ProjectInstance[] projectInstances = null;
+
+            SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFileName, out int solutionVersion, out int visualStudioVersion);
+
+            // If we get to this point, it's because it's a valid version.  Map the solution version
+            // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old
+            // engine to generate the solution wrapper.
+            if (solutionVersion <= 9) /* Whidbey or before */
+            {
+                loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedOldSolutionVersion", "2.0", solutionVersion);
+                projectInstances = GenerateSolutionWrapperUsingOldOM(projectFile, globalProperties, "2.0", buildParameters.ProjectRootElementCache, buildParameters, loggingService, projectBuildEventContext, isExplicitlyLoaded, sdkResolverService, submissionId);
+            }
+            else if (solutionVersion == 10) /* Orcas */
+            {
+                loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedOldSolutionVersion", "3.5", solutionVersion);
+                projectInstances = GenerateSolutionWrapperUsingOldOM(projectFile, globalProperties, "3.5", buildParameters.ProjectRootElementCache, buildParameters, loggingService, projectBuildEventContext, isExplicitlyLoaded, sdkResolverService, submissionId);
+            }
+            else
+            {
+                if ((solutionVersion == 11) || (solutionVersion == 12 && visualStudioVersion == 0)) /* Dev 10 and Dev 11 */
                 {
-                    loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedOldSolutionVersion", "2.0", solutionVersion);
-                    projectInstances = GenerateSolutionWrapperUsingOldOM(projectFile, globalProperties, "2.0", buildParameters.ProjectRootElementCache, buildParameters, loggingService, projectBuildEventContext, isExplicitlyLoaded, sdkResolverService, submissionId);
+                    toolsVersion = "4.0";
                 }
-                else if (solutionVersion == 10) /* Orcas */
+                else /* Dev 12 and above */
                 {
-                    loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedOldSolutionVersion", "3.5", solutionVersion);
-                    projectInstances = GenerateSolutionWrapperUsingOldOM(projectFile, globalProperties, "3.5", buildParameters.ProjectRootElementCache, buildParameters, loggingService, projectBuildEventContext, isExplicitlyLoaded, sdkResolverService, submissionId);
+                    toolsVersion = visualStudioVersion.ToString(CultureInfo.InvariantCulture) + ".0";
                 }
-                else
-                {
-                    if ((solutionVersion == 11) || (solutionVersion == 12 && visualStudioVersion == 0)) /* Dev 10 and Dev 11 */
-                    {
-                        toolsVersion = "4.0";
-                    }
-                    else /* Dev 12 and above */
-                    {
-                        toolsVersion = visualStudioVersion.ToString(CultureInfo.InvariantCulture) + ".0";
-                    }
 
-                    string toolsVersionToUse = Utilities.GenerateToolsVersionToUse(
-                        explicitToolsVersion: null,
-                        toolsVersionFromProject: FileUtilities.IsSolutionFilterFilename(projectFile) ? "Current" : toolsVersion,
-                        getToolset: buildParameters.GetToolset,
-                        defaultToolsVersion: Constants.defaultSolutionWrapperProjectToolsVersion,
-                        usingDifferentToolsVersionFromProjectFile: out _);
-                    projectInstances = GenerateSolutionWrapper(projectFile, globalProperties, toolsVersionToUse, loggingService, projectBuildEventContext, targetNames, sdkResolverService, submissionId);
-                }
+                string toolsVersionToUse = Utilities.GenerateToolsVersionToUse(
+                    explicitToolsVersion: null,
+                    toolsVersionFromProject: FileUtilities.IsSolutionFilterFilename(projectFile) ? "Current" : toolsVersion,
+                    getToolset: buildParameters.GetToolset,
+                    defaultToolsVersion: Constants.defaultSolutionWrapperProjectToolsVersion,
+                    usingDifferentToolsVersionFromProjectFile: out _);
+                projectInstances = GenerateSolutionWrapper(projectFile, globalProperties, toolsVersionToUse, loggingService, projectBuildEventContext, targetNames, sdkResolverService, submissionId);
             }
 
             return projectInstances;
@@ -2647,7 +2684,7 @@ internal bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<
 
             if (targets == null)
             {
-                targets = Array.Empty<string>();
+                targets = [];
             }
 
             BuildResult results;
@@ -2962,7 +2999,7 @@ private static ProjectInstance[] GenerateSolutionWrapperUsingOldOM(
                 };
                 ProjectInstance instance = new(projectRootElement, globalProperties, toolsVersion, buildParameters, loggingService, projectBuildEventContext, sdkResolverService, submissionId);
 
-                return new[] { instance };
+                return [instance];
             }
         }
 
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 2051107c8bd..d1d7ac3c678 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -122,7 +122,7 @@ public int MetadataCount
         /// <summary>
         /// Names of all metadata on this item definition
         /// </summary>
-        public IEnumerable<string> MetadataNames => _metadata == null ? Enumerable.Empty<string>() : _metadata.Keys;
+        public IEnumerable<string> MetadataNames => _metadata == null ? [] : _metadata.Keys;
 
         /// <summary>
         /// Implementation of IKeyed exposing the item type, so these
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index ce19ec7872f..ec5c67f344e 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1063,7 +1063,7 @@ public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
                 }
                 else
                 {
-                    return Enumerable.Empty<KeyValuePair<string, string>>();
+                    return [];
                 }
             }
 
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 20f381dda93..6130bc25264 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -483,9 +483,9 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
                 }
                 else
                 {
-                    exceptionMessageArgs = new string[] { _taskType.Type.Name,
+                    exceptionMessageArgs = [_taskType.Type.Name,
                         AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly),
-                        string.Empty };
+                        string.Empty];
                 }
 
                 _taskLoggingContext.LogFatalError(taskHostTaskComplete.TaskException, new BuildEventFileInfo(_taskLocation), taskHostTaskComplete.TaskExceptionMessage, taskHostTaskComplete.TaskExceptionMessageArgs);
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 598819b3cd4..3618f4c1b14 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -664,7 +664,7 @@ private IEnumerable<RegisteredTaskRecord> GetRelevantOrderedRegistrations(Regist
 
             if (exactMatchRequired)
             {
-                return Enumerable.Empty<RegisteredTaskRecord>();
+                return [];
             }
 
             // look through all task declarations for partial matches
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index afda13dd6e5..59a7a4ef914 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -46,5 +46,6 @@ public enum BinaryLogRecordKind
         BuildCheckTracing,
         BuildCheckAcquisition,
         BuildSubmissionStarted,
+        BuildCanceled,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 0e07217a267..be4eaa2288d 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -78,6 +78,8 @@ public sealed class BinaryLogger : ILogger
         // version 23:
         //    - new record kinds: BuildCheckMessageEvent, BuildCheckWarningEvent, BuildCheckErrorEvent,
         //    BuildCheckTracingEvent, BuildCheckAcquisitionEvent, BuildSubmissionStartedEvent
+        // version 24:
+        //    - new record kind: BuildCanceledEventArgs
 
         // MAKE SURE YOU KEEP BuildEventArgsWriter AND StructuredLogViewer.BuildEventArgsWriter IN SYNC WITH THE CHANGES ABOVE.
         // Both components must stay in sync to avoid issues with logging or event handling in the products.
@@ -88,7 +90,7 @@ public sealed class BinaryLogger : ILogger
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 23;
+        internal const int FileFormatVersion = 24;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index dc7b097be1a..9fd2cd14812 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -243,10 +243,11 @@ e is FormatException ||
                     (e is EndOfStreamException && _readStream.BytesCountAllowedToReadRemaining <= 0))
                 {
                     hasError = true;
-
+                    int localSerializedEventLength = serializedEventLength;
+                    Exception localException = e;
                     string ErrorFactory() =>
                         ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_ReaderMismatchedRead",
-                            _recordNumber, serializedEventLength, e.GetType(), e.Message) + (_skipUnknownEvents
+                            _recordNumber, localSerializedEventLength, localException.GetType(), localException.Message) + (_skipUnknownEvents
                             ? " " + ResourceUtilities.GetResourceString("Binlog_ReaderSkippingRecord")
                             : string.Empty);
 
@@ -255,9 +256,11 @@ string ErrorFactory() =>
 
                 if (result == null && !hasError)
                 {
+                    int localSerializedEventLength = serializedEventLength;
+                    BinaryLogRecordKind localRecordKind = recordKind;
                     string ErrorFactory() =>
                         ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_ReaderUnknownType",
-                            _recordNumber, serializedEventLength, recordKind) + (_skipUnknownEvents
+                            _recordNumber, localSerializedEventLength, localRecordKind) + (_skipUnknownEvents
                             ? " " + ResourceUtilities.GetResourceString("Binlog_ReaderSkippingRecord")
                             : string.Empty);
 
@@ -266,9 +269,10 @@ string ErrorFactory() =>
 
                 if (_readStream.BytesCountAllowedToReadRemaining > 0)
                 {
+                    int localSerializedEventLength = serializedEventLength;
                     string ErrorFactory() => ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
-                        "Binlog_ReaderUnderRead", _recordNumber, serializedEventLength,
-                        serializedEventLength - _readStream.BytesCountAllowedToReadRemaining);
+                        "Binlog_ReaderUnderRead", _recordNumber, localSerializedEventLength,
+                        localSerializedEventLength - _readStream.BytesCountAllowedToReadRemaining);
 
                     HandleError(ErrorFactory, _skipUnknownEventParts, ReaderErrorType.UnknownEventData, recordKind);
                 }
@@ -325,6 +329,7 @@ void HandleError(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType re
                 BinaryLogRecordKind.BuildCheckError => ReadBuildErrorEventArgs(),
                 BinaryLogRecordKind.BuildCheckTracing => ReadBuildCheckTracingEventArgs(),
                 BinaryLogRecordKind.BuildCheckAcquisition => ReadBuildCheckAcquisitionEventArgs(),
+                BinaryLogRecordKind.BuildCanceled => ReadBuildCanceledEventArgs(),
                 _ => null
             };
 
@@ -634,8 +639,8 @@ private BuildEventArgs ReadBuildSubmissionStartedEventArgs()
             IDictionary<string, string>? globalProperties = null;
             globalProperties = ReadStringDictionary() ?? new Dictionary<string, string>();
 
-            var entryProjectsFullPath = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
-            var targetNames = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
+            var entryProjectsFullPath = ReadStringIEnumerable() ?? [];
+            var targetNames = ReadStringIEnumerable() ?? [];
             var flags = (BuildRequestDataFlags)ReadInt32();
             var submissionId = ReadInt32();
 
@@ -1275,6 +1280,15 @@ private BuildEventArgs ReadBuildCheckAcquisitionEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadBuildCanceledEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var e = new BuildCanceledEventArgs(fields.Message);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         /// <summary>
         /// For errors and warnings these 8 fields are written out explicitly
         /// (their presence is not marked as a bit in the flags). So we have to
@@ -1427,9 +1441,9 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
             }
         }
 
-        private IEnumerable? ReadPropertyList()
+        private IList<DictionaryEntry>? ReadPropertyList()
         {
-            var properties = ReadStringDictionary();
+            IDictionary<string, string>? properties = ReadStringDictionary();
             if (properties == null || properties.Count == 0)
             {
                 return null;
@@ -1520,7 +1534,7 @@ private ITaskItem ReadTaskItem()
             return taskItem;
         }
 
-        private IEnumerable? ReadProjectItems()
+        private IList<DictionaryEntry>? ReadProjectItems()
         {
             IList<DictionaryEntry>? list;
 
@@ -1602,7 +1616,7 @@ private ITaskItem ReadTaskItem()
             return list;
         }
 
-        private IEnumerable? ReadTaskItemList()
+        private IList<ITaskItem>? ReadTaskItemList()
         {
             int count = ReadInt32();
             if (count == 0)
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index f140698b70a..77121b29b21 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -187,6 +187,7 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     BuildSubmissionStarted
                     BuildStarted
                     BuildFinished
+                    BuildCanceled
                     ProjectEvaluationStarted
                     ProjectEvaluationFinished
                 BuildError
@@ -215,6 +216,7 @@ private BinaryLogRecordKind WriteCore(BuildEventArgs e)
                 case BuildSubmissionStartedEventArgs buildSubmissionStarted: return Write(buildSubmissionStarted);
                 case BuildStartedEventArgs buildStarted: return Write(buildStarted);
                 case BuildFinishedEventArgs buildFinished: return Write(buildFinished);
+                case BuildCanceledEventArgs buildCanceled: return Write(buildCanceled);
                 case ProjectEvaluationStartedEventArgs projectEvaluationStarted: return Write(projectEvaluationStarted);
                 case ProjectEvaluationFinishedEventArgs projectEvaluationFinished: return Write(projectEvaluationFinished);
                 case BuildCheckTracingEventArgs buildCheckTracing: return Write(buildCheckTracing);
@@ -307,6 +309,13 @@ private BinaryLogRecordKind Write(BuildFinishedEventArgs e)
             return BinaryLogRecordKind.BuildFinished;
         }
 
+        private BinaryLogRecordKind Write(BuildCanceledEventArgs e)
+        {
+            WriteBuildEventArgsFields(e);
+
+            return BinaryLogRecordKind.BuildCanceled;
+        }
+
         private BinaryLogRecordKind Write(ProjectEvaluationStartedEventArgs e)
         {
             WriteBuildEventArgsFields(e, writeMessage: false);
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
index d8eca6c3848..8a0cc2ed489 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
@@ -59,30 +59,28 @@ public static long SkipBytes(this Stream stream, long bytesCount, byte[] buffer)
 
         public static byte[] ReadToEnd(this Stream stream)
         {
-            if (stream.TryGetLength(out long length))
-            {
-                using BinaryReader reader = new(stream, Encoding.UTF8, leaveOpen: true);
-
-                return reader.ReadBytes((int)length);
-            }
-
-            using var ms = new MemoryStream();
+            MemoryStream ms = stream.TryGetLength(out long length) && length <= int.MaxValue ? new((int)length) : new();
             stream.CopyTo(ms);
-            return ms.ToArray();
+            byte[] buffer = ms.GetBuffer();
+            return buffer.Length == ms.Length ? buffer : ms.ToArray();
         }
 
         public static bool TryGetLength(this Stream stream, out long length)
         {
             try
             {
-                length = stream.Length;
-                return true;
+                if (stream.CanSeek)
+                {
+                    length = stream.Length;
+                    return true;
+                }
             }
             catch (NotSupportedException)
             {
-                length = 0;
-                return false;
             }
+
+            length = 0;
+            return false;
         }
 
         public static Stream ToReadableSeekableStream(this Stream stream)
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
index ff5caf9bfdf..8c6e0c6e2b8 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
@@ -3,6 +3,8 @@
 
 using System;
 using System.IO;
+using System.Threading;
+using System.Threading.Tasks;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
@@ -40,7 +42,8 @@ public SubStream(Stream stream, long length)
 
         public override long Position { get => _position; set => throw new NotImplementedException(); }
 
-        public override void Flush() { }
+        public override void Flush() => _stream.Flush();
+        public override Task FlushAsync(CancellationToken cancellationToken) => _stream.FlushAsync(cancellationToken);
         public override int Read(byte[] buffer, int offset, int count)
         {
             count = Math.Min((int)Math.Max(Length - _position, 0), count);
@@ -48,6 +51,50 @@ public override int Read(byte[] buffer, int offset, int count)
             _position += read;
             return read;
         }
+
+        public override int ReadByte()
+        {
+            if (Length - _position > 0)
+            {
+                int value = _stream.ReadByte();
+                if (value >= 0)
+                {
+                    _position++;
+                    return value;
+                }
+            }
+
+            return -1;
+        }
+
+        public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
+        {
+            count = Math.Min((int)Math.Max(Length - _position, 0), count);
+#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            int read = await _stream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(false);
+#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            _position += read;
+            return read;
+        }
+
+#if NET
+        public override int Read(Span<byte> buffer)
+        {
+            buffer = buffer.Slice(0, Math.Min((int)Math.Max(Length - _position, 0), buffer.Length));
+            int read = _stream.Read(buffer);
+            _position += read;
+            return read;
+        }
+
+        public override async ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default)
+        {
+            buffer = buffer.Slice(0, Math.Min((int)Math.Max(Length - _position, 0), buffer.Length));
+            int read = await _stream.ReadAsync(buffer, cancellationToken).ConfigureAwait(false);
+            _position += read;
+            return read;
+        }
+#endif
+
         public override long Seek(long offset, SeekOrigin origin) => throw new NotImplementedException();
         public override void SetLength(long value) => throw new NotImplementedException();
         public override void Write(byte[] buffer, int offset, int count) => throw new NotImplementedException();
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
index 4dd9afa0300..ea3fcb3c9c7 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
@@ -3,6 +3,8 @@
 
 using System;
 using System.IO;
+using System.Threading;
+using System.Threading.Tasks;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
@@ -75,6 +77,11 @@ public override void Flush()
             _stream.Flush();
         }
 
+        public override Task FlushAsync(CancellationToken cancellationToken)
+        {
+            return _stream.FlushAsync(cancellationToken);
+        }
+
         public override int Read(byte[] buffer, int offset, int count)
         {
             if (_position + count > _maxAllowedPosition)
@@ -87,6 +94,61 @@ public override int Read(byte[] buffer, int offset, int count)
             return cnt;
         }
 
+        public override int ReadByte()
+        {
+            if (_position + 1 <= _maxAllowedPosition)
+            {
+                int value = _stream.ReadByte();
+                if (value >= 0)
+                {
+                    _position++;
+                    return value;
+                }
+            }
+
+            return -1;
+        }
+
+        public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
+        {
+            if (_position + count > _maxAllowedPosition)
+            {
+                count = (int)(_maxAllowedPosition - _position);
+            }
+
+#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            int cnt = await _stream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(false);
+#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            _position += cnt;
+            return cnt;
+        }
+
+#if NET
+        public override int Read(Span<byte> buffer)
+        {
+            if (_position + buffer.Length > _maxAllowedPosition)
+            {
+                buffer = buffer.Slice(0, (int)(_maxAllowedPosition - _position));
+            }
+
+            int cnt = _stream.Read(buffer);
+            _position += cnt;
+            return cnt;
+        }
+
+        public override async ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default)
+        {
+            if (_position + buffer.Length > _maxAllowedPosition)
+            {
+                buffer = buffer.Slice(0, (int)(_maxAllowedPosition - _position));
+            }
+
+            int cnt = await _stream.ReadAsync(buffer, cancellationToken).ConfigureAwait(false);
+            _position += cnt;
+            return cnt;
+        }
+#endif
+
         public override long Seek(long offset, SeekOrigin origin)
         {
             if (origin != SeekOrigin.Current)
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index de9c04f2c57..dd73599bec2 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -146,7 +146,7 @@ internal string[] ProjectCallStackFromProject(BuildEventContext e)
             // or the event is raised before the project started event
             if (startedEvent == null)
             {
-                return Array.Empty<string>();
+                return [];
             }
 
             List<ProjectStartedEventMinimumFields> projectStackTrace = GetProjectCallStack(e);
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index 77c521d5452..b80dcf8cf0e 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -297,19 +297,12 @@ private void GenerateProfilerReport()
 
                 Console.WriteLine(ResourceUtilities.GetResourceString("WritingProfilerReportDone"));
             }
-            catch (DirectoryNotFoundException ex)
-            {
-                Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ErrorWritingProfilerReport", ex.Message));
-            }
-            catch (IOException ex)
-            {
-                Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ErrorWritingProfilerReport", ex.Message));
-            }
-            catch (UnauthorizedAccessException ex)
-            {
-                Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ErrorWritingProfilerReport", ex.Message));
-            }
-            catch (SecurityException ex)
+            catch (Exception ex) when (ex is
+                DirectoryNotFoundException or
+                IOException or
+                UnauthorizedAccessException or
+                SecurityException or
+                ArgumentException)
             {
                 Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ErrorWritingProfilerReport", ex.Message));
             }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 24471d364ba..9a39ec6bad7 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -30,6 +30,7 @@
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
+    <PackageReference Include="Microsoft.VisualStudio.SolutionPersistence" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
 
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
@@ -38,7 +39,7 @@
 
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
   </ItemGroup>
-
+  
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildSourceOnly)' != 'true'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
   </ItemGroup>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 34a4bb82c85..5829ce6fad9 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -604,6 +604,9 @@
       LOCALIZATION: "{0}" is the expression that was bad. "{1}" is a message from an FX exception that describes why the expression is bad.
     </comment>
   </data>
+  <data name="CouldNotDifferentiateBetweenCompatibleMethods">
+    <value>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</value>
+  </data>
   <data name="InvalidFunctionPropertyExpression" xml:space="preserve">
     <value>MSB4184: The expression "{0}" cannot be evaluated. {1}</value>
     <comment>{StrBegin="MSB4184: "}
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 49c8424d99a..e8d7f67f12a 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -287,6 +287,11 @@
         <target state="translated">Nepoda≈ôilo se naj√≠t zadan√© sestaven√≠ vlastn√≠ kontroly: {0}. Zkontrolujte pros√≠m, jestli existuje.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Nepoda≈ôilo se naƒç√≠st typ vlastn√≠ kontroly: {0} ze sestaven√≠: {1}. Ujistƒõte se, ≈æe dƒõd√≠ z√°kladn√≠ t≈ô√≠du Microsoft.Build.Experimental.BuildCheck.Check. Pokud se nem√° jednat o vlastn√≠ kontrolu, nemƒõl by b√Ωt exponovan√Ω. Dal≈°√≠ informace: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index db307f01220..028fd604138 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -287,6 +287,11 @@
         <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Pr√ºfassembly: {0}. √úberpr√ºfen Sie, ob sie vorhanden ist.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Fehler beim Laden des benutzerdefinierten Pr√ºftyps ‚Äû{0}‚Äú aus der Assembly: {1}. Stellen Sie sicher, dass sie die Basisklasse ‚ÄûMicrosoft.Build.Experimental.BuildCheck.Check‚Äú erbt. Wenn es sich nicht um eine benutzerdefinierte √úberpr√ºfung handelt, sollte sie nicht verf√ºgbar gemacht werden. Weitere Informationen: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 53e2125399c..86de00da3ed 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -287,6 +287,11 @@
         <target state="translated">No se pudo encontrar el ensamblado de comprobaci√≥n personalizado especificado: "{0}". Compruebe si existe.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">No se pudo cargar el tipo de comprobaci√≥n personalizada: "{0}" desde el ensamblado: "{1}". Aseg√∫rese de que hereda la clase base Microsoft.Build.Experimental.BuildCheck.Check. Si no se pretende que sea una comprobaci√≥n personalizada, no debe exponerse. M√°s informaci√≥n: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index e65fb9bbc72..d0d5b8a101a 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -287,6 +287,11 @@
         <target state="translated">Impossible de trouver l‚Äôassembly de v√©rification personnalis√© sp√©cifi√© : ¬´¬†{0}¬†¬ª. Veuillez v√©rifier s‚Äôil existe.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">√âchec du chargement du type de v√©rification personnalis√© ¬´¬†{0}¬†¬ª √† partir de l‚Äôassembly ¬´¬†{1}¬†¬ª. Assurez-vous qu‚Äôil h√©rite de la classe de base Microsoft.Build.Experimental.BuildCheck.Check. S‚Äôil ne s‚Äôagit pas d‚Äôune v√©rification personnalis√©e, elle ne doit pas √™tre expos√©e. Plus d‚Äôinformations¬†: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 2ecacd50c7a..9665b1238d7 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -287,6 +287,11 @@
         <target state="translated">Non √® possibile trovare l'assembly del controllo personalizzato specificato: '{0}'. Verificare se esiste.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Non √® possibile caricare il tipo di controllo personalizzato '{0}' dall'assembly '{1}'. Assicurarsi che erediti la classe di base Microsoft.Build.Experimental.BuildCheck.Check. Se non √® destinato a essere un controllo personalizzato, non deve essere esposto. Altre informazioni: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index f5bc0bc25c2..366edaf78e0 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -287,6 +287,11 @@
         <target state="translated">ÊåáÂÆö„Åï„Çå„Åü„Ç´„Çπ„Çø„É† „ÉÅ„Çß„ÉÉ„ÇØ „Ç¢„Çª„É≥„Éñ„É™: '{0}' „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Åì„Çå„ÅåÂ≠òÂú®„Åô„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">„Ç¢„Çª„É≥„Éñ„É™: '{1}' „Åã„Çâ„ÄÅ„Ç´„Çπ„Çø„É† „ÉÅ„Çß„ÉÉ„ÇØ„ÅÆÁ®ÆÈ°û: '{0}'„ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇMicrosoft.Build.Experimental.BuildCheck.Check „ÅÆÂü∫Â∫ï„ÇØ„É©„Çπ„ÇíÁ∂ôÊâø„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Ç´„Çπ„Çø„É† „ÉÅ„Çß„ÉÉ„ÇØ„ÇíÊÑèÂõ≥„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅÂÖ¨Èñã„Åó„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ„ÄÇË©≥Á¥∞ÊÉÖÂ†±: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index a6e1a60302e..58ce075c959 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -287,6 +287,11 @@
         <target state="translated">ÏßÄÏ†ïÌïú ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï Í≤ÄÏÇ¨ Ïñ¥ÏÖàÎ∏îÎ¶¨Î•º Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§. '{0}'. ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Ïñ¥ÏÖàÎ∏îÎ¶¨ÏóêÏÑú ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï Í≤ÄÏÇ¨ Ïú†Ìòï '{0}'ÏùÑ(Î•º) Î°úÎìúÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. '{1}'. Microsoft.Build.Experimental.BuildCheck.Check Í∏∞Î≥∏ ÌÅ¥ÎûòÏä§Î•º ÏÉÅÏÜçÌï¥Ïïº Ìï©ÎãàÎã§. ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï Í≤ÄÏÇ¨Í∞Ä ÏïÑÎãå Í≤ΩÏö∞ ÎÖ∏Ï∂úÎêòÏßÄ ÏïäÏïÑÏïº Ìï©ÎãàÎã§. Ï∂îÍ∞Ä Ï†ïÎ≥¥: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b6f122d8d88..80dbe890de0 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -287,6 +287,11 @@
         <target state="translated">Nie uda≈Ço siƒô znale≈∫ƒá okre≈õlonego niestandardowego zestawu kontroli: ‚Äû{0}‚Äù. Sprawd≈∫, czy istnieje.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Nie uda≈Ço siƒô za≈Çadowaƒá niestandardowego typu kontroli: ‚Äû{0}‚Äù z zestawu: ‚Äû{1}‚Äù. Upewnij siƒô, ≈ºe dziedziczy klasƒô bazowƒÖ Microsoft.Build.Experimental.BuildCheck.Check. Je≈õli nie ma to byƒá kontrola niestandardowa, to nie powinna byƒá ona ujawniana. Wiƒôcej informacji: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index e9ff9122da6..01fbb41e2f0 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -287,6 +287,11 @@
         <target state="translated">Falha ao localizar o assembly de verifica√ß√£o personalizada especificado: '{0}'. Verifique se existe.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Falha ao carregar o tipo de verifica√ß√£o personalizado: '{0}' do assembly: '{1}'. Verifique se ele herda a classe base Microsoft.Build.Experimental.BuildCheck.Check. Se n√£o se destina a ser uma verifica√ß√£o personalizada, ela n√£o deve ser exposta. Mais informa√ß√µes: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 6a459c4234d..f2fd3f0ea0b 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -287,6 +287,11 @@
         <target state="translated">–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —É–∫–∞–∑–∞–Ω–Ω—É—é —Å–±–æ—Ä–∫—É –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ "{0}". –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–∏–ø –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ "{0}" –∏–∑ —Å–±–æ—Ä–∫–∏ "{1}". –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω –Ω–∞—Å–ª–µ–¥—É–µ—Ç –±–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å Microsoft.Build.Experimental.BuildCheck.Check. –ï—Å–ª–∏ –æ–Ω –Ω–µ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏, –µ–≥–æ –Ω–µ —Å–ª–µ–¥—É–µ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—Ç—å. –ü–æ–¥—Ä–æ–±–Ω–µ–µ: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index a072234741f..2287d82f4bd 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -287,6 +287,11 @@
         <target state="translated">Belirtilen √∂zel denetim derlemesi bulunamadƒ±: '{0}'. L√ºtfen var olup olmadƒ±ƒüƒ±nƒ± kontrol edin.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">‚Äò{0}‚Äô √∂zel denetim t√ºr√º ‚Äò{1}‚Äô derlemesinden y√ºklenemedi. Microsoft.Build.Experimental.BuildCheck.Check temel sƒ±nƒ±fƒ±nƒ± devralmƒ±≈ü olduƒüundan emin olun. √ñzel bir denetim olmasƒ± ama√ßlanmadƒ±ysa a√ßƒ±ƒüa √ßƒ±karƒ±lmamasƒ± gerekir. Daha fazla bilgi: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 125a80f18d9..c2366dce4b0 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -287,6 +287,11 @@
         <target state="translated">Êâæ‰∏çÂà∞ÊåáÂÆöÁöÑËá™ÂÆö‰πâÊ£ÄÊü•Á®ãÂ∫èÈõÜ: '{0}'„ÄÇËØ∑Ê£ÄÊü•ÂÆÉÊòØÂê¶Â≠òÂú®„ÄÇ</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Êú™ËÉΩ‰ªéÁ®ãÂ∫èÈõÜ '{1}' Âä†ËΩΩËá™ÂÆö‰πâÊ£ÄÊü•Á±ªÂûã '{0}'„ÄÇËØ∑Á°Æ‰øùÂÆÉÁªßÊâø Microsoft.Build.Experimental.BuildCheck.Check Âü∫Á±ª„ÄÇÂ¶ÇÊûúÂÆÉ‰∏çÊó®Âú®‰Ωú‰∏∫Ëá™ÂÆö‰πâÊ£ÄÊü•ÔºåÂàô‰∏çÂ∫îÂ∞ÜÂÖ∂ÂÖ¨ÂºÄ„ÄÇËØ¶ÁªÜ‰ø°ÊÅØ: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index c3cc990467f..123d6019589 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -287,6 +287,11 @@
         <target state="translated">Êâæ‰∏çÂà∞ÊåáÂÆöÁöÑËá™Ë®ÇÊ™¢Êü•ÁµÑ‰ª∂: '{0}'„ÄÇË´ãÁ¢∫Ë™çÂÖ∂ÊòØÂê¶Â≠òÂú®„ÄÇ</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">ÁÑ°Ê≥ïÂæûÁµÑ‰ª∂: '{1}' ËºâÂÖ•Ëá™Ë®ÇÊ™¢Êü•È°ûÂûã: '{0}'„ÄÇË´ãÁ¢∫Ë™çÂÖ∂ÁπºÊâø‰∫Ü Microsoft.Build.Experimental.BuildCheck.Check Âü∫Â∫ïÈ°ûÂà•„ÄÇÂ¶ÇÈùû‰ΩúÁÇ∫Ëá™Ë®ÇÊ™¢Êü•ÔºåÂâá‰∏çÊáâÂÖ¨Èñã„ÄÇÊõ¥Â§öË≥áË®ä: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 9fc62d7b964..82724a46b03 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -185,7 +185,7 @@ private static string[] GetFileList(
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
-            string[] fileList = Array.Empty<string>();
+            string[] fileList = [];
 
             // Used to properly detect and log drive enumerating wildcards when applicable.
             string excludeFileSpec = string.Empty;
@@ -200,7 +200,7 @@ private static string[] GetFileList(
             if (filespecMatchesLazyWildcard || (filespecHasNoWildCards && excludeSpecsAreEmpty))
             {
                 // Just return the original string.
-                fileList = new string[] { returnEscaped ? filespecEscaped : EscapingUtilities.UnescapeAll(filespecEscaped) };
+                fileList = [returnEscaped ? filespecEscaped : EscapingUtilities.UnescapeAll(filespecEscaped)];
             }
             else
             {
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 97ccb0de770..4e1f865bbae 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -66,7 +66,7 @@ public void Initialize(AssemblyName assemblyName, string assemblyFilePath)
             var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
             var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
             var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
-            ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
+            ParseMethod = NuGetFramework.GetMethod("Parse", [typeof(string)]);
             IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
             DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, Array.Empty<object>());
             FrameworkProperty = NuGetFramework.GetProperty("Framework");
@@ -78,7 +78,7 @@ public void Initialize(AssemblyName assemblyName, string assemblyFilePath)
 
         private object Parse(string tfm)
         {
-            return ParseMethod.Invoke(null, new object[] { tfm });
+            return ParseMethod.Invoke(null, [tfm]);
         }
 
         public string GetTargetFrameworkIdentifier(string tfm)
@@ -105,7 +105,7 @@ public string GetTargetPlatformVersion(string tfm, int minVersionPartCount)
 
         public bool IsCompatible(string target, string candidate)
         {
-            return Convert.ToBoolean(IsCompatibleMethod.Invoke(DefaultCompatibilityProvider, new object[] { Parse(target), Parse(candidate) }));
+            return Convert.ToBoolean(IsCompatibleMethod.Invoke(DefaultCompatibilityProvider, [Parse(target), Parse(candidate)]));
         }
 
         private string GetNonZeroVersionParts(Version version, int minVersionPartCount)
@@ -143,7 +143,7 @@ public string FilterTargetFrameworks(string incoming, string filter)
 
             IEnumerable<(string originalTfm, object parsedTfm)> ParseTfms(string desiredTargetFrameworks)
             {
-                return desiredTargetFrameworks.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(tfm =>
+                return desiredTargetFrameworks.Split([';'], StringSplitOptions.RemoveEmptyEntries).Select(tfm =>
                 {
                     (string originalTfm, object parsedTfm) parsed = (tfm, Parse(tfm));
                     return parsed;
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index ebe70f61d8c..e946a3546a3 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -128,7 +128,7 @@ public virtual string[] GetValueNames()
         {
             try
             {
-                return Exists() ? WrappedKey.GetValueNames() : Array.Empty<string>();
+                return Exists() ? WrappedKey.GetValueNames() : [];
             }
             catch (Exception ex) when (!ExceptionHandling.NotExpectedRegistryException(ex))
             {
@@ -144,7 +144,7 @@ public virtual string[] GetSubKeyNames()
         {
             try
             {
-                return Exists() ? WrappedKey.GetSubKeyNames() : Array.Empty<string>();
+                return Exists() ? WrappedKey.GetSubKeyNames() : [];
             }
             catch (Exception ex) when (!ExceptionHandling.NotExpectedRegistryException(ex))
             {
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index f66c5bb3880..b12e865dfd1 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -125,7 +125,7 @@ public static SimpleVersion Parse(string input)
             return new SimpleVersion(major, minor, build, revision);
         }
 
-        private static readonly char[] s_semverSeparators = new char[] { '-', '+' };
+        private static readonly char[] s_semverSeparators = ['-', '+'];
 
         private static ReadOnlySpan<char> RemoveTrivia(string input)
         {
diff --git a/src/Deprecated/Conversion/Microsoft.Build.Conversion.Core.pkgdef b/src/Deprecated/Conversion/Microsoft.Build.Conversion.Core.pkgdef
deleted file mode 100644
index bef750a882f..00000000000
--- a/src/Deprecated/Conversion/Microsoft.Build.Conversion.Core.pkgdef
+++ /dev/null
@@ -1,7 +0,0 @@
-[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{69CFFD1A-343F-46C5-81B3-8437CD1272CD}]
-"name"="Microsoft.Build.Conversion.Core"
-"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\Microsoft.Build.Conversion.Core.dll"
-"publicKeyToken"="b03f5f7f11d50a3a"
-"culture"="neutral"
-"oldVersion"="0.0.0.0-99.9.9.9"
-"newVersion"="15.1.0.0"
diff --git a/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs b/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs
new file mode 100644
index 00000000000..0ad43127a32
--- /dev/null
+++ b/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs
@@ -0,0 +1,41 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class BuildCanceledEventArgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            var message = "message";
+            var datetime = DateTime.Today;
+
+            BuildCanceledEventArgs args = new(
+                message,
+                datetime
+                );
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            args.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            BuildCanceledEventArgs argDeserialized = new("m");
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+
+            argDeserialized.CreateFromStream(br, packetVersion);
+            argDeserialized.Message.ShouldBe(message);
+            argDeserialized.Timestamp.ShouldBe(datetime); 
+        }
+    }
+}
diff --git a/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs b/src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
similarity index 97%
rename from src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
rename to src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
index 1db4853b515..199d2fc038d 100644
--- a/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
@@ -12,7 +12,7 @@
 
 namespace Microsoft.Build.Framework.UnitTests
 {
-    public class BuildSubmissionStartedEventAgs_Tests
+    public class BuildSubmissionStartedEventArgs_Tests
     {
         [Fact]
         public void SerializationDeserializationTest()
diff --git a/src/Framework/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
index eea490775a7..c7e1ac2473b 100644
--- a/src/Framework/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -166,7 +166,7 @@ private static CultureInfo[] GetValidCultures()
 
             var allCulturesEnumValue = Enum.Parse(cultureTypesType, "AllCultures", true);
 
-            var cultures = s_cultureInfoGetCultureMethod.Invoke(null, new[] { allCulturesEnumValue }) as CultureInfo[];
+            var cultures = s_cultureInfoGetCultureMethod.Invoke(null, [allCulturesEnumValue]) as CultureInfo[];
 
             FrameworkErrorUtilities.VerifyThrowInternalNull(cultures, "CultureInfo.GetCultures should work if all reflection checks pass");
 
diff --git a/src/Framework/BuildSubmissionStartedEventArgs.cs b/src/Framework/BuildSubmissionStartedEventArgs.cs
index f77fdf8cfd0..3e42bbb142b 100644
--- a/src/Framework/BuildSubmissionStartedEventArgs.cs
+++ b/src/Framework/BuildSubmissionStartedEventArgs.cs
@@ -19,8 +19,8 @@ public sealed class BuildSubmissionStartedEventArgs : BuildStatusEventArgs
         public BuildSubmissionStartedEventArgs()
         {
             GlobalProperties = new Dictionary<string, string?>();
-            EntryProjectsFullPath = Enumerable.Empty<string>();
-            TargetNames = Enumerable.Empty<string>();
+            EntryProjectsFullPath = [];
+            TargetNames = [];
             Flags = BuildRequestDataFlags.None;
             SubmissionId = 0;
         }
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index 8f19fd39b81..2072633870b 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -85,7 +85,7 @@ private set
         /// <summary>
         ///     Copy on write snapshot of <see cref="_knownImmutableDirectories"/>.
         /// </summary>
-        private volatile IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();
+        private volatile IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = [];
 
         /// <summary>
         ///     Creates default FileClassifier which following immutable folders:
@@ -103,7 +103,7 @@ private set
         public FileClassifier()
         {
             // Register Microsoft "Reference Assemblies" as immutable
-            string[] programFilesEnvs = new[] { "ProgramFiles(x86)", "ProgramW6432", "ProgramFiles(Arm)" };
+            string[] programFilesEnvs = ["ProgramFiles(x86)", "ProgramW6432", "ProgramFiles(Arm)"];
             foreach (string programFilesEnv in programFilesEnvs)
             {
                 string? programFiles = Environment.GetEnvironmentVariable(programFilesEnv);
diff --git a/src/Framework/NullableAttributes.cs b/src/Framework/Polyfills/NullableAttributes.cs
similarity index 99%
rename from src/Framework/NullableAttributes.cs
rename to src/Framework/Polyfills/NullableAttributes.cs
index 4e46baa38f0..b6698fce618 100644
--- a/src/Framework/NullableAttributes.cs
+++ b/src/Framework/Polyfills/NullableAttributes.cs
@@ -99,7 +99,7 @@ internal sealed class MemberNotNullAttribute : Attribute
         /// <param name="member">
         /// The field or property member that is promised to be not-null.
         /// </param>
-        public MemberNotNullAttribute(string member) => Members = new[] { member };
+        public MemberNotNullAttribute(string member) => Members = [member];
 
         /// <summary>Initializes the attribute with the list of field and property members.</summary>
         /// <param name="members">
@@ -125,7 +125,7 @@ internal sealed class MemberNotNullWhenAttribute : Attribute
         public MemberNotNullWhenAttribute(bool returnValue, string member)
         {
             ReturnValue = returnValue;
-            Members = new[] { member };
+            Members = [member];
         }
 
         /// <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 8dcf4330fb0..c8e0538eb25 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -303,7 +303,7 @@ public IEnumerable? Properties
                 // By doing this, we no longer need to transmit properties using this message because they've already
                 // been transmitted as part of the BuildRequestConfiguration.
                 return properties ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
-                    ? Enumerable.Empty<DictionaryEntry>()
+                    ? (DictionaryEntry[])[]
                     : null);
             }
         }
@@ -329,7 +329,7 @@ public IEnumerable? Items
                 // has likely not loaded this project, and therefore the live items would not be available to them, which is
                 // the same as the current functionality.
                 return items ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
-                    ? Enumerable.Empty<DictionaryEntry>()
+                    ? (DictionaryEntry[])[]
                     : null);
             }
         }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 6cf235e8ab1..2558de02b41 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -423,26 +423,6 @@ public bool UnquoteTargetSwitchParameters
             }
         }
 
-        private bool? _isBinaryFormatterSerializationAllowed;
-        public bool IsBinaryFormatterSerializationAllowed
-        {
-            get
-            {
-                if (!_isBinaryFormatterSerializationAllowed.HasValue)
-                {
-#if RUNTIME_TYPE_NETCORE
-                    AppContext.TryGetSwitch("System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization",
-                        out bool enabled);
-                    _isBinaryFormatterSerializationAllowed = enabled;
-#else
-                    _isBinaryFormatterSerializationAllowed = true;
-#endif
-                }
-
-                return _isBinaryFormatterSerializationAllowed.Value;
-            }
-        }
-
 
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 6ffae8dfb52..47e9361022d 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1531,25 +1531,6 @@ public void ProcessInvalidTargetSwitch()
 #endif
         }
 
-        /// <summary>
-        /// Verifies that when the /profileevaluation switch is used with invalid filenames an error is shown.
-        /// </summary>
-        [MemberData(nameof(GetInvalidFilenames))]
-        [WindowsFullFrameworkOnlyTheory(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
-        public void ProcessProfileEvaluationInvalidFilename(string filename)
-        {
-            bool enableProfiler = false;
-            Should.Throw(
-                () => MSBuildApp.ProcessProfileEvaluationSwitch(new[] { filename }, new List<ILogger>(), out enableProfiler),
-                typeof(CommandLineSwitchException));
-        }
-
-        public static IEnumerable<object[]> GetInvalidFilenames()
-        {
-            yield return new object[] { $"a_file_with${Path.GetInvalidFileNameChars().First()}invalid_chars" };
-            yield return new object[] { $"C:\\a_path\\with{Path.GetInvalidPathChars().First()}invalid\\chars" };
-        }
-
         /// <summary>
         /// Verifies that help messages are correctly formed with the right width and leading spaces.
         /// </summary>
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index ee6eb6219fb..fb588b1615b 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -1577,8 +1577,10 @@ private void RunPriorityBuildTest(ProcessPriorityClass expectedPrority, params s
         /// </summary>
         [Theory]
         [InlineData(new[] { "my.proj", "my.sln", "my.slnf" }, "my.sln")]
+        [InlineData(new[] { "my.proj", "my.slnx", "my.slnf" }, "my.slnx")]
         [InlineData(new[] { "abc.proj", "bcd.csproj", "slnf.slnf", "other.slnf" }, "abc.proj")]
         [InlineData(new[] { "abc.sln", "slnf.slnf", "abc.slnf" }, "abc.sln")]
+        [InlineData(new[] { "abc.slnx", "slnf.slnf", "abc.slnf" }, "abc.slnx")]
         [InlineData(new[] { "abc.csproj", "abc.slnf", "not.slnf" }, "abc.csproj")]
         [InlineData(new[] { "abc.slnf" }, "abc.slnf")]
         public void TestDefaultBuildWithSolutionFilter(string[] projects, string answer)
@@ -1724,11 +1726,21 @@ public void TestProcessProjectSwitch()
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
+            projects = new[] { "test.proj", "test.slnx" };
+            extensionsToIgnore = new[] { ".vcproj" };
+            projectHelper = new IgnoreProjectExtensionsHelper(projects);
+            MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.slnx", StringCompareShould.IgnoreCase); // "Expected test.slnx to be only solution found"
+
             projects = new[] { "test.proj", "test.sln", "test.proj~", "test.sln~" };
             extensionsToIgnore = Array.Empty<string>();
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
+            projects = new[] { "test.proj", "test.slnx", "test.proj~", "test.sln~" };
+            extensionsToIgnore = Array.Empty<string>();
+            projectHelper = new IgnoreProjectExtensionsHelper(projects);
+            MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.slnx", StringCompareShould.IgnoreCase); // "Expected test.slnx to be only solution found"
+
             projects = new[] { "test.proj" };
             extensionsToIgnore = Array.Empty<string>();
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
@@ -1744,6 +1756,12 @@ public void TestProcessProjectSwitch()
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
+            projects = new[] { "test.slnx" };
+            extensionsToIgnore = Array.Empty<string>();
+            projectHelper = new IgnoreProjectExtensionsHelper(projects);
+            MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.slnx", StringCompareShould.IgnoreCase); // "Expected test.slnx to be only solution found"
+
+
             projects = new[] { "test.sln", "test.sln~" };
             extensionsToIgnore = Array.Empty<string>();
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
@@ -1796,6 +1814,21 @@ public void TestProcessProjectSwitchSlnProjDifferentNames()
             });
         }
         /// <summary>
+        /// Test the case where there is a .slnx and a project in the same directory but they have different names
+        /// </summary>
+        [Fact]
+        public void TestProcessProjectSwitchSlnxProjDifferentNames()
+        {
+            string[] projects = ["test.proj", "Different.slnx"];
+            string[] extensionsToIgnore = null;
+
+            Should.Throw<InitializationException>(() =>
+            {
+                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
+                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);
+            });
+        }
+        /// <summary>
         /// Test the case where we have two proj files in the same directory
         /// </summary>
         [Fact]
@@ -1838,6 +1871,33 @@ public void TestProcessProjectSwitchTwoSolutions()
             });
         }
         /// <summary>
+        /// Test when there are two solutions in the same directory - .sln and .slnx
+        /// </summary>
+        [Fact]
+        public void TestProcessProjectSwitchSlnAndSlnx()
+        {
+            string[] projects = ["test.slnx", "Different.sln"];
+            string[] extensionsToIgnore = null;
+
+            Should.Throw<InitializationException>(() =>
+            {            
+                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
+                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);
+            });
+        }
+        [Fact]
+        public void TestProcessProjectSwitchTwoSlnx()
+        {
+            string[] projects = ["test.slnx", "Different.slnx"];
+            string[] extensionsToIgnore = null;
+
+            Should.Throw<InitializationException>(() =>
+            {
+                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
+                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);
+            });
+        }
+        /// <summary>
         /// Check the case where there are more than two projects in the directory and one is a proj file
         /// </summary>
         [Fact]
@@ -1897,7 +1957,7 @@ internal string[] GetFiles(string path, string searchPattern)
                 List<string> fileNamesToReturn = new List<string>();
                 foreach (string file in _directoryFileNameList)
                 {
-                    if (string.Equals(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(searchPattern, "*.sln?", StringComparison.OrdinalIgnoreCase))
                     {
                         if (FileUtilities.IsSolutionFilename(file))
                         {
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 28c4fbd93b9..b192f584c19 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -213,24 +213,24 @@ internal ParameterizedSwitchInfo(
             //----------------------------------------------------------------------------------------------------------------------------------------------------------
             //                                          Switch Names                        Switch Id                             Dup Error  Light up key    resourceId
             //----------------------------------------------------------------------------------------------------------------------------------------------------------
-            new ParameterlessSwitchInfo(  new string[] { "help", "h", "?" },                         ParameterlessSwitch.Help,                  null,       "HelpMessage_4_HelpSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "version", "ver" },                         ParameterlessSwitch.Version,               null,       "HelpMessage_6_VersionSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "nologo" },                                 ParameterlessSwitch.NoLogo,                null,       "HelpMessage_5_NoLogoSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "noautoresponse", "noautorsp" },            ParameterlessSwitch.NoAutoResponse,        null,       "HelpMessage_8_NoAutoResponseSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "noconsolelogger", "noconlog" },            ParameterlessSwitch.NoConsoleLogger,       null,       "HelpMessage_14_NoConsoleLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger", "fl" },                       ParameterlessSwitch.FileLogger,            null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger1", "fl1" },                     ParameterlessSwitch.FileLogger1,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger2", "fl2" },                     ParameterlessSwitch.FileLogger2,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger3", "fl3" },                     ParameterlessSwitch.FileLogger3,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger4", "fl4" },                     ParameterlessSwitch.FileLogger4,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger5", "fl5" },                     ParameterlessSwitch.FileLogger5,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger6", "fl6" },                     ParameterlessSwitch.FileLogger6,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger7", "fl7" },                     ParameterlessSwitch.FileLogger7,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },                     ParameterlessSwitch.FileLogger8,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },                     ParameterlessSwitch.FileLogger9,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },           ParameterlessSwitch.DistributedFileLogger, null,       "HelpMessage_21_DistributedFileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["help", "h", "?"],¬†                        ParameterlessSwitch.Help,                  null,       "HelpMessage_4_HelpSwitch"),
+            new ParameterlessSwitchInfo(  ["version", "ver"],¬†                        ParameterlessSwitch.Version,               null,       "HelpMessage_6_VersionSwitch"),
+            new ParameterlessSwitchInfo(  ["nologo"],¬†                                ParameterlessSwitch.NoLogo,                null,       "HelpMessage_5_NoLogoSwitch"),
+            new ParameterlessSwitchInfo(  ["noautoresponse", "noautorsp"],¬†           ParameterlessSwitch.NoAutoResponse,        null,       "HelpMessage_8_NoAutoResponseSwitch"),
+            new ParameterlessSwitchInfo(  ["noconsolelogger", "noconlog"],¬†           ParameterlessSwitch.NoConsoleLogger,       null,       "HelpMessage_14_NoConsoleLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger", "fl"],¬†                      ParameterlessSwitch.FileLogger,            null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger1", "fl1"],¬†                    ParameterlessSwitch.FileLogger1,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger2", "fl2"],¬†                    ParameterlessSwitch.FileLogger2,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger3", "fl3"],¬†                    ParameterlessSwitch.FileLogger3,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger4", "fl4"],¬†                    ParameterlessSwitch.FileLogger4,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger5", "fl5"],¬†                    ParameterlessSwitch.FileLogger5,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger6", "fl6"],¬†                    ParameterlessSwitch.FileLogger6,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger7", "fl7"],¬†                    ParameterlessSwitch.FileLogger7,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger8", "fl8"],¬†                    ParameterlessSwitch.FileLogger8,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger9", "fl9"],¬†                    ParameterlessSwitch.FileLogger9,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["distributedfilelogger", "dfl"],¬†          ParameterlessSwitch.DistributedFileLogger, null,       "HelpMessage_21_DistributedFileLoggerSwitch"),
 #if DEBUG
-            new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },                 ParameterlessSwitch.WaitForDebugger,       null,       null),
+            new ParameterlessSwitchInfo(  ["waitfordebugger", "wfd"],¬†                ParameterlessSwitch.WaitForDebugger,       null,       null),
 #endif
         };
 
@@ -241,62 +241,62 @@ internal ParameterizedSwitchInfo(
             //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
             //                                          Switch Names                            Switch Id                                       Duplicate Switch Error          Multi Params?   Missing Parameters Error           Unquote?    Empty?   reosurceId
             //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-            new ParameterizedSwitchInfo(  new string[] { null },                                ParameterizedSwitch.Project,                    "DuplicateProjectSwitchError",  false,          null,                                  true,   false,   null),
-            new ParameterizedSwitchInfo(  new string[] { "target", "t"},                        ParameterizedSwitch.Target,                     null,                           true,           "MissingTargetError",                  true,   false,   "HelpMessage_9_TargetSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "property", "p" },                     ParameterizedSwitch.Property,                   null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_10_PropertySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "logger", "l" },                       ParameterizedSwitch.Logger,                     null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_11_LoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "distributedlogger", "dl" },           ParameterizedSwitch.DistributedLogger,          null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_18_DistributedLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "verbosity", "v" },                    ParameterizedSwitch.Verbosity,                  null,                           false,          "MissingVerbosityError",               true,   false,   "HelpMessage_12_VerbositySwitch"),
+            new ParameterizedSwitchInfo(  [null],                                ParameterizedSwitch.Project,                    "DuplicateProjectSwitchError",  false,          null,                                  true,   false,   null),
+            new ParameterizedSwitchInfo(  ["target", "t"],                       ParameterizedSwitch.Target,                     null,                           true,           "MissingTargetError",                  true,   false,   "HelpMessage_9_TargetSwitch"),
+            new ParameterizedSwitchInfo(  ["property", "p"],¬†                    ParameterizedSwitch.Property,                   null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_10_PropertySwitch"),
+            new ParameterizedSwitchInfo(  ["logger", "l"],¬†                      ParameterizedSwitch.Logger,                     null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_11_LoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["distributedlogger", "dl"],¬†          ParameterizedSwitch.DistributedLogger,          null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_18_DistributedLoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["verbosity", "v"],¬†                   ParameterizedSwitch.Verbosity,                  null,                           false,          "MissingVerbosityError",               true,   false,   "HelpMessage_12_VerbositySwitch"),
 #if FEATURE_XML_SCHEMA_VALIDATION
-            new ParameterizedSwitchInfo(  new string[] { "validate", "val" },                   ParameterizedSwitch.Validate,                   null,                           false,          null,                                  true,   false,   "HelpMessage_15_ValidateSwitch"),
+            new ParameterizedSwitchInfo(  ["validate", "val"],¬†                  ParameterizedSwitch.Validate,                   null,                           false,          null,                                  true,   false,   "HelpMessage_15_ValidateSwitch"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "consoleloggerparameters", "clp" },    ParameterizedSwitch.ConsoleLoggerParameters,    null,                           false,          "MissingConsoleLoggerParameterError",  true,   false,   "HelpMessage_13_ConsoleLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "nodemode", "nmode" },                 ParameterizedSwitch.NodeMode,                   null,                           false,          null,                                  false,  false,   null),
-            new ParameterizedSwitchInfo(  new string[] { "maxcpucount", "m" },                  ParameterizedSwitch.MaxCPUCount,                null,                           false,          "MissingMaxCPUCountError",             true,   false,   "HelpMessage_17_MaximumCPUSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "ignoreprojectextensions", "ignore" }, ParameterizedSwitch.IgnoreProjectExtensions,    null,                           true,           "MissingIgnoreProjectExtensionsError", true,   false,   "HelpMessage_19_IgnoreProjectExtensionsSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "toolsversion","tv" },                 ParameterizedSwitch.ToolsVersion,               null,                           false,          "MissingToolsVersionError",            true,   false,   "HelpMessage_23_ToolsVersionSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters", "flp" },       ParameterizedSwitch.FileLoggerParameters,       null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters1", "flp1" },     ParameterizedSwitch.FileLoggerParameters1,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters2", "flp2" },     ParameterizedSwitch.FileLoggerParameters2,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters3", "flp3" },     ParameterizedSwitch.FileLoggerParameters3,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters4", "flp4" },     ParameterizedSwitch.FileLoggerParameters4,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters5", "flp5" },     ParameterizedSwitch.FileLoggerParameters5,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters6", "flp6" },     ParameterizedSwitch.FileLoggerParameters6,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters7", "flp7" },     ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters8", "flp8" },     ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters9", "flp9" },     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["consoleloggerparameters", "clp"],¬†   ParameterizedSwitch.ConsoleLoggerParameters,    null,                           false,          "MissingConsoleLoggerParameterError",  true,   false,   "HelpMessage_13_ConsoleLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["nodemode", "nmode"],¬†                ParameterizedSwitch.NodeMode,                   null,                           false,          null,                                  false,  false,   null),
+            new ParameterizedSwitchInfo(  ["maxcpucount", "m"],¬†                 ParameterizedSwitch.MaxCPUCount,                null,                           false,          "MissingMaxCPUCountError",             true,   false,   "HelpMessage_17_MaximumCPUSwitch"),
+            new ParameterizedSwitchInfo(  ["ignoreprojectextensions", "ignore"],¬†ParameterizedSwitch.IgnoreProjectExtensions,    null,                           true,           "MissingIgnoreProjectExtensionsError", true,   false,   "HelpMessage_19_IgnoreProjectExtensionsSwitch"),
+            new ParameterizedSwitchInfo(  ["toolsversion","tv"],¬†                ParameterizedSwitch.ToolsVersion,               null,                           false,          "MissingToolsVersionError",            true,   false,   "HelpMessage_23_ToolsVersionSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters", "flp"],¬†      ParameterizedSwitch.FileLoggerParameters,       null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters1", "flp1"],¬†    ParameterizedSwitch.FileLoggerParameters1,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters2", "flp2"],¬†    ParameterizedSwitch.FileLoggerParameters2,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters3", "flp3"],¬†    ParameterizedSwitch.FileLoggerParameters3,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters4", "flp4"],¬†    ParameterizedSwitch.FileLoggerParameters4,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters5", "flp5"],¬†    ParameterizedSwitch.FileLoggerParameters5,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters6", "flp6"],¬†    ParameterizedSwitch.FileLoggerParameters6,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters7", "flp7"],¬†    ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters8", "flp8"],¬†    ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters9", "flp9"],¬†    ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
             // To not break existing use, keep supporting live logger switches
-            new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true,    "HelpMessage_47_TerminalLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "terminalloggerparameters", "tlp" },   ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false,   "HelpMessage_48_TerminalLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["livelogger", "ll", "terminallogger", "tl"],¬†ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true,    "HelpMessage_47_TerminalLoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["terminalloggerparameters", "tlp"],¬†  ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false,   "HelpMessage_48_TerminalLoggerParametersSwitch"),
 #if FEATURE_NODE_REUSE
-            new ParameterizedSwitchInfo(  new string[] { "nodereuse", "nr" },                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false,   "HelpMessage_24_NodeReuse"),
+            new ParameterizedSwitchInfo(  ["nodereuse", "nr"],¬†                  ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false,   "HelpMessage_24_NodeReuse"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "preprocess", "pp" },                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false,   "HelpMessage_25_PreprocessSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "targets", "ts" },                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false,   "HelpMessage_38_TargetsSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "warnaserror", "err" },                ParameterizedSwitch.WarningsAsErrors,           null,                           true,           null,                                  true,   true,    "HelpMessage_28_WarnAsErrorSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false,   "HelpMessage_40_WarnNotAsErrorSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false,   "HelpMessage_29_WarnAsMessageSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false,   "HelpMessage_30_BinaryLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "check", },                            ParameterizedSwitch.Check,                      null,                           false,          null,                                  true,   false,   "HelpMessage_52_BuildCheckSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false,   "HelpMessage_31_RestoreSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false,   "HelpMessage_32_ProfilerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_33_RestorePropertySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "interactive" },                       ParameterizedSwitch.Interactive,                null,                           false,          null,                                  true,   false,   "HelpMessage_34_InteractiveSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "isolateprojects", "isolate" },        ParameterizedSwitch.IsolateProjects,            null,                           false,          null,                                  true,   false,   "HelpMessage_35_IsolateProjectsSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false,   "HelpMessage_36_GraphBuildSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true,    "HelpMessage_InputCachesFiles"),
-            new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true,    "HelpMessage_OutputCacheFile"),
+            new ParameterizedSwitchInfo(  ["preprocess", "pp"],¬†                 ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false,   "HelpMessage_25_PreprocessSwitch"),
+            new ParameterizedSwitchInfo(  ["targets", "ts"],¬†                    ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false,   "HelpMessage_38_TargetsSwitch"),
+            new ParameterizedSwitchInfo(  ["warnaserror", "err"],¬†               ParameterizedSwitch.WarningsAsErrors,           null,                           true,           null,                                  true,   true,    "HelpMessage_28_WarnAsErrorSwitch"),
+            new ParameterizedSwitchInfo(  ["warnnotaserror", "noerr"],¬†          ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false,   "HelpMessage_40_WarnNotAsErrorSwitch"),
+            new ParameterizedSwitchInfo(  ["warnasmessage", "nowarn"],¬†          ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false,   "HelpMessage_29_WarnAsMessageSwitch"),
+            new ParameterizedSwitchInfo(  ["binarylogger", "bl"],¬†               ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false,   "HelpMessage_30_BinaryLoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["check"],                             ParameterizedSwitch.Check,                      null,                           false,          null,                                  true,   false,   "HelpMessage_52_BuildCheckSwitch"),
+            new ParameterizedSwitchInfo(  ["restore", "r"],¬†                     ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false,   "HelpMessage_31_RestoreSwitch"),
+            new ParameterizedSwitchInfo(  ["profileevaluation", "prof"],¬†        ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false,   "HelpMessage_32_ProfilerSwitch"),
+            new ParameterizedSwitchInfo(  ["restoreproperty", "rp"],¬†            ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_33_RestorePropertySwitch"),
+            new ParameterizedSwitchInfo(  ["interactive"],¬†                      ParameterizedSwitch.Interactive,                null,                           false,          null,                                  true,   false,   "HelpMessage_34_InteractiveSwitch"),
+            new ParameterizedSwitchInfo(  ["isolateprojects", "isolate"],¬†       ParameterizedSwitch.IsolateProjects,            null,                           false,          null,                                  true,   false,   "HelpMessage_35_IsolateProjectsSwitch"),
+            new ParameterizedSwitchInfo(  ["graphbuild", "graph"],¬†              ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false,   "HelpMessage_36_GraphBuildSwitch"),
+            new ParameterizedSwitchInfo(  ["inputResultsCaches", "irc"],¬†        ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true,    "HelpMessage_InputCachesFiles"),
+            new ParameterizedSwitchInfo(  ["outputResultsCache", "orc"],¬†        ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true,    "HelpMessage_OutputCacheFile"),
 #if FEATURE_REPORTFILEACCESSES
-            new ParameterizedSwitchInfo(  new string[] { "reportfileaccesses" },                ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false,   "HelpMessage_42_ReportFileAccessesSwitch"),
+            new ParameterizedSwitchInfo(  ["reportfileaccesses"],¬†               ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false,   "HelpMessage_42_ReportFileAccessesSwitch"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false,   "HelpMessage_39_LowPrioritySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false,   "HelpMessage_41_QuestionSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false,   "HelpMessage_26_DetailedSummarySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getProperty" },                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false,   "HelpMessage_43_GetPropertySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false,   "HelpMessage_44_GetItemSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false,   "HelpMessage_45_GetTargetResultSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getResultOutputFile" },               ParameterizedSwitch.GetResultOutputFile,        null,                           true,           "MissingGetResultFileError",           true,   false,   "HelpMessage_51_GetResultOutputFileSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "featureAvailability", "fa" },         ParameterizedSwitch.FeatureAvailability,        null,                           true,           "MissingFeatureAvailabilityError",     true,   false,   "HelpMessage_46_FeatureAvailabilitySwitch")
+            new ParameterizedSwitchInfo(  ["lowpriority", "low"],¬†               ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false,   "HelpMessage_39_LowPrioritySwitch"),
+            new ParameterizedSwitchInfo(  ["question", "q"],¬†                    ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false,   "HelpMessage_41_QuestionSwitch"),
+            new ParameterizedSwitchInfo(  ["detailedsummary", "ds"],¬†            ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false,   "HelpMessage_26_DetailedSummarySwitch"),
+            new ParameterizedSwitchInfo(  ["getProperty"],¬†                      ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false,   "HelpMessage_43_GetPropertySwitch"),
+            new ParameterizedSwitchInfo(  ["getItem"],¬†                          ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false,   "HelpMessage_44_GetItemSwitch"),
+            new ParameterizedSwitchInfo(  ["getTargetResult"],¬†                  ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false,   "HelpMessage_45_GetTargetResultSwitch"),
+            new ParameterizedSwitchInfo(  ["getResultOutputFile"],¬†              ParameterizedSwitch.GetResultOutputFile,        null,                           true,           "MissingGetResultFileError",           true,   false,   "HelpMessage_51_GetResultOutputFileSwitch"),
+            new ParameterizedSwitchInfo(  ["featureAvailability", "fa"],¬†        ParameterizedSwitch.FeatureAvailability,        null,                           true,           "MissingFeatureAvailabilityError",     true,   false,   "HelpMessage_46_FeatureAvailabilitySwitch")
         };
 
         /// <summary>
@@ -651,7 +651,7 @@ internal bool IsParameterizedSwitchSet(ParameterizedSwitch parameterizedSwitch)
         }
 
         // used to indicate a null parameter list for a switch
-        private static readonly string[] s_noParameters = Array.Empty<string>();
+        private static readonly string[] s_noParameters = [];
 
         /// <summary>
         /// Gets the parameters (if any) detected on the command line for the given parameterized switch.
@@ -745,7 +745,7 @@ private string[] GetSpecificFileLoggerParameters(ParameterlessSwitch parameterle
             }
             else if (IsParameterlessSwitchSet(parameterlessSwitch))
             {
-                result = Array.Empty<string>();
+                result = [];
             }
 
             return result;
diff --git a/src/MSBuild/MSBuild.ico b/src/MSBuild/MSBuild.ico
index 69d0069cb74..f70202a070e 100644
Binary files a/src/MSBuild/MSBuild.ico and b/src/MSBuild/MSBuild.ico differ
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index 2cd1b34f072..d3502c8befd 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -125,7 +125,7 @@ internal OutOfProcTaskHostTaskResult ExecuteTask(
                                 TaskCompleteType.CrashedDuringInitialization,
                                 exceptionToReturn,
                                 "TaskInstantiationFailureError",
-                                new string[] { taskName, taskLocation, String.Empty });
+                                [taskName, taskLocation, String.Empty]);
             }
 
             OutOfProcTaskHostTaskResult taskResult;
@@ -142,7 +142,7 @@ internal OutOfProcTaskHostTaskResult ExecuteTask(
                                                     TaskCompleteType.CrashedDuringInitialization,
                                                     null,
                                                     "TaskInstantiationFailureNotSupported",
-                                                    new string[] { taskName, taskLocation, typeof(RunInSTAAttribute).FullName });
+                                                    [taskName, taskLocation, typeof(RunInSTAAttribute).FullName]);
 #endif
             }
             else
@@ -318,7 +318,7 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                     TaskCompleteType.CrashedDuringInitialization,
                     exceptionToReturn,
                     "TaskInstantiationFailureError",
-                    new string[] { taskName, taskLocation, String.Empty });
+                    [taskName, taskLocation, String.Empty]);
             }
 
             foreach (KeyValuePair<string, TaskParameter> param in taskParams)
@@ -335,7 +335,7 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                                 // If it's a TargetInvocationException, we only care about the contents of the inner exception, so save that instead.
                                 e is TargetInvocationException ? e.InnerException : e,
                                 "InvalidTaskAttributeError",
-                                new string[] { param.Key, param.Value.ToString(), taskName });
+                                [param.Key, param.Value.ToString(), taskName]);
                 }
             }
 
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 00b1333080b..02d83eca1c6 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -644,7 +644,7 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
             _nodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(OnLinkStatusChanged);
             _nodeEndpoint.Listen(this);
 
-            WaitHandle[] waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent, _taskCompleteEvent, _taskCancelledEvent };
+            WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent, _taskCompleteEvent, _taskCancelledEvent];
 
             while (true)
             {
diff --git a/src/MSBuild/PerformanceLogEventListener.cs b/src/MSBuild/PerformanceLogEventListener.cs
index 4aaa1283384..3eb6090cd4b 100644
--- a/src/MSBuild/PerformanceLogEventListener.cs
+++ b/src/MSBuild/PerformanceLogEventListener.cs
@@ -22,15 +22,15 @@ internal struct ProviderConfiguration
             internal EventLevel Level { get; set; }
         }
 
-        private static ProviderConfiguration[] s_config = new ProviderConfiguration[]
-        {
+        private static ProviderConfiguration[] s_config =
+        [
             new ProviderConfiguration()
             {
                 Name = "Microsoft-Build",
                 Keywords = MSBuildEventSource.Keywords.PerformanceLog,
                 Level = EventLevel.Verbose
             }
-        };
+        ];
 
         private const string PerfLogDirEnvVar = "DOTNET_PERFLOG_DIR";
         private const char EventDelimiter = '\n';
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 4b9497fda51..8e80657dfea 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -138,9 +138,9 @@
                      used, write out the values after the build.
     </source>
         <target state="translated">  -getProperty:propertyName,...
-                     –ó–∞–ø–∏—à–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —Å–≤–æ–π—Å—Ç–≤ 
-                     –ø–æ—Å–ª–µ –æ—Ü–µ–Ω–∫–∏, –Ω–µ –≤—ã–ø–æ–ª–Ω—è—è —Å–±–æ—Ä–∫—É, –∏–ª–∏, –µ—Å–ª–∏ 
-                     –æ–ø—Ü–∏—è -targets –∏–ª–∏ –æ–ø—Ü–∏—è -getTargetResult 
+                     –ó–∞–ø–∏—à–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —Å–≤–æ–π—Å—Ç–≤
+                     –ø–æ—Å–ª–µ –æ—Ü–µ–Ω–∫–∏, –Ω–µ –≤—ã–ø–æ–ª–Ω—è—è —Å–±–æ—Ä–∫—É, –∏–ª–∏, –µ—Å–ª–∏
+                     –æ–ø—Ü–∏—è -targets –∏–ª–∏ –æ–ø—Ü–∏—è -getTargetResult
                      –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –∑–∞–ø–∏—à–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ—Å–ª–µ —Å–±–æ—Ä–∫–∏.
     </target>
         <note>
@@ -157,11 +157,11 @@
                      the values after the build.
     </source>
         <target state="translated">  -getItem:itemName,...
-                     –ó–∞–ø–∏—à–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏ 
-                     —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–∏–º–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –æ—Ü–µ–Ω–∫–∏ –±–µ–∑ 
-                     –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–±–æ—Ä–∫–∏ –∏–ª–∏, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–ø—Ü–∏—è -targets 
-                     –∏–ª–∏ –æ–ø—Ü–∏—è -getTargetResult, –∑–∞–ø–∏—à–∏—Ç–µ 
-                     –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ—Å–ª–µ —Å–±–æ—Ä–∫–∏. 
+                     –ó–∞–ø–∏—à–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏
+                     —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–∏–º–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –æ—Ü–µ–Ω–∫–∏ –±–µ–∑
+                     –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–±–æ—Ä–∫–∏ –∏–ª–∏, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–ø—Ü–∏—è -targets
+                     –∏–ª–∏ –æ–ø—Ü–∏—è -getTargetResult, –∑–∞–ø–∏—à–∏—Ç–µ
+                     –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ—Å–ª–µ —Å–±–æ—Ä–∫–∏.
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -174,8 +174,8 @@
                      the specified targets will be executed.
     </source>
         <target state="translated">  -getTargetResult:targetName,...
-                     –ó–∞–ø–∏—à–∏—Ç–µ –≤—ã—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–Ω–æ–π –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ü–µ–ª–µ–π –∏ 
-                     —É–∫–∞–∑–∞–Ω–Ω—ã–µ —Ü–µ–ª–∏ –±—É–¥—É—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω—ã. 
+                     –ó–∞–ø–∏—à–∏—Ç–µ –≤—ã—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–Ω–æ–π –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ü–µ–ª–µ–π –∏
+                     —É–∫–∞–∑–∞–Ω–Ω—ã–µ —Ü–µ–ª–∏ –±—É–¥—É—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω—ã.
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -199,18 +199,18 @@
                      (Short form: -fa)
     </source>
         <target state="translated">  -featureAvailability:featureName,...
-                     –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏. –†–µ–∑—É–ª—å—Ç–∞—Ç–æ–º —è–≤–ª—è–µ—Ç—Å—è –æ–¥–Ω–∞ –∏–∑ 
-                     —Å—Ç—Ä–æ–∫ "–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ", "–î–æ—Å—Ç—É–ø–Ω–æ", "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ" –∏ 
-                     "–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä". 
-                     - –ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ¬†‚Äî –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ 
-                     (–∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤—É –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ 
-                     —Ñ—É–Ω–∫—Ü–∏–∏) 
-                     - NotAvailable ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ (–≤ –æ—Ç–ª–∏—á–∏–µ –æ—Ç 
-                     –ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ, –∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑–≤–µ—Å—Ç–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤—É –ø—Ä–æ–≤–µ—Ä–∫–∏ 
-                     –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏, –∏ –µ–º—É –∏–∑–≤–µ—Å—Ç–Ω–æ, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ 
-                     –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è —Ç–µ–∫—É—â–∏–º –º–µ—Ö–∞–Ω–∏–∑–º–æ–º MSBuild) 
-                     - –î–æ—Å—Ç—É–ø–Ω–æ ‚Äì —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ 
-                     - –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è¬†‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏ (–Ω–µ —Å—Ç–∞–±–∏–ª—å–Ω–∞) 
+                     –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏. –†–µ–∑—É–ª—å—Ç–∞—Ç–æ–º —è–≤–ª—è–µ—Ç—Å—è –æ–¥–Ω–∞ –∏–∑
+                     —Å—Ç—Ä–æ–∫ "–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ", "–î–æ—Å—Ç—É–ø–Ω–æ", "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ" –∏
+                     "–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä".
+                     - –ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ¬†‚Äî –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞
+                     (–∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤—É –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
+                     —Ñ—É–Ω–∫—Ü–∏–∏)
+                     - NotAvailable ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ (–≤ –æ—Ç–ª–∏—á–∏–µ –æ—Ç
+                     –ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ, –∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑–≤–µ—Å—Ç–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤—É –ø—Ä–æ–≤–µ—Ä–∫–∏
+                     –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏, –∏ –µ–º—É –∏–∑–≤–µ—Å—Ç–Ω–æ, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ
+                     –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è —Ç–µ–∫—É—â–∏–º –º–µ—Ö–∞–Ω–∏–∑–º–æ–º MSBuild)
+                     - –î–æ—Å—Ç—É–ø–Ω–æ ‚Äì —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞
+                     - –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è¬†‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏ (–Ω–µ —Å—Ç–∞–±–∏–ª—å–Ω–∞)
                      (Short form: -fa)
     </target>
         <note>
@@ -231,16 +231,16 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="translated">  -terminalLogger[:–∞–≤—Ç–æ,–≤–∫–ª,–≤—ã–∫–ª] 
-                     –í–∫–ª—é—á–∏—Ç–µ –∏–ª–∏ –æ—Ç–∫–ª—é—á–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Ç–µ—Ä–º–∏–Ω–∞–ª–∞. –†–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Ç–µ—Ä–º–∏–Ω–∞–ª–∞ 
-                     –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –≤—ã–≤–æ–¥ —Å–±–æ—Ä–∫–∏ –Ω–∞ –∫–æ–Ω—Å–æ–ª—å –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏, 
-                     –ª–æ–≥–∏—á–µ—Å–∫–∏ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–Ω—ã–π –ø–æ –ø—Ä–æ–µ–∫—Ç–∞–º –∏ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è 
-                     –ø–æ–ª–µ–∑–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏. –£–∫–∞–∂–∏—Ç–µ –∞–≤—Ç–æ (–∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–ø—Ü–∏—é 
-                     –±–µ–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤), —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Ç–µ—Ä–º–∏–Ω–∞–ª–∞ —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ 
-                     —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥ –Ω–µ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è. –ù–µ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ 
-                     –∏ –Ω–µ –ø–æ–ª–∞–≥–∞–π—Ç–µ—Å—å –Ω–∞ —Ç–æ, —á—Ç–æ –æ–Ω–∏ –æ—Å—Ç–∞–Ω—É—Ç—Å—è –Ω–µ–∏–∑–º–µ–Ω–Ω—ã–º–∏ –≤ –±—É–¥—É—â–∏—Ö 
-                     –≤–µ—Ä—Å–∏—è—Ö. –≠—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –≤ MSBuild 17.8 –∏ 
-                     –ø–æ–∑–∂–µ. 
+        <target state="translated">  -terminalLogger[:–∞–≤—Ç–æ,–≤–∫–ª,–≤—ã–∫–ª]
+                     –í–∫–ª—é—á–∏—Ç–µ –∏–ª–∏ –æ—Ç–∫–ª—é—á–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Ç–µ—Ä–º–∏–Ω–∞–ª–∞. –†–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
+                     –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –≤—ã–≤–æ–¥ —Å–±–æ—Ä–∫–∏ –Ω–∞ –∫–æ–Ω—Å–æ–ª—å –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏,
+                     –ª–æ–≥–∏—á–µ—Å–∫–∏ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–Ω—ã–π –ø–æ –ø—Ä–æ–µ–∫—Ç–∞–º –∏ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è
+                     –ø–æ–ª–µ–∑–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏. –£–∫–∞–∂–∏—Ç–µ –∞–≤—Ç–æ (–∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–ø—Ü–∏—é
+                     –±–µ–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤), —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Ç–µ—Ä–º–∏–Ω–∞–ª–∞ —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏
+                     —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥ –Ω–µ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è. –ù–µ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
+                     –∏ –Ω–µ –ø–æ–ª–∞–≥–∞–π—Ç–µ—Å—å –Ω–∞ —Ç–æ, —á—Ç–æ –æ–Ω–∏ –æ—Å—Ç–∞–Ω—É—Ç—Å—è –Ω–µ–∏–∑–º–µ–Ω–Ω—ã–º–∏ –≤ –±—É–¥—É—â–∏—Ö
+                     –≤–µ—Ä—Å–∏—è—Ö. –≠—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –≤ MSBuild 17.8 –∏
+                     –ø–æ–∑–∂–µ.
                      (Short form: -tl)
     </target>
         <note>
@@ -270,19 +270,19 @@
     </source>
         <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
                      –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –ª–æ–≥–≥–µ—Ä–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞. (Short form: -tlp)
-                     –î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã. 
-                        –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ª–æ–≥–≥–µ—Ä–∞ 
-                        —Ç–µ—Ä–º–∏–Ω–∞–ª–∞. –¢—Ä–µ–±—É–µ—Ç—Å—è –æ–¥–Ω–æ –∏–∑ —Å–ª–µ–¥—É—é—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π: 
-                           - "on", "true" –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å TerminalLogger –¥–∞–∂–µ 
-                            –∫–æ–≥–¥–∞ –æ–Ω –±—É–¥–µ—Ç –æ—Ç–∫–ª—é—á–µ–Ω. 
-                           - "off", "false" –∑–∞–ø—Ä–µ—â–∞–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ TerminalLogger 
-                            –¥–∞–∂–µ –µ—Å–ª–∏ –±—ã –æ–Ω –±—ã–ª –≤–∫–ª—é—á–µ–Ω. 
-                           - "auto" –≤–∫–ª—é—á–∞–µ—Ç TerminalLogger, –∫–æ–≥–¥–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª 
+                     –î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.
+                        –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ª–æ–≥–≥–µ—Ä–∞
+                        —Ç–µ—Ä–º–∏–Ω–∞–ª–∞. –¢—Ä–µ–±—É–µ—Ç—Å—è –æ–¥–Ω–æ –∏–∑ —Å–ª–µ–¥—É—é—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π:
+                           - "on", "true" –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å TerminalLogger –¥–∞–∂–µ
+                            –∫–æ–≥–¥–∞ –æ–Ω –±—É–¥–µ—Ç –æ—Ç–∫–ª—é—á–µ–Ω.
+                           - "off", "false" –∑–∞–ø—Ä–µ—â–∞–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ TerminalLogger
+                            –¥–∞–∂–µ –µ—Å–ª–∏ –±—ã –æ–Ω –±—ã–ª –≤–∫–ª—é—á–µ–Ω.
+                           - "auto" –≤–∫–ª—é—á–∞–µ—Ç TerminalLogger, –∫–æ–≥–¥–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª
                             –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —ç—Ç–æ, –∏ –≤ —Å–µ–∞–Ω—Å–µ –Ω–µ—Ç –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                             stdout/stderr
-                        verbosity¬†‚Äì –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä -verbosity –¥–ª—è —ç—Ç–æ–≥–æ 
-                        —Ç–µ—Ä–º–∏–Ω–∞–ª–∞ 
-                        showCommandLine ‚Äî –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è TaskCommandLineEvent 
+                        verbosity¬†‚Äì –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä -verbosity –¥–ª—è —ç—Ç–æ–≥–æ
+                        —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
+                        showCommandLine ‚Äî –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è TaskCommandLineEvent
 
                       –ü—Ä–∏–º–µ—Ä:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
@@ -301,11 +301,11 @@
                      This writes the value of property Bar into Biz.txt.
     </source>
         <target state="translated">  -getResultOutputFile:file
-                     –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–∏—Ç—å –≤—ã–≤–æ–¥ get* –≤ —Ñ–∞–π–ª. 
+                     –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–∏—Ç—å –≤—ã–≤–æ–¥ get* –≤ —Ñ–∞–π–ª.
 
                      –ü—Ä–∏–º–µ—Ä:
                      -getProperty:Bar -getResultOutputFile:Biz.txt
-                     –ü—Ä–∏ —ç—Ç–æ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞ Bar –±—É–¥–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–æ –≤ Biz.txt. 
+                     –ü—Ä–∏ —ç—Ç–æ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞ Bar –±—É–¥–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–æ –≤ Biz.txt.
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -318,9 +318,9 @@
                      BuildCheck enables evaluating rules to ensure properties 
                      of the build. For more info see aka.ms/buildcheck
 	</source>
-        <target state="translated">  -check
+        <target state="needs-review-translation">  -check
                      –í–∫–ª—é—á–∞–µ—Ç BuildChecks –≤–æ –≤—Ä–µ–º—è —Å–±–æ—Ä–∫–∏.
-                     BuildCheck –¥–∞–µ—Ç –æ—Ü–µ–Ω–∏–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–≤–æ–π—Å—Ç–≤ 
+                     BuildCheck –¥–∞–µ—Ç –æ—Ü–µ–Ω–∏–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–≤–æ–π—Å—Ç–≤
                      —Å–±–æ—Ä–∫–∏. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–≤–µ–¥–µ–Ω–∏—è —Å–º. –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ aka.ms/buildcheck
 	</target>
         <note>
@@ -340,7 +340,7 @@
       </trans-unit>
       <trans-unit id="InvalidTerminalLoggerValue">
         <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
-        <target state="translated">MSBUILD : error MSB1065: –ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞. –≠—Ç–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ–¥–Ω–æ –∏–∑ —Å–ª–µ–¥—É—é—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π: "auto", "–ò–°–¢–ò–ù–ê" –∏–ª–∏ "–õ–û–ñ–¨". {0}</target>
+        <target state="translated">MSBUILD : error MSB1065: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞. –≠—Ç–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ–¥–Ω–æ –∏–∑ –∑–Ω–∞—á–µ–Ω–∏–π: "auto", "true" –∏–ª–∏ "false". {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1065: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1111,7 +1111,7 @@
     </source>
         <target state="translated">  -ignoreprojectextensions:&lt;—Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è&gt;
                      –°–ø–∏—Å–æ–∫ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º—ã—Ö —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏
-                     —Ç–∏–ø–∞ —Å–æ–∑–¥–∞–≤–∞–µ–º–æ–≥–æ —Ñ–∞–π–ª–∞ –ø—Ä–æ–µ–∫—Ç–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π –∏–ª–∏ –∑–∞–ø—è—Ç—É—é 
+                     —Ç–∏–ø–∞ —Å–æ–∑–¥–∞–≤–∞–µ–º–æ–≥–æ —Ñ–∞–π–ª–∞ –ø—Ä–æ–µ–∫—Ç–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π –∏–ª–∏ –∑–∞–ø—è—Ç—É—é
                      –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π.
                      (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -ignore)
                      –ü—Ä–∏–º–µ—Ä:
@@ -1138,7 +1138,7 @@
         <target state="translated">  -toolsversion:&lt;–≤–µ—Ä—Å–∏—è&gt;
                      –í–µ—Ä—Å–∏—è –Ω–∞–±–æ—Ä–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ MSBuild Toolset (–∑–∞–¥–∞—á–∏, —Ü–µ–ª–µ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã –∏ —Ç.¬†–¥.),
                      –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞ –ø—Ä–∏ —Å–±–æ—Ä–∫–µ. –≠—Ç–∞ –≤–µ—Ä—Å–∏—è –∑–∞–º–µ–Ω–∏—Ç
-                   –≤–µ—Ä—Å–∏–∏, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤. (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: 
+                   –≤–µ—Ä—Å–∏–∏, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤. (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞:
                      -tv)
                      –ü—Ä–∏–º–µ—Ä:
                        -toolsVersion:3.5
@@ -1197,7 +1197,7 @@
         <target state="translated">  -distributedFileLogger
           –í–Ω–æ—Å–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–±–æ—Ä–∫–∏ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤ –∂—É—Ä–Ω–∞–ª–∞, –ø–æ –æ–¥–Ω–æ–º—É —Ñ–∞–π–ª—É –∂—É—Ä–Ω–∞–ª–∞
                      –Ω–∞ —É–∑–µ–ª MSBuild. –ò—Å—Ö–æ–¥–Ω—ã–º —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ–º —ç—Ç–∏—Ö —Ñ–∞–π–ª–æ–≤ —è–≤–ª—è–µ—Ç—Å—è
-                     —Ç–µ–∫—É—â–∏–π –∫–∞—Ç–∞–ª–æ–≥. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ñ–∞–π–ª—ã –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è 
+                     —Ç–µ–∫—É—â–∏–π –∫–∞—Ç–∞–ª–æ–≥. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ñ–∞–π–ª—ã –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è
                      "MSBuild&lt;–∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É–∑–ª–∞ nodeid&gt;.log". –ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –∏
                      –¥—Ä—É–≥–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è fileLogger,
                     –¥–æ–±–∞–≤–∏–≤  –ø–∞—Ä–∞–º–µ—Ç—Ä "-fileLoggerParameters".
@@ -1248,7 +1248,7 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;–ø–∞—Ä–∞–º–µ—Ç—Ä—ã&gt;
                      –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –∂—É—Ä–Ω–∞–ª–æ–≤ —Ñ–∞–π–ª–æ–≤.
-                     –ù–∞–ª–∏—á–∏–µ —ç—Ç–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç –Ω–∞–ª–∏—á–∏–µ 
+                     –ù–∞–ª–∏—á–∏–µ —ç—Ç–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç –Ω–∞–ª–∏—á–∏–µ
                      —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ -fileLogger[n].
                      –ó–Ω–∞—á–µ–Ω–∏–µ "n" (–ø—Ä–∏ –µ–≥–æ –Ω–∞–ª–∏—á–∏–∏) –º–æ–∂–µ—Ç –±—ã—Ç—å —Ü–∏—Ñ—Ä–æ–π –æ—Ç 1 –¥–æ 9.
                      -fileLoggerParameters —Ç–∞–∫–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª—é–±—ã–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 8411c5408ba..6ced0b3e006 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -43,6 +43,17 @@
 using SimpleErrorLogger = Microsoft.Build.Logging.SimpleErrorLogger.SimpleErrorLogger;
 using TerminalLogger = Microsoft.Build.Logging.TerminalLogger.TerminalLogger;
 
+#if NETFRAMEWORK
+// Use I/O operations from Microsoft.IO.Redist which is generally higher perf
+// and also works around https://github.com/dotnet/msbuild/issues/10540.
+// Unnecessary on .NET 6+ because the perf improvements are in-box there.
+using Microsoft.IO;
+using Directory = Microsoft.IO.Directory;
+using File = Microsoft.IO.File;
+using FileInfo = Microsoft.IO.FileInfo;
+using Path = Microsoft.IO.Path;
+#endif
+
 #nullable disable
 
 namespace Microsoft.Build.CommandLine
@@ -684,7 +695,7 @@ public static ExitType Execute(
                 // process the detected command line switches -- gather build information, take action on non-build switches, and
                 // check for non-trivial errors
                 string projectFile = null;
-                string[] targets = Array.Empty<string>();
+                string[] targets = [];
                 string toolsVersion = null;
                 Dictionary<string, string> globalProperties = null;
                 Dictionary<string, string> restoreProperties = null;
@@ -717,9 +728,9 @@ public static ExitType Execute(
                 string outputResultsCache = null;
                 bool question = false;
                 bool isBuildCheckEnabled = false;
-                string[] getProperty = Array.Empty<string>();
-                string[] getItem = Array.Empty<string>();
-                string[] getTargetResult = Array.Empty<string>();
+                string[] getProperty = [];
+                string[] getItem = [];
+                string[] getTargetResult = [];
                 string getResultOutputFile = string.Empty;
                 BuildResult result = null;
 #if FEATURE_REPORTFILEACCESSES
@@ -1569,7 +1580,7 @@ internal static bool BuildProject(
 
                                 if (graphBuildOptions != null)
                                 {
-                                    graphBuildRequest = new GraphBuildRequestData(new[] { new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, flags, graphBuildOptions);
+                                    graphBuildRequest = new GraphBuildRequestData([new ProjectGraphEntryPoint(projectFile, globalProperties)], targets, null, flags, graphBuildOptions);
                                 }
                                 else
                                 {
@@ -1854,7 +1865,7 @@ private static BuildResult ExecuteRestore(string projectFile, string toolsVersio
                 projectFile,
                 restoreGlobalProperties,
                 toolsVersion,
-                targetsToBuild: new[] { MSBuildConstants.RestoreTargetName },
+                targetsToBuild: [MSBuildConstants.RestoreTargetName],
                 hostServices: null,
                 flags: flags);
 
@@ -2648,9 +2659,9 @@ private static bool ProcessCommandLineSwitches(
                     targets = ProcessTargetSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Target]);
 
                     // If we are looking for the value of a specific property or item post-evaluation or a target post-build, figure that out now
-                    getProperty = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetProperty] ?? Array.Empty<string>();
-                    getItem = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetItem] ?? Array.Empty<string>();
-                    getTargetResult = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetTargetResult] ?? Array.Empty<string>();
+                    getProperty = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetProperty] ?? [];
+                    getItem = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetItem] ?? [];
+                    getTargetResult = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetTargetResult] ?? [];
                     getResultOutputFile = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetResultOutputFile].FirstOrDefault() ?? string.Empty;
 
                     bool minimizeStdOutOutput = getProperty.Length + getItem.Length + getTargetResult.Length > 0 && getResultOutputFile.Length == 0;
@@ -3251,7 +3262,7 @@ private static ISet<string> ProcessWarningRelatedSwitch(CommandLineSwitches comm
             ISet<string> warningSwitches = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (string code in parameters
-                .SelectMany(parameter => parameter?.Split(s_commaSemicolon, StringSplitOptions.RemoveEmptyEntries) ?? new string[] { null }))
+                .SelectMany(parameter => parameter?.Split(s_commaSemicolon, StringSplitOptions.RemoveEmptyEntries) ?? [null]))
             {
                 if (code == null)
                 {
@@ -3526,7 +3537,7 @@ internal static string ProcessProjectSwitch(
             if (projectFile == null)
             {
                 ValidateExtensions(projectsExtensionsToIgnore);
-                HashSet<string> extensionsToIgnore = new HashSet<string>(projectsExtensionsToIgnore ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);
+                HashSet<string> extensionsToIgnore = new HashSet<string>(projectsExtensionsToIgnore ?? [], StringComparer.OrdinalIgnoreCase);
                 // Get all files in the current directory that have a proj-like extension
                 string[] potentialProjectFiles = getFiles(projectDirectory ?? ".", "*.*proj");
                 List<string> actualProjectFiles = new List<string>();
@@ -3541,8 +3552,8 @@ internal static string ProcessProjectSwitch(
                     }
                 }
 
-                // Get all files in the current directory that have a sln extension
-                string[] potentialSolutionFiles = getFiles(projectDirectory ?? ".", "*.sln");
+                // Get all files in the current directory that have a sln-like extension
+                string[] potentialSolutionFiles = getFiles(projectDirectory ?? ".", "*.sln?");
                 List<string> actualSolutionFiles = new List<string>();
                 List<string> solutionFilterFiles = new List<string>();
                 if (potentialSolutionFiles != null)
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 826e12a889e..7817604a16e 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -134,8 +134,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.4" newVersion="8.0.0.4" />
-          <codeBase version="8.0.0.4" href="..\System.Text.Json.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.5" newVersion="8.0.0.5" />
+          <codeBase version="8.0.0.5" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 084b86bb3a6..0931bf4a8ce 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -94,7 +94,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.4" newVersion="8.0.0.4" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.5" newVersion="8.0.0.5" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index bca1b949230..da3dae7bf0f 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -62,7 +62,7 @@
       <Link>IExtendedBuildEventArgs.cs</Link>
     </Compile>
     <Compile Include="..\Framework\AssemblyUtilities.cs" />
-    <Compile Include="..\Framework\NullableAttributes.cs" />
+    <Compile Include="..\Framework\Polyfills\*.cs" />
     <Compile Include="..\Framework\ResponseFileUsedEventArgs.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CollectionHelpers.cs" />
diff --git a/src/Package/DevDivPackage/DevDivPackage.csproj b/src/Package/DevDivPackage/DevDivPackage.csproj
index 83f231e362d..e4396d9d736 100644
--- a/src/Package/DevDivPackage/DevDivPackage.csproj
+++ b/src/Package/DevDivPackage/DevDivPackage.csproj
@@ -14,7 +14,6 @@
   <ItemGroup>
     <ProjectReference Include="..\..\MSBuild\MSBuild.csproj" />
     <ProjectReference Include="..\..\Framework\Microsoft.Build.Framework.csproj" />
-    <ProjectReference Include="..\..\Deprecated\Conversion\Microsoft.Build.Conversion.csproj" />
     <ProjectReference Include="..\..\Deprecated\Engine\Microsoft.Build.Engine.csproj" />
   </ItemGroup>
 
diff --git a/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec b/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
index 338a4620c27..2ca9b231420 100644
--- a/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
+++ b/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
@@ -22,7 +22,6 @@
 
     <!-- Obsolete but still referenced in the VS repo -->
     <file src="Microsoft.Build.Engine.dll" target="lib\net472" />
-    <file src="Microsoft.Build.Conversion.Core.dll" target="lib\net472" />
 
     <file src="Microsoft.Build.tlb" target="lib\net472" />
     <file src="Microsoft.Build.Framework.tlb" target="lib\net472" />
diff --git a/src/Package/GetBinPaths.targets b/src/Package/GetBinPaths.targets
index 961b4bf13d3..479cacfaaf2 100644
--- a/src/Package/GetBinPaths.targets
+++ b/src/Package/GetBinPaths.targets
@@ -19,11 +19,6 @@
                       ReferenceOutputAssembly="false"
                       OutputItemType="MSBuildTaskHostResolvedProjectReferencePath" />
 
-    <ProjectReference Include="$(MSBuildThisFileDirectory)\..\Deprecated\Conversion\Microsoft.Build.Conversion.csproj"
-                      Private="false"
-                      ReferenceOutputAssembly="false"
-                      OutputItemType="MSBuildConversionResolvedProjectReferencePath" />
-
     <!-- Set up items to build projects where the Platform is set to x64, when we need the x64 versions of the files.
          We have to treat these separately from normal project references, as the AssignProjectConfiguration task would overwrite
          the SetPlatform item metadata if they were ProjectReferences.
@@ -54,7 +49,6 @@
       <FrameworkBinPath>@(FrameworkResolvedProjectReferencePath->'%(RootDir)%(Directory)')</FrameworkBinPath>
       <MSBuildTaskHostBinPath>@(MSBuildTaskHostResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostBinPath>
       <MSBuildTaskHostX64BinPath>@(MSBuildTaskHostX64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostX64BinPath>
-      <MSBuildConversionBinPath>@(MSBuildConversionResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildConversionBinPath>
     </PropertyGroup>
   </Target>
 
diff --git a/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj b/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj
index fa17cd82f82..232272ae659 100644
--- a/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj
+++ b/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj
@@ -37,7 +37,6 @@
       <SwrProperty Include="FrameworkBinPath=$(FrameworkBinPath)" />
       <SwrProperty Include="TaskHostBinPath=$(MSBuildTaskHostBinPath)" />
       <SwrProperty Include="TaskHostX64BinPath=$(MSBuildTaskHostX64BinPath)" />
-      <SwrProperty Include="MSBuildConversionBinPath=$(MSBuildConversionBinPath)" />
     </ItemGroup>
   </Target>
 
diff --git a/src/Package/MSBuild.VSSetup/MSBuild.clientenabledpkg b/src/Package/MSBuild.VSSetup/MSBuild.clientenabledpkg
index 489e2745d8c..6720b9b4800 100644
--- a/src/Package/MSBuild.VSSetup/MSBuild.clientenabledpkg
+++ b/src/Package/MSBuild.VSSetup/MSBuild.clientenabledpkg
@@ -3,5 +3,4 @@ Microsoft.Build.pkgdef
 Microsoft.Build.Tasks.Core.pkgdef
 System.Resources.Extensions.pkgdef
 Microsoft.Build.Utilities.Core.pkgdef
-Microsoft.Build.Conversion.Core.pkgdef
 Microsoft.Build.Engine.pkgdef
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 211d1307c6f..8c90f12b740 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -26,9 +26,7 @@ folder InstallDir:\MSBuild\Current
   file source=$(ThirdPartyNotice)
 
 folder InstallDir:\MSBuild\Current\Bin
-  file source=$(MSBuildConversionBinPath)Microsoft.Build.Conversion.Core.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Build.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(MSBuildConversionBinPath)Microsoft.Build.Engine.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Build.Framework.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Build.Framework.tlb
   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -184,9 +182,7 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X64BinPath)MSBuild.exe.config
   file source=$(TaskHostX64BinPath)MSBuildTaskHost.exe.config
 
-  file source=$(MSBuildConversionBinPath)Microsoft.Build.Conversion.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Build.dll vs.file.ngenArchitecture=all
-  file source=$(MSBuildConversionBinPath)Microsoft.Build.Engine.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Build.Framework.dll vs.file.ngenArchitecture=all
   file source=$(FrameworkBinPath)x64\Microsoft.Build.Framework.tlb
   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=all
@@ -335,5 +331,4 @@ folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
   file source=$(SourceDir)Tasks\Microsoft.Build.Tasks.Core.pkgdef
   file source=$(SourceDir)Tasks\System.Resources.Extensions.pkgdef
   file source=$(SourceDir)Utilities\Microsoft.Build.Utilities.Core.pkgdef
-  file source=$(SourceDir)Deprecated\Conversion\Microsoft.Build.Conversion.Core.pkgdef
   file source=$(SourceDir)Deprecated\Engine\Microsoft.Build.Engine.pkgdef
diff --git a/src/Samples/Directory.Build.props b/src/Samples/Directory.Build.props
index f04411fb004..be310dc5e89 100644
--- a/src/Samples/Directory.Build.props
+++ b/src/Samples/Directory.Build.props
@@ -15,7 +15,7 @@
     <ImportDirectoryPackagesProps>false</ImportDirectoryPackagesProps>
 
     <IsShipping>false</IsShipping>
-    <ExcludeFromSourceBuild>true</ExcludeFromSourceBuild>
+    <ExcludeFromSourceOnlyBuild>true</ExcludeFromSourceOnlyBuild>
   </PropertyGroup>
 
 </Project>
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 314301eec05..d9d361df7ba 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -119,8 +119,8 @@ public override string ToString()
 
         public virtual int[] RetrieveHandshakeComponents()
         {
-            return new int[]
-            {
+            return
+            [
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
@@ -128,7 +128,7 @@ public virtual int[] RetrieveHandshakeComponents()
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)
-            };
+            ];
         }
 
         public virtual string GetKey() => $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}".ToString(CultureInfo.InvariantCulture);
@@ -152,15 +152,15 @@ internal ServerNodeHandshake(HandshakeOptions nodeType)
 
         public override int[] RetrieveHandshakeComponents()
         {
-            return new int[]
-            {
+            return
+            [
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
-            };
+            ];
         }
 
         public override string GetKey()
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 27bdb7e93e3..c1e3d664d3e 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -119,7 +119,7 @@ private Assembly TryGetWellKnownAssembly(AssemblyLoadContext context, AssemblyNa
             // of the Microsoft.Build.* assembly.
             assemblyName.Version = _currentAssemblyVersion;
 
-            var searchPaths = new[] { Assembly.GetExecutingAssembly().Location };
+            string[] searchPaths = [Assembly.GetExecutingAssembly().Location];
             return TryResolveAssemblyFromPaths(context, assemblyName, searchPaths);
         }
 
@@ -145,14 +145,14 @@ private Assembly TryResolveAssembly(AssemblyLoadContext context, AssemblyName as
 
         private Assembly TryResolveAssemblyFromPaths(AssemblyLoadContext context, AssemblyName assemblyName, IEnumerable<string> searchPaths)
         {
-            foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
+            foreach (string cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
                 ? new[] { string.Empty }
                 // Search for satellite assemblies in culture subdirectories
                 // of the assembly search directories, but fall back to the
                 // bare search directory if that fails.
-                : new[] { assemblyName.CultureName, string.Empty })
+                : [assemblyName.CultureName, string.Empty])
             {
                 foreach (var searchPath in searchPaths)
                 {
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index ea3b9735314..10afb6c4d4d 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -128,7 +128,7 @@ public void Log(
 #if DEBUG
             var writer = GetWriter();
 
-            writer?.Invoke(_id, CallsiteString(sourceFilePath, memberName, sourceLineNumber), new[] { message });
+            writer?.Invoke(_id, CallsiteString(sourceFilePath, memberName, sourceLineNumber), [message]);
 #endif
         }
 
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 43fb3d65d16..4cda8fc8a4e 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -231,7 +231,7 @@ private static IReadOnlyList<string> GetAccessibleFileSystemEntries(IFileSystem
                     ErrorUtilities.ThrowInternalError("Unexpected filesystem entity type.");
                     break;
             }
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -266,7 +266,7 @@ private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSyste
                 }
             }
 
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -354,12 +354,12 @@ private static IReadOnlyList<string> GetAccessibleFiles(
             catch (System.Security.SecurityException)
             {
                 // For code access security.
-                return Array.Empty<string>();
+                return [];
             }
             catch (System.UnauthorizedAccessException)
             {
                 // For OS security.
-                return Array.Empty<string>();
+                return [];
             }
         }
 
@@ -410,12 +410,12 @@ private static IReadOnlyList<string> GetAccessibleDirectories(
             catch (System.Security.SecurityException)
             {
                 // For code access security.
-                return Array.Empty<string>();
+                return [];
             }
             catch (System.UnauthorizedAccessException)
             {
                 // For OS security.
-                return Array.Empty<string>();
+                return [];
             }
         }
 
@@ -1042,7 +1042,7 @@ private IEnumerable<string> GetFilesForStep(
         {
             if (!stepResult.ConsiderFiles)
             {
-                return Enumerable.Empty<string>();
+                return [];
             }
 
             // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending
@@ -2340,18 +2340,18 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                     // - maintain legacy behaviour where an illegal filespec is treated as a normal string
                     if (FileUtilities.PathsEqual(filespecUnescaped, excludeSpec))
                     {
-                        return Array.Empty<string>();
+                        return [];
                     }
 
                     var match = Default.FileMatch(excludeSpec, filespecUnescaped);
 
                     if (match.isLegalFileSpec && match.isMatch)
                     {
-                        return Array.Empty<string>();
+                        return [];
                     }
                 }
             }
-            return new[] { filespecUnescaped };
+            return [filespecUnescaped];
         }
 
         /// <summary>
@@ -2377,7 +2377,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
 
             if (action == SearchAction.ReturnEmptyList)
             {
-                return (Array.Empty<string>(), action, string.Empty);
+                return ([], action, string.Empty);
             }
             else if (action == SearchAction.ReturnFileSpec)
             {
@@ -2385,7 +2385,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
             }
             else if (action == SearchAction.FailOnDriveEnumeratingWildcard)
             {
-                return (Array.Empty<string>(), action, string.Empty);
+                return ([], action, string.Empty);
             }
             else if ((action != SearchAction.RunSearch) && (action != SearchAction.LogDriveEnumeratingWildcard))
             {
@@ -2430,7 +2430,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                     }
                     else if (excludeAction == SearchAction.FailOnDriveEnumeratingWildcard)
                     {
-                        return (Array.Empty<string>(), excludeAction, excludeSpec);
+                        return ([], excludeAction, excludeSpec);
                     }
                     else if (excludeAction == SearchAction.LogDriveEnumeratingWildcard)
                     {
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index fe1b7c6e2b0..76dd5ee1f2d 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -91,27 +91,27 @@ public static bool GetIsFileSystemCaseSensitive()
         /// Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/dotnet/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-        internal static readonly char[] InvalidPathChars = new char[]
-        {
+        internal static readonly char[] InvalidPathChars =
+        [
             '|', '\0',
             (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10,
             (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20,
             (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30,
             (char)31
-        };
+        ];
 
         /// <summary>
         /// Copied from https://github.com/dotnet/corefx/blob/387cf98c410bdca8fd195b28cbe53af578698f94/src/System.Runtime.Extensions/src/System/IO/Path.Windows.cs#L18
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/dotnet/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-        internal static readonly char[] InvalidFileNameChars = new char[]
-        {
+        internal static readonly char[] InvalidFileNameChars =
+        [
             '\"', '<', '>', '|', '\0',
             (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10,
             (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20,
             (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30,
             (char)31, ':', '*', '?', '\\', '/'
-        };
+        ];
 
         internal static readonly char[] Slashes = { '/', '\\' };
 
@@ -361,7 +361,7 @@ internal static string TrimAndStripAnyQuotes(string path)
 
             // Trim returns the same string if trimming isn't needed
             path = path.Trim();
-            path = path.Trim(new char[] { '"' });
+            path = path.Trim(['"']);
 
             return path;
         }
@@ -1065,7 +1065,9 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
         /// </remarks>
         internal static bool IsSolutionFilename(string filename)
         {
-            return HasExtension(filename, ".sln") || HasExtension(filename, ".slnf");
+            return HasExtension(filename, ".sln") ||
+                   HasExtension(filename, ".slnf") ||
+                   HasExtension(filename, ".slnx");
         }
 
         internal static bool IsSolutionFilterFilename(string filename)
@@ -1073,6 +1075,11 @@ internal static bool IsSolutionFilterFilename(string filename)
             return HasExtension(filename, ".slnf");
         }
 
+        internal static bool IsSolutionXFilename(string filename)
+        {
+            return HasExtension(filename, ".slnx");
+        }
+
         /// <summary>
         /// Returns true if the specified filename is a VC++ project file, otherwise returns false
         /// </summary>
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 51d551eef38..4107d4b4197 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -148,8 +148,8 @@ internal static class FrameworkLocationHelper
         /// <summary>
         /// List the supported .net versions.
         /// </summary>
-        private static DotNetFrameworkSpec[] DotNetFrameworkSpecs() => new DotNetFrameworkSpec[]
-        {
+        private static DotNetFrameworkSpec[] DotNetFrameworkSpecs() =>
+        [
             // v1.1
             new DotNetFrameworkSpecLegacy(
                 dotNetFrameworkVersion11,
@@ -223,7 +223,7 @@ internal static class FrameworkLocationHelper
 
             // v4.8.1
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion481, visualStudioVersion170),
-        };
+        ];
 
         /// <summary>
         /// List the supported visual studio versions.
@@ -231,30 +231,30 @@ internal static class FrameworkLocationHelper
         /// <remarks>
         /// The items must be ordered by the version, because some methods depend on that fact to find the previous visual studio version.
         /// </remarks>
-        private static readonly Lazy<VisualStudioSpec[]> VisualStudioSpecs = new(() => new VisualStudioSpec[]
-        {
+        private static readonly Lazy<VisualStudioSpec[]> VisualStudioSpecs = new(() =>
+        [
             // VS10
-            new VisualStudioSpec(visualStudioVersion100, "Windows\\v7.0A", null, null, new []
-            {
+            new VisualStudioSpec(visualStudioVersion100, "Windows\\v7.0A", null, null,
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
                 dotNetFrameworkVersion40,
-            }),
+            ]),
 
             // VS11
-            new VisualStudioSpec(visualStudioVersion110, "Windows\\v8.0A", "v8.0", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion110, "Windows\\v8.0A", "v8.0", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
                 dotNetFrameworkVersion40,
                 dotNetFrameworkVersion45,
-            }),
+            ]),
 
             // VS12
-            new VisualStudioSpec(visualStudioVersion120, "Windows\\v8.1A", "v8.1", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion120, "Windows\\v8.1A", "v8.1", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -262,11 +262,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion45,
                 dotNetFrameworkVersion451,
                 dotNetFrameworkVersion452,
-            }),
+            ]),
 
             // VS14
-            new VisualStudioSpec(visualStudioVersion140, "NETFXSDK\\{0}", "v8.1", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion140, "NETFXSDK\\{0}", "v8.1", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -276,11 +276,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion452,
                 dotNetFrameworkVersion46,
                 dotNetFrameworkVersion461,
-            }),
+            ]),
 
             // VS15
-            new VisualStudioSpec(visualStudioVersion150, "NETFXSDK\\{0}", "v8.1", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion150, "NETFXSDK\\{0}", "v8.1", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -295,11 +295,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion471,
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
-            }),
+            ]),
 
             // VS16
-            new VisualStudioSpec(visualStudioVersion160, "NETFXSDK\\{0}", "v10.0", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion160, "NETFXSDK\\{0}", "v10.0", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -314,11 +314,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion471,
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
-            }),
+            ]),
 
             // VS17
-            new VisualStudioSpec(visualStudioVersion170, "NETFXSDK\\{0}", "v10.0", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion170, "NETFXSDK\\{0}", "v10.0", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -334,8 +334,8 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
                 dotNetFrameworkVersion481,
-            }),
-        });
+            ]),
+        ]);
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 4caf4874652..650b62c2a1b 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -244,6 +244,11 @@ internal enum LoggingEventType : int
         /// Event is <see cref="BuildSubmissionStartedEventArgs"/>.
         /// </summary>
         BuildSubmissionStartedEvent = 40,
+
+        /// <summary>
+        /// Event is <see cref="BuildCanceledEventArgs"/>
+        /// </summary>
+        BuildCanceledEvent = 41,
     }
     #endregion
 
@@ -656,6 +661,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.BuildCheckTracingEvent => new BuildCheckTracingEventArgs(),
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
                 LoggingEventType.BuildSubmissionStartedEvent => new BuildSubmissionStartedEventArgs(),
+                LoggingEventType.BuildCanceledEvent => new BuildCanceledEventArgs("Build canceled."),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -799,6 +805,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildSubmissionStartedEvent;
             }
+            else if (eventType == typeof(BuildCanceledEventArgs))
+            {
+                return LoggingEventType.BuildCanceledEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
@@ -1414,7 +1424,7 @@ private IEnumerable ReadProperties(ITranslator translator)
             int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
             if (count == 0)
             {
-                return Enumerable.Empty<DictionaryEntry>();
+                return (DictionaryEntry[])[];
             }
 
             var list = new ArrayList(count);
@@ -1436,7 +1446,7 @@ private IEnumerable ReadItems(ITranslator translator)
             int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
             if (count == 0)
             {
-                return Enumerable.Empty<DictionaryEntry>();
+                return (DictionaryEntry[])[];
             }
 
             var list = new ArrayList(count);
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index e2ebdff4f85..7427c5ed735 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -22,14 +22,13 @@ internal class MSBuildLoadContext : AssemblyLoadContext
         private readonly string _directory;
 
         internal static readonly ImmutableHashSet<string> WellKnownAssemblyNames =
-            new[]
-            {
-                "MSBuild",
-                "Microsoft.Build",
-                "Microsoft.Build.Framework",
-                "Microsoft.Build.Tasks.Core",
-                "Microsoft.Build.Utilities.Core",
-            }.ToImmutableHashSet();
+        [
+            "MSBuild",
+            "Microsoft.Build",
+            "Microsoft.Build.Framework",
+            "Microsoft.Build.Tasks.Core",
+            "Microsoft.Build.Utilities.Core",
+        ];
 
         public MSBuildLoadContext(string assemblyPath)
             : base($"MSBuild plugin {assemblyPath}")
@@ -69,11 +68,11 @@ public MSBuildLoadContext(string assemblyPath)
             foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
-                ? new[] { string.Empty }
+                ? (string[])[string.Empty]
                 // Search for satellite assemblies in culture subdirectories
                 // of the assembly search directories, but fall back to the
                 // bare search directory if that fails.
-                : new[] { assemblyName.CultureName, string.Empty })
+                : [assemblyName.CultureName, string.Empty])
             {
                 var candidatePath = Path.Combine(_directory,
                     cultureSubfolder,
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 8783318b2e5..55cfb842bdf 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -531,13 +531,15 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
             {
                 // Ordering is important.  We want packetAvailable to supercede terminate otherwise we will not properly wait for all
                 // packets to be sent by other threads which are shutting down, such as the logging thread.
-                WaitHandle[] handles = new WaitHandle[] {
+                WaitHandle[] handles =
+                [
 #if FEATURE_APM
                     result.AsyncWaitHandle,
 #else
                     ((IAsyncResult)readTask).AsyncWaitHandle,
 #endif
-                    localPacketAvailable, localTerminatePacketPump };
+                    localPacketAvailable, localTerminatePacketPump
+                ];
 
                 int waitId = WaitHandle.WaitAny(handles);
                 switch (waitId)
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index deaf884e4d5..58e02e85616 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -135,9 +135,7 @@ internal static string ExtractMessageCode(bool msbuildCodeOnly, string message,
         /// <param name="resourceName">Resource string to get the MSBuild F1-keyword for.</param>
         /// <returns>The MSBuild F1-help keyword string.</returns>
         private static string GetHelpKeyword(string resourceName)
-        {
-            return "MSBuild." + resourceName;
-        }
+            => "MSBuild." + resourceName;
 
 #if !BUILDINGAPPXTASKS
         /// <summary>
@@ -146,17 +144,14 @@ private static string GetHelpKeyword(string resourceName)
         /// <param name="resourceName">Resource string name.</param>
         /// <returns>Resource string contents.</returns>
         internal static string GetResourceString(string resourceName)
-        {
-            string result = AssemblyResources.GetString(resourceName);
-            return result;
-        }
+            => AssemblyResources.GetString(resourceName);
 
         /// <summary>
         /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they too are returned.
         ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
-        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios.
         /// </summary>
         /// <remarks>This method is thread-safe.</remarks>
         /// <param name="code">[out] The MSBuild message code, or null.</param>
@@ -172,6 +167,68 @@ internal static string FormatResourceStringStripCodeAndKeyword(out string code,
             return ExtractMessageCode(true /* msbuildCodeOnly */, FormatString(GetResourceString(resourceName), args), out code);
         }
 
+        // Overloads with 0-3 arguments to avoid array allocations.
+
+        /// <summary>
+        /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they too are returned.
+        /// </summary>
+        /// <remarks>This method is thread-safe.</remarks>
+        /// <param name="code">[out] The MSBuild message code, or null.</param>
+        /// <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName)
+        {
+            helpKeyword = GetHelpKeyword(resourceName);
+            return ExtractMessageCode(true, GetResourceString(resourceName), out code);
+        }
+
+        /// <summary>
+        /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they too are returned.
+        /// </summary>
+        /// <param name="code">[out] The MSBuild message code, or null.</param>
+        /// <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">Argument for formatting the resource string.</param>
+        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName, object arg1)
+        {
+            helpKeyword = GetHelpKeyword(resourceName);
+            return ExtractMessageCode(true, FormatString(GetResourceString(resourceName), arg1), out code);
+        }
+
+        /// <summary>
+        /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they too are returned.
+        /// </summary>
+        /// <param name="code">[out] The MSBuild message code, or null.</param>
+        /// <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName, object arg1, object arg2)
+        {
+            helpKeyword = GetHelpKeyword(resourceName);
+            return ExtractMessageCode(true, FormatString(GetResourceString(resourceName), arg1, arg2), out code);
+        }
+
+        /// <summary>
+        /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they too are returned.
+        /// </summary>
+        /// <param name="code">[out] The MSBuild message code, or null.</param>
+        /// <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        /// <param name="arg3">Third argument for formatting the resource string.</param>
+        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName, object arg1, object arg2, object arg3)
+        {
+            helpKeyword = GetHelpKeyword(resourceName);
+            return ExtractMessageCode(true, FormatString(GetResourceString(resourceName), arg1, arg2, arg3), out code);
+        }
+
         [Obsolete("Use GetResourceString instead.", true)]
         [EditorBrowsable(EditorBrowsableState.Never)]
         internal static string FormatResourceString(string resourceName)
@@ -184,32 +241,117 @@ internal static string FormatResourceString(string resourceName)
         /// message code and help keyword associated with it, they are discarded.
         ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
-        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios.
         /// </summary>
         /// <remarks>This method is thread-safe.</remarks>
         /// <param name="resourceName">Resource string to load.</param>
         /// <param name="args">Optional arguments for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
         internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, params object[] args)
-        {
-            string code;
-            string helpKeyword;
+            => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, args);
 
-            return FormatResourceStringStripCodeAndKeyword(out code, out helpKeyword, resourceName, args);
-        }
+        // Overloads with 0-3 arguments to avoid array allocations.
+
+        /// <summary>
+        /// Looks up a string in the resources. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they are discarded.
+        /// </summary>
+        /// <remarks>This method is thread-safe.</remarks>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName)
+           => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName);
+
+        /// <summary>
+        /// Looks up a string in the resources, and formats it with the argument passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they are discarded.
+        /// </summary>
+        /// <remarks>This method is thread-safe.</remarks>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">Argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object arg1)
+           => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, arg1);
+
+        /// <summary>
+        /// Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they are discarded.
+        /// </summary>
+        /// <remarks>This method is thread-safe.</remarks>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object arg1, object arg2)
+            => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, arg1, arg2);
+
+        /// <summary>
+        /// Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they are discarded.
+        /// </summary>
+        /// <remarks>This method is thread-safe.</remarks>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        /// <param name="arg3">Third argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object arg1, object arg2, object arg3)
+            => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, arg1, arg2, arg3);
 
         /// <summary>
         /// Formats the resource string with the given arguments.
-        /// Ignores error codes and keywords
+        /// Ignores error codes and keywords.
         /// </summary>
-        /// <param name="resourceName"></param>
-        /// <param name="args"></param>
-        /// <returns></returns>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="args">Optional arguments for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        /// <remarks>the AssemblyResources.GetString() method is thread-safe.</remarks>
         internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, params object[] args)
-        {
-            // NOTE: the AssemblyResources.GetString() method is thread-safe
-            return FormatString(GetResourceString(resourceName), args);
-        }
+            => FormatString(GetResourceString(resourceName), args);
+
+        // Overloads with 0-3 arguments to avoid array allocations.
+
+        /// <summary>
+        /// Formats the resource string.
+        /// Ignores error codes and keywords.
+        /// </summary>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName)
+            => GetResourceString(resourceName);
+
+        /// <summary>
+        /// Formats the resource string with the given argument.
+        /// Ignores error codes and keywords.
+        /// </summary>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">Argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object arg1)
+            => FormatString(GetResourceString(resourceName), arg1);
+
+        /// <summary>
+        /// Formats the resource string with the given arguments.
+        /// Ignores error codes and keywords.
+        /// </summary>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object arg1, object arg2)
+            => FormatString(GetResourceString(resourceName), arg1, arg2);
+
+        /// <summary>
+        /// Formats the resource string with the given arguments.
+        /// Ignores error codes and keywords.
+        /// </summary>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        /// <param name="arg3">Third argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object arg1, object arg2, object arg3)
+            => FormatString(GetResourceString(resourceName), arg1, arg2, arg3);
 
         /// <summary>
         /// Formats the given string using the variable arguments passed in.
@@ -227,33 +369,80 @@ internal static string FormatString(string unformatted, params object[] args)
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args?.Length > 0))
+            if (args?.Length > 0)
             {
-#if DEBUG
-                // If you accidentally pass some random type in that can't be converted to a string,
-                // FormatResourceString calls ToString() which returns the full name of the type!
-                foreach (object param in args)
-                {
-                    // Check it has a real implementation of ToString() and the type is not actually System.String
-                    if (param != null)
-                    {
-                        if (string.Equals(param.GetType().ToString(), param.ToString(), StringComparison.Ordinal) &&
-                            param.GetType() != typeof(string))
-                        {
-                            ErrorUtilities.ThrowInternalError("Invalid resource parameter type, was {0}",
-                                param.GetType().FullName);
-                        }
-                    }
-                }
-#endif
+                ValidateArgsIfDebug(args);
+
                 // Format the string, using the variable arguments passed in.
                 // NOTE: all String methods are thread-safe
-                formatted = String.Format(CultureInfo.CurrentCulture, unformatted, args);
+                formatted = string.Format(CultureInfo.CurrentCulture, unformatted, args);
             }
 
             return formatted;
         }
 
+        // Overloads with 1-3 arguments to avoid array allocations.
+
+        /// <summary>
+        /// Formats the given string using the variable arguments passed in.
+        /// </summary>
+        /// <param name="unformatted">The string to format.</param>
+        /// <param name="arg1">Argument for formatting the given string.</param>
+        /// <returns>The formatted string.</returns>
+        internal static string FormatString(string unformatted, object arg1)
+        {
+            ValidateArgsIfDebug([arg1]);
+            return string.Format(CultureInfo.CurrentCulture, unformatted, arg1);
+        }
+
+        /// <summary>
+        /// Formats the given string using the variable arguments passed in.
+        /// </summary>
+        /// <param name="unformatted">The string to format.</param>
+        /// <param name="arg1">First argument for formatting the given string.</param>
+        /// <param name="arg2">Second argument for formatting the given string.</param>
+        /// <returns>The formatted string.</returns>
+        internal static string FormatString(string unformatted, object arg1, object arg2)
+        {
+            ValidateArgsIfDebug([arg1, arg2]);
+            return string.Format(CultureInfo.CurrentCulture, unformatted, arg1, arg2);
+        }
+
+        /// <summary>
+        /// Formats the given string using the variable arguments passed in.
+        /// </summary>
+        /// <param name="unformatted">The string to format.</param>
+        /// <param name="arg1">First argument for formatting the given string.</param>
+        /// <param name="arg2">Second argument for formatting the given string.</param>
+        /// <param name="arg3">Third argument for formatting the given string.</param>
+        /// <returns>The formatted string.</returns>
+        internal static string FormatString(string unformatted, object arg1, object arg2, object arg3)
+        {
+            ValidateArgsIfDebug([arg1, arg2, arg3]);
+            return string.Format(CultureInfo.CurrentCulture, unformatted, arg1, arg2, arg3);
+        }
+
+        [Conditional("DEBUG")]
+        private static void ValidateArgsIfDebug(object[] args)
+        {
+            // If you accidentally pass some random type in that can't be converted to a string,
+            // FormatResourceString calls ToString() which returns the full name of the type!
+            foreach (object param in args)
+            {
+                // Check it has a real implementation of ToString() and the type is not actually System.String
+                if (param != null)
+                {
+                    if (string.Equals(param.GetType().ToString(), param.ToString(), StringComparison.Ordinal) &&
+                        param.GetType() != typeof(string))
+                    {
+                        ErrorUtilities.ThrowInternalError(
+                            "Invalid resource parameter type, was {0}",
+                            param.GetType().FullName);
+                    }
+                }
+            }
+        }
+
         /// <summary>
         /// Verifies that a particular resource string actually exists in the string table. This will only be called in debug
         /// builds. It helps catch situations where a dev calls VerifyThrowXXX with a new resource string, but forgets to add the
diff --git a/src/Shared/StrongNameHelpers.cs b/src/Shared/StrongNameHelpers.cs
index ac9476181eb..b6ba9a50cc3 100644
--- a/src/Shared/StrongNameHelpers.cs
+++ b/src/Shared/StrongNameHelpers.cs
@@ -45,11 +45,10 @@ private static IClrStrongName StrongName
                     if (s_GetRuntimeInterfaceAsObjectMethod != null)
                     {
                         s_StrongName = (IClrStrongName)s_GetRuntimeInterfaceAsObjectMethod.Invoke(null,
-                            new object[]
-                            {
+                            [
                                 new Guid("B79B0ACD-F5CD-409b-B5A5-A16244610B92"),
                                 new Guid("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")
-                            });
+                            ]);
                     }
                 }
                 return s_StrongName;
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 9a9c199f732..723a4ba240b 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -417,27 +417,20 @@ public void Translate(ITranslator translator)
             translator.TranslateCulture(ref _culture);
             translator.TranslateCulture(ref _uiCulture);
 #if FEATURE_APPDOMAIN
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
-            {
-                byte[] appDomainConfigBytes = null;
+            byte[] appDomainConfigBytes = null;
 
-                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
-                if (translator.Mode == TranslationDirection.WriteToStream)
-                {
-                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
-                }
+            // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+            }
 
-                translator.Translate(ref appDomainConfigBytes);
+            translator.Translate(ref appDomainConfigBytes);
 
-                if (translator.Mode == TranslationDirection.ReadFromStream)
-                {
-                    _appDomainSetup = new AppDomainSetup();
-                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
-                }
-            }
-            else
+            if (translator.Mode == TranslationDirection.ReadFromStream)
             {
-                translator.TranslateDotNet(ref _appDomainSetup);
+                _appDomainSetup = new AppDomainSetup();
+                _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
             }
 #endif
             translator.Translate(ref _lineNumberOfTask);
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 187a7a43e4b..79e0ea37008 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -1003,12 +1003,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
             {
                 if (_customEscapedMetadata == null || _customEscapedMetadata.Count == 0)
                 {
-#if TASKHOST
-                    // MSBuildTaskHost.dll compiles against .NET 3.5 which doesn't have Enumerable.Empty()
-                    return new KeyValuePair<string, string>[0];
-#else
-                    return Enumerable.Empty<KeyValuePair<string, string>>();
-#endif
+                    return [];
                 }
 
                 var result = new KeyValuePair<string, string>[_customEscapedMetadata.Count];
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 0b587df5b74..d1872e4fb39 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -356,17 +356,17 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
             commandLine.AppendSwitchIfNotNull("/win32icon:", Win32Icon);
             commandLine.AppendSwitchIfNotNull("/win32res:", Win32Resource);
 
-            commandLine.AppendSwitchIfNotNull("", SourceModules, new[] { "TargetFile" });
+            commandLine.AppendSwitchIfNotNull("", SourceModules, ["TargetFile"]);
 
             commandLine.AppendSwitchIfNotNull(
                 "/embed:",
                 EmbedResources,
-                new[] { "LogicalName", "Access" });
+                ["LogicalName", "Access"]);
 
             commandLine.AppendSwitchIfNotNull(
                 "/link:",
                 LinkResources,
-                new[] { "LogicalName", "TargetFile", "Access" });
+                ["LogicalName", "TargetFile", "Access"]);
 
             // It's a good idea for the response file to be the very last switch passed, just
             // from a predictability perspective.  This is also consistent with the compiler
diff --git a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
index d9803997df2..b7352e6b255 100644
--- a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
+++ b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
@@ -140,7 +140,7 @@ internal IEnumerable<AssemblyEntry> FindAssemblyNameFromSimpleName(string simple
         {
             if (_redistList == null)
             {
-                return Enumerable.Empty<AssemblyEntry>();
+                return [];
             }
 
             return _redistList.FindAssemblyNameFromSimpleName(simpleName);
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index 5819184dc59..d9ba3671e32 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -40,7 +40,7 @@ internal sealed class Reference
         /// <summary>
         /// Scatter files associated with this reference.
         /// </summary>
-        private string[] _scatterFiles = Array.Empty<string>();
+        private string[] _scatterFiles = [];
 
         /// <summary>
         /// Any errors that occurred while resolving or finding dependencies on this item.
@@ -258,7 +258,7 @@ internal void AttachScatterFiles(string[] scatterFilesToAttach)
         {
             if (scatterFilesToAttach == null || scatterFilesToAttach.Length == 0)
             {
-                _scatterFiles = Array.Empty<string>();
+                _scatterFiles = [];
             }
             else
             {
@@ -500,7 +500,7 @@ internal string FullPath
 
                     if (string.IsNullOrEmpty(_fullPath))
                     {
-                        _scatterFiles = Array.Empty<string>();
+                        _scatterFiles = [];
                         _satelliteFiles = new List<string>();
                         _serializationAssemblyFiles = new List<string>();
                         AssembliesConsideredAndRejected = new List<ResolutionSearchLocation>();
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index b8cf7e10aa4..e353f56470a 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -46,7 +46,7 @@ internal sealed class ReferenceTable
         private readonly Dictionary<string, AssemblyNameExtension> _externallyResolvedImmutableFiles = new Dictionary<string, AssemblyNameExtension>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>The table of remapped assemblies. Used for Unification.</summary>
-        private IEnumerable<DependentAssembly> _remappedAssemblies = Enumerable.Empty<DependentAssembly>();
+        private IEnumerable<DependentAssembly> _remappedAssemblies = [];
 
         /// <summary>If true, then search for dependencies.</summary>
         private readonly bool _findDependencies;
@@ -817,7 +817,7 @@ private static void TryGetAssemblyNameComponent(string fusionName, string compon
                 return;
             }
             position += component.Length + 1;
-            int nextDelimiter = fusionName.IndexOfAny(new[] { ',', ' ' }, position);
+            int nextDelimiter = fusionName.IndexOfAny([',', ' '], position);
             if (nextDelimiter == -1)
             {
                 value = fusionName.Substring(position);
@@ -1290,7 +1290,7 @@ private void ResolveReference(
             // If a reference has the SDKName metadata on it then we will only search using a single resolver, that is the InstalledSDKResolver.
             if (reference.SDKName.Length > 0)
             {
-                jaggedResolvers.Add(new Resolver[] { new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _getRuntimeVersion, _targetedRuntimeVersion) });
+                jaggedResolvers.Add([new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _getRuntimeVersion, _targetedRuntimeVersion)]);
             }
             else
             {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 75ea877da61..a0f8ea6bb75 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -175,11 +175,11 @@ internal static void Initialize(TaskLoggingHelper log)
         private ITaskItem[] _resolvedSDKReferences = Array.Empty<TaskItem>();
         private bool _ignoreDefaultInstalledAssemblyTables = false;
         private bool _ignoreDefaultInstalledAssemblySubsetTables = false;
-        private string[] _candidateAssemblyFiles = Array.Empty<string>();
-        private string[] _targetFrameworkDirectories = Array.Empty<string>();
-        private string[] _searchPaths = Array.Empty<string>();
-        private string[] _allowedAssemblyExtensions = new string[] { ".winmd", ".dll", ".exe" };
-        private string[] _relatedFileExtensions = new string[] { ".pdb", ".xml", ".pri" };
+        private string[] _candidateAssemblyFiles = [];
+        private string[] _targetFrameworkDirectories = [];
+        private string[] _searchPaths = [];
+        private string[] _allowedAssemblyExtensions = [".winmd", ".dll", ".exe"];
+        private string[] _relatedFileExtensions = [".pdb", ".xml", ".pri"];
         private string _appConfigFile = null;
         private bool _supportsBindingRedirectGeneration;
         private bool _autoUnify = false;
@@ -194,8 +194,8 @@ internal static void Initialize(TaskLoggingHelper log)
         private ITaskItem[] _copyLocalFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _suggestedRedirects = Array.Empty<TaskItem>();
         private List<ITaskItem> _unresolvedConflicts = new List<ITaskItem>();
-        private string[] _targetFrameworkSubsets = Array.Empty<string>();
-        private string[] _fullTargetFrameworkSubsetNames = Array.Empty<string>();
+        private string[] _targetFrameworkSubsets = [];
+        private string[] _fullTargetFrameworkSubsetNames = [];
         private string _targetedFrameworkMoniker = String.Empty;
 
         private bool _findDependencies = true;
@@ -211,8 +211,8 @@ internal static void Initialize(TaskLoggingHelper log)
         private string _targetProcessorArchitecture = null;
 
         private string _profileName = String.Empty;
-        private string[] _fullFrameworkFolders = Array.Empty<string>();
-        private string[] _latestTargetFrameworkDirectories = Array.Empty<string>();
+        private string[] _fullFrameworkFolders = [];
+        private string[] _latestTargetFrameworkDirectories = [];
         private bool _copyLocalDependenciesWhenParentReferenceInGac = true;
         private Dictionary<string, MessageImportance> _showAssemblyFoldersExLocations = new Dictionary<string, MessageImportance>(StringComparer.OrdinalIgnoreCase);
         private bool _logVerboseSearchResults = false;
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index e1923c87f9d..2b996326fc5 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -429,7 +429,7 @@ private List<string> ExtractReferencedAssemblies()
             {
                 XmlAttribute attribute = referenceNodes[i].Attributes["Include"];
 
-                bool hasInvalidChildNodes = HasInvalidChildNodes(referenceNodes[i], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace });
+                bool hasInvalidChildNodes = HasInvalidChildNodes(referenceNodes[i], [XmlNodeType.Comment, XmlNodeType.Whitespace]);
 
                 if (hasInvalidChildNodes)
                 {
@@ -459,7 +459,7 @@ private List<string> ExtractUsingNamespaces()
             var usings = new List<string>();
             for (int i = 0; i < usingNodes.Count; i++)
             {
-                bool hasInvalidChildNodes = HasInvalidChildNodes(usingNodes[i], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace });
+                bool hasInvalidChildNodes = HasInvalidChildNodes(usingNodes[i], [XmlNodeType.Comment, XmlNodeType.Whitespace]);
 
                 if (hasInvalidChildNodes)
                 {
@@ -509,7 +509,7 @@ private XmlNode ExtractTaskContent(string taskElementContents)
                 return null;
             }
 
-            bool hasInvalidChildNodes = HasInvalidChildNodes(codeNodes[0], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace, XmlNodeType.Text, XmlNodeType.CDATA });
+            bool hasInvalidChildNodes = HasInvalidChildNodes(codeNodes[0], [XmlNodeType.Comment, XmlNodeType.Whitespace, XmlNodeType.Text, XmlNodeType.CDATA]);
 
             if (hasInvalidChildNodes)
             {
diff --git a/src/Tasks/CreateProperty.cs b/src/Tasks/CreateProperty.cs
index 7980feb2d14..d077411d58c 100644
--- a/src/Tasks/CreateProperty.cs
+++ b/src/Tasks/CreateProperty.cs
@@ -59,7 +59,7 @@ public override bool Execute()
         {
             if (Value == null)
             {
-                Value = Array.Empty<string>();
+                Value = [];
             }
 
             return true;
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index e37a9bcf300..aed8b824d4f 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -31,7 +31,7 @@ internal static class CultureInfoCache
         // These pseudo-locales are available in versions of Windows from Vista and later.
         // However, from Windows 10, version 1803, they are not returned when enumerating the
         // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.
-        private static readonly string[] pseudoLocales = new[] { "qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh" };
+        private static readonly string[] pseudoLocales = ["qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh"];
 
         private static HashSet<string> InitializeValidCultureNames()
         {
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index faa3df5e80e..67d44af7c62 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -579,7 +579,7 @@ private void LogResgenCommandLine(List<ITaskItem> inputFiles, List<ITaskItem> ou
                     if (!ExtractResWFiles)
                     {
                         commandLineBuilder.AppendFileNamesIfNotNull(
-                            new string[] { inputFiles[i].ItemSpec, outputFiles[i].ItemSpec },
+                            [inputFiles[i].ItemSpec, outputFiles[i].ItemSpec],
                             ",");
                     }
                     else
@@ -597,7 +597,7 @@ private void LogResgenCommandLine(List<ITaskItem> inputFiles, List<ITaskItem> ou
                 // append the strongly-typed resource details
                 commandLineBuilder.AppendSwitchIfNotNull(
                     "/str:",
-                    new string[] { StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName },
+                    [StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName],
                     ",");
             }
 
@@ -1238,7 +1238,7 @@ private int CalculateResourceBatchSize(List<ITaskItem> inputsToProcess, List<ITa
             while (currentCommand.Length < s_maximumCommandLength && i < inputsToProcess.Count)
             {
                 currentCommand.AppendFileNamesIfNotNull(
-                        new ITaskItem[] { inputsToProcess[i], outputsToProcess[i] },
+                        [inputsToProcess[i], outputsToProcess[i]],
                         ",");
                 i++;
             }
@@ -1705,7 +1705,7 @@ private void UpdateNewestUncorrelatedInputWriteTime()
 
             // Check the timestamp of each of the passed-in references to find the newest;
             // and then the additional inputs
-            var inputs = (this.References ?? Enumerable.Empty<ITaskItem>()).Concat(this.AdditionalInputs ?? Enumerable.Empty<ITaskItem>());
+            ITaskItem[] inputs = this.References ?? [..(this.AdditionalInputs ?? [])];
 
             foreach (ITaskItem input in inputs)
             {
@@ -2020,7 +2020,7 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
         /// <summary>
         /// Chars that should be ignored in the nicely justified block of base64
         /// </summary>
-        private static readonly char[] s_specialChars = new char[] { ' ', '\r', '\n' };
+        private static readonly char[] s_specialChars = [' ', '\r', '\n'];
 
         /// <summary>
         /// Turns the nicely justified block of base64 found in a resx into a byte array.
diff --git a/src/Tasks/GetAssembliesMetadata.cs b/src/Tasks/GetAssembliesMetadata.cs
index 520b979be03..73a3877001f 100644
--- a/src/Tasks/GetAssembliesMetadata.cs
+++ b/src/Tasks/GetAssembliesMetadata.cs
@@ -32,7 +32,7 @@ public class GetAssembliesMetadata : TaskExtension
         /// <summary>
         /// Assembly paths.
         /// </summary>
-        private string[] _assemblyPaths = Array.Empty<string>();
+        private string[] _assemblyPaths = [];
 
         /// <summary>
         /// Set of resolved assembly metadata.
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index e1d4bb966e7..05aa5d2a30f 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -169,8 +169,8 @@ public override bool Execute()
                     item.SetMetadata("PlatformVersion", sdk.Value.Item2);
 
                     // Need to stash these so we can unroll the platform via GetMatchingPlatformSDK when we get the reference files for the sdks
-                    item.SetMetadata(DirectoryRootsMetadataName, String.Join(";", SDKDirectoryRoots ?? Array.Empty<string>()));
-                    item.SetMetadata(ExtensionDirectoryRootsMetadataName, String.Join(";", SDKExtensionDirectoryRoots ?? Array.Empty<string>()));
+                    item.SetMetadata(DirectoryRootsMetadataName, String.Join(";", SDKDirectoryRoots ?? []));
+                    item.SetMetadata(ExtensionDirectoryRootsMetadataName, String.Join(";", SDKExtensionDirectoryRoots ?? []));
                     item.SetMetadata(RegistryRootMetadataName, SDKRegistryRoot);
 
                     outputItems.Add(item);
diff --git a/src/Tasks/GetReferenceAssemblyPaths.cs b/src/Tasks/GetReferenceAssemblyPaths.cs
index 621291acdac..50e3f54d4c4 100644
--- a/src/Tasks/GetReferenceAssemblyPaths.cs
+++ b/src/Tasks/GetReferenceAssemblyPaths.cs
@@ -65,7 +65,7 @@ public string[] ReferenceAssemblyPaths
                 }
                 else
                 {
-                    return Array.Empty<string>();
+                    return [];
                 }
             }
         }
@@ -87,7 +87,7 @@ public string[] FullFrameworkReferenceAssemblyPaths
                 }
                 else
                 {
-                    return Array.Empty<string>();
+                    return [];
                 }
             }
         }
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 2af5faaf3b8..b1a24a00d6a 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -1168,7 +1168,7 @@ private static IEnumerable<string> GetAllRedistDirectories(string sdkRoot)
                     return Directory.GetDirectories(redistPath, "*", SearchOption.AllDirectories);
                 }
 
-                return Enumerable.Empty<string>();
+                return [];
             }
 
             /// <summary>
@@ -1182,7 +1182,7 @@ private static IEnumerable<string> GetAllReferenceDirectories(string sdkRoot)
                     return Directory.GetDirectories(referencesPath, "*", SearchOption.AllDirectories);
                 }
 
-                return Enumerable.Empty<string>();
+                return [];
             }
         }
 
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index d1d6f8f7bc6..0bc42f56bfe 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -26,7 +26,7 @@ public class Hash : TaskExtension
     {
         private const char ItemSeparatorCharacter = '\u2028';
         private static readonly Encoding s_encoding = Encoding.UTF8;
-        private static readonly byte[] s_itemSeparatorCharacterBytes = s_encoding.GetBytes(new char[] { ItemSeparatorCharacter });
+        private static readonly byte[] s_itemSeparatorCharacterBytes = s_encoding.GetBytes([ItemSeparatorCharacter]);
 
         // Size of buffer where bytes of the strings are stored until sha.TransformBlock is to be run on them.
         // It is needed to get a balance between amount of costly sha.TransformBlock calls and amount of allocated memory.
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index 9fd40f7963e..b8f7d6a0b12 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -62,13 +62,13 @@ public override bool Resolve(
                     string referenceAssemblyPathNeutral = Path.Combine(sdkDirectory, "References", configuration, "Neutral");
                     string referenceAssemblyArchFilePathNeutral = Path.Combine(sdkDirectory, "References", "CommonConfiguration", "Neutral");
 
-                    string[] searchLocations = new string[]
-                    {
+                    string[] searchLocations =
+                    [
                         referenceAssemblyFilePath, // Config-Arch
                         referenceAssemblyPathNeutral, // Config-Neutral
                         referenceAssemblyCommonArchFilePath, // CommonArch-Config
                         referenceAssemblyArchFilePathNeutral // CommonArch-Neutral
-                    };
+                    ];
 
                     // Lets try and resovle from the windowsmetadata directory first
 
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 9e78a48daf4..3169eaec219 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -460,7 +460,7 @@ internal static List<string[]> CreateTargetLists(string[] targets, bool runEachT
                 // Separate target invocations for each individual target.
                 foreach (string targetName in targets)
                 {
-                    targetLists.Add(new[] { targetName });
+                    targetLists.Add([targetName]);
                 }
             }
             else
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 64af947c9d1..6328476020f 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -509,7 +509,7 @@ internal string Resolve(string[] searchPaths, bool specificVersion)
         {
             if (searchPaths == null)
             {
-                searchPaths = new[] { ".\\" };
+                searchPaths = [".\\"];
             }
 
             foreach (string searchPath in searchPaths)
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index 3ccb3de31b9..9df8266fb8e 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -558,7 +558,7 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
                 methodName,
                 BindingFlags.Public | BindingFlags.Static,
                 null,
-                new[] { typeof(X509Certificate2) },
+                [typeof(X509Certificate2)],
                 null);
 
             Debug.Assert(api != null, "Method '" + methodName + "(X509Certificate2 c)' not found on type '" + type + "'");
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 084c04b607e..b4678e65365 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -125,7 +125,7 @@ public ComImporter(string path, OutputMessageCollection outputMessages, string o
 
         private void CheckForUnknownSubKeys(RegistryKey key)
         {
-            CheckForUnknownSubKeys(key, Array.Empty<string>());
+            CheckForUnknownSubKeys(key, []);
         }
 
         private void CheckForUnknownSubKeys(RegistryKey key, string[] knownNames)
@@ -144,7 +144,7 @@ private void CheckForUnknownSubKeys(RegistryKey key, string[] knownNames)
 
         private void CheckForUnknownValues(RegistryKey key)
         {
-            CheckForUnknownValues(key, Array.Empty<string>());
+            CheckForUnknownValues(key, []);
         }
 
         private void CheckForUnknownValues(RegistryKey key, string[] knownNames)
@@ -230,7 +230,7 @@ private bool GetRegisteredClassInfo(RegistryKey rootKey, Guid clsid, ref ClassIn
                     registeredPath = (string)subKey.GetValue(null);
                     threadingModel = (string)subKey.GetValue("ThreadingModel");
                     CheckForUnknownSubKeys(subKey);
-                    CheckForUnknownValues(subKey, new string[] { "ThreadingModel" });
+                    CheckForUnknownValues(subKey, ["ThreadingModel"]);
                 }
                 else if (String.Equals(subKeyName, "ProgID", StringComparison.OrdinalIgnoreCase))
                 {
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index b49395de0d6..a737ed59012 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -255,7 +255,7 @@ private static XmlElement GetCurrentCLRPermissions(string targetZone)
                 Internet => SecurityZone.Internet,
                 _ => throw new ArgumentException(String.Empty /* no message */, nameof(targetZone)),
             };
-            var evidence = new Evidence(new EvidenceBase[] { new Zone(zone), new System.Runtime.Hosting.ActivationArguments(new System.ApplicationIdentity("")) }, null);
+            var evidence = new Evidence([new Zone(zone), new System.Runtime.Hosting.ActivationArguments(new System.ApplicationIdentity(""))], null);
 
             PermissionSet sandbox = SecurityManager.GetStandardSandbox(evidence);
             string resultInString = sandbox.ToString();
@@ -455,7 +455,7 @@ private static string[] XmlToIdentityList(XmlElement psElement)
             }
             else
             {
-                a = Array.Empty<string>();
+                a = [];
             }
             return a;
         }
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 59e9f6c1ba5..111880e1d30 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -1334,7 +1334,7 @@ private void InitializeEnum(String assemblyName)
                     }
                     else
                     {
-                        _gacDirectories = Array.Empty<string>();
+                        _gacDirectories = [];
                     }
                 }
             }
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index c46d663bbb7..e94588e4264 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -215,7 +215,7 @@ public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRema
         public static RedistList GetFrameworkList20()
         {
             string frameworkVersion20Path = ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20);
-            string[] redistListPaths = Array.Empty<string>();
+            string[] redistListPaths = [];
             if (frameworkVersion20Path != null)
             {
                 redistListPaths = RedistList.GetRedistListPathsFromDisk(frameworkVersion20Path);
@@ -255,7 +255,7 @@ public static RedistList GetFrameworkList35()
         /// </summary>
         public static RedistList GetRedistListFromPath(string path)
         {
-            string[] redistListPaths = (path == null) ? Array.Empty<string>() : GetRedistListPathsFromDisk(path);
+            string[] redistListPaths = (path == null) ? [] : GetRedistListPathsFromDisk(path);
 
             var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
             for (int i = 0; i < redistListPaths.Length; ++i)
@@ -272,7 +272,7 @@ private static RedistList GetFrameworkListFromReferenceAssembliesPath(TargetDotN
 
             // On dogfood build machines, v3.5 is not formally installed, so this returns null.
             // We don't use redist lists in this case.
-            string[] redistListPaths = (referenceAssembliesPath == null) ? Array.Empty<string>() : GetRedistListPathsFromDisk(referenceAssembliesPath);
+            string[] redistListPaths = (referenceAssembliesPath == null) ? [] : GetRedistListPathsFromDisk(referenceAssembliesPath);
 
             var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
             for (int i = 0; i < redistListPaths.Length; ++i)
@@ -317,7 +317,7 @@ public static string[] GetRedistListPathsFromDisk(string frameworkDirectory)
                 }
             }
 
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -1067,7 +1067,7 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
                 }
             }
 
-            return Array.Empty<string>();
+            return [];
         }
         #endregion
     }
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 614ed571685..4931ce4aa84 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -601,7 +601,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                             else
                             {
                                 resGenArguments.AppendFileNamesIfNotNull(
-                                    new[] { inputFiles[i], outputFiles[i] },
+                                    [inputFiles[i], outputFiles[i]],
                                     ",");
                             }
                         }
@@ -616,7 +616,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                     // append the strongly-typed resource details
                     resGenArguments.AppendSwitchIfNotNull(
                         "/str:",
-                        new[] { StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName },
+                        [StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName],
                         ",");
                 }
             }
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index b3a1bca439a..c8ba6d686f4 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -1297,7 +1297,7 @@ internal bool ResolveComReferencePia(ComReferenceInfo referenceInfo, string refN
         /// <returns></returns>
         internal IEnumerable<string> GetResolvedAssemblyReferenceItemSpecs()
         {
-            return (ResolvedAssemblyReferences == null) ? Array.Empty<string>() : ResolvedAssemblyReferences.Select(rar => rar.ItemSpec);
+            return (ResolvedAssemblyReferences == null) ? [] : ResolvedAssemblyReferences.Select(rar => rar.ItemSpec);
         }
 
         /// <summary>
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index f67cab5f410..80620581904 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -83,7 +83,7 @@ public string[] AdditionalSearchPaths
         public ITaskItem[] ContainedLooseEtcFiles { get; set; }
 
         private ITaskItem[] _nativeReferences;
-        private string[] _additionalSearchPaths = Array.Empty<string>();
+        private string[] _additionalSearchPaths = [];
         #endregion
 
         #region Nested classes
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 0e458a48807..824bb439e46 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -561,7 +561,7 @@ internal SDKReference ParseSDKReference(ITaskItem referenceItem)
 
             if (!splitSuccessful)
             {
-                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.SDKReferenceIncorrectFormat", new object[] { referenceItem.ItemSpec }));
+                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.SDKReferenceIncorrectFormat", [referenceItem.ItemSpec]));
                 return null;
             }
 
@@ -613,7 +613,7 @@ private void LogResolution(SDKReference reference)
             else if (reference.ResolutionErrors == null || reference.ResolutionErrors.Count == 0)
             {
                 // We only want to say we could not find it if there were no other errors which would cause it not to be found
-                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.CouldNotResolveSDK", new object[] { reference.ReferenceItem.ItemSpec }));
+                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.CouldNotResolveSDK", [reference.ReferenceItem.ItemSpec]));
             }
 
             // Log warnings
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 05c2e50efe6..29ca1ce275f 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -366,15 +366,15 @@ internal static string[] ParseResxFileRefString(string stringValue)
                 string[] parts = remainingString.Split(';');
                 if (parts.Length > 1)
                 {
-                    result = new string[] { fileName, parts[0], parts[1] };
+                    result = [fileName, parts[0], parts[1]];
                 }
                 else if (parts.Length > 0)
                 {
-                    result = new string[] { fileName, parts[0] };
+                    result = [fileName, parts[0]];
                 }
                 else
                 {
-                    result = new string[] { fileName };
+                    result = [fileName];
                 }
             }
             return result;
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 7989a98917a..b2bac7f674a 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -737,7 +737,7 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
                     managedCompiler.Optimize = false;
                     managedCompiler.OutputAssembly = new TaskItem(assemblyPath);
                     managedCompiler.References = references;
-                    managedCompiler.Sources = new ITaskItem[] { new TaskItem(sourceCodePath) };
+                    managedCompiler.Sources = [new TaskItem(sourceCodePath)];
                     managedCompiler.TargetType = "Library";
                     managedCompiler.UseSharedCompilation = false;
 
diff --git a/src/Tasks/SGen.cs b/src/Tasks/SGen.cs
index 743cbf2eaf8..7be17cf5dc2 100644
--- a/src/Tasks/SGen.cs
+++ b/src/Tasks/SGen.cs
@@ -365,7 +365,7 @@ protected override string GenerateCommandLineCommands()
                 {
                     Debug.Assert(ShouldGenerateSerializer, "GenerateCommandLineCommands() should not be called if ShouldGenerateSerializer is true and SerializationAssembly is null.");
 
-                    SerializationAssembly = new ITaskItem[] { new TaskItem(SerializationAssemblyPath) };
+                    SerializationAssembly = [new TaskItem(SerializationAssemblyPath)];
                 }
 
                 // Add the assembly switch
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 7e1e971b48d..e44fbf5f2bf 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -102,7 +102,7 @@ internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log) w
                             var parameters = constructor.GetParameters();
                             if (parameters.Length == 1 && parameters[0].ParameterType == typeof(ITranslator))
                             {
-                                retVal = constructor.Invoke(new object[] { translator }) as T;
+                                retVal = constructor.Invoke([translator]) as T;
                             }
                         }
 
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 6039813ba39..690308135f0 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -319,7 +319,7 @@ private void ParseIncludeExclude()
 
         private void ParsePattern(string pattern, out string[] patterns)
         {
-            patterns = Array.Empty<string>();
+            patterns = [];
             if (!string.IsNullOrWhiteSpace(pattern))
             {
                 if (FileMatcher.HasPropertyOrItemReferences(pattern))
@@ -334,8 +334,8 @@ private void ParsePattern(string pattern, out string[] patterns)
                 else
                 {
                     patterns = pattern.Contains(';')
-                                   ? pattern.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()
-                                   : new[] { pattern };
+                                   ? pattern.Split([';'], StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()
+                                   : [pattern];
                 }
             }
         }
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 79efdf61495..ecfe9bad0d6 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -34,7 +34,7 @@ public class WriteCodeFragment : TaskExtension
     {
         private const string TypeNameSuffix = "_TypeName";
         private const string IsLiteralSuffix = "_IsLiteral";
-        private static readonly IEnumerable<string> NamespaceImports = new string[] { "System", "System.Reflection" };
+        private static readonly string[] NamespaceImports = ["System", "System.Reflection"];
         private static readonly IReadOnlyDictionary<string, ParameterType> EmptyParameterTypes = new Dictionary<string, ParameterType>();
 
         /// <summary>
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index 38a2a4562e5..83d45753651 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -765,19 +765,19 @@ private void GenerateIntegers(Property property, CodeMemberProperty propertyName
             string name = property.SwitchName != String.Empty ? property.Prefix + property.SwitchName : property.Name;
             if (!String.IsNullOrEmpty(property.Min) && !String.IsNullOrEmpty(property.Max))
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression()];
             }
             else if (!String.IsNullOrEmpty(property.Min))
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression()];
             }
             else if (!String.IsNullOrEmpty(property.Max))
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression()];
             }
             else
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression()];
             }
 
             var validateInt = new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), ValidateIntegerMethod);
@@ -896,9 +896,9 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
                     // The condition to test.
                     new CodeVariableReferenceExpression("i >= 0"),
                     // The statements to execute if the condition evaluates to true.
-                    new CodeStatement[] { setToolSwitchNameGoodIndex, setArgumentsGoodIndex },
+                    [setToolSwitchNameGoodIndex, setArgumentsGoodIndex],
                     // The statements to execute if the condition evalues to false.
-                    new CodeStatement[] { setToolSwitchNameBadIndex, setArgumentsBadIndex });
+                    [setToolSwitchNameBadIndex, setArgumentsBadIndex]);
 
                 propertyName.SetStatements.Add(conditionalStatement);
                 // Set the separator
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 342fb1f30b2..b2823627ffd 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -118,13 +118,12 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
             // create the code generator options
             // Since we are running msbuild 12.0 these had better load.
             var compilerParameters = new CompilerParameters(
-                new[]
-                {
+                [
                     "System.dll",
                     Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Framework.dll"),
                     Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Utilities.Core.dll"),
                     Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Tasks.Core.dll")
-                })
+                ])
             {
                 GenerateInMemory = true,
                 TreatWarningsAsErrors = false
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index f55532b9546..dd15d64cea9 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -292,7 +292,7 @@ public XmlInput(ITaskItem[] xmlFile, string xml)
                 else
                 {
                     XmlMode = XmlModes.Xml;
-                    _data = new[] { xml };
+                    _data = [xml];
                 }
             }
 
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 6f6bf7f491e..c43ddc11ad1 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -71,10 +71,10 @@ internal static class StronglyTypedResourceBuilder
 
         // When fixing up identifiers, we will replace all these chars with
         // a single char that is valid in identifiers, such as '_'.
-        private static readonly char[] s_charsToReplace = new char[] { ' ',
+        private static readonly char[] s_charsToReplace = [' ',
         '\u00A0' /* non-breaking space */, '.', ',', ';', '|', '~', '@',
         '#', '%', '^', '&', '*', '+', '-', '/', '\\', '<', '>', '?', '[',
-        ']', '(', ')', '{', '}', '\"', '\'', ':', '!' };
+        ']', '(', ')', '{', '}', '\"', '\'', ':', '!'];
         private const char ReplacementChar = '_';
 
         private const String DocCommentSummaryStart = "<summary>";
diff --git a/src/Utilities/LockCheck.cs b/src/Utilities/LockCheck.cs
index c2de1dfaa65..7b191851e70 100644
--- a/src/Utilities/LockCheck.cs
+++ b/src/Utilities/LockCheck.cs
@@ -342,7 +342,7 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
                         // If pnProcInfo == 0, then there is simply no locking process (found), in this case rgAffectedApps is "null".
                         if (pnProcInfo == 0)
                         {
-                            return Enumerable.Empty<ProcessInfo>();
+                            return [];
                         }
 
                         var lockInfos = new List<ProcessInfo>((int)pnProcInfo);
@@ -371,7 +371,7 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
                 }
             }
 
-            return Enumerable.Empty<ProcessInfo>();
+            return [];
         }
 
         private static Exception GetException(int res, string apiName, string message)
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index dc1e8ee78ff..ab2c1fd9b9b 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -495,7 +495,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
         {
             if (_metadata == null)
             {
-                return Enumerable.Empty<KeyValuePair<string, string>>();
+                return [];
             }
 
             int count = _metadata.Count;
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 20510c33d8b..0ee514640fc 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -1060,7 +1060,7 @@ private static string[] GetLegacyTargetPlatformReferences(string targetPlatformI
                 ErrorUtilities.DebugTraceMessage("GetLegacyTargetPlatformReferences", "Encountered exception trying to gather the platform references: {0}", e.Message);
             }
 
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -1081,7 +1081,7 @@ private static string[] GetTargetPlatformReferencesFromManifest(
             ErrorUtilities.VerifyThrowArgumentLength(targetPlatformIdentifier, nameof(targetPlatformIdentifier));
             ErrorUtilities.VerifyThrowArgumentLength(targetPlatformVersion, nameof(targetPlatformVersion));
 
-            string[] contractWinMDs = Array.Empty<string>();
+            string[] contractWinMDs = [];
 
             TargetPlatformSDK matchingSdk = GetMatchingPlatformSDK(targetPlatformIdentifier, targetPlatformVersion, diskRoots, null, registryRoot);
             string platformKey = TargetPlatformSDK.GetSdkKey(targetPlatformIdentifier, targetPlatformVersion);
@@ -1119,7 +1119,7 @@ internal static string[] GetApiContractReferences(IEnumerable<ApiContract> apiCo
         {
             if (apiContracts == null)
             {
-                return Array.Empty<string>();
+                return [];
             }
 
             var contractWinMDs = new List<string>();
@@ -2479,7 +2479,7 @@ private static IEnumerable<TargetPlatformSDK> RetrieveTargetPlatformList(string[
                         GatherExtensionSDKListFromDirectory(extensionSdkDiskRoots, extensionSdk);
                         s_cachedExtensionSdks.Add(cachedExtensionSdksKey, extensionSdk);
                     }
-                    collection = collection.Concat(new[] { extensionSdk });
+                    collection = collection.Concat([extensionSdk]);
                 }
 
                 return collection;
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index c196b0afcc8..ae2f672a390 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -127,7 +127,7 @@ public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskI
         /// <param name="useMinimalRebuildOptimization">WARNING: Minimal rebuild optimization requires 100% accurate computed outputs to be specified!</param>
         /// <param name="maintainCompositeRootingMarkers">True to keep composite rooting markers around (many-to-one case) or false to shred them (one-to-one or one-to-many case)</param>
         public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem sourceFile, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)
-            => InternalConstruct(ownerTask, tlogFiles, new[] { sourceFile }, null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);
+            => InternalConstruct(ownerTask, tlogFiles, [sourceFile], null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);
 
         /// <summary>
         /// Common internal constructor
@@ -930,7 +930,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
-        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource(new[] { source });
+        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource([source]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
@@ -1002,14 +1002,14 @@ private void RemoveDependencyFromEntry(string rootingMarker, ITaskItem dependenc
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing(new ITaskItem[] { source }, null);
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing([source], null);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
         /// <param name="correspondingOutput">Output that correspond ot the sources (used for same file processing)</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing(new[] { source }, new[] { correspondingOutput });
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing([source], [correspondingOutput]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 5a94ceeb1ad..fad06ee59a9 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -617,14 +617,14 @@ public void SaveTlog(DependencyFilter includeInTLog)
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Sources that should be removed from the graph</param>
-        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource(new[] { source }, null);
+        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource([source], null);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Sources that should be removed from the graph</param>
         /// <param name="correspondingOutput">Outputs that correspond ot the sources (used for same file processing)</param>
-        public void RemoveEntriesForSource(ITaskItem source, ITaskItem correspondingOutput) => RemoveEntriesForSource(new[] { source }, new[] { correspondingOutput });
+        public void RemoveEntriesForSource(ITaskItem source, ITaskItem correspondingOutput) => RemoveEntriesForSource([source], [correspondingOutput]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
@@ -696,14 +696,14 @@ private void RemoveDependencyFromEntry(string rootingMarker, ITaskItem dependenc
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing(new[] { source }, null);
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing([source], null);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
         /// <param name="correspondingOutput">Output that correspond ot the sources (used for same file processing)</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing(new[] { source }, new[] { correspondingOutput });
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing([source], [correspondingOutput]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index be62498f6ee..f3db3169e4f 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -284,14 +284,14 @@ public static bool FileIsUnderPath(string fileName, string path)
         /// Construct a rooting marker string from the ITaskItem array of primary sources.
         /// </summary>
         /// <param name="source">An <see cref="ITaskItem"/> containing information about the primary source.</param>
-        public static string FormatRootingMarker(ITaskItem source) => FormatRootingMarker(new[] { source }, null);
+        public static string FormatRootingMarker(ITaskItem source) => FormatRootingMarker([source], null);
 
         /// <summary>
         /// Construct a rooting marker string from the ITaskItem array of primary sources.
         /// </summary>
         /// <param name="source">An <see cref="ITaskItem"/> containing information about the primary source.</param>
         /// <param name="output">An <see cref="ITaskItem"/> containing information about the output.</param>
-        public static string FormatRootingMarker(ITaskItem source, ITaskItem output) => FormatRootingMarker(new[] { source }, new[] { output });
+        public static string FormatRootingMarker(ITaskItem source, ITaskItem output) => FormatRootingMarker([source], [output]);
 
         /// <summary>
         /// Construct a rooting marker string from the ITaskItem array of primary sources.
