diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index cc07f196424..523ce5fd8ef 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22212.5">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22218.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1a6b24397e50146d0fece9cfb9c0b87275691e6f</Sha>
+      <Sha>095ae444583627c1f0575967529107fd1e1d6913</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.2.0-rc.146">
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>b8a61266d9a6780cb7eb9c1942695cf813fdef0a</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.2.0-4.22212.4">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.2.0-4.22223.6">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>f2d278f9a5131b7944d6ac5fecf2ce5b0a98195f</Sha>
+      <Sha>68ce7949a2ac960994374d387ec3c840523f2a44</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22212.5">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22218.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1a6b24397e50146d0fece9cfb9c0b87275691e6f</Sha>
+      <Sha>095ae444583627c1f0575967529107fd1e1d6913</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 04a2928f961..20fa019c66e 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -32,10 +32,10 @@
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22212.5</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22218.4</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.2.0-4.22212.4</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.2.0-4.22223.6</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.2.0-rc.146</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>6.0.0</SystemTextJsonVersion>
diff --git a/global.json b/global.json
index 02afe6e7bef..9433b51dca5 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22212.5"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22218.4"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs
index 52d7fe31cfa..d29d9623ecc 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs
@@ -34,6 +34,7 @@ public void TestCreateAsynchronousLogger()
             LoggingServiceFactory factory = new LoggingServiceFactory(LoggerMode.Asynchronous, 1);
             LoggingService loggingService = (LoggingService)factory.CreateInstance(BuildComponentType.LoggingService);
             Assert.Equal(LoggerMode.Asynchronous, loggingService.LoggingMode); // "Expected to create an Asynchronous LoggingService"
+            loggingService.ShutdownComponent();
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 1753fc92445..c9964af9f2d 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -1099,6 +1099,7 @@ public void TestBuildFinishedWaitForEvents()
         {
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Asynchronous, 1);
             service.LogBuildFinished(true);
+            service.ShutdownComponent();
         }
 
         #endregion
@@ -1898,7 +1899,7 @@ public static IBuildComponent CreateLoggingService(LoggerMode mode, int nodeId,
             /// Override the method to log which event was processed so it can be verified in a test
             /// </summary>
             /// <param name="buildEvent">Build event which was asked to be processed</param>
-            internal override void ProcessLoggingEvent(object buildEvent, bool allowThrottling = false)
+            internal override void ProcessLoggingEvent(object buildEvent)
             {
                 if (buildEvent is BuildEventArgs buildEventArgs)
                 {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 50062bec8cf..c4a9d2c9523 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1662,7 +1662,7 @@ private void WaitForAllLoggingServiceEventsToBeProcessed()
             // this has to be called out of the lock (_syncLock)
             // because processing events can callback to 'this' instance and cause deadlock
             Debug.Assert(!Monitor.IsEntered(_syncLock));
-            ((LoggingService) ((IBuildComponentHost) this).LoggingService).WaitForThreadToProcessEvents();
+            ((LoggingService) ((IBuildComponentHost) this).LoggingService).WaitForLoggingToProcessEvents();
         }
 
         /// <summary>
@@ -2652,26 +2652,20 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
                         break;
 
                     case ScheduleActionType.CreateNode:
-                        var newNodes = new List<NodeInfo>();
+                        IList<NodeInfo> newNodes = _nodeManager.CreateNodes(GetNodeConfiguration(), response.RequiredNodeType, response.NumberOfNodesToCreate);
 
-                        for (int i = 0; i < response.NumberOfNodesToCreate; i++)
+                        if (newNodes?.Count != response.NumberOfNodesToCreate || newNodes.Any(n => n == null))
                         {
-                            NodeInfo createdNode = _nodeManager.CreateNode(GetNodeConfiguration(), response.RequiredNodeType);
+                            BuildEventContext buildEventContext = new BuildEventContext(0, Scheduler.VirtualNode, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+                            ((IBuildComponentHost)this).LoggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty), "UnableToCreateNode", response.RequiredNodeType.ToString("G"));
 
-                            if (createdNode != null)
-                            {
-                                _noNodesActiveEvent.Reset();
-                                _activeNodes.Add(createdNode.NodeId);
-                                newNodes.Add(createdNode);
-                                ErrorUtilities.VerifyThrow(_activeNodes.Count != 0, "Still 0 nodes after asking for a new node.  Build cannot proceed.");
-                            }
-                            else
-                            {
-                                BuildEventContext buildEventContext = new BuildEventContext(0, Scheduler.VirtualNode, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                                ((IBuildComponentHost)this).LoggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty), "UnableToCreateNode", response.RequiredNodeType.ToString("G"));
+                            throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnableToCreateNode", response.RequiredNodeType.ToString("G")));
+                        }
 
-                                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnableToCreateNode", response.RequiredNodeType.ToString("G")));
-                            }
+                        foreach (var node in newNodes)
+                        {
+                            _noNodesActiveEvent.Reset();
+                            _activeNodes.Add(node.NodeId);
                         }
 
                         IEnumerable<ScheduleResponse> newResponses = _scheduler.ReportNodesCreated(newNodes);
diff --git a/src/Build/BackEnd/Components/Communications/INodeManager.cs b/src/Build/BackEnd/Components/Communications/INodeManager.cs
index e1562a6d20a..f35f8cba087 100644
--- a/src/Build/BackEnd/Components/Communications/INodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeManager.cs
@@ -5,8 +5,6 @@
 using System.Diagnostics;
 using Microsoft.Build.Execution;
 
-#nullable disable
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
@@ -23,11 +21,12 @@ internal interface INodeManager : IBuildComponent,
         /// </summary>
         /// <param name="configuration">The configuration to use to create the node.</param>
         /// <param name="affinity">The <see cref="NodeAffinity"/> to use.</param>
+        /// <param name="numberOfNodesToCreate">Number of nodes to be reused or created.</param>
         /// <returns>Information about the node created</returns>
         /// <remarks>
         /// Throws an exception if the node could not be created.
         /// </remarks>
-        NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity affinity);
+        IList<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity affinity, int numberOfNodesToCreate);
 
         /// <summary>
         /// Sends a data packet to a specific node
diff --git a/src/Build/BackEnd/Components/Communications/INodeProvider.cs b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
index acb65f7681f..0da32af6678 100644
--- a/src/Build/BackEnd/Components/Communications/INodeProvider.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
@@ -1,7 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#nullable disable
+using System;
 
 using System.Collections;
 using System.Collections.Generic;
@@ -61,14 +61,15 @@ int AvailableNodes
         /// <summary>
         /// Requests that a new node be created on the specified machine.
         /// </summary>
-        /// <param name="nodeId">The id to assign to the node.</param>
+        /// <param name="nextNodeId">The id to assign to the first created node. Resulting nodes ids will be in range [nextNodeId, nextNodeId + numberOfNodesToCreate - 1]</param>
         /// <param name="packetFactory">
         /// The packet factory used to create packets when data is
         /// received on this node.
         /// </param>
-        /// <param name="configuration">The configuration to use to create the remote node.</param>
-        /// <returns>True if the node was created, false otherwise.</returns>
-        bool CreateNode(int nodeId, INodePacketFactory packetFactory, NodeConfiguration configuration);
+        /// <param name="configurationFactory">NodeConfiguration factory of particular node</param>
+        /// <param name="numberOfNodesToCreate">Required number of nodes to create</param>
+        /// <returns>Array of NodeInfo of successfully created nodes</returns>
+        IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory packetFactory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate);
 
         /// <summary>
         /// Sends data to a specific node.
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index e63ab105bfd..6d9f73590eb 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -5,10 +5,8 @@
 using System.Collections.Generic;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
+using System.Threading;
 using System.Diagnostics;
-using System.Linq;
-
-#nullable disable
 
 namespace Microsoft.Build.BackEnd
 {
@@ -18,30 +16,25 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal class NodeManager : INodeManager
     {
-        /// <summary>
-        /// The invalid node id
-        /// </summary>
-        private const int InvalidNodeId = 0;
-
         /// <summary>
         /// The node provider for the in-proc node.
         /// </summary>
-        private INodeProvider _inProcNodeProvider;
+        private INodeProvider? _inProcNodeProvider;
 
         /// <summary>
         /// The node provider for out-of-proc nodes.
         /// </summary> 
-        private INodeProvider _outOfProcNodeProvider;
+        private INodeProvider? _outOfProcNodeProvider;
 
         /// <summary>
         /// The build component host.
         /// </summary>
-        private IBuildComponentHost _componentHost;
+        private IBuildComponentHost? _componentHost;
 
         /// <summary>
         /// Mapping of manager-produced node IDs to the provider hosting the node.
         /// </summary>
-        private Dictionary<int, INodeProvider> _nodeIdToProvider;
+        private readonly Dictionary<int, INodeProvider> _nodeIdToProvider;
 
         /// <summary>
         /// The packet factory used to translate and route packets
@@ -94,32 +87,31 @@ private NodeManager()
         /// </summary>
         /// <param name="configuration">The configuration to use for the remote node.</param>
         /// <param name="nodeAffinity">The <see cref="NodeAffinity"/> to use.</param>
+        /// <param name="numberOfNodesToCreate">Number of nodes to be reused ot created.</param>
         /// <returns>A NodeInfo describing the node created, or null if none could be created.</returns>
-        public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity)
+        public IList<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity nodeAffinity, int numberOfNodesToCreate)
         {
             // We will prefer to make nodes on the "closest" providers first; in-proc, then
             // out-of-proc, then remote.
             // When we support distributed build, we will also consider the remote provider.
-            int nodeId = InvalidNodeId;
-            if ((nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.InProc) && !_componentHost.BuildParameters.DisableInProcNode)
+            List<NodeInfo> nodes = new(numberOfNodesToCreate);
+            if ((nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.InProc) && !_componentHost!.BuildParameters.DisableInProcNode)
             {
-                nodeId = AttemptCreateNode(_inProcNodeProvider, configuration);
+                nodes.AddRange(AttemptCreateNode(_inProcNodeProvider!, configuration, numberOfNodesToCreate));
             }
 
-            if (nodeId == InvalidNodeId && (nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.OutOfProc))
+            if (nodes.Count < numberOfNodesToCreate && (nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.OutOfProc))
             {
-                nodeId = AttemptCreateNode(_outOfProcNodeProvider, configuration);
+                nodes.AddRange(AttemptCreateNode(_outOfProcNodeProvider!, configuration, numberOfNodesToCreate - nodes.Count));
             }
 
-            if (nodeId == InvalidNodeId)
+            // If we created a node, they should no longer be considered shut down.
+            if (nodes.Count > 0)
             {
-                return null;
+                _nodesShutdown = false;
             }
 
-            // If we created a node, they should no longer be considered shut down.
-            _nodesShutdown = false;
-
-            return new NodeInfo(nodeId, _nodeIdToProvider[nodeId].ProviderType);
+            return nodes;
         }
 
         /// <summary>
@@ -129,14 +121,14 @@ public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAff
         /// <param name="packet">The packet to send.</param>
         public void SendData(int node, INodePacket packet)
         {
-            // Look up the node provider for this node in the mapping.
-            if (!_nodeIdToProvider.TryGetValue(node, out INodeProvider provider))
+            if (!_nodeIdToProvider.TryGetValue(node, out INodeProvider? provider))
             {
                 ErrorUtilities.ThrowInternalError("Node {0} does not have a provider.", node);
             }
-
-            // Send the data.
-            provider.SendData(node, packet);
+            else
+            {
+                provider.SendData(node, packet);
+            }
         }
 
         /// <summary>
@@ -178,7 +170,7 @@ public void InitializeComponent(IBuildComponentHost host)
         {
             ErrorUtilities.VerifyThrow(_componentHost == null, "NodeManager already initialized.");
             ErrorUtilities.VerifyThrow(host != null, "We can't create a NodeManager with a null componentHost");
-            _componentHost = host;
+            _componentHost = host!;
 
             _inProcNodeProvider = _componentHost.GetComponent(BuildComponentType.InProcNodeProvider) as INodeProvider;
             _outOfProcNodeProvider = _componentHost.GetComponent(BuildComponentType.OutOfProcNodeProvider) as INodeProvider;
@@ -307,52 +299,57 @@ private void RemoveNodeFromMapping(int nodeId)
         /// </summary>
         /// <param name="nodeProvider">The provider used to create the node.</param>
         /// <param name="nodeConfiguration">The <see cref="NodeConfiguration"/> to use.</param>
-        /// <returns>The id of the node created.</returns>
-        private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration)
+        /// <param name="numberOfNodesToCreate">Number of nodes to be reused ot created.</param>
+        /// <returns>List of created nodes.</returns>
+        private IList<NodeInfo> AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration, int numberOfNodesToCreate)
         {
             // If no provider was passed in, we obviously can't create a node.
             if (nodeProvider == null)
             {
                 ErrorUtilities.ThrowInternalError("No node provider provided.");
-                return InvalidNodeId;
+                return new List<NodeInfo>();
             }
 
             // Are there any free slots on this provider?
             if (nodeProvider.AvailableNodes == 0)
             {
-                return InvalidNodeId;
+                return new List<NodeInfo>();
             }
 
             // Assign a global ID to the node we are about to create.
-            int nodeId;
+            int fromNodeId;
             if (nodeProvider is NodeProviderInProc)
             {
-                nodeId = _inprocNodeId;
+                fromNodeId = _inprocNodeId;
             }
             else
             {
-                nodeId = _nextNodeId;
-                _nextNodeId++;
+                // Reserve node numbers for all needed nodes.
+                fromNodeId = Interlocked.Add(ref _nextNodeId, numberOfNodesToCreate) - numberOfNodesToCreate;
             }
 
-            NodeConfiguration configToSend = nodeConfiguration.Clone();
-            configToSend.NodeId = nodeId;
 
             // Create the node and add it to our mapping.
-            bool createdNode = nodeProvider.CreateNode(nodeId, this, configToSend);
+            IList<NodeInfo> nodes = nodeProvider.CreateNodes(fromNodeId, this, AcquiredNodeConfigurationFactory, numberOfNodesToCreate);
 
-            if (!createdNode)
+            foreach (NodeInfo node in nodes)
             {
-                return InvalidNodeId;
+                _nodeIdToProvider.Add(node.NodeId, nodeProvider);
             }
 
-            _nodeIdToProvider.Add(nodeId, nodeProvider);
-            return nodeId;
+            return nodes;
+
+            NodeConfiguration AcquiredNodeConfigurationFactory(NodeInfo nodeInfo)
+            {
+                var config = nodeConfiguration.Clone();
+                config.NodeId = nodeInfo.NodeId;
+                return config;
+            }
         }
 
         public IEnumerable<Process> GetProcesses()
         {
-            return _outOfProcNodeProvider.GetProcesses();
+            return _outOfProcNodeProvider?.GetProcesses()!;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 8d221aaa2b0..88f5feea51b 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -186,13 +186,34 @@ public void ShutdownAllNodes()
             ShutdownConnectedNodes(false /* no node reuse */);
         }
 
+        public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate)
+        {
+            var nodes = new List<NodeInfo>(numberOfNodesToCreate);
+
+            for (int i = 0; i < numberOfNodesToCreate; i++)
+            {
+                int nodeId = nextNodeId + i;
+
+                NodeInfo nodeInfo = new(nodeId, ProviderType);
+                if (!CreateNode(nodeId, factory, configurationFactory(nodeInfo)))
+                {
+                    // If it fails let it return what we have created so far so caller can somehow acquire missing nodes.
+                    break;
+                }
+
+                nodes.Add(nodeInfo);
+            }
+
+            return nodes;
+        }
+
         /// <summary>
         /// Requests that a node be created on the specified machine.
         /// </summary>
         /// <param name="nodeId">The id of the node to create.</param>
         /// <param name="factory">The factory to use to create packets from this node.</param>
         /// <param name="configuration">The configuration for the node.</param>
-        public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
+        private bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
         {
             ErrorUtilities.VerifyThrow(nodeId != InvalidInProcNodeId, "Cannot create in-proc node.");
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index b27d5ee93e0..96ebeef27f9 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -1,9 +1,10 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
-
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
@@ -23,7 +24,7 @@ internal class NodeProviderOutOfProc : NodeProviderOutOfProcBase, INodeProvider
         /// <summary>
         /// A mapping of all the nodes managed by this provider.
         /// </summary>
-        private Dictionary<int, NodeContext> _nodeContexts;
+        private ConcurrentDictionary<int, NodeContext> _nodeContexts;
 
         /// <summary>
         /// Constructor.
@@ -73,44 +74,54 @@ internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPrior
         }
 
         /// <summary>
-        /// Instantiates a new MSBuild process acting as a child node.
+        /// Instantiates a new MSBuild processes acting as a child nodes or connect to existing ones.
         /// </summary>
-        public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
+        public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate)
         {
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
 
-            if (_nodeContexts.Count >= ComponentHost.BuildParameters.MaxNodeCount)
+            // This can run concurrently. To be properly detect internal bug when we create more nodes than allowed
+            //   we add into _nodeContexts premise of future node and verify that it will not cross limits.
+            if (_nodeContexts.Count + numberOfNodesToCreate > ComponentHost.BuildParameters.MaxNodeCount)
             {
-                ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
-                return false;
+                ErrorUtilities.ThrowInternalError("Exceeded max node count of '{0}', current count is '{1}' ", ComponentHost.BuildParameters.MaxNodeCount, _nodeContexts.Count);
+                return new List<NodeInfo>();
             }
 
+            ConcurrentBag<NodeInfo> nodes = new();
+
             // Start the new process.  We pass in a node mode with a node number of 1, to indicate that we
             // want to start up just a standard MSBuild out-of-proc node.
             // Note: We need to always pass /nodeReuse to ensure the value for /nodeReuse from msbuild.rsp
             // (next to msbuild.exe) is ignored.
             string commandLineArgs = $"/nologo /nodemode:1 /nodeReuse:{ComponentHost.BuildParameters.EnableNodeReuse.ToString().ToLower()} /low:{ComponentHost.BuildParameters.LowPriority.ToString().ToLower()}";
 
-            // Make it here.
-            CommunicationsUtilities.Trace("Starting to acquire a new or existing node to establish node ID {0}...", nodeId);
+            CommunicationsUtilities.Trace("Starting to acquire {1} new or existing node(s) to establish nodes from ID {0} to {2}...", nextNodeId, numberOfNodesToCreate, nextNodeId + numberOfNodesToCreate - 1);
+
+            Handshake hostHandshake = new(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture(), nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority));
+            IList<NodeContext> nodeContexts = GetNodes(null, commandLineArgs, nextNodeId, factory, hostHandshake, NodeContextCreated, NodeContextTerminated, numberOfNodesToCreate);
+
+            if (nodeContexts.Count > 0)
+            {
+                return nodeContexts
+                    .Select(nc => new NodeInfo(nc.NodeId, ProviderType))
+                    .ToList();
+            }
 
-            Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture(), nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority));
-            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);
+            throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotConnectToMSBuildExe", ComponentHost.BuildParameters.NodeExeLocation));
 
-            if (context != null)
+            void NodeContextCreated(NodeContext context)
             {
-                _nodeContexts[nodeId] = context;
+                NodeInfo nodeInfo = new NodeInfo(context.NodeId, ProviderType);
+
+                _nodeContexts[context.NodeId] = context;
 
                 // Start the asynchronous read.
                 context.BeginAsyncPacketRead();
 
                 // Configure the node.
-                context.SendData(configuration);
-
-                return true;
+                context.SendData(configurationFactory(nodeInfo));
             }
-
-            throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotConnectToMSBuildExe", ComponentHost.BuildParameters.NodeExeLocation));
         }
 
         /// <summary>
@@ -132,12 +143,7 @@ public void SendData(int nodeId, INodePacket packet)
         public void ShutdownConnectedNodes(bool enableReuse)
         {
             // Send the build completion message to the nodes, causing them to shutdown or reset.
-            List<NodeContext> contextsToShutDown;
-
-            lock (_nodeContexts)
-            {
-                contextsToShutDown = new List<NodeContext>(_nodeContexts.Values);
-            }
+            var contextsToShutDown = new List<NodeContext>(_nodeContexts.Values);
 
             ShutdownConnectedNodes(contextsToShutDown, enableReuse);
         }
@@ -171,7 +177,7 @@ public void ShutdownAllNodes()
         public void InitializeComponent(IBuildComponentHost host)
         {
             this.ComponentHost = host;
-            _nodeContexts = new Dictionary<int, NodeContext>();
+            _nodeContexts = new ConcurrentDictionary<int, NodeContext>();
         }
 
         /// <summary>
@@ -197,10 +203,7 @@ static internal IBuildComponent CreateComponent(BuildComponentType componentType
         /// </summary>
         private void NodeContextTerminated(int nodeId)
         {
-            lock (_nodeContexts)
-            {
-                _nodeContexts.Remove(nodeId);
-            }
+            _nodeContexts.TryRemove(nodeId, out _);
         }
 
         public IEnumerable<Process> GetProcesses()
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index ec334e698b5..c681f417bb5 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -9,6 +9,7 @@
 using System.IO;
 using System.IO.Pipes;
 using System.Diagnostics;
+using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
 using System.Runtime.InteropServices;
@@ -23,8 +24,6 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
-
 using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
 using Task = System.Threading.Tasks.Task;
 using Microsoft.Build.Framework;
@@ -67,8 +66,15 @@ internal abstract class NodeProviderOutOfProcBase
 
         /// <summary>
         /// Keeps track of the processes we've already checked for nodes so we don't check them again.
+        /// We decided to use ConcurrentDictionary of(string, byte) as common implementation of ConcurrentHashSet.
+        /// </summary>
+        private readonly ConcurrentDictionary<string, byte /*void*/> _processesToIgnore = new();
+
+        /// <summary>
+        /// Delegate used to tell the node provider that a context has been created.
         /// </summary>
-        private HashSet<string> _processesToIgnore = new HashSet<string>();
+        /// <param name="context">The created node context.</param>
+        internal delegate void NodeContextCreatedDelegate(NodeContext context);
 
         /// <summary>
         /// Delegate used to tell the node provider that a context has terminated.
@@ -143,7 +149,7 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
             // INodePacketFactory
             INodePacketFactory factory = new NodePacketFactory();
 
-            List<Process> nodeProcesses = GetPossibleRunningNodes().nodeProcesses;
+            List<Process> nodeProcesses = GetPossibleRunningNodes().nodeProcesses.ToList();
 
             // Find proper MSBuildTaskHost executable name
             string msbuildtaskhostExeName = NodeProviderOutOfProcTaskHost.TaskHostNameForClr2TaskHost;
@@ -178,10 +184,16 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
         }
 
         /// <summary>
-        /// Finds or creates a child process which can act as a node.
+        /// Finds or creates a child processes which can act as a node.
         /// </summary>
-        /// <returns>The pipe stream representing the node.</returns>
-        protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, Handshake hostHandshake, NodeContextTerminateDelegate terminateNode)
+        protected IList<NodeContext> GetNodes(string msbuildLocation,
+            string commandLineArgs,
+            int nextNodeId,
+            INodePacketFactory factory,
+            Handshake hostHandshake,
+            NodeContextCreatedDelegate createNode,
+            NodeContextTerminateDelegate terminateNode,
+            int numberOfNodesToCreate)
         {
 #if DEBUG
             if (Execution.BuildManager.WaitForDebugger)
@@ -206,115 +218,169 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                 }
             }
 
+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.
+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while
+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left
+            //    new node process will be started.
+            string expectedProcessName = null;
+            ConcurrentQueue<Process> possibleRunningNodes = null;
 #if FEATURE_NODE_REUSE
             // Try to connect to idle nodes if node reuse is enabled.
             if (_componentHost.BuildParameters.EnableNodeReuse)
             {
-                (string expectedProcessName, List<Process> processes) runningNodesTuple = GetPossibleRunningNodes(msbuildLocation);
+                IList<Process> possibleRunningNodesList;
+                (expectedProcessName, possibleRunningNodesList) = GetPossibleRunningNodes(msbuildLocation);
+                possibleRunningNodes = new ConcurrentQueue<Process>(possibleRunningNodesList);
 
-                CommunicationsUtilities.Trace("Attempting to connect to each existing {1} process in turn to establish node {0}...", nodeId, runningNodesTuple.expectedProcessName);
-                foreach (Process nodeProcess in runningNodesTuple.processes)
+                if (possibleRunningNodesList.Count > 0)
+                {
+                    CommunicationsUtilities.Trace("Attempting to connect to {1} existing processes '{0}'...", expectedProcessName, possibleRunningNodesList.Count);
+                }
+            }
+#endif
+            ConcurrentQueue<NodeContext> nodeContexts = new();
+            ConcurrentQueue<Exception> exceptions = new();
+            Parallel.For(nextNodeId, nextNodeId + numberOfNodesToCreate, (nodeId) =>
+            {
+                try
                 {
-                    if (nodeProcess.Id == Process.GetCurrentProcess().Id)
+                    if (!TryReuseAnyFromPossibleRunningNodes(nodeId) && !StartNewNode(nodeId))
+                    {
+                        // We were unable to reuse or launch a node.
+                        CommunicationsUtilities.Trace("FAILED TO CONNECT TO A CHILD NODE");
+                    }
+                }
+                catch (Exception ex)
+                {
+                    // It will be rethrown as aggregate exception
+                    exceptions.Enqueue(ex);
+                }
+            });
+            if (!exceptions.IsEmpty)
+            {
+                ErrorUtilities.ThrowInternalError("Cannot acquire required number of nodes.", new AggregateException(exceptions.ToArray()));
+            }
+
+            return nodeContexts.ToList();
+
+            bool TryReuseAnyFromPossibleRunningNodes(int nodeId)
+            {
+                while (possibleRunningNodes != null && possibleRunningNodes.TryDequeue(out var nodeToReuse))
+                {
+                    CommunicationsUtilities.Trace("Trying to connect to existing process {2} with id {1} to establish node {0}...", nodeId, nodeToReuse.Id, nodeToReuse.ProcessName);
+                    if (nodeToReuse.Id == Process.GetCurrentProcess().Id)
                     {
                         continue;
                     }
 
                     // Get the full context of this inspection so that we can always skip this process when we have the same taskhost context
-                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeProcess.Id);
-                    if (_processesToIgnore.Contains(nodeLookupKey))
+                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeToReuse.Id);
+                    if (_processesToIgnore.ContainsKey(nodeLookupKey))
                     {
                         continue;
                     }
 
                     // We don't need to check this again
-                    _processesToIgnore.Add(nodeLookupKey);
+                    _processesToIgnore.TryAdd(nodeLookupKey, default);
 
                     // Attempt to connect to each process in turn.
-                    Stream nodeStream = TryConnectToProcess(nodeProcess.Id, 0 /* poll, don't wait for connections */, hostHandshake);
+                    Stream nodeStream = TryConnectToProcess(nodeToReuse.Id, 0 /* poll, don't wait for connections */, hostHandshake);
                     if (nodeStream != null)
                     {
                         // Connection successful, use this node.
-                        CommunicationsUtilities.Trace("Successfully connected to existed node {0} which is PID {1}", nodeId, nodeProcess.Id);
-                        return new NodeContext(nodeId, nodeProcess, nodeStream, factory, terminateNode);
+                        CommunicationsUtilities.Trace("Successfully connected to existed node {0} which is PID {1}", nodeId, nodeToReuse.Id);
+
+                        CreateNodeContext(nodeId, nodeToReuse, nodeStream);
+                        return true;
                     }
                 }
+
+                return false;
             }
-#endif
 
-            // None of the processes we tried to connect to allowed a connection, so create a new one.
-            // We try this in a loop because it is possible that there is another MSBuild multiproc
-            // host process running somewhere which is also trying to create nodes right now.  It might
-            // find our newly created node and connect to it before we get a chance.
-            CommunicationsUtilities.Trace("Could not connect to existing process, now creating a process...");
-            int retries = NodeCreationRetries;
-            while (retries-- > 0)
+            // Create a new node process.
+            bool StartNewNode(int nodeId)
             {
-#if FEATURE_NET35_TASKHOST
-                // We will also check to see if .NET 3.5 is installed in the case where we need to launch a CLR2 OOP TaskHost.
-                // Failure to detect this has been known to stall builds when Windows pops up a related dialog.
-                // It's also a waste of time when we attempt several times to launch multiple MSBuildTaskHost.exe (CLR2 TaskHost)
-                // nodes because we should never be able to connect in this case.
-                string taskHostNameForClr2TaskHost = Path.GetFileNameWithoutExtension(NodeProviderOutOfProcTaskHost.TaskHostNameForClr2TaskHost);
-                if (Path.GetFileNameWithoutExtension(msbuildLocation).Equals(taskHostNameForClr2TaskHost, StringComparison.OrdinalIgnoreCase))
+                CommunicationsUtilities.Trace("Could not connect to existing process, now creating a process...");
+
+                // We try this in a loop because it is possible that there is another MSBuild multiproc
+                // host process running somewhere which is also trying to create nodes right now.  It might
+                // find our newly created node and connect to it before we get a chance.
+                int retries = NodeCreationRetries;
+                while (retries-- > 0)
                 {
-                    if (FrameworkLocationHelper.GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture.Current) == null)
+#if FEATURE_NET35_TASKHOST
+                    // We will also check to see if .NET 3.5 is installed in the case where we need to launch a CLR2 OOP TaskHost.
+                    // Failure to detect this has been known to stall builds when Windows pops up a related dialog.
+                    // It's also a waste of time when we attempt several times to launch multiple MSBuildTaskHost.exe (CLR2 TaskHost)
+                    // nodes because we should never be able to connect in this case.
+                    string taskHostNameForClr2TaskHost = Path.GetFileNameWithoutExtension(NodeProviderOutOfProcTaskHost.TaskHostNameForClr2TaskHost);
+                    if (Path.GetFileNameWithoutExtension(msbuildLocation).Equals(taskHostNameForClr2TaskHost, StringComparison.OrdinalIgnoreCase))
                     {
-                        CommunicationsUtilities.Trace
+                        if (FrameworkLocationHelper.GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture.Current) == null)
+                        {
+                            CommunicationsUtilities.Trace
                             (
                                 "Failed to launch node from {0}. The required .NET Framework v3.5 is not installed or enabled. CommandLine: {1}",
                                 msbuildLocation,
                                 commandLineArgs
                             );
 
-                        string nodeFailedToLaunchError = ResourceUtilities.GetResourceString("TaskHostNodeFailedToLaunchErrorCodeNet35NotInstalled");
-                        throw new NodeFailedToLaunchException(null, nodeFailedToLaunchError);
+                            string nodeFailedToLaunchError = ResourceUtilities.GetResourceString("TaskHostNodeFailedToLaunchErrorCodeNet35NotInstalled");
+                            throw new NodeFailedToLaunchException(null, nodeFailedToLaunchError);
+                        }
                     }
-                }
 #endif
+                    // Create the node process
+                    Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);
+                    _processesToIgnore.TryAdd(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id), default);
 
-                // Create the node process
-                Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);
-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));
+                    // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
+                    // gotten back from CreateProcess is that of the debugger, which causes this to try to connect
+                    // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
 
-                // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
-                // gotten back from CreateProcess is that of the debugger, which causes this to try to connect
-                // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
+                    // Now try to connect to it.
+                    Stream nodeStream = TryConnectToProcess(msbuildProcess.Id, TimeoutForNewNodeCreation, hostHandshake);
+                    if (nodeStream != null)
+                    {
+                        // Connection successful, use this node.
+                        CommunicationsUtilities.Trace("Successfully connected to created node {0} which is PID {1}", nodeId, msbuildProcess.Id);
 
-                // Now try to connect to it.
-                Stream nodeStream = TryConnectToProcess(msbuildProcess.Id, TimeoutForNewNodeCreation, hostHandshake);
-                if (nodeStream != null)
-                {
-                    // Connection successful, use this node.
-                    CommunicationsUtilities.Trace("Successfully connected to created node {0} which is PID {1}", nodeId, msbuildProcess.Id);
-                    return new NodeContext(nodeId, msbuildProcess, nodeStream, factory, terminateNode);
-                }
+                        CreateNodeContext(nodeId, msbuildProcess, nodeStream);
+                        return true;
+                    }
 
-                if (msbuildProcess.HasExited)
-                {
-                    if (Traits.Instance.DebugNodeCommunication)
+                    if (msbuildProcess.HasExited)
                     {
-                        try
-                        {
-                            CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it has exited with exit code {1}. This can indicate a crash at startup", msbuildProcess.Id, msbuildProcess.ExitCode);
-                        }
-                        catch (InvalidOperationException)
+                        if (Traits.Instance.DebugNodeCommunication)
                         {
-                            // This case is common on Windows where we called CreateProcess and the Process object
-                            // can't get the exit code.
-                            CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it has exited with unknown exit code. This can indicate a crash at startup", msbuildProcess.Id);
+                            try
+                            {
+                                CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it has exited with exit code {1}. This can indicate a crash at startup", msbuildProcess.Id, msbuildProcess.ExitCode);
+                            }
+                            catch (InvalidOperationException)
+                            {
+                                // This case is common on Windows where we called CreateProcess and the Process object
+                                // can't get the exit code.
+                                CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it has exited with unknown exit code. This can indicate a crash at startup", msbuildProcess.Id);
+                            }
                         }
                     }
+                    else
+                    {
+                        CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it is still running. This can occur when two multiprocess builds run in parallel and the other one 'stole' this node", msbuildProcess.Id);
+                    }
                 }
-                else
-                {
-                    CommunicationsUtilities.Trace("Could not connect to node with PID {0}; it is still running. This can occur when two multiprocess builds run in parallel and the other one 'stole' this node", msbuildProcess.Id);
-                }
+
+                return false;
             }
 
-            // We were unable to launch a node.
-            CommunicationsUtilities.Trace("FAILED TO CONNECT TO A CHILD NODE");
-            return null;
+            void CreateNodeContext(int nodeId, Process nodeToReuse, Stream nodeStream)
+            {
+                NodeContext nodeContext = new(nodeId, nodeToReuse, nodeStream, factory, terminateNode);
+                nodeContexts.Enqueue(nodeContext);
+                createNode(nodeContext);
+            }
         }
 
         /// <summary>
@@ -323,9 +389,9 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
         /// <param name="msbuildLocation"></param>
         /// <returns>
         /// Item 1 is the name of the process being searched for.
-        /// Item 2 is the list of processes themselves.
+        /// Item 2 is the ConcurrentQueue of ordered processes themselves.
         /// </returns>
-        private (string expectedProcessName, List<Process> nodeProcesses) GetPossibleRunningNodes(string msbuildLocation = null)
+        private (string expectedProcessName, IList<Process> nodeProcesses) GetPossibleRunningNodes(string msbuildLocation = null)
         {
             if (String.IsNullOrEmpty(msbuildLocation))
             {
@@ -334,12 +400,10 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
 
             var expectedProcessName = Path.GetFileNameWithoutExtension(GetCurrentHost() ?? msbuildLocation);
 
-            List<Process> nodeProcesses = new List<Process>(Process.GetProcessesByName(expectedProcessName));
-
-            // Trivial sort to try to prefer most recently used nodes
-            nodeProcesses.Sort((left, right) => left.Id - right.Id);
+            var processes = Process.GetProcessesByName(expectedProcessName);
+            Array.Sort(processes, (left, right) => left.Id.CompareTo(right.Id));
 
-            return (expectedProcessName, nodeProcesses);
+            return (expectedProcessName, processes);
         }
 
         /// <summary>
@@ -730,6 +794,11 @@ public NodeContext(int nodeId, Process process,
                 _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
             }
 
+            /// <summary>
+            /// Id of node.
+            /// </summary>
+            public int NodeId => _nodeId;
+
             /// <summary>
             /// Starts a new asynchronous read operation for this node.
             /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 453bd4346fc..b9a9d2a2f2f 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -162,7 +162,7 @@ internal static string TaskHostNameForClr2TaskHost
         /// <summary>
         /// Instantiates a new MSBuild process acting as a child node.
         /// </summary>
-        public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
+        public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory packetFactory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate)
         {
             throw new NotImplementedException("Use the other overload of CreateNode instead");
         }
@@ -550,31 +550,36 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
 
             CommunicationsUtilities.Trace("For a host context of {0}, spawning executable from {1}.", hostContext.ToString(), msbuildLocation ?? "MSBuild.exe");
 
-            // Make it here.
-            NodeContext context = GetNode
-                                    (
-                                        msbuildLocation,
-                                        commandLineArgs,
-                                        (int)hostContext,
-                                        this,
-                                        new Handshake(hostContext),
-                                        NodeContextTerminated
-                                    );
-
-            if (context != null)
-            {
-                _nodeContexts[hostContext] = context;
+            // There is always one task host per host context so we always create just 1 one task host node here.
+            int nodeId = (int)hostContext;
+            IList<NodeContext> nodeContexts = GetNodes(
+                msbuildLocation,
+                commandLineArgs,
+                nodeId,
+                this,
+                new Handshake(hostContext),
+                NodeContextCreated,
+                NodeContextTerminated,
+                1);
+
+            return nodeContexts.Count == 1;
+        }
 
-                // Start the asynchronous read.
-                context.BeginAsyncPacketRead();
+        /// <summary>
+        /// Method called when a context created.
+        /// </summary>
+        private void NodeContextCreated(NodeContext context)
+        {
+            _nodeContexts[(HandshakeOptions)context.NodeId] = context;
 
-                _activeNodes.Add((int)hostContext);
-                _noNodesActiveEvent.Reset();
+            // Start the asynchronous read.
+            context.BeginAsyncPacketRead();
 
-                return true;
+            lock (_activeNodes)
+            {
+                _activeNodes.Add(context.NodeId);
             }
-
-            return false;
+            _noNodesActiveEvent.Reset();
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index 91eb535887d..2b2102095b8 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -44,14 +44,10 @@ private TaskHostNodeManager()
 
         /// <summary>
         /// Creates a node on an available NodeProvider, if any..
+        /// Not used - base class <see cref="NodeProviderOutOfProcBase"/> implementation is reused instead.
         /// </summary>
-        /// <param name="configuration">The configuration to use for the remote node.</param>
-        /// <param name="nodeAffinity">The <see cref="NodeAffinity"/> to use.</param>
-        /// <returns>A NodeInfo describing the node created, or null if none could be created.</returns>
-        public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity)
-        {
-            throw new NotSupportedException("not used");
-        }
+        public IList<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity affinity, int numberOfNodesToCreate)
+            => throw new NotSupportedException("not used");
 
         /// <summary>
         /// Sends data to the specified node.
diff --git a/src/Build/BackEnd/Components/IBuildComponent.cs b/src/Build/BackEnd/Components/IBuildComponent.cs
index a133f4f31e1..6ee30b83ed9 100644
--- a/src/Build/BackEnd/Components/IBuildComponent.cs
+++ b/src/Build/BackEnd/Components/IBuildComponent.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#nullable disable
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 6f1f5152377..2f08099b333 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -4,12 +4,11 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
 using System.Linq;
 using System.Reflection;
 using System.Threading;
-using System.Threading.Tasks.Dataflow;
+using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
@@ -103,7 +102,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <summary>
         /// The mapping of build request configuration ids to project file names.
         /// </summary>
-        private Dictionary<int, string> _projectFileMap;
+        private ConcurrentDictionary<int, string> _projectFileMap;
 
         /// <summary>
         /// The current state of the logging service
@@ -167,12 +166,12 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <summary>
         /// The next project ID to assign when a project evaluation started event is received.
         /// </summary>
-        private int _nextEvaluationId = 1;
+        private int _nextEvaluationId;
 
         /// <summary>
         /// The next project ID to assign when a project started event is received.
         /// </summary>
-        private int _nextProjectId = 1;
+        private int _nextProjectId;
 
         /// <summary>
         /// The next target ID to assign when a target started event is received.
@@ -239,14 +238,32 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         #region LoggingThread Data
 
         /// <summary>
-        /// The data flow buffer for logging events.
+        /// Queue for asynchronous event processing.
         /// </summary>
-        private BufferBlock<object> _loggingQueue;
+        private ConcurrentQueue<object> _eventQueue;
 
         /// <summary>
-        /// The data flow processor for logging events.
+        /// Event set when message is consumed from queue.
         /// </summary>
-        private ActionBlock<object> _loggingQueueProcessor;
+        private ManualResetEventSlim _dequeueEvent;
+        /// <summary>
+        /// Event set when queue become empty.
+        /// </summary>
+        private ManualResetEventSlim _emptyQueueEvent;
+        /// <summary>
+        /// Even set when message is added into queue.
+        /// </summary>
+        private ManualResetEventSlim _enqueueEvent;
+
+        /// <summary>
+        /// CTS for stopping logging event processing.
+        /// </summary>
+        private CancellationTokenSource _loggingEventProcessingCancellation;
+
+        /// <summary>
+        /// Task which pump/process messages from <see cref="_eventQueue"/>
+        /// </summary>
+        private Thread _loggingEventProcessingThread;
 
         /// <summary>
         /// The queue size above which the queue will close to messages from remote nodes.
@@ -276,7 +293,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <param name="nodeId">The node identifier.</param>
         protected LoggingService(LoggerMode loggerMode, int nodeId)
         {
-            _projectFileMap = new Dictionary<int, string>();
+            _projectFileMap = new ConcurrentDictionary<int, string>();
             _logMode = loggerMode;
             _loggers = new List<ILogger>();
             _loggerDescriptions = new List<LoggerDescription>();
@@ -301,7 +318,7 @@ protected LoggingService(LoggerMode loggerMode, int nodeId)
 
             if (_logMode == LoggerMode.Asynchronous)
             {
-                CreateLoggingEventQueue();
+                StartLoggingEventProcessing();
             }
 
             // Ensure the static constructor of ItemGroupLoggingHelper runs.
@@ -372,11 +389,8 @@ public int NextEvaluationId
         {
             get
             {
-                lock (_lockObject)
-                {
-                    _nextEvaluationId += MaxCPUCount + 2 /* We can create one node more than the maxCPU count (this can happen if either the inproc or out of proc node has not been created yet and the project collection needs to be counted also)*/;
-                    return _nextEvaluationId;
-                }
+                // We can create one node more than the maxCPU count (this can happen if either the inproc or out of proc node has not been created yet and the project collection needs to be counted also)
+                return Interlocked.Add(ref _nextEvaluationId, MaxCPUCount + 2);
             }
         }
 
@@ -388,11 +402,8 @@ public int NextProjectId
         {
             get
             {
-                lock (_lockObject)
-                {
-                    _nextProjectId += MaxCPUCount + 2 /* We can create one node more than the maxCPU count (this can happen if either the inproc or out of proc node has not been created yet and the project collection needs to be counted also)*/;
-                    return _nextProjectId;
-                }
+                // We can create one node more than the maxCPU count (this can happen if either the inproc or out of proc node has not been created yet and the project collection needs to be counted also)
+                return Interlocked.Add(ref _nextProjectId, MaxCPUCount + 2);
             }
         }
 
@@ -404,11 +415,7 @@ public int NextTargetId
         {
             get
             {
-                lock (_lockObject)
-                {
-                    _nextTargetId++;
-                    return _nextTargetId;
-                }
+                return Interlocked.Increment(ref _nextTargetId);
             }
         }
 
@@ -420,11 +427,7 @@ public int NextTaskId
         {
             get
             {
-                lock (_lockObject)
-                {
-                    _nextTaskId++;
-                    return _nextTaskId;
-                }
+                return Interlocked.Increment(ref _nextTaskId);
             }
         }
 
@@ -690,28 +693,6 @@ private void AddWarningsAsMessagesOrErrors(ref IDictionary<int, ISet<string>> wa
             }
         }
 
-        /// <summary>
-        /// Return whether or not the LoggingQueue has any events left in it
-        /// </summary>
-        public bool LoggingQueueHasEvents
-        {
-            get
-            {
-                lock (_lockObject)
-                {
-                    if (_loggingQueue != null)
-                    {
-                        return _loggingQueue.Count > 0;
-                    }
-                    else
-                    {
-                        ErrorUtilities.ThrowInternalError("loggingQueue is null");
-                        return false;
-                    }
-                }
-            }
-        }
-
         /// <summary>
         /// Return an array which contains the logger type names
         /// this can be used to display which loggers are registered on the node
@@ -861,7 +842,7 @@ public void ShutdownComponent()
                         // 2. Terminate the logging event queue
                         if (_logMode == LoggerMode.Asynchronous)
                         {
-                            TerminateLoggingEventQueue();
+                            TerminateLoggingEventProcessing();
                         }
                     }
 
@@ -885,12 +866,7 @@ public void ShutdownComponent()
                     // sink for the central loggers.
                     _centralForwardingLoggerSinkId = -1;
 
-                    // Clean up anything related to the asynchronous logging
-                    if (_logMode == LoggerMode.Asynchronous)
-                    {
-                        _loggingQueue = null;
-                        _loggingQueueProcessor = null;
-                    }
+                    CleanLoggingEventProcessing();
 
                     _loggers = new List<ILogger>();
                     _loggerDescriptions = null;
@@ -924,7 +900,7 @@ public void PacketReceived(int node, INodePacket packet)
 
             LogMessagePacket loggingPacket = (LogMessagePacket)packet;
             InjectNonSerializedData(loggingPacket);
-            ProcessLoggingEvent(loggingPacket.NodeBuildEvent, allowThrottling: true);
+            ProcessLoggingEvent(loggingPacket.NodeBuildEvent);
         }
 
         /// <summary>
@@ -1150,46 +1126,43 @@ public void InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, I
         /// <exception cref="InternalErrorException">buildEvent is null</exception>
         public void LogBuildEvent(BuildEventArgs buildEvent)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(buildEvent != null, "buildEvent is null");
+            ErrorUtilities.VerifyThrow(buildEvent != null, "buildEvent is null");
 
-                BuildWarningEventArgs warningEvent = null;
-                BuildErrorEventArgs errorEvent = null;
-                BuildMessageEventArgs messageEvent = null;
+            BuildWarningEventArgs warningEvent = null;
+            BuildErrorEventArgs errorEvent = null;
+            BuildMessageEventArgs messageEvent = null;
 
-                if ((warningEvent = buildEvent as BuildWarningEventArgs) != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    warningEvent.ProjectFile = GetAndVerifyProjectFileFromContext(warningEvent.BuildEventContext);
-                }
-                else if ((errorEvent = buildEvent as BuildErrorEventArgs) != null && errorEvent.BuildEventContext != null && errorEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    errorEvent.ProjectFile = GetAndVerifyProjectFileFromContext(errorEvent.BuildEventContext);
-                }
-                else if ((messageEvent = buildEvent as BuildMessageEventArgs) != null && messageEvent.BuildEventContext != null && messageEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    messageEvent.ProjectFile = GetAndVerifyProjectFileFromContext(messageEvent.BuildEventContext);
-                }
+            if ((warningEvent = buildEvent as BuildWarningEventArgs) != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+            {
+                warningEvent.ProjectFile = GetAndVerifyProjectFileFromContext(warningEvent.BuildEventContext);
+            }
+            else if ((errorEvent = buildEvent as BuildErrorEventArgs) != null && errorEvent.BuildEventContext != null && errorEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+            {
+                errorEvent.ProjectFile = GetAndVerifyProjectFileFromContext(errorEvent.BuildEventContext);
+            }
+            else if ((messageEvent = buildEvent as BuildMessageEventArgs) != null && messageEvent.BuildEventContext != null && messageEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+            {
+                messageEvent.ProjectFile = GetAndVerifyProjectFileFromContext(messageEvent.BuildEventContext);
+            }
 
-                if (OnlyLogCriticalEvents)
-                {
-                    // Only log certain events if OnlyLogCriticalEvents is true
-                    if (
-                        (warningEvent != null)
-                        || (errorEvent != null)
-                        || (buildEvent is CustomBuildEventArgs)
-                        || (buildEvent is CriticalBuildMessageEventArgs)
-                       )
-                    {
-                        ProcessLoggingEvent(buildEvent);
-                    }
-                }
-                else
+            if (OnlyLogCriticalEvents)
+            {
+                // Only log certain events if OnlyLogCriticalEvents is true
+                if (
+                    (warningEvent != null)
+                    || (errorEvent != null)
+                    || (buildEvent is CustomBuildEventArgs)
+                    || (buildEvent is CriticalBuildMessageEventArgs)
+                   )
                 {
-                    // Log all events if OnlyLogCriticalEvents is false
                     ProcessLoggingEvent(buildEvent);
                 }
             }
+            else
+            {
+                // Log all events if OnlyLogCriticalEvents is false
+                ProcessLoggingEvent(buildEvent);
+            }
         }
 
         #endregion
@@ -1202,20 +1175,22 @@ public void LogBuildEvent(BuildEventArgs buildEvent)
         /// In Synchronous mode the event should be routed to the correct sink or logger right away
         /// </summary>
         /// <param name="buildEvent">BuildEventArgs to process</param>
-        /// <param name="allowThrottling"><code>true</code> to allow throttling, otherwise <code>false</code>.</param>
         /// <exception cref="InternalErrorException">buildEvent is null</exception>
-        internal virtual void ProcessLoggingEvent(object buildEvent, bool allowThrottling = false)
+        internal virtual void ProcessLoggingEvent(object buildEvent)
         {
             ErrorUtilities.VerifyThrow(buildEvent != null, "buildEvent is null");
             if (_logMode == LoggerMode.Asynchronous)
             {
-                // If the queue is at capacity, this call will block - the task returned by SendAsync only completes 
-                // when the message is actually consumed or rejected (permanently) by the buffer.
-                var task = _loggingQueue.SendAsync(buildEvent);
-                if (allowThrottling)
+                // Block until queue is not full.
+                while (_eventQueue.Count >= _queueCapacity)
                 {
-                    task.Wait();
+                    // Block and wait for dequeue event.
+                    _dequeueEvent.Wait();
+                    _dequeueEvent.Reset();
                 }
+
+                _eventQueue.Enqueue(buildEvent);
+                _enqueueEvent.Set();
             }
             else
             {
@@ -1227,41 +1202,21 @@ internal virtual void ProcessLoggingEvent(object buildEvent, bool allowThrottlin
         }
 
         /// <summary>
-        /// Wait for the logging messages in the logging queue to be completly processed.
+        /// Wait for the logging messages in the logging queue to be completely processed.
         /// This is required because for Logging build finished or when the component is to shutdown
         /// we need to make sure we process all of the events before the build finished event is raised
         /// and we need to make sure we process all of the logging events before we shutdown the component.
         /// </summary>
-        internal void WaitForThreadToProcessEvents()
+        public void WaitForLoggingToProcessEvents()
         {
-            // This method may be called in the shutdown submission callback, this callback may be called after the logging service has 
-            // shutdown and nulled out the events we were going to wait on.
-            if (_logMode == LoggerMode.Asynchronous && _loggingQueue != null)
+            while (_eventQueue?.IsEmpty == false)
             {
-                BufferBlock<object> loggingQueue = null;
-                ActionBlock<object> loggingQueueProcessor = null;
-
-                lock (_lockObject)
-                {
-                    loggingQueue = _loggingQueue;
-                    loggingQueueProcessor = _loggingQueueProcessor;
-
-                    // Replaces _loggingQueue and _loggingQueueProcessor with new one, this will assure that
-                    // no further messages could possibly be trying to be added into queue we are about to drain
-                    CreateLoggingEventQueue();
-                }
-
-                // Drain queue.
-                // This shall not be locked to avoid possible deadlock caused by
-                // event handlers to reenter 'this' instance while trying to log something.
-                if (loggingQueue != null)
-                {
-                    Debug.Assert(!Monitor.IsEntered(_lockObject));
-
-                    loggingQueue.Complete();
-                    loggingQueueProcessor.Completion.Wait();
-                }
+                _emptyQueueEvent?.Wait();
             }
+            // To avoid race condition when last message has been removed from queue but
+            //   not yet fully processed (handled by loggers), we need to make sure _emptyQueueEvent
+            //   is set as it is guaranteed to be in set state no sooner than after event has been processed.
+            _emptyQueueEvent?.Wait();
         }
 
         /// <summary>
@@ -1305,55 +1260,81 @@ private static int GetWarningsAsErrorOrMessageKey(BuildEventArgs buildEventArgs)
         }
 
         /// <summary>
-        /// Create a logging thread to process the logging queue
+        /// Create a logging thread to process the logging queue.
         /// </summary>
-        private void CreateLoggingEventQueue()
+        private void StartLoggingEventProcessing()
         {
-            // We are creating a two-node dataflow graph here.  The first node is a buffer, which will hold up to the number of
-            // logging events we have specified as the queueCapacity.  The second node is the processor which will actually process each message.
-            // When the capacity of the buffer is reached, further attempts to send messages to it will block.
-            // The reason we can't just set the BoundedCapacity on the processing block is that ActionBlock has some weird behavior
-            // when the queue capacity is reached.  Specifically, it will block new messages from being processed until it has
-            // entirely drained its input queue, as opposed to letting new ones in as old ones are processed.  This is logged as 
-            // a perf bug (305575) against Dataflow.  If they choose to fix it, we can eliminate the buffer node from the graph.
-            var dataBlockOptions = new DataflowBlockOptions
-            {
-                BoundedCapacity = Convert.ToInt32(_queueCapacity)
-            };
-
-            var loggingQueue = new BufferBlock<object>(dataBlockOptions);
-
-            var executionDataBlockOptions = new ExecutionDataflowBlockOptions
+            _eventQueue = new ConcurrentQueue<object>();
+            _dequeueEvent = new ManualResetEventSlim(false);
+            _emptyQueueEvent = new ManualResetEventSlim(false);
+            _enqueueEvent = new ManualResetEventSlim(false);
+            _loggingEventProcessingCancellation = new CancellationTokenSource();
+
+            _loggingEventProcessingThread = new Thread(LoggingEventProc);
+            _loggingEventProcessingThread.Name = $"MSBuild LoggingService events queue pump: {this.GetHashCode()}";
+            _loggingEventProcessingThread.IsBackground = true;
+            _loggingEventProcessingThread.Start();
+
+            void LoggingEventProc()
             {
-                BoundedCapacity = 1
-            };
+                var completeAdding = _loggingEventProcessingCancellation.Token;
+                WaitHandle[] waitHandlesForNextEvent = { completeAdding.WaitHandle, _enqueueEvent.WaitHandle };
 
-            var loggingQueueProcessor = new ActionBlock<object>(loggingEvent => LoggingEventProcessor(loggingEvent), executionDataBlockOptions);
+                do
+                {
+                    if (_eventQueue.TryDequeue(out object ev))
+                    {
+                        LoggingEventProcessor(ev);
+                        _dequeueEvent.Set();
+                    }
+                    else
+                    {
+                        _emptyQueueEvent.Set();
 
-            var dataLinkOptions = new DataflowLinkOptions
-            {
-                PropagateCompletion = true
-            };
+                        // Wait for next event, or finish.
+                        if (!completeAdding.IsCancellationRequested && _eventQueue.IsEmpty)
+                        {
+                            WaitHandle.WaitAny(waitHandlesForNextEvent);
+                        }
 
-            loggingQueue.LinkTo(loggingQueueProcessor, dataLinkOptions);
+                        _enqueueEvent.Reset();
+                        _emptyQueueEvent.Reset();
+                    }
+                } while (!_eventQueue.IsEmpty || !completeAdding.IsCancellationRequested);
 
-            lock (_lockObject)
-            {
-                _loggingQueue = loggingQueue;
-                _loggingQueueProcessor = loggingQueueProcessor;
+                _emptyQueueEvent.Set();
             }
         }
 
+
         /// <summary>
-        /// Wait for the logginQueue to empty and then terminate the logging thread
+        /// Clean resources used for logging event processing queue.
         /// </summary>
-        private void TerminateLoggingEventQueue()
+        private void CleanLoggingEventProcessing()
         {
-            // Dont accept any more items from other threads.
-            _loggingQueue.Complete();
+            _loggingEventProcessingCancellation?.Cancel();
+            _dequeueEvent?.Dispose();
+            _enqueueEvent?.Dispose();
+            _emptyQueueEvent?.Dispose();
+            _loggingEventProcessingCancellation?.Dispose();
+
+            _eventQueue = null;
+            _dequeueEvent = null;
+            _enqueueEvent = null;
+            _emptyQueueEvent = null;
+            _loggingEventProcessingCancellation = null;
+            _loggingEventProcessingThread = null;
+        }
 
-            // Wait for completion
-            _loggingQueueProcessor.Completion.Wait();
+        /// <summary>
+        /// Create a logging thread to process the logging queue
+        /// </summary>
+        private void TerminateLoggingEventProcessing()
+        {
+            // Capture pump task in local variable as cancelling event processing is nulling _loggingEventProcessingThread.
+            var pumpTask = _loggingEventProcessingThread;
+            _loggingEventProcessingCancellation.Cancel();
+            pumpTask.Join();
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index e1906fde381..214a5118c2c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -33,14 +33,11 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <exception cref="InternalErrorException">MessageResourceName is null</exception>
         public void LogComment(BuildEventContext buildEventContext, MessageImportance importance, string messageResourceName, params object[] messageArgs)
         {
-            lock (_lockObject)
+            if (!OnlyLogCriticalEvents)
             {
-                if (!OnlyLogCriticalEvents)
-                {
-                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for comment message.");
+                ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for comment message.");
 
-                    LogCommentFromText(buildEventContext, importance, ResourceUtilities.GetResourceString(messageResourceName), messageArgs);
-                }
+                LogCommentFromText(buildEventContext, importance, ResourceUtilities.GetResourceString(messageResourceName), messageArgs);
             }
         }
 
@@ -55,10 +52,7 @@ public void LogComment(BuildEventContext buildEventContext, MessageImportance im
         /// <exception cref="InternalErrorException">Message is null</exception>
         public void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message)
         {
-            lock (_lockObject)
-            {
-                this.LogCommentFromText(buildEventContext, importance, message, messageArgs: null);
-            }
+            this.LogCommentFromText(buildEventContext, importance, message, messageArgs: null);
         }
 
         /// <summary>
@@ -73,25 +67,22 @@ public void LogCommentFromText(BuildEventContext buildEventContext, MessageImpor
         /// <exception cref="InternalErrorException">Message is null</exception>
         public void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, params object[] messageArgs)
         {
-            lock (_lockObject)
+            if (!OnlyLogCriticalEvents)
             {
-                if (!OnlyLogCriticalEvents)
-                {
-                    ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext was null");
-                    ErrorUtilities.VerifyThrow(message != null, "message was null");
-
-                    BuildMessageEventArgs buildEvent = new BuildMessageEventArgs
-                        (
-                            message,
-                            helpKeyword: null,
-                            senderName: "MSBuild",
-                            importance,
-                            DateTime.UtcNow,
-                            messageArgs
-                        );
-                    buildEvent.BuildEventContext = buildEventContext;
-                    ProcessLoggingEvent(buildEvent);
-                }
+                ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext was null");
+                ErrorUtilities.VerifyThrow(message != null, "message was null");
+
+                BuildMessageEventArgs buildEvent = new BuildMessageEventArgs
+                    (
+                        message,
+                        helpKeyword: null,
+                        senderName: "MSBuild",
+                        importance,
+                        DateTime.UtcNow,
+                        messageArgs
+                    );
+                buildEvent.BuildEventContext = buildEventContext;
+                ProcessLoggingEvent(buildEvent);
             }
         }
         #endregion
@@ -113,10 +104,7 @@ public void LogCommentFromText(BuildEventContext buildEventContext, MessageImpor
         /// <param name="messageArgs">Arguments for the string resource</param>
         public void LogError(BuildEventContext location, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            lock (_lockObject)
-            {
-                LogError(location, null, file, messageResourceName, messageArgs);
-            }
+            LogError(location, null, file, messageResourceName, messageArgs);
         }
 
         /// <summary>
@@ -130,14 +118,11 @@ public void LogError(BuildEventContext location, BuildEventFileInfo file, string
         /// <exception cref="InternalErrorException">MessageResourceName is null</exception>
         public void LogError(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for error message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for error message.");
 
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, messageResourceName, messageArgs);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, messageResourceName, messageArgs);
 
-                LogErrorFromText(buildEventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
-            }
+            LogErrorFromText(buildEventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
         }
 
         /// <summary>
@@ -153,44 +138,41 @@ public void LogError(BuildEventContext buildEventContext, string subcategoryReso
         /// <exception cref="InternalErrorException">Message is null</exception>
         public void LogErrorFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(buildEventContext != null, "Must specify the buildEventContext");
-                ErrorUtilities.VerifyThrow(file != null, "Must specify the associated file.");
-                ErrorUtilities.VerifyThrow(message != null, "Need error message.");
-
-                string subcategory = null;
+            ErrorUtilities.VerifyThrow(buildEventContext != null, "Must specify the buildEventContext");
+            ErrorUtilities.VerifyThrow(file != null, "Must specify the associated file.");
+            ErrorUtilities.VerifyThrow(message != null, "Need error message.");
 
-                if (subcategoryResourceName != null)
-                {
-                    subcategory = AssemblyResources.GetString(subcategoryResourceName);
-                }
+            string subcategory = null;
 
-                BuildErrorEventArgs buildEvent =
-                new BuildErrorEventArgs
-                (
-                    subcategory,
-                    errorCode,
-                    file.File,
-                    file.Line,
-                    file.Column,
-                    file.EndLine,
-                    file.EndColumn,
-                    message,
-                    helpKeyword,
-                    "MSBuild"
-                );
-
-                buildEvent.BuildEventContext = buildEventContext;
-                if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
-                    ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
-                    buildEvent.ProjectFile = projectFile;
-                }
+            if (subcategoryResourceName != null)
+            {
+                subcategory = AssemblyResources.GetString(subcategoryResourceName);
+            }
 
-                ProcessLoggingEvent(buildEvent);
+            BuildErrorEventArgs buildEvent =
+            new BuildErrorEventArgs
+            (
+                subcategory,
+                errorCode,
+                file.File,
+                file.Line,
+                file.Column,
+                file.EndLine,
+                file.EndColumn,
+                message,
+                helpKeyword,
+                "MSBuild"
+            );
+
+            buildEvent.BuildEventContext = buildEventContext;
+            if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+            {
+                _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
+                ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
+                buildEvent.ProjectFile = projectFile;
             }
+
+            ProcessLoggingEvent(buildEvent);
         }
 
         /// <summary>
@@ -204,39 +186,36 @@ public void LogErrorFromText(BuildEventContext buildEventContext, string subcate
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public void LogInvalidProjectFileError(BuildEventContext buildEventContext, InvalidProjectFileException invalidProjectFileException)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(invalidProjectFileException != null, "Need exception context.");
-                ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext is null");
+            ErrorUtilities.VerifyThrow(invalidProjectFileException != null, "Need exception context.");
+            ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext is null");
 
-                // Don't log the exception more than once.
-                if (!invalidProjectFileException.HasBeenLogged)
+            // Don't log the exception more than once.
+            if (!invalidProjectFileException.HasBeenLogged)
+            {
+                BuildErrorEventArgs buildEvent =
+                    new BuildErrorEventArgs
+                    (
+                        invalidProjectFileException.ErrorSubcategory,
+                        invalidProjectFileException.ErrorCode,
+                        invalidProjectFileException.ProjectFile,
+                        invalidProjectFileException.LineNumber,
+                        invalidProjectFileException.ColumnNumber,
+                        invalidProjectFileException.EndLineNumber,
+                        invalidProjectFileException.EndColumnNumber,
+                        invalidProjectFileException.BaseMessage,
+                        invalidProjectFileException.HelpKeyword,
+                        "MSBuild"
+                    );
+                buildEvent.BuildEventContext = buildEventContext;
+                if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
                 {
-                    BuildErrorEventArgs buildEvent =
-                        new BuildErrorEventArgs
-                        (
-                            invalidProjectFileException.ErrorSubcategory,
-                            invalidProjectFileException.ErrorCode,
-                            invalidProjectFileException.ProjectFile,
-                            invalidProjectFileException.LineNumber,
-                            invalidProjectFileException.ColumnNumber,
-                            invalidProjectFileException.EndLineNumber,
-                            invalidProjectFileException.EndColumnNumber,
-                            invalidProjectFileException.BaseMessage,
-                            invalidProjectFileException.HelpKeyword,
-                            "MSBuild"
-                        );
-                    buildEvent.BuildEventContext = buildEventContext;
-                    if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                    {
-                        _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
-                        ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
-                        buildEvent.ProjectFile = projectFile;
-                    }
-
-                    ProcessLoggingEvent(buildEvent);
-                    invalidProjectFileException.HasBeenLogged = true;
+                    _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
+                    ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
+                    buildEvent.ProjectFile = projectFile;
                 }
+
+                ProcessLoggingEvent(buildEvent);
+                invalidProjectFileException.HasBeenLogged = true;
             }
         }
 
@@ -249,10 +228,7 @@ public void LogInvalidProjectFileError(BuildEventContext buildEventContext, Inva
         /// <param name="file">Provides file information about where the build error happened</param>
         public void LogFatalBuildError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file)
         {
-            lock (_lockObject)
-            {
-                LogFatalError(buildEventContext, exception, file, "FatalBuildError");
-            }
+            LogFatalError(buildEventContext, exception, file, "FatalBuildError");
         }
 
         /// <summary>
@@ -266,12 +242,9 @@ public void LogFatalBuildError(BuildEventContext buildEventContext, Exception ex
         /// <exception cref="InternalErrorException">TaskName is null</exception>
         public void LogFatalTaskError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(taskName != null, "Must specify the name of the task that failed.");
+            ErrorUtilities.VerifyThrow(taskName != null, "Must specify the name of the task that failed.");
 
-                LogFatalError(buildEventContext, exception, file, "FatalTaskError", taskName);
-            }
+            LogFatalError(buildEventContext, exception, file, "FatalTaskError", taskName);
         }
 
         /// <summary>
@@ -286,21 +259,18 @@ public void LogFatalTaskError(BuildEventContext buildEventContext, Exception exc
         /// <exception cref="InternalErrorException">MessageResourceName is null</exception>
         public void LogFatalError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for error message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for error message.");
 
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, messageResourceName, messageArgs);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, messageResourceName, messageArgs);
 #if DEBUG
-                message += Environment.NewLine + "This is an unhandled exception from a task -- PLEASE OPEN A BUG AGAINST THE TASK OWNER.";
+            message += Environment.NewLine + "This is an unhandled exception from a task -- PLEASE OPEN A BUG AGAINST THE TASK OWNER.";
 #endif
-                if (exception != null)
-                {
-                    message += Environment.NewLine + exception.ToString();
-                }
-
-                LogErrorFromText(buildEventContext, null, errorCode, helpKeyword, file, message);
+            if (exception != null)
+            {
+                message += Environment.NewLine + exception.ToString();
             }
+
+            LogErrorFromText(buildEventContext, null, errorCode, helpKeyword, file, message);
         }
 
         #endregion
@@ -323,22 +293,19 @@ public void LogFatalError(BuildEventContext buildEventContext, Exception excepti
         /// <param name="taskName">Name of the task which the warning is being raised from</param>
         public void LogTaskWarningFromException(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(!String.IsNullOrEmpty(taskName), "Must specify the name of the task that failed.");
+            ErrorUtilities.VerifyThrow(!String.IsNullOrEmpty(taskName), "Must specify the name of the task that failed.");
 
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string warningCode, out string helpKeyword, "FatalTaskError", taskName);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string warningCode, out string helpKeyword, "FatalTaskError", taskName);
 #if DEBUG
-                message += Environment.NewLine + "This is an unhandled exception from a task -- PLEASE OPEN A BUG AGAINST THE TASK OWNER.";
+            message += Environment.NewLine + "This is an unhandled exception from a task -- PLEASE OPEN A BUG AGAINST THE TASK OWNER.";
 #endif
 
-                if (exception != null)
-                {
-                    message += Environment.NewLine + exception.ToString();
-                }
-
-                LogWarningFromText(buildEventContext, null, warningCode, helpKeyword, file, message);
+            if (exception != null)
+            {
+                message += Environment.NewLine + exception.ToString();
             }
+
+            LogWarningFromText(buildEventContext, null, warningCode, helpKeyword, file, message);
         }
 
         /// <summary>
@@ -351,13 +318,10 @@ public void LogTaskWarningFromException(BuildEventContext buildEventContext, Exc
         /// <param name="messageArgs">Arguments for messageResourceName</param>
         public void LogWarning(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for warning message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(messageResourceName), "Need resource string for warning message.");
 
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string warningCode, out string helpKeyword, messageResourceName, messageArgs);
-                LogWarningFromText(buildEventContext, subcategoryResourceName, warningCode, helpKeyword, file, message);
-            }
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string warningCode, out string helpKeyword, messageResourceName, messageArgs);
+            LogWarningFromText(buildEventContext, subcategoryResourceName, warningCode, helpKeyword, file, message);
         }
 
         /// <summary>
@@ -371,43 +335,40 @@ public void LogWarning(BuildEventContext buildEventContext, string subcategoryRe
         /// <param name="message">Warning message to log</param>
         public void LogWarningFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(file != null, "Must specify the associated file.");
-                ErrorUtilities.VerifyThrow(message != null, "Need warning message.");
-                ErrorUtilities.VerifyThrow(buildEventContext != null, "Need a BuildEventContext");
+            ErrorUtilities.VerifyThrow(file != null, "Must specify the associated file.");
+            ErrorUtilities.VerifyThrow(message != null, "Need warning message.");
+            ErrorUtilities.VerifyThrow(buildEventContext != null, "Need a BuildEventContext");
 
-                string subcategory = null;
+            string subcategory = null;
 
-                if (!string.IsNullOrWhiteSpace(subcategoryResourceName))
-                {
-                    subcategory = AssemblyResources.GetString(subcategoryResourceName);
-                }
-
-                BuildWarningEventArgs buildEvent = new BuildWarningEventArgs
-                    (
-                        subcategory,
-                        warningCode,
-                        file.File,
-                        file.Line,
-                        file.Column,
-                        file.EndLine,
-                        file.EndColumn,
-                        message,
-                        helpKeyword,
-                        "MSBuild"
-                    );
+            if (!string.IsNullOrWhiteSpace(subcategoryResourceName))
+            {
+                subcategory = AssemblyResources.GetString(subcategoryResourceName);
+            }
 
-                buildEvent.BuildEventContext = buildEventContext;
-                if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
-                    ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
-                    buildEvent.ProjectFile = projectFile;
-                }
+            BuildWarningEventArgs buildEvent = new BuildWarningEventArgs
+                (
+                    subcategory,
+                    warningCode,
+                    file.File,
+                    file.Line,
+                    file.Column,
+                    file.EndLine,
+                    file.EndColumn,
+                    message,
+                    helpKeyword,
+                    "MSBuild"
+                );
 
-                ProcessLoggingEvent(buildEvent);
+            buildEvent.BuildEventContext = buildEventContext;
+            if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+            {
+                _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
+                ErrorUtilities.VerifyThrow(projectFile != null, "ContextID {0} should have been in the ID-to-project file mapping but wasn't!", buildEventContext.ProjectContextId);
+                buildEvent.ProjectFile = projectFile;
             }
+
+            ProcessLoggingEvent(buildEvent);
         }
 
         #endregion
@@ -419,31 +380,28 @@ public void LogWarningFromText(BuildEventContext buildEventContext, string subca
         /// </summary>
         public void LogBuildStarted()
         {
-            lock (_lockObject)
+            // If we're only logging critical events, don't risk causing all the resources to load by formatting
+            // a string that won't get emitted anyway.
+            string message = String.Empty;
+            if (!OnlyLogCriticalEvents)
             {
-                // If we're only logging critical events, don't risk causing all the resources to load by formatting
-                // a string that won't get emitted anyway.
-                string message = String.Empty;
-                if (!OnlyLogCriticalEvents)
-                {
-                    message = ResourceUtilities.GetResourceString("BuildStarted");
-                }
+                message = ResourceUtilities.GetResourceString("BuildStarted");
+            }
 
-                IDictionary<string, string> environmentProperties = null;
+            IDictionary<string, string> environmentProperties = null;
 
-                if (_componentHost?.BuildParameters != null)
-                {
-                    environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
-                }
+            if (_componentHost?.BuildParameters != null)
+            {
+                environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
+            }
 
-                BuildStartedEventArgs buildEvent = new BuildStartedEventArgs(message, null /* no help keyword */, environmentProperties);
+            BuildStartedEventArgs buildEvent = new BuildStartedEventArgs(message, null /* no help keyword */, environmentProperties);
 
-                // Raise the event with the filters
-                ProcessLoggingEvent(buildEvent);
-            }
+            // Raise the event with the filters
+            ProcessLoggingEvent(buildEvent);
 
             // Make sure we process this event before going any further
-            WaitForThreadToProcessEvents();
+            WaitForLoggingToProcessEvents();
         }
 
         /// <summary>
@@ -452,23 +410,20 @@ public void LogBuildStarted()
         /// <param name="success">Did the build pass or fail</param>
         public void LogBuildFinished(bool success)
         {
-            lock (_lockObject)
+            // If we're only logging critical events, don't risk causing all the resources to load by formatting
+            // a string that won't get emitted anyway.
+            string message = String.Empty;
+            if (!OnlyLogCriticalEvents)
             {
-                // If we're only logging critical events, don't risk causing all the resources to load by formatting
-                // a string that won't get emitted anyway.
-                string message = String.Empty;
-                if (!OnlyLogCriticalEvents)
-                {
-                    message = ResourceUtilities.GetResourceString(success ? "BuildFinishedSuccess" : "BuildFinishedFailure");
-                }
+                message = ResourceUtilities.GetResourceString(success ? "BuildFinishedSuccess" : "BuildFinishedFailure");
+            }
 
-                BuildFinishedEventArgs buildEvent = new BuildFinishedEventArgs(message, null /* no help keyword */, success);
+            BuildFinishedEventArgs buildEvent = new BuildFinishedEventArgs(message, null /* no help keyword */, success);
 
-                ProcessLoggingEvent(buildEvent);
-            }
+            ProcessLoggingEvent(buildEvent);
 
             // Make sure we process this event before going any further
-            WaitForThreadToProcessEvents();
+            WaitForLoggingToProcessEvents();
         }
 
         /// <inheritdoc />
@@ -482,36 +437,30 @@ public BuildEventContext CreateProjectCacheBuildEventContext(
             int projectInstanceId,
             string projectFile)
         {
-            lock (_lockObject)
-            {
-                int projectContextId = NextProjectId;
+            int projectContextId = NextProjectId;
 
-                // In the future if some LogProjectCacheStarted event is created, move this there to align with evaluation and build execution.
-                _projectFileMap[projectContextId] = projectFile;
+            // In the future if some LogProjectCacheStarted event is created, move this there to align with evaluation and build execution.
+            _projectFileMap[projectContextId] = projectFile;
 
-                // Because the project cache runs in the BuildManager, it makes some sense to associate logging with the in-proc node.
-                // If a invalid node id is used the messages become deferred in the console logger and spit out at the end.
-                int nodeId = Scheduler.InProcNodeId;
+            // Because the project cache runs in the BuildManager, it makes some sense to associate logging with the in-proc node.
+            // If a invalid node id is used the messages become deferred in the console logger and spit out at the end.
+            int nodeId = Scheduler.InProcNodeId;
 
-                return new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-            }
+            return new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
         }
 
         /// <inheritdoc />
         public void LogProjectEvaluationStarted(BuildEventContext projectEvaluationEventContext, string projectFile)
         {
-            lock (_lockObject)
-            {
-                ProjectEvaluationStartedEventArgs evaluationEvent =
-                    new ProjectEvaluationStartedEventArgs(ResourceUtilities.GetResourceString("EvaluationStarted"),
-                        projectFile)
-                    {
-                        BuildEventContext = projectEvaluationEventContext,
-                        ProjectFile = projectFile
-                    };
+            ProjectEvaluationStartedEventArgs evaluationEvent =
+                new ProjectEvaluationStartedEventArgs(ResourceUtilities.GetResourceString("EvaluationStarted"),
+                    projectFile)
+                {
+                    BuildEventContext = projectEvaluationEventContext,
+                    ProjectFile = projectFile
+                };
 
-                ProcessLoggingEvent(evaluationEvent);
-            }
+            ProcessLoggingEvent(evaluationEvent);
         }
 
         /// <summary>
@@ -532,22 +481,19 @@ public void LogProjectEvaluationFinished(
             IEnumerable items,
             ProfilerResult? profilerResult)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(projectEvaluationEventContext != null, "projectBuildEventContext");
+            ErrorUtilities.VerifyThrow(projectEvaluationEventContext != null, "projectBuildEventContext");
 
-                ProjectEvaluationFinishedEventArgs buildEvent =
-                    new ProjectEvaluationFinishedEventArgs(ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile)
-                    {
-                        BuildEventContext = projectEvaluationEventContext,
-                        ProjectFile = projectFile,
-                        ProfilerResult = profilerResult,
-                        GlobalProperties = globalProperties,
-                        Properties = properties,
-                        Items = items
-                    };
-                ProcessLoggingEvent(buildEvent);
-            }
+            ProjectEvaluationFinishedEventArgs buildEvent =
+                new ProjectEvaluationFinishedEventArgs(ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile)
+                {
+                    BuildEventContext = projectEvaluationEventContext,
+                    ProjectFile = projectFile,
+                    ProfilerResult = profilerResult,
+                    GlobalProperties = globalProperties,
+                    Properties = properties,
+                    Items = items
+                };
+            ProcessLoggingEvent(buildEvent);
         }
 
         /// <summary>
@@ -578,76 +524,73 @@ public BuildEventContext LogProjectStarted(
             int evaluationId = BuildEventContext.InvalidEvaluationId,
             int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
-            lock (_lockObject)
+            ErrorUtilities.VerifyThrow(nodeBuildEventContext != null, "Need a nodeBuildEventContext");
+
+            if (projectContextId == BuildEventContext.InvalidProjectContextId)
             {
-                ErrorUtilities.VerifyThrow(nodeBuildEventContext != null, "Need a nodeBuildEventContext");
+                projectContextId = NextProjectId;
 
-                if (projectContextId == BuildEventContext.InvalidProjectContextId)
+                // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
+                if (_projectFileMap.ContainsKey(projectContextId))
                 {
-                    projectContextId = NextProjectId;
+                    ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should not already be in the ID-to-file mapping!", projectContextId, projectFile);
+                }
 
-                    // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
-                    if (_projectFileMap.ContainsKey(projectContextId))
+                _projectFileMap[projectContextId] = projectFile;
+            }
+            else
+            {
+                // A projectContextId was provided, so use it with some sanity checks
+                if (_projectFileMap.TryGetValue(projectContextId, out string existingProjectFile))
+                {
+                    if (!projectFile.Equals(existingProjectFile, StringComparison.OrdinalIgnoreCase))
                     {
-                        ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should not already be in the ID-to-file mapping!", projectContextId, projectFile);
+                        ErrorUtilities.ThrowInternalError("ContextID {0} was already in the ID-to-project file mapping but the project file {1} did not match the provided one {2}!", projectContextId, existingProjectFile, projectFile);
                     }
-
-                    _projectFileMap[projectContextId] = projectFile;
                 }
                 else
                 {
-                    // A projectContextId was provided, so use it with some sanity checks
-                    if (_projectFileMap.TryGetValue(projectContextId, out string existingProjectFile))
+                    // Currently, an existing projectContextId can only be provided in the project cache scenario, which runs on the in-proc node.
+                    // If there was a cache miss and the build was scheduled on a worker node, it may not have seen this projectContextId yet.
+                    // So we only need this sanity check for the in-proc node.
+                    if (nodeBuildEventContext.NodeId == Scheduler.InProcNodeId)
                     {
-                        if (!projectFile.Equals(existingProjectFile, StringComparison.OrdinalIgnoreCase))
-                        {
-                            ErrorUtilities.ThrowInternalError("ContextID {0} was already in the ID-to-project file mapping but the project file {1} did not match the provided one {2}!", projectContextId, existingProjectFile, projectFile);
-                        }
-                    }
-                    else
-                    {
-                        // Currently, an existing projectContextId can only be provided in the project cache scenario, which runs on the in-proc node.
-                        // If there was a cache miss and the build was scheduled on a worker node, it may not have seen this projectContextId yet.
-                        // So we only need this sanity check for the in-proc node.
-                        if (nodeBuildEventContext.NodeId == Scheduler.InProcNodeId)
-                        {
-                            ErrorUtilities.ThrowInternalError("ContextID {0} should have been in the ID-to-project file mapping but wasn't!", projectContextId);
-                        }
-
-                        _projectFileMap[projectContextId] = projectFile;
+                        ErrorUtilities.ThrowInternalError("ContextID {0} should have been in the ID-to-project file mapping but wasn't!", projectContextId);
                     }
+
+                    _projectFileMap[projectContextId] = projectFile;
                 }
+            }
 
-                BuildEventContext projectBuildEventContext = new BuildEventContext(submissionId, nodeBuildEventContext.NodeId, evaluationId, configurationId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+            BuildEventContext projectBuildEventContext = new BuildEventContext(submissionId, nodeBuildEventContext.NodeId, evaluationId, configurationId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
 
-                ErrorUtilities.VerifyThrow(parentBuildEventContext != null, "Need a parentBuildEventContext");
+            ErrorUtilities.VerifyThrow(parentBuildEventContext != null, "Need a parentBuildEventContext");
 
-                ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(configurationId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
-                var buildRequestConfiguration = _configCache.Value[configurationId];
+            ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(configurationId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
+            var buildRequestConfiguration = _configCache.Value[configurationId];
 
-                // Always log GlobalProperties on ProjectStarted
-                // See https://github.com/dotnet/msbuild/issues/6341 for details
-                IDictionary<string, string> globalProperties = buildRequestConfiguration.GlobalProperties.ToDictionary();
+            // Always log GlobalProperties on ProjectStarted
+            // See https://github.com/dotnet/msbuild/issues/6341 for details
+            IDictionary<string, string> globalProperties = buildRequestConfiguration.GlobalProperties.ToDictionary();
 
-                var buildEvent = new ProjectStartedEventArgs
-                    (
-                        configurationId,
-                        message: null,
-                        helpKeyword: null,
-                        projectFile,
-                        targetNames,
-                        properties,
-                        items,
-                        parentBuildEventContext,
-                        globalProperties,
-                        buildRequestConfiguration.ToolsVersion
-                    );
-                buildEvent.BuildEventContext = projectBuildEventContext;
+            var buildEvent = new ProjectStartedEventArgs
+                (
+                    configurationId,
+                    message: null,
+                    helpKeyword: null,
+                    projectFile,
+                    targetNames,
+                    properties,
+                    items,
+                    parentBuildEventContext,
+                    globalProperties,
+                    buildRequestConfiguration.ToolsVersion
+                );
+            buildEvent.BuildEventContext = projectBuildEventContext;
 
-                ProcessLoggingEvent(buildEvent);
+            ProcessLoggingEvent(buildEvent);
 
-                return projectBuildEventContext;
-            }
+            return projectBuildEventContext;
         }
 
         /// <summary>
@@ -659,25 +602,22 @@ public BuildEventContext LogProjectStarted(
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public void LogProjectFinished(BuildEventContext projectBuildEventContext, string projectFile, bool success)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(projectBuildEventContext != null, "projectBuildEventContext");
+            ErrorUtilities.VerifyThrow(projectBuildEventContext != null, "projectBuildEventContext");
 
-                ProjectFinishedEventArgs buildEvent = new ProjectFinishedEventArgs
-                    (
-                        message: null,
-                        helpKeyword: null,
-                        projectFile,
-                        success
-                    );
-                buildEvent.BuildEventContext = projectBuildEventContext;
-                ProcessLoggingEvent(buildEvent);
+            ProjectFinishedEventArgs buildEvent = new ProjectFinishedEventArgs
+                (
+                    message: null,
+                    helpKeyword: null,
+                    projectFile,
+                    success
+                );
+            buildEvent.BuildEventContext = projectBuildEventContext;
+            ProcessLoggingEvent(buildEvent);
 
-                // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
-                if (!_projectFileMap.Remove(projectBuildEventContext.ProjectContextId))
-                {
-                    ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should be in the ID-to-file mapping!", projectBuildEventContext.ProjectContextId, projectFile);
-                }
+            // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
+            if (!_projectFileMap.TryRemove(projectBuildEventContext.ProjectContextId, out _))
+            {
+                ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should be in the ID-to-file mapping!", projectBuildEventContext.ProjectContextId, projectFile);
             }
         }
 
@@ -694,38 +634,35 @@ public void LogProjectFinished(BuildEventContext projectBuildEventContext, strin
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public BuildEventContext LogTargetStarted(BuildEventContext projectBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, string parentTargetName, TargetBuiltReason buildReason)
         {
-            lock (_lockObject)
+            ErrorUtilities.VerifyThrow(projectBuildEventContext != null, "projectBuildEventContext is null");
+            BuildEventContext targetBuildEventContext = new BuildEventContext
+                (
+                    projectBuildEventContext.SubmissionId,
+                    projectBuildEventContext.NodeId,
+                    projectBuildEventContext.ProjectInstanceId,
+                    projectBuildEventContext.ProjectContextId,
+                    NextTargetId,
+                    BuildEventContext.InvalidTaskId
+                );
+
+            if (!OnlyLogCriticalEvents)
             {
-                ErrorUtilities.VerifyThrow(projectBuildEventContext != null, "projectBuildEventContext is null");
-                BuildEventContext targetBuildEventContext = new BuildEventContext
+                TargetStartedEventArgs buildEvent = new TargetStartedEventArgs
                     (
-                        projectBuildEventContext.SubmissionId,
-                        projectBuildEventContext.NodeId,
-                        projectBuildEventContext.ProjectInstanceId,
-                        projectBuildEventContext.ProjectContextId,
-                        NextTargetId,
-                        BuildEventContext.InvalidTaskId
+                        message: null,
+                        helpKeyword: null,
+                        targetName,
+                        projectFile,
+                        projectFileOfTargetElement,
+                        parentTargetName,
+                        buildReason,
+                        DateTime.UtcNow
                     );
-
-                if (!OnlyLogCriticalEvents)
-                {
-                    TargetStartedEventArgs buildEvent = new TargetStartedEventArgs
-                        (
-                            message: null,
-                            helpKeyword: null,
-                            targetName,
-                            projectFile,
-                            projectFileOfTargetElement,
-                            parentTargetName,
-                            buildReason,
-                            DateTime.UtcNow
-                        );
-                    buildEvent.BuildEventContext = targetBuildEventContext;
-                    ProcessLoggingEvent(buildEvent);
-                }
-
-                return targetBuildEventContext;
+                buildEvent.BuildEventContext = targetBuildEventContext;
+                ProcessLoggingEvent(buildEvent);
             }
+
+            return targetBuildEventContext;
         }
 
         /// <summary>
@@ -740,26 +677,23 @@ public BuildEventContext LogTargetStarted(BuildEventContext projectBuildEventCon
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public void LogTargetFinished(BuildEventContext targetBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, bool success, IEnumerable<TaskItem> targetOutputs)
         {
-            lock (_lockObject)
+            if (!OnlyLogCriticalEvents)
             {
-                if (!OnlyLogCriticalEvents)
-                {
-                    ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
-
-                    TargetFinishedEventArgs buildEvent = new TargetFinishedEventArgs
-                        (
-                            message: null,
-                            helpKeyword: null,
-                            targetName,
-                            projectFile,
-                            projectFileOfTargetElement,
-                            success,
-                            targetOutputs
-                        );
-
-                    buildEvent.BuildEventContext = targetBuildEventContext;
-                    ProcessLoggingEvent(buildEvent);
-                }
+                ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
+
+                TargetFinishedEventArgs buildEvent = new TargetFinishedEventArgs
+                    (
+                        message: null,
+                        helpKeyword: null,
+                        targetName,
+                        projectFile,
+                        projectFileOfTargetElement,
+                        success,
+                        targetOutputs
+                    );
+
+                buildEvent.BuildEventContext = targetBuildEventContext;
+                ProcessLoggingEvent(buildEvent);
             }
         }
 
@@ -773,22 +707,19 @@ public void LogTargetFinished(BuildEventContext targetBuildEventContext, string
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)
         {
-            lock (_lockObject)
+            ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "targetBuildEventContext is null");
+            if (!OnlyLogCriticalEvents)
             {
-                ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "targetBuildEventContext is null");
-                if (!OnlyLogCriticalEvents)
-                {
-                    TaskStartedEventArgs buildEvent = new TaskStartedEventArgs
-                        (
-                            message: null,
-                            helpKeyword: null,
-                            projectFile,
-                            projectFileOfTaskNode,
-                            taskName
-                        );
-                    buildEvent.BuildEventContext = taskBuildEventContext;
-                    ProcessLoggingEvent(buildEvent);
-                }
+                TaskStartedEventArgs buildEvent = new TaskStartedEventArgs
+                    (
+                        message: null,
+                        helpKeyword: null,
+                        projectFile,
+                        projectFileOfTaskNode,
+                        taskName
+                    );
+                buildEvent.BuildEventContext = taskBuildEventContext;
+                ProcessLoggingEvent(buildEvent);
             }
         }
 
@@ -805,37 +736,34 @@ public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskN
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column)
         {
-            lock (_lockObject)
+            ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
+            BuildEventContext taskBuildEventContext = new BuildEventContext
+                (
+                    targetBuildEventContext.SubmissionId,
+                    targetBuildEventContext.NodeId,
+                    targetBuildEventContext.ProjectInstanceId,
+                    targetBuildEventContext.ProjectContextId,
+                    targetBuildEventContext.TargetId,
+                    NextTaskId
+                );
+
+            if (!OnlyLogCriticalEvents)
             {
-                ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
-                BuildEventContext taskBuildEventContext = new BuildEventContext
+                TaskStartedEventArgs buildEvent = new TaskStartedEventArgs
                     (
-                        targetBuildEventContext.SubmissionId,
-                        targetBuildEventContext.NodeId,
-                        targetBuildEventContext.ProjectInstanceId,
-                        targetBuildEventContext.ProjectContextId,
-                        targetBuildEventContext.TargetId,
-                        NextTaskId
+                        message: null,
+                        helpKeyword: null,
+                        projectFile,
+                        projectFileOfTaskNode,
+                        taskName
                     );
-
-                if (!OnlyLogCriticalEvents)
-                {
-                    TaskStartedEventArgs buildEvent = new TaskStartedEventArgs
-                        (
-                            message: null,
-                            helpKeyword: null,
-                            projectFile,
-                            projectFileOfTaskNode,
-                            taskName
-                        );
-                    buildEvent.BuildEventContext = taskBuildEventContext;
-                    buildEvent.LineNumber = line;
-                    buildEvent.ColumnNumber = column;
-                    ProcessLoggingEvent(buildEvent);
-                }
-
-                return taskBuildEventContext;
+                buildEvent.BuildEventContext = taskBuildEventContext;
+                buildEvent.LineNumber = line;
+                buildEvent.ColumnNumber = column;
+                ProcessLoggingEvent(buildEvent);
             }
+
+            return taskBuildEventContext;
         }
 
         /// <summary>
@@ -849,24 +777,21 @@ public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventConte
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
         public void LogTaskFinished(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, bool success)
         {
-            lock (_lockObject)
+            if (!OnlyLogCriticalEvents)
             {
-                if (!OnlyLogCriticalEvents)
-                {
-                    ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "taskBuildEventContext is null");
-
-                    TaskFinishedEventArgs buildEvent = new TaskFinishedEventArgs
-                        (
-                            message: null,
-                            helpKeyword: null,
-                            projectFile,
-                            projectFileOfTaskNode,
-                            taskName,
-                            success
-                        );
-                    buildEvent.BuildEventContext = taskBuildEventContext;
-                    ProcessLoggingEvent(buildEvent);
-                }
+                ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "taskBuildEventContext is null");
+
+                TaskFinishedEventArgs buildEvent = new TaskFinishedEventArgs
+                    (
+                        message: null,
+                        helpKeyword: null,
+                        projectFile,
+                        projectFileOfTaskNode,
+                        taskName,
+                        success
+                    );
+                buildEvent.BuildEventContext = taskBuildEventContext;
+                ProcessLoggingEvent(buildEvent);
             }
         }
 
@@ -882,19 +807,16 @@ public void LogTaskFinished(BuildEventContext taskBuildEventContext, string task
         /// <param name="properties">The list of properties assocated with the event.</param>
         public void LogTelemetry(BuildEventContext buildEventContext, string eventName, IDictionary<string, string> properties)
         {
-            lock (_lockObject)
-            {
-                ErrorUtilities.VerifyThrow(eventName != null, "eventName is null");
+            ErrorUtilities.VerifyThrow(eventName != null, "eventName is null");
 
-                TelemetryEventArgs telemetryEvent = new TelemetryEventArgs
-                {
-                    BuildEventContext = buildEventContext,
-                    EventName = eventName,
-                    Properties = properties == null ? new Dictionary<string, string>() : new Dictionary<string, string>(properties)
-                };
+            TelemetryEventArgs telemetryEvent = new TelemetryEventArgs
+            {
+                BuildEventContext = buildEventContext,
+                EventName = eventName,
+                Properties = properties == null ? new Dictionary<string, string>() : new Dictionary<string, string>(properties)
+            };
 
-                ProcessLoggingEvent(telemetryEvent);
-            }
+            ProcessLoggingEvent(telemetryEvent);
         }
 
         #endregion
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 0adf9e61756..6fb05e271d0 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -23,6 +23,7 @@
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using ProjectItemFactory = Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory;
 using System.Globalization;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Globbing;
@@ -3287,6 +3288,10 @@ public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnum
                 if (!IsBuildEnabled)
                 {
                     LoggingService.LogError(s_buildEventContext, new BuildEventFileInfo(FullPath), "SecurityProjectBuildDisabled");
+                    if (LoggingService is LoggingService defaultLoggingService)
+                    {
+                        defaultLoggingService.WaitForLoggingToProcessEvents();
+                    }
                     return false;
                 }
 
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 485b905abe0..32f9b37fe68 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -225,6 +225,12 @@ public void Dispose()
         /// </summary>
         private int _maxNodeCount;
 
+        /// <summary>
+        /// LoggingService Logger mode.
+        /// If Asynchronous mode is used
+        /// </summary>
+        private LoggerMode _loggerMode;
+
         /// <summary>
         /// Instantiates a project collection with no global properties or loggers that reads toolset
         /// information from the configuration file and registry.
@@ -302,6 +308,27 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab
         /// <param name="onlyLogCriticalEvents">If set to true, only critical events will be logged.</param>
         /// <param name="loadProjectsReadOnly">If set to true, load all projects as read-only.</param>
         public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly)
+            : this(globalProperties, loggers, remoteLoggers, toolsetDefinitionLocations, maxNodeCount, onlyLogCriticalEvents, loadProjectsReadOnly, useAsynchronousLogging: false)
+        {
+        }
+
+
+        /// <summary>
+        /// Instantiates a project collection with specified global properties and loggers and using the
+        /// specified toolset locations, node count, and setting of onlyLogCriticalEvents.
+        /// Global properties and loggers may be null.
+        /// Throws InvalidProjectFileException if any of the global properties are reserved.
+        /// May throw InvalidToolsetDefinitionException.
+        /// </summary>
+        /// <param name="globalProperties">The default global properties to use. May be null.</param>
+        /// <param name="loggers">The loggers to register. May be null and specified to any build instead.</param>
+        /// <param name="remoteLoggers">Any remote loggers to register. May be null and specified to any build instead.</param>
+        /// <param name="toolsetDefinitionLocations">The locations from which to load toolsets.</param>
+        /// <param name="maxNodeCount">The maximum number of nodes to use for building.</param>
+        /// <param name="onlyLogCriticalEvents">If set to true, only critical events will be logged.</param>
+        /// <param name="loadProjectsReadOnly">If set to true, load all projects as read-only.</param>
+        /// <param name="useAsynchronousLogging">If set to true, asynchronous logging will be used. <see cref="ProjectCollection.Dispose()"/> has to called to clear resources used by async logging.</param>
+        internal ProjectCollection(IDictionary<string, string> globalProperties, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging)
         {
             _loadedProjects = new LoadedProjectCollection();
             ToolsetLocations = toolsetDefinitionLocations;
@@ -319,6 +346,7 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab
 
             try
             {
+                _loggerMode = useAsynchronousLogging ? LoggerMode.Asynchronous : LoggerMode.Synchronous;
                 CreateLoggingService(maxNodeCount, onlyLogCriticalEvents);
 
                 RegisterLoggers(loggers);
@@ -418,8 +446,14 @@ public static ProjectCollection GlobalProjectCollection
                 {
                     // Take care to ensure that there is never more than one value observed
                     // from this property even in the case of race conditions while lazily initializing.
-                    var local = new ProjectCollection();
-                    Interlocked.CompareExchange(ref s_globalProjectCollection, local, null);
+                    var local = new ProjectCollection(null, null, null, ToolsetDefinitionLocations.Default,
+                        maxNodeCount: 1, onlyLogCriticalEvents: false, loadProjectsReadOnly: false, useAsynchronousLogging: true);
+
+                    if (Interlocked.CompareExchange(ref s_globalProjectCollection, local, null) != null)
+                    {
+                        // Other thread beat us to it; dispose of this project collection
+                        local.Dispose();
+                    }
                 }
 
                 return s_globalProjectCollection;
@@ -1724,7 +1758,7 @@ private void ShutDownLoggingService()
         /// </summary>
         private void CreateLoggingService(int maxCPUCount, bool onlyLogCriticalEvents)
         {
-            _loggingService = BackEnd.Logging.LoggingService.CreateLoggingService(LoggerMode.Synchronous, 0 /*Evaluation can be done as if it was on node "0"*/);
+            _loggingService = BackEnd.Logging.LoggingService.CreateLoggingService(_loggerMode, 0 /*Evaluation can be done as if it was on node "0"*/);
             _loggingService.MaxCPUCount = maxCPUCount;
             _loggingService.OnlyLogCriticalEvents = onlyLogCriticalEvents;
         }
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 9fdf1e22306..73dcf6f5a93 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -153,6 +153,11 @@ static internal class CommunicationsUtilities
         /// </summary>
         private static bool s_trace = Traits.Instance.DebugNodeCommunication;
 
+        /// <summary>
+        /// Lock trace to ensure we are logging in serial fashion.
+        /// </summary>
+        private static readonly object s_traceLock = new();
+
         /// <summary>
         /// Place to dump trace
         /// </summary>
@@ -616,9 +621,11 @@ internal static void Trace(int nodeId, string format, params object[] args)
         {
             if (s_trace)
             {
-                if (s_debugDumpPath == null)
+                lock (s_traceLock)
                 {
-                    s_debugDumpPath =
+                    if (s_debugDumpPath == null)
+                    {
+                        s_debugDumpPath =
 #if CLR2COMPATIBILITY
                         Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #else
@@ -627,39 +634,43 @@ internal static void Trace(int nodeId, string format, params object[] args)
                             : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #endif
 
-                    if (String.IsNullOrEmpty(s_debugDumpPath))
-                    {
-                        s_debugDumpPath = Path.GetTempPath();
-                    }
-                    else
-                    {
-                        Directory.CreateDirectory(s_debugDumpPath);
+                        if (String.IsNullOrEmpty(s_debugDumpPath))
+                        {
+                            s_debugDumpPath = Path.GetTempPath();
+                        }
+                        else
+                        {
+                            Directory.CreateDirectory(s_debugDumpPath);
+                        }
                     }
-                }
 
-                try
-                {
-                    string fileName = @"MSBuild_CommTrace_PID_{0}";
-                    if (nodeId != -1)
+                    try
                     {
-                        fileName += "_node_" + nodeId;
-                    }
+                        string fileName = @"MSBuild_CommTrace_PID_{0}";
+                        if (nodeId != -1)
+                        {
+                            fileName += "_node_" + nodeId;
+                        }
 
-                    fileName += ".txt";
+                        fileName += ".txt";
 
-                    using (StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId), append: true))
+                        using (StreamWriter file =
+                               FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId),
+                                   append: true))
+                        {
+                            string message = String.Format(CultureInfo.CurrentCulture, format, args);
+                            long now = DateTime.UtcNow.Ticks;
+                            float millisecondsSinceLastLog = (float)(now - s_lastLoggedTicks) / 10000L;
+                            s_lastLoggedTicks = now;
+                            file.WriteLine("{0} (TID {1}) {2,15} +{3,10}ms: {4}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, now, millisecondsSinceLastLog,
+                                message);
+                        }
+                    }
+                    catch (IOException)
                     {
-                        string message = String.Format(CultureInfo.CurrentCulture, format, args);
-                        long now = DateTime.UtcNow.Ticks;
-                        float millisecondsSinceLastLog = (float)(now - s_lastLoggedTicks) / 10000L;
-                        s_lastLoggedTicks = now;
-                        file.WriteLine("{0} (TID {1}) {2,15} +{3,10}ms: {4}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, now, millisecondsSinceLastLog, message);
+                        // Ignore
                     }
                 }
-                catch (IOException)
-                {
-                    // Ignore
-                }
             }
         }
 
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index b9d063a4be9..fbe9d5e00fb 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -1,10 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
-
-using System;
 using System.Collections.Immutable;
 using System.IO;
 using System.Reflection;
@@ -18,8 +15,6 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal class MSBuildLoadContext : AssemblyLoadContext
     {
-        private AssemblyDependencyResolver? _resolver;
-
         private readonly string _directory;
 
         internal static readonly ImmutableHashSet<string> WellKnownAssemblyNames =
@@ -36,8 +31,6 @@ public MSBuildLoadContext(string assemblyPath)
             : base($"MSBuild plugin {assemblyPath}")
         {
             _directory = Directory.GetParent(assemblyPath)!.FullName;
-
-            _resolver = File.Exists(assemblyPath) ? new AssemblyDependencyResolver(assemblyPath) : null;
         }
 
         protected override Assembly? Load(AssemblyName assemblyName)
@@ -49,19 +42,6 @@ public MSBuildLoadContext(string assemblyPath)
                 return null;
             }
 
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-            {
-                // respect plugin.dll.json with the AssemblyDependencyResolver
-                string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
-                if (assemblyPath != null)
-                {
-                    return LoadFromAssemblyPath(assemblyPath);
-                }
-            }
-
-            // Fall back to the older MSBuild-on-Core behavior to continue to support
-            // plugins that don't ship a .deps.json
-
             foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
@@ -93,6 +73,7 @@ public MSBuildLoadContext(string assemblyPath)
             // - the assembly from the user specified path is loaded, if it exists, into the custom ALC, or
             // - if the simple name of the assembly exists in the same folder as msbuild.exe, then that assembly gets loaded
             //   into the default ALC (so it's shared with other uses).
+
             var assemblyNameInExecutableDirectory = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
                 $"{assemblyName.Name}.dll");
 
@@ -103,19 +84,5 @@ public MSBuildLoadContext(string assemblyPath)
 
             return null;
         }
-
-        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
-        {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-            {
-                string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
-                if (libraryPath != null)
-                {
-                    return LoadUnmanagedDllFromPath(libraryPath);
-                }
-            }
-
-            return base.LoadUnmanagedDll(unmanagedDllName);
-        }
     }
 }
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index cb820d22e61..9fb112d8c03 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -6,10 +6,8 @@
 using System.IO;
 using Microsoft.Build.Shared;
 using System.Reflection;
-using Microsoft.Build.UnitTests.Shared;
 using Xunit;
-using Xunit.Abstractions;
-using Shouldly;
+using Microsoft.Build.UnitTests.Shared;
 
 #nullable disable
 
@@ -21,13 +19,6 @@ public class TypeLoader_Tests
         private const string ProjectFileName = "portableTaskTest.proj";
         private const string DLLFileName = "PortableTask.dll";
 
-        private readonly ITestOutputHelper _output;
-
-        public TypeLoader_Tests(ITestOutputHelper testOutputHelper)
-        {
-            _output = testOutputHelper;
-        }
-
         [Fact]
         public void Basic()
         {
@@ -59,18 +50,19 @@ public void Regress_Mutation_ParameterOrderDoesntMatter()
         [Fact]
         public void LoadNonExistingAssembly()
         {
-            using var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder);
-
-            string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
+            using (var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder))
+            {
+                string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
 
-            string dllName = "NonExistent.dll";
+                string dllName = "NonExistent.dll";
 
-            bool successfulExit;
-            string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + dllName, out successfulExit, _output);
-            successfulExit.ShouldBeFalse();
+                bool successfulExit;
+                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + dllName, out successfulExit);
+                Assert.False(successfulExit);
 
-            string dllPath = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, dllName);
-            CheckIfCorrectAssemblyLoaded(output, dllPath, false);
+                string dllPath = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, dllName);
+                CheckIfCorrectAssemblyLoaded(output, dllPath, false);
+            }
         }
 
         [Fact]
@@ -81,7 +73,7 @@ public void LoadInsideAsssembly()
                 string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
 
                 bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag", out successfulExit, _output);
+                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag", out successfulExit);
                 Assert.True(successfulExit);
 
                 string dllPath = Path.Combine(dir.Path, DLLFileName);
@@ -103,7 +95,7 @@ public void LoadOutsideAssembly()
                 try
                 {
                     bool successfulExit;
-                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + movedDLLPath, out successfulExit, _output);
+                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + movedDLLPath, out successfulExit);
                     Assert.True(successfulExit);
 
                     CheckIfCorrectAssemblyLoaded(output, movedDLLPath);
@@ -127,7 +119,7 @@ public void LoadInsideAssemblyWhenGivenOutsideAssemblyWithSameName()
                 try
                 {
                     bool successfulExit;
-                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + copiedDllPath, out successfulExit, _output);
+                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + copiedDllPath, out successfulExit);
                     Assert.True(successfulExit);
 
                     CheckIfCorrectAssemblyLoaded(output, originalDLLPath);
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 3410e8d85b4..9801bf9fa79 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -6106,7 +6106,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- This item represents the native manifest, example: WindowsApplication1.exe.manifest or Native.ClassLibrary1.manifest -->
     <ItemGroup>
-      <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)" Condition="'@(NativeReference)'!='' or '@(_IsolatedComReference)'!=''">
+      <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)" Condition="('@(NativeReference)'!='' or '@(_IsolatedComReference)'!='') And Exists('$(OutDir)$(_DeploymentTargetApplicationManifestFileName)')">
         <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
         <!-- For compatibility with 2.0 -->
         <OriginalItemSpec>$(OutDir)$(_DeploymentTargetApplicationManifestFileName)</OriginalItemSpec>
