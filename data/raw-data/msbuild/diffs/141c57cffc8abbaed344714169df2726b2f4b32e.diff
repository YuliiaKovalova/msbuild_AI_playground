diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 844fec05dbb..6d60820d15a 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -33,18 +33,19 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/log/Debug'
-      ArtifactName: 'FullOnWindows build logs'
+      targetPath: 'artifacts/log/Debug'
+      artifact: 'FullOnWindows build logs'
+      publishLocation: 'pipeline'
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'FullOnWindows test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'FullOnWindows test logs'
     continueOnError: true
     condition: always()
 
@@ -78,18 +79,18 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/log/Debug'
-      ArtifactName: 'CoreOnWindows build logs'
+      path: 'artifacts/log/Debug'
+      artifactName: 'CoreOnWindows build logs'
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'CoreOnWindows test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'CoreOnWindows test logs'
     continueOnError: true
     condition: always()
 
@@ -123,18 +124,18 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/Log/Release'
-      ArtifactName: 'FullOnWindows Release build logs'
+      path: 'artifacts/Log/Release'
+      artifactName: 'FullOnWindows Release build logs'
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'FullOnWindows Release test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'FullOnWindows Release test logs'
     continueOnError: true
     condition: always()
 
@@ -155,18 +156,18 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/log/Debug'
-      ArtifactName: 'CoreOnLinux build logs'
+      path: 'artifacts/log/Debug'
+      artifactName: 'CoreOnLinux build logs'
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'CoreOnLinux test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'CoreOnLinux test logs'
     continueOnError: true
     condition: always()
 
@@ -187,18 +188,18 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/log/Debug'
-      ArtifactName: 'CoreOnMac build logs'
+      path: 'artifacts/log/Debug'
+      artifactName: 'CoreOnMac build logs'
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'CoreOnMac test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'CoreOnMac test logs'
     continueOnError: true
     condition: always()
 
@@ -227,16 +228,16 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/log'
-      ArtifactName: 'MonoOnMac build logs'
+      path: 'artifacts/log'
+      artifactName: 'MonoOnMac build logs'
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'MonoOnMac test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'MonoOnMac test logs'
     continueOnError: true
     condition: always()
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 0ce3034d70b..b54fe9462e0 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -31,7 +31,6 @@ stages:
       name: VSEng-MicroBuildVS2019
       demands:
       - agent.os -equals Windows_NT
-      - VSTS_OS -equals Windows_Server_2019_Data_Center_with_Containers
 
     timeoutInMinutes: 180
 
@@ -133,26 +132,25 @@ stages:
       condition: succeeded()
 
     # Publish bootstrapper info
-    - task: PublishBuildArtifacts@1
+    - task: PublishPipelineArtifact@1
       inputs:
-        PathtoPublish: $(Build.StagingDirectory)\MicroBuild\Output
-        ArtifactName: MicroBuildOutputs
-        ArtifactType: Container
+        path: $(Build.StagingDirectory)\MicroBuild\Output
+        artifactName: MicroBuildOutputs
       displayName: 'OptProf - Publish Artifact: MicroBuildOutputs'
       condition: succeeded()
 
-    - task: PublishBuildArtifacts@1
+    - task: PublishPipelineArtifact@1
       displayName: 'Publish Artifact: logs'
       inputs:
-        PathtoPublish: 'artifacts\log\$(BuildConfiguration)'
-        ArtifactName: logs
+        path: 'artifacts\log\$(BuildConfiguration)'
+        artifactName: logs
       condition: succeededOrFailed()
 
-    - task: PublishBuildArtifacts@1
-      displayName: 'Publish Artifact: symbols'
+    - task: PublishPipelineArtifact@1
+      displayName: 'Publish Artifact: bin'
       inputs:
-        PathtoPublish: 'artifacts\bin'
-        ArtifactName: symbols
+        path: 'artifacts\bin'
+        artifactName: bin
       condition: succeededOrFailed()
 
     # Publishes setup VSIXes to a drop.
@@ -165,29 +163,11 @@ stages:
       condition: succeeded()
 
     # Publish an artifact that the RoslynInsertionTool is able to find by its name.
-    - task: PublishBuildArtifacts@1
+    - task: PublishPipelineArtifact@1
       displayName: 'Publish Artifact: VSSetup'
       inputs:
-        PathtoPublish: 'artifacts\VSSetup\$(BuildConfiguration)'
-        ArtifactName: VSSetup
-      condition: succeeded()
-
-    # Archive NuGet packages to DevOps.
-    # Publish our NuPkgs as an artifact. The name of this artifact must be PackageArtifacts as the 
-    # arcade templates depend on the name.
-    - task: PublishBuildArtifacts@1
-      displayName: 'Publish Artifact: packages'
-      inputs:
-        PathtoPublish: 'artifacts\packages\$(BuildConfiguration)'
-        ArtifactName: PackageArtifacts
-      condition: succeeded()
-
-    # Publish Asset Manifests for Build Asset Registry job
-    - task: PublishBuildArtifacts@1
-      displayName: Publish Asset Manifests
-      inputs:
-        PathtoPublish: '$(Build.SourcesDirectory)/artifacts/log/$(BuildConfiguration)/AssetManifest'
-        ArtifactName: AssetManifests
+        path: 'artifacts\VSSetup\$(BuildConfiguration)'
+        artifactName: VSSetup
       condition: succeeded()
 
     # Tag the build at the very end when we know it's been successful.
diff --git a/Directory.Build.targets b/Directory.Build.targets
index 289480d734a..177373cd81e 100644
--- a/Directory.Build.targets
+++ b/Directory.Build.targets
@@ -15,4 +15,16 @@
   </PropertyGroup>
   <Import Project="Sdk.targets" Sdk="Microsoft.Build.CentralPackageVersions" />
   <Import Project="Sdk.targets" Sdk="Microsoft.DotNet.Arcade.Sdk" />
+
+  <Target Name="DeleteDevPackage" AfterTargets="GenerateNuspec">
+    <!-- If package just built was already in global packages folder, delete it.  This helps support a local dev cycle where you are consuming
+         a package from another repo without having to update the package version each time. -->
+    
+    <PropertyGroup>
+      <_PackageFolderInGlobalPackages>$(NuGetPackageRoot)$(PackageId.ToLowerInvariant())\$(PackageVersion)</_PackageFolderInGlobalPackages>
+    </PropertyGroup>
+
+    <RemoveDir Directories="$(_PackageFolderInGlobalPackages)"
+               Condition="Exists('$(_PackageFolderInGlobalPackages)')" />
+  </Target>
 </Project>
diff --git a/MSBuild.Dev.sln b/MSBuild.Dev.sln
index 2c02e70c642..8fc92510fca 100644
--- a/MSBuild.Dev.sln
+++ b/MSBuild.Dev.sln
@@ -3,6 +3,12 @@ Microsoft Visual Studio Solution File, Format Version 12.00
 # Visual Studio 15
 VisualStudioVersion = 15.0.27004.2009
 MinimumVisualStudioVersion = 10.0.40219.1
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
+	ProjectSection(SolutionItems) = preProject
+		..\NuGet.Config = ..\NuGet.Config
+		..\targets\xunit.runner.json = ..\targets\xunit.runner.json
+	EndProjectSection
+EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build", "src\Build\Microsoft.Build.csproj", "{69BE05E2-CBDA-4D27-9733-44E12B0F5627}"
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Engine.OM.UnitTests", "src\Build.OM.UnitTests\Microsoft.Build.Engine.OM.UnitTests.csproj", "{5C53E4FD-0985-432D-B9E4-7BC354A057E5}"
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 39880a118e9..03b9e7d5087 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -25,8 +25,8 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 
 One can run MSBuild with eventing using the following command:
 
-`PerfView /OnlyProviders=*Microsoft-VisualStudio-Common run MSBuild.exe <project to build>`
+`PerfView /OnlyProviders=*Microsoft-Build run MSBuild.exe <project to build>`
 
 For example, if PerfView is one level up from my current directory (which has MSBuild.exe), and I want to build MSBuild.sln on Windows, I would use the following command:
 
-`..\PerfView /OnlyProviders=*Microsoft-VisualStudio-Common run .\MSBuild.exe .\MSBuild.sln`
+`..\PerfView /OnlyProviders=*Microsoft-Build run .\MSBuild.exe .\MSBuild.sln`
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index e4f4b600c6d..e1895c63eba 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -82,7 +82,7 @@ It is a `GZipStream`-compressed binary stream of serialized `BuildEventArgs` obj
 
 ## Incrementing the file format
 
-Every .binlog file has the first three bytes that indicate the file version. The current file format version is 2 (`00 00 02`).
+Every .binlog file has the first three bytes that indicate the file version. The current file format version is 9 (`00 00 09`).
 
 When incrementing the file format, keep this in mind:
  * Increment the version and add a summary of the changes: https://github.com/Microsoft/msbuild/blob/master/src/Build/Logging/BinaryLogger/BinaryLogger.cs#L22
diff --git a/documentation/wiki/Localization.md b/documentation/wiki/Localization.md
index 9a65e553f65..e0d31a285b8 100644
--- a/documentation/wiki/Localization.md
+++ b/documentation/wiki/Localization.md
@@ -1,4 +1,7 @@
+# Localizing MSBuild
+
 ## Localizable resource structure
+
 - Neutral resources: [*resx](https://github.com/search?utf8=%E2%9C%93&q=repo%3AMicrosoft%2Fmsbuild+extension%3Aresx&type=Code&ref=advsearch&l=&l=)
 - `Strings.shared.resx` is a shared resource and gets embedded into all msbuild dlls
 - each neutral resource has a directory named `xlf` besides it which contains its localized strings in .xlf format
@@ -6,18 +9,43 @@
 - the logical name for a resource is: `<Assembly Name>.<Neutral Resx File Name>.resources`. In the ResourceManager this appears as `<Assembly Name>.<Neutral Resx File Name>` (without the trailing `.resources`). For example, the `Microsoft.Build` assembly uses the `Microsoft.Build.Strings.resources` [logical resource name](https://github.com/Microsoft/msbuild/blob/master/src/XMakeBuildEngine/Microsoft.Build.csproj#L659) (the resource file is `Strings.resx`), and its corresponding [ResourceManager](https://github.com/Microsoft/msbuild/blob/master/src/XMakeBuildEngine/Resources/AssemblyResources.cs#L116) uses `Microsoft.Build.Strings`.
 
 ## How to edit a resource
+
 - if you need to add / remove / update a resource, only do so in the neutral resx files. xlf files get automatically updated during localized builds.
 
 ## What a localized build does
+
 - converts xlf files to localized resx files
 - the localized resx files are generated into the `$(IntermediaryOutputPath)`
 - produces satellite assemblies for each language
- - satellite assemblies are used even on English machines. This is for testing purposes, to ensure that English builds are not different than non English builds
+- satellite assemblies are used even on English machines. This is for testing purposes, to ensure that English builds are not different than non English builds
 
 ## Process for interacting with the localization team
+
 - 3 weeks cadence for master, initiated by loc team
 - on demand for master / release branches, initiated by msbuild team
 
 ## Contributing a better translation
+
 - send a PR with an updated `<target>` element of the xlf resource (do not include other non-localization changes)
 - we will notify the localization team, which will then take over and review the PR
+
+## Localizing XSD "IntelliSense"
+
+Code completion ("IntelliSense") for MSBuild project files is provided minimally in Visual Studio by XML Schema files like [`Microsoft.Build.CommonTypes.xsd`](https://github.com/microsoft/msbuild/blob/ba9a1d64a7abf15a8505827c00413156a3eb7f62/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd). These files are English-only in the GitHub repo; their localization is managed in the Microsoft-internal `VS` repo.
+
+### If there is a bug in XSD localization
+
+File xsd localization bugs in this repo. The MSBuild team will coordinate with the Visual Studio localization team to redirect it appropriately.
+
+### When an XSD has been updated
+
+After updating an XSD in the GitHub repo, someone with internal access must update the copy in the `VS` repo. To do so:
+
+1. Locally clone VS following the standard instructions.
+2. Locally update your clone of the GitHub msbuild repo to include the merge of the change.
+3. Start a new branch in the VS repository from the current working branch (probably `master`).
+4. Copy from the msbuild path `src/MSBuild/MSBuild/*.xsd` to the VS path `src/xmake/XMakeCommandLine`.
+5. Ensure that the commit message has a full link to the commit used to update the `.xsd` files, like `https://github.com/microsoft/msbuild/commit/ba9a1d64a7abf15a8505827c00413156a3eb7f62`.
+6. Push and submit through the usual VS PR process, including the `MSBuild` team as reviewers.
+
+Example PR doing this: https://dev.azure.com/devdiv/DevDiv/_git/VS/pullrequest/186890.
diff --git a/documentation/wiki/ResolveAssemblyReference.md b/documentation/wiki/ResolveAssemblyReference.md
index 2a1b7060e85..cd0e51172b3 100644
--- a/documentation/wiki/ResolveAssemblyReference.md
+++ b/documentation/wiki/ResolveAssemblyReference.md
@@ -9,7 +9,7 @@ If you notice the ordering, ResolveAssemblyReferences is happening before Compil
 
 ## Source Code
 You can browse Microsoft's MSBuild targets online at:
-http://source.roslyn.io/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.CurrentVersion.targets,1820
+https://github.com/microsoft/msbuild/blob/a936b97e30679dcea4d99c362efa6f732c9d3587/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1991-L2140
 This is where the RAR task is invoked in the targets file.
 
 The source code for RAR is at:
@@ -149,4 +149,4 @@ There were recent fixes made to RAR to alleviate the situation. You can control
 
 A common situation is MSBuild gives a warning about different versions of the same assembly being used by different references. The solution often involves adding a binding redirect to the app.config file. 
 
-A useful way to investigate these conflicts is to search in MSBuild Structured Log Viewer for "There was a conflict". It will show you detailed information about which references needed which versions of the assembly in question.
\ No newline at end of file
+A useful way to investigate these conflicts is to search in MSBuild Structured Log Viewer for "There was a conflict". It will show you detailed information about which references needed which versions of the assembly in question.
diff --git a/eng/Packages.props b/eng/Packages.props
index b8ebc96c259..d3ac170588d 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -18,6 +18,7 @@
     <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="1.16.30" />
     <PackageReference Update="Microsoft.Win32.Registry" Version="4.3.0" />
     <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
+    <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="PdbGit" Version="3.0.41" />
     <PackageReference Update="Shouldly" Version="3.0.0" />
     <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
@@ -40,6 +41,7 @@
     <PackageReference Update="System.Security.Permissions" Version="4.7.0" />
     <PackageReference Update="System.Security.Principal.Windows" Version="4.7.0" />
     <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
+    <PackageReference Update="System.Text.Json" Version="4.7.0" />
     <PackageReference Update="System.Threading.Tasks.Dataflow" Version="4.9.0" />
     <PackageReference Update="System.Threading.Thread" Version="4.0.0" />
     <PackageReference Update="System.Xml.XPath" Version="4.3.0" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 3aa465663ec..5c670906e71 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20215.5">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20302.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>36fd49bf87b14b78d722179b787e6518b5205518</Sha>
+      <Sha>9b71be0663493cd0e111b55536a2e1eeb272f54c</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 1aedd883c78..e20df56fead 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -30,6 +30,9 @@
     <UsingToolVisualStudioIbcTraining>true</UsingToolVisualStudioIbcTraining>
     <UsingToolSymbolUploader>true</UsingToolSymbolUploader>
     <UsingToolVSSDK>true</UsingToolVSSDK>
+    <!-- Override Arcade's default VSSDK version with one that supports client enablement.
+         Can be removed after Arcade moves up. -->
+    <MicrosoftVSSDKBuildToolsVersion>16.7.13</MicrosoftVSSDKBuildToolsVersion>
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
diff --git a/eng/common/darc-init.ps1 b/eng/common/darc-init.ps1
index b94c2f4e411..435e7641341 100644
--- a/eng/common/darc-init.ps1
+++ b/eng/common/darc-init.ps1
@@ -1,13 +1,14 @@
 param (
     $darcVersion = $null,
-    $versionEndpoint = "https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16",
-    $verbosity = "m"
+    $versionEndpoint = 'https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16',
+    $verbosity = 'minimal',
+    $toolpath = $null
 )
 
 . $PSScriptRoot\tools.ps1
 
-function InstallDarcCli ($darcVersion) {
-  $darcCliPackageName = "microsoft.dotnet.darc"
+function InstallDarcCli ($darcVersion, $toolpath) {
+  $darcCliPackageName = 'microsoft.dotnet.darc'
 
   $dotnetRoot = InitializeDotNetCli -install:$true
   $dotnet = "$dotnetRoot\dotnet.exe"
@@ -23,11 +24,24 @@ function InstallDarcCli ($darcVersion) {
     $darcVersion = $(Invoke-WebRequest -Uri $versionEndpoint -UseBasicParsing).Content
   }
 
-  $arcadeServicesSource = 'https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json'
+  $arcadeServicesSource = 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
 
   Write-Host "Installing Darc CLI version $darcVersion..."
-  Write-Host "You may need to restart your command window if this is the first dotnet tool you have installed."
-  & "$dotnet" tool install $darcCliPackageName --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g --framework netcoreapp2.1
+  Write-Host 'You may need to restart your command window if this is the first dotnet tool you have installed.'
+  if (-not $toolpath) {
+    Write-Host "'$dotnet' tool install $darcCliPackageName --version $darcVersion --add-source '$arcadeServicesSource' -v $verbosity -g"
+    & "$dotnet" tool install $darcCliPackageName --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g
+  }else {
+    Write-Host "'$dotnet' tool install $darcCliPackageName --version $darcVersion --add-source '$arcadeServicesSource' -v $verbosity --tool-path '$toolpath'"
+    & "$dotnet" tool install $darcCliPackageName --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity --tool-path "$toolpath"
+  }
 }
 
-InstallDarcCli $darcVersion
+try {
+  InstallDarcCli $darcVersion $toolpath
+}
+catch {
+  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'Darc' -Message $_
+  ExitWithExitCode 1
+}
\ No newline at end of file
diff --git a/eng/common/templates/post-build/common-variables.yml b/eng/common/templates/post-build/common-variables.yml
index 216d043e4e3..1883d2b1700 100644
--- a/eng/common/templates/post-build/common-variables.yml
+++ b/eng/common/templates/post-build/common-variables.yml
@@ -29,14 +29,6 @@ variables:
   - name: NetCore_3_Tools_Channel_Id
     value: 344
 
-  # .NET Core 3.0 Internal Servicing
-  - name: InternalServicing_30_Channel_Id
-    value: 184
-
-  # .NET Core 3.0 Release
-  - name: PublicRelease_30_Channel_Id
-    value: 19
-
   # .NET Core 3.1 Release
   - name: PublicRelease_31_Channel_Id
     value: 129
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index 3c69186f03a..e1cff6e7029 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -103,18 +103,6 @@ stages:
         continueOnError: ${{ parameters.SDLValidationParameters.continueOnError }}
         artifactNames: ${{ parameters.SDLValidationParameters.artifactNames }}
 
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_Dev5_Publish'
-    channelName: '.NET Core 5 Dev'
-    channelId: 131
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-symbols/nuget/v3/index.json'
-
 - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
   parameters:
     artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
@@ -175,18 +163,6 @@ stages:
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
     symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng-symbols/nuget/v3/index.json'
 
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_Release30_Publish'
-    channelName: '.NET Core 3.0 Release'
-    channelId: 19
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3-symbols/nuget/v3/index.json'
-
 - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
   parameters:
     artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
@@ -211,18 +187,6 @@ stages:
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-blazor/nuget/v3/index.json'
     symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-blazor-symbols/nuget/v3/index.json'
 
-- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_30_Internal_Servicing_Publishing'
-    channelName: '.NET Core 3.0 Internal Servicing'
-    channelId: 184
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal-symbols/nuget/v3/index.json'
-
 - template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
   parameters:
     artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
@@ -271,30 +235,6 @@ stages:
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
     symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
 
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_301xx_Publishing'
-    channelName: '.NET Core SDK 3.0.1xx'
-    channelId: 556
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_301xx_Internal_Publishing'
-    channelName: '.NET Core SDK 3.0.1xx Internal'
-    channelId: 555
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal-symbols/nuget/v3/index.json'
-
 - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
   parameters:
     artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
@@ -365,4 +305,64 @@ stages:
     channelId: 760
     transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
\ No newline at end of file
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
+    
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'NETCore_SDK_314xx_Publishing'
+    channelName: '.NET Core SDK 3.1.4xx'
+    channelId: 921
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
+
+- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'NETCore_SDK_314xx_Internal_Publishing'
+    channelName: '.NET Core SDK 3.1.4xx Internal'
+    channelId: 922
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
+
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'VS16_6_Publishing'
+    channelName: 'VS 16.6'
+    channelId: 1010
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'VS16_7_Publishing'
+    channelName: 'VS 16.7'
+    channelId: 1011
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'VS_Master_Publishing'
+    channelName: 'VS Master'
+    channelId: 1012
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
\ No newline at end of file
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 92a053bd16b..bc228dfdf9f 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -119,7 +119,9 @@ function InitializeDotNetCli([bool]$install) {
 
   # Find the first path on %PATH% that contains the dotnet.exe
   if ($useInstalledDotNetCli -and (-not $globalJsonHasRuntimes) -and ($env:DOTNET_INSTALL_DIR -eq $null)) {
-    $dotnetCmd = Get-Command "dotnet.exe" -ErrorAction SilentlyContinue
+    $dotnetExecutable = GetExecutableFileName 'dotnet'
+    $dotnetCmd = Get-Command $dotnetExecutable -ErrorAction SilentlyContinue
+
     if ($dotnetCmd -ne $null) {
       $env:DOTNET_INSTALL_DIR = Split-Path $dotnetCmd.Path -Parent
     }
@@ -243,6 +245,10 @@ function InstallDotNet([string] $dotnetRoot,
 # Throws on failure.
 #
 function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements = $null) {
+  if (-not (IsWindowsPlatform)) {
+    throw "Cannot initialize Visual Studio on non-Windows"
+  }
+
   if (Test-Path variable:global:_MSBuildExe) {
     return $global:_MSBuildExe
   }
@@ -344,7 +350,11 @@ function InitializeXCopyMSBuild([string]$packageVersion, [bool]$install) {
 # or $null if no instance meeting the requirements is found on the machine.
 #
 function LocateVisualStudio([object]$vsRequirements = $null){
-  if (Get-Member -InputObject $GlobalJson.tools -Name "vswhere") {
+  if (-not (IsWindowsPlatform)) {
+    throw "Cannot run vswhere on non-Windows platforms."
+  }
+
+  if (Get-Member -InputObject $GlobalJson.tools -Name 'vswhere') {
     $vswhereVersion = $GlobalJson.tools.vswhere
   } else {
     $vswhereVersion = "2.5.2"
@@ -404,7 +414,8 @@ function InitializeBuildTool() {
       Write-PipelineTelemetryError -Category "InitializeToolset" -Message "/global.json must specify 'tools.dotnet'."
       ExitWithExitCode 1
     }
-    $buildTool = @{ Path = Join-Path $dotnetRoot "dotnet.exe"; Command = "msbuild"; Tool = "dotnet"; Framework = "netcoreapp2.1" }
+    $dotnetPath = Join-Path $dotnetRoot (GetExecutableFileName 'dotnet')
+    $buildTool = @{ Path = $dotnetPath; Command = 'msbuild'; Tool = 'dotnet'; Framework = 'netcoreapp2.1' }
   } elseif ($msbuildEngine -eq "vs") {
     try {
       $msbuildPath = InitializeVisualStudioMSBuild -install:$restore
@@ -610,6 +621,19 @@ function GetMSBuildBinaryLogCommandLineArgument($arguments) {
   return $null
 }
 
+function GetExecutableFileName($baseName) {
+  if (IsWindowsPlatform) {
+    return "$baseName.exe"
+  }
+  else {
+    return $baseName
+  }
+}
+
+function IsWindowsPlatform() {
+  return [environment]::OSVersion.Platform -eq [PlatformID]::Win32NT
+}
+
 . $PSScriptRoot\pipeline-logging-functions.ps1
 
 $RepoRoot = Resolve-Path (Join-Path $PSScriptRoot "..\..")
diff --git a/global.json b/global.json
index aae65e77550..fc53c0de68f 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20215.5"
+    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20302.3"
   }
 }
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 691916c7c90..c826858733e 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -205,6 +205,7 @@ public partial interface IBuildEngine6 : Microsoft.Build.Framework.IBuildEngine,
     }
     public partial interface IBuildEngine7 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6
     {
+        bool AllowFailureWithoutError { get; set; }
         void ReleaseCores(int coresToRelease);
         int RequestCores(int requestedCores);
     }
@@ -497,7 +498,10 @@ protected SdkResolverContext() { }
     public abstract partial class SdkResult
     {
         protected SdkResult() { }
+        public virtual System.Collections.Generic.IList<string> AdditionalPaths { get { throw null; } set { } }
+        public virtual System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> ItemsToAdd { get { throw null; } protected set { } }
         public virtual string Path { get { throw null; } protected set { } }
+        public virtual System.Collections.Generic.IDictionary<string, string> PropertiesToAdd { get { throw null; } protected set { } }
         public virtual Microsoft.Build.Framework.SdkReference SdkReference { get { throw null; } protected set { } }
         public virtual bool Success { get { throw null; } protected set { } }
         public virtual string Version { get { throw null; } protected set { } }
@@ -506,8 +510,18 @@ public abstract partial class SdkResultFactory
     {
         protected SdkResultFactory() { }
         public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings=null);
+        public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd=null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd=null, System.Collections.Generic.IEnumerable<string> warnings=null);
         public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings=null);
     }
+    public partial class SdkResultItem
+    {
+        public SdkResultItem() { }
+        public SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) { }
+        public string ItemSpec { get { throw null; } set { } }
+        public System.Collections.Generic.Dictionary<string, string> Metadata { get { throw null; } }
+        public override bool Equals(object obj) { throw null; }
+        public override int GetHashCode() { throw null; }
+    }
     public enum TargetBuiltReason
     {
         AfterTargets = 3,
@@ -572,6 +586,8 @@ public TaskFinishedEventArgs(string message, string helpKeyword, string projectF
     public partial class TaskPropertyInfo
     {
         public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
+        public bool Log { get { throw null; } set { } }
+        public bool LogItemMetadata { get { throw null; } set { } }
         public string Name { get { throw null; } }
         public bool Output { get { throw null; } }
         public System.Type PropertyType { get { throw null; } }
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index f06e6f1b929..3d157409013 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -205,6 +205,7 @@ public partial interface IBuildEngine6 : Microsoft.Build.Framework.IBuildEngine,
     }
     public partial interface IBuildEngine7 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6
     {
+        bool AllowFailureWithoutError { get; set; }
         void ReleaseCores(int coresToRelease);
         int RequestCores(int requestedCores);
     }
@@ -496,7 +497,10 @@ protected SdkResolverContext() { }
     public abstract partial class SdkResult
     {
         protected SdkResult() { }
+        public virtual System.Collections.Generic.IList<string> AdditionalPaths { get { throw null; } set { } }
+        public virtual System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> ItemsToAdd { get { throw null; } protected set { } }
         public virtual string Path { get { throw null; } protected set { } }
+        public virtual System.Collections.Generic.IDictionary<string, string> PropertiesToAdd { get { throw null; } protected set { } }
         public virtual Microsoft.Build.Framework.SdkReference SdkReference { get { throw null; } protected set { } }
         public virtual bool Success { get { throw null; } protected set { } }
         public virtual string Version { get { throw null; } protected set { } }
@@ -505,8 +509,18 @@ public abstract partial class SdkResultFactory
     {
         protected SdkResultFactory() { }
         public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings=null);
+        public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd=null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd=null, System.Collections.Generic.IEnumerable<string> warnings=null);
         public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings=null);
     }
+    public partial class SdkResultItem
+    {
+        public SdkResultItem() { }
+        public SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) { }
+        public string ItemSpec { get { throw null; } set { } }
+        public System.Collections.Generic.Dictionary<string, string> Metadata { get { throw null; } }
+        public override bool Equals(object obj) { throw null; }
+        public override int GetHashCode() { throw null; }
+    }
     public enum TargetBuiltReason
     {
         AfterTargets = 3,
@@ -571,6 +585,8 @@ public TaskFinishedEventArgs(string message, string helpKeyword, string projectF
     public partial class TaskPropertyInfo
     {
         public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
+        public bool Log { get { throw null; } set { } }
+        public bool LogItemMetadata { get { throw null; } set { } }
         public string Name { get { throw null; } }
         public bool Output { get { throw null; } }
         public System.Type PropertyType { get { throw null; } }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 5e4da25caa7..7915650703a 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -967,6 +967,7 @@ public partial class BuildParameters
     {
         public BuildParameters() { }
         public BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
+        public bool AllowFailureWithoutError { get { throw null; } set { } }
         public System.Collections.Generic.IDictionary<string, string> BuildProcessEnvironment { get { throw null; } }
         public System.Threading.ThreadPriority BuildThreadPriority { get { throw null; } set { } }
         public System.Globalization.CultureInfo Culture { get { throw null; } set { } }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 9744334fb4e..fb016e00783 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -963,6 +963,7 @@ public partial class BuildParameters
     {
         public BuildParameters() { }
         public BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
+        public bool AllowFailureWithoutError { get { throw null; } set { } }
         public System.Collections.Generic.IDictionary<string, string> BuildProcessEnvironment { get { throw null; } }
         public System.Globalization.CultureInfo Culture { get { throw null; } set { } }
         public string DefaultToolsVersion { get { throw null; } set { } }
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index a1c01d9bd6c..a4e0c79e34e 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.Construction
@@ -16,6 +17,72 @@ namespace Microsoft.Build.UnitTests.Construction
     /// </summary>
     public class SolutionFile_Tests
     {
+        [Theory]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects2"": [
+                      ""src\\Build\\Microsoft.Build.csproj"",
+                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
+                      ""src\\MSBuild\\MSBuild.csproj"",
+                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                [{
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      ""src\\Build\\Microsoft.Build.csproj"",
+                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
+                      ""src\\MSBuild\\MSBuild.csproj"",
+                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
+                    ]
+                    }
+                }]
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
+                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
+                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
+                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath2\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
+                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
+                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
+                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterMissingSolutionError")]
+        public void InvalidSolutionFilters(string slnfValue, string exceptionReason)
+        {
+            Assert.False(File.Exists("C:\\notAPath2\\MSBuild.Dev.sln"));
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "Dev.sln");
+                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf", slnfValue.Replace(@"C:\\notAPath\\MSBuild.Dev.sln", sln.Path.Replace("\\", "\\\\")));
+                InvalidProjectFileException e = Should.Throw<InvalidProjectFileException>(() => SolutionFile.Parse(slnf.Path));
+                e.HelpKeyword.ShouldBe(exceptionReason);
+            }
+        }
+
         /// <summary>
         /// Test that a project with the C++ project guid and an extension of vcproj is seen as invalid.
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 0dc21b3faf8..1f887d229ee 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -13,8 +13,18 @@
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
   </PropertyGroup>
 
+  <PropertyGroup>
+    <NuGetCommandLinePackageVersion>4.1.0</NuGetCommandLinePackageVersion>
+</PropertyGroup>
+
   <ItemGroup>
     <PackageReference Include="Shouldly" />
+    <PackageDownload Include="NuGet.CommandLine" Version="[$(NuGetCommandLinePackageVersion)]" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <!-- GeneratePathProperty currently isn't enabled for PackageDownload. -->
+    <Content Condition="'$(MSBuildRuntimeType)' != 'Core' and '$(Configuration)' == 'Release'" Include="$(NuGetPackageRoot)\nuget.commandline\$(NuGetCommandLinePackageVersion)\tools\NuGet.exe" CopyToOutputDirectory="PreserveNewest" Link="nuget\NuGet.exe" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
@@ -87,6 +97,9 @@
     <Compile Include="..\Shared\StringBuilderCache.cs">
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\IInternable.cs" />
+    <Compile Include="..\Shared\WeakStringCache.cs" />
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
     <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
@@ -94,6 +107,7 @@
     <Compile Include="..\Shared\UnitTests\TestData\GlobbingTestData.cs">
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
+    <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
new file mode 100644
index 00000000000..64be9580f68
--- /dev/null
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -0,0 +1,57 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using System.IO;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Engine.OM.UnitTests
+{
+    public sealed class NugetRestoreTests
+    {
+        private ITestOutputHelper _output;
+        public NugetRestoreTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        // This NuGet version cannot locate other assemblies when parsing solutions at restore time. This includes localized strings required in debug mode.
+        // NuGet version 4.1.0 was somewhat arbitrarily chosen. 3.5 breaks with an unrelated error, and 4.8.2 does not fail when a new dependency is introduced. This is a safe middle point.
+#if !DEBUG
+        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [Fact]
+        public void TestOldNuget()
+        {
+            string msbuildExePath = Path.GetDirectoryName(RunnerUtilities.PathToCurrentlyRunningMsBuildExe);
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+            // The content of the solution isn't known to matter, but having a custom solution makes it easier to add requirements should they become evident.
+            TransientTestFile sln = testEnvironment.CreateFile(folder, "test.sln",
+                @"
+Microsoft Visual Studio Solution File, Format Version 12.00
+\# Visual Studio 15
+VisualStudioVersion = 15.0.26124.0
+MinimumVisualStudioVersion = 15.0.26124.0
+Global
+GlobalSection(SolutionConfigurationPlatforms) = preSolution
+	Debug|Any CPU = Debug|Any CPU
+	Debug|x64 = Debug|x64
+	Debug|x86 = Debug|x86
+	Release|Any CPU = Release|Any CPU
+	Release|x64 = Release|x64
+	Release|x86 = Release|x86
+EndGlobalSection
+GlobalSection(SolutionProperties) = preSolution
+	HideSolutionNode = FALSE
+EndGlobalSection
+EndGlobal
+");
+            RunnerUtilities.RunProcessAndGetOutput(Path.Combine(msbuildExePath, "nuget", "NuGet.exe"), "restore " + sln.Path + " -MSBuildPath \"" + msbuildExePath + "\"", out bool success, outputHelper: _output);
+            success.ShouldBeTrue();
+        }
+#endif
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index 0db697ff651..af9bf647c5d 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -10,8 +10,8 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
+using Shouldly;
 using Xunit;
-
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 namespace Microsoft.Build.UnitTests.BackEnd
diff --git a/src/Build.UnitTests/BackEnd/FailingTask.cs b/src/Build.UnitTests/BackEnd/FailingTask.cs
new file mode 100644
index 00000000000..c42f912d679
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/FailingTask.cs
@@ -0,0 +1,20 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class FailingTask : Task
+    {
+        public override bool Execute()
+        {
+            BuildEngine.GetType().GetProperty("AllowFailureWithoutError").SetValue(BuildEngine, EnableDefaultFailure);
+            return false;
+        }
+
+        [Required]
+        public bool EnableDefaultFailure { get; set; }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
index 861d10cd4b6..338cc793c8e 100644
--- a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
@@ -4,8 +4,10 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
+using Shouldly;
 using System;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -14,29 +16,36 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class LoggingContext_Tests
     {
+        private readonly ITestOutputHelper _output;
+
+        public LoggingContext_Tests(ITestOutputHelper outputHelper)
+        {
+            _output = outputHelper;
+        }
+
         /// <summary>
         /// A few simple tests for NodeLoggingContexts. 
         /// </summary>
         [Fact]
         public void CreateValidNodeLoggingContexts()
         {
-            NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(), 1, true);
-            Assert.True(context.IsInProcNode);
-            Assert.True(context.IsValid);
+            NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(_output.WriteLine), 1, true);
+            context.IsInProcNode.ShouldBeTrue();
+            context.IsValid.ShouldBeTrue();
 
             context.LogBuildFinished(true);
-            Assert.False(context.IsValid);
+            context.IsValid.ShouldBeFalse();
 
-            Assert.Equal(1, context.BuildEventContext.NodeId);
+            context.BuildEventContext.NodeId.ShouldBe(1);
 
-            NodeLoggingContext context2 = new NodeLoggingContext(new MockLoggingService(), 2, false);
-            Assert.False(context2.IsInProcNode);
-            Assert.True(context2.IsValid);
+            NodeLoggingContext context2 = new NodeLoggingContext(new MockLoggingService(_output.WriteLine), 2, false);
+            context2.IsInProcNode.ShouldBeFalse();
+            context2.IsValid.ShouldBeTrue();
 
             context2.LogBuildFinished(true);
-            Assert.False(context2.IsValid);
+            context2.IsValid.ShouldBeFalse();
 
-            Assert.Equal(2, context2.BuildEventContext.NodeId);
+            context2.BuildEventContext.NodeId.ShouldBe(2);
         }
 
         /// <summary>
@@ -49,9 +58,25 @@ public void InvalidNodeIdOnNodeLoggingContext()
         {
             Assert.Throws<InternalErrorException>(() =>
             {
-                NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(), -2, true);
+                _ = new NodeLoggingContext(new MockLoggingService(), -2, true);
             }
            );
         }
+
+        [Fact]
+        public void HasLoggedErrors()
+        {
+            NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(_output.WriteLine), 1, true);
+            context.HasLoggedErrors.ShouldBeFalse();
+
+            context.LogCommentFromText(Framework.MessageImportance.High, "Test message");
+            context.HasLoggedErrors.ShouldBeFalse();
+
+            context.LogWarningFromText(null, null, null, null, "Test warning");
+            context.HasLoggedErrors.ShouldBeFalse();
+
+            context.LogErrorFromText(null, null, null, null, "Test error");
+            context.HasLoggedErrors.ShouldBeTrue();
+        }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index 191f8573567..745a3e91b04 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -11,6 +11,9 @@
 using System.Xml;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using System.Reflection;
+using Shouldly;
+using System.Linq;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -559,6 +562,29 @@ public void OutOfOrderOnError()
            );
         }
 
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ErrorWhenTaskFailsWithoutLoggingErrorEscapeHatch(bool emitError)
+        {
+            MockLogger logger = ObjectModelHelpers.BuildProjectExpectFailure($@"
+<Project>
+    <UsingTask TaskName=""FailingTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
+    <Target Name=""MyTarget"">
+        <FailingTask EnableDefaultFailure=""{emitError}"" />
+    </Target>
+</Project>");
+            if (emitError)
+            {
+                logger.ErrorCount.ShouldBe(1);
+                logger.Errors.First().Code.ShouldBe("MSB4181");
+            }
+            else
+            {
+                logger.ErrorCount.ShouldBe(0);
+            }
+        }
+
         #region Postbuild
         /*
          * Method:  PostBuildBasic
diff --git a/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs b/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs
new file mode 100644
index 00000000000..8d9b0b8b436
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs
@@ -0,0 +1,26 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Utilities;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+namespace Microsoft.Build.UnitTests
+{
+    /// <summary>
+    /// This task was created for https://github.com/microsoft/msbuild/issues/2036
+    /// </summary>
+    public class ReturnFailureWithoutLoggingErrorTask : Task
+    {
+        /// <summary>
+        /// Intentionally return false without logging an error to test proper error catching.
+        /// </summary>
+        /// <returns></returns>
+        public override bool Execute()
+        {
+            return false;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index a06af07a61c..b6fa324c806 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -1,4 +1,7 @@
-﻿using Microsoft.Build.BackEnd.Logging;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
@@ -217,6 +220,223 @@ public void CachingWrapperShouldWarnWhenMultipleVersionsAreReferenced()
             resolver.ResolvedCalls.Count.ShouldBe(1);
         }
 
+        private void CreateMockSdkResultPropertiesAndItems(out Dictionary<string, string> propertiesToAdd, out Dictionary<string, SdkResultItem> itemsToAdd)
+        {
+            propertiesToAdd = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                {
+                    {"PropertyFromSdkResolver", "ValueFromSdkResolver" }
+                };
+
+            itemsToAdd = new Dictionary<string, SdkResultItem>(StringComparer.OrdinalIgnoreCase)
+                {
+                    { "ItemNameFromSdkResolver", new SdkResultItem( "ItemValueFromSdkResolver",
+                        new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                        {
+                            { "MetadataName", "MetadataValue" }
+                        })
+                    }
+                };
+        }
+
+        private void ValidateExpectedPropertiesAndItems(bool includePropertiesAndItems, SdkResultBase result)
+        {
+            if (includePropertiesAndItems)
+            {
+                result.PropertiesToAdd.Count.ShouldBe(1);
+                result.PropertiesToAdd["PropertyFromSdkResolver"].ShouldBe("ValueFromSdkResolver");
+
+                result.ItemsToAdd.Count().ShouldBe(1);
+                result.ItemsToAdd.Keys.Single().ShouldBe("ItemNameFromSdkResolver");
+                result.ItemsToAdd.Values.Single().ItemSpec.ShouldBe("ItemValueFromSdkResolver");
+                var metadata = result.ItemsToAdd.Values.Single().Metadata;
+                metadata.ShouldBeSameIgnoringOrder(new[] { new KeyValuePair<string, string>("MetadataName", "MetadataValue") });
+            }
+            else
+            {
+                result.PropertiesToAdd.ShouldBeNull();
+                result.ItemsToAdd.ShouldBeNull();
+            }
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
+        {
+            var sdk = new SdkReference("foo", null, null);
+
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            if (includePropertiesAndItems)
+            {
+                CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+            }
+
+            var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
+                new SdkResultImpl(
+                    sdk,
+                    Enumerable.Empty<string>(),
+                    version: null,
+                    propertiesToAdd,
+                    itemsToAdd,
+                    warnings: null
+                    ));
+
+            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+
+            result.Success.ShouldBeTrue();
+            result.Path.ShouldBeNull();
+            result.Version.ShouldBeNull();
+
+            result.AdditionalPaths.ShouldBeNull();
+
+            ValidateExpectedPropertiesAndItems(includePropertiesAndItems, result);
+
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Fact]
+        public void SdkResultCanReturnPropertiesAndItems()
+        {
+            string expectedPath = "Path/To/Return/From/Resolver";
+
+            var sdk = new SdkReference("foo", null, null);
+
+            Dictionary<string, string> propertiesToAdd;
+            Dictionary<string, SdkResultItem> itemsToAdd;
+           
+            CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+
+            var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
+                new SdkResultImpl(
+                    sdk,
+                    new[] { expectedPath },
+                    version: "1.0",
+                    propertiesToAdd,
+                    itemsToAdd,
+                    warnings: null
+                    ));
+
+            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+
+            result.Success.ShouldBeTrue();
+            result.Path.ShouldBe(expectedPath);
+            result.Version.ShouldBe("1.0");
+
+            result.AdditionalPaths.ShouldBeNull();
+
+            ValidateExpectedPropertiesAndItems(true, result);
+
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SdkResultCanReturnMultiplePaths(bool includePropertiesAndItems)
+        {
+            string expectedPath1 = "First/Path/To/Return/From/Resolver";
+            string expectedPath2 = "Second/Path/To/Return/From/Resolver";
+
+            var sdk = new SdkReference("foo", "1.0", null);
+
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            if (includePropertiesAndItems)
+            {
+                CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+            }
+
+            var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
+                new SdkResultImpl(
+                    sdk,
+                    new []
+                    {
+                        expectedPath1,
+                        expectedPath2
+                    },
+                    version: "1.0",
+                    propertiesToAdd,
+                    itemsToAdd,
+                    warnings: null
+                    ));
+
+            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+
+            result.Success.ShouldBeTrue();
+
+            var resultPaths = new List<string>();
+            resultPaths.Add(result.Path);
+            resultPaths.AddRange(result.AdditionalPaths);
+
+            resultPaths.ShouldBeSameIgnoringOrder(new[]
+            {
+                expectedPath1,
+                expectedPath2
+            });
+
+            ValidateExpectedPropertiesAndItems(includePropertiesAndItems, result);
+
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Fact]
+        public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersionWithMultipleReturnPaths()
+        {
+            var expectedPath1 = "First/Path/To/Return/From/Resolver";
+            var expectedPath2 = "Second/Path/To/Return/From/Resolver";
+
+            var sdk = new SdkReference("foo", "1.0", null);
+
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+            
+            CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+
+            var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
+                new SdkResultImpl(
+                    sdk,
+                    new[]
+                    {
+                        expectedPath1,
+                        expectedPath2
+                    },
+                    version: "1.1",
+                    propertiesToAdd,
+                    itemsToAdd,
+                    warnings: null
+                    ));
+
+            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+
+            result.Success.ShouldBeTrue();
+
+            var resultPaths = new List<string>();
+            resultPaths.Add(result.Path);
+            resultPaths.AddRange(result.AdditionalPaths);
+
+            resultPaths.ShouldBeSameIgnoringOrder(new[]
+            {
+                expectedPath1,
+                expectedPath2
+            });
+
+            ValidateExpectedPropertiesAndItems(true, result);
+
+            _logger.WarningCount.ShouldBe(1);
+            _logger.Warnings.First().Code.ShouldStartWith("MSB4241");
+        }
+
         /// <summary>
         /// Verifies that an SDK resolver is only called once per build per SDK.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
new file mode 100644
index 00000000000..8fd40d75ddc
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -0,0 +1,281 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Unittest;
+using Microsoft.Build.UnitTests.Definition;
+using Shouldly;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Xml;
+using Xunit;
+using Xunit.Abstractions;
+using static Microsoft.Build.UnitTests.ObjectModelHelpers;
+
+namespace Microsoft.Build.UnitTests.BackEnd
+{
+    public class SdkResultOutOfProc_Tests : IDisposable
+    {
+        /// <summary>
+        /// The mock logger for testing.
+        /// </summary>
+        private readonly MockLogger _logger;
+
+        /// <summary>
+        /// The standard build manager for each test.
+        /// </summary>
+        private readonly BuildManager _buildManager;
+
+        /// <summary>
+        /// The build parameters.
+        /// </summary>
+        private readonly BuildParameters _parameters;
+
+        /// <summary>
+        /// The project collection used.
+        /// </summary>
+        private readonly ProjectCollection _projectCollection;
+
+        private readonly TestEnvironment _env;
+        private readonly ITestOutputHelper _output;
+
+        public SdkResultOutOfProc_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+            // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.
+            BuildManager.DefaultBuildManager.Dispose();
+
+            _logger = new MockLogger(output);
+            _parameters = new BuildParameters
+            {
+                ShutdownInProcNodeOnBuildFinish = true,
+                Loggers = new ILogger[] { _logger },
+                EnableNodeReuse = false
+            };
+            _buildManager = new BuildManager();
+            _projectCollection = new ProjectCollection();
+
+            _env = TestEnvironment.Create(output);
+            _env.SetEnvironmentVariable("MSBUILDINPROCENVCHECK", "1");
+            _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+
+            // Need to set this env variable to enable Process.GetCurrentProcess().Id in the project file.
+            _env.SetEnvironmentVariable("MSBUILDENABLEALLPROPERTYFUNCTIONS", "1");
+
+            //  Set this if you need to debug the out of process build
+            //_env.SetEnvironmentVariable("MSBUILDDEBUGONSTART", "1");
+        }
+
+        public void Dispose()
+        {
+            _buildManager.Dispose();
+            _projectCollection.Dispose();
+            _env.Dispose();
+            EvaluationContext.TestOnlyHookOnCreate = null;
+        }
+
+        private const string GetCurrentProcessIdTarget = @"<Target Name='GetCurrentProcessId' Returns='@(CurrentProcessId)'>
+    <ItemGroup>
+       <CurrentProcessId Include='$([System.Diagnostics.Process]::GetCurrentProcess().Id)'/>
+    </ItemGroup>
+    <Message Text='[success]'/>
+ </Target>";
+
+        private const string GetResolverResultsTarget = @"<Target Name='GetResolverResults' Returns='@(ResolverResult)'>
+    <ItemGroup>
+       <ResolverResult Include='$(PropertyNameFromResolver)' Type='PropertyNameFromResolver' />
+       <ResolverResult Include='@(ItemFromResolver)' Type='ItemFromResolver' />
+       <ResolverResult Include='@(SdksImported)' Type='SdksImported' />
+    </ItemGroup>
+ </Target>";
+
+        [Fact]
+        public void RunOutOfProcBuild()
+        {
+            string contents = $@"
+<Project>
+<Import Project='Sdk.props' Sdk='TestSdk' />
+{GetCurrentProcessIdTarget}
+{GetResolverResultsTarget}
+</Project>
+";
+
+            string projectFolder = _env.CreateFolder().Path;
+
+            string projectPath = Path.Combine(projectFolder, "TestProject.proj");
+            File.WriteAllText(projectPath, CleanupFileContents(contents));
+
+            ProjectInstance projectInstance = CreateProjectInstance(projectPath, MSBuildDefaultToolsVersion, _projectCollection);
+
+            var data = new BuildRequestData(projectInstance, new[] { "GetCurrentProcessId", "GetResolverResults" }, _projectCollection.HostServices);
+            var customparameters = new BuildParameters { EnableNodeReuse = false, Loggers = new ILogger[] { _logger } };
+
+            BuildResult result = _buildManager.Build(customparameters, data);
+
+            result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            ValidateRanInSeparateProcess(result);
+            ValidateResolverResults(result);
+        }
+
+        //  Test scenario where using an SdkResolver in a project that hasn't been evaluated
+        //  in the main node (which is where the SdkResolver runs).  This validates that
+        //  the SdkResult is correctly transferred between nodes.
+        [Fact]
+        public void RunOutOfProcBuildWithTwoProjects()
+        {
+            string entryProjectContents = $@"
+<Project>
+ {GetCurrentProcessIdTarget}
+<Target Name='GetResolverResults' Returns='@(ResolverResults)'>
+    <MSBuild Projects='ProjectWithSdkImport.proj'
+             Targets='GetResolverResults'>
+        <Output TaskParameter='TargetOutputs' ItemName='ResolverResults' />
+    </MSBuild>
+ </Target>
+</Project>
+";
+            string projectFolder = _env.CreateFolder().Path;
+
+            string entryProjectPath = Path.Combine(projectFolder, "EntryProject.proj");
+            File.WriteAllText(entryProjectPath, CleanupFileContents(entryProjectContents));
+
+            string projectWithSdkImportContents = $@"
+<Project>
+<Import Project='Sdk.props' Sdk='TestSdk' />
+{GetResolverResultsTarget}
+</Project>
+";
+
+            string projectWithSdkImportPath = Path.Combine(projectFolder, "ProjectWithSdkImport.proj");
+            File.WriteAllText(projectWithSdkImportPath, CleanupFileContents(projectWithSdkImportContents));
+
+            ProjectInstance projectInstance = CreateProjectInstance(entryProjectPath, MSBuildDefaultToolsVersion, _projectCollection);
+
+            var data = new BuildRequestData(projectInstance, new[] { "GetCurrentProcessId", "GetResolverResults" }, _projectCollection.HostServices);
+            var customparameters = new BuildParameters { EnableNodeReuse = false, Loggers = new ILogger[] { _logger } };
+
+            BuildResult result = _buildManager.Build(customparameters, data);
+
+
+            result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            ValidateRanInSeparateProcess(result);
+            ValidateResolverResults(result);
+        }
+
+
+        private void ValidateRanInSeparateProcess(BuildResult result)
+        {
+            TargetResult targetresult = result.ResultsByTarget["GetCurrentProcessId"];
+            ITaskItem[] item = targetresult.Items;
+
+            item.ShouldHaveSingleItem();
+
+            int.TryParse(item[0].ItemSpec, out int processId)
+                .ShouldBeTrue($"Process ID passed from the 'test' target is not a valid integer (actual is '{item[0].ItemSpec}')");
+            processId.ShouldNotBe(Process.GetCurrentProcess().Id);
+        }
+
+        private void ValidateResolverResults(BuildResult result)
+        {
+            TargetResult targetresult = result.ResultsByTarget["GetResolverResults"];
+
+            IEnumerable<string> GetResolverResults(string type)
+            {
+                return targetresult.Items.Where(i => i.GetMetadata("Type").Equals(type, StringComparison.OrdinalIgnoreCase))
+                    .Select(i => i.ItemSpec)
+                    .ToList();
+            }
+
+            GetResolverResults("PropertyNameFromResolver").ShouldBeSameIgnoringOrder(new[] { "PropertyValueFromResolver" });
+            GetResolverResults("ItemFromResolver").ShouldBeSameIgnoringOrder(new[] { "ItemValueFromResolver" });
+            GetResolverResults("SdksImported").ShouldBeSameIgnoringOrder(new[] { "Sdk1", "Sdk2" });
+        }
+
+        private ProjectInstance CreateProjectInstance(string projectPath, string toolsVersion, ProjectCollection projectCollection)
+        {
+            var sdkResolver = SetupSdkResolver(Path.GetDirectoryName(projectPath));
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(sdkResolver);
+
+            projectOptions.ProjectCollection = projectCollection;
+            projectOptions.ToolsVersion = toolsVersion;
+
+            ProjectRootElement projectRootElement = ProjectRootElement.Open(projectPath, _projectCollection);
+
+            Project project = Project.FromProjectRootElement(projectRootElement, projectOptions);
+
+            return project.CreateProjectInstance(ProjectInstanceSettings.None, projectOptions.EvaluationContext);
+        }
+
+        private SdkResolver SetupSdkResolver(string projectFolder)
+        {
+            Directory.CreateDirectory(Path.Combine(projectFolder, "Sdk1"));
+            Directory.CreateDirectory(Path.Combine(projectFolder, "Sdk2"));
+
+            string sdk1propsContents = @"
+<Project>
+    <ItemGroup>
+        <SdksImported Include='Sdk1' />
+    </ItemGroup>
+</Project>";
+
+            string sdk2propsContents = @"
+<Project>
+    <ItemGroup>
+        <SdksImported Include='Sdk2' />
+    </ItemGroup>
+</Project>";
+
+            File.WriteAllText(Path.Combine(projectFolder, "Sdk1", "Sdk.props"), CleanupFileContents(sdk1propsContents));
+            File.WriteAllText(Path.Combine(projectFolder, "Sdk2", "Sdk.props"), CleanupFileContents(sdk2propsContents));
+
+            var sdkResolver = new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestSdk", null, null),
+                        new[]
+                        {
+                            Path.Combine(projectFolder, "Sdk1"),
+                            Path.Combine(projectFolder, "Sdk2")
+                        },
+                        version: null,
+                        propertiesToAdd: new Dictionary<string, string>()
+                            { {"PropertyNameFromResolver","PropertyValueFromResolver" } },
+                        itemsToAdd: new Dictionary<string, SdkResultItem>()
+                            {
+                                { "ItemFromResolver", new SdkResultItem("ItemValueFromResolver", null) }
+                            },
+                        warnings: null
+                    ));
+
+            EvaluationContext.TestOnlyHookOnCreate = context =>
+            {
+                var sdkService = (SdkResolverService)context.SdkResolverService;
+
+                sdkService.InitializeForTests(null, new List<SdkResolver> { sdkResolver });
+            };
+
+            ((IBuildComponentHost)_buildManager).RegisterFactory(BuildComponentType.SdkResolverService, type =>
+            {
+                var resolverService = new MainNodeSdkResolverService();
+                resolverService.InitializeForTests(null, new List<SdkResolver> { sdkResolver });
+                return resolverService;
+            });
+
+            return sdkResolver;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Collections/OMcollections_tests.cs b/src/Build.UnitTests/Collections/OMcollections_tests.cs
index 0421b05453d..a2c9c2ac165 100644
--- a/src/Build.UnitTests/Collections/OMcollections_tests.cs
+++ b/src/Build.UnitTests/Collections/OMcollections_tests.cs
@@ -16,6 +16,7 @@
 using Shouldly;
 using ObjectModel = System.Collections.ObjectModel;
 using Xunit;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.OM.Collections
 {
diff --git a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
index 43d62d5c4dd..dd48d7391e5 100644
--- a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
@@ -18,6 +18,7 @@
 using System.Reflection;
 using Xunit;
 using System.Text;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.Construction
 {
diff --git a/src/Build.UnitTests/Construction/ProjectImportElement_Tests.cs b/src/Build.UnitTests/Construction/ProjectImportElement_Tests.cs
new file mode 100644
index 00000000000..4450f83c458
--- /dev/null
+++ b/src/Build.UnitTests/Construction/ProjectImportElement_Tests.cs
@@ -0,0 +1,207 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
+using Shouldly;
+using System;
+using System.Linq;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests.Construction
+{
+    public class ProjectImportElement_Tests
+    {
+        [Fact]
+        public void SdkReferenceIsCorrect_CreatedFromOnDiskProject_SdkAndVersionAttributeSet()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFile projectFile = testEnvironment.CreateFile(
+                    "test.proj",
+                    @"
+<Project>
+  <Import Project=""Sdk.props"" Sdk=""My.Sdk"" Version=""1.2.0"" />
+</Project>");
+                ProjectRootElement rootElement = ProjectRootElement.Open(projectFile.Path);
+
+                ProjectImportElement importElement = rootElement.Imports.First();
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Sdk = "My.Sdk");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Version = "1.2.0");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.MinimumVersion = "1.0.0", "Set Import Minimum Version 1.0.0");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.MinimumVersion = "1.0.0");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Sdk = "Some.Other.Sdk", "Set Import Sdk Some.Other.Sdk");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+            }
+        }
+
+        [Fact]
+        public void SdkReferenceIsCorrect_CreatedFromOnDiskProject_SdkAttributeSet()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFile projectFile = testEnvironment.CreateFile(
+                    "test.proj",
+                    @"
+<Project>
+  <Import Project=""Sdk.props"" Sdk=""My.Sdk"" />
+</Project>");
+                ProjectRootElement rootElement = ProjectRootElement.Open(projectFile.Path);
+
+                ProjectImportElement importElement = rootElement.Imports.First();
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBeNull();
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Sdk = "My.Sdk");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Version = "1.2.0", "Set Import Version 1.2.0");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Version = "1.2.0");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.MinimumVersion = "1.0.0", "Set Import Minimum Version 1.0.0");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.MinimumVersion = "1.0.0");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+            }
+        }
+
+        /// <summary>
+        /// Verifies that the <see cref="ProjectImportElement.SdkReference" /> object is correctly set when creating <see cref="ProjectImportElement" /> objects.
+        /// </summary>
+        [Fact]
+        public void SdkReferenceIsCorrect_CreatedInMemory()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                ProjectRootElement rootElement = ProjectRootElement.Create(NewProjectFileOptions.None);
+
+                ProjectImportElement importElement = rootElement.AddImport("Sdk.props");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Sdk = "My.Sdk", "Set Import Sdk My.Sdk");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Sdk = "My.Sdk");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBeNull();
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Version = "1.2.0", "Set Import Version 1.2.0");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Version = "1.2.0");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.MinimumVersion = "1.0.0", "Set Import Minimum Version 1.0.0");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.MinimumVersion = "1.0.0");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+
+                rootElement.Save(env.GetTempFile(".csproj").Path);
+
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Sdk = "My.Sdk");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Sdk = "Some.Other.Sdk", "Set Import Sdk Some.Other.Sdk");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+
+                rootElement.Save();
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Version = "4.0.0", "Set Import Version 4.0.0");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBe("4.0.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+
+                rootElement.Save();
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.MinimumVersion = "2.0.0", "Set Import Minimum Version 2.0.0");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBe("4.0.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("2.0.0");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Version = null, "Set Import Version ");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBeNull();
+                importElement.SdkReference.MinimumVersion.ShouldBe("2.0.0");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.MinimumVersion = null, "Set Import Minimum Version ");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBeNull();
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+            }
+        }
+
+        private void SetPropertyAndExpectProjectXmlChangedEventToFire(ProjectRootElement rootElement, Action action, string expectedReason)
+        {
+            ProjectXmlChangedEventArgs projectXmlChangedEventArgs = null;
+
+            void OnProjectXmlChanged(object sender, ProjectXmlChangedEventArgs args)
+            {
+                projectXmlChangedEventArgs = args;
+            }
+
+            rootElement.OnProjectXmlChanged += OnProjectXmlChanged;
+            try
+            {
+                action();
+            }
+            finally
+            {
+                rootElement.OnProjectXmlChanged -= OnProjectXmlChanged;
+            }
+
+            projectXmlChangedEventArgs.ShouldNotBeNull();
+            projectXmlChangedEventArgs.Reason.ShouldBe(expectedReason);
+        }
+
+        private void SetPropertyAndExpectProjectXmlChangedEventToNotFire(ProjectRootElement rootElement, Action action)
+        {
+            ProjectXmlChangedEventArgs projectXmlChangedEventArgs = null;
+
+            void OnProjectXmlChanged(object sender, ProjectXmlChangedEventArgs args)
+            {
+                projectXmlChangedEventArgs = args;
+            }
+
+            rootElement.OnProjectXmlChanged += OnProjectXmlChanged;
+            try
+            {
+                action();
+            }
+            finally
+            {
+                rootElement.OnProjectXmlChanged -= OnProjectXmlChanged;
+            }
+
+            projectXmlChangedEventArgs.ShouldBeNull();
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index c9b10410185..e9dc6951439 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -17,6 +17,64 @@ namespace Microsoft.Build.UnitTests.Construction
 {
     public class SolutionFile_Tests
     {
+        /// <summary>
+        /// Test that a solution filter file is parsed correctly, and it can accurately respond as to whether a project should be filtered out.
+        /// </summary>
+        [Fact]
+        public void ParseSolutionFilter()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder src = testEnvironment.CreateFolder(Path.Combine(folder.Path, "src"), createFolder: true);
+                TransientTestFile microsoftBuild = testEnvironment.CreateFile(src, "Microsoft.Build.csproj");
+                TransientTestFile msbuild = testEnvironment.CreateFile(src, "MSBuild.csproj");
+                TransientTestFile commandLineUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.CommandLine.UnitTests.csproj");
+                TransientTestFile tasksUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.Tasks.UnitTests.csproj");
+                // The important part of this .sln is that it has references to each of the four projects we just created.
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "Microsoft.Build.Dev.sln",
+                    @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio 15
+                    VisualStudioVersion = 15.0.27004.2009
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build"", """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)) + @""", ""{69BE05E2-CBDA-4D27-9733-44E12B0F5627}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""MSBuild"", """ + Path.Combine("src", Path.GetFileName(msbuild.Path)) + @""", ""{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.CommandLine.UnitTests"", """ + Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)) + @""", ""{0ADDBC02-0076-4159-B351-2BF33FAA46B2}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.Tasks.UnitTests"", """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)) + @""", ""{CF999BDE-02B3-431B-95E6-E88D621D9CBF}""
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(ExtensibilityGlobals) = postSolution
+                    EndGlobalSection
+                    EndGlobal
+                    ");
+                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf",
+                    @"
+                    {
+                      ""solution"": {
+                        ""path"": """ + sln.Path.Replace("\\", "\\\\") + @""",
+                        ""projects"": [
+                          """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)).Replace("\\", "\\\\") + @""",
+                          """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)).Replace("\\", "\\\\") + @"""
+                        ]
+                        }
+                    }");
+                SolutionFile sp = SolutionFile.Parse(slnf.Path);
+                Assert.True(sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(microsoftBuild.Path))) && sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(tasksUnitTests.Path))));
+                Assert.False(sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path))) || sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(msbuild.Path))) || sp.ProjectShouldBuild(Path.Combine("src", "notAProject.csproj")));
+            }
+        }
+
         /// <summary>
         /// Test just the most basic, plain vanilla first project line.
         /// </summary>
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 655a4ad71c3..4cc129d7abd 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -60,6 +60,121 @@ public void Dispose()
             ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
         }
 
+        /// <summary>
+        /// Test that if a before.{sln}>.targets or after.{sln}.targets file has one of the default targets (Build, Clean, etc.) that it includes only the user-defined target.
+        /// </summary>
+        [Theory]
+        [InlineData("before.MySln.sln.targets")]
+        [InlineData("after.MySln.sln.targets")]
+        [InlineData("name.that.does.Not.Affect.The.Build.targets")]
+        public void SolutionProjectIgnoresDuplicateDefaultTargets(string name)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "MySln.sln", @"Microsoft Visual Studio Solution File, Format Version 16.00");
+                TransientTestFile targetsFile = testEnvironment.CreateFile(folder, name,
+                    @"<Project>
+                        <Target Name=""Build"" AfterTargets=""NonsenseTarget"">
+                        </Target>
+                      </Project>");
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(SolutionFile.Parse(sln.Path), null, null, _buildEventContext, CreateMockLoggingService());
+                instances.ShouldHaveSingleItem();
+                instances[0].Targets["Build"].AfterTargets.ShouldBe(string.Empty);
+                MockLogger logger = new MockLogger(output);
+                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
+            }
+        }
+
+        /// <summary>
+        /// Test that a solution filter file excludes projects not covered by its list of projects or their dependencies.
+        /// </summary>
+        [Fact]
+        public void SolutionFilterFiltersProjects()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);              
+                TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "ClassLibrary"), createFolder: true);
+                TransientTestFolder classLibSubFolder = testEnvironment.CreateFolder(Path.Combine(classLibFolder.Path, "ClassLibrary"), createFolder: true);
+                TransientTestFile classLibrary = testEnvironment.CreateFile(classLibSubFolder, "ClassLibrary.csproj",
+                    @"<Project>
+                  <Target Name=""ClassLibraryTarget"">
+                      <Message Text=""ClassLibraryBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "SimpleProject"), createFolder: true);
+                TransientTestFolder simpleProjectSubFolder = testEnvironment.CreateFolder(Path.Combine(simpleProjectFolder.Path, "SimpleProject"), createFolder: true);
+                TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectSubFolder, "SimpleProject.csproj",
+                    @"<Project DefaultTargets=""SimpleProjectTarget"">
+                  <Target Name=""SimpleProjectTarget"">
+                      <Message Text=""SimpleProjectBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+                TransientTestFile solutionFile = testEnvironment.CreateFile(simpleProjectFolder, "SimpleProject.sln",
+                    @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.0.29326.124
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", """ + Path.Combine("SimpleProject", "SimpleProject.csproj") + @""", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", """ + Path.Combine("..", "ClassLibrary", "ClassLibrary", "ClassLibrary.csproj") + @""", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|Any CPU = Debug|Any CPU
+                            Release|Any CPU = Release|Any CPU
+                            EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.Build.0 = Release|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.Build.0 = Release|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.Build.0 = Release|Any CPU
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                        GlobalSection(ExtensibilityGlobals) = postSolution
+                            SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
+                        EndGlobalSection
+                    EndGlobal
+                ");
+                TransientTestFile filterFile = testEnvironment.CreateFile(folder, "solutionFilter.slnf",
+                    @"
+                {
+                  ""solution"": {
+                    ""path"": """ + solutionFile.Path.Replace("\\", "\\\\") + @""",
+                    ""projects"": [
+                      """ + Path.Combine("SimpleProject", "SimpleProject.csproj").Replace("\\", "\\\\") + @"""
+                    ]
+                    }
+                }
+                ");
+                SolutionFile solution = SolutionFile.Parse(filterFile.Path);
+                ILoggingService mockLogger = CreateMockLoggingService();
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, mockLogger);
+                instances.ShouldHaveSingleItem();
+
+                // Check that dependencies are built, and non-dependencies in the .sln are not.
+                MockLogger logger = new MockLogger(output);
+                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
+                logger.AssertLogContains(new string[] { "SimpleProjectBuilt" });
+                logger.AssertLogDoesntContain("ClassLibraryBuilt");
+            }
+        }
+
         /// <summary>
         /// Verify the AddNewErrorWarningMessageElement method
         /// </summary>
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index 4d62dca5bca..f476576b44f 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -58,6 +58,13 @@ override public bool Execute()
 
     public class SimpleScenarios : IDisposable
     {
+        private readonly ITestOutputHelper _output;
+
+        public SimpleScenarios(ITestOutputHelper testOutputHelper)
+        {
+            _output = testOutputHelper;
+        }
+
         /// <summary>
         /// Since we create a project with the same name in many of these tests, and two projects with
         /// the same name cannot be loaded in a ProjectCollection at the same time, we should unload the
@@ -84,7 +91,7 @@ public void SemicolonInPropertyPassedIntoStringParam()
                         <Message Text=`Property value is '$(MyPropertyWithSemicolons)'` />
                     </Target>
                 </Project>
-                ");
+                ", logger: new MockLogger(_output));
 
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
@@ -108,7 +115,7 @@ public void SemicolonInPropertyPassedIntoStringParam_UsingTaskHost()
                         <Message Text=`Property value is '$(MyPropertyWithSemicolons)'` />
                     </Target>
                 </Project>
-                ");
+                ", logger: new MockLogger(_output));
 
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
@@ -138,7 +145,8 @@ public void SemicolonInPropertyPassedIntoITaskItemParam()
 
                 </Project>
 
-                ", new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath));
+                ", new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath),
+                logger: new MockLogger(_output));
 
             logger.AssertLogContains("Received TaskItemParam: 123 abc ; def ; ghi 789");
         }
@@ -167,7 +175,8 @@ public void SemicolonInPropertyPassedIntoITaskItemParam_UsingTaskHost()
 
                 </Project>
 
-                ", new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath));
+                ", new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath),
+                logger: new MockLogger(_output));
 
             logger.AssertLogContains("Received TaskItemParam: 123 abc ; def ; ghi 789");
         }
@@ -544,7 +553,8 @@ public void InferEscapedOutputsFromTask()
 
                 </Project>
 
-                ", inputFile, outputFile));
+                ", inputFile, outputFile),
+                logger: new MockLogger(_output));
 
                 logger.AssertLogContains("Resources = aaa%3bbbb.resx;ccc%3bddd.resx");
             }
@@ -575,7 +585,7 @@ public void ItemTransformContainingSemicolon()
                     </Target>
                 </Project>
 
-                ");
+                ", logger: new MockLogger(_output));
 
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
@@ -604,7 +614,7 @@ public void ItemTransformContainingSemicolon_InTaskHost()
                     </Target>
                 </Project>
 
-                ");
+                ", logger: new MockLogger(_output));
 
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 6766d6124cf..2009a9b3f55 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -2489,7 +2489,7 @@ public void PropertyStaticFunctionAllEnabled()
         /// Expand property function that is defined (on CoreFX) in an assembly named after its full namespace.
         /// </summary>
         [Fact]
-        public void PropertyStaticFunctioLocatedFromAssemblyWithNamespaceName()
+        public void PropertyStaticFunctionLocatedFromAssemblyWithNamespaceName()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
 
@@ -2777,6 +2777,27 @@ public void PropertyFunctionRuntimeInformation(string propertyFunction, string e
             Assert.Equal(expectedExpansion, result);
         }
 
+        [Theory]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x', 1))", "3")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x45', 1))", "3")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x', 1, 4))", "3")]
+        // 9 is not a valid StringComparison enum value
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x', 9))", "10")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('X', 'StringComparison.Ordinal'))", "-1")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('X', 'StringComparison.OrdinalIgnoreCase'))", "0")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('X4', 'StringComparison.OrdinalIgnoreCase'))", "3")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('X4', 1, 'StringComparison.OrdinalIgnoreCase'))", "3")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('X', 1, 3, 'StringComparison.OrdinalIgnoreCase'))", "3")]
+        public void StringIndexOfTests(string propertyName, string properyValue, string propertyFunction, string expectedExpansion)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>
+                {[propertyName] = ProjectPropertyInstance.Create(propertyName, properyValue)};
+
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expectedExpansion);
+        }
+
         [Fact]
         public void IsOsPlatformShouldBeCaseInsensitiveToParameter()
         {
@@ -2800,34 +2821,23 @@ public void PropertyFunctionVersionComparisonsFailsWithInvalidArguments(string b
             var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
             string expectedMessage = ResourceUtilities.GetResourceString("InvalidVersionFormat");
 
-            AssertThrows($"$([MSBuild]::VersionGreaterThan('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionGreaterThan('1.0.0', '{badVersion}'))");
+            AssertThrows(expander, $"$([MSBuild]::VersionGreaterThan('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionGreaterThan('1.0.0', '{badVersion}'))", expectedMessage);
 
-            AssertThrows($"$([MSBuild]::VersionGreaterThanOrEquals('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionGreaterThanOrEquals('1.0.0', '{badVersion}'))");
+            AssertThrows(expander, $"$([MSBuild]::VersionGreaterThanOrEquals('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionGreaterThanOrEquals('1.0.0', '{badVersion}'))", expectedMessage);
 
-            AssertThrows($"$([MSBuild]::VersionLessThan('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionLessThan('1.0.0', '{badVersion}'))");
+            AssertThrows(expander, $"$([MSBuild]::VersionLessThan('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionLessThan('1.0.0', '{badVersion}'))", expectedMessage);
 
-            AssertThrows($"$([MSBuild]::VersionLessThanOrEquals('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionLessThanOrEquals('1.0.0', '{badVersion}'))");
+            AssertThrows(expander, $"$([MSBuild]::VersionLessThanOrEquals('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionLessThanOrEquals('1.0.0', '{badVersion}'))", expectedMessage);
 
-            AssertThrows($"$([MSBuild]::VersionEquals('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionEquals('1.0.0', '{badVersion}'))");
+            AssertThrows(expander, $"$([MSBuild]::VersionEquals('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionEquals('1.0.0', '{badVersion}'))", expectedMessage);
 
-            AssertThrows($"$([MSBuild]::VersionNotEquals('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionNotEquals('1.0.0', '{badVersion}'))");
-
-            void AssertThrows(string expression)
-            {
-                var ex = Assert.Throws<InvalidProjectFileException>(
-                    () => expander.ExpandPropertiesLeaveTypedAndEscaped(
-                        expression,
-                        ExpanderOptions.ExpandProperties,
-                        MockElementLocation.Instance));
-
-                Assert.Contains(expectedMessage, ex.Message);
-            }
+            AssertThrows(expander, $"$([MSBuild]::VersionNotEquals('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionNotEquals('1.0.0', '{badVersion}'))", expectedMessage);
         }
 
         [Theory]
@@ -2843,22 +2853,64 @@ public void PropertyFunctionVersionComparisons(string a, string b, int expectedS
             var pg = new PropertyDictionary<ProjectPropertyInstance>();
             var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
 
-            AssertSuccess(expectedSign >  0, $"$([MSBuild]::VersionGreaterThan('{a}', '{b}'))");
-            AssertSuccess(expectedSign >= 0, $"$([MSBuild]::VersionGreaterThanOrEquals('{a}', '{b}'))");
-            AssertSuccess(expectedSign <  0, $"$([MSBuild]::VersionLessThan('{a}', '{b}'))");
-            AssertSuccess(expectedSign <= 0, $"$([MSBuild]::VersionLessThanOrEquals('{a}', '{b}'))");
-            AssertSuccess(expectedSign == 0, $"$([MSBuild]::VersionEquals('{a}', '{b}'))");
-            AssertSuccess(expectedSign != 0, $"$([MSBuild]::VersionNotEquals('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign >  0, $"$([MSBuild]::VersionGreaterThan('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign >= 0, $"$([MSBuild]::VersionGreaterThanOrEquals('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign <  0, $"$([MSBuild]::VersionLessThan('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign <= 0, $"$([MSBuild]::VersionLessThanOrEquals('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign == 0, $"$([MSBuild]::VersionEquals('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign != 0, $"$([MSBuild]::VersionNotEquals('{a}', '{b}'))");
+        }
 
-            void AssertSuccess(bool expected, string expression)
-            {
-                bool actual = (bool)expander.ExpandPropertiesLeaveTypedAndEscaped(
+        [Theory]
+        [InlineData("net45", ".NETFramework", "4.5")]
+        [InlineData("netcoreapp3.1", ".NETCoreApp", "3.1")]
+        [InlineData("netstandard2.1", ".NETStandard", "2.1")]
+        [InlineData("foo", "Unsupported", "0.0")]
+        public void PropertyFunctionTargetFrameworkParsing(string tfm, string expectedIdentifier, string expectedVersion)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            AssertSuccess(expander, expectedIdentifier, $"$([MSBuild]::GetTargetFrameworkIdentifier('{tfm}'))");
+            AssertSuccess(expander, expectedVersion, $"$([MSBuild]::GetTargetFrameworkVersion('{tfm}'))");
+        }
+
+        [Theory]
+        [InlineData("net5.0", "net5.0", true)]
+        [InlineData("net45", "net46", false)]
+        [InlineData("net46", "net45", true)]
+        [InlineData("netcoreapp3.1", "netcoreapp1.0", true)]
+        [InlineData("netstandard1.6", "netstandard2.1", false)]
+        [InlineData("netcoreapp3.0", "netstandard2.1", true)]
+        [InlineData("net461", "netstandard1.0", true)]
+        [InlineData("foo", "netstandard1.0", false)]
+        public void PropertyFunctionTargetFrameworkComparisons(string tfm1, string tfm2, bool expectedFrameworkCompatible)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            AssertSuccess(expander, expectedFrameworkCompatible, $"$([MSBuild]::IsTargetFrameworkCompatible('{tfm1}', '{tfm2}'))");
+        }
+
+        private void AssertThrows(Expander<ProjectPropertyInstance, ProjectItemInstance> expander, string expression, string expectedMessage)
+        {
+            var ex = Assert.Throws<InvalidProjectFileException>(
+                () => expander.ExpandPropertiesLeaveTypedAndEscaped(
                     expression,
                     ExpanderOptions.ExpandProperties,
-                    MockElementLocation.Instance);
+                    MockElementLocation.Instance));
 
-                Assert.Equal(expected, actual);
-            }
+            Assert.Contains(expectedMessage, ex.Message);
+        }
+
+        private void AssertSuccess(Expander<ProjectPropertyInstance, ProjectItemInstance> expander, object expected, string expression)
+        {
+            var actual = expander.ExpandPropertiesLeaveTypedAndEscaped(
+                expression,
+                ExpanderOptions.ExpandProperties,
+                MockElementLocation.Instance);
+
+            Assert.Equal(expected, actual);
         }
 
         /// <summary>
@@ -3432,6 +3484,26 @@ public void PropertyFunctionConsumingItemMetadata()
             Assert.Equal(Path.Combine(s_rootPathPrefix, "some", "path", "fOo.Cs"), result);
         }
 
+        /// <summary>
+        /// Expand a property function which is a string constructor referencing item metadata.
+        /// </summary>
+        /// <remarks>
+        /// Note that referencing a non-existent metadatum results in binding to a parameter-less String constructor. This constructor
+        /// does not exist in BCL but it is special-cased in the expander logic and handled to return an empty string.
+        /// </remarks>
+        [Theory]
+        [InlineData("language", "english")]
+        [InlineData("nonexistent", "")]
+        public void PropertyStringConstructorConsumingItemMetadata(string metadatumName, string metadatumValue)
+        {
+            ProjectHelpers.CreateEmptyProjectInstance();
+            var expander = CreateItemFunctionExpander();
+
+            string result = expander.ExpandIntoStringLeaveEscaped($"$([System.String]::new(%({metadatumName})))", ExpanderOptions.ExpandAll, MockElementLocation.Instance);
+
+            result.ShouldBe(metadatumValue);
+        }
+
         /// <summary>
         /// A whole bunch error check tests
         /// </summary>
diff --git a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
index c6573a00527..8585455ea7f 100644
--- a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
@@ -12,6 +12,8 @@
 using Microsoft.Build.Definition;
 using Microsoft.Build.Unittest;
 using Xunit;
+using Microsoft.Build.Framework;
+using System.Linq;
 
 namespace Microsoft.Build.UnitTests.Preprocessor
 {
@@ -927,6 +929,122 @@ This import was added implicitly because the Project element's Sdk attribute spe
             }
         }
 
+        [Fact]
+        public void SdkResolverItemsAndPropertiesAreInPreprocessedOutput()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                string testDirectory = env.CreateFolder().Path;
+
+                var propertiesToAdd = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                {
+                    {"PropertyFromSdkResolver", "ValueFromSdkResolver" }
+                };
+
+                var itemsToAdd = new Dictionary<string, SdkResultItem>(StringComparer.OrdinalIgnoreCase)
+                {
+                    { "ItemNameFromSdkResolver", new SdkResultItem( "ItemValueFromSdkResolver",
+                        new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                        {
+                            { "MetadataName", "MetadataValue" }
+                        })
+                    }
+                };
+
+                var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                    new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        new [] { testDirectory},
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                        )));
+
+                string content = @"<Project>
+<Import Project='Import.props' Sdk='TestPropsAndItemsFromResolverSdk' />
+<PropertyGroup>
+<p>v1</p>
+</PropertyGroup>
+</Project>";
+
+                string importedPropsPath = Path.Combine(testDirectory, "Import.props");
+                File.WriteAllText(importedPropsPath, @"<Project>
+    <PropertyGroup>
+        <SdkPropsImported>true</SdkPropsImported>
+    </PropertyGroup>
+</Project>");
+
+                string projectPath = Path.Combine(testDirectory, "TestProject.csproj");
+                File.WriteAllText(projectPath, content);
+
+                var project = Project.FromFile(projectPath, projectOptions);
+
+                StringWriter writer = new StringWriter();
+
+                project.SaveLogicalProject(writer);
+
+                string actual = writer.ToString();
+
+                //  File names for the projects including the properties and items from the SDK resolvers are based on a hash of
+                //  the values, so look up the filename here.
+                //  Sample filename: projectPath + ".SdkResolver.-171948414.proj"
+                var virtualImport = project.Imports.First(i => i.ImportedProject.FullPath.StartsWith(projectPath + ".SdkResolver"));
+                string virtualProjectPath = virtualImport.ImportedProject.FullPath;
+
+                string expected = ObjectModelHelpers.CleanupFileContents(
+                    $@"<?xml version=""1.0"" encoding=""utf-16""?>
+<!--
+============================================================================================================================================
+{projectPath.Replace("--", "__")}
+============================================================================================================================================
+-->
+<Project>
+  <!--
+============================================================================================================================================
+  <Import Project=""Import.props"" Sdk=""TestPropsAndItemsFromResolverSdk"">
+
+{virtualProjectPath.Replace("--", "__")}
+============================================================================================================================================
+-->
+  <PropertyGroup xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+    <PropertyFromSdkResolver>ValueFromSdkResolver</PropertyFromSdkResolver>
+  </PropertyGroup>
+  <ItemGroup xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+    <ItemNameFromSdkResolver Include=""ItemValueFromSdkResolver"">
+      <MetadataName>MetadataValue</MetadataName>
+    </ItemNameFromSdkResolver>
+  </ItemGroup>
+  <!--
+============================================================================================================================================
+  </Import>
+============================================================================================================================================
+-->
+  <!--
+============================================================================================================================================
+  <Import Project=""Import.props"" Sdk=""TestPropsAndItemsFromResolverSdk"">
+
+{importedPropsPath.Replace("--", "__")}
+============================================================================================================================================
+-->
+  <PropertyGroup>
+    <SdkPropsImported>true</SdkPropsImported>
+  </PropertyGroup>
+  <!--
+============================================================================================================================================
+  </Import>
+
+{projectPath.Replace("--", "__")}
+============================================================================================================================================
+-->
+  <PropertyGroup>
+    <p>v1</p>
+  </PropertyGroup>
+</Project>");
+                Helpers.VerifyAssertLineByLine(expected, actual);
+            }
+        }
+
         [Fact]
         public void ImportedProjectsSdkImportsAreInPreprocessedOutput()
         {
diff --git a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
index 1311582de2a..659ce98e4bc 100644
--- a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
@@ -511,9 +511,9 @@ public void ImplicitImportsShouldHaveParsedSdkInfo(
                 var import = imports[i];
                 var importingElement = import.ImportingElement;
                 importingElement.Sdk.ShouldBe(SdkName + $"/{version}");
-                importingElement.ParsedSdkReference.Name.ShouldBe(SdkName);
-                importingElement.ParsedSdkReference.Version.ShouldBe(expectedVersion);
-                importingElement.ParsedSdkReference.MinimumVersion.ShouldBe(expectedMinimumVersion);
+                importingElement.SdkReference.Name.ShouldBe(SdkName);
+                importingElement.SdkReference.Version.ShouldBe(expectedVersion);
+                importingElement.SdkReference.MinimumVersion.ShouldBe(expectedMinimumVersion);
                 importingElement.SdkLocation.ShouldBe(ElementLocation.EmptyLocation);
                 importingElement.OriginalElement.ShouldBeOfType(expectedOriginalElementType);
 
@@ -523,7 +523,7 @@ public void ImplicitImportsShouldHaveParsedSdkInfo(
 
                 importingElement.ImplicitImportLocation.ShouldBe(implicitLocation);
 
-                import.SdkResult.SdkReference.ShouldBeSameAs(importingElement.ParsedSdkReference);
+                import.SdkResult.SdkReference.ShouldBeSameAs(importingElement.SdkReference);
 
                 var expectedSdkPath = i == 0
                     ? _sdkPropsPath
@@ -554,7 +554,7 @@ private void VerifyPropertyFromImplicitImport(Project project, string propertyNa
 
         private SdkReference GetParsedSdk(ProjectImportElement element)
         {
-            PropertyInfo parsedSdkInfo = typeof(ProjectImportElement).GetProperty("ParsedSdkReference", BindingFlags.Instance | BindingFlags.NonPublic);
+            PropertyInfo parsedSdkInfo = typeof(ProjectImportElement).GetProperty("SdkReference", BindingFlags.Instance | BindingFlags.NonPublic);
             return (SdkReference)parsedSdkInfo.GetValue(element);
         }
     }
diff --git a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
new file mode 100644
index 00000000000..ee2a51e78b8
--- /dev/null
+++ b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
@@ -0,0 +1,471 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Unittest;
+using Shouldly;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.UnitTests.Evaluation
+{
+    public class SdkResultEvaluation_Tests : IDisposable
+    {
+        private TestEnvironment _env;
+        private readonly string _testFolder;
+        private MockLogger _logger;
+        private ProjectCollection _projectCollection;
+        private ITestOutputHelper _log;
+        private bool _originalWarnOnUnitializedProperty;
+
+        public SdkResultEvaluation_Tests(ITestOutputHelper log)
+        {
+            _log = log;
+    
+            _env = TestEnvironment.Create();
+
+            _originalWarnOnUnitializedProperty = BuildParameters.WarnOnUninitializedProperty;
+            BuildParameters.WarnOnUninitializedProperty = false;
+
+            _testFolder = _env.CreateFolder().Path;
+            _logger = new MockLogger();
+            _projectCollection = _env.CreateProjectCollection().Collection;
+            _projectCollection.RegisterLogger(_logger);
+        }
+
+        private Project CreateProject(string projectPath, ProjectOptions projectOptions)
+        {
+            ProjectRootElement projectRootElement = ProjectRootElement.Open(projectPath, _projectCollection);
+
+            projectOptions.ProjectCollection = _projectCollection;
+
+            var project = Project.FromProjectRootElement(projectRootElement, projectOptions);
+
+            return project;
+        }
+
+        private void CreateMockSdkResultPropertiesAndItems(out Dictionary<string, string> propertiesToAdd, out Dictionary<string, SdkResultItem> itemsToAdd)
+        {
+            propertiesToAdd = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                {
+                    {"PropertyFromSdkResolver", "ValueFromSdkResolver" }
+                };
+
+            itemsToAdd = new Dictionary<string, SdkResultItem>(StringComparer.OrdinalIgnoreCase)
+                {
+                    { "ItemNameFromSdkResolver", new SdkResultItem( "ItemValueFromSdkResolver",
+                        new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                        {
+                            { "MetadataName", "MetadataValue" }
+                        })
+                    }
+                };
+        }
+
+        private void ValidateExpectedPropertiesAndItems(bool includePropertiesAndItems, Project project, int expectedItemCount = 1)
+        {
+            if (includePropertiesAndItems)
+            {
+                project.GetPropertyValue("PropertyFromSdkResolver").ShouldBe("ValueFromSdkResolver");
+
+                var itemsFromResolver = project.GetItems("ItemNameFromSdkResolver");
+                itemsFromResolver.Count.ShouldBe(expectedItemCount);
+                foreach (var item in itemsFromResolver)
+                {
+                    ValidateItemFromResolver(item);
+                }
+            }
+            else
+            {
+                project.GetProperty("PropertyFromSdkResolver").ShouldBeNull();
+                project.GetItems("ItemNameFromSdkResolver").ShouldBeEmpty();
+            }
+        }
+
+        private void ValidateItemFromResolver(ProjectItem item)
+        {
+            item.EvaluatedInclude.ShouldBe("ItemValueFromSdkResolver");
+            item.Metadata.Select(m => (m.Name, m.EvaluatedValue))
+                .ShouldBeSameIgnoringOrder(new[] { (Name: "MetadataName", EvaluatedValue: "MetadataValue") });
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
+        {
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            if (includePropertiesAndItems)
+            {
+                CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+            }
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        Enumerable.Empty<string>(),
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                    ))
+                );
+
+            string projectContent = @"
+                    <Project>
+                        <Import Project=""Sdk.props"" Sdk=""TestPropsAndItemsFromResolverSdk""/>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            var project = CreateProject(projectPath, projectOptions);
+
+            ValidateExpectedPropertiesAndItems(includePropertiesAndItems, project);
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SdkResolverCanReturnSinglePath(bool includePropertiesAndItems)
+        {
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            if (includePropertiesAndItems)
+            {
+                CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+            }
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        new[] { Path.Combine(_testFolder, "Sdk") },
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                    ))
+                );
+
+            string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <ValueFromResolverBefore>Value=$(PropertyFromSdkResolver)</ValueFromResolverBefore>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <ItemsFromSdkResolverBefore Include=""@(ItemNameFromSdkResolver)"" />
+                        </ItemGroup>
+                        <Import Project=""Sdk.props"" Sdk=""TestPropsAndItemsFromResolverSdk""/>
+                        <PropertyGroup>
+                            <ValueFromResolverAfter>Value=$(PropertyFromSdkResolver)</ValueFromResolverAfter>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <ItemsFromSdkResolverAfter Include=""@(ItemNameFromSdkResolver)"" />
+                        </ItemGroup>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            string sdkImportContents = @"
+                    <Project>
+                        <PropertyGroup>
+                            <PropertyFromImportedSdk>ValueFromImportedSdk</PropertyFromImportedSdk>
+                        </PropertyGroup>
+                    </Project>";
+
+            string sdkPropsPath = Path.Combine(_testFolder, "Sdk", "Sdk.props");
+            Directory.CreateDirectory(Path.Combine(_testFolder, "Sdk"));
+            File.WriteAllText(sdkPropsPath, sdkImportContents);
+
+            var project = CreateProject(projectPath, projectOptions);
+
+            ValidateExpectedPropertiesAndItems(includePropertiesAndItems, project);
+
+            project.GetPropertyValue("ValueFromResolverBefore").ShouldBe("Value=");
+            if (includePropertiesAndItems)
+            {
+                project.GetPropertyValue("ValueFromResolverAfter").ShouldBe("Value=ValueFromSdkResolver");
+            }
+            else
+            {
+                project.GetPropertyValue("ValueFromResolverAfter").ShouldBe("Value=");
+            }
+
+            project.GetPropertyValue("PropertyFromImportedSdk").ShouldBe("ValueFromImportedSdk");
+
+            project.GetItems("ItemsFromSdkResolverBefore").ShouldBeEmpty();
+            if (includePropertiesAndItems)
+            {
+                var items = project.GetItems("ItemsFromSdkResolverAfter");
+                items.Count.ShouldBe(1);
+                ValidateItemFromResolver(items.Single());
+            }
+            else
+            {
+                project.GetItems("ItemsFromSdkResolverAfter").ShouldBeEmpty();
+            }
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SdkResolverCanReturnMultiplePaths(bool includePropertiesAndItems)
+        {
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            if (includePropertiesAndItems)
+            {
+                CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+            }
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        new[] {
+                            Path.Combine(_testFolder, "Sdk1"),
+                            Path.Combine(_testFolder, "Sdk2")
+                        },
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                    ))
+                );
+
+            string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <ValueFromResolverBefore>Value=$(PropertyFromSdkResolver)</ValueFromResolverBefore>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <ItemsFromSdkResolverBefore Include=""@(ItemNameFromSdkResolver)"" />
+                        </ItemGroup>
+                        <Import Project=""Sdk.props"" Sdk=""TestPropsAndItemsFromResolverSdk""/>
+                        <PropertyGroup>
+                            <ValueFromResolverAfter>Value=$(PropertyFromSdkResolver)</ValueFromResolverAfter>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <ItemsFromSdkResolverAfter Include=""@(ItemNameFromSdkResolver)"" />
+                        </ItemGroup>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            string sdk1ImportContents = @"
+                    <Project>
+                        <PropertyGroup>
+                            <PropertyFromImportedSdk1>ValueFromImportedSdk1</PropertyFromImportedSdk1>
+                        </PropertyGroup>
+                    </Project>";
+
+            string sdk1PropsPath = Path.Combine(_testFolder, "Sdk1", "Sdk.props");
+            Directory.CreateDirectory(Path.Combine(_testFolder, "Sdk1"));
+            File.WriteAllText(sdk1PropsPath, sdk1ImportContents);
+
+            string sdk2ImportContents = @"
+                    <Project>
+                        <PropertyGroup>
+                            <PropertyFromImportedSdk2>ValueFromImportedSdk2</PropertyFromImportedSdk2>
+                        </PropertyGroup>
+                    </Project>";
+
+            string sdk2PropsPath = Path.Combine(_testFolder, "Sdk2", "Sdk.props");
+            Directory.CreateDirectory(Path.Combine(_testFolder, "Sdk2"));
+            File.WriteAllText(sdk2PropsPath, sdk2ImportContents);
+
+            var project = CreateProject(projectPath, projectOptions);
+
+            ValidateExpectedPropertiesAndItems(includePropertiesAndItems, project);
+
+            project.GetPropertyValue("ValueFromResolverBefore").ShouldBe("Value=");
+            if (includePropertiesAndItems)
+            {
+                project.GetPropertyValue("ValueFromResolverAfter").ShouldBe("Value=ValueFromSdkResolver");
+            }
+            else
+            {
+                project.GetPropertyValue("ValueFromResolverAfter").ShouldBe("Value=");
+            }
+
+            project.GetPropertyValue("PropertyFromImportedSdk1").ShouldBe("ValueFromImportedSdk1");
+            project.GetPropertyValue("PropertyFromImportedSdk2").ShouldBe("ValueFromImportedSdk2");
+
+            project.GetItems("ItemsFromSdkResolverBefore").ShouldBeEmpty();
+            if (includePropertiesAndItems)
+            {
+                var items = project.GetItems("ItemsFromSdkResolverAfter");
+                items.Count.ShouldBe(1);
+                ValidateItemFromResolver(items.Single());
+            }
+            else
+            {
+                project.GetItems("ItemsFromSdkResolverAfter").ShouldBeEmpty();
+            }
+
+            if (_logger.ErrorCount > 0 || _logger.WarningCount > 0)
+            {
+                _log.WriteLine(_logger.FullLog);
+            }
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        //  When two different SdkResults (ie from the Sdk.props and Sdk.targets imports) return the same combination of items / properties:
+        //  - Test that there aren't warnings for duplicate imports
+        //  - Test that items from resolver are duplicated in final evaluation result
+        [Fact]
+        public void SdkResolverCanReturnTheSamePropertiesAndItemsMultipleTimes()
+        {
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        new[] { Path.Combine(_testFolder, "Sdk") },
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                    ))
+                );
+
+            string projectContent = @"
+                    <Project Sdk=""TestPropsAndItemsFromResolverSdk"">
+                        <PropertyGroup>
+                            <ValueFromResolverInProjectBody>Value=$(PropertyFromSdkResolver)</ValueFromResolverInProjectBody>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <ItemsFromSdkResolverInProjectBody Include=""@(ItemNameFromSdkResolver)"" />
+                        </ItemGroup>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            string sdkPropsContents = @"
+                    <Project>
+                        <PropertyGroup>
+                            <PropertyFromSdkProps>PropertyFromSdkPropsValue</PropertyFromSdkProps>
+                        </PropertyGroup>
+                    </Project>";
+
+            string sdkPropsPath = Path.Combine(_testFolder, "Sdk", "Sdk.props");
+            Directory.CreateDirectory(Path.Combine(_testFolder, "Sdk"));
+            File.WriteAllText(sdkPropsPath, sdkPropsContents);
+
+            string sdkTargetsContents = @"
+                    <Project>
+                        <PropertyGroup>
+                            <PropertyFromSdkTargets>PropertyFromSdkTargetsValue</PropertyFromSdkTargets>
+                        </PropertyGroup>
+                    </Project>";
+
+            string sdkTargetsPath = Path.Combine(_testFolder, "Sdk", "Sdk.targets");
+            File.WriteAllText(sdkTargetsPath, sdkTargetsContents);
+
+            var project = CreateProject(projectPath, projectOptions);
+
+            ValidateExpectedPropertiesAndItems(true, project, expectedItemCount: 2);
+
+            project.GetPropertyValue("ValueFromResolverInProjectBody").ShouldBe("Value=ValueFromSdkResolver");
+            project.GetPropertyValue("PropertyFromSdkProps").ShouldBe("PropertyFromSdkPropsValue");
+            project.GetPropertyValue("PropertyFromSdkTargets").ShouldBe("PropertyFromSdkTargetsValue");
+
+            var itemsFromBody = project.GetItems("ItemsFromSdkResolverInProjectBody");
+            itemsFromBody.Count.ShouldBe(1);
+            ValidateItemFromResolver(itemsFromBody.Single());
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Fact]
+        public void SdkResolverCanReturnSpecialCharacters()
+        {
+            //  %3B - semicolon
+            //  %24 - $
+            //  %0A - LF
+
+            string specialString = "%3B;%24$%0A\\\"'";
+
+            Dictionary<string, string> propertiesToAdd = new Dictionary<string, string>()
+            {
+                { "PropertyName", "PropertyValue" + specialString }
+            };
+
+            Dictionary<string, SdkResultItem> itemsToAdd = new Dictionary<string, SdkResultItem>()
+            {
+                {
+                    "ItemName",
+                    new SdkResultItem(itemSpec: "ItemValue" + specialString, new Dictionary<string, string>()
+                        { { "MetadataName", "MetadataValue" + specialString } })
+                }
+            };
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestSpecialCharactersFromSdkResolver", null, null),
+                        Enumerable.Empty<string>(),
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                    ))
+                );
+
+            string projectContent = @"
+                    <Project>
+                        <Import Project=""Sdk.props"" Sdk=""TestSpecialCharactersFromSdkResolver""/>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            var project = CreateProject(projectPath, projectOptions);
+
+            project.GetPropertyValue("PropertyName").ShouldBe("PropertyValue" + specialString);
+
+            var itemsFromResolver = project.GetItems("ItemName");
+            var item = itemsFromResolver.ShouldHaveSingleItem();
+            item.EvaluatedInclude.ShouldBe("ItemValue" + specialString);
+            item.Metadata.Select(m => (m.Name, m.EvaluatedValue))
+                .ShouldBeSameIgnoringOrder(new[] { (Name: "MetadataName", EvaluatedValue: "MetadataValue" + specialString) });
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
+
+        }
+
+        public void Dispose()
+        {
+            _env.Dispose();
+            BuildParameters.WarnOnUninitializedProperty = _originalWarnOnUnitializedProperty;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 8a15d66ec99..6ae0368da58 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -581,8 +581,8 @@ public void SolutionEdgesShouldNotOverwriteMultitargetingEdges()
                 Projects = new Dictionary<string, string>
                 {
                     {"1", GraphTestingUtilities.CreateProjectFile(_env, 1, new[] {2}).Path},
-                    {"2", GraphTestingUtilities.CreateProjectFile(_env, 2, extraContent: MultitargetingSpecification).Path},
-                    {"3", GraphTestingUtilities.CreateProjectFile(_env, 3, new[] {4}, extraContent: MultitargetingSpecification).Path},
+                    {"2", GraphTestingUtilities.CreateProjectFile(_env, 2, extraContent: MultitargetingSpecificationPropertyGroup).Path},
+                    {"3", GraphTestingUtilities.CreateProjectFile(_env, 3, new[] {4}, extraContent: MultitargetingSpecificationPropertyGroup).Path},
                     {"4", GraphTestingUtilities.CreateProjectFile(_env, 4).Path}
                 },
                 SolutionDependencies = new[] {("1", "2"), ("3", "4")}
@@ -687,10 +687,10 @@ private void AssertSolutionBasedGraph(
             if (projectConfigurations == null || graphFromSolution.ProjectNodes.All(n => n.ProjectReferences.Count == 0))
             {
                 graphFromSolution.GraphRoots.Select(GetProjectPath)
-                    .ShouldBeEquivalentTo(graph.GraphRoots.Select(GetProjectPath));
+                    .ShouldBeSameIgnoringOrder(graph.GraphRoots.Select(GetProjectPath));
 
                 graphFromSolution.ProjectNodes.Select(GetProjectPath)
-                    .ShouldBeEquivalentTo(graph.ProjectNodes.Select(GetProjectPath));
+                    .ShouldBeSameIgnoringOrder(graph.ProjectNodes.Select(GetProjectPath));
             }
 
             var expectedCurrentConfiguration = currentSolutionConfiguration ?? solutionConfigurations.First();
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index b52763372bf..4cde1fc90bc 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.IO;
@@ -17,12 +18,22 @@ internal static class GraphTestingUtilities
         public static readonly ImmutableDictionary<string, string> EmptyGlobalProperties = new Dictionary<string, string> {{PropertyNames.IsGraphBuild, "true"}}.ToImmutableDictionary();
 
         public static readonly string InnerBuildPropertyName = "InnerBuild";
+        public static readonly string InnerBuildPropertiesName = "InnerBuildProperties";
 
-        public static readonly string MultitargetingSpecification = $@"<PropertyGroup>
+        public static readonly string MultitargetingSpecificationPropertyGroup = $@"<PropertyGroup>
                                                                         <InnerBuildProperty>{InnerBuildPropertyName}</InnerBuildProperty>
-                                                                        <InnerBuildPropertyValues>InnerBuildProperties</InnerBuildPropertyValues>
-                                                                        <InnerBuildProperties>a;b</InnerBuildProperties>
+                                                                        <InnerBuildPropertyValues>{InnerBuildPropertiesName}</InnerBuildPropertyValues>
+                                                                        <{InnerBuildPropertiesName}>a;b</{InnerBuildPropertiesName}>
                                                                      </PropertyGroup>";
+        public static readonly string HardCodedInnerBuildWithMultitargetingSpecification = $@"<PropertyGroup>
+                                                                        <InnerBuildProperty>{InnerBuildPropertyName}</InnerBuildProperty>
+                                                                        <InnerBuildPropertyValues>{InnerBuildPropertiesName}</InnerBuildPropertyValues>
+                                                                        <{InnerBuildPropertyName}>a</{InnerBuildPropertyName}>
+                                                                     </PropertyGroup>";
+
+        public static readonly string EnableTransitiveProjectReferencesPropertyGroup = @"<PropertyGroup>
+                                                                                            <AddTransitiveProjectReferencesInStaticGraph>true</AddTransitiveProjectReferencesInStaticGraph>
+                                                                                         </PropertyGroup>";
 
         public static void AssertOuterBuildAsNonRoot(
             ProjectGraphNode outerBuild,
@@ -30,7 +41,7 @@ public static void AssertOuterBuildAsNonRoot(
             Dictionary<string, string> additionalGlobalProperties = null,
             int expectedInnerBuildCount = 2)
         {
-            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>();
 
             AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
 
@@ -54,7 +65,7 @@ public static void AssertOuterBuildAsNonRoot(
                     innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);
                     innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);
 
-                    graph.TestOnly_Edges.TestOnly_HasEdge((outerBuild, innerBuild)).ShouldBeFalse();
+                    graph.TestOnly_Edges.HasEdge((outerBuild, innerBuild)).ShouldBeFalse();
 
                     var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
                     var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
@@ -69,7 +80,7 @@ public static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary
             additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
 
             IsNotMultitargeting(node).ShouldBeTrue();
-            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
+            node.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
             node.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();
         }
 
@@ -81,7 +92,7 @@ public static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dicti
             IsInnerBuild(outerBuild).ShouldBeFalse();
 
             outerBuild.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();
-            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
         }
 
         public static void AssertInnerBuildEvaluation(
@@ -100,7 +111,7 @@ public static void AssertInnerBuildEvaluation(
 
             if (InnerBuildPropertyIsSetViaGlobalProperty)
             {
-                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(
+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(
                     EmptyGlobalProperties
                         .Add(InnerBuildPropertyName, innerBuildPropertyValue)
                         .AddRange(additionalGlobalProperties));
@@ -205,5 +216,37 @@ internal static TransientTestFile CreateProjectFile(
                 defaultTargets ?? "Build",
                 extraContent);
         }
+
+        internal static IEnumerable<ProjectGraphNode> ComputeClosure(ProjectGraphNode node)
+        {
+            return ComputeClosureRecursive(node).ToHashSet();
+
+            IEnumerable<ProjectGraphNode> ComputeClosureRecursive(ProjectGraphNode projectGraphNode)
+            {
+                foreach (var reference in projectGraphNode.ProjectReferences)
+                {
+                    yield return reference;
+
+                    foreach (var closureReference in ComputeClosureRecursive(reference))
+                    {
+                        yield return closureReference;
+                    }
+                }
+            }
+        }
+
+        internal static void AssertReferencesIgnoringOrder(this ProjectGraph graph, Dictionary<int, int[]> expectedReferencesForNode)
+        {
+            foreach (var kvp in expectedReferencesForNode)
+            {
+                var node = GetFirstNodeWithProjectNumber(graph, kvp.Key);
+                node.AssertReferencesIgnoringOrder(kvp.Value);
+            }
+        }
+
+        internal static void AssertReferencesIgnoringOrder(this ProjectGraphNode node, int[] expectedReferences)
+        {
+            node.ProjectReferences.Select(GetProjectNumber).ShouldBeSameIgnoringOrder(expectedReferences);
+        }
     }
 }
diff --git a/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs b/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
index 119edea8b05..234f6f3a47d 100644
--- a/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
+++ b/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
@@ -247,7 +247,7 @@ private void TestParallelWorkSet(ParallelWorkSetTestCase tt)
 
             _workSet.WaitForAllWorkAndComplete();
             _workSet.IsCompleted.ShouldBeTrue();
-            _workSet.CompletedWork.ShouldBeEquivalentTo((IReadOnlyCollection<KeyValuePair<string, string>>) tt.ExpectedCompletedWork);
+            _workSet.CompletedWork.ShouldBeSameIgnoringOrder((IReadOnlyCollection<KeyValuePair<string, string>>) tt.ExpectedCompletedWork);
         }
     }
 }
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 84edacaf9c7..7e7022e5622 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -33,7 +33,7 @@ public class ProjectGraphTests : IDisposable
         private static string[] NonOuterBuildTargets = {"AHelperOuter", "AHelperInner", "A"};
         private static string[] OuterBuildTargets = {"AHelperOuter"};
 
-        private static readonly string OuterBuildSpecificationWithProjectReferenceTargets = MultitargetingSpecification + ProjectReferenceTargetsWithMultitargeting;
+        private static readonly string OuterBuildSpecificationWithProjectReferenceTargets = MultitargetingSpecificationPropertyGroup + ProjectReferenceTargetsWithMultitargeting;
 
         public ProjectGraphTests(ITestOutputHelper outputHelper)
         {
@@ -114,13 +114,13 @@ public void UpdatingReferencesIsBidirectional()
                 node.AddProjectReference(reference1, referenceItem1, edges);
                 node.AddProjectReference(reference2, referenceItem2, edges);
 
-                node.ProjectReferences.ShouldBeEquivalentTo(new []{reference1, reference2});
+                node.ProjectReferences.ShouldBeSameIgnoringOrder(new []{reference1, reference2});
                 node.ReferencingProjects.ShouldBeEmpty();
 
-                reference1.ReferencingProjects.ShouldBeEquivalentTo(new[] {node});
+                reference1.ReferencingProjects.ShouldBeSameIgnoringOrder(new[] {node});
                 reference1.ProjectReferences.ShouldBeEmpty();
 
-                reference2.ReferencingProjects.ShouldBeEquivalentTo(new[] {node});
+                reference2.ReferencingProjects.ShouldBeSameIgnoringOrder(new[] {node});
                 reference2.ProjectReferences.ShouldBeEmpty();
 
                 edges[(node, reference1)].ShouldBe(referenceItem1);
@@ -336,16 +336,16 @@ public void ProjectCollectionShouldNotInfluenceGlobalProperties()
             var root1 = GetFirstNodeWithProjectNumber(graph, 1);
             var globalPropertiesFor1 = new Dictionary<string, string> { ["B"] = "EntryPointB", ["C"] = "EntryPointC", ["IsGraphBuild"] = "true" };
 
-            root1.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor1);
-            root1.ProjectReferences.First(r => GetProjectNumber(r) == 3).ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor1);
-            root1.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor1);
+            root1.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
+            root1.ProjectReferences.First(r => GetProjectNumber(r) == 3).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
+            root1.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
 
             var root2 = GetFirstNodeWithProjectNumber(graph, 2);
             var globalPropertiesFor2 = new Dictionary<string, string> { ["IsGraphBuild"] = "true" };
 
-            root2.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor2);
-            root2.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor2);
-            root2.ProjectReferences.First(r => GetProjectNumber(r) == 5).ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor2);
+            root2.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
+            root2.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
+            root2.ProjectReferences.First(r => GetProjectNumber(r) == 5).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
         }
 
         [Fact]
@@ -375,7 +375,7 @@ public void ConstructWithDifferentGlobalProperties()
                 // Projects 2 and 3 both reference project 4, but with different properties, so they should not point to the same node.
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ShouldNotBe(GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First());
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("4.proj");
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties);
                 GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("4.proj");
                 GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First().ProjectInstance.GlobalProperties.Count.ShouldBeGreaterThan(1);
             }
@@ -972,7 +972,7 @@ public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBui
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: "D1",
-                extraContent: MultitargetingSpecification +
+                extraContent: MultitargetingSpecificationPropertyGroup +
                               projectReferenceTargetsProtocol +
 $@"
 <ItemGroup>
@@ -998,7 +998,7 @@ public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBui
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: "D3",
-                extraContent: MultitargetingSpecification + projectReferenceTargetsProtocol);
+                extraContent: MultitargetingSpecificationPropertyGroup + projectReferenceTargetsProtocol);
 
             var graph = new ProjectGraph(entryProject);
 
@@ -1373,6 +1373,17 @@ public static IEnumerable<object[]> Graphs
                     }
                 };
 
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{4, 2}},
+                        {2, new []{3}},
+                        {3, new []{4}},
+                        {4, new []{5}}
+                    }
+                };
+
                 yield return new object[]
                 {
                     new Dictionary<int, int[]>
@@ -1394,6 +1405,19 @@ public static IEnumerable<object[]> Graphs
                     }
                 };
 
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{2, 4, 3, 5} },
+                        {2, new []{5} },
+                        {3, new []{5} },
+                        {4, new []{6} },
+                        {5, new []{7} },
+                        {6, new []{5} }
+                    },
+                };
+
                 yield return new object[]
                 {
                     new Dictionary<int, int[]>
@@ -1499,7 +1523,7 @@ private static void AssertOuterBuildAsRoot(
         [Fact]
         public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
         {
-            var projectFile = _env.CreateTestProjectWithFiles($@"<Project>{MultitargetingSpecification}</Project>").ProjectFile;
+            var projectFile = _env.CreateTestProjectWithFiles($@"<Project>{MultitargetingSpecificationPropertyGroup}</Project>").ProjectFile;
 
             var graph = new ProjectGraph(projectFile);
 
@@ -1525,7 +1549,7 @@ public void OuterBuildAsNonRootShouldNotReferenceInnerBuilds()
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: null,
-                extraContent: MultitargetingSpecification);
+                extraContent: MultitargetingSpecificationPropertyGroup);
 
 
             var graph = new ProjectGraph(entryProject);
@@ -1559,7 +1583,7 @@ public void InnerBuildsFromNonRootOuterBuildInheritEdgesToOuterBuild()
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: null,
-                extraContent: MultitargetingSpecification);
+                extraContent: MultitargetingSpecificationPropertyGroup);
 
 
             var graph = new ProjectGraph(entryProject);
@@ -1587,7 +1611,7 @@ public void InnerBuildsFromNonRootOuterBuildInheritEdgesToOuterBuild()
         public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
         {
             // multitarget to duplicate monikers
-            var multitargetingSpecification = MultitargetingSpecification +
+            var multitargetingSpecification = MultitargetingSpecificationPropertyGroup +
                                               @"<PropertyGroup>
                                                     <InnerBuildProperties>a;a</InnerBuildProperties>
                                                 </PropertyGroup>";
@@ -1611,7 +1635,7 @@ public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
         [Fact]
         public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGlobalProperties()
         {
-            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification).Path;
+            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
             CreateProjectFile(env: _env, projectNumber: 2);
 
             var graph = new ProjectGraph(root);
@@ -1630,7 +1654,7 @@ public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGl
         [Fact]
         public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildPropertyToReference()
         {
-            var innerBuildViaLocalProperty = MultitargetingSpecification + $"<PropertyGroup><{InnerBuildPropertyName}>foo</{InnerBuildPropertyName}></PropertyGroup>";
+            var innerBuildViaLocalProperty = MultitargetingSpecificationPropertyGroup + $"<PropertyGroup><{InnerBuildPropertyName}>foo</{InnerBuildPropertyName}></PropertyGroup>";
 
             var root = CreateProjectFile(
                 env: _env,
@@ -1658,7 +1682,7 @@ public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildProperty
         [Fact]
         public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropertyToReference()
         {
-            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification).Path;
+            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
             CreateProjectFile(env: _env, projectNumber: 2);
 
             var graph = new ProjectGraph(root, new Dictionary<string, string>{{InnerBuildPropertyName, "foo"}});
@@ -1677,10 +1701,10 @@ public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropert
         [Fact]
         public void NonMultitargetingProjectsAreCompatibleWithMultitargetingProjects()
         {
-            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2, 3}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification).Path;
+            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2, 3}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
             CreateProjectFile(env: _env, projectNumber: 2, projectReferences: new[] {4});
             CreateProjectFile(env: _env, projectNumber: 3, projectReferences: new[] {4});
-            CreateProjectFile(env: _env, projectNumber: 4, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification);
+            CreateProjectFile(env: _env, projectNumber: 4, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup);
 
             var graph = new ProjectGraph(root);
 
@@ -1698,15 +1722,15 @@ public void NonMultitargetingProjectsAreCompatibleWithMultitargetingProjects()
         [Fact]
         public void InnerBuildsCanHaveSeparateReferences()
         {
-            var extraInnerBuildReferenceSpec = MultitargetingSpecification +
+            var extraInnerBuildReferenceSpec = MultitargetingSpecificationPropertyGroup +
                                           $@"<ItemGroup>
                                                 <ProjectReference Condition=`'$({InnerBuildPropertyName})'=='b'` Include=`4.proj;5.proj`/>
                                             </ItemGroup>".Cleanup();
 
             var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2, 3}, projectReferenceTargets: null, defaultTargets: null, extraContent: extraInnerBuildReferenceSpec).Path;
-            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification);
+            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup);
             CreateProjectFile(env: _env, projectNumber: 3);
-            CreateProjectFile(env: _env, projectNumber: 4, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification);
+            CreateProjectFile(env: _env, projectNumber: 4, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup);
             CreateProjectFile(env: _env, projectNumber: 5);
 
             var graph = new ProjectGraph(root);
@@ -1726,13 +1750,13 @@ public void InnerBuildsCanHaveSeparateReferences()
 
             innerBuildWithCommonReferences.ProjectReferences.Count.ShouldBe(4);
             var referenceNumbersSet = innerBuildWithCommonReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstance.FullPath)).ToHashSet();
-            referenceNumbersSet.ShouldBeEquivalentTo(new HashSet<string>{"2", "3"});
+            referenceNumbersSet.ShouldBeSameIgnoringOrder(new HashSet<string>{"2", "3"});
 
             var innerBuildWithAdditionalReferences = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GlobalProperties.TryGetValue(InnerBuildPropertyName, out string p) && p == "b");
 
             innerBuildWithAdditionalReferences.ProjectReferences.Count.ShouldBe(8);
             referenceNumbersSet = innerBuildWithAdditionalReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstance.FullPath)).ToHashSet();
-            referenceNumbersSet.ShouldBeEquivalentTo(new HashSet<string>{"2", "3", "4", "5"});
+            referenceNumbersSet.ShouldBeSameIgnoringOrder(new HashSet<string>{"2", "3", "4", "5"});
         }
 
         [Fact]
@@ -1746,7 +1770,7 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
 
             var graph = new ProjectGraph(new []
             {
-                CreateProjectFile(env: _env, projectNumber: 1, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification).Path,
+                CreateProjectFile(env: _env, projectNumber: 1, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path,
                 CreateProjectFile(env: _env, projectNumber: 2, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: referenceToInnerBuild).Path
             },
             additionalGlobalProperties);
@@ -1767,7 +1791,7 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
             two.ProjectReferences.ShouldHaveSingleItem();
             two.ProjectReferences.First().ShouldBe(referencedInnerBuild);
 
-            referencedInnerBuild.ReferencingProjects.ShouldBeEquivalentTo(new []{two, outerBuild});
+            referencedInnerBuild.ReferencingProjects.ShouldBeSameIgnoringOrder(new []{two, outerBuild});
         }
 
         [Fact]
@@ -1778,7 +1802,7 @@ public void StandaloneInnerBuildsCanBeReferencedWithoutOuterBuilds()
                                            </ItemGroup>";
 
             var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: referenceToInnerBuild).Path;
-            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: new []{3}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification + $"<PropertyGroup><{InnerBuildPropertyName}>a</{InnerBuildPropertyName}></PropertyGroup>");
+            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: new []{3}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup + $"<PropertyGroup><{InnerBuildPropertyName}>a</{InnerBuildPropertyName}></PropertyGroup>");
             CreateProjectFile(env: _env, projectNumber: 3);
 
             var additionalGlobalProperties = new Dictionary<string, string>{{"x", "y"}};
@@ -1816,7 +1840,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: null,
-                extraContent: MultitargetingSpecification + referenceToInnerBuild)
+                extraContent: MultitargetingSpecificationPropertyGroup + referenceToInnerBuild)
                 .Path;
 
             CreateProjectFile(
@@ -1825,7 +1849,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: null,
-                extraContent: MultitargetingSpecification);
+                extraContent: MultitargetingSpecificationPropertyGroup);
 
             var graph = new ProjectGraph(new [] { root }, additionalGlobalProperties);
 
@@ -1852,7 +1876,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
             // the outer build is necessary as the referencing inner build can still call targets on it
             GetNodesWithProjectNumber(graph, 2).Count().ShouldBe(2);
 
-            innerBuild1WithReferenceToInnerBuild2.ProjectReferences.ShouldBeEquivalentTo(new []{outerBuild2, innerBuild2});
+            innerBuild1WithReferenceToInnerBuild2.ProjectReferences.ShouldBeSameIgnoringOrder(new []{outerBuild2, innerBuild2});
         }
 
         public static IEnumerable<object[]> AllNodesShouldHaveGraphBuildGlobalPropertyData
@@ -1953,7 +1977,7 @@ public void AllNodesShouldHaveGraphBuildGlobalProperty(Dictionary<int, int[]> ed
 
                 foreach (var node in projectGraph.ProjectNodes)
                 {
-                    node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(expectedGlobalProperties);
+                    node.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(expectedGlobalProperties);
                 }
             }
         }
@@ -1972,6 +1996,320 @@ public void UserValuesForIsGraphBuildGlobalPropertyShouldBePreserved()
             }
         }
 
+        [Theory]
+        [MemberData(nameof(Graphs))]
+        public void GraphShouldSupportTransitiveReferences(Dictionary<int, int[]> edges)
+        {
+            var graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: edges,
+                extraContentPerProjectNumber: null,
+                extraContentForAllNodes: EnableTransitiveProjectReferencesPropertyGroup
+                );
+
+            foreach (var node in graph.ProjectNodes)
+            {
+                var expectedClosure = ComputeClosure(node);
+
+                node.ProjectReferences.ShouldBeSameIgnoringOrder(expectedClosure);
+            }
+        }
+
+        public static IEnumerable<object[]> TransitiveReferencesAreDefinedPerProjectTestData
+        {
+            get
+            {
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3}},
+                        {2, new[] {3}},
+                        {3, new[] {4}}
+                    },
+                    new Dictionary<int, string>(),
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3}},
+                        {2, new[] {3}}
+                    }
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}},
+                        {2, new[] {3}},
+                        {3, new[] {4}}
+                    },
+                    new Dictionary<int, string>
+                    {
+                        {1, EnableTransitiveProjectReferencesPropertyGroup}
+                    },
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2, 3, 4}},
+                        {2, new[] {3}},
+                        {3, new[] {4}},
+                        {4, new int[0]}
+                    }
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3}},
+                        {2, new[] {3}},
+                        {3, new[] {4}}
+                    },
+                    new Dictionary<int, string>
+                    {
+                        {1, EnableTransitiveProjectReferencesPropertyGroup}
+                    },
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3, 4}},
+                        {2, new[] {3}}
+                    }
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3}},
+                        {2, new[] {3}},
+                        {3, new[] {4}}
+                    },
+                    new Dictionary<int, string>
+                    {
+                        {1, EnableTransitiveProjectReferencesPropertyGroup},
+                        {2, EnableTransitiveProjectReferencesPropertyGroup}
+                    },
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3, 4}},
+                        {2, new[] {3, 4}}
+                    }
+                };
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}},
+                        {2, new[] {3}},
+                        {3, new[] {4}},
+                        {4, new[] {5}},
+                        {5, new[] {6}}
+                    },
+                    new Dictionary<int, string>
+                    {
+                        {1, EnableTransitiveProjectReferencesPropertyGroup},
+                        {3, EnableTransitiveProjectReferencesPropertyGroup},
+                        {5, EnableTransitiveProjectReferencesPropertyGroup}
+                    },
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2, 3, 4, 5, 6}},
+                        {2, new[] {3}},
+                        {3, new[] {4, 5, 6}},
+                        {4, new[] {5}},
+                        {5, new[] {6}},
+                        {6, new int[0]},
+                    }
+                };
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(TransitiveReferencesAreDefinedPerProjectTestData))]
+        public void TransitiveReferencesAreDefinedPerProject(
+            Dictionary<int, int[]> edges,
+            Dictionary<int, string> extraContentPerProjectNumber,
+            Dictionary<int, int[]> expectedReferences
+            )
+        {
+            var graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: edges,
+                extraContentPerProjectNumber: extraContentPerProjectNumber
+            );
+
+            graph.AssertReferencesIgnoringOrder(expectedReferences);
+        }
+
+        [Fact]
+        public void TransitiveReferencesShouldNotBeAddedToOuterBuilds()
+        {
+            var graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: new Dictionary<int, int[]>
+                {
+                    {1, new []{3, 4} },
+                    {2, new []{3, 4} },
+                    {3, new []{4} },
+                    {4, new []{5} },
+                    {5, new []{6} }
+                },
+                extraContentPerProjectNumber: new Dictionary<int, string>
+                {
+                    {
+                        1,
+                        EnableTransitiveProjectReferencesPropertyGroup +
+                        MultitargetingSpecificationPropertyGroup
+                    },
+                    {
+                        2,
+                        EnableTransitiveProjectReferencesPropertyGroup +
+                        HardCodedInnerBuildWithMultitargetingSpecification
+                    },
+                    {
+                        4,
+                        EnableTransitiveProjectReferencesPropertyGroup +
+                        MultitargetingSpecificationPropertyGroup
+                    },
+                    {
+                        5,
+                        HardCodedInnerBuildWithMultitargetingSpecification
+                    },
+                    {
+                        6,
+                        MultitargetingSpecificationPropertyGroup
+                    }
+                }
+            );
+
+            GetOuterBuild(graph, 1).AssertReferencesIgnoringOrder(new []{1, 1});
+
+            var innerBuilds1 = GetInnerBuilds(graph, 1);
+            innerBuilds1.Count.ShouldBe(2);
+
+            foreach (var innerBuild in innerBuilds1)
+            {
+                innerBuild.AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
+            }
+
+            GetFirstNodeWithProjectNumber(graph, 2).AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
+
+            GetOuterBuild(graph, 4).AssertReferencesIgnoringOrder(new int[0]);
+
+            var innerBuilds4 = GetInnerBuilds(graph, 4);
+            innerBuilds4.Count.ShouldBe(2);
+
+            foreach (var innerBuild in innerBuilds4)
+            {
+                innerBuild.AssertReferencesIgnoringOrder(new []{5, 6, 6, 6});
+            }
+        }
+
+        [Fact]
+        public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
+        {
+            var graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: new Dictionary<int, int[]>()
+                {
+                    {1, new[] {2}},
+                    {2, new[] {3}}
+                },
+                extraContentPerProjectNumber: new Dictionary<int, string>()
+                {
+                    {
+                        1,
+                        $@"
+<PropertyGroup>
+    <{InnerBuildPropertiesName}>1A;1B</{InnerBuildPropertiesName}>
+</PropertyGroup>
+
+<ItemGroup>
+    <ProjectReference Update='@(ProjectReference)' Targets='1ATarget' Condition=`'$({InnerBuildPropertyName})' == '1A'` />
+    <ProjectReference Update='@(ProjectReference)' Targets='1BTarget' Condition=`'$({InnerBuildPropertyName})' == '1B'` />
+</ItemGroup>"
+                    },
+                    {
+                        2,
+                        $@"
+<PropertyGroup>
+    <{InnerBuildPropertiesName}>2A;2B</{InnerBuildPropertiesName}>
+</PropertyGroup>
+
+<ItemGroup>
+    <ProjectReference Update='@(ProjectReference)' Targets='2ATarget' Condition=`'$({InnerBuildPropertyName})' == '2A'` />
+    <ProjectReference Update='@(ProjectReference)' Targets='2BTarget' Condition=`'$({InnerBuildPropertyName})' == '2B'` />
+</ItemGroup>"
+                    },
+                    {
+                        3,
+                        $@"
+<PropertyGroup>
+    <{InnerBuildPropertiesName}>3A;3B</{InnerBuildPropertiesName}>
+</PropertyGroup>"
+                    }
+                },
+                extraContentForAllNodes: @$"
+<PropertyGroup>
+    <{ProjectInterpretation.AddTransitiveProjectReferencesInStaticGraphPropertyName}>true</{ProjectInterpretation.AddTransitiveProjectReferencesInStaticGraphPropertyName}>
+</PropertyGroup>
+
+<PropertyGroup>
+    <InnerBuildProperty>{InnerBuildPropertyName}</InnerBuildProperty>
+    <InnerBuildPropertyValues>{InnerBuildPropertiesName}</InnerBuildPropertyValues>
+</PropertyGroup>
+
+<ItemGroup>
+    <ProjectReferenceTargets Include='Build' Targets='Build;{MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker}' />
+    <ProjectReferenceTargets Include='Build' Targets='BuildForOuterBuild' OuterBuild='true' />
+</ItemGroup>");
+
+            var targetLists = graph.GetTargetLists(new[] {"Build"});
+
+            var outerBuild1 = GetOuterBuild(graph, 1);
+            targetLists[outerBuild1].ShouldBe(new[] {"Build"});
+
+            AssertOuterBuildAsRoot(outerBuild1, graph, expectedInnerBuildCount: 2);
+
+            var innerBuildsFor1 = GetInnerBuilds(graph, 1);
+            innerBuildsFor1.Count.ShouldBe(2);
+
+            foreach (var inner1 in innerBuildsFor1)
+            {
+                // Outer build targets are added to inner builds because 
+                targetLists[inner1].ShouldBe(new[] {"BuildForOuterBuild", "Build"});
+            }
+
+            var outerBuild2 = GetOuterBuild(graph, 2);
+            targetLists[outerBuild2].ShouldBe(new[] {"BuildForOuterBuild"});
+            AssertOuterBuildAsNonRoot(outerBuild2, graph, expectedInnerBuildCount: 2);
+
+            var innerBuildsFor2 = GetInnerBuilds(graph, 2);
+            innerBuildsFor2.Count.ShouldBe(2);
+
+            foreach (var inner2 in innerBuildsFor2)
+            {
+                targetLists[inner2].ShouldBe(new[] {"BuildForOuterBuild", "Build", "1ATarget", "1BTarget"});
+            }
+
+            var outerBuild3 = GetOuterBuild(graph, 3);
+            targetLists[outerBuild3].ShouldBe(new[] { "BuildForOuterBuild" });
+
+            outerBuild3.ReferencingProjects.Count.ShouldBe(4);
+
+            AssertOuterBuildAsNonRoot(outerBuild3, graph, expectedInnerBuildCount: 2);
+            var innerBuildsFor3 = GetInnerBuilds(graph, 3);
+            innerBuildsFor3.Count.ShouldBe(2);
+
+            foreach (var inner3 in innerBuildsFor3)
+            {
+                inner3.ReferencingProjects.Count.ShouldBe(4);
+
+                // 3 does not get called with 1ATarget or 1BTarget because those apply only to direct references
+                targetLists[inner3]
+                    .ShouldBe(new[] { "BuildForOuterBuild", "Build", "2ATarget", "2BTarget" });
+            }
+        }
+
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
index 88a009211a3..1611340705b 100644
--- a/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.OM.Instance
 {
diff --git a/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
index ab9d4e89982..1f8544a3eb4 100644
--- a/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.OM.Instance
 {
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 24110272103..e387e719ad6 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Framework;
 using System.IO;
 using Xunit;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.OM.Instance
 {
diff --git a/src/Build.UnitTests/InternalEngineHelpers.cs b/src/Build.UnitTests/InternalEngineHelpers.cs
index 74717d25628..833539345c7 100644
--- a/src/Build.UnitTests/InternalEngineHelpers.cs
+++ b/src/Build.UnitTests/InternalEngineHelpers.cs
@@ -68,11 +68,60 @@ public override Framework.SdkResult Resolve(SdkReference sdkReference, SdkResolv
                 ResolvedCalls.AddOrUpdate(sdkReference.Name, k => 1, (k, c) => c + 1);
 
                 return _resultMap.TryGetValue(sdkReference.Name, out var result)
-                    ? new SdkResult(sdkReference, result.Path, result.Version, null)
+                    ? CloneSdkResult(result)
                     : null;
             }
 
+            private SdkResult CloneSdkResult(SdkResult sdkResult)
+            {
+                if (!sdkResult.Success)
+                {
+                    return new SdkResult(sdkResult.SdkReference, sdkResult.Warnings, sdkResult.Errors);
+                }
+
+                IEnumerable<string> sdkResultPaths;
+                if (sdkResult.Path == null)
+                {
+                    sdkResultPaths = Enumerable.Empty<string>();
+                }
+                else
+                {
+                    List<string> pathList = new List<string>();
+                    pathList.Add(sdkResult.Path);
+                    if (sdkResult.AdditionalPaths != null)
+                    {
+                        pathList.AddRange(sdkResult.AdditionalPaths);
+                    }
+                    sdkResultPaths = pathList;
+                }
 
+                Dictionary<string, SdkResultItem> sdkResultItems;
+
+                if (sdkResult.ItemsToAdd == null)
+                {
+                    sdkResultItems = null;
+                }
+                else
+                {
+                    sdkResultItems = new Dictionary<string, SdkResultItem>(StringComparer.OrdinalIgnoreCase);
+                    foreach (var item in sdkResult.ItemsToAdd)
+                    {
+                        Dictionary<string, string> newMetadata = null;
+                        if (item.Value.Metadata != null)
+                        {
+                            newMetadata = new Dictionary<string, string>(item.Value.Metadata, StringComparer.OrdinalIgnoreCase);
+                        }
+                        sdkResultItems.Add(item.Key, new SdkResultItem(item.Value.ItemSpec, newMetadata));
+                    }
+                }
+
+                return new SdkResult(sdkResult.SdkReference,
+                                     sdkResultPaths,
+                                     version: sdkResult.Version,
+                                     sdkResult.PropertiesToAdd == null ? null : new Dictionary<string, string>(sdkResult.PropertiesToAdd, StringComparer.OrdinalIgnoreCase),
+                                     sdkResultItems,
+                                     sdkResult.Warnings);
+            }
         }
 
         internal class FileBasedMockSdkResolver : SdkResolver
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 5806db2d3e6..c36a51b66b8 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -11,12 +11,17 @@
     
     <!-- Define a constant so we can skip tests that require MSBuildTaskHost -->
     <DefineConstants Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(MonoBuild)' == 'true'">$(DefineConstants);NO_MSBUILDTASKHOST</DefineConstants>
+
+    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
   </PropertyGroup>
 
   <ItemGroup>
     <PackageReference Include="System.Collections.Concurrent" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
+    <PackageReference Include="NuGet.Frameworks" >
+      <PrivateAssets>all</PrivateAssets>
+    </PackageReference>
 
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
diff --git a/src/Build.UnitTests/OpportunisticIntern_Tests.cs b/src/Build.UnitTests/OpportunisticIntern_Tests.cs
index cae14b38b49..fd7f70ba885 100644
--- a/src/Build.UnitTests/OpportunisticIntern_Tests.cs
+++ b/src/Build.UnitTests/OpportunisticIntern_Tests.cs
@@ -7,12 +7,25 @@
 using Microsoft.Build;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
 {
-    public class OpportunisticIntern_Tests
+    public abstract class OpportunisticInternTestBase : IDisposable
     {
-        private static bool IsInternable(OpportunisticIntern.IInternable internable)
+        protected TestEnvironment _env;
+
+        public void Dispose()
+        {
+            _env.Dispose();
+        }
+
+        protected OpportunisticInternTestBase(ITestOutputHelper testOutput)
+        {
+            _env = TestEnvironment.Create(testOutput);
+        }
+
+        private static bool IsInternable(IInternable internable)
         {
             string i1 = OpportunisticIntern.InternableToString(internable);
             string i2 = OpportunisticIntern.InternableToString(internable);
@@ -20,19 +33,19 @@ private static bool IsInternable(OpportunisticIntern.IInternable internable)
             return Object.ReferenceEquals(i1, i2);
         }
 
-        private static void AssertInternable(OpportunisticIntern.IInternable internable)
+        private static void AssertInternable(IInternable internable)
         {
             Assert.True(IsInternable(internable));
         }
 
         private static void AssertInternable(StringBuilder sb)
         {
-            AssertInternable(new OpportunisticIntern.StringBuilderInternTarget(sb));
+            AssertInternable(new StringBuilderInternTarget(sb));
         }
 
         private static string AssertInternable(char[] ch, int startIndex, int count)
         {
-            var target = new OpportunisticIntern.CharArrayInternTarget(ch, startIndex, count);
+            var target = new CharArrayInternTarget(ch, startIndex, count);
             AssertInternable(target);
             Assert.Equal(target.Length, count);
 
@@ -45,22 +58,22 @@ private static void AssertInternable(string value)
             AssertInternable(value.ToCharArray(), 0, value.ToCharArray().Length);
         }
 
-        private static void AssertNotInternable(OpportunisticIntern.IInternable internable)
+        private static void AssertNotInternable(IInternable internable)
         {
             Assert.False(IsInternable(internable));
         }
 
         private static void AssertNotInternable(StringBuilder sb)
         {
-            AssertNotInternable(new OpportunisticIntern.StringBuilderInternTarget(sb));
+            AssertNotInternable(new StringBuilderInternTarget(sb));
         }
 
         private static void AssertNotInternable(char[] ch)
         {
-            AssertNotInternable(new OpportunisticIntern.CharArrayInternTarget(ch, ch.Length));
+            AssertNotInternable(new CharArrayInternTarget(ch, ch.Length));
         }
 
-        private static void AssertNotInternable(string value)
+        protected static void AssertNotInternable(string value)
         {
             AssertNotInternable(new StringBuilder(value));
             AssertNotInternable(value.ToCharArray());
@@ -88,24 +101,6 @@ public void SubArray2()
             Assert.Equal("true", result);
         }
 
-        /// <summary>
-        /// Test a single know-to-intern tiny string to verify the mechanism.
-        /// </summary>
-        [Fact]
-        public void InternableTinyString()
-        {
-            AssertInternable("true");
-        }
-
-        /// <summary>
-        /// Test a single known-to-not-intern tiny string to verify the mechanism.
-        /// </summary>
-        [Fact]
-        public void NonInternableTinyString()
-        {
-            AssertNotInternable("1234");
-        }
-
         /// <summary>
         /// Unique strings should not be interned
         /// </summary>
@@ -173,4 +168,52 @@ public void DoubleDoubleQuotes()
             AssertInternable("");
         }
     }
+
+    /// <summary>
+    /// Tests the new (default) implementation of OpportunisticIntern.
+    /// </summary>
+    public class OpportunisticIntern_Tests : OpportunisticInternTestBase
+    {
+        public OpportunisticIntern_Tests(ITestOutputHelper testOutput)
+            : base(testOutput)
+        {
+            OpportunisticIntern.ResetForTests();
+        }
+    }
+
+    /// <summary>
+    /// Tests the legacy implementation of OpportunisticIntern.
+    /// </summary>
+    public class OpportunisticInternLegacy_Tests : OpportunisticInternTestBase
+    {
+        public OpportunisticInternLegacy_Tests(ITestOutputHelper testOutput)
+            : base(testOutput)
+        {
+            _env.SetEnvironmentVariable("MSBuildUseLegacyStringInterner", "1");
+            OpportunisticIntern.ResetForTests();
+        }
+
+        /// <summary>
+        /// The legacy implementation does not intern tiny strings unless they are on the hard-coded list.
+        /// </summary>
+        [Fact]
+        public void NonInternableTinyString()
+        {
+            AssertNotInternable("1234");
+        }
+    }
+
+    /// <summary>
+    /// Tests the legacy implementation of OpportunisticIntern with simple concurrency enabled.
+    /// </summary>
+    public class OpportunisticInternLegacySimpleConcurrecy_Tests : OpportunisticInternTestBase
+    {
+        public OpportunisticInternLegacySimpleConcurrecy_Tests(ITestOutputHelper testOutput)
+            : base(testOutput)
+        {
+            _env.SetEnvironmentVariable("MSBuildUseLegacyStringInterner", "1");
+            _env.SetEnvironmentVariable("MSBuildUseSimpleInternConcurrency", "1");
+            OpportunisticIntern.ResetForTests();
+        }
+    }
 }
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index 0c8aa4a2da8..6cde0e901df 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -4,7 +4,9 @@
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.UnitTests;
+using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.Engine.UnitTests
 {
@@ -13,6 +15,13 @@ public sealed class WarningsAsMessagesAndErrorsTests
         private const string ExpectedEventMessage = "03767942CDB147B98D0ECDBDE1436DA3";
         private const string ExpectedEventCode = "0BF68998";
 
+        ITestOutputHelper _output;
+
+        public WarningsAsMessagesAndErrorsTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
         [Fact]
         public void TreatAllWarningsAsErrors()
         {
@@ -29,7 +38,7 @@ public void TreatAllWarningsAsErrors()
         [Fact]
         public void TreatWarningsAsErrorsWhenBuildingSameProjectMultipleTimes()
         {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            using (TestEnvironment testEnvironment = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles project2 = testEnvironment.CreateTestProjectWithFiles($@"
                 <Project xmlns=""msbuildnamespace"">
@@ -123,7 +132,7 @@ public void TreatWarningsAsMessagesWhenSpecified()
         [Fact]
         public void TreatWarningsAsMessagesWhenBuildingSameProjectMultipleTimes()
         {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            using (TestEnvironment testEnvironment = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles project2 = testEnvironment.CreateTestProjectWithFiles($@"
                 <Project xmlns=""msbuildnamespace"">
@@ -263,5 +272,111 @@ private string GetTestProject(bool? treatAllWarningsAsErrors = null, string warn
                 </Target>
             </Project>";
         }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.AssertLogContains("MSB4181");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""WarnAndContinue""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+
+                logger.WarningCount.ShouldBe(1);
+
+                logger.AssertLogContains("MSB4181");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""true""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+
+                logger.AssertLogContains("MSB4181");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_ErrorAndStop()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""ErrorAndStop""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.AssertLogContains("MSB4181");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_False()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""false""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.AssertLogContains("MSB4181");
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/WeakStringCache_Tests.cs b/src/Build.UnitTests/WeakStringCache_Tests.cs
new file mode 100644
index 00000000000..ece79899fd0
--- /dev/null
+++ b/src/Build.UnitTests/WeakStringCache_Tests.cs
@@ -0,0 +1,185 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Linq;
+using System.Runtime.CompilerServices;
+using System.Text;
+
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class WeakStringCache_Tests : IDisposable
+    {
+        /// <summary>
+        /// The weak string cache under test.
+        /// </summary>
+        private WeakStringCache _cache = new WeakStringCache();
+
+        public void Dispose()
+        {
+            _cache.Dispose();
+        }
+
+        /// <summary>
+        /// Adds a string to the cache under test.
+        /// </summary>
+        /// <param name="strPart1">Part one of the string (split to prevent runtime interning and unintended GC roots).</param>
+        /// <param name="strPart2">Part two of the string (split to prevent runtime interning and unintended GC roots).</param>
+        /// <param name="callbackToRunWithTheStringAlive">Callback to be invoked after the string has been added but before the strong GC ref is released.</param>
+        /// <returns>The hash code of the string as calculated by WeakStringCache.</returns>
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        private int AddString(string strPart1, string strPart2, Action<string> callbackToRunWithTheStringAlive)
+        {
+            // Compose the string with SB so it doesn't get interned by the runtime.
+            string testString = new StringBuilder(strPart1).Append(strPart2).ToString();
+            StringInternTarget testStringTarget = new StringInternTarget(testString);
+
+            int hashCode = WeakStringCache.GetInternableHashCode(testStringTarget);
+
+            string cachedString = _cache.GetOrCreateEntry(testStringTarget, out bool cacheHit);
+            cacheHit.ShouldBeFalse();
+            cachedString.ShouldBeSameAs(testString);
+
+            callbackToRunWithTheStringAlive(cachedString);
+
+            // Verify that the string is really in the cache and the cache returns the interned instance.
+            string testStringCopy = new StringBuilder(strPart1).Append(strPart2).ToString();
+            cachedString = _cache.GetOrCreateEntry(new StringInternTarget(testStringCopy), out cacheHit);
+            cacheHit.ShouldBeTrue();
+            cachedString.ShouldBeSameAs(testString);
+
+            // Trigger full GC and verify that nothing has changed since we're still keeping testString alive.
+            GC.Collect();
+
+            callbackToRunWithTheStringAlive(cachedString);
+
+            cachedString = _cache.GetOrCreateEntry(new StringInternTarget(testStringCopy), out cacheHit);
+            cacheHit.ShouldBeTrue();
+            cachedString.ShouldBeSameAs(testString);
+
+            return hashCode;
+        }
+
+        /// <summary>
+        /// Adds strings that are known to have a hash code collision to the cache under test.
+        /// </summary>
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        private void AddStringsWithSameHashCode(int numberOfStrings)
+        {
+            string[] cachedStrings = new string[numberOfStrings];
+            int[] hashCodes = new int[numberOfStrings];
+
+            for (int i = 0; i < numberOfStrings; i++)
+            {
+                string strPart2 = "1" + String.Concat(Enumerable.Repeat("4428939786", i));
+                hashCodes[i] = AddString("Random string ", strPart2, (string cachedString) =>
+                {
+                    _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+                    {
+                        LiveStringCount = 1,
+                        CollectedStringCount = 0,
+                    });
+                    cachedStrings[i] = cachedString;
+                });
+
+                if (i > 0)
+                {
+                    // The strings have been carefully constructed to have the same hash code.
+                    hashCodes[i].ShouldBe(hashCodes[i - 1]);
+                }
+            }
+
+            // There are no cache hits when iterating over our strings again because the last one always wins and steals the slot.
+            for (int i = 0; i < numberOfStrings; i++)
+            {
+                StringBuilder sb = new StringBuilder(cachedStrings[i]);
+                string cachedStringFromCache =_cache.GetOrCreateEntry(new StringBuilderInternTarget(sb), out bool cacheHit);
+                cacheHit.ShouldBeFalse();
+                cachedStringFromCache.ShouldNotBeSameAs(cachedStrings[i]);
+            }
+        }
+
+        /// <summary>
+        /// Simple test case to verify that:
+        /// 1. A string added to the cache stays in the cache as long as it's alive.
+        /// 2. The string is no longer retrievable after all strong GC refs are gone.
+        /// 3. The cache completely removes the handle after calling Scavenge on it.
+        /// </summary>
+        /// <remarks>
+        /// Disabled on MacOS Mono because it doesn't play well with conservative GC scanning.
+        /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
+        /// </remarks>
+        [Fact]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "doesn't play well with conservative GC scanning")]
+        public void RetainsStringUntilCollected()
+        {
+            // Add a string to the cache using a non-inlinable method to make sure it's not reachable from a GC root.
+            AddString("Random string ", "test", (string cachedString) =>
+            {
+                _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+                {
+                    LiveStringCount = 1,
+                    CollectedStringCount = 0,
+                });
+            });
+
+            // Trigger full GC.
+            GC.Collect();
+
+            // The handle is still in the cache but it's unused now as the string has been collected.
+            _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+            {
+                LiveStringCount = 0,
+                CollectedStringCount = 1,
+            });
+
+            // Ask the cache to get rid of unused handles.
+            _cache.Scavenge();
+
+            // The cache should be empty now.
+            _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+            {
+                LiveStringCount = 0,
+                CollectedStringCount = 0,
+            });
+        }
+
+        /// <summary>
+        /// Same as RetainsStringUntilCollected but with multiple strings sharing the same hash code.
+        /// </summary>
+        /// <remarks>
+        /// Disabled on MacOS Mono because it doesn't play well with conservative GC scanning.
+        /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
+        /// </remarks>
+        [Fact]
+        [Trait("Category", "mono-osx-failing")]
+        public void RetainsLastStringWithGivenHashCode()
+        {
+            // Add 3 strings with the same hash code.
+            AddStringsWithSameHashCode(3);
+
+            // Trigger full GC.
+            GC.Collect();
+
+            // The handle is still in the cache but it's unused now as the strings have been collected.
+            _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+            {
+                LiveStringCount = 0,
+                CollectedStringCount = 1,
+            });
+
+            // Ask the cache to get rid of unused handles.
+            _cache.Scavenge();
+
+            // The cache should be empty now.
+            _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+            {
+                LiveStringCount = 0,
+                CollectedStringCount = 0,
+            });
+        }
+    }
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index b2157cf4e07..9f435bb36ba 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -406,7 +406,7 @@ public void BeginBuild(BuildParameters parameters)
 
                 if (BuildParameters.DumpOpportunisticInternStats)
                 {
-                    OpportunisticIntern.EnableStatisticsGathering();
+                    OpportunisticIntern.Instance.EnableStatisticsGathering();
                 }
 
                 _overallBuildSuccess = true;
@@ -824,7 +824,7 @@ public void EndBuild()
 
                     if (BuildParameters.DumpOpportunisticInternStats)
                     {
-                        OpportunisticIntern.ReportStatistics();
+                        OpportunisticIntern.Instance.ReportStatistics();
                     }
                 }
             }
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 090cb82acf9..b86d476910f 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -318,6 +318,12 @@ public bool UseSynchronousLogging
             set => _useSynchronousLogging = value;
         }
 
+
+        /// <summary>
+        /// Indicates whether to emit a default error if a task returns false without logging an error.
+        /// </summary>
+        public bool AllowFailureWithoutError { get; set; } = true;
+
         /// <summary>
         /// Gets the environment variables which were set when this build was created.
         /// </summary>
diff --git a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
index e0e300403cf..1df6a64b42b 100644
--- a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
+++ b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
@@ -44,12 +44,12 @@ private static IDictionary<string, List<string>> CreateItemMetadataDictionary(in
             return new Dictionary<string, List<string>>(capacity, StringComparer.OrdinalIgnoreCase);
         }
 
-        private static void TranslateMetadataForItem(ref List<string> list, ITranslator translator)
+        private static void TranslateMetadataForItem(ITranslator translator, ref List<string> list)
         {
             translator.Translate(ref list);
         }
 
-        private static void TranslateString(ref string s, ITranslator translator)
+        private static void TranslateString(ITranslator translator, ref string s)
         {
             translator.Translate(ref s);
         }
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index b6989894a6b..2645a3feba6 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -348,8 +348,8 @@ public void Translate(ITranslator translator)
         {
             translator.TranslateDictionary(
                 ref _configurations,
-                (ref int configId, ITranslator aTranslator) => aTranslator.Translate(ref configId),
-                (ref BuildRequestConfiguration configuration, ITranslator aTranslator) =>
+                (ITranslator aTranslator, ref int configId) => aTranslator.Translate(ref configId),
+                (ITranslator aTranslator, ref BuildRequestConfiguration configuration) =>
                 {
                     if (translator.Mode == TranslationDirection.WriteToStream)
                     {
@@ -365,8 +365,8 @@ public void Translate(ITranslator translator)
 
             translator.TranslateDictionary(
                 ref _configurationIdsByMetadata,
-                (ref ConfigurationMetadata configMetadata, ITranslator aTranslator) => aTranslator.Translate(ref configMetadata, ConfigurationMetadata.FactoryForDeserialization),
-                (ref int configId, ITranslator aTranslator) => aTranslator.Translate(ref configId),
+                (ITranslator aTranslator, ref ConfigurationMetadata configMetadata) => aTranslator.Translate(ref configMetadata, ConfigurationMetadata.FactoryForDeserialization),
+                (ITranslator aTranslator, ref int configId) => aTranslator.Translate(ref configId),
                 capacity => new Dictionary<ConfigurationMetadata, int>(capacity));
         }
 
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 36e1a24824e..64db389a8ed 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -243,8 +243,8 @@ public void Translate(ITranslator translator)
 
             translator.TranslateDictionary(
                 ref localReference,
-                (ref int i, ITranslator aTranslator) => aTranslator.Translate(ref i),
-                (ref BuildResult result, ITranslator aTranslator) => aTranslator.Translate(ref result),
+                (ITranslator aTranslator, ref int i) => aTranslator.Translate(ref i),
+                (ITranslator aTranslator, ref BuildResult result) => aTranslator.Translate(ref result),
                 capacity => new ConcurrentDictionary<int, BuildResult>(Environment.ProcessorCount, capacity));
 
             if (translator.Mode == TranslationDirection.ReadFromStream)
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 20660afd183..a1b4c7ae411 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -77,7 +77,7 @@ protected override long GetHostHandshake()
         /// </summary>
         protected override long GetClientHandshake()
         {
-            return NodeProviderOutOfProc.GetClientHandshake();
+            return NodeProviderOutOfProc.GetClientHandshake(_enableReuse, _lowPriority);
         }
 
         #region Structs
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index e7048a57870..e94c194e33d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -3,26 +3,18 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
-using System.Text;
-using System.IO;
-using System.IO.Pipes;
 using System.Diagnostics;
-using System.Threading;
-using System.Runtime.InteropServices;
-using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.AccessControl;
 #endif
-using System.Security.Principal;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -80,27 +72,17 @@ public int AvailableNodes
         /// <param name="enableLowPriority">Is the build running at low priority?</param>
         internal static long GetHostHandshake(bool enableNodeReuse, bool enableLowPriority)
         {
-            long baseHandshake = Constants.AssemblyTimestamp;
-
-            baseHandshake = baseHandshake*17 + EnvironmentUtilities.Is64BitProcess.GetHashCode();
-
-            baseHandshake = baseHandshake*17 + enableNodeReuse.GetHashCode();
-
-            baseHandshake = baseHandshake*17 + enableLowPriority.GetHashCode();
-
-            return CommunicationsUtilities.GenerateHostHandshakeFromBase(baseHandshake, GetClientHandshake());
+            CommunicationsUtilities.Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", enableNodeReuse={2}, enableLowPriority={3}", Traits.MSBuildNodeHandshakeSalt, BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, enableNodeReuse, enableLowPriority);
+            return CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
         }
 
         /// <summary>
         /// Magic number sent by the client to the host during the handshake.
         /// Munged version of the host handshake.
         /// </summary>
-        internal static long GetClientHandshake()
+        internal static long GetClientHandshake(bool enableNodeReuse, bool enableLowPriority)
         {
-            // Mask out the first byte. That's because old
-            // builds used a single, non zero initial byte,
-            // and we don't want to risk communicating with them
-            return (Constants.AssemblyTimestamp ^ Int64.MaxValue) & 0x00FFFFFFFFFFFFFF;
+            return CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetHandshakeOptions(false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
         }
 
         /// <summary>
@@ -126,7 +108,7 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
             CommunicationsUtilities.Trace("Starting to acquire a new or existing node to establish node ID {0}...", nodeId);
 
             long hostHandShake = NodeProviderOutOfProc.GetHostHandshake(ComponentHost.BuildParameters.EnableNodeReuse, ComponentHost.BuildParameters.LowPriority);
-            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandShake, NodeProviderOutOfProc.GetClientHandshake(), NodeContextTerminated);
+            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandShake, NodeProviderOutOfProc.GetClientHandshake(ComponentHost.BuildParameters.EnableNodeReuse, ComponentHost.BuildParameters.LowPriority), NodeContextTerminated);
 
             if (null != context)
             {
@@ -188,11 +170,7 @@ public void ShutdownAllNodes()
             // down all the nodes on exit, we will attempt to shutdown
             // all matching nodes with and without the priority bit set.
             // This means we need both versions of the handshake.
-            ShutdownAllNodes(
-                NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: false),
-                NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: true),
-                NodeProviderOutOfProc.GetClientHandshake(),
-                NodeContextTerminated);
+            ShutdownAllNodes(nodeReuse, NodeContextTerminated);
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 898c3f432fe..cc8507b4645 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -106,7 +106,7 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool
         /// <param name="hostHandshakeWithLowPriority">host handshake key with low priority added</param>
         /// <param name="clientHandshake">client handshake key</param>
         /// <param name="terminateNode">Delegate used to tell the node provider that a context has terminated</param>
-        protected void ShutdownAllNodes(long hostHandshake, long hostHandshakeWithLowPriority, long clientHandshake, NodeContextTerminateDelegate terminateNode)
+        protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate terminateNode)
         {
             // INodePacketFactory
             INodePacketFactory factory = new NodePacketFactory();
@@ -126,12 +126,12 @@ protected void ShutdownAllNodes(long hostHandshake, long hostHandshakeWithLowPri
                 int timeout = 30;
 
                 // Attempt to connect to the process with the handshake without low priority.
-                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, hostHandshake, clientHandshake);
+                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHostHandshake(nodeReuse, false), NodeProviderOutOfProc.GetClientHandshake(nodeReuse, false));
 
                 if (null == nodeStream)
                 {
                     // If we couldn't connect attempt to connect to the process with the handshake including low priority.
-                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, hostHandshakeWithLowPriority, clientHandshake);
+                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHostHandshake(nodeReuse, true), NodeProviderOutOfProc.GetClientHandshake(nodeReuse, true));
                 }
 
                 if (null != nodeStream)
@@ -356,7 +356,7 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHand
                 nodeStream.WriteLongForHandshake(hostHandshake);
 
                 CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
                 long handshake = nodeStream.ReadLongForHandshake(timeout);
 #else
                 long handshake = nodeStream.ReadLongForHandshake();
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 2ec94b46b8a..e0aebf0ade8 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -90,7 +90,7 @@ internal class NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase, INodeP
         /// <summary>
         /// A mapping of all the nodes managed by this provider.
         /// </summary>
-        private Dictionary<TaskHostContext, NodeContext> _nodeContexts;
+        private Dictionary<HandshakeOptions, NodeContext> _nodeContexts;
 
         /// <summary>
         /// A mapping of all of the INodePacketFactories wrapped by this provider.
@@ -186,7 +186,7 @@ public void SendData(int nodeId, INodePacket packet)
         /// </summary>
         /// <param name="hostContext">The node to which data shall be sent.</param>
         /// <param name="packet">The packet to send.</param>
-        public void SendData(TaskHostContext hostContext, INodePacket packet)
+        public void SendData(HandshakeOptions hostContext, INodePacket packet)
         {
             ErrorUtilities.VerifyThrow(_nodeContexts.ContainsKey(hostContext), "Invalid host context specified: {0}.", hostContext.ToString());
 
@@ -226,11 +226,7 @@ public void ShutdownAllNodes()
             long hostHandshake = NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: false);
             long hostHandshakeWithLow = NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: true);
 
-            ShutdownAllNodes(
-                hostHandshake,
-                hostHandshakeWithLow,
-                NodeProviderOutOfProc.GetClientHandshake(),
-                NodeContextTerminated);
+            ShutdownAllNodes(nodeReuse, NodeContextTerminated);
         }
         #endregion
 
@@ -243,7 +239,7 @@ public void ShutdownAllNodes()
         public void InitializeComponent(IBuildComponentHost host)
         {
             this.ComponentHost = host;
-            _nodeContexts = new Dictionary<TaskHostContext, NodeContext>();
+            _nodeContexts = new Dictionary<HandshakeOptions, NodeContext>();
             _nodeIdToPacketFactory = new Dictionary<int, INodePacketFactory>();
             _nodeIdToPacketHandler = new Dictionary<int, INodePacketHandler>();
             _activeNodes = new HashSet<int>();
@@ -388,9 +384,13 @@ internal static void ClearCachedTaskHostPaths()
         /// <summary>
         /// Given a TaskHostContext, returns the name of the executable we should be searching for.
         /// </summary>
-        internal static string GetTaskHostNameFromHostContext(TaskHostContext hostContext)
+        internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostContext)
         {
-            if (hostContext == TaskHostContext.X64CLR4 || hostContext == TaskHostContext.X32CLR4)
+            ErrorUtilities.VerifyThrowInternalErrorUnreachable((hostContext & HandshakeOptions.TaskHost) == HandshakeOptions.TaskHost);
+            if ((hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2) {
+                return TaskHostNameForClr2TaskHost;
+            }
+            else
             {
                 if (s_msbuildName == null)
                 {
@@ -404,15 +404,6 @@ internal static string GetTaskHostNameFromHostContext(TaskHostContext hostContex
 
                 return s_msbuildName;
             }
-            else if (hostContext == TaskHostContext.X32CLR2 || hostContext == TaskHostContext.X64CLR2)
-            {
-                return TaskHostNameForClr2TaskHost;
-            }
-            else
-            {
-                ErrorUtilities.ThrowInternalErrorUnreachable();
-                return null;
-            }
         }
 
         /// <summary>
@@ -420,60 +411,59 @@ internal static string GetTaskHostNameFromHostContext(TaskHostContext hostContex
         /// executable (MSBuild or MSBuildTaskHost) that we wish to use, or null
         /// if that location cannot be resolved.
         /// </summary>
-        internal static string GetMSBuildLocationFromHostContext(TaskHostContext hostContext)
+        internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostContext)
         {
             string toolName = GetTaskHostNameFromHostContext(hostContext);
-            string toolPath = null;
+            string toolPath;
 
             s_baseTaskHostPath = BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
             s_baseTaskHostPath64 = BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64;
+            ErrorUtilities.VerifyThrowInternalErrorUnreachable((hostContext & HandshakeOptions.TaskHost) == HandshakeOptions.TaskHost);
 
-            switch (hostContext)
+            if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64 && (hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
             {
-                case TaskHostContext.X32CLR2:
-                    if (s_pathToX32Clr2 == null)
-                    {
-                        s_pathToX32Clr2 = Environment.GetEnvironmentVariable("MSBUILDTASKHOSTLOCATION");
-                        if (s_pathToX32Clr2 == null || !FileUtilities.FileExistsNoThrow(Path.Combine(s_pathToX32Clr2, toolName)))
-                        {
-                            s_pathToX32Clr2 = s_baseTaskHostPath;
-                        }
-                    }
+                if (s_pathToX64Clr2 == null)
+                {
+                    s_pathToX64Clr2 = Environment.GetEnvironmentVariable("MSBUILDTASKHOSTLOCATION64");
 
-                    toolPath = s_pathToX32Clr2;
-                    break;
-                case TaskHostContext.X64CLR2:
-                    if (s_pathToX64Clr2 == null)
+                    if (s_pathToX64Clr2 == null || !FileUtilities.FileExistsNoThrow(Path.Combine(s_pathToX64Clr2, toolName)))
                     {
-                        s_pathToX64Clr2 = Environment.GetEnvironmentVariable("MSBUILDTASKHOSTLOCATION64");
-
-                        if (s_pathToX64Clr2 == null || !FileUtilities.FileExistsNoThrow(Path.Combine(s_pathToX64Clr2, toolName)))
-                        {
-                            s_pathToX64Clr2 = s_baseTaskHostPath64;
-                        }
+                        s_pathToX64Clr2 = s_baseTaskHostPath64;
                     }
+                }
 
-                    toolPath = s_pathToX64Clr2;
-                    break;
-                case TaskHostContext.X32CLR4:
-                    if (s_pathToX32Clr4 == null)
+                toolPath = s_pathToX64Clr2;
+            }
+            else if ((hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
+            {
+                if (s_pathToX32Clr2 == null)
+                {
+                    s_pathToX32Clr2 = Environment.GetEnvironmentVariable("MSBUILDTASKHOSTLOCATION");
+                    if (s_pathToX32Clr2 == null || !FileUtilities.FileExistsNoThrow(Path.Combine(s_pathToX32Clr2, toolName)))
                     {
-                        s_pathToX32Clr4 = s_baseTaskHostPath;
+                        s_pathToX32Clr2 = s_baseTaskHostPath;
                     }
+                }
 
-                    toolPath = s_pathToX32Clr4;
-                    break;
-                case TaskHostContext.X64CLR4:
-                    if (s_pathToX64Clr4 == null)
-                    {
-                        s_pathToX64Clr4 = s_baseTaskHostPath64;
-                    }
+                toolPath = s_pathToX32Clr2;
+            }
+            else if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64)
+            {
+                if (s_pathToX64Clr4 == null)
+                {
+                    s_pathToX64Clr4 = s_baseTaskHostPath64;
+                }
+
+                toolPath = s_pathToX64Clr4;
+            }
+            else
+            {
+                if (s_pathToX32Clr4 == null)
+                {
+                    s_pathToX32Clr4 = s_baseTaskHostPath;
+                }
 
-                    toolPath = s_pathToX64Clr4;
-                    break;
-                default:
-                    ErrorUtilities.ThrowInternalErrorUnreachable();
-                    break;
+                toolPath = s_pathToX32Clr4;
             }
 
             if (toolName != null && toolPath != null)
@@ -487,7 +477,7 @@ internal static string GetMSBuildLocationFromHostContext(TaskHostContext hostCon
         /// <summary>
         /// Make sure a node in the requested context exists.
         /// </summary>
-        internal bool AcquireAndSetUpHost(TaskHostContext hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
+        internal bool AcquireAndSetUpHost(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
             NodeContext context = null;
             bool nodeCreationSucceeded = false;
@@ -519,7 +509,7 @@ internal bool AcquireAndSetUpHost(TaskHostContext hostContext, INodePacketFactor
         /// <summary>
         /// Expected to be called when TaskHostTask is done with host of the given context.
         /// </summary>
-        internal void DisconnectFromHost(TaskHostContext hostContext)
+        internal void DisconnectFromHost(HandshakeOptions hostContext)
         {
             ErrorUtilities.VerifyThrow(_nodeIdToPacketFactory.ContainsKey((int)hostContext) && _nodeIdToPacketHandler.ContainsKey((int)hostContext), "Why are we trying to disconnect from a context that we already disconnected from?  Did we call DisconnectFromHost twice?");
 
@@ -530,7 +520,7 @@ internal void DisconnectFromHost(TaskHostContext hostContext)
         /// <summary>
         /// Instantiates a new MSBuild or MSBuildTaskHost process acting as a child node.
         /// </summary>
-        internal bool CreateNode(TaskHostContext hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
+        internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
             ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
             ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context!  Did we forget to call DisconnectFromHost somewhere?");
@@ -590,7 +580,7 @@ private void NodeContextTerminated(int nodeId)
         {
             lock (_nodeContexts)
             {
-                _nodeContexts.Remove((TaskHostContext)nodeId);
+                _nodeContexts.Remove((HandshakeOptions)nodeId);
             }
 
             // May also be removed by unnatural termination, so don't assume it's there
diff --git a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
index 49f31354b1c..888ba5a557c 100644
--- a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
@@ -65,6 +65,7 @@ internal void LogFatalTaskError(Exception exception, BuildEventFileInfo file, st
         {
             ErrorUtilities.VerifyThrow(IsValid, "must be valid");
             LoggingService.LogFatalTaskError(BuildEventContext, exception, file, taskName);
+            _hasLoggedErrors = true;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 51edfe927d6..2ba4ef2be8c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -28,6 +28,8 @@ internal class LoggingContext
         /// </summary>
         private bool _isValid;
 
+        protected bool _hasLoggedErrors;
+
         /// <summary>
         /// Constructs the logging context from a logging service and an event context.
         /// </summary>
@@ -41,6 +43,7 @@ public LoggingContext(ILoggingService loggingService, BuildEventContext eventCon
             _loggingService = loggingService;
             _eventContext = eventContext;
             _isValid = false;
+            _hasLoggedErrors = false;
         }
 
         /// <summary>
@@ -106,6 +109,8 @@ protected set
             }
         }
 
+        internal bool HasLoggedErrors { get { return _hasLoggedErrors; } set { _hasLoggedErrors = value; } }
+
         /// <summary>
         ///  Helper method to create a message build event from a string resource and some parameters
         /// </summary>
@@ -139,6 +144,7 @@ internal void LogError(BuildEventFileInfo file, string messageResourceName, para
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogError(_eventContext, file, messageResourceName, messageArgs);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -152,6 +158,7 @@ internal void LogErrorWithSubcategory(string subcategoryResourceName, BuildEvent
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogError(_eventContext, subcategoryResourceName, file, messageResourceName, messageArgs);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -166,6 +173,7 @@ internal void LogErrorFromText(string subcategoryResourceName, string errorCode,
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogErrorFromText(_eventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -176,6 +184,7 @@ internal void LogInvalidProjectFileError(InvalidProjectFileException invalidProj
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogInvalidProjectFileError(_eventContext, invalidProjectFileException);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -189,6 +198,7 @@ internal void LogFatalError(Exception exception, BuildEventFileInfo file, string
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogFatalError(_eventContext, exception, file, messageResourceName, messageArgs);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -237,6 +247,7 @@ internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file)
         {
             ErrorUtilities.VerifyThrow(IsValid, "must be valid");
             LoggingService.LogFatalBuildError(BuildEventContext, exception, file);
+            _hasLoggedErrors = true;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 35d669162f1..f528cadbfaf 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -220,7 +220,8 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
                     ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix,
                     child.ItemType,
-                    itemsToAdd);
+                    itemsToAdd,
+                    logItemMetadata: true);
                 LoggingContext.LogCommentFromText(MessageImportance.Low, itemGroupText);
             }
 
@@ -261,7 +262,8 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
                         ItemGroupLoggingHelper.ItemGroupRemoveLogMessage,
                         child.ItemType,
-                        itemsToRemove);
+                        itemsToRemove,
+                        logItemMetadata: true);
                     LoggingContext.LogCommentFromText(MessageImportance.Low, itemGroupText);
                 }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index 848c183ebb4..84eaa27f0e7 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -27,14 +27,6 @@ internal static class ItemGroupLoggingHelper
         /// </summary>
         internal static int parameterLimit = 200;
 
-        /// <summary>
-        /// Gets a text serialized value of a parameter for logging.
-        /// </summary>
-        internal static string GetParameterText(string prefix, string parameterName, params object[] parameterValues)
-        {
-            return GetParameterText(prefix, parameterName, (IList)parameterValues);
-        }
-
         internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString("ItemGroupIncludeLogMessagePrefix");
         internal static string ItemGroupRemoveLogMessage = ResourceUtilities.GetResourceString("ItemGroupRemoveLogMessage");
         internal static string OutputItemParameterMessagePrefix = ResourceUtilities.GetResourceString("OutputItemParameterMessagePrefix");
@@ -43,7 +35,7 @@ internal static string GetParameterText(string prefix, string parameterName, par
         /// <summary>
         /// Gets a text serialized value of a parameter for logging.
         /// </summary>
-        internal static string GetParameterText(string prefix, string parameterName, IList parameterValue)
+        internal static string GetParameterText(string prefix, string parameterName, IList parameterValue, bool logItemMetadata = true)
         {
             if (parameterValue == null || parameterValue.Count == 0)
             {
@@ -94,7 +86,7 @@ internal static string GetParameterText(string prefix, string parameterName, ILi
                         sb.Append("        ");
                     }
 
-                    AppendStringFromParameterValue(sb, parameterValue[i]);
+                    AppendStringFromParameterValue(sb, parameterValue[i], logItemMetadata);
 
                     if (!specialTreatmentForSingle && i < parameterValue.Count - 1)
                     {
@@ -118,7 +110,7 @@ internal static string GetParameterText(string prefix, string parameterName, ILi
         /// First line is already indented.
         /// Indent of any subsequent line should be 12 spaces.
         /// </summary>
-        internal static string GetStringFromParameterValue(object parameterValue)
+        internal static string GetStringFromParameterValue(object parameterValue, bool logItemMetadata = true)
         {
             // fast path for the common case
             if (parameterValue is string valueText)
@@ -128,7 +120,7 @@ internal static string GetStringFromParameterValue(object parameterValue)
 
             using (var sb = new ReuseableStringBuilder())
             {
-                AppendStringFromParameterValue(sb, parameterValue);
+                AppendStringFromParameterValue(sb, parameterValue, logItemMetadata);
                 return sb.ToString();
             }
         }
@@ -138,7 +130,7 @@ internal static string GetStringFromParameterValue(object parameterValue)
         [ThreadStatic]
         private static List<KeyValuePair<string, string>> keyValuePairList;
 
-        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue)
+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue, bool logItemMetadata = true)
         {
             if (parameterValue is string text)
             {
@@ -148,6 +140,11 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob
             {
                 sb.Append(item.ItemSpec);
 
+                if (!logItemMetadata)
+                {
+                    return;
+                }
+
                 var customMetadata = item.CloneCustomMetadata();
                 int count = customMetadata.Count;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 4cca645d906..c34edb8c8e7 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -1081,7 +1081,7 @@ private async Task<BuildResult> BuildProject()
 
             if (MSBuildEventSource.Log.IsEnabled())
             {
-                MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath, allTargets.Aggregate((f, s) => f + ", " + s));
+                MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath, string.Join(", ", allTargets));
             }
 
             return result;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index bd9849a4217..2a9dfd95217 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -324,12 +324,6 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 // Loop through each of the batch buckets and execute them one at a time
                 for (int i = 0; i < buckets.Count; i++)
                 {
-                    // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
-                    if (MSBuildEventSource.Log.IsEnabled())
-                    {
-                        TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
-                        MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-                    }
                     // Execute the batch bucket, pass in which bucket we are executing so that we know when to get a new taskId for the bucket.
                     taskResult = await ExecuteBucket(taskHost, (ItemBucket)buckets[i], mode, lookupHash);
 
@@ -339,12 +333,6 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                     {
                         break;
                     }
-                    // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
-                    if (MSBuildEventSource.Log.IsEnabled())
-                    {
-                        TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
-                        MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-                    }
                 }
 
                 taskResult = aggregateResult;
@@ -400,6 +388,13 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 return taskResult;
             }
 
+            // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
+            if (MSBuildEventSource.Log.IsEnabled())
+            {
+                TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
+            }
+
             // If this is an Intrinsic task, it gets handled in a special fashion.
             if (_taskNode == null)
             {
@@ -507,6 +502,13 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 }
             }
 
+            // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
+            if (MSBuildEventSource.Log.IsEnabled())
+            {
+                TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
+            }
+
             return taskResult;
         }
 
@@ -763,6 +765,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     if (taskType == typeof(MSBuild))
                     {
                         MSBuild msbuildTask = host.TaskInstance as MSBuild;
+
                         ErrorUtilities.VerifyThrow(msbuildTask != null, "Unexpected MSBuild internal task.");
 
                         var undeclaredProjects = GetUndeclaredProjects(msbuildTask);
@@ -940,6 +943,29 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     }
                 }
 
+                // When a task fails it must log an error. If a task fails to do so,
+                // that is logged as an error. MSBuild tasks are an exception because
+                // errors are not logged directly from them, but the tasks spawned by them.
+                IBuildEngine be = host.TaskInstance.BuildEngine;
+                if (taskReturned && !taskResult && !taskLoggingContext.HasLoggedErrors && (be is TaskHost th ? th.BuildRequestsSucceeded : false) && (be is IBuildEngine7 be7 ? be7.AllowFailureWithoutError : true))
+                {
+                    if (_continueOnError == ContinueOnError.WarnAndContinue)
+                    {
+                        taskLoggingContext.LogWarning(null,
+                            new BuildEventFileInfo(_targetChildInstance.Location),
+                            "TaskReturnedFalseButDidNotLogError",
+                            _taskNode.Name);
+
+                        taskLoggingContext.LogComment(MessageImportance.Normal, "ErrorConvertedIntoWarning");
+                    }
+                    else
+                    {
+                        taskLoggingContext.LogError(new BuildEventFileInfo(_targetChildInstance.Location),
+                            "TaskReturnedFalseButDidNotLogError",
+                            _taskNode.Name);
+                    }
+                }
+
                 // If the task returned attempt to gather its outputs.  If gathering outputs fails set the taskResults
                 // to false
                 if (taskReturned)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 884a150edd2..1e591e8ce29 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -38,7 +38,7 @@ internal class TaskHost :
         IBuildEngine7
     {
         /// <summary>
-        /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set. 
+        /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set.
         /// </summary>
         private static bool s_onlyUseOutOfProcNodes = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
 
@@ -132,7 +132,7 @@ public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, Elemen
         /// Returns true in the multiproc case
         /// </summary>
         /// <comment>
-        /// If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.  
+        /// If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.
         /// </comment>
         public bool IsRunningMultipleNodes
         {
@@ -321,7 +321,7 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
         #region IBuildEngine3 Members
 
         /// <summary>
-        /// Builds multiple project files in parallel. 
+        /// Builds multiple project files in parallel.
         /// Thread safe.
         /// </summary>
         /// <param name="projectFileNames">The list of projects to build</param>
@@ -329,7 +329,7 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
         /// <param name="globalProperties">The global properties to use for each project</param>
         /// <param name="undefineProperties">The list of global properties to undefine</param>
         /// <param name="toolsVersion">The tools versions to use</param>
-        /// <param name="returnTargetOutputs">Should the target outputs be returned in teh BuildEngineResult</param>
+        /// <param name="returnTargetOutputs">Should the target outputs be returned in the BuildEngineResult</param>
         /// <returns>A structure containing the result of the build, success or failure and the list of target outputs per project</returns>
         public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs)
         {
@@ -413,8 +413,8 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -423,7 +423,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
 
                 if (_convertErrorsToWarnings)
                 {
-                    // Convert the error into a warning.  We do this because the whole point of 
+                    // Convert the error into a warning.  We do this because the whole point of
                     // ContinueOnError is that a project author expects that the task might fail,
                     // but wants to ignore the failures.  This implies that we shouldn't be logging
                     // errors either, because you should never have a successful build with errors.
@@ -451,6 +451,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                 {
                     e.BuildEventContext = _taskLoggingContext.BuildEventContext;
                     _taskLoggingContext.LoggingService.LogBuildEvent(e);
+                    _taskLoggingContext.HasLoggedErrors = true;
                 }
             }
         }
@@ -483,8 +484,8 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -524,8 +525,8 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -565,8 +566,8 @@ public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -675,6 +676,8 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
 
         #endregion
 
+        #region IBuildEngine7 Members
+
         int runningTotal = 0;
 
         public int RequestCores(int requestedCores)
@@ -719,6 +722,12 @@ internal void ReleaseAllCores()
             runningTotal = 0;
         }
 
+        /// <summary>
+        /// Enables or disables emitting a default error when a task fails without logging errors
+        /// </summary>
+        public bool AllowFailureWithoutError { get; set; } = true;
+        #endregion
+
         /// <summary>
         /// Called by the internal MSBuild task.
         /// Does not take the lock because it is called by another request builder thread.
@@ -768,7 +777,7 @@ public async Task<BuildEngineResult> InternalBuildProjects(string[] projectFileN
 #if FEATURE_APPDOMAIN
         /// <inheritdoc />
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         /// <returns>The lease object to control this object's lifetime.</returns>
@@ -783,7 +792,7 @@ public override object InitializeLifetimeService()
                 ILease lease = (ILease)base.InitializeLifetimeService();
 
                 // Set how long a lease should be initially. Once a lease expires
-                // the remote object will be disconnected and it will be marked as being availiable 
+                // the remote object will be disconnected and it will be marked as being availiable
                 // for garbage collection
                 int initialLeaseTime = 1;
 
@@ -805,7 +814,7 @@ public override object InitializeLifetimeService()
                 // increase the lease time allowing the object to stay in memory
                 _sponsor = new ClientSponsor();
 
-                // When a new lease is requested lets make it last 1 minutes longer. 
+                // When a new lease is requested lets make it last 1 minutes longer.
                 int leaseExtensionTime = 1;
 
                 string leaseExtensionTimeFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDENGINEPROXYLEASEEXTENSIONTIME");
@@ -842,7 +851,7 @@ internal void MarkAsInactive()
                 ReleaseAllCores();
 
                 // Since the task has a pointer to this class it may store it in a static field. Null out
-                // internal data so the leak of this object doesn't lead to a major memory leak.            
+                // internal data so the leak of this object doesn't lead to a major memory leak.
                 _host = null;
                 _requestEntry = null;
 
@@ -892,7 +901,7 @@ internal bool IsEventSerializable(BuildEventArgs e)
         /// <param name="globalProperties">The global properties to use for each project</param>
         /// <param name="undefineProperties">The list of global properties to undefine</param>
         /// <param name="toolsVersion">The tools versions to use</param>
-        /// <param name="returnTargetOutputs">Should the target outputs be returned in teh BuildEngineResult</param>
+        /// <param name="returnTargetOutputs">Should the target outputs be returned in the BuildEngineResult</param>
         /// <param name="skipNonexistentTargets">If set, skip targets that are not defined in the projects to be built.</param>
         /// <returns>A Task returning a structure containing the result of the build, success or failure and the list of target outputs per project</returns>
         private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets = false)
@@ -933,7 +942,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                 }
                 else
                 {
-                    // UNDONE: (Refactor) Investigate making this a ReadOnly collection of some sort.  
+                    // UNDONE: (Refactor) Investigate making this a ReadOnly collection of some sort.
                     PropertyDictionary<ProjectPropertyInstance>[] propertyDictionaries = new PropertyDictionary<ProjectPropertyInstance>[projectFileNames.Length];
 
                     for (int i = 0; i < projectFileNames.Length; i++)
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 096ea1c4d84..37c708c8d14 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -58,6 +58,12 @@ public static IBuildComponent CreateComponent(BuildComponentType type)
             return new MainNodeSdkResolverService();
         }
 
+        //  Test hook
+        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<SdkResolver> resolvers = null)
+        {
+            ((CachingSdkResolverService)_cachedSdkResolver).InitializeForTests(resolverLoader, resolvers);
+        }
+
         /// <inheritdoc cref="ISdkResolverService.ClearCache"/>
         public override void ClearCache(int submissionId)
         {
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 36c1f8d2696..3d1813a7727 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -69,7 +69,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                 key =>
                 {
                     var result = RequestSdkPathFromMainNode(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive);
-                    return new SdkResult(null, result.Path, result.Version, null);
+                    return result;
                 });
 
             if (sdkResult.Version != null && !SdkResolverService.IsReferenceSameVersion(sdk, sdkResult.Version))
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
index 7df27e04020..3ab79ea3fbc 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
@@ -1,8 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
+using System;
 using System.Collections.Generic;
-
+using System.Linq;
+using System.Runtime.Versioning;
 using SdkReference = Microsoft.Build.Framework.SdkReference;
 using SdkResultBase = Microsoft.Build.Framework.SdkResult;
 
@@ -13,9 +16,6 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// </summary>
     internal sealed class SdkResult : SdkResultBase, INodePacket
     {
-        private string _path;
-        private string _version;
-
         public SdkResult(ITranslator translator)
         {
             Translate(translator);
@@ -33,30 +33,62 @@ public SdkResult(SdkReference sdkReference, string path, string version, IEnumer
         {
             Success = true;
             SdkReference = sdkReference;
-            _path = path;
-            _version = version;
+            Path = path;
+            Version = version;
             Warnings = warnings;
         }
 
         public SdkResult()
         {
+
         }
 
-        public Construction.ElementLocation ElementLocation { get; set; }
+        public SdkResult(SdkReference sdkReference, IEnumerable<string> paths, string version, IDictionary<string, string> propertiesToAdd,
+                         IDictionary<string, SdkResultItem> itemsToAdd, IEnumerable<string> warnings)
+        {
+            Success = true;
+            SdkReference = sdkReference;
+            if (paths != null)
+            {
+                var firstPath = paths.FirstOrDefault();
+                if (firstPath != null)
+                {
+                    Path = firstPath;
+                }
+                if (paths.Count() > 1)
+                {
+                    AdditionalPaths = paths.Skip(1).ToList();
+                }
+            }
 
-        public IEnumerable<string> Errors { get; }
+            Version = version;
 
-        public override string Path => _path;
+            //  Note: these dictionaries should use StringComparison.OrdinalIgnoreCase
+            PropertiesToAdd = propertiesToAdd;
+            ItemsToAdd = itemsToAdd;
 
-        public override SdkReference SdkReference { get; protected set; }
+            Warnings = warnings;
+        }
 
-        public override string Version => _version;
+        public Construction.ElementLocation ElementLocation { get; set; }
+
+        public IEnumerable<string> Errors { get; }
 
         public IEnumerable<string> Warnings { get; }
         public void Translate(ITranslator translator)
         {
+            translator.Translate(ref _success);
             translator.Translate(ref _path);
             translator.Translate(ref _version);
+
+            translator.Translate(ref _additionalPaths, (ITranslator t, ref string s) => t.Translate(ref s), count => new List<string>(count));
+            translator.TranslateDictionary(ref _propertiesToAdd, count => new Dictionary<string, string>(count, StringComparer.OrdinalIgnoreCase));
+            translator.TranslateDictionary(ref _itemsToAdd,
+                                           keyTranslator: (ITranslator t, ref string s) => t.Translate(ref s),
+                                           valueTranslator: SdkResultTranslationHelpers.Translate,
+                                           dictionaryCreator: count => new Dictionary<string, SdkResultItem>(count, StringComparer.OrdinalIgnoreCase));
+
+            translator.Translate(ref _sdkReference);
         }
 
         public NodePacketType Type => NodePacketType.ResolveSdkResponse;
@@ -65,5 +97,91 @@ public static INodePacket FactoryForDeserialization(ITranslator translator)
         {
             return new SdkResult(translator);
         }
+
+        public override bool Equals(object obj)
+        {
+            if (obj is SdkResult result &&
+                  _success == result._success &&
+                  StringComparer.OrdinalIgnoreCase.Equals(_path, result._path) &&
+                  StringComparer.OrdinalIgnoreCase.Equals(_version, result._version) &&
+                  _additionalPaths?.Count == result._additionalPaths?.Count &&
+                  _propertiesToAdd?.Count == result._propertiesToAdd?.Count &&
+                  _itemsToAdd?.Count == result._propertiesToAdd?.Count &&
+                  EqualityComparer<SdkReference>.Default.Equals(_sdkReference, result._sdkReference))
+            {
+                if (_additionalPaths != null)
+                {
+                    for (int i = 0; i < _additionalPaths.Count; i++)
+                    {
+                        if (!_additionalPaths[i].Equals(result._additionalPaths[i], StringComparison.OrdinalIgnoreCase))
+                        {
+                            return false;
+                        }
+                    }
+                }
+
+                if (_propertiesToAdd != null)
+                {
+                    foreach (var propertyToAdd in _propertiesToAdd)
+                    {
+                        if (result._propertiesToAdd[propertyToAdd.Key] != propertyToAdd.Value)
+                        {
+                            return false;
+                        }
+                    }
+                }
+
+                if (_itemsToAdd != null)
+                {
+                    foreach (var itemToAdd in _itemsToAdd)
+                    {
+                        if (!result._itemsToAdd[itemToAdd.Key].Equals(itemToAdd.Value))
+                        {
+                            return false;
+                        }
+                    }
+                }
+
+                return true;
+            }
+
+
+            return false;
+        }
+
+        public override int GetHashCode()
+        {
+            int hashCode = -1043047289;
+            hashCode = hashCode * -1521134295 + _success.GetHashCode();
+            hashCode = hashCode * -1521134295 + StringComparer.OrdinalIgnoreCase.GetHashCode(_path);
+            hashCode = hashCode * -1521134295 + StringComparer.OrdinalIgnoreCase.GetHashCode(_version);
+            hashCode = hashCode * -1521134295 + EqualityComparer<SdkReference>.Default.GetHashCode(_sdkReference);
+
+            if (_additionalPaths != null)
+            {
+                foreach (var additionalPath in _additionalPaths)
+                {
+                    hashCode = hashCode * -1521134295 + StringComparer.OrdinalIgnoreCase.GetHashCode(additionalPath);
+                }
+            }
+            if (_propertiesToAdd != null)
+            {
+                foreach (var propertyToAdd in _propertiesToAdd)
+                {
+                    hashCode = hashCode * -1521134295 + propertyToAdd.Key.GetHashCode();
+                    hashCode = hashCode * -1521134295 + propertyToAdd.Value.GetHashCode();
+                }
+            }
+            if (_itemsToAdd != null)
+            {
+                foreach (var itemToAdd in _itemsToAdd)
+                {
+                    hashCode = hashCode * -1521134295 + itemToAdd.Key.GetHashCode();
+                    hashCode = hashCode * -1521134295 + itemToAdd.Value.GetHashCode();
+                }
+            }
+
+            return hashCode;
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
index 1cb4360a9e1..7e4f0d898b6 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using System.Collections.Generic;
 
 using SdkReference = Microsoft.Build.Framework.SdkReference;
@@ -30,5 +31,14 @@ public override SdkResultBase IndicateSuccess(string path, string version, IEnum
         {
             return new SdkResult(_sdkReference, path, version, warnings);
         }
+
+        public override SdkResultBase IndicateSuccess(IEnumerable<string> paths,
+                                                      string version,
+                                                      IDictionary<string, string> propertiesToAdd = null,
+                                                      IDictionary<string, SdkResultItem> itemsToAdd = null,
+                                                      IEnumerable<string> warnings = null)
+        {
+            return new SdkResult(_sdkReference, paths, version, propertiesToAdd, itemsToAdd, warnings);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/TranslationHelpers.cs b/src/Build/BackEnd/Components/SdkResolution/TranslationHelpers.cs
new file mode 100644
index 00000000000..2a518c1b9e2
--- /dev/null
+++ b/src/Build/BackEnd/Components/SdkResolution/TranslationHelpers.cs
@@ -0,0 +1,55 @@
+﻿using Microsoft.Build.Framework;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.BackEnd.SdkResolution
+{
+    static class SdkResultTranslationHelpers
+    {
+        public static void Translate(this ITranslator t, ref SdkReference sdkReference)
+        {
+            string name = null;
+            string version = null;
+            string minimumVersion = null;
+
+            if (t.Mode == TranslationDirection.WriteToStream)
+            {
+                name = sdkReference.Name;
+                version = sdkReference.Version;
+                minimumVersion = sdkReference.MinimumVersion;
+            }
+
+            t.Translate(ref name);
+            t.Translate(ref version);
+            t.Translate(ref minimumVersion);
+
+            if (t.Mode == TranslationDirection.ReadFromStream)
+            {
+                sdkReference = new SdkReference(name, version, minimumVersion);
+            }
+        }
+
+        public static void Translate(this ITranslator t, ref SdkResultItem item)
+        {
+            string itemSpec = null;
+            Dictionary<string, string> metadata = null;
+
+            if (t.Mode == TranslationDirection.WriteToStream)
+            {
+                itemSpec = item.ItemSpec;
+                metadata = item.Metadata;
+            }
+
+            t.Translate(ref itemSpec);
+            t.TranslateDictionary(ref metadata, StringComparer.InvariantCultureIgnoreCase);
+
+            if (t.Mode == TranslationDirection.ReadFromStream)
+            {
+                item = new SdkResultItem(itemSpec, metadata);
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index f53958658e0..d7bddbdc133 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -425,13 +425,7 @@ private void OnEngineException(Exception e)
         /// </summary>
         private NodeEngineShutdownReason HandleShutdown(out Exception exception)
         {
-            if (_debugCommunications)
-            {
-                using (StreamWriter writer = File.CreateText(String.Format(CultureInfo.CurrentCulture, Path.Combine(Path.GetTempPath(), @"MSBuild_NodeShutdown_{0}.txt"), Process.GetCurrentProcess().Id)))
-                {
-                    writer.WriteLine("Node shutting down with reason {0} and exception: {1}", _shutdownReason, _shutdownException);
-                }
-            }
+            CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}.", _shutdownReason, _shutdownException);
 
             // Clean up the engine
             if (null != _buildRequestEngine && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
@@ -515,6 +509,8 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
                 CleanupCaches();
             }
 
+            CommunicationsUtilities.Trace("Shut down complete.");
+
             return _shutdownReason;
         }
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 4fd9e940ac1..81183622bb9 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -427,15 +427,17 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                 // grab the outputs from the task's designated output parameter (which is a .NET property)
                 Type type = parameter.PropertyType;
 
+                EnsureParameterInitialized(parameter, _batchBucket.Lookup);
+
                 if (TaskParameterTypeVerifier.IsAssignableToITask(type))
                 {
                     ITaskItem[] outputs = GetItemOutputs(parameter);
-                    GatherTaskItemOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation);
+                    GatherTaskItemOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation, parameter);
                 }
                 else if (TaskParameterTypeVerifier.IsValueTypeOutputParameter(type))
                 {
                     string[] outputs = GetValueOutputs(parameter);
-                    GatherArrayStringAndValueOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation);
+                    GatherArrayStringAndValueOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation, parameter);
                 }
                 else
                 {
@@ -1042,6 +1044,8 @@ out bool parameterSet
                 {
                     Type parameterType = parameter.PropertyType;
 
+                    EnsureParameterInitialized(parameter, _batchBucket.Lookup);
+
                     // try to set the parameter
                     if (TaskParameterTypeVerifier.IsValidScalarInputParameter(parameterType))
                     {
@@ -1222,6 +1226,29 @@ ex is FormatException || // bad string representation of a type
             return success;
         }
 
+        private void EnsureParameterInitialized(TaskPropertyInfo parameter, Lookup lookup)
+        {
+            if (parameter.Initialized)
+            {
+                return;
+            }
+
+            parameter.Initialized = true;
+
+            string taskAndParameterName = _taskName + "_" + parameter.Name;
+            string key = "DisableLogTaskParameter_" + taskAndParameterName;
+            string metadataKey = "DisableLogTaskParameterItemMetadata_" + taskAndParameterName;
+
+            if (string.Equals(lookup.GetProperty(key)?.EvaluatedValue, "true", StringComparison.OrdinalIgnoreCase))
+            {
+                parameter.Log = false;
+            }
+            else if (string.Equals(lookup.GetProperty(metadataKey)?.EvaluatedValue, "true", StringComparison.OrdinalIgnoreCase))
+            {
+                parameter.LogItemMetadata = false;
+            }
+        }
+
         /// <summary>
         /// Given an instantiated task, this helper method sets the specified vector parameter. Vector parameters can be composed
         /// of multiple item vectors. The semicolon is the only separator allowed, and white space around the semicolon is
@@ -1283,12 +1310,16 @@ out bool taskParameterSet
         /// </remarks>
         private bool InternalSetTaskParameter(TaskPropertyInfo parameter, IList parameterValue)
         {
-            if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && parameterValue.Count > 0)
+            if (LogTaskInputs &&
+                !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents &&
+                parameterValue.Count > 0 &&
+                parameter.Log)
             {
                 string parameterText = ItemGroupLoggingHelper.GetParameterText(
                     ItemGroupLoggingHelper.TaskParameterPrefix,
                     parameter.Name,
-                    parameterValue);
+                    parameterValue,
+                    parameter.LogItemMetadata);
                 _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
             }
 
@@ -1370,7 +1401,7 @@ object parameterValue
         /// <summary>
         /// Gets task item outputs
         /// </summary>
-        private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetName, ITaskItem[] outputs, ElementLocation parameterLocation)
+        private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetName, ITaskItem[] outputs, ElementLocation parameterLocation, TaskPropertyInfo parameter)
         {
             // if the task has generated outputs (if it didn't, don't do anything)
             if (outputs != null)
@@ -1425,12 +1456,13 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                         }
                     }
 
-                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0)
+                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0 && parameter.Log)
                     {
                         string parameterText = ItemGroupLoggingHelper.GetParameterText(
                             ItemGroupLoggingHelper.OutputItemParameterMessagePrefix,
                             outputTargetName,
-                            outputs);
+                            outputs,
+                            parameter.LogItemMetadata);
 
                         _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
                     }
@@ -1483,7 +1515,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
         /// <summary>
         /// Gather task outputs in array form
         /// </summary>
-        private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string outputTargetName, string[] outputs, ElementLocation parameterLocation)
+        private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string outputTargetName, string[] outputs, ElementLocation parameterLocation, TaskPropertyInfo parameter)
         {
             // if the task has generated outputs (if it didn't, don't do anything)            
             if (outputs != null)
@@ -1501,12 +1533,13 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         }
                     }
 
-                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0)
+                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0 && parameter.Log)
                     {
                         string parameterText = ItemGroupLoggingHelper.GetParameterText(
                             ItemGroupLoggingHelper.OutputItemParameterMessagePrefix,
                             outputTargetName,
-                            outputs);
+                            outputs,
+                            parameter.LogItemMetadata);
                         _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
                     }
                 }
diff --git a/src/Build/Construction/ProjectImportElement.cs b/src/Build/Construction/ProjectImportElement.cs
index 676677dd9a8..0260a1eae46 100644
--- a/src/Build/Construction/ProjectImportElement.cs
+++ b/src/Build/Construction/ProjectImportElement.cs
@@ -6,8 +6,6 @@
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -36,7 +34,7 @@ internal ProjectImportElement(XmlElementWithLocation xmlElement, ProjectElementC
             : base(xmlElement, parent, containingProject)
         {
             ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
-            ParsedSdkReference = sdkReference;
+            SdkReference = sdkReference;
         }
 
         /// <summary>
@@ -75,12 +73,10 @@ public string Sdk
             set
             {
                 ErrorUtilities.VerifyThrowArgumentLength(value, XMakeAttributes.sdk);
-                // TODO: here and other setters. Confirm that CheckUpdatedSdk() ussage is
-                //       really the intended one. Currently it does check for equality  before updating the attribute
-                //       so setter will only take effect if "ParsedSdkReference" is not updated. Currently it might work by accident
-                //       if all "Set" calls are different and no ParsedSdkReference is triggered in between.
-                if (!CheckUpdatedSdk()) return;
-                SetOrRemoveAttribute(XMakeAttributes.sdk, value, "Set Import Sdk {0}", value);
+                if (UpdateSdkReference(name: value, SdkReference?.Version, SdkReference?.MinimumVersion))
+                {
+                    SetOrRemoveAttribute(XMakeAttributes.sdk, value, "Set Import Sdk {0}", value);
+                }
             }
         }
 
@@ -92,8 +88,10 @@ public string Version
             get => GetAttributeValue(XMakeAttributes.sdkVersion);
             set
             {
-                if (!CheckUpdatedSdk()) return;
-                SetOrRemoveAttribute(XMakeAttributes.sdkVersion, value, "Set Import Version {0}", value);
+                if (UpdateSdkReference(SdkReference?.Name, version: value, SdkReference?.MinimumVersion))
+                {
+                    SetOrRemoveAttribute(XMakeAttributes.sdkVersion, value, "Set Import Version {0}", value);
+                }
             }
         }
 
@@ -105,8 +103,10 @@ public string MinimumVersion
             get => GetAttributeValue(XMakeAttributes.sdkMinimumVersion);
             set
             {
-                if (!CheckUpdatedSdk()) return;
-                SetOrRemoveAttribute(XMakeAttributes.sdkMinimumVersion, value, "Set Import Minimum Version {0}", value);
+                if (UpdateSdkReference(SdkReference?.Name, SdkReference?.Version, minimumVersion: value))
+                {
+                    SetOrRemoveAttribute(XMakeAttributes.sdkMinimumVersion, value, "Set Import Minimum Version {0}", value);
+                }
             }
         }
 
@@ -130,9 +130,9 @@ public string MinimumVersion
 
 
         /// <summary>
-        /// <see cref="SdkReference"/> if applicable to this import element.
+        /// <see cref="Framework.SdkReference"/> if applicable to this import element.
         /// </summary>
-        internal SdkReference ParsedSdkReference { get; set; }
+        internal SdkReference SdkReference { get; set; }
 
         /// <summary>
         /// Creates an unparented ProjectImportElement, wrapping an unparented XmlElement.
@@ -162,7 +162,7 @@ internal static ProjectImportElement CreateImplicit(
                 Project = project,
                 Sdk = sdkReference.ToString(),
                 ImplicitImportLocation = implicitImportLocation,
-                ParsedSdkReference = sdkReference,
+                SdkReference = sdkReference,
                 OriginalElement = originalElement
             };
         }
@@ -183,23 +183,20 @@ protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         }
 
         /// <summary>
-        /// Helper method to extract attribute values and update the ParsedSdkReference property if
-        /// necessary (update only when changed).
+        /// Helper method to update the <see cref="SdkReference" /> property if necessary (update only when changed).
         /// </summary>
-        /// <returns>True if the ParsedSdkReference was updated, otherwise false (no update necessary).</returns>
-        private bool CheckUpdatedSdk()
+        /// <returns>True if the <see cref="SdkReference" /> property was updated, otherwise false (no update necessary).</returns>
+        private bool UpdateSdkReference(string name, string version, string minimumVersion)
         {
-            var sdk = new SdkReference(
-                GetAttributeValue(XMakeAttributes.sdk, true),
-                GetAttributeValue(XMakeAttributes.sdkVersion, true),
-                GetAttributeValue(XMakeAttributes.sdkMinimumVersion, true));
+            SdkReference sdk = new SdkReference(name, version, minimumVersion);
 
-            if (sdk.Equals(ParsedSdkReference))
+            if (sdk.Equals(SdkReference))
             {
                 return false;
             }
 
-            ParsedSdkReference = sdk;
+            SdkReference = sdk;
+
             return true;
         }
     }
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 840be8683f2..b43999f8a97 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -8,6 +8,7 @@
 using System.Text;
 using System.Globalization;
 using System.Security;
+using System.Text.Json;
 using System.Text.RegularExpressions;
 
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
@@ -17,6 +18,8 @@
 using ResourceUtilities = Microsoft.Build.Shared.ResourceUtilities;
 using ExceptionUtilities = Microsoft.Build.Shared.ExceptionHandling;
 using System.Collections.ObjectModel;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Construction
 {
@@ -85,6 +88,7 @@ public sealed class SolutionFile
         #endregion
         #region Member data
         private string _solutionFile;                 // Could be absolute or relative path to the .SLN file.
+        private HashSet<string> _solutionFilter;     // The project files to include in loading the solution.
         private bool _parsingForConversionOnly;      // Are we parsing this solution to get project reference data during
                                                      // conversion, or in preparation for actually building the solution?
 
@@ -195,7 +199,15 @@ internal string FullPath
             {
                 // Should already be canonicalized to a full path
                 ErrorUtilities.VerifyThrowInternalRooted(value);
-                _solutionFile = value;
+                if (FileUtilities.IsSolutionFilterFilename(value))
+                {
+                    ParseSolutionFilter(value);
+                }
+                else
+                {
+                    _solutionFile = value;
+                    _solutionFilter = null;
+                }
             }
         }
 
@@ -218,6 +230,11 @@ internal string FullPath
 
         #region Methods
 
+        internal bool ProjectShouldBuild(string projectFile)
+        {
+            return _solutionFilter == null || _solutionFilter.Contains(projectFile);
+        }
+
         /// <summary>
         /// This method takes a path to a solution file, parses the projects and project dependencies
         /// in the solution file, and creates internal data structures representing the projects within
@@ -286,9 +303,8 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
 
                         if (!System.Version.TryParse(fileVersionFromHeader, out Version version))
                         {
-                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                            ProjectFileErrorUtilities.ThrowInvalidProjectFile
                                 (
-                                    false /* just throw the exception */,
                                     "SubCategoryForSolutionParsingErrors",
                                     new BuildEventFileInfo(solutionFile),
                                     "SolutionParseVersionMismatchError",
@@ -334,15 +350,52 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
             }
 
             // Didn't find the header in lines 1-4, so the solution file is invalid.
-            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+            ProjectFileErrorUtilities.ThrowInvalidProjectFile
                 (
-                    false /* just throw the exception */,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(solutionFile),
                     "SolutionParseNoHeaderError"
                  );
         }
 
+        private void ParseSolutionFilter(string solutionFilterFile)
+        {
+            try
+            {
+                using JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile));
+                JsonElement solution = text.RootElement.GetProperty("solution");
+                _solutionFile = Path.GetFullPath(solution.GetProperty("path").GetString());
+                if (!FileSystems.Default.FileExists(_solutionFile))
+                {
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile
+                    (
+                        "SubCategoryForSolutionParsingErrors",
+                        new BuildEventFileInfo(_solutionFile),
+                        "SolutionFilterMissingSolutionError",
+                        solutionFilterFile,
+                        _solutionFile
+                    );
+                }
+                _solutionFilter = new HashSet<string>(NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
+                foreach (JsonElement project in solution.GetProperty("projects").EnumerateArray())
+                {
+                    _solutionFilter.Add(project.GetString());
+                }
+            }
+            catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
+            {
+                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                (
+                    false, /* Just throw the exception */
+                    "SubCategoryForSolutionParsingErrors",
+                    new BuildEventFileInfo(solutionFilterFile),
+                    e,
+                    "SolutionFilterJsonParsingError",
+                    solutionFilterFile
+                );
+            }
+        }
+
         /// <summary>
         /// Adds a configuration to this solution
         /// </summary>
@@ -461,6 +514,30 @@ internal void ParseSolution()
                 }
             }
 
+            if (_solutionFilter != null)
+            {
+                HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
+                foreach (ProjectInSolution project in _projectsInOrder)
+                {
+                    projectPaths.Add(project.RelativePath);
+                }
+                foreach (string project in _solutionFilter)
+                {
+                    if (!projectPaths.Contains(project))
+                    {
+                        ProjectFileErrorUtilities.ThrowInvalidProjectFile
+                        (
+                            "SubCategoryForSolutionParsingErrors",
+                            new BuildEventFileInfo(project),
+                            "SolutionFilterFilterContainsProjectNotInSolution",
+                            _solutionFilter,
+                            project,
+                            _solutionFile
+                        );
+                    }
+                }
+            }
+
             if (rawProjectConfigurationsEntries != null)
             {
                 ProcessProjectConfigurationSection(rawProjectConfigurationsEntries);
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 5edc192921f..b1f32e3a5d0 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -637,6 +637,12 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionFile so
         /// </summary>
         private static bool WouldProjectBuild(SolutionFile solutionFile, string selectedSolutionConfiguration, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration)
         {
+            // If the solution filter does not contain this project, do not build it.
+            if (!solutionFile.ProjectShouldBuild(project.RelativePath))
+            {
+                return false;
+            }
+
             if (projectConfiguration == null)
             {
                 if (project.ProjectType == SolutionProjectType.WebProject)
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 9004c89b90f..15c91a6f68e 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -139,7 +139,14 @@ public override void Load(XmlReader reader)
         {
             if (reader.BaseURI.Length > 0)
             {
-                DetermineWhetherToLoadReadOnly(new Uri(reader.BaseURI).LocalPath);
+                string adjustedLocalPath = null;
+
+                if (Uri.TryCreate(reader.BaseURI, UriKind.RelativeOrAbsolute, out Uri uri))
+                {
+                    adjustedLocalPath = uri.LocalPath;
+                }
+
+                DetermineWhetherToLoadReadOnly(adjustedLocalPath);
             }
 
             // Set the line info source if it is available given the specific implementation of XmlReader
@@ -340,7 +347,7 @@ private void DetermineWhetherToLoadReadOnly(string fullPath)
                 {
                     _loadAsReadOnly = true;
                 }
-                else if (s_readOnlyFlags == ReadOnlyLoadFlags.LoadReadOnlyIfAppropriate)
+                else if (s_readOnlyFlags == ReadOnlyLoadFlags.LoadReadOnlyIfAppropriate && fullPath is object)
                 {
                     // Only files from Microsoft
                     if (Path.GetFileName(fullPath).StartsWith("Microsoft.", StringComparison.OrdinalIgnoreCase))
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 8e90acfa61d..449d9e4f3c2 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1776,7 +1776,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
 
             string project = importElement.Project;
 
-            if (importElement.ParsedSdkReference != null)
+            if (importElement.SdkReference != null)
             {
                 // Try to get the path to the solution and project being built. The solution path is not directly known
                 // in MSBuild. It is passed in as a property either by the VS project system or by MSBuild's solution
@@ -1788,7 +1788,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                 var projectPath = _data.GetProperty(ReservedPropertyNames.projectFullPath)?.EvaluatedValue;
 
                 // Combine SDK path with the "project" relative path
-                sdkResult = _sdkResolverService.ResolveSdk(_submissionId, importElement.ParsedSdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive);
+                sdkResult = _sdkResolverService.ResolveSdk(_submissionId, importElement.SdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive);
 
                 if (!sdkResult.Success)
                 {
@@ -1798,7 +1798,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                             importElement.Location.Line,
                             importElement.Location.Column,
                             ResourceUtilities.GetResourceString("CouldNotResolveSdk"),
-                            importElement.ParsedSdkReference.ToString())
+                            importElement.SdkReference.ToString())
                         {
                             BuildEventContext = _evaluationLoggingContext.BuildEventContext,
                             UnexpandedProject = importElement.Project,
@@ -1814,14 +1814,135 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                         return;
                     }
 
-                    ProjectErrorUtilities.ThrowInvalidProject(importElement.SdkLocation, "CouldNotResolveSdk", importElement.ParsedSdkReference.ToString());
+                    ProjectErrorUtilities.ThrowInvalidProject(importElement.SdkLocation, "CouldNotResolveSdk", importElement.SdkReference.ToString());
                 }
 
-                project = Path.Combine(sdkResult.Path, project);
+                if (sdkResult.Path == null)
+                {
+                    projects = new List<ProjectRootElement>();
+                }
+                else
+                {
+                    ExpandAndLoadImportsFromUnescapedImportExpression(directoryOfImportingFile, importElement, Path.Combine(sdkResult.Path, project),
+                        throwOnFileNotExistsError, out projects);
+
+                    if (sdkResult.AdditionalPaths != null)
+                    {
+                        foreach (var additionalPath in sdkResult.AdditionalPaths)
+                        {
+                            ExpandAndLoadImportsFromUnescapedImportExpression(directoryOfImportingFile, importElement, Path.Combine(additionalPath, project),
+                                throwOnFileNotExistsError, out var additionalProjects);
+
+                            projects.AddRange(additionalProjects);
+                        }
+                    }
+                }
+
+                if ((sdkResult.PropertiesToAdd != null && sdkResult.PropertiesToAdd.Any()) ||
+                    (sdkResult.ItemsToAdd != null && sdkResult.ItemsToAdd.Any()))
+                {
+                    //  Inserting at the beginning will mean that the properties or items from the SdkResult will be evaluated before
+                    //  any projects from paths returned by the SDK Resolver.
+                    projects.Insert(0, CreateProjectForSdkResult(sdkResult));
+                }
+            }
+            else
+            {
+                ExpandAndLoadImportsFromUnescapedImportExpression(directoryOfImportingFile, importElement, project,
+                    throwOnFileNotExistsError, out projects);
+            }
+        }
+
+        //  Creates a project to set the properties and include the items from an SdkResult
+        private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
+        {
+            int propertiesAndItemsHash;
+
+#if NETCOREAPP
+            HashCode hash = new HashCode();
+#else
+            propertiesAndItemsHash = -849885975;
+#endif
+
+            if (sdkResult.PropertiesToAdd != null)
+            {
+                foreach (var property in sdkResult.PropertiesToAdd)
+                {
+#if NETCOREAPP
+                    hash.Add(property.Key);
+                    hash.Add(property.Value);
+#else
+                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + property.Key.GetHashCode();
+                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + property.Value.GetHashCode();
+#endif
+                }
+            }
+            if (sdkResult.ItemsToAdd != null)
+            {
+                foreach (var item in sdkResult.ItemsToAdd)
+                {
+#if NETCOREAPP
+                    hash.Add(item.Key);
+                    hash.Add(item.Value);
+#else
+                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + item.Key.GetHashCode();
+                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + item.Value.GetHashCode();
+#endif
+
+                }
+            }
+
+#if NETCOREAPP
+            propertiesAndItemsHash = hash.ToHashCode();
+#endif
+
+            //  Generate a unique filename for the generated project for each unique set of properties and items.
+            string projectPath = _projectRootElement.FullPath + ".SdkResolver." + propertiesAndItemsHash + ".proj";
+
+            ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
+            {
+                ProjectRootElement project = ProjectRootElement.Create();
+                project.FullPath = projectPath;
+
+                if (sdkResult.PropertiesToAdd != null && sdkResult.PropertiesToAdd.Any())
+                {
+                    var propertyGroup = project.AddPropertyGroup();
+                    foreach (var propertyNameAndValue in sdkResult.PropertiesToAdd)
+                    {
+                        propertyGroup.AddProperty(propertyNameAndValue.Key, EscapingUtilities.Escape(propertyNameAndValue.Value));
+                    }
+                }
+
+                if (sdkResult.ItemsToAdd != null && sdkResult.ItemsToAdd.Any())
+                {
+                    var itemGroup = project.AddItemGroup();
+                    foreach (var item in sdkResult.ItemsToAdd)
+                    {
+                        Dictionary<string, string> escapedMetadata = null;
+
+                        if (item.Value.Metadata != null)
+                        {
+                            escapedMetadata = new Dictionary<string, string>(item.Value.Metadata.Count, StringComparer.OrdinalIgnoreCase);
+                            foreach (var metadata in item.Value.Metadata)
+                            {
+                                escapedMetadata[metadata.Key] = EscapingUtilities.Escape(metadata.Value);
+                            }
+                        }
+
+                        itemGroup.AddItem(item.Key, EscapingUtilities.Escape(item.Value.ItemSpec), escapedMetadata);
+                    }
+                }
+
+                _projectRootElementCache.AddEntry(project);
+
+                return project;
             }
 
-            ExpandAndLoadImportsFromUnescapedImportExpression(directoryOfImportingFile, importElement, project,
-                throwOnFileNotExistsError, out projects);
+            return _projectRootElementCache.Get(
+                projectPath,
+                InnerCreate,
+                _projectRootElement.IsExplicitlyLoaded,
+                preserveFormatting: null);
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index c066300ffe8..d9eb06311f0 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -3341,7 +3341,10 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     // need to locate an appropriate constructor and invoke it
                     if (String.Equals("new", _methodMethodName, StringComparison.OrdinalIgnoreCase))
                     {
-                        functionResult = LateBindExecute(null /* no previous exception */, BindingFlags.Public | BindingFlags.Instance, null /* no instance for a constructor */, args, true /* is constructor */);
+                        if (!TryExecuteWellKnownConstructorNoThrow(out functionResult, args))
+                        {
+                            functionResult = LateBindExecute(null /* no previous exception */, BindingFlags.Public | BindingFlags.Instance, null /* no instance for a constructor */, args, true /* is constructor */);
+                        }
                     }
                     else
                     {
@@ -3534,6 +3537,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             return true;
                         }
                     }
+                    else if (string.Equals(_methodMethodName, nameof(string.IndexOf), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (TryGetArgs(args, out string arg0, out StringComparison arg1))
+                        {
+                            returnVal = text.IndexOf(arg0, arg1);
+                            return true;
+                        }
+                    }
                     else if (string.Equals(_methodMethodName, nameof(string.IndexOfAny), StringComparison.OrdinalIgnoreCase))
                     {
                         if (TryGetArg(args, out string arg0))
@@ -3554,20 +3565,10 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             returnVal = text.LastIndexOf(arg0, startIndex);
                             return true;
                         }
-                        else if (TryGetArgs(args, out arg0, out string arg1))
+                        else if (TryGetArgs(args, out arg0, out StringComparison arg1))
                         {
-                            string comparisonType = arg1;
-
-                            // Allow fully-qualified enum, e.g. "System.StringComparison.OrdinalIgnoreCase"
-                            if (comparisonType.Contains("."))
-                            {
-                                comparisonType = arg1.Replace("System.StringComparison.", "").Replace("StringComparison.", "");
-                            }
-                            if (Enum.TryParse<StringComparison>(comparisonType, out StringComparison comparison))
-                            {
-                                returnVal = text.LastIndexOf(arg0, comparison);
-                                return true;
-                            }
+                            returnVal = text.LastIndexOf(arg0, arg1);
+                            return true;
                         }
                     }
                     else if (string.Equals(_methodMethodName, nameof(string.Length), StringComparison.OrdinalIgnoreCase))
@@ -3913,6 +3914,30 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetFrameworkIdentifier), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetFrameworkIdentifier(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetFrameworkVersion), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsTargetFrameworkCompatible), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out string arg0, out string arg1))
+                            {
+                                returnVal = IntrinsicFunctions.IsTargetFrameworkCompatible(arg0, arg1);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Path))
                     {
@@ -4043,6 +4068,33 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                 return false;
             }
 
+            /// <summary>
+            /// Shortcut to avoid calling into binding if we recognize some most common constructors.
+            /// Analogous to TryExecuteWellKnownFunction but guaranteed to not throw.
+            /// </summary>
+            /// <param name="returnVal">The instance as created by the constructor call.</param>
+            /// <param name="args">Arguments.</param>
+            /// <returns>True if the well known constructor call binding was successful.</returns>
+            private bool TryExecuteWellKnownConstructorNoThrow(out object returnVal, object[] args)
+            {
+                returnVal = null;
+
+                if (_receiverType == typeof(string))
+                {
+                    if (args.Length == 0)
+                    {
+                        returnVal = String.Empty;
+                        return true;
+                    }
+                    if (TryGetArg(args, out string arg0))
+                    {
+                        returnVal = arg0;
+                        return true;
+                    }
+                }
+                return false;
+            }
+
             private bool ElementsOfType(object[] args, Type type)
             {
                 for (var i = 0; i < args.Length; i++)
@@ -4212,6 +4264,34 @@ private static bool TryGetArg(object[] args, out string arg0)
                 return arg0 != null;
             }
 
+            private static bool TryGetArgs(object[] args, out string arg0, out StringComparison arg1)
+            {
+                if (args.Length != 2)
+                {
+                    arg0 = null;
+                    arg1 = default;
+
+                    return false;
+                }
+
+                arg0 = args[0] as string;
+
+                // reject enums as ints. In C# this would require a cast, which is not supported in msbuild expressions
+                if (arg0 == null || !(args[1] is string comparisonTypeName) || int.TryParse(comparisonTypeName, out _))
+                {
+                    arg1 = default;
+                    return false;
+                }
+
+                // Allow fully-qualified enum, e.g. "System.StringComparison.OrdinalIgnoreCase"
+                if (comparisonTypeName.Contains('.'))
+                {
+                    comparisonTypeName = comparisonTypeName.Replace("System.StringComparison.", "").Replace("StringComparison.", "");
+                }
+
+                return Enum.TryParse(comparisonTypeName, out arg1);
+            }
+
             private static bool TryGetArgs(object[] args, out int arg0, out int arg1)
             {
                 arg0 = 0;
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index e532306e5c2..55f9e185226 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Text.RegularExpressions;
 
@@ -32,6 +30,8 @@ internal static class IntrinsicFunctions
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
 #endif // FEATURE_WIN32_REGISTRY
 
+        private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => new NuGetFrameworkWrapper());
+
         /// <summary>
         /// Add two doubles
         /// </summary>
@@ -379,7 +379,7 @@ internal static bool DoesTaskHostExist(string runtime, string architecture)
             parameters.Add(XMakeAttributes.runtime, runtime);
             parameters.Add(XMakeAttributes.architecture, architecture);
 
-            TaskHostContext desiredContext = CommunicationsUtilities.GetTaskHostContext(parameters);
+            HandshakeOptions desiredContext = CommunicationsUtilities.GetHandshakeOptions(taskHost: true, taskHostParameters: parameters);
             string taskHostLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(desiredContext);
 
             if (taskHostLocation != null && FileUtilities.FileExistsNoThrow(taskHostLocation))
@@ -480,6 +480,21 @@ internal static bool VersionLessThanOrEquals(string a, string b)
             return SimpleVersion.Parse(a) <= SimpleVersion.Parse(b);
         }
 
+        internal static string GetTargetFrameworkIdentifier(string tfm)
+        {
+            return NuGetFramework.Value.GetTargetFrameworkIdentifier(tfm);
+        }
+
+        internal static string GetTargetFrameworkVersion(string tfm)
+        {
+            return NuGetFramework.Value.GetTargetFrameworkVersion(tfm);
+        }
+
+        internal static bool IsTargetFrameworkCompatible(string target, string candidate)
+        {
+            return NuGetFramework.Value.IsCompatible(target, candidate);
+        }
+
         public static string GetCurrentToolsDirectory()
         {
             return BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index cdd16bf54e6..89f99c08aee 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -100,7 +100,7 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                         string[] includeSplitFilesEscaped;
                         if (MSBuildEventSource.Log.IsEnabled())
                         {
-                            MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, excludePatternsForGlobs.ToList().Aggregate((f, s) => f + ", " + s));
+                            MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
                         }
                         using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
                         {
@@ -112,7 +112,7 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                         }
                         if (MSBuildEventSource.Log.IsEnabled())
                         {
-                            MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, excludePatternsForGlobs.ToList().Aggregate((f, s) => f + ", " + s));
+                            MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
                         }
 
                         foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 45866736036..21bdd300107 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -323,6 +323,27 @@ protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElem
 
                 return needToExpandMetadataForEachItem;
             }
+
+            protected static bool ItemspecContainsASingleItemReference(ItemSpec<P, I> itemSpec, string referencedItemType)
+            {
+                if (itemSpec.Fragments.Count != 1)
+                {
+                    return false;
+                }
+
+                var itemExpressionFragment = itemSpec.Fragments[0] as ItemSpec<P, I>.ItemExpressionFragment;
+                if (itemExpressionFragment == null)
+                {
+                    return false;
+                }
+
+                if (!itemExpressionFragment.Capture.ItemType.Equals(referencedItemType, StringComparison.OrdinalIgnoreCase))
+                {
+                    return false;
+                }
+
+                return true;
+            }
         }
     }
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index fdd5b3e312d..fe2dcf43a85 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -23,9 +23,14 @@ public RemoveOperation(RemoveOperationBuilder builder, LazyItemEvaluator<P, I, M
                 _matchOnMetadataOptions = builder.MatchOnMetadataOptions;
             }
 
-            // todo port the self referencing matching optimization (e.g. <I Remove="@(I)">) from Update to Remove as well. Ideally make one mechanism for both. https://github.com/Microsoft/msbuild/issues/2314
-            // todo Perf: do not match against the globs: https://github.com/Microsoft/msbuild/issues/2329
-            protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+            /// <summary>
+            /// Apply the Remove operation.
+            /// </summary>
+            /// <remarks>
+            /// This operation is mostly implemented in terms of the default <see cref="LazyItemOperation.ApplyImpl(ImmutableList{ItemData}.Builder, ImmutableHashSet{string})"/>.
+            /// This override exists to apply the removing-everything short-circuit.
+            /// </remarks>
+            protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
                 var matchOnMetadataValid = !_matchOnMetadata.IsEmpty && _itemSpec.Fragments.Count == 1
                     && _itemSpec.Fragments.First() is ItemSpec<ProjectProperty, ProjectItem>.ItemExpressionFragment;
@@ -34,6 +39,20 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                     new BuildEventFileInfo(string.Empty),
                     "OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
 
+                if (_matchOnMetadata.IsEmpty && ItemspecContainsASingleItemReference(_itemSpec, _itemElement.ItemType))
+                {
+                    // Perf optimization: If the Remove operation references itself (e.g. <I Remove="@(I)"/>)
+                    // then all items are removed and matching is not necessary
+                    listBuilder.Clear();
+                    return;
+                }
+
+                base.ApplyImpl(listBuilder, globsToIgnore);
+            }
+
+            // todo Perf: do not match against the globs: https://github.com/Microsoft/msbuild/issues/2329
+            protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+            {
                 var items = ImmutableHashSet.CreateBuilder<I>();
                 foreach (ItemData item in listBuilder)
                 {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index 24b3d9a375b..025f247cfec 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -134,27 +134,6 @@ private static bool ItemSpecContainsItemReferences(ItemSpec<P, I> itemSpec)
             {
                 return itemSpec.Fragments.Any(f => f is ItemSpec<P,I>.ItemExpressionFragment);
             }
-
-            private static bool ItemspecContainsASingleItemReference(ItemSpec<P, I> itemSpec, string referencedItemType)
-            {
-                if (itemSpec.Fragments.Count != 1)
-                {
-                    return false;
-                }
-
-                var itemExpressionFragment = itemSpec.Fragments[0] as ItemSpec<P,I>.ItemExpressionFragment;
-                if (itemExpressionFragment == null)
-                {
-                    return false;
-                }
-
-                if (!itemExpressionFragment.Capture.ItemType.Equals(referencedItemType, StringComparison.OrdinalIgnoreCase))
-                {
-                    return false;
-                }
-
-                return true;
-            }
         }
     }
 }
diff --git a/src/Build/Evaluation/SemiColonTokenizer.cs b/src/Build/Evaluation/SemiColonTokenizer.cs
index ceac85a143e..3d3c0791baa 100644
--- a/src/Build/Evaluation/SemiColonTokenizer.cs
+++ b/src/Build/Evaluation/SemiColonTokenizer.cs
@@ -145,7 +145,7 @@ private string GetExpressionSubstring(int startIndex, int length)
                 }
                 if (startIndex < endIndex)
                 {
-                    var target = new OpportunisticIntern.SubstringInternTarget(_expression, startIndex, endIndex - startIndex);
+                    var target = new SubstringInternTarget(_expression, startIndex, endIndex - startIndex);
                     return OpportunisticIntern.InternableToString(target);
                 }
                 return null;
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 0fb077ab7e9..546fcc45a68 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -78,6 +78,7 @@ public void BuildGraph()
             {
                 return;
             }
+
             var allParsedProjects = FindGraphNodes();
             
             AddEdges(allParsedProjects);
@@ -110,28 +111,78 @@ private static IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyColl
         private void AddEdges(Dictionary<ConfigurationMetadata, ParsedProject> allParsedProjects)
         {
             Edges = new GraphEdges();
-            AddEdgesFromProjectFileReferences(allParsedProjects, Edges);
-            _projectInterpretation.PostProcess(allParsedProjects, this);
+
+            AddEdgesFromProjectReferenceItems(allParsedProjects, Edges);
+
+            _projectInterpretation.ReparentInnerBuilds(allParsedProjects, this);
+
             if (_solutionDependencies != null && _solutionDependencies.Count != 0)
             {
                 AddEdgesFromSolution(allParsedProjects, _solutionDependencies, Edges);
             }
         }
 
-        private static void AddEdgesFromProjectFileReferences(Dictionary<ConfigurationMetadata, ParsedProject> allParsedProjects, GraphEdges edges)
+        private void AddEdgesFromProjectReferenceItems(Dictionary<ConfigurationMetadata, ParsedProject> allParsedProjects, GraphEdges edges)
         {
+            var transitiveReferenceCache = new Dictionary<ProjectGraphNode, HashSet<ProjectGraphNode>>(allParsedProjects.Count);
+
             foreach (var parsedProject in allParsedProjects)
             {
+                var currentNode = parsedProject.Value.GraphNode;
+
+                var requiresTransitiveProjectReferences = _projectInterpretation.RequiresTransitiveProjectReferences(currentNode.ProjectInstance);
+
                 foreach (var referenceInfo in parsedProject.Value.ReferenceInfos)
                 {
-                    ErrorUtilities.VerifyThrow(
-                        allParsedProjects.ContainsKey(referenceInfo.ReferenceConfiguration),
-                        "all references should have been parsed");
-
-                    parsedProject.Value.GraphNode.AddProjectReference(
+                    // Always add direct references.
+                    currentNode.AddProjectReference(
                         allParsedProjects[referenceInfo.ReferenceConfiguration].GraphNode,
                         referenceInfo.ProjectReferenceItem,
                         edges);
+
+                    // Add transitive references only if the project requires it.
+                    if (requiresTransitiveProjectReferences)
+                    {
+                        foreach (var transitiveProjectReference in GetTransitiveProjectReferencesExcludingSelf(allParsedProjects[referenceInfo.ReferenceConfiguration]))
+                        {
+                            currentNode.AddProjectReference(
+                                transitiveProjectReference,
+                                new ProjectItemInstance(
+                                    project: currentNode.ProjectInstance,
+                                    itemType: ProjectInterpretation.TransitiveReferenceItemName,
+                                    includeEscaped: referenceInfo.ReferenceConfiguration.ProjectFullPath,
+                                    directMetadata: null,
+                                    definingFileEscaped: currentNode.ProjectInstance.FullPath
+                                ),
+                                edges);
+                        }
+                    }
+                }
+            }
+
+            HashSet<ProjectGraphNode> GetTransitiveProjectReferencesExcludingSelf(ParsedProject parsedProject)
+            {
+                if (transitiveReferenceCache.TryGetValue(parsedProject.GraphNode, out HashSet<ProjectGraphNode> cachedTransitiveReferences))
+                {
+                    return cachedTransitiveReferences;
+                }
+                else
+                {
+                    var transitiveReferences = new HashSet<ProjectGraphNode>();
+
+                    foreach (var referenceInfo in parsedProject.ReferenceInfos)
+                    {
+                        transitiveReferences.Add(allParsedProjects[referenceInfo.ReferenceConfiguration].GraphNode);
+
+                        foreach (var transitiveReference in GetTransitiveProjectReferencesExcludingSelf(allParsedProjects[referenceInfo.ReferenceConfiguration]))
+                        {
+                            transitiveReferences.Add(transitiveReference);
+                        }
+                    }
+
+                    transitiveReferenceCache.Add(parsedProject.GraphNode, transitiveReferences);
+
+                    return transitiveReferences;
                 }
             }
         }
@@ -582,6 +633,9 @@ public void RemoveEdge((ProjectGraphNode node, ProjectGraphNode reference) key)
                 ReferenceItems.TryRemove(key, out _);
             }
 
+            internal bool HasEdge((ProjectGraphNode node, ProjectGraphNode reference) key) => ReferenceItems.ContainsKey(key);
+            internal bool TryGetEdge((ProjectGraphNode node, ProjectGraphNode reference) key, out ProjectItemInstance edge) => ReferenceItems.TryGetValue(key, out edge);
+
             internal IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> TestOnly_AsConfigurationMetadata()
             {
                 return ReferenceItems.ToImmutableDictionary(
@@ -589,8 +643,6 @@ public void RemoveEdge((ProjectGraphNode node, ProjectGraphNode reference) key)
                     kvp => kvp.Value
                     );
             }
-
-            internal bool TestOnly_HasEdge((ProjectGraphNode node, ProjectGraphNode reference) key) => ReferenceItems.ContainsKey(key);
         }
 
         private enum NodeVisitationState
diff --git a/src/Build/Graph/ProjectGraphNode.cs b/src/Build/Graph/ProjectGraphNode.cs
index 24772ceadf3..0a2280a1758 100644
--- a/src/Build/Graph/ProjectGraphNode.cs
+++ b/src/Build/Graph/ProjectGraphNode.cs
@@ -58,6 +58,14 @@ internal void AddProjectReference(ProjectGraphNode reference, ProjectItemInstanc
             edges[(this, reference)] = projectReferenceItem;
         }
 
+        internal void RemoveReference(ProjectGraphNode reference, GraphBuilder.GraphEdges edges)
+        {
+            _projectReferences.Remove(reference);
+            reference._referencingProjects.Remove(reference);
+
+            edges.RemoveEdge((this, reference));
+        }
+
         internal void RemoveReferences(GraphBuilder.GraphEdges edges)
         {
             foreach (var reference in _projectReferences)
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 298f4ea4721..cd9b85686e5 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -24,7 +24,9 @@ internal sealed class ProjectInterpretation
         private const string SetTargetFrameworkMetadataName = "SetTargetFramework";
         private const string GlobalPropertiesToRemoveMetadataName = "GlobalPropertiesToRemove";
         private const string ProjectReferenceTargetIsOuterBuildMetadataName = "OuterBuild";
-        internal const string InnerBuildReferenceItemName = "_ProjectSelfReference";
+        private const string InnerBuildReferenceItemName = "_ProjectSelfReference";
+        internal static string TransitiveReferenceItemName = "_TransitiveProjectReference";
+        internal const string AddTransitiveProjectReferencesInStaticGraphPropertyName = "AddTransitiveProjectReferencesInStaticGraph";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
@@ -132,10 +134,10 @@ internal static ProjectType GetProjectType(ProjectInstance project)
         /// However, at build time, for non root outer builds, the inner builds are NOT referenced by the outer build, but by the nodes referencing the
         /// outer build. Change the graph to mimic this behaviour.
         /// Examples
-        /// OuterAsRoot -> Inner stays the same
-        /// Node -> Outer -> Inner goes to: Node -> Outer; Node->Inner; Outer -> empty
+        /// OuterAsRoot -> Inner go to OuterAsRoot -> Inner. Inner builds remain the same, parented to their outer build
+        /// Node -> Outer -> Inner go to: Node -> Outer; Node->Inner; Outer -> empty. Inner builds get reparented to Node
         /// </summary>
-        public void PostProcess(Dictionary<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder)
+        public void ReparentInnerBuilds(Dictionary<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder)
         {
             foreach (var node in allNodes)
             {
@@ -153,6 +155,20 @@ public void PostProcess(Dictionary<ConfigurationMetadata, ParsedProject> allNode
                             // targets to call on the references.
                             var newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
 
+                            if (outerBuildReferencingProject.ProjectReferences.Contains(innerBuild))
+                            {
+                                graphBuilder.Edges.TryGetEdge((outerBuildReferencingProject, innerBuild), out var existingEdge);
+
+                                ErrorUtilities.VerifyThrow(
+                                    graphBuilder.Edges[(outerBuildReferencingProject, innerBuild)]
+                                        .ItemType.Equals(
+                                            TransitiveReferenceItemName,
+                                            StringComparison.OrdinalIgnoreCase),
+                                    "Only transitive references may reference inner builds that got generated by outer builds");
+
+                                outerBuildReferencingProject.RemoveReference(innerBuild, graphBuilder.Edges);
+                            }
+
                             outerBuildReferencingProject.AddProjectReference(innerBuild, newInnerBuildEdge, graphBuilder.Edges);
                         }
                     }
@@ -173,11 +189,11 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
             foreach (var globalPropertyValue in ExpressionShredder.SplitSemiColonSeparatedList(globalPropertyValues))
             {
                 yield return new ProjectItemInstance(
-                    outerBuild,
-                    InnerBuildReferenceItemName,
-                    outerBuild.FullPath,
-                    new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")},
-                    outerBuild.FullPath);
+                    project: outerBuild,
+                    itemType: InnerBuildReferenceItemName,
+                    includeEscaped: outerBuild.FullPath,
+                    directMetadata: new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")},
+                    definingFileEscaped: outerBuild.FullPath);
             }
         }
 
@@ -386,7 +402,7 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj
                         {
                             var targetsMetadataValue = projectReferenceTarget.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
 
-                            var targetsAreForOuterBuild = projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName).Equals("true", StringComparison.OrdinalIgnoreCase);
+                            var targetsAreForOuterBuild = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName));
 
                             var targets = ExpressionShredder.SplitSemiColonSeparatedList(targetsMetadataValue).ToArray();
 
@@ -420,5 +436,31 @@ public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance re
                 }
             }
         }
+
+        public bool RequiresTransitiveProjectReferences(ProjectInstance projectInstance)
+        {
+            // Outer builds do not get edges based on ProjectReference or their transitive closure, only inner builds do.
+            if (GetProjectType(projectInstance) == ProjectType.OuterBuild)
+            {
+                return false;
+            }
+
+            // special case for Quickbuild which updates msbuild binaries independent of props/targets. Remove this when all QB repos will have
+            // migrated to new enough Visual Studio versions whose Microsoft.Managed.After.Targets enable transitive references.
+            if (string.IsNullOrWhiteSpace(projectInstance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName)) &&
+                MSBuildStringIsTrue(projectInstance.GetPropertyValue("UsingMicrosoftNETSdk")) &&
+                MSBuildStringIsFalse(projectInstance.GetPropertyValue("DisableTransitiveProjectReferences")))
+            {
+                return true;
+            }
+
+            return MSBuildStringIsTrue(
+                projectInstance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName));
+        }
+
+        private static bool MSBuildStringIsTrue(string msbuildString) =>
+            ConversionUtilities.ConvertStringToBool(msbuildString, nullOrWhitespaceIsFalse: true);
+
+        private static bool MSBuildStringIsFalse(string msbuildString) => !MSBuildStringIsTrue(msbuildString);
     }
 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index ac9d3200de3..17b0520b4f3 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -10,6 +10,7 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.CompilerServices;
+using System.Text.Json;
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
@@ -2045,13 +2046,13 @@ private void TranslateTargets(ITranslator translator)
         }
 
         // todo move to nested function after c#7
-        private static void TranslatorForTargetSpecificDictionaryKey(ref string key, ITranslator translator)
+        private static void TranslatorForTargetSpecificDictionaryKey(ITranslator translator, ref string key)
         {
             translator.Translate(ref key);
         }
 
         // todo move to nested function after c#7
-        private static void TranslatorForTargetSpecificDictionaryValue(ref List<TargetSpecification> value, ITranslator translator)
+        private static void TranslatorForTargetSpecificDictionaryValue(ITranslator translator, ref List<TargetSpecification> value)
         {
             translator.Translate(ref value, TargetSpecification.FactoryForDeserialization);
         }
@@ -2142,9 +2143,29 @@ internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, Prope
             // we should be generating a 4.0+ or a 3.5-style wrapper project based on the version of the solution. 
             else
             {
-                int solutionVersion;
-                int visualStudioVersion;
-                SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(projectFile, out solutionVersion, out visualStudioVersion);
+                string solutionFile = projectFile;
+                if (FileUtilities.IsSolutionFilterFilename(projectFile))
+                {
+                    try
+                    {
+                        using JsonDocument text = JsonDocument.Parse(File.ReadAllText(projectFile));
+                        JsonElement solution = text.RootElement.GetProperty("solution");
+                        solutionFile = Path.GetFullPath(solution.GetProperty("path").GetString());
+                    }
+                    catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
+                    {
+                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                        (
+                            false, /* Just throw the exception */
+                            "SubCategoryForSolutionParsingErrors",
+                            new BuildEventFileInfo(projectFile),
+                            e,
+                            "SolutionFilterJsonParsingError",
+                            projectFile
+                        );
+                    }
+                }
+                SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFile, out int solutionVersion, out int visualStudioVersion);
 
                 // If we get to this point, it's because it's a valid version.  Map the solution version 
                 // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old 
@@ -2172,7 +2193,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, Prope
 
                     string toolsVersionToUse = Utilities.GenerateToolsVersionToUse(
                         explicitToolsVersion: null,
-                        toolsVersionFromProject: toolsVersion,
+                        toolsVersionFromProject: FileUtilities.IsSolutionFilterFilename(projectFile) ? "Current" : toolsVersion,
                         getToolset: buildParameters.GetToolset,
                         defaultToolsVersion: Constants.defaultSolutionWrapperProjectToolsVersion,
                         usingDifferentToolsVersionFromProjectFile: out _);
diff --git a/src/Build/Instance/ProjectTaskInstance.cs b/src/Build/Instance/ProjectTaskInstance.cs
index 3c5a256de29..98b42dc76ce 100644
--- a/src/Build/Instance/ProjectTaskInstance.cs
+++ b/src/Build/Instance/ProjectTaskInstance.cs
@@ -390,12 +390,12 @@ void ITranslatable.Translate(ITranslator translator)
             }
         }
 
-        private static void ParametersKeyTranslator(ref string key, ITranslator translator)
+        private static void ParametersKeyTranslator(ITranslator translator, ref string key)
         {
             translator.Translate(ref key);
         }
 
-        private static void ParametersValueTranslator(ref (string, ElementLocation) value, ITranslator translator)
+        private static void ParametersValueTranslator(ITranslator translator, ref (string, ElementLocation) value)
         {
             if (translator.Mode == TranslationDirection.WriteToStream)
             {
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index ead6986c715..072b94052e9 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -89,7 +89,7 @@ internal class TaskHostTask : IGeneratedTask, ICancelableTask, INodePacketFactor
         /// The task host context of the task host we're launching -- used to 
         /// communicate with the task host. 
         /// </summary>
-        private TaskHostContext _requiredContext = TaskHostContext.Invalid;
+        private HandshakeOptions _requiredContext = HandshakeOptions.None;
 
         /// <summary>
         /// True if currently connected to the task host; false otherwise. 
@@ -281,7 +281,7 @@ public bool Execute()
             {
                 lock (_taskHostLock)
                 {
-                    _requiredContext = CommunicationsUtilities.GetTaskHostContext(_taskHostParameters);
+                    _requiredContext = CommunicationsUtilities.GetHandshakeOptions(taskHost: true, taskHostParameters: _taskHostParameters);
                     _connectedToTaskHost = _taskHostProvider.AcquireAndSetUpHost(_requiredContext, this, this, hostConfiguration);
                 }
 
@@ -549,30 +549,12 @@ private void HandleLoggedMessage(LogMessagePacket logMessagePacket)
         /// Since we log that we weren't able to connect to the task host in a couple of different places,
         /// extract it out into a separate method. 
         /// </summary>
-        private void LogErrorUnableToCreateTaskHost(TaskHostContext requiredContext, string runtime, string architecture, NodeFailedToLaunchException e)
+        private void LogErrorUnableToCreateTaskHost(HandshakeOptions requiredContext, string runtime, string architecture, NodeFailedToLaunchException e)
         {
-            string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext);
-
-            if (msbuildLocation == null)
-            {
+            string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext) ??
                 // We don't know the path -- probably we're trying to get a 64-bit assembly on a 
                 // 32-bit machine.  At least give them the exe name to look for, though ...
-                switch (requiredContext)
-                {
-                    case TaskHostContext.X32CLR2:
-                    case TaskHostContext.X64CLR2:
-                        msbuildLocation = "MSBuildTaskHost.exe";
-                        break;
-                    case TaskHostContext.X32CLR4:
-                    case TaskHostContext.X64CLR4:
-                        msbuildLocation = "MSBuild.exe";
-                        break;
-                    case TaskHostContext.Invalid:
-                    default:
-                        ErrorUtilities.ThrowInternalErrorUnreachable();
-                        break;
-                }
-            }
+                ((requiredContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2 ? "MSBuildTaskHost.exe" : "MSBuild.exe");
 
             if (e == null)
             {
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 7a83bd9f59b..3d261b4cf46 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -1707,13 +1707,13 @@ public void Translate(ITranslator translator)
                 }
 
                 // todo move to nested function after C# 7
-                private static void TranslatorForTaskParametersKey(ref string key, ITranslator translator)
+                private static void TranslatorForTaskParametersKey(ITranslator translator, ref string key)
                 {
                     translator.Translate(ref key);
                 }
 
                 // todo move to nested function after C# 7
-                private static void TranslatorForTaskParameterValue(ref TaskPropertyInfo taskPropertyInfo, ITranslator translator)
+                private static void TranslatorForTaskParameterValue(ITranslator translator, ref TaskPropertyInfo taskPropertyInfo)
                 {
                     string name = null;
                     string propertyTypeName = null;
@@ -1783,13 +1783,13 @@ public void Translate(ITranslator translator)
         }
 
         //todo make nested after C# 7
-        void TranslateTaskRegistrationKey(ref RegisteredTaskIdentity taskIdentity, ITranslator translator)
+        void TranslateTaskRegistrationKey(ITranslator translator, ref RegisteredTaskIdentity taskIdentity)
         {
             translator.Translate(ref taskIdentity);
         }
 
         //todo make nested after C# 7
-        void TranslateTaskRegistrationValue(ref List<RegisteredTaskRecord> taskRecords, ITranslator translator)
+        void TranslateTaskRegistrationValue(ITranslator translator, ref List<RegisteredTaskRecord> taskRecords)
         {
             translator.Translate(ref taskRecords, RegisteredTaskRecord.FactoryForDeserialization);
         }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 4b5a55262d5..a80444cecbc 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -34,6 +34,7 @@
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
     <PackageReference Include="System.Memory" />
+    <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
   </ItemGroup>
@@ -137,6 +138,7 @@
     </Compile>
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\TaskParameterTypeVerifier.cs" />
+    <Compile Include="..\Shared\TranslatorHelpers.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
@@ -155,6 +157,8 @@
     <Compile Include="BackEnd\Components\Caching\ConfigCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ResourceManager\ResourceManagerService.cs" />
+    <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
+    <Compile Include="Utilities\NuGetFrameworkWrapper.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskParameterElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ExternalProjectsProvider.cs" />
     <Compile Include="ObjectModelRemoting\LinkedObjectFactory.cs" />
@@ -352,6 +356,9 @@
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="Collections\ConvertingEnumerable.cs" />
     <Compile Include="Collections\CopyOnReadEnumerable.cs" />
+    <Compile Include="..\Shared\IInternable.cs" />
+    <Compile Include="..\Shared\WeakStringCache.cs" />
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
     <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
       <Link>Collections\CopyOnWriteDictionary.cs</Link>
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index 5cd809d1166..6f2353241c9 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -135,11 +135,6 @@ internal static class Constants
         /// </summary>
         internal const string Dev10SubToolsetValue = "10.0";
 
-        /// <summary>
-        /// Number representing the current assembly's timestamp
-        /// </summary>
-        internal static long assemblyTimestamp;
-
         /// <summary>
         /// Current version of this MSBuild Engine assembly in the 
         /// form, e.g, "4.0"
@@ -152,29 +147,6 @@ internal static string AssemblyVersion
             }
         }
 
-
-        /// <summary>
-        /// Number representing the current assembly's timestamp
-        /// </summary>
-        internal static long AssemblyTimestamp
-        {
-            get
-            {
-                if (assemblyTimestamp == 0)
-                {
-                    // Get the file version from the currently executing assembly.
-                    // Use .CodeBase instead of .Location, because .Location doesn't
-                    // work when Microsoft.Build.dll has been shadow-copied, for example
-                    // in scenarios where NUnit is loading Microsoft.Build.
-                    string path = FileUtilities.ExecutingAssemblyPath;
-
-                    assemblyTimestamp = new FileInfo(path).LastWriteTime.Ticks;
-                }
-
-                return assemblyTimestamp;
-            }
-        }
-
         // Name of the environment variable that always points to 32-bit program files.
         internal const string programFilesx86 = "ProgramFiles(x86)";
 
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 4b0fe42ac90..846868e1a22 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1101,9 +1101,9 @@
       LOCALIZATION: "{2}" is a localized message from a CLR/FX exception. Also, Microsoft.Build.Framework should not be localized
     </comment>
   </data>
-  <data name="TaskReturnedFalseButDidNotLogError" xml:space="preserve">
-    <value>MSB4132: The "{0}" task returned false but did not log an error.</value>
-    <comment>{StrBegin="MSB4132: "}</comment>
+  <data name="TaskReturnedFalseButDidNotLogError">
+    <value>MSB4181: The "{0}" task returned false but did not log an error.</value>
+    <comment>{StrBegin="MSB4181: "}</comment>
   </data>
   <data name="LoggerCreationError" xml:space="preserve">
     <value>MSB1021: Cannot create an instance of the logger. {0}</value>
@@ -1661,6 +1661,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>MSB4231: ProjectRootElement can't reload if it contains unsaved changes.</value>
     <comment>{StrBegin="MSB4231: "}</comment>
   </data>
+  <data name="LogTaskInputs.Truncated">
+    <value>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</value>
+  </data>
   <data name="MetaprojectGenerated" xml:space="preserve">
     <value>Metaproject "{0}" generated.</value>
   </data>
@@ -1822,4 +1825,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="PropertyAssignment" xml:space="preserve">
     <value>Property initial value: $({0})="{1}" Source: {2}</value>
   </data>
+  <data name="NuGetAssemblyNotFound" xml:space="preserve">
+    <value>A required NuGet assembly was not found. Expected Path: {0}</value>
+  </data>
 </root>
\ No newline at end of file
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 262a0f64993..245e60f730e 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Od tohoto místa dále jsou parametry zkrácené. Pokud si chcete zobrazit všechny parametry, vymažte proměnnou prostředí MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Metaprojekt {0} byl vygenerován.</target>
@@ -117,6 +122,11 @@
         <target state="translated">Operaci nelze dokončit, protože funkce BeginBuild ještě nebyla zavolána.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Uživatelem zadané zpětné volání ProjectInstanceFactoryFunc vrátilo odkaz null. To není přípustné.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: Úloha {0} vrátila false, ale do protokolu se nezaznamenala chyba.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 64073a3496c..ec4322d75e3 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Die Parameter wurden über diesen Punkt hinaus abgeschnitten. Um alle Parameter anzuzeigen, löschen Sie die Umgebungsvariable MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Das Metaprojekt "{0}" wurde generiert.</target>
@@ -117,6 +122,11 @@
         <target state="translated">Der Vorgang kann nicht abgeschlossen werden, da BeginBuild noch nicht aufgerufen wurde.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Ein benutzerseitig angegebener ProjectInstanceFactoryFunc-Rückruf hat einen NULL-Verweis zurückgegeben. Dies ist nicht zulässig.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: Die Aufgabe "{0}" hat FALSE zurückgegeben, jedoch keinen Fehler protokolliert.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index 1891ae50769..ca1dd2da57a 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="new">The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="new">Metaproject "{0}" generated.</target>
@@ -117,6 +122,11 @@
         <target state="new">The operation cannot be completed because BeginBuild has not yet been called.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="new">MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4181: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 6211b592508..2c081aa56d0 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Los parámetros se han truncado a partir de este punto. Para ver todos los parámetros, borre la variable de entorno MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Se generó el metaproyecto "{0}".</target>
@@ -117,6 +122,11 @@
         <target state="translated">La operación no se puede completar porque todavía no se llamó a BeginBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Se devolvió una referencia nula de una devolución de llamada de ProjectInstanceFactoryFunc proporcionada por el usuario, y no se permite.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: La tarea "{0}" devolvió false, pero no registró un error.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 10c3dc7f551..16a7024cede 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Les paramètres ont été tronqués au-delà de ce point. Pour voir tous les paramètres, désactivez la variable d'environnement MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Le métaprojet "{0}" a été généré.</target>
@@ -117,6 +122,11 @@
         <target state="translated">Impossible d'effectuer l'opération car la méthode BeginBuild n'a pas encore été appelée.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Une référence null a été retournée à partir d'un rappel ProjectInstanceFactoryFunc fourni par l'utilisateur. Ceci n'est pas autorisé.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: la tâche "{0}" a retourné false mais n'a pas journalisé d'erreur.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 30f528b6661..7cf9c7da35c 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">I parametri oltre questo punto sono stati troncati. Per visualizzare tutti i parametri, cancellare la variabile di ambiente MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Il metaprogetto "{0}" è stato generato.</target>
@@ -117,6 +122,11 @@
         <target state="translated">Non è possibile completare l'operazione perché BeginBuild non è stato ancora chiamato.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: è stato restituito un riferimento Null da un callback ProjectInstanceFactoryFunc fornito dall'utente. Questa operazione non è consentita.</target>
@@ -200,13 +210,13 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: l'attività "{0}" ha restituito false, ma non è stato registrato alcun errore.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: il task MSBuild compila progetti "{0}" che non sono specificati nell'elemento ProjectReference. Nelle compilazioni isolate questa condizione indica probabilmente che i riferimenti non sono specificati in modo esplicito come elemento ProjectReference in "{1}"</target>
+        <target state="translated">MSB4254: l'attività MSBuild compila progetti "{0}" che non sono specificati nell'elemento ProjectReference. Nelle compilazioni isolate questa condizione indica probabilmente che i riferimenti non sono specificati in modo esplicito come elemento ProjectReference in "{1}"</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 50fc9bd8263..269832f4806 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">このポイントを超えるパラメーターは切り詰められています。すべてのパラメーターを表示するには、MSBUILDTRUNCATETASKINPUTLOGGING 環境変数をクリアします。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">メタプロジェクト "{0}" が生成されました。</target>
@@ -117,6 +122,11 @@
         <target state="translated">BeginBuild がまだ呼び出されていないため、操作を完了できません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: ユーザー提供の ProjectInstanceFactoryFunc コールバックから null 参照が返されました。これは許可されていません。</target>
@@ -200,13 +210,13 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: "{0}" タスクから false が返されましたが、エラーがログに記録されませんでした。</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: ProjectReference 項目で指定されていないプロジェクト "{0}" が MSBuild task によってビルドされています。分離されたビルドでは、これは多くの場合、参照が "{1}" で ProjectReference 項目として明示的に指定されていないことを意味します</target>
+        <target state="translated">MSB4254: ProjectReference 項目で指定されていないプロジェクト "{0}" が MSBuild タスクによってビルドされています。分離されたビルドでは、これは多くの場合、参照が "{1}" で ProjectReference 項目として明示的に指定されていないことを意味します</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index f3d92995264..d969c555020 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">이 지점 이후의 매개 변수가 잘렸습니다. 모든 매개 변수를 보려면 MSBUILDTRUNCATETASKINPUTLOGGING 환경 변수를 지우세요.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">메타프로젝트 "{0}"이(가) 생성되었습니다.</target>
@@ -117,6 +122,11 @@
         <target state="translated">BeginBuild가 아직 호출되지 않았으므로 작업을 완료할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: 사용자가 제공한 ProjectInstanceFactoryFunc 콜백에서 Null 참조가 반환되었습니다. 이는 허용되지 않습니다.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: "{0}" 작업이 false를 반환했지만 오류를 기록하지 않았습니다.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b9c95988257..01ed823e267 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Parametry zostały obcięte za tym punktem. Aby wyświetlić wszystkie parametry, wyczyść zmienną środowiskową MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Wygenerowano metaprojekt „{0}”.</target>
@@ -117,6 +122,11 @@
         <target state="translated">Nie można zakończyć operacji, ponieważ metoda BeginBuild nie została jeszcze wywołana.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Z podanego przez użytkownika wywołania zwrotnego ProjectInstanceFactoryFunc została zwrócona pusta referencja. Jest to niedozwolone.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: Zadanie „{0}” zwróciło wartość false, ale nie zarejestrowało błędu.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index f857a832d90..1ebadba8527 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Os parâmetros foram truncados além deste ponto. Para exibir todos os parâmetros, limpe a variável de ambiente MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Metaprojeto "{0}" gerado.</target>
@@ -117,6 +122,11 @@
         <target state="translated">A operação não pode ser concluída porque BeginBuild ainda não foi chamado.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Uma referência nula foi devolvida de um retorno de chamada do ProjectInstanceFactoryFunc fornecido pelo usuário. Isso não é permitido.</target>
@@ -200,13 +210,13 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: a tarefa "{0}" retornou false, mas não registrou um erro.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: a task MSBuild está criando projetos "{0}" que não estão especificados no item ProjectReference. Nos builds isolados isso provavelmente significa que as referências não estão explicitamente especificadas como um item ProjectReference em "{1}"</target>
+        <target state="translated">MSB4254: a tarefa MSBuild está criando projetos "{0}" que não estão especificados no item ProjectReference. Nos builds isolados, isso provavelmente significa que as referências não estão explicitamente especificadas como um item ProjectReference em "{1}"</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 2ae481c61d9..0e8728ed6ca 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Далее параметры были усечены. Чтобы просмотреть все параметры, очистите переменную среды MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Создан метапроект "{0}".</target>
@@ -117,6 +122,11 @@
         <target state="translated">Не удается завершить операцию, так как ещё не был вызван BeginBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: ссылка со значением NULL была возвращена из предоставленного пользователем вызова ProjectInstanceFactoryFunc. Это недопустимо.</target>
@@ -200,13 +210,13 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: задача "{0}" возвратила значение false, но не зарегистрировала ошибку.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: задача MSBuild собирает проект(ы) {0}, которые не указаны в элементе ProjectReference. В изолированных сборках это может означать, что ссылки явно не указаны как элемент ProjectReference в "{1}".</target>
+        <target state="translated">MSB4254: задача MSBuild собирает проект(ы) {0}, который(ые) не указан(ы) в элементе ProjectReference. В изолированных сборках это может означать, что ссылки явно не указаны как элемент ProjectReference в "{1}".</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 248b8565c6f..19de9e7a29a 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Parametreler bu noktanın ötesinde kısaltıldı. Tüm parametreleri görüntülemek için MSBUILDTRUNCATETASKINPUTLOGGING ortam değişkenini temizleyin.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">"{0}" meta projesi oluşturuldu.</target>
@@ -117,6 +122,11 @@
         <target state="translated">BeginBuild henüz çağrılmadığı için işlem tamamlanamıyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Kullanıcı tarafından sağlanan bir ProjectInstanceFactoryFunc geri aramasında null başvuru var. Buna izin verilmez.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: "{0}" görevi false değerini döndürdü ancak günlüğe hata kaydetmedi.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index fd1afbf8728..3b1f23c2414 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">这些参数在此点之前已被截断。若要查看所有参数，请清除 MSBUILDTRUNCATETASKINPUTLOGGING 环境变量。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">已生成元项目“{0}”。</target>
@@ -117,6 +122,11 @@
         <target state="translated">无法完成该操作，因为尚未调用 BeginBuild。</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: 从用户提供的 ProjectInstanceFactoryFunc 回调中返回了一个空引用。这是不允许的。</target>
@@ -200,13 +210,13 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: “{0}”任务返回了 false，但未记录错误。</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: MSBuild 任务正在生成未在 ProjectReference 项中指定的项目“{0}”。在独立生成中，这可能表示未将引用显式地指定为“{1}”中的 ProjectReference 项</target>
+        <target state="translated">MSB4254: MSBuild task 正在生成未在 ProjectReference 项中指定的项目“{0}”。在独立生成中，这可能表示未将引用显式地指定为“{1}”中的 ProjectReference 项</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 6c6f3879ab2..b8349400ff0 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">參數已在此點之後截斷。若要檢視所有參數，請清除 MSBUILDTRUNCATETASKINPUTLOGGING 環境變數。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">已產生中繼專案 "{0}"。</target>
@@ -117,6 +122,11 @@
         <target state="translated">無法完成作業，因為尚未呼叫 BeginBuild。</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: 使用者提供的 ProjectInstanceFactoryFunc 回呼傳回了 null 參考。這是不允許的情況。</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: "{0}" 工作傳回了 false，但並未記錄錯誤。</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/System.Text.Encodings.Web.pkgdef b/src/Build/System.Text.Encodings.Web.pkgdef
new file mode 100644
index 00000000000..bee4d6921fe
--- /dev/null
+++ b/src/Build/System.Text.Encodings.Web.pkgdef
@@ -0,0 +1,7 @@
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{1A1A9DA4-9F25-4AC8-89BF-BCEF74875CA8}]
+"name"="System.Text.Encodings.Web"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\System.Text.Encodings.Web.dll"
+"publicKeyToken"="cc7b13ffcd2ddd51"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-4.0.5.0"
+"newVersion"="4.0.5.0"
diff --git a/src/Build/System.Text.Json.pkgdef b/src/Build/System.Text.Json.pkgdef
new file mode 100644
index 00000000000..f20fee293fd
--- /dev/null
+++ b/src/Build/System.Text.Json.pkgdef
@@ -0,0 +1,7 @@
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{1F1A9DA4-9F25-4AB8-89BF-BCEF73875178}]
+"name"="System.Text.Json"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\System.Text.Json.dll"
+"publicKeyToken"="cc7b13ffcd2ddd51"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-4.0.1.0"
+"newVersion"="4.0.1.0"
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
new file mode 100644
index 00000000000..117e85acd93
--- /dev/null
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -0,0 +1,69 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO;
+using System.Reflection;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Evaluation
+{
+    /// <summary>
+    /// Wraps the NuGet.Frameworks assembly, which is referenced by reflection.
+    /// </summary>
+    internal class NuGetFrameworkWrapper
+    {
+        /// <summary>
+        /// NuGet Types
+        /// </summary>
+        private static MethodInfo ParseMethod;
+        private static MethodInfo IsCompatibleMethod;
+        private static object DefaultCompatibilityProvider;
+        private static PropertyInfo FrameworkProperty;
+        private static PropertyInfo VersionProperty;
+
+        public NuGetFrameworkWrapper()
+        {
+            /// Resolve the location of the NuGet.Frameworks assembly
+            var assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
+                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
+                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
+            try
+            {
+                var NuGetAssembly = Assembly.LoadFile(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
+                var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
+                var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
+                var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
+                ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
+                IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
+                DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, new object[] { });
+                FrameworkProperty = NuGetFramework.GetProperty("Framework");
+                VersionProperty = NuGetFramework.GetProperty("Version");
+            }
+            catch
+            {
+                throw new InternalErrorException(string.Format(AssemblyResources.GetString("NuGetAssemblyNotFound"), assemblyDirectory));
+            }
+        }
+
+        private object Parse(string tfm)
+        {
+            return ParseMethod.Invoke(null, new object[] { tfm });
+        }
+
+        public string GetTargetFrameworkIdentifier(string tfm)
+        {
+            return FrameworkProperty.GetValue(Parse(tfm)) as string;
+        }
+
+        public string GetTargetFrameworkVersion(string tfm)
+        {
+            return (VersionProperty.GetValue(Parse(tfm)) as Version).ToString(2);
+        }
+
+        public bool IsCompatible(string target, string candidate)
+        {
+            return Convert.ToBoolean(IsCompatibleMethod.Invoke(DefaultCompatibilityProvider, new object[] { Parse(target), Parse(candidate) }));
+        }
+    }
+}
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 1953f6976a4..7d4b6537997 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -17,7 +17,10 @@
     <!-- Set output type of test projects to EXE.  This will allow us to run tests on .NET Core via F5 or "dotnet run" -->
     <OutputType>Exe</OutputType>
     <GenerateProgramFile>false</GenerateProgramFile>
-
+    
+    <!-- Makes xunit print all test names in stdout -->
+    <XunitOptions>$(XunitOptions) -diagnostics</XunitOptions>
+    
     <!-- Respect the traits set up by PlatformSpecific attribute. -->
     <XunitOptions Condition="'$(OsEnvironment)'=='windows'">$(XunitOptions) -notrait category=nonwindowstests</XunitOptions>
     <XunitOptions Condition="'$(OsEnvironment)'=='linux'">$(XunitOptions) -notrait category=nonlinuxtests</XunitOptions>
@@ -38,6 +41,10 @@
     <TestRunnerAdditionalArguments>$(XunitOptions)</TestRunnerAdditionalArguments>
     
     <PackageOutputPath Condition="'$(IsVisualStudioInsertionPackage)' == 'true'">$(DevDivPackagesDir)</PackageOutputPath>
+
+    <!-- Arcade sdk also carries an xunit.runner.json which sometimes overrides the one in this repo. Assign a value to the arcade properties XUnitDesktopSettingsFile and XUnitCoreSettingsFile to prevent the arcade version of the file being added. -->
+    <XUnitDesktopSettingsFile>$(MSBuildThisFileDirectory)Shared\UnitTests\xunit.runner.json</XUnitDesktopSettingsFile>
+    <XUnitCoreSettingsFile>$(XUnitDesktopSettingsFile)</XUnitCoreSettingsFile>
   </PropertyGroup>
 
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true'">
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index f233d9bc446..0d39dc25f6e 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -43,6 +43,9 @@
     <Compile Include="..\Shared\ExceptionHandling.cs" />
     <Compile Include="..\Shared\VisualStudioLocationHelper.cs" />
     <Compile Include="..\Shared\StringBuilderCache.cs" />
+    <Compile Include="..\Shared\IInternable.cs" />
+    <Compile Include="..\Shared\WeakStringCache.cs" />
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
     <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
     <Compile Include="..\Shared\UnitTests\AssemblyResources.cs" />
diff --git a/src/Framework.UnitTests/SdkReference_Tests.cs b/src/Framework.UnitTests/SdkReference_Tests.cs
index b4d641ca926..a6d9238c30a 100644
--- a/src/Framework.UnitTests/SdkReference_Tests.cs
+++ b/src/Framework.UnitTests/SdkReference_Tests.cs
@@ -84,9 +84,9 @@ public void VerifySdkReferenceEquality()
             sdk.ShouldNotBe(new SdkReference("Name", "Version", null));
             sdk.ShouldNotBe(new SdkReference("Name", null, "Min"));
             sdk.ShouldNotBe(new SdkReference("Name", null, null));
-            sdk.ShouldNotBe(new SdkReference("Name", "version", "Min"));
-            sdk.ShouldNotBe(new SdkReference("name", "Version", "Min"));
-            sdk.ShouldNotBe(new SdkReference("Name", "Version", "min"));
+            sdk.ShouldBe(new SdkReference("Name", "version", "Min"));
+            sdk.ShouldBe(new SdkReference("name", "Version", "Min"));
+            sdk.ShouldBe(new SdkReference("Name", "Version", "min"));
             sdk.ShouldNotBe(new SdkReference("Name2", "Version", "Min"));
         }
     }
diff --git a/src/Framework/IBuildEngine7.cs b/src/Framework/IBuildEngine7.cs
index 0d826f2ca14..025b60a6fbc 100644
--- a/src/Framework/IBuildEngine7.cs
+++ b/src/Framework/IBuildEngine7.cs
@@ -1,16 +1,16 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// This interface extends IBuildEngine6 to allow tasks and build scheduler to coordinate resource (cores) usage.
+    /// This interface extends <see cref="IBuildEngine6" /> to allow tasks to set whether they want to
+    /// log an error when a task returns without logging an error.
     /// </summary>
-
     public interface IBuildEngine7 : IBuildEngine6
     {
+        public bool AllowFailureWithoutError { get; set; }
+
         /// <summary>
         /// If a task launches multiple parallel processes, it should ask how many cores it can use.
         /// </summary>
@@ -24,5 +24,6 @@ public interface IBuildEngine7 : IBuildEngine6
         /// </summary>
         /// <param name="coresToRelease">Number of cores no longer in use.</param>
         void ReleaseCores(int coresToRelease);
+
     }
 }
diff --git a/src/Framework/Sdk/SdkReference.cs b/src/Framework/Sdk/SdkReference.cs
index 2fc413d4e65..9be25528bcc 100644
--- a/src/Framework/Sdk/SdkReference.cs
+++ b/src/Framework/Sdk/SdkReference.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Diagnostics;
 using System.Linq;
 using Microsoft.Build.Shared;
 
@@ -10,6 +11,7 @@ namespace Microsoft.Build.Framework
     /// <summary>
     ///     Represents a software development kit (SDK) that is referenced in a &lt;Project /&gt; or &lt;Import /&gt; element.
     /// </summary>
+    [DebuggerDisplay("Name={Name} Version={Version} MinimumVersion={MinimumVersion}")]
     public sealed class SdkReference : IEquatable<SdkReference>
     {
         /// <summary>
@@ -50,8 +52,9 @@ public bool Equals(SdkReference other)
         {
             if (ReferenceEquals(null, other)) return false;
             if (ReferenceEquals(this, other)) return true;
-            return string.Equals(Name, other.Name) && string.Equals(Version, other.Version) &&
-                   string.Equals(MinimumVersion, other.MinimumVersion);
+            return string.Equals(Name, other.Name, StringComparison.OrdinalIgnoreCase) &&
+                   string.Equals(Version, other.Version, StringComparison.OrdinalIgnoreCase) &&
+                   string.Equals(MinimumVersion, other.MinimumVersion, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -101,9 +104,9 @@ public override int GetHashCode()
         {
             unchecked
             {
-                var hashCode = (Name != null ? Name.GetHashCode() : 0);
-                hashCode = (hashCode * 397) ^ (Version != null ? Version.GetHashCode() : 0);
-                hashCode = (hashCode * 397) ^ (MinimumVersion != null ? MinimumVersion.GetHashCode() : 0);
+                var hashCode = (Name != null ? Name.ToLowerInvariant().GetHashCode() : 0);
+                hashCode = (hashCode * 397) ^ (Version != null ? Version.ToLowerInvariant().GetHashCode() : 0);
+                hashCode = (hashCode * 397) ^ (MinimumVersion != null ? MinimumVersion.ToLowerInvariant().GetHashCode() : 0);
                 return hashCode;
             }
         }
diff --git a/src/Framework/Sdk/SdkResult.cs b/src/Framework/Sdk/SdkResult.cs
index c98dfcf6281..12cf5db0eac 100644
--- a/src/Framework/Sdk/SdkResult.cs
+++ b/src/Framework/Sdk/SdkResult.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
+
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -12,17 +14,26 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public abstract class SdkResult
     {
+        //  Explicit backing fields so that implementation in Microsoft.Build.dll can use them for translation
+        private protected bool _success;
+        private protected string _path;
+        private protected string _version;
+        private protected IList<string> _additionalPaths;
+        private protected IDictionary<string, string> _propertiesToAdd;
+        private protected IDictionary<string, SdkResultItem> _itemsToAdd;
+        private protected SdkReference _sdkReference;
+
         /// <summary>
         ///     Indicates the resolution was successful.
         /// </summary>
-        public virtual bool Success { get; protected set; }
+        public virtual bool Success { get => _success; protected set => _success = value; }
 
         /// <summary>
         ///     Resolved path to the SDK.
         /// 
         ///     Null if <see cref="Success"/> == false
         /// </summary>
-        public virtual string Path { get; protected set; }
+        public virtual string Path { get => _path; protected set => _path = value; }
 
         /// <summary>
         ///     Resolved version of the SDK.
@@ -30,11 +41,29 @@ public abstract class SdkResult
         /// 
         ///     Null if <see cref="Success"/> == false
         /// </summary>
-        public virtual string Version { get; protected set; }
+        public virtual string Version { get => _version; protected set => _version = value; }
+
+        /// <summary>
+        /// Additional resolved SDK paths beyond the one specified in <see cref="Path"/>
+        /// </summary>
+        /// <remarks>
+        /// This allows an SDK resolver to return multiple SDK paths, which will all be imported.
+        /// </remarks>
+        public virtual IList<string> AdditionalPaths { get => _additionalPaths; set => _additionalPaths = value; }
+
+        /// <summary>
+        /// Properties that should be added to the evaluation.  This allows an SDK resolver to provide information to the build
+        /// </summary>
+        public virtual IDictionary<string, string> PropertiesToAdd { get => _propertiesToAdd; protected set => _propertiesToAdd = value; }
+
+        /// <summary>
+        /// Items that should be added to the evaluation.  This allows an SDK resolver to provide information to the build
+        /// </summary>
+        public virtual IDictionary<string, SdkResultItem> ItemsToAdd { get => _itemsToAdd; protected set => _itemsToAdd = value; }
 
         /// <summary>
         ///     The Sdk reference
         /// </summary>
-        public virtual SdkReference SdkReference { get; protected set; }
+        public virtual SdkReference SdkReference { get => _sdkReference; protected set => _sdkReference = value; }
     }
 }
diff --git a/src/Framework/Sdk/SdkResultFactory.cs b/src/Framework/Sdk/SdkResultFactory.cs
index cca970e6d0e..3ed0eda1700 100644
--- a/src/Framework/Sdk/SdkResultFactory.cs
+++ b/src/Framework/Sdk/SdkResultFactory.cs
@@ -20,6 +20,26 @@ public abstract class SdkResultFactory
         /// <returns></returns>
         public abstract SdkResult IndicateSuccess(string path, string version, IEnumerable<string> warnings = null);
 
+        /// <summary>
+        ///     Create an <see cref="SdkResolver" /> object indicating success.
+        /// </summary>
+        /// <remarks>
+        /// This overload allows any number (zero, one, or many) of SDK paths to be returned.  This means a "successful" result
+        /// may not resolve to any SDKs.  The resolver can also supply properties or items to communicate information to the build.  This
+        /// can allow resolvers to report SDKs that could not be resolved without hard-failing the evaluation, which can allow other
+        /// components to take more appropriate action (for example installing optional workloads or downloading NuGet SDKs).
+        /// </remarks>
+        /// <param name="paths">SDK paths which should be imported</param>
+        /// <param name="propertiesToAdd">Properties to set in the evaluation</param>
+        /// <param name="itemsToAdd">Items to add to the evaluation</param>
+        /// <param name="warnings">Optional warnings to display during resolution.</param>
+        /// <returns></returns>
+        public abstract SdkResult IndicateSuccess(IEnumerable<string> paths,
+            string version,
+            IDictionary<string, string> propertiesToAdd = null,
+            IDictionary<string, SdkResultItem> itemsToAdd = null,
+            IEnumerable<string> warnings = null);
+
         /// <summary>
         ///     Create an <see cref="SdkResolver" /> object indicating failure resolving the SDK.
         /// </summary>
diff --git a/src/Framework/Sdk/SdkResultItem.cs b/src/Framework/Sdk/SdkResultItem.cs
new file mode 100644
index 00000000000..0ed9de3114e
--- /dev/null
+++ b/src/Framework/Sdk/SdkResultItem.cs
@@ -0,0 +1,75 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// The value of an item and any associated metadata to be added by an SDK resolver.  See <see cref="SdkResult.ItemsToAdd"/>
+    /// </summary>
+    public class SdkResultItem
+    {
+        public string ItemSpec { get; set; }
+        public Dictionary<string, string> Metadata { get;}
+
+        public SdkResultItem()
+        {
+            Metadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+        }
+
+        /// <summary>
+        /// Creates an <see cref="SdkResultItem"/>
+        /// </summary>
+        /// <param name="itemSpec">The value (itemspec) for the item</param>
+        /// <param name="metadata">A dictionary of item metadata.  This should be created with <see cref="StringComparer.OrdinalIgnoreCase"/> for the comparer.</param>
+        public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)
+        {
+            ItemSpec = itemSpec;
+            Metadata = metadata;
+        }
+
+        public override bool Equals(object obj)
+        {
+            if (obj is SdkResultItem item &&
+                   ItemSpec == item.ItemSpec &&
+                   Metadata?.Count == item.Metadata?.Count)
+            {
+                if (Metadata != null)
+                {
+                    foreach (var kvp in Metadata)
+                    {
+                        if (item.Metadata[kvp.Key] != kvp.Value)
+                        {
+                            return false;
+                        }
+                    }
+                }
+
+                return true;
+            }
+            return false;
+        }
+
+        public override int GetHashCode()
+        {
+            int hashCode = -849885975;
+            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(ItemSpec);
+
+            if (Metadata != null)
+            {
+                foreach (var kvp in Metadata)
+                {
+                    hashCode = hashCode * -1521134295 + kvp.Key.GetHashCode();
+                    hashCode = hashCode * -1521134295 + kvp.Value.GetHashCode();
+                }
+            }
+
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Framework/TaskPropertyInfo.cs b/src/Framework/TaskPropertyInfo.cs
index 07567a482d2..eb5808ef40b 100644
--- a/src/Framework/TaskPropertyInfo.cs
+++ b/src/Framework/TaskPropertyInfo.cs
@@ -46,5 +46,20 @@ public TaskPropertyInfo(string name, Type typeOfParameter, bool output, bool req
         /// This task parameter is required (analogous to the [Required] attribute)
         /// </summary>
         public bool Required { get; private set; }
+
+        /// <summary>
+        /// This task parameter should be logged when LogTaskInputs is set. Defaults to true.
+        /// </summary>
+        public bool Log { get; set; } = true;
+
+        /// <summary>
+        /// When this task parameter is an item list, determines whether to log item metadata. Defaults to true.
+        /// </summary>
+        public bool LogItemMetadata { get; set; } = true;
+
+        /// <summary>
+        /// Whether the Log and LogItemMetadata properties have been assigned already.
+        /// </summary>
+        internal bool Initialized = false;
     }
 }
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index b2acd9e5646..6c4a2e79218 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -1215,7 +1215,7 @@ public void ResponseFileSupportsThisFileDirectory()
         /// <summary>
         /// Test that low priority builds actually execute with low priority.
         /// </summary>
-        [Fact]
+        [Fact(Skip = "https://github.com/microsoft/msbuild/issues/5229")]
         public void LowPriorityBuild()
         {
             RunPriorityBuildTest(expectedPrority: ProcessPriorityClass.BelowNormal, arguments: "/low");
@@ -1224,7 +1224,7 @@ public void LowPriorityBuild()
         /// <summary>
         /// Test that normal builds execute with normal priority.
         /// </summary>
-        [Fact]
+        [Fact(Skip = "https://github.com/microsoft/msbuild/issues/5229")]
         public void NormalPriorityBuild()
         {
             // In case we are already running at a  different priority, validate
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 75f5ca314aa..0d230763e6b 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -126,9 +126,13 @@
     <Compile Include="..\Shared\INodePacketHandler.cs" />
     <Compile Include="..\Shared\ITranslatable.cs" />
     <Compile Include="..\Shared\ITranslator.cs" />
+    <Compile Include="..\Shared\TranslatorHelpers.cs" />
     <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
+    <Compile Include="..\Shared\IInternable.cs" />
+    <Compile Include="..\Shared\WeakStringCache.cs" />
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
     <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
     <Compile Include="..\Shared\TaskHostTaskComplete.cs" />
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 9e1c7b7b557..3f21a504d85 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1141,6 +1141,16 @@ elementFormDefault="qualified">
             </xs:complexContent>
         </xs:complexType>
     </xs:element>
+    <xs:element name="AndroidResource" substitutionGroup="msb:Item">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="AndroidResource" _locComment="" -->Android resource files to be used within a Xamarin.Android project.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="ProguardConfiguration" substitutionGroup="msb:Item">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="ProguardConfiguration" _locComment="" -->ProGuard configuration files to be used within a Xamarin.Android project.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <!-- ======================== PROPERTIES =====================================-->
     <!-- Possible Types include StringPropertyType (text with no subelements), GenericPropertyType (any content), or something more specific.-->
 
@@ -2054,6 +2064,79 @@ elementFormDefault="qualified">
       </xs:annotation>
     </xs:element>
 
+    <!-- ======================== XAMARIN.ANDROID PROPERTIES ======================== -->
+
+    <xs:element name="AndroidApplication" type="msb:boolean" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidApplication" _locComment="" -->Used by Xamarin.Android projects. A boolean value that indicates whether the project is for an Android Application (True) or for an Android Library Project (False or not present).</xs:documentation>
+      </xs:annotation>
+    </xs:element>
+    <xs:element name="AndroidDexTool" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidDexTool" _locComment="" -->Used by Xamarin.Android projects. A string property that indicates which Android dex compiler is used during the Xamarin.Android build process.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="d8" />
+          <xs:enumeration value="dx" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
+    <xs:element name="AndroidEnableProfiledAot" type="msb:boolean" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidEnableProfiledAot" _locComment="" -->Used by Xamarin.Android projects. A boolean property that determines whether or not AOT profiles are used during Ahead-of-Time compilation.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
+    <xs:element name="AndroidLinkMode" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidLinkMode" _locComment="" -->Used by Xamarin.Android projects. A string property that specifies which type of linking should be performed on assemblies contained within the Android package. Only used in Android Application projects.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="None" />
+          <xs:enumeration value="SdkOnly" />
+          <xs:enumeration value="Full" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
+    <xs:element name="AndroidLinkTool" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidLinkTool" _locComment="" -->Used by Xamarin.Android projects. A string property that indicates which code shrinker is used for Java code.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="r8" />
+          <xs:enumeration value="proguard" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
+    <xs:element name="AndroidLinkSkip" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidLinkSkip" _locComment="" -->Used by Xamarin.Android projects. Specifies a semicolon-delimited (;) list of assembly names, without file extensions, of assemblies that should not be linked.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
+    <xs:element name="AndroidPackageFormat" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidPackageFormat" _locComment="" -->Used by Xamarin.Android projects. A string property that indicates if you want to package the Android application as an APK file or Android App Bundle.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="apk" />
+          <xs:enumeration value="aab" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
+    <xs:element name="AndroidSupportedAbis" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidSupportedAbis" _locComment="" -->Used by Xamarin.Android projects. A string property that contains a semicolon (;)-delimited list of ABIs which should be included into the application.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
+    <xs:element name="AotAssemblies" type="msb:boolean" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AotAssemblies" _locComment="" -->Used by Xamarin.Android projects. A boolean property that determines whether or not assemblies will be Ahead-of-Time compiled into native code.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
+
     <!-- ======================== TASKS =====================================-->
     <xs:element name="AL" substitutionGroup="msb:Task">
         <xs:complexType>
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index 622d8cef56a..e3ea73f69f8 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -32,8 +32,7 @@ internal NodeEndpointOutOfProcTaskHost(string pipeName)
         /// </summary>
         protected override long GetHostHandshake()
         {
-            long hostHandshake = CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetCurrentTaskHostContext());
-            return hostHandshake;
+            return CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
         }
 
         /// <summary>
@@ -41,8 +40,7 @@ protected override long GetHostHandshake()
         /// </summary>
         protected override long GetClientHandshake()
         {
-            long clientHandshake = CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetCurrentTaskHostContext());
-            return clientHandshake;
+            return CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
         }
     }
 }
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index f29eff427fb..da75a8716a6 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -37,7 +37,7 @@ internal class OutOfProcTaskHostNode :
 #if CLR2COMPATIBILITY
         IBuildEngine3
 #else
-        IBuildEngine6
+        IBuildEngine7
 #endif
     {
         /// <summary>
@@ -268,6 +268,13 @@ public bool IsRunningMultipleNodes
 
         #endregion // IBuildEngine2 Implementation (Properties)
 
+        #region IBuildEngine7 Implementation
+        /// <summary>
+        /// Enables or disables emitting a default error when a task fails without logging errors
+        /// </summary>
+        public bool AllowFailureWithoutError { get; set; } = true;
+        #endregion
+
         #region IBuildEngine Implementation (Methods)
 
         /// <summary>
@@ -455,7 +462,6 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
         }
 
         #endregion
-
 #endif
 
         #region INodePacketFactory Members
@@ -1166,5 +1172,15 @@ private void LogErrorFromResource(string messageResource)
 
             LogErrorEvent(error);
         }
+
+        public int RequestCores(int requestedCores)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void ReleaseCores(int coresToRelease)
+        {
+            throw new NotImplementedException();
+        }
     }
 }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index f4a29c07fab..31ea76ac5d5 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -626,10 +626,13 @@ string [] commandLine
                         Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
                     }
 
-                    // Honor the low priority flag, we place our selves below normal
-                    // priority and let sub processes inherit that priority.
-                    ProcessPriorityClass priority = lowPriority ? ProcessPriorityClass.BelowNormal : ProcessPriorityClass.Normal;
-                    Process.GetCurrentProcess().PriorityClass = priority;
+                    // Honor the low priority flag, we place our selves below normal priority and let sub processes inherit
+                    // that priority. Idle priority would prevent the build from proceeding as the user does normal actions.
+                    // We avoid increasing priority because that causes failures on mac/linux.
+                    if (lowPriority && Process.GetCurrentProcess().PriorityClass != ProcessPriorityClass.Idle)
+                    {
+                        Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.BelowNormal;
+                    }
 
                     DateTime t1 = DateTime.Now;
 
@@ -3740,7 +3743,7 @@ private static void ThrowInvalidToolsVersionInitializationException(IEnumerable<
         private static void DisplayCopyrightMessage()
         {
 #if RUNTIME_TYPE_NETCORE
-            const string frameworkName = ".NET Core";
+            const string frameworkName = ".NET";
 #elif MONO
             const string frameworkName = "Mono";
 #else
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 2e10ebdd3fd..4fcb3ad7d8d 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -92,6 +92,7 @@
     <Compile Include="..\Shared\ITranslator.cs">
       <Link>ITranslator.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\TranslatorHelpers.cs" />
     <Compile Include="..\Shared\InternalErrorException.cs">
       <Link>InternalErrorException.cs</Link>
     </Compile>
@@ -125,6 +126,12 @@
     <Compile Include="..\Shared\NodeShutdown.cs">
       <Link>NodeShutdown.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IInternable.cs">
+      <Link>IInternable.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.cs">
+      <Link>WeakStringCache.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\OpportunisticIntern.cs">
       <Link>OpportunisticIntern.cs</Link>
     </Compile>
@@ -158,6 +165,7 @@
     <Compile Include="Concurrent\ConcurrentQueue.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="TypeLoader.cs" />
+    <Compile Include="WeakStringCache.Locking.cs" />
     <Compile Include="..\MSBuild\LogMessagePacket.cs">
       <Link>LogMessagePacket.cs</Link>
     </Compile>
diff --git a/src/MSBuildTaskHost/WeakStringCache.Locking.cs b/src/MSBuildTaskHost/WeakStringCache.Locking.cs
new file mode 100644
index 00000000000..d26dd984963
--- /dev/null
+++ b/src/MSBuildTaskHost/WeakStringCache.Locking.cs
@@ -0,0 +1,125 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build
+{
+    /// <summary>
+    /// Implements the WeakStringCache functionality on .NET Framework 3.5 where ConcurrentDictionary is not available.
+    /// </summary>
+    internal sealed partial class WeakStringCache : IDisposable
+    {
+        private readonly Dictionary<int, StringWeakHandle> _stringsByHashCode;
+
+        public WeakStringCache()
+        {
+            _stringsByHashCode = new Dictionary<int, StringWeakHandle>(_initialCapacity);
+        }
+
+        /// <summary>
+        /// Main entrypoint of this cache. Tries to look up a string that matches the given internable. If it succeeds, returns
+        /// the string and sets cacheHit to true. If the string is not found, calls ExpensiveConvertToString on the internable,
+        /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
+        /// </summary>
+        /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <returns>A string matching the given internable.</returns>
+        public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IInternable
+        {
+            int hashCode = GetInternableHashCode(internable);
+
+            StringWeakHandle handle;
+            string result;
+            bool addingNewHandle = false;
+
+            lock (_stringsByHashCode)
+            {
+                if (_stringsByHashCode.TryGetValue(hashCode, out handle))
+                {
+                    result = handle.GetString(internable);
+                    if (result != null)
+                    {
+                        cacheHit = true;
+                        return result;
+                    }
+                }
+                else
+                {
+                    handle = new StringWeakHandle();
+                    addingNewHandle = true;
+                }
+
+                // We don't have the string in the cache - create it.
+                result = internable.ExpensiveConvertToString();
+
+                // Set the handle to reference the new string.
+                handle.SetString(result);
+
+                if (addingNewHandle)
+                {
+                    // Prevent the dictionary from growing forever with GC handles that don't reference live strings anymore.
+                    if (_stringsByHashCode.Count >= _scavengeThreshold)
+                    {
+                        // Get rid of unused handles.
+                        ScavengeNoLock();
+                        // And do this again when the number of handles reaches double the current after-scavenge number.
+                        _scavengeThreshold = _stringsByHashCode.Count * 2;
+                    }
+                }
+                _stringsByHashCode[hashCode] = handle;
+            }
+
+            cacheHit = false;
+            return result;
+        }
+
+        /// <summary>
+        /// Iterates over the cache and removes unused GC handles, i.e. handles that don't reference live strings.
+        /// This is expensive so try to call such that the cost is amortized to O(1) per GetOrCreateEntry() invocation.
+        /// Assumes the lock is taken by the caller.
+        /// </summary>
+        private void ScavengeNoLock()
+        {
+            List<int> keysToRemove = null;
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                if (!entry.Value.IsUsed)
+                {
+                    entry.Value.Free();
+                    keysToRemove ??= new List<int>();
+                    keysToRemove.Add(entry.Key);
+                }
+            }
+            if (keysToRemove != null)
+            {
+                for (int i = 0; i < keysToRemove.Count; i++)
+                {
+                    _stringsByHashCode.Remove(keysToRemove[i]);
+                }
+            }
+        }
+
+        /// <summary>
+        /// Public version of ScavengeUnderLock() which takes the lock.
+        /// </summary>
+        public void Scavenge()
+        {
+            lock (_stringsByHashCode)
+            {
+                ScavengeNoLock();
+            }
+        }
+
+        /// <summary>
+        /// Returns internal debug counters calculated based on the current state of the cache.
+        /// </summary>
+        public DebugInfo GetDebugInfo()
+        {
+            lock (_stringsByHashCode)
+            {
+                return GetDebugInfoImpl();
+            }
+        }
+    }
+}
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index e2ae215109f..f2132af28e6 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -30,6 +30,12 @@
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.Bcl.AsyncInterfaces.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Buffers.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Text.Encodings.Web.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Threading.Tasks.Extensions.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.ValueTuple.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Numerics.Vectors.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin" />
@@ -78,6 +84,12 @@
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.Bcl.AsyncInterfaces.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Buffers.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Text.Encodings.Web.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Threading.Tasks.Extensions.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.ValueTuple.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Numerics.Vectors.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin/amd64" />
diff --git a/src/Package/MSBuild.VSSetup/MSBuild.clientenabledpkg b/src/Package/MSBuild.VSSetup/MSBuild.clientenabledpkg
new file mode 100644
index 00000000000..489e2745d8c
--- /dev/null
+++ b/src/Package/MSBuild.VSSetup/MSBuild.clientenabledpkg
@@ -0,0 +1,7 @@
+Microsoft.Build.Framework.pkgdef
+Microsoft.Build.pkgdef
+Microsoft.Build.Tasks.Core.pkgdef
+System.Resources.Extensions.pkgdef
+Microsoft.Build.Utilities.Core.pkgdef
+Microsoft.Build.Conversion.Core.pkgdef
+Microsoft.Build.Engine.pkgdef
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index bdff4bb1c63..44277b783c7 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -38,6 +38,11 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.ValueTuple.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
@@ -182,6 +187,11 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.ValueTuple.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
@@ -305,8 +315,11 @@ folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hant
   file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
 
 folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
+  file source=$(SourceDir)Package\MSBuild.VSSetup\MSBuild.clientenabledpkg
   file source=$(SourceDir)Framework\Microsoft.Build.Framework.pkgdef
   file source=$(SourceDir)Build\Microsoft.Build.pkgdef
+  file source=$(SourceDir)Build\System.Text.Encodings.Web.pkgdef
+  file source=$(SourceDir)Build\System.Text.Json.pkgdef
   file source=$(SourceDir)Tasks\Microsoft.Build.Tasks.Core.pkgdef
   file source=$(SourceDir)Tasks\System.Resources.Extensions.pkgdef
   file source=$(SourceDir)Utilities\Microsoft.Build.Utilities.Core.pkgdef
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 3dce827846d..d8bd3da94f8 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -259,19 +259,19 @@ public void Translate(ref List<string> list)
             }
 
             /// <summary>
-            /// Translates a list of T where T implements INodePacketTranslateable
+            /// Translates a list of T using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
             /// <param name="list">The list to be translated.</param>
-            /// <param name="factory">Factory to deserialize T</param>
+            /// <param name="objectTranslator">The translator to use for the items in the list</param>
             /// <typeparam name="T">TaskItem type</typeparam>
-            public void Translate<T>(ref List<T> list, NodePacketValueFactory<T> factory) where T : ITranslatable
+            public void Translate<T>(ref List<T> list, ObjectTranslator<T> objectTranslator)
             {
                 IList<T> listAsInterface = list;
-                Translate(ref listAsInterface, factory, count => new List<T>(count));
+                Translate(ref listAsInterface, objectTranslator, count => new List<T>(count));
                 list = (List<T>) listAsInterface;
             }
 
-            public void Translate<T, L>(ref IList<T> list, NodePacketValueFactory<T> factory, NodePacketCollectionCreator<L> collectionFactory) where T : ITranslatable where L : IList<T>
+            public void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : IList<T>
             {
                 if (!TranslateNullable(list))
                 {
@@ -285,12 +285,7 @@ public void Translate<T, L>(ref IList<T> list, NodePacketValueFactory<T> factory
                 {
                     T value = default(T);
 
-                    if (!TranslateNullable(value))
-                    {
-                        continue;
-                    }
-
-                    value = factory(this);
+                    objectTranslator(this, ref value);
                     list.Add(value);
                 }
             }
@@ -444,24 +439,6 @@ public void Translate<T>(ref T value)
                 value.Translate(this);
             }
 
-            /// <summary>
-            /// Translates an object implementing INodePacketTranslatable which does not expose a
-            /// public parameterless constructor.
-            /// </summary>
-            /// <typeparam name="T">The reference type.</typeparam>
-            /// <param name="value">The value to be translated.</param>
-            /// <param name="factory">The factory method used to instantiate values of type T.</param>
-            public void Translate<T>(ref T value, NodePacketValueFactory<T> factory)
-                where T : ITranslatable
-            {
-                if (!TranslateNullable(value))
-                {
-                    return;
-                }
-
-                value = factory(this);
-            }
-
             /// <summary>
             /// Translates an array of objects implementing INodePacketTranslatable.
             /// </summary>
@@ -486,13 +463,12 @@ public void TranslateArray<T>(ref T[] array)
             }
 
             /// <summary>
-            /// Translates an array of objects implementing INodePacketTranslatable requiring a factory to create.
+            /// Translates an array of objects using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
             /// <typeparam name="T">The reference type.</typeparam>
             /// <param name="array">The array to be translated.</param>
-            /// <param name="factory">The factory method used to instantiate values of type T.</param>
-            public void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
-                where T : ITranslatable
+            /// <param name="objectTranslator">The translator to use for the elements in the array</param>
+            public void TranslateArray<T>(ref T[] array, ObjectTranslator<T> objectTranslator)
             {
                 if (!TranslateNullable(array))
                 {
@@ -504,7 +480,7 @@ public void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
 
                 for (int i = 0; i < count; i++)
                 {
-                    array[i] = factory(this);
+                    objectTranslator(this, ref array[i]);
                 }
             }
 
@@ -546,8 +522,8 @@ public void TranslateDictionary(ref IDictionary<string, string> dictionary, Node
 
             public void TranslateDictionary<K, V>(
                 ref IDictionary<K, V> dictionary,
-                Translator<K> keyTranslator,
-                Translator<V> valueTranslator,
+                ObjectTranslator<K> keyTranslator,
+                ObjectTranslator<V> valueTranslator,
                 NodePacketCollectionCreator<IDictionary<K, V>> dictionaryCreator)
             {
                 if (!TranslateNullable(dictionary))
@@ -561,9 +537,9 @@ public void TranslateDictionary<K, V>(
                 for (int i = 0; i < count; i++)
                 {
                     K key = default(K);
-                    keyTranslator.Invoke(ref key, this);
+                    keyTranslator(this, ref key);
                     V value = default(V);
-                    valueTranslator(ref value, this);
+                    valueTranslator(this, ref value);
                     dictionary[key] = value;
                 }
             }
@@ -571,12 +547,12 @@ public void TranslateDictionary<K, V>(
             /// <summary>
             /// Translates a dictionary of { string, T }.  
             /// </summary>
-            /// <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
+            /// <typeparam name="T">The reference type for the values</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
             /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-            public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, NodePacketValueFactory<T> valueFactory)
-                where T : class, ITranslatable
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
+            public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, ObjectTranslator<T> objectTranslator)
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -591,7 +567,7 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali
                     string key = null;
                     Translate(ref key);
                     T value = null;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                     dictionary[key] = value;
                 }
             }
@@ -602,10 +578,10 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali
             /// <typeparam name="D">The reference type for the dictionary.</typeparam>
             /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-            public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory)
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
+            public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator)
                 where D : IDictionary<string, T>, new()
-                where T : class, ITranslatable
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -620,7 +596,7 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
                     string key = null;
                     Translate(ref key);
                     T value = null;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                     dictionary[key] = value;
                 }
             }
@@ -631,11 +607,11 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
             /// <typeparam name="D">The reference type for the dictionary.</typeparam>
             /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
             /// <param name="dictionaryCreator">The delegate used to instantiate the dictionary.</param>
-            public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory, NodePacketCollectionCreator<D> dictionaryCreator)
+            public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<D> dictionaryCreator)
                 where D : IDictionary<string, T>
-                where T : class, ITranslatable
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -650,7 +626,7 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
                     string key = null;
                     Translate(ref key);
                     T value = null;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                     dictionary[key] = value;
                 }
             }
@@ -858,12 +834,12 @@ public void Translate(ref HashSet<string> set)
             }
 
             /// <summary>
-            /// Translates a list of T where T implements INodePacketTranslateable
+            /// Translates a list of T using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
             /// <param name="list">The list to be translated.</param>
-            /// <param name="factory">factory to create type T</param>
+            /// <param name="objectTranslator">The translator to use for the items in the list</param>
             /// <typeparam name="T">A TaskItemType</typeparam>
-            public void Translate<T>(ref List<T> list, NodePacketValueFactory<T> factory) where T : ITranslatable
+            public void Translate<T>(ref List<T> list, ObjectTranslator<T> objectTranslator)
             {
                 if (!TranslateNullable(list))
                 {
@@ -876,19 +852,19 @@ public void Translate<T>(ref List<T> list, NodePacketValueFactory<T> factory) wh
                 for (int i = 0; i < count; i++)
                 {
                     T value = list[i];
-                    Translate<T>(ref value, factory);
+                    objectTranslator(this, ref value);
                 }
             }
 
             /// <summary>
-            /// Translates a list of T where T implements INodePacketTranslateable
+            /// Translates a list of T using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
             /// <param name="list">The list to be translated.</param>
-            /// <param name="factory">factory to create type T</param>
+            /// <param name="objectTranslator">The translator to use for the items in the list</param>
             /// <param name="collectionFactory">factory to create the IList</param>
             /// <typeparam name="T">A TaskItemType</typeparam>
             /// <typeparam name="L">IList subtype</typeparam>
-            public void Translate<T, L>(ref IList<T> list, NodePacketValueFactory<T> factory, NodePacketCollectionCreator<L> collectionFactory) where T : ITranslatable where L : IList<T>
+            public void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : IList<T>
             {
                 if (!TranslateNullable(list))
                 {
@@ -901,7 +877,7 @@ public void Translate<T, L>(ref IList<T> list, NodePacketValueFactory<T> factory
                 for (int i = 0; i < count; i++)
                 {
                     T value = list[i];
-                    Translate<T>(ref value, factory);
+                    objectTranslator(this, ref value);
                 }
             }
 
@@ -1016,24 +992,6 @@ public void Translate<T>(ref T value)
                 value.Translate(this);
             }
 
-            /// <summary>
-            /// Translates an object implementing INodePacketTranslatable which does not expose a
-            /// public parameterless constructor.
-            /// </summary>
-            /// <typeparam name="T">The reference type.</typeparam>
-            /// <param name="value">The value to be translated.</param>
-            /// <param name="factory">The factory method used to instantiate values of type T.</param>
-            public void Translate<T>(ref T value, NodePacketValueFactory<T> factory)
-                where T : ITranslatable
-            {
-                if (!TranslateNullable(value))
-                {
-                    return;
-                }
-
-                value.Translate(this);
-            }
-
             /// <summary>
             /// Translates a byte array
             /// </summary>
@@ -1076,13 +1034,12 @@ public void TranslateArray<T>(ref T[] array)
             }
 
             /// <summary>
-            /// Translates an array of objects implementing INodePacketTranslatable requiring a factory to create.
+            /// Translates an array of objects using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
             /// <typeparam name="T">The reference type.</typeparam>
             /// <param name="array">The array to be translated.</param>
-            /// <param name="factory">The factory method used to instantiate values of type T.</param>
-            public void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
-                where T : ITranslatable
+            /// <param name="objectTranslator">The translator to use for the elements in the array</param>
+            public void TranslateArray<T>(ref T[] array, ObjectTranslator<T> objectTranslator)
             {
                 if (!TranslateNullable(array))
                 {
@@ -1094,7 +1051,7 @@ public void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
 
                 for (int i = 0; i < count; i++)
                 {
-                    array[i].Translate(this);
+                    objectTranslator(this, ref array[i]);
                 }
             }
 
@@ -1130,8 +1087,8 @@ public void TranslateDictionary(ref IDictionary<string, string> dictionary, Node
 
             public void TranslateDictionary<K, V>(
                 ref IDictionary<K, V> dictionary,
-                Translator<K> keyTranslator,
-                Translator<V> valueTranslator,
+                ObjectTranslator<K> keyTranslator,
+                ObjectTranslator<V> valueTranslator,
                 NodePacketCollectionCreator<IDictionary<K, V>> collectionCreator)
             {
                 if (!TranslateNullable(dictionary))
@@ -1145,9 +1102,9 @@ public void TranslateDictionary<K, V>(
                 foreach (KeyValuePair<K, V> pair in dictionary)
                 {
                     K key = pair.Key;
-                    keyTranslator.Invoke(ref key, this);
+                    keyTranslator(this, ref key);
                     V value = pair.Value;
-                    valueTranslator.Invoke(ref value, this);
+                    valueTranslator(this, ref value);
                 }
             }
 
@@ -1157,9 +1114,9 @@ public void TranslateDictionary<K, V>(
             /// <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
             /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-            public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, NodePacketValueFactory<T> valueFactory)
-                where T : class, ITranslatable
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
+            public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, ObjectTranslator<T> objectTranslator)
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -1174,7 +1131,7 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali
                     string key = pair.Key;
                     Translate(ref key);
                     T value = pair.Value;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                 }
             }
 
@@ -1184,10 +1141,10 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali
             /// <typeparam name="D">The reference type for the dictionary.</typeparam>
             /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-            public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory)
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
+            public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator)
                 where D : IDictionary<string, T>, new()
-                where T : class, ITranslatable
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -1202,7 +1159,7 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
                     string key = pair.Key;
                     Translate(ref key);
                     T value = pair.Value;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                 }
             }
 
@@ -1212,11 +1169,11 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
             /// <typeparam name="D">The reference type for the dictionary.</typeparam>
             /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
             /// <param name="dictionaryCreator">The delegate used to instantiate the dictionary.</param>
-            public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory, NodePacketCollectionCreator<D> dictionaryCreator)
+            public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<D> dictionaryCreator)
                 where D : IDictionary<string, T>
-                where T : class, ITranslatable
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -1231,7 +1188,7 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
                     string key = pair.Key;
                     Translate(ref key);
                     T value = pair.Value;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                 }
             }
 
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 9217837e7e6..35131046269 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -13,8 +13,6 @@
 
 using Microsoft.Build.Shared;
 using System.Reflection;
-using System.Security.Cryptography;
-using System.Text;
 
 #if !FEATURE_APM
 using System.Threading.Tasks;
@@ -23,34 +21,37 @@
 namespace Microsoft.Build.Internal
 {
     /// <summary>
-    /// Enumeration of all possible (currently supported) types of task host context.
+    /// Enumeration of all possible (currently supported) options for handshakes.
     /// </summary>
-    internal enum TaskHostContext
+    [Flags]
+    internal enum HandshakeOptions
     {
+        None = 0,
+
         /// <summary>
-        /// 32-bit Intel process, using the 2.0 CLR.
+        /// Process is a TaskHost
         /// </summary>
-        X32CLR2,
+        TaskHost = 1,
 
         /// <summary>
-        /// 64-bit Intel process, using the 2.0 CLR.
+        /// Using the 2.0 CLR
         /// </summary>
-        X64CLR2,
+        CLR2 = 2,
 
         /// <summary>
-        /// 32-bit Intel process, using the 4.0 CLR.
+        /// 64-bit Intel process
         /// </summary>
-        X32CLR4,
+        X64 = 4,
 
         /// <summary>
-        /// 64-bit Intel process, using the 4.0 CLR.
+        /// Node reuse enabled
         /// </summary>
-        X64CLR4,
+        NodeReuse = 8,
 
         /// <summary>
-        /// Invalid task host context
+        /// Building with BelowNormal priority
         /// </summary>
-        Invalid
+        LowPriority = 16
     }
 
     /// <summary>
@@ -292,9 +293,8 @@ internal static void SetEnvironment(IDictionary<string, string> newEnvironment)
 
         /// <summary>
         /// Given a base handshake, generates the real handshake based on e.g. elevation level.  
-        /// Client handshake required for comparison purposes only.  Returns the update handshake.  
         /// </summary>
-        internal static long GenerateHostHandshakeFromBase(long baseHandshake, long clientHandshake)
+        private static long GenerateHostHandshakeFromBase(long baseHandshake)
         {
 #if FEATURE_SECURITY_PRINCIPAL_WINDOWS
             // If we are running in elevated privs, we will only accept a handshake from an elevated process as well.
@@ -309,17 +309,12 @@ internal static long GenerateHostHandshakeFromBase(long baseHandshake, long clie
                 {
                     baseHandshake = baseHandshake ^ 0x5c5c5c5c5c5c5c5c + Process.GetCurrentProcess().SessionId;
                 }
-
-                if ((baseHandshake & 0x00FFFFFFFFFFFFFF) == clientHandshake)
-                {
-                    baseHandshake = ~baseHandshake;
-                }
             }
 #endif
 
-            // Mask out the first byte. That's because old
-            // builds used a single, non zero initial byte,
-            // and we don't want to risk communicating with them
+            // Mask out the first byte. Modern builds expect the first byte to be zero to indicate that they are modern
+            // and should be treated as such. Older builds used a non-zero initial byte. See here:
+            // https://github.com/microsoft/msbuild/blob/584ca5f11b28971f5651b4b8de5f173ad1cb2786/src/Shared/NodeEndpointOutOfProcBase.cs#L403.
             return baseHandshake & 0x00FFFFFFFFFFFFFF;
         }
 
@@ -327,23 +322,31 @@ internal static long GenerateHostHandshakeFromBase(long baseHandshake, long clie
         /// Magic number sent by the host to the client during the handshake.
         /// Derived from the binary timestamp to avoid mixing binary versions.
         /// </summary>
-        internal static long GetHostHandshake(TaskHostContext hostContext)
+        internal static long GetHostHandshake(HandshakeOptions nodeType)
         {
-            long baseHandshake = GenerateHostHandshakeFromBase(GetBaseHandshakeForContext(hostContext), GetClientHandshake(hostContext));
-            return baseHandshake;
+            string salt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+            string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
+            int nodeHandshakeSalt = GetHandshakeHashCode(salt + toolsDirectory);
+
+            Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", nodeType={2}, FileVersionHash={3}", salt, toolsDirectory, nodeType, FileVersionHash);
+
+            //FileVersionHash (32 bits) is shifted 8 bits to avoid session ID collision
+            //nodeType (4 bits) is shifted just after the FileVersionHash
+            //nodeHandshakeSalt (32 bits) is shifted just after hostContext
+            //the most significant byte (leftmost 8 bits) will get zero'd out to avoid connecting to older builds.
+            //| masked out | nodeHandshakeSalt | hostContext |              fileVersionHash             | SessionID
+            //  0000 0000     0000 0000 0000        0000        0000 0000 0000 0000 0000 0000 0000 0000   0000 0000
+            long baseHandshake = ((long)nodeHandshakeSalt << 44) | ((long)nodeType << 40) | ((long)FileVersionHash << 8);
+            return GenerateHostHandshakeFromBase(baseHandshake);
         }
 
         /// <summary>
         /// Magic number sent by the client to the host during the handshake.
         /// Munged version of the host handshake.
         /// </summary>
-        internal static long GetClientHandshake(TaskHostContext hostContext)
+        internal static long GetClientHandshake(HandshakeOptions hostContext)
         {
-            // Mask out the first byte. That's because old
-            // builds used a single, non zero initial byte,
-            // and we don't want to risk communicating with them
-            long clientHandshake = ((GetBaseHandshakeForContext(hostContext) ^ Int64.MaxValue) & 0x00FFFFFFFFFFFFFF);
-            return clientHandshake;
+            return ~GetHostHandshake(hostContext);
         }
 
         /// <summary>
@@ -369,13 +372,13 @@ internal static void WriteLongForHandshake(this PipeStream stream, long value)
         /// Extension method to read a series of bytes from a stream
         /// </summary>
         internal static long ReadLongForHandshake(this PipeStream stream
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
             , int handshakeReadTimeout
 #endif
             )
         {
             return stream.ReadLongForHandshake((byte[])null, 0
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
                 , handshakeReadTimeout
 #endif
                 );
@@ -387,14 +390,14 @@ internal static long ReadLongForHandshake(this PipeStream stream
         /// </summary>
         internal static long ReadLongForHandshake(this PipeStream stream, byte[] leadingBytesToReject,
             byte rejectionByteToReturn
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
             , int timeout
 #endif
             )
         {
             byte[] bytes = new byte[8];
 
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
             if (!NativeMethodsShared.IsWindows)
             {
                 // Enforce a minimum timeout because the Windows code can pass
@@ -488,86 +491,47 @@ internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int byte
 #endif
 
         /// <summary>
-        /// Given the appropriate information, return the equivalent TaskHostContext.  
+        /// Given the appropriate information, return the equivalent HandshakeOptions.
         /// </summary>
-        internal static TaskHostContext GetTaskHostContext(IDictionary<string, string> taskHostParameters)
+        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit = false, int clrVersion = 0, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
         {
-            ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.runtime), "Should always have an explicit runtime when we call this method.");
-            ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.architecture), "Should always have an explicit architecture when we call this method.");
-
-            string runtime = taskHostParameters[XMakeAttributes.runtime];
-            string architecture = taskHostParameters[XMakeAttributes.architecture];
-
-            bool is64BitProcess = false;
-            int clrVersion = 0;
+            HandshakeOptions context = taskHost ? HandshakeOptions.TaskHost : HandshakeOptions.None;
 
-            if (architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64, StringComparison.OrdinalIgnoreCase))
+            // We don't know about the TaskHost. Figure it out.
+            if (taskHost && clrVersion == 0)
             {
-                is64BitProcess = true;
+                // Take the current TaskHost context
+                if (taskHostParameters == null)
+                {
+                    clrVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version.Major;
+                    is64Bit = XMakeAttributes.GetCurrentMSBuildArchitecture().Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
+                }
+                else
+                {
+                    ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.runtime), "Should always have an explicit runtime when we call this method.");
+                    ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.architecture), "Should always have an explicit architecture when we call this method.");
+
+                    clrVersion = taskHostParameters[XMakeAttributes.runtime].Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;
+                    is64Bit = taskHostParameters[XMakeAttributes.architecture].Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
+                }
             }
-            else if (architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x86, StringComparison.OrdinalIgnoreCase))
+            if (is64Bit)
             {
-                is64BitProcess = false;
+                context |= HandshakeOptions.X64;
             }
-            else
+            if (clrVersion == 2)
             {
-                ErrorUtilities.ThrowInternalError("Should always have an explicit architecture when calling this method");
+                context |= HandshakeOptions.CLR2;
             }
-
-            if (runtime.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))
+            if (nodeReuse)
             {
-                clrVersion = 4;
+                context |= HandshakeOptions.NodeReuse;
             }
-            else if (runtime.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))
+            if (lowPriority)
             {
-                clrVersion = 2;
+                context |= HandshakeOptions.LowPriority;
             }
-            else
-            {
-                ErrorUtilities.ThrowInternalError("Should always have an explicit runtime when calling this method");
-            }
-
-            TaskHostContext hostContext = GetTaskHostContext(is64BitProcess, clrVersion);
-            return hostContext;
-        }
-
-        /// <summary>
-        /// Given the appropriate information, return the equivalent TaskHostContext.  
-        /// </summary>
-        internal static TaskHostContext GetTaskHostContext(bool is64BitProcess, int clrVersion)
-        {
-            TaskHostContext hostContext = TaskHostContext.Invalid;
-            switch (clrVersion)
-            {
-                case 2:
-                    hostContext = is64BitProcess ? TaskHostContext.X64CLR2 : TaskHostContext.X32CLR2;
-                    break;
-                case 4:
-                    hostContext = is64BitProcess ? TaskHostContext.X64CLR4 : TaskHostContext.X32CLR4;
-                    break;
-                default:
-                    ErrorUtilities.ThrowInternalErrorUnreachable();
-                    hostContext = TaskHostContext.Invalid;
-                    break;
-            }
-
-            return hostContext;
-        }
-
-        /// <summary>
-        /// Returns the TaskHostContext corresponding to this process
-        /// </summary>
-        internal static TaskHostContext GetCurrentTaskHostContext()
-        {
-            // We know that whichever assembly is executing this code -- whether it's MSBuildTaskHost.exe or 
-            // Microsoft.Build.dll -- is of the version of the CLR that this process is running.  So grab
-            // the version of mscorlib currently in use and call that good enough.  
-            Version mscorlibVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version;
-
-            string currentMSBuildArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
-            TaskHostContext hostContext = GetTaskHostContext(currentMSBuildArchitecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64), mscorlibVersion.Major);
-
-            return hostContext;
+            return context;
         }
 
         /// <summary>
@@ -645,31 +609,6 @@ internal static void Trace(int nodeId, string format, params object[] args)
             }
         }
 
-        /// <summary>
-        /// Add the task host context to this handshake, to make sure that task hosts with different contexts 
-        /// will have different handshakes. Shift it into the upper 32-bits to avoid running into the 
-        /// session ID. The connection may be salted to allow MSBuild to only connect to nodes that come from the same
-        /// test environment.
-        /// </summary>
-        /// <param name="hostContext">TaskHostContext</param>
-        /// <returns>Base Handshake</returns>
-        private static long GetBaseHandshakeForContext(TaskHostContext hostContext)
-        {
-            string salt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT") + BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
-            long nodeHandshakeSalt = GetHandshakeHashCode(salt);
-
-            Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", hostContext={2}, FileVersionHash={3}", Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT"), BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, hostContext, FileVersionHash);
-
-            //FileVersionHash (32 bits) is shifted 8 bits to avoid session ID collision
-            //hostContext (4 bits) is shifted just after the FileVersionHash
-            //nodeHandshakeSalt (32 bits) is shifted just after hostContext
-            //the most significant byte (leftmost 8 bits) will get zero'd out to avoid connecting to older builds.
-            //| masked out | nodeHandshakeSalt | hostContext |              fileVersionHash             | SessionID
-            //  0000 0000     0000 0000 0000        0000        0000 0000 0000 0000 0000 0000 0000 0000   0000 0000
-            long baseHandshake = (nodeHandshakeSalt << 44) | ((long)hostContext << 40) | ((long)FileVersionHash << 8);
-            return baseHandshake;
-        }
-
         /// <summary>
         /// Gets a hash code for this string.  If strings A and B are such that A.Equals(B), then
         /// they will return the same hash code.
@@ -677,7 +616,7 @@ private static long GetBaseHandshakeForContext(TaskHostContext hostContext)
         /// but stripped out architecture specific defines
         /// that causes the hashcode to be different and this causes problem in cross-architecture handshaking
         /// </summary>
-        private static int GetHandshakeHashCode(string fileVersion)
+        internal static int GetHandshakeHashCode(string fileVersion)
         {
             unsafe
             {
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index eb27fe8b372..14cf1d2d866 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -38,6 +38,16 @@ internal static bool ConvertStringToBool(string parameterValue)
             }
         }
 
+        internal static bool ConvertStringToBool(string parameterValue, bool nullOrWhitespaceIsFalse)
+        {
+            if (nullOrWhitespaceIsFalse && string.IsNullOrWhiteSpace(parameterValue))
+            {
+                return false;
+            }
+
+            return ConvertStringToBool(parameterValue);
+        }
+
         /// <summary>
         /// Returns a hex representation of a byte array.
         /// </summary>
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 9e170951cb3..641980fc490 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -84,6 +84,19 @@ internal static void ThrowInternalErrorUnreachable()
             }
         }
 
+        /// <summary>
+        /// Throws InternalErrorException. 
+        /// Indicates the code path followed should not have been possible.
+        /// This is only for situations that would mean that there is a bug in MSBuild itself.
+        /// </summary>
+        internal static void VerifyThrowInternalErrorUnreachable(bool condition)
+        {
+            if (s_throwExceptions && !condition)
+            {
+                throw new InternalErrorException("Unreachable?");
+            }
+        }
+
         /// <summary>
         /// Throws InternalErrorException. 
         /// Indicates the code path followed should not have been possible.
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index be4f2f5cd6e..a02cf5c4582 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -977,12 +977,21 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
         }
 
         /// <summary>
-        /// This method returns true if the specified filename is a solution file (.sln), otherwise
-        /// it returns false.
+        /// This method returns true if the specified filename is a solution file (.sln) or
+        /// solution filter file (.slnf); otherwise, it returns false.
         /// </summary>
+        /// <remarks>
+        /// Solution filters are included because they are a thin veneer over solutions, just
+        /// with a more limited set of projects to build, and should be treated the same way.
+        /// </remarks>
         internal static bool IsSolutionFilename(string filename)
         {
-            return HasExtension(filename, ".sln");
+            return HasExtension(filename, ".sln") || HasExtension(filename, ".slnf");
+        }
+
+        internal static bool IsSolutionFilterFilename(string filename)
+        {
+            return HasExtension(filename, ".slnf");
         }
 
         /// <summary>
diff --git a/src/Shared/IInternable.cs b/src/Shared/IInternable.cs
new file mode 100644
index 00000000000..f4f810f8f2e
--- /dev/null
+++ b/src/Shared/IInternable.cs
@@ -0,0 +1,341 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Text;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build
+{
+    #region IInternable
+    /// <summary>
+    /// Define the methods needed to intern something.
+    /// </summary>
+    internal interface IInternable
+    {
+        /// <summary>
+        /// The length of the target.
+        /// </summary>
+        int Length { get; }
+
+        /// <summary>
+        /// Indexer into the target. Presumed to be fast.
+        /// </summary>
+        char this[int index] { get; }
+
+        /// <summary>
+        /// Convert target to string. Presumed to be slow (and will be called just once).
+        /// </summary>
+        string ExpensiveConvertToString();
+
+        /// <summary>
+        /// Compare target to string. Assumes string is of equal or smaller length than target.
+        /// </summary>
+        bool StartsWithStringByOrdinalComparison(string other);
+
+        /// <summary>
+        /// Reference compare target to string. If target is non-string this should return false.
+        /// </summary>
+        bool ReferenceEquals(string other);
+    }
+    #endregion
+
+
+    #region IInternable Implementations
+    /// <summary>
+    /// A wrapper over StringBuilder.
+    /// </summary>
+    internal readonly struct StringBuilderInternTarget : IInternable
+    {
+        /// <summary>
+        /// The held StringBuilder
+        /// </summary>
+        private readonly StringBuilder _target;
+
+        /// <summary>
+        /// Pointless comment about constructor.
+        /// </summary>
+        internal StringBuilderInternTarget(StringBuilder target)
+        {
+            _target = target;
+        }
+
+        /// <summary>
+        /// The length of the target.
+        /// </summary>
+        public int Length => _target.Length;
+
+        /// <summary>
+        /// Indexer into the target. Presumed to be fast.
+        /// </summary>
+        public char this[int index] => _target[index];
+
+        /// <summary>
+        /// Never reference equals to string.
+        /// </summary>
+        public bool ReferenceEquals(string other) => false;
+
+        /// <summary>
+        /// Convert target to string. Presumed to be slow (and will be called just once).
+        /// </summary>
+        public string ExpensiveConvertToString()
+        {
+            // PERF NOTE: This will be an allocation hot-spot because the StringBuilder is finally determined to
+            // not be internable. There is still only one conversion of StringBuilder into string it has just
+            // moved into this single spot.
+            return _target.ToString();
+        }
+
+        /// <summary>
+        /// Compare target to string. Assumes string is of equal or smaller length than target.
+        /// </summary>
+        public bool StartsWithStringByOrdinalComparison(string other)
+        {
+#if DEBUG
+            ErrorUtilities.VerifyThrow(other.Length <= _target.Length, "should be at most as long as target");
+#endif
+            int length = other.Length;
+
+            // Backwards because the end of the string is more likely to be different earlier in the loop.
+            // For example, C:\project1, C:\project2
+            for (int i = length - 1; i >= 0; --i)
+            {
+                if (_target[i] != other[i])
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Don't use this function. Use ExpensiveConvertToString
+        /// </summary>
+        public override string ToString() => throw new InvalidOperationException();
+    }
+
+    /// <summary>
+    /// A wrapper over char[].
+    /// </summary>
+    internal readonly struct CharArrayInternTarget : IInternable
+    {
+        /// <summary>
+        /// Start index for the string
+        /// </summary>
+        private readonly int _startIndex;
+
+        /// <summary>
+        /// The held array
+        /// </summary>
+        private readonly char[] _target;
+
+        /// <summary>
+        /// Pointless comment about constructor.
+        /// </summary>
+        internal CharArrayInternTarget(char[] target, int count)
+            : this(target, 0, count)
+        {
+        }
+
+        /// <summary>
+        /// Pointless comment about constructor.
+        /// </summary>
+        internal CharArrayInternTarget(char[] target, int startIndex, int count)
+        {
+#if DEBUG
+            if (startIndex + count > target.Length)
+            {
+                ErrorUtilities.ThrowInternalError("wrong length");
+            }
+#endif
+            _target = target;
+            _startIndex = startIndex;
+            Length = count;
+        }
+
+        /// <summary>
+        /// The length of the target.
+        /// </summary>
+        public int Length { get; }
+
+        /// <summary>
+        /// Indexer into the target. Presumed to be fast.
+        /// </summary>
+        public char this[int index]
+        {
+            get
+            {
+                return _target[index + _startIndex];
+            }
+        }
+
+        /// <summary>
+        /// Convert target to string. Presumed to be slow (and will be called just once).
+        /// </summary>
+        public bool ReferenceEquals(string other)
+        {
+            return false;
+        }
+
+        /// <summary>
+        /// Convert target to string. Presumed to be slow (and will be called just once).
+        /// </summary>
+        public string ExpensiveConvertToString()
+        {
+            // PERF NOTE: This will be an allocation hot-spot because the char[] is finally determined to
+            // not be internable. There is still only one conversion of char[] into string it has just
+            // moved into this single spot.
+            return new string(_target, _startIndex, Length);
+        }
+
+        /// <summary>
+        /// Compare target to string. Assumes string is of equal or smaller length than target.
+        /// </summary>
+        public bool StartsWithStringByOrdinalComparison(string other)
+        {
+#if DEBUG
+            ErrorUtilities.VerifyThrow(other.Length <= Length, "should be at most as long as target");
+#endif
+            // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
+            // For example, C:\project1, C:\project2
+            for (int i = other.Length - 1; i >= 0; --i)
+            {
+                if (_target[i + _startIndex] != other[i])
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Don't use this function. Use ExpensiveConvertToString
+        /// </summary>
+        public override string ToString()
+        {
+            throw new InvalidOperationException();
+        }
+    }
+
+    /// <summary>
+    /// Wrapper over a string.
+    /// </summary>
+    internal readonly struct StringInternTarget : IInternable
+    {
+        /// <summary>
+        /// Stores the wrapped string.
+        /// </summary>
+        private readonly string _target;
+
+        /// <summary>
+        /// Constructor of the class
+        /// </summary>
+        /// <param name="target">The string to wrap</param>
+        internal StringInternTarget(string target)
+        {
+            ErrorUtilities.VerifyThrowArgumentLength(target, nameof(target));
+            _target = target;
+        }
+
+        /// <summary>
+        /// Gets the length of the target string.
+        /// </summary>
+        public int Length => _target.Length;
+
+        /// <summary>
+        /// Gets the n character in the target string.
+        /// </summary>
+        /// <param name="index">Index of the character to gather.</param>
+        /// <returns>The character in the position marked by index.</returns>
+        public char this[int index] => _target[index];
+
+        /// <summary>
+        /// Returns the target which is already a string.
+        /// </summary>
+        /// <returns>The target string.</returns>
+        public string ExpensiveConvertToString() => _target;
+
+        /// <summary>
+        /// Compare target to string. Assumes string is of equal or smaller length than target.
+        /// </summary>
+        /// <param name="other">The string to compare with the target.</param>
+        /// <returns>True if target starts with <paramref name="other"/>, false otherwise.</returns>
+        public bool StartsWithStringByOrdinalComparison(string other) => _target.StartsWith(other, StringComparison.Ordinal);
+
+        /// <summary>
+        /// Verifies if the reference of the target string is the same of the given string.
+        /// </summary>
+        /// <param name="other">The string reference to compare to.</param>
+        /// <returns>True if both references are equal, false otherwise.</returns>
+        public bool ReferenceEquals(string other) => ReferenceEquals(_target, other);
+    }
+
+    /// <summary>
+    /// Wrapper over a substring of a string.
+    /// </summary>
+    internal readonly struct SubstringInternTarget : IInternable
+    {
+        /// <summary>
+        /// Stores the wrapped string.
+        /// </summary>
+        private readonly string _target;
+
+        /// <summary>
+        /// Start index of the substring within the wrapped string.
+        /// </summary>
+        private readonly int _startIndex;
+
+        /// <summary>
+        /// Constructor of the class
+        /// </summary>
+        /// <param name="target">The string to wrap.</param>
+        /// <param name="startIndex">Start index of the substring within <paramref name="target"/>.</param>
+        /// <param name="length">Length of the substring.</param>
+        internal SubstringInternTarget(string target, int startIndex, int length)
+        {
+#if DEBUG
+            if (startIndex + length > target.Length)
+            {
+                ErrorUtilities.ThrowInternalError("wrong length");
+            }
+#endif
+            _target = target;
+            _startIndex = startIndex;
+            Length = length;
+        }
+
+        /// <summary>
+        /// Gets the length of the target substring.
+        /// </summary>
+        public int Length { get; }
+
+        /// <summary>
+        /// Gets the n character in the target substring.
+        /// </summary>
+        /// <param name="index">Index of the character to gather.</param>
+        /// <returns>The character in the position marked by index.</returns>
+        public char this[int index] => _target[index + _startIndex];
+
+        /// <summary>
+        /// Returns the target substring as a string.
+        /// </summary>
+        /// <returns>The substring.</returns>
+        public string ExpensiveConvertToString() => _target.Substring(_startIndex, Length);
+
+        /// <summary>
+        /// Compare target substring to a string. Assumes string is of equal or smaller length than the target substring.
+        /// </summary>
+        /// <param name="other">The string to compare with the target substring.</param>
+        /// <returns>True if target substring starts with <paramref name="other"/>, false otherwise.</returns>
+        public bool StartsWithStringByOrdinalComparison(string other) => (String.CompareOrdinal(_target, _startIndex, other, 0, other.Length) == 0);
+
+        /// <summary>
+        /// Never reference equals to string.
+        /// </summary>
+        public bool ReferenceEquals(string other) => false;
+    }
+
+    #endregion
+}
diff --git a/src/Shared/ITranslatable.cs b/src/Shared/ITranslatable.cs
index 1ddeb30a6f6..a235e30aa2e 100644
--- a/src/Shared/ITranslatable.cs
+++ b/src/Shared/ITranslatable.cs
@@ -3,13 +3,6 @@
 
 namespace Microsoft.Build.BackEnd
 {
-    /// <summary>
-    /// Delegate for users that want to translate an arbitrary structure that cannot implement <see cref="ITranslatable"/> (e.g. translating a complex collection)
-    /// </summary>
-    /// <param name="translator">the translator</param>
-    /// <param name="obj">the object to translate</param>
-    internal delegate void Translator<T>(ref T obj, ITranslator translator);
-
     /// <summary>
     /// An interface representing an object which may be serialized by the node packet serializer.
     /// </summary>
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 088ffef172d..47b7770b797 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -16,6 +16,13 @@ namespace Microsoft.Build.BackEnd
     /// <typeparam name="T">The type to be translated.</typeparam>
     internal delegate T NodePacketValueFactory<T>(ITranslator translator);
 
+    /// <summary>
+    /// Delegate for users that want to translate an arbitrary structure that doesn't implement <see cref="ITranslatable"/> (e.g. translating a complex collection)
+    /// </summary>
+    /// <param name="translator">the translator</param>
+    /// <param name="objectToTranslate">the object to translate</param>
+    internal delegate void ObjectTranslator<T>(ITranslator translator, ref T objectToTranslate);
+
     /// <summary>
     /// This delegate is used to create arbitrary collection types for serialization.
     /// </summary>
@@ -156,22 +163,22 @@ BinaryWriter Writer
         void Translate(ref HashSet<string> set);
 
         /// <summary>
-        /// Translates a list of T where T implements INodePacketTranslateable
+        /// Translates a list of T using an <see cref="ObjectTranslator{T}"/>
         /// </summary>
         /// <param name="list">The list to be translated.</param>
-        /// <param name="factory">factory to create type T</param>
+        /// <param name="objectTranslator">The translator to use for the items in the list</param>
         /// <typeparam name="T">A TaskItemType</typeparam>
-        void Translate<T>(ref List<T> list, NodePacketValueFactory<T> factory) where T : ITranslatable;
+        void Translate<T>(ref List<T> list, ObjectTranslator<T> objectTranslator);
 
         /// <summary>
-        /// Translates a list of T where T implements INodePacketTranslateable using a collection factory
+        /// Translates a list of T using an <see cref="ObjectTranslator{T}"/> anda collection factory
         /// </summary>
         /// <param name="list">The list to be translated.</param>
-        /// <param name="factory">factory to create type T</param>
+        /// <param name="objectTranslator">The translator to use for the items in the list</param>
         /// <typeparam name="T">An ITranslatable subtype</typeparam>
         /// <typeparam name="L">An IList subtype</typeparam>
         /// <param name="collectionFactory">factory to create a collection</param>
-        void Translate<T, L>(ref IList<T> list, NodePacketValueFactory<T> factory, NodePacketCollectionCreator<L> collectionFactory) where T : ITranslatable where L : IList<T>;
+        void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : IList<T>;
 
         /// <summary>
         /// Translates a DateTime.
@@ -240,16 +247,6 @@ BinaryWriter Writer
         void Translate<T>(ref T value)
             where T : ITranslatable, new();
 
-        /// <summary>
-        /// Translates an object implementing INodePacketTranslatable which does not expose a
-        /// public parameterless constructor.
-        /// </summary>
-        /// <typeparam name="T">The reference type.</typeparam>
-        /// <param name="value">The value to be translated.</param>
-        /// <param name="factory">The factory method used to instantiate values of type T.</param>
-        void Translate<T>(ref T value, NodePacketValueFactory<T> factory)
-            where T : ITranslatable;
-
         /// <summary>
         /// Translates a culture
         /// </summary>
@@ -271,13 +268,12 @@ void TranslateArray<T>(ref T[] array)
             where T : ITranslatable, new();
 
         /// <summary>
-        /// Translates an array of objects implementing INodePacketTranslatable requiring a factory to create.
+        /// Translates an array of objects using an <see cref="ObjectTranslator{T}"/>.
         /// </summary>
         /// <typeparam name="T">The reference type.</typeparam>
         /// <param name="array">The array to be translated.</param>
-        /// <param name="factory">The factory method used to instantiate values of type T.</param>
-        void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
-            where T : ITranslatable;
+        /// <param name="objectTranslator">The translator to use for the elements in the array.</param>
+        void TranslateArray<T>(ref T[] array, ObjectTranslator<T> objectTranslator);
 
         /// <summary>
         /// Translates a dictionary of { string, string }.
@@ -288,7 +284,7 @@ void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
 
         void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> collectionCreator);
 
-        void TranslateDictionary<K, V>(ref IDictionary<K, V> dictionary, Translator<K> keyTranslator, Translator<V> valueTranslator, NodePacketCollectionCreator<IDictionary<K, V>> dictionaryCreator);
+        void TranslateDictionary<K, V>(ref IDictionary<K, V> dictionary, ObjectTranslator<K> keyTranslator, ObjectTranslator<V> valueTranslator, NodePacketCollectionCreator<IDictionary<K, V>> dictionaryCreator);
 
         /// <summary>
         /// Translates a dictionary of { string, T }.  
@@ -296,9 +292,9 @@ void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
         /// <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
         /// <param name="dictionary">The dictionary to be translated.</param>
         /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
-        /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-        void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, NodePacketValueFactory<T> valueFactory)
-            where T : class, ITranslatable;
+        /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
+        void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, ObjectTranslator<T> objectTranslator)
+            where T : class;
 
         /// <summary>
         /// Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.
@@ -306,10 +302,10 @@ void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityCompa
         /// <typeparam name="D">The reference type for the dictionary.</typeparam>
         /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
         /// <param name="dictionary">The dictionary to be translated.</param>
-        /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-        void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory)
+        /// <param name="objectTranslator">The translator to use for the values in the dictionary.</param>
+        void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator)
             where D : IDictionary<string, T>, new()
-            where T : class, ITranslatable;
+            where T : class;
 
         /// <summary>
         /// Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.
@@ -317,11 +313,11 @@ void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> value
         /// <typeparam name="D">The reference type for the dictionary.</typeparam>
         /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
         /// <param name="dictionary">The dictionary to be translated.</param>
-        /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
+        /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
         /// <param name="collectionCreator">A factory used to create the dictionary.</param>
-        void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory, NodePacketCollectionCreator<D> collectionCreator)
+        void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<D> collectionCreator)
             where D : IDictionary<string, T>
-            where T : class, ITranslatable;
+            where T : class;
 
         /// <summary>
         /// Translates the boolean that says whether this value is null or not
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index c2f69cf67c5..6bc94246966 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -670,6 +670,11 @@ internal static string GetOSNameForExtensionsPath()
             return IsOSX ? "osx" : IsUnixLike ? "unix" : "windows";
         }
 
+        internal static bool OSUsesCaseSensitivePaths
+        {
+            get { return IsLinux; }
+        }
+
         /// <summary>
         /// The base directory for all framework paths in Mono
         /// </summary>
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 8278f878092..8f24e1c56c8 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -38,12 +38,12 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
     {
         #region Private Data
 
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
         /// <summary>
         /// The amount of time to wait for the client to connect to the host.
         /// </summary>
         private const int ClientConnectTimeout = 60000;
-#endif // NETCOREAPP2_1
+#endif // NETCOREAPP2_1 || MONO
 
         /// <summary>
         /// The size of the buffers to use for named pipes
@@ -401,7 +401,7 @@ private void PacketPumpProc()
                     try
                     {
                         long handshake = localReadPipe.ReadLongForHandshake(/* reject these leads */ new byte[] { 0x5F, 0x60 }, 0xFF /* this will disconnect the host; it expects leading 00 or F5 or 06 */
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
                             , ClientConnectTimeout /* wait a long time for the handshake from this side */
 #endif
                             );
diff --git a/src/Shared/OpportunisticIntern.cs b/src/Shared/OpportunisticIntern.cs
index 7761a103d8d..6da9e42a34c 100644
--- a/src/Shared/OpportunisticIntern.cs
+++ b/src/Shared/OpportunisticIntern.cs
@@ -21,116 +21,138 @@ namespace Microsoft.Build
     ///
     ///     string interned = OpportunisticIntern.Intern(String.Join(",",someStrings));
     ///
-    /// This class uses heuristics to decide whether it will be efficient to intern a string or not. There is no
+    /// There are currently two underlying implementations. The new default one in WeakStringCacheInterner is based on weak GC handles.
+    /// The legacy one in BucketedPrioritizedStringList is available only as an escape hatch by setting an environment variable.
+    ///
+    /// The legacy implementation uses heuristics to decide whether it will be efficient to intern a string or not. There is no
     /// guarantee that a string will intern.
     ///
     /// The thresholds and sizes were determined by experimentation to give the best number of bytes saved
     /// at reasonable elapsed time cost.
+    ///
+    /// The new implementation interns all strings but maintains only weak references so it doesn't keep the strings alive.
     /// </summary>
-    internal static class OpportunisticIntern
+    internal sealed class OpportunisticIntern
     {
-        private static readonly bool s_useSimpleConcurrency = Traits.Instance.UseSimpleInternConcurrency;
+        /// <summary>
+        /// Defines the interner interface as we currently implement more than one.
+        /// </summary>
+        private interface IInternerImplementation
+        {
+            /// <summary>
+            /// Converts the given internable candidate to its string representation. Efficient implementions have side-effects
+            /// of caching the results to end up with as few duplicates on the managed heap as practical.
+            /// </summary>
+            string InterningToString<T>(T candidate) where T : IInternable;
+
+            /// <summary>
+            /// Prints implementation specific interning statistics to the console.
+            /// </summary>
+            /// <param name="heading">A string identifying the interner in the output.</param>
+            void ReportStatistics(string heading);
+        }
+
+        /// <summary>
+        /// The singleton instance of OpportunisticIntern.
+        /// </summary>
+        private static OpportunisticIntern _instance = new OpportunisticIntern();
+        internal static OpportunisticIntern Instance => _instance;
+
+        private readonly bool _useLegacyInterner = Traits.Instance.UseLegacyStringInterner;
+        private readonly bool _useSimpleConcurrency = Traits.Instance.UseSimpleInternConcurrency;
 
         /// <summary>
         /// The size of the small mru list.
         /// </summary>
-        private static readonly int s_smallMruSize = AssignViaEnvironment("MSBUILDSMALLINTERNSIZE", 50);
+        private readonly int _smallMruSize;
 
         /// <summary>
         /// The size of the large mru list.
         /// </summary>
-        private static readonly int s_largeMruSize = AssignViaEnvironment("MSBUILDLARGEINTERNSIZE", 100);
+        private readonly int _largeMruSize;
 
         /// <summary>
         /// The size of the huge mru list.
         /// </summary>
-        private static readonly int s_hugeMruSize = AssignViaEnvironment("MSBUILDHUGEINTERNSIZE", 100);
+        private readonly int _hugeMruSize;
 
         /// <summary>
         /// The smallest size a string can be to be considered small.
         /// </summary>
-        private static readonly int s_smallMruThreshold = AssignViaEnvironment("MSBUILDSMALLINTERNTHRESHOLD", 50);
+        private readonly int _smallMruThreshold;
 
         /// <summary>
         /// The smallest size a string can be to be considered large.
         /// </summary>
-        private static readonly int s_largeMruThreshold = AssignViaEnvironment("MSBUILDLARGEINTERNTHRESHOLD", 70);
+        private readonly int _largeMruThreshold;
 
         /// <summary>
         /// The smallest size a string can be to be considered huge.
         /// </summary>
-        private static readonly int s_hugeMruThreshold = AssignViaEnvironment("MSBUILDHUGEINTERNTHRESHOLD", 200);
+        private readonly int _hugeMruThreshold;
 
         /// <summary>
         /// The smallest size a string can be to be ginormous.
         /// 8K for large object heap.
         /// </summary>
-        private static readonly int s_ginormousThreshold = AssignViaEnvironment("MSBUILDGINORMOUSINTERNTHRESHOLD", 8000);
+        private readonly int _ginormousThreshold;
 
         /// <summary>
-        /// Manages the separate MRU lists.
+        /// The interner implementation in use.
         /// </summary>
-        private static BucketedPrioritizedStringList s_si = new BucketedPrioritizedStringList(/*gatherStatistics*/ false, s_smallMruSize, s_largeMruSize, s_hugeMruSize, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
+        private IInternerImplementation _interner;
 
         #region Statistics
         /// <summary>
         /// What if Mru lists were infinitely long?
         /// </summary>
-        private static BucketedPrioritizedStringList s_whatIfInfinite;
+        private BucketedPrioritizedStringList _whatIfInfinite;
 
         /// <summary>
         /// What if we doubled the size of the Mru lists?
         /// </summary>
-        private static BucketedPrioritizedStringList s_whatIfDoubled;
+        private BucketedPrioritizedStringList _whatIfDoubled;
 
         /// <summary>
         /// What if we halved the size of the Mru lists?
         /// </summary>
-        private static BucketedPrioritizedStringList s_whatIfHalved;
+        private BucketedPrioritizedStringList _whatIfHalved;
 
         /// <summary>
         /// What if the size of Mru lists was zero? (We still intern tiny strings in this case)
         /// </summary>
-        private static BucketedPrioritizedStringList s_whatIfZero;
+        private BucketedPrioritizedStringList _whatIfZero;
         #endregion
 
-        #region IInternable
+        private OpportunisticIntern()
+        {
+            _smallMruSize = AssignViaEnvironment("MSBUILDSMALLINTERNSIZE", 50);
+            _largeMruSize = AssignViaEnvironment("MSBUILDLARGEINTERNSIZE", 100);
+            _hugeMruSize = AssignViaEnvironment("MSBUILDHUGEINTERNSIZE", 100);
+            _smallMruThreshold = AssignViaEnvironment("MSBUILDSMALLINTERNTHRESHOLD", 50);
+            _largeMruThreshold = AssignViaEnvironment("MSBUILDLARGEINTERNTHRESHOLD", 70);
+            _hugeMruThreshold = AssignViaEnvironment("MSBUILDHUGEINTERNTHRESHOLD", 200);
+            _ginormousThreshold = AssignViaEnvironment("MSBUILDGINORMOUSINTERNTHRESHOLD", 8000);
+
+            _interner = _useLegacyInterner
+               ? (IInternerImplementation)new BucketedPrioritizedStringList(gatherStatistics: false, _smallMruSize, _largeMruSize, _hugeMruSize,
+                    _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency)
+               : (IInternerImplementation)new WeakStringCacheInterner(gatherStatistics: false);
+        }
+
         /// <summary>
-        /// Define the methods needed to intern something.
+        /// Recreates the singleton instance based on the current environment (test only).
         /// </summary>
-        internal interface IInternable
+        internal static void ResetForTests()
         {
-            /// <summary>
-            /// The length of the target.
-            /// </summary>
-            int Length { get; }
-
-            /// <summary>
-            /// Indexer into the target. Presumed to be fast.
-            /// </summary>
-            char this[int index] { get; }
-
-            /// <summary>
-            /// Convert target to string. Presumed to be slow (and will be called just once).
-            /// </summary>
-            string ExpensiveConvertToString();
-
-            /// <summary>
-            /// Compare target to string. Assumes string is of equal or smaller length than target.
-            /// </summary>
-            bool StartsWithStringByOrdinalComparison(string other);
-
-            /// <summary>
-            /// Reference compare target to string. If target is non-string this should return false.
-            /// </summary>
-            bool ReferenceEquals(string other);
+            Debug.Assert(BuildEnvironmentHelper.Instance.RunningTests);
+            _instance = new OpportunisticIntern();
         }
-        #endregion
 
         /// <summary>
         /// Assign an int from an environment variable. If its not present, use the default.
         /// </summary>
-        internal static int AssignViaEnvironment(string env, int @default)
+        private int AssignViaEnvironment(string env, int @default)
         {
             string threshold = Environment.GetEnvironmentVariable(env);
             if (!string.IsNullOrEmpty(threshold))
@@ -147,14 +169,21 @@ internal static int AssignViaEnvironment(string env, int @default)
         /// <summary>
         /// Turn on statistics gathering.
         /// </summary>
-        internal static void EnableStatisticsGathering()
+        internal void EnableStatisticsGathering()
         {
-            // Statistics include several 'what if' scenarios such as doubling the size of the MRU lists.
-            s_si = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize, s_largeMruSize, s_hugeMruSize, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
-            s_whatIfInfinite = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, int.MaxValue, int.MaxValue, int.MaxValue, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
-            s_whatIfDoubled = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize * 2, s_largeMruSize * 2, s_hugeMruSize * 2, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
-            s_whatIfHalved = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize / 2, s_largeMruSize / 2, s_hugeMruSize / 2, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
-            s_whatIfZero = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, 0, 0, 0, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
+            if (_useLegacyInterner)
+            {
+                // Statistics include several 'what if' scenarios such as doubling the size of the MRU lists.
+                _interner = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize, _largeMruSize, _hugeMruSize, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
+                _whatIfInfinite = new BucketedPrioritizedStringList(gatherStatistics: true, int.MaxValue, int.MaxValue, int.MaxValue, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
+                _whatIfDoubled = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize * 2, _largeMruSize * 2, _hugeMruSize * 2, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
+                _whatIfHalved = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize / 2, _largeMruSize / 2, _hugeMruSize / 2, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
+                _whatIfZero = new BucketedPrioritizedStringList(gatherStatistics: true, 0, 0, 0, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
+            }
+            else
+            {
+                _interner = new WeakStringCacheInterner(gatherStatistics: true);
+            }
         }
 
         /// <summary>
@@ -162,23 +191,7 @@ internal static void EnableStatisticsGathering()
         /// </summary>
         internal static string InternableToString<T>(T candidate) where T : IInternable
         {
-            if (s_whatIfInfinite != null)
-            {
-                s_whatIfInfinite.InterningToString(candidate);
-                s_whatIfDoubled.InterningToString(candidate);
-                s_whatIfHalved.InterningToString(candidate);
-                s_whatIfZero.InterningToString(candidate);
-            }
-
-            string result = s_si.InterningToString(candidate);
-#if DEBUG
-            string expected = candidate.ExpensiveConvertToString();
-            if (!String.Equals(result, expected))
-            {
-                ErrorUtilities.ThrowInternalError("Interned string {0} should have been {1}", result, expected);
-            }
-#endif
-            return result;
+            return Instance.InternableToStringImpl(candidate);
         }
 
         /// <summary>
@@ -186,7 +199,7 @@ internal static string InternableToString<T>(T candidate) where T : IInternable
         /// </summary>
         internal static string StringBuilderToString(StringBuilder candidate)
         {
-            return InternableToString(new StringBuilderInternTarget(candidate));
+            return Instance.InternableToStringImpl(new StringBuilderInternTarget(candidate));
         }
 
         /// <summary>
@@ -194,7 +207,7 @@ internal static string StringBuilderToString(StringBuilder candidate)
         /// </summary>
         internal static string CharArrayToString(char[] candidate, int count)
         {
-            return InternableToString(new CharArrayInternTarget(candidate, count));
+            return Instance.InternableToStringImpl(new CharArrayInternTarget(candidate, count));
         }
 
         /// <summary>
@@ -202,7 +215,7 @@ internal static string CharArrayToString(char[] candidate, int count)
         /// </summary>
         internal static string CharArrayToString(char[] candidate, int startIndex, int count)
         {
-            return InternableToString(new CharArrayInternTarget(candidate, startIndex, count));
+            return Instance.InternableToStringImpl(new CharArrayInternTarget(candidate, startIndex, count));
         }
 
         /// <summary>
@@ -212,330 +225,348 @@ internal static string CharArrayToString(char[] candidate, int startIndex, int c
         /// <returns>The interned string, or the same string if it could not be interned.</returns>
         internal static string InternStringIfPossible(string candidate)
         {
-            return InternableToString(new StringInternTarget(candidate));
+            return Instance.InternableToStringImpl(new StringInternTarget(candidate));
         }
 
         /// <summary>
-        /// Report statistics about interning. Don't call unless GatherStatistics has been called beforehand.
-        /// </summary>
-        internal static void ReportStatistics()
-        {
-            s_si.ReportStatistics("Main");
-            s_whatIfInfinite.ReportStatistics("if Infinite");
-            s_whatIfDoubled.ReportStatistics("if Doubled");
-            s_whatIfHalved.ReportStatistics("if Halved");
-            s_whatIfZero.ReportStatistics("if Zero");
-            Console.WriteLine(" * Even for MRU size of zero there will still be some intern hits because of the tiny ");
-            Console.WriteLine("   string matching (eg. 'true')");
-        }
-
-        #region IInternable Implementations
-        /// <summary>
-        /// A wrapper over StringBuilder.
+        /// Intern the given internable.
         /// </summary>
-        internal struct StringBuilderInternTarget : IInternable
+        private string InternableToStringImpl<T>(T candidate) where T : IInternable
         {
-            /// <summary>
-            /// The held StringBuilder
-            /// </summary>
-            private readonly StringBuilder _target;
-
-            /// <summary>
-            /// Pointless comment about constructor.
-            /// </summary>
-            internal StringBuilderInternTarget(StringBuilder target)
+            if (candidate.Length == 0)
             {
-                _target = target;
+                // As in the case that a property or itemlist has evaluated to empty.
+                return string.Empty;
             }
 
-            /// <summary>
-            /// The length of the target.
-            /// </summary>
-            public int Length => _target.Length;
-
-            /// <summary>
-            /// Indexer into the target. Presumed to be fast.
-            /// </summary>
-            public char this[int index] => _target[index];
-
-            /// <summary>
-            /// Never reference equals to string.
-            /// </summary>
-            public bool ReferenceEquals(string other) => false;
-
-            /// <summary>
-            /// Convert target to string. Presumed to be slow (and will be called just once).
-            /// </summary>
-            public string ExpensiveConvertToString()
+            if (_whatIfInfinite != null)
             {
-                // PERF NOTE: This will be an allocation hot-spot because the StringBuilder is finally determined to
-                // not be internable. There is still only one conversion of StringBuilder into string it has just
-                // moved into this single spot.
-                return _target.ToString();
+                _whatIfInfinite.InterningToString(candidate);
+                _whatIfDoubled.InterningToString(candidate);
+                _whatIfHalved.InterningToString(candidate);
+                _whatIfZero.InterningToString(candidate);
             }
 
-            /// <summary>
-            /// Compare target to string. Assumes string is of equal or smaller length than target.
-            /// </summary>
-            public bool StartsWithStringByOrdinalComparison(string other)
-            {
+            string result = _interner.InterningToString(candidate);
 #if DEBUG
-                ErrorUtilities.VerifyThrow(other.Length <= _target.Length, "should be at most as long as target");
-#endif
-                int length = other.Length;
-
-                // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
-                // For example, C:\project1, C:\project2
-                for (int i = length - 1; i >= 0; --i)
-                {
-                    if (_target[i] != other[i])
-                    {
-                        return false;
-                    }
-                }
-
-                return true;
+            string expected = candidate.ExpensiveConvertToString();
+            if (!String.Equals(result, expected))
+            {
+                ErrorUtilities.ThrowInternalError("Interned string {0} should have been {1}", result, expected);
             }
-
-            /// <summary>
-            /// Don't use this function. Use ExpensiveConvertToString
-            /// </summary>
-            public override string ToString() => throw new InvalidOperationException();
+#endif
+            return result;
         }
 
         /// <summary>
-        /// A wrapper over char[].
+        /// Report statistics about interning. Don't call unless GatherStatistics has been called beforehand.
         /// </summary>
-        internal struct CharArrayInternTarget : IInternable
+        internal void ReportStatistics()
         {
-            /// <summary>
-            /// Start index for the string
-            /// </summary>
-            private readonly int _startIndex;
-
-            /// <summary>
-            /// The held array
-            /// </summary>
-            private readonly char[] _target;
-
-            /// <summary>
-            /// Pointless comment about constructor.
-            /// </summary>
-            internal CharArrayInternTarget(char[] target, int count)
-                : this(target, 0, count)
+            _interner.ReportStatistics("Main");
+            if (_useLegacyInterner)
             {
+                _whatIfInfinite.ReportStatistics("if Infinite");
+                _whatIfDoubled.ReportStatistics("if Doubled");
+                _whatIfHalved.ReportStatistics("if Halved");
+                _whatIfZero.ReportStatistics("if Zero");
+                Console.WriteLine(" * Even for MRU size of zero there will still be some intern hits because of the tiny ");
+                Console.WriteLine("   string matching (eg. 'true')");
             }
+        }
 
-            /// <summary>
-            /// Pointless comment about constructor.
-            /// </summary>
-            internal CharArrayInternTarget(char[] target, int startIndex, int count)
+        private static bool TryInternHardcodedString<T>(T candidate, string str, ref string interned) where T : IInternable
+        {
+            Debug.Assert(candidate.Length == str.Length);
+
+            if (candidate.StartsWithStringByOrdinalComparison(str))
             {
-#if DEBUG
-                if (startIndex + count > target.Length)
-                {
-                    ErrorUtilities.ThrowInternalError("wrong length");
-                }
-#endif
-                _target = target;
-                _startIndex = startIndex;
-                Length = count;
+                interned = str;
+                return true;
             }
+            return false;
+        }
 
-            /// <summary>
-            /// The length of the target.
-            /// </summary>
-            public int Length { get; }
+        /// <summary>
+        /// Try to match the candidate with small number of hardcoded interned string literals.
+        /// The return value indicates how the string was interned (if at all).
+        /// </summary>
+        /// <returns>
+        /// True if the candidate matched a hardcoded literal, null if it matched a "do not intern" string, false otherwise.
+        /// </returns>
+        private static bool? TryMatchHardcodedStrings<T>(T candidate, out string interned) where T : IInternable
+        {
+            int length = candidate.Length;
+            interned = null;
 
-            /// <summary>
-            /// Indexer into the target. Presumed to be fast.
-            /// </summary>
-            public char this[int index]
+            // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.
+            if (length == 2)
             {
-                get
+                if (candidate[1] == '#')
                 {
-                    if (index > _startIndex + Length - 1 || index < 0)
+                    if (candidate[0] == 'C')
                     {
-                        ErrorUtilities.ThrowInternalError("past end");
+                        interned = "C#";
+                        return true;
                     }
 
-                    return _target[index + _startIndex];
+                    if (candidate[0] == 'F')
+                    {
+                        interned = "F#";
+                        return true;
+                    }
                 }
-            }
 
-            /// <summary>
-            /// Convert target to string. Presumed to be slow (and will be called just once).
-            /// </summary>
-            public bool ReferenceEquals(string other)
+                if (candidate[0] == 'V' && candidate[1] == 'B')
+                {
+                    interned = "VB";
+                    return true;
+                }
+            }
+            else if (length == 4)
             {
-                return false;
+                if (TryInternHardcodedString(candidate, "TRUE", ref interned) ||
+                    TryInternHardcodedString(candidate, "True", ref interned) ||
+                    TryInternHardcodedString(candidate, "Copy", ref interned) ||
+                    TryInternHardcodedString(candidate, "true", ref interned) ||
+                    TryInternHardcodedString(candidate, "v4.0", ref interned))
+                {
+                    return true;
+                }
             }
-
-            /// <summary>
-            /// Convert target to string. Presumed to be slow (and will be called just once).
-            /// </summary>
-            public string ExpensiveConvertToString()
+            else if (length == 5)
             {
-                // PERF NOTE: This will be an allocation hot-spot because the char[] is finally determined to
-                // not be internable. There is still only one conversion of char[] into string it has just
-                // moved into this single spot.
-                return new string(_target, _startIndex, Length);
+                if (TryInternHardcodedString(candidate, "FALSE", ref interned) ||
+                    TryInternHardcodedString(candidate, "false", ref interned) ||
+                    TryInternHardcodedString(candidate, "Debug", ref interned) ||
+                    TryInternHardcodedString(candidate, "Build", ref interned) ||
+                    TryInternHardcodedString(candidate, "Win32", ref interned))
+                {
+                    return true;
+                }
             }
-
-            /// <summary>
-            /// Compare target to string. Assumes string is of equal or smaller length than target.
-            /// </summary>
-            public bool StartsWithStringByOrdinalComparison(string other)
+            else if (length == 6)
             {
-#if DEBUG
-                ErrorUtilities.VerifyThrow(other.Length <= Length, "should be at most as long as target");
-#endif
-                // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
-                // For example, C:\project1, C:\project2
-                for (int i = other.Length - 1; i >= 0; --i)
+                if (TryInternHardcodedString(candidate, "''!=''", ref interned) ||
+                    TryInternHardcodedString(candidate, "AnyCPU", ref interned))
                 {
-                    if (_target[i + _startIndex] != other[i])
-                    {
-                        return false;
-                    }
+                    return true;
                 }
-
-                return true;
             }
-
-            /// <summary>
-            /// Don't use this function. Use ExpensiveConvertToString
-            /// </summary>
-            public override string ToString()
+            else if (length == 7)
             {
-                throw new InvalidOperationException();
+                if (TryInternHardcodedString(candidate, "Library", ref interned) ||
+                    TryInternHardcodedString(candidate, "MSBuild", ref interned) ||
+                    TryInternHardcodedString(candidate, "Release", ref interned))
+                {
+                    return true;
+                }
             }
+            // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty
+            else if (length > MSBuildConstants.MSBuildDummyGlobalPropertyHeader.Length &&
+                    candidate.StartsWithStringByOrdinalComparison(MSBuildConstants.MSBuildDummyGlobalPropertyHeader))
+            {
+                // don't want to leak unique strings into the cache
+                interned = candidate.ExpensiveConvertToString();
+                return null;
+            }
+            else if (length == 24)
+            {
+                if (TryInternHardcodedString(candidate, "ResolveAssemblyReference", ref interned))
+                {
+                    return true;
+                }
+            }
+            return false;
         }
 
         /// <summary>
-        /// Wrapper over a string.
+        /// Implements interning based on a WeakStringCache (new implementation).
         /// </summary>
-        internal struct StringInternTarget : IInternable
+        private class WeakStringCacheInterner : IInternerImplementation
         {
             /// <summary>
-            /// Stores the wrapped string.
+            /// Enumerates the possible interning results.
             /// </summary>
-            private readonly string _target;
+            private enum InternResult
+            {
+                MatchedHardcodedString,
+                FoundInWeakStringCache,
+                AddedToWeakStringCache,
+                RejectedFromInterning
+            }
 
             /// <summary>
-            /// Constructor of the class
+            /// The cache to keep strings in.
             /// </summary>
-            /// <param name="target">The string to wrap</param>
-            internal StringInternTarget(string target)
-            {
-                ErrorUtilities.VerifyThrowArgumentLength(target, nameof(target));
-                _target = target;
-            }
+            private readonly WeakStringCache _weakStringCache = new WeakStringCache();
 
+#region Statistics
             /// <summary>
-            /// Gets the length of the target string.
+            /// Whether or not to gather statistics.
             /// </summary>
-            public int Length => _target.Length;
+            private readonly bool _gatherStatistics;
 
             /// <summary>
-            /// Gets the n character in the target string.
+            /// Number of times interning with hardcoded string literals worked.
             /// </summary>
-            /// <param name="index">Index of the character to gather.</param>
-            /// <returns>The character in the position marked by index.</returns>
-            public char this[int index] => _target[index];
+            private int _hardcodedInternHits;
 
             /// <summary>
-            /// Returns the target which is already a string.
+            /// Number of times the regular interning path found the string in the cache.
             /// </summary>
-            /// <returns>The target string.</returns>
-            public string ExpensiveConvertToString() => _target;
+            private int _regularInternHits;
 
             /// <summary>
-            /// Compare target to string. Assumes string is of equal or smaller length than target.
+            /// Number of times the regular interning path added the string to the cache.
             /// </summary>
-            /// <param name="other">The string to compare with the target.</param>
-            /// <returns>True if target starts with <paramref name="other"/>, false otherwise.</returns>
-            public bool StartsWithStringByOrdinalComparison(string other) => _target.StartsWith(other, StringComparison.Ordinal);
+            private int _regularInternMisses;
 
             /// <summary>
-            /// Verifies if the reference of the target string is the same of the given string.
+            /// Number of times interning wasn't attempted.
             /// </summary>
-            /// <param name="other">The string reference to compare to.</param>
-            /// <returns>True if both references are equal, false otherwise.</returns>
-            public bool ReferenceEquals(string other) => ReferenceEquals(_target, other);
-        }
+            private int _rejectedStrings;
 
-        /// <summary>
-        /// Wrapper over a substring of a string.
-        /// </summary>
-        internal struct SubstringInternTarget : IInternable
-        {
             /// <summary>
-            /// Stores the wrapped string.
+            /// Total number of strings eliminated by interning.
             /// </summary>
-            private readonly string _target;
+            private int _internEliminatedStrings;
 
             /// <summary>
-            /// Start index of the substring within the wrapped string.
+            /// Total number of chars eliminated across all strings.
             /// </summary>
-            private readonly int _startIndex;
+            private int _internEliminatedChars;
 
             /// <summary>
-            /// Constructor of the class
+            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been
+            /// seen. The higher the number the better the payoff if the string had been hardcoded.
             /// </summary>
-            /// <param name="target">The string to wrap.</param>
-            /// <param name="startIndex">Start index of the substring within <paramref name="target"/>.</param>
-            /// <param name="length">Length of the substring.</param>
-            internal SubstringInternTarget(string target, int startIndex, int length)
+            private Dictionary<string, int> _missedHardcodedStrings;
+
+#endregion
+
+            public WeakStringCacheInterner(bool gatherStatistics)
             {
-#if DEBUG
-                if (startIndex + length > target.Length)
+                if (gatherStatistics)
                 {
-                    ErrorUtilities.ThrowInternalError("wrong length");
+                    _missedHardcodedStrings = new Dictionary<string, int>();
                 }
-#endif
-                _target = target;
-                _startIndex = startIndex;
-                Length = length;
+                _gatherStatistics = gatherStatistics;
             }
 
             /// <summary>
-            /// Gets the length of the target substring.
+            /// Intern the given internable.
             /// </summary>
-            public int Length { get; }
+            public string InterningToString<T>(T candidate) where T : IInternable
+            {
+                if (_gatherStatistics)
+                {
+                    return InternWithStatistics(candidate);
+                }
+                else
+                {
+                    TryIntern(candidate, out string result);
+                    return result;
+                }
+            }
 
             /// <summary>
-            /// Gets the n character in the target substring.
+            /// Report statistics to the console.
             /// </summary>
-            /// <param name="index">Index of the character to gather.</param>
-            /// <returns>The character in the position marked by index.</returns>
-            public char this[int index] => _target[index + _startIndex];
+            public void ReportStatistics(string heading)
+            {
+                string title = "Opportunistic Intern (" + heading + ")";
+                Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title);
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Hardcoded Hits", _hardcodedInternHits, "hits");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Hardcoded Rejects", _rejectedStrings, "rejects");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Hits", _regularInternHits, "hits");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Misses", _regularInternMisses, "misses");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes");
+                Console.WriteLine("Elimination assumes that strings provided were unique objects.");
+                Console.WriteLine("|---------------------------------------------------------------------------------|");
 
-            /// <summary>
-            /// Returns the target substring as a string.
-            /// </summary>
-            /// <returns>The substring.</returns>
-            public string ExpensiveConvertToString() => _target.Substring(_startIndex, Length);
+                IEnumerable<string> topMissingHardcodedString =
+                    _missedHardcodedStrings
+                    .OrderByDescending(kv => kv.Value * kv.Key.Length)
+                    .Take(15)
+                    .Where(kv => kv.Value > 1)
+                    .Select(kv => string.Format(CultureInfo.InvariantCulture, "({1} instances x each {2} chars)\n{0}", kv.Key, kv.Value, kv.Key.Length));
+
+                Console.WriteLine("##########Top Missing Hardcoded Strings:  \n{0} ", string.Join("\n==============\n", topMissingHardcodedString.ToArray()));
+                Console.WriteLine();
+
+                WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();
+                Console.WriteLine("WeakStringCache statistics:");
+                Console.WriteLine("String count live/collected/total = {0}/{1}/{2}", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount);
+            }
 
             /// <summary>
-            /// Compare target substring to a string. Assumes string is of equal or smaller length than the target substring.
+            /// Try to intern the string.
+            /// The return value indicates the how the string was interned (if at all).
             /// </summary>
-            /// <param name="other">The string to compare with the target substring.</param>
-            /// <returns>True if target substring starts with <paramref name="other"/>, false otherwise.</returns>
-            public bool StartsWithStringByOrdinalComparison(string other) => (String.CompareOrdinal(_target, _startIndex, other, 0, other.Length) == 0);
+            private InternResult TryIntern<T>(T candidate, out string interned) where T : IInternable
+            {
+                // First, try the hard coded intern strings.
+                bool? hardcodedMatchResult = TryMatchHardcodedStrings(candidate, out interned);
+                if (hardcodedMatchResult != false)
+                {
+                    // Either matched a hardcoded string or is explicitly not to be interned.
+                    return hardcodedMatchResult.HasValue ? InternResult.MatchedHardcodedString : InternResult.RejectedFromInterning;
+                }
+
+                interned = _weakStringCache.GetOrCreateEntry(candidate, out bool cacheHit);
+                return cacheHit ? InternResult.FoundInWeakStringCache : InternResult.AddedToWeakStringCache;
+            }
 
             /// <summary>
-            /// Never reference equals to string.
+            /// Version of Intern that gathers statistics
             /// </summary>
-            public bool ReferenceEquals(string other) => false;
-        }
+            private string InternWithStatistics<T>(T candidate) where T : IInternable
+            {
+                lock (_missedHardcodedStrings)
+                {
+                    InternResult internResult = TryIntern(candidate, out string result);
 
-        #endregion
+                    switch (internResult)
+                    {
+                        case InternResult.MatchedHardcodedString:
+                            _hardcodedInternHits++;
+                            break;
+                        case InternResult.FoundInWeakStringCache:
+                            _regularInternHits++;
+                            break;
+                        case InternResult.AddedToWeakStringCache:
+                            _regularInternMisses++;
+                            break;
+                        case InternResult.RejectedFromInterning:
+                            _rejectedStrings++;
+                            break;
+                    }
+
+                    if (internResult != InternResult.MatchedHardcodedString && internResult != InternResult.RejectedFromInterning)
+                    {
+                        _missedHardcodedStrings.TryGetValue(result, out int priorCount);
+                        _missedHardcodedStrings[result] = priorCount + 1;
+                    }
+
+                    if (!candidate.ReferenceEquals(result))
+                    {
+                        // Reference changed so 'candidate' is now released and should save memory.
+                        _internEliminatedStrings++;
+                        _internEliminatedChars += candidate.Length;
+                    }
+
+                    return result;
+                }
+            }
+        }
 
         /// <summary>
-        /// Manages a set of mru lists that hold strings in varying size ranges.
+        /// Manages a set of mru lists that hold strings in varying size ranges (legacy implementation).
         /// </summary>
-        private class BucketedPrioritizedStringList
+        private class BucketedPrioritizedStringList : IInternerImplementation
         {
             /// <summary>
             /// The small string Mru list.
@@ -588,7 +619,7 @@ private class BucketedPrioritizedStringList
             private readonly ConcurrentDictionary<string, string> _internedStrings = new ConcurrentDictionary<string, string>(Environment.ProcessorCount, InitialCapacity, StringComparer.Ordinal);
 #endif
 
-            #region Statistics
+#region Statistics
             /// <summary>
             /// Whether or not to gather statistics
             /// </summary>
@@ -661,7 +692,7 @@ private class BucketedPrioritizedStringList
             /// </summary>
             private const int GinormousSize = 10;
 
-            #endregion
+#endregion
 
             /// <summary>
             /// Construct.
@@ -699,14 +730,8 @@ internal BucketedPrioritizedStringList(bool gatherStatistics, int smallMruSize,
             /// <summary>
             /// Intern the given internable.
             /// </summary>
-            internal string InterningToString<T>(T candidate) where T : IInternable
+            public string InterningToString<T>(T candidate) where T : IInternable
             {
-                if (candidate.Length == 0)
-                {
-                    // As in the case that a property or itemlist has evaluated to empty.
-                    return string.Empty;
-                }
-
                 if (_gatherStatistics)
                 {
                     return InternWithStatistics(candidate);
@@ -721,30 +746,30 @@ internal string InterningToString<T>(T candidate) where T : IInternable
             /// <summary>
             /// Report statistics to the console.
             /// </summary>
-            internal void ReportStatistics(string heading)
+            public void ReportStatistics(string heading)
             {
                 string title = "Opportunistic Intern (" + heading + ")";
                 Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title);
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Hits", _internHits, "hits");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Misses", _internMisses, "misses");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Rejects (as shorter than " + s_smallMruThreshold + " bytes)", _internRejects, "rejects");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Rejects (as shorter than " + _smallMruThreshold + " bytes)", _internRejects, "rejects");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes");
                 Console.WriteLine("Elimination assumes that strings provided were unique objects.");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
                 KeyValuePair<int, int> held = _smallMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings MRU Size", s_smallMruSize, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings MRU Size", Instance._smallMruSize, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings (>=" + _smallMruThreshold + " chars) Held", held.Key, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Estimated Bytes Held", held.Value * 2, "bytes");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
                 held = _largeMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings MRU Size", s_largeMruSize, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings MRU Size", Instance._largeMruSize, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings  (>=" + _largeMruThreshold + " chars) Held", held.Key, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Estimated Bytes Held", held.Value * 2, "bytes");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
                 held = _hugeMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings MRU Size", s_hugeMruSize, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings MRU Size", Instance._hugeMruSize, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings  (>=" + _hugeMruThreshold + " chars) Held", held.Key, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Estimated Bytes Held", held.Value * 2, "bytes");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
@@ -778,18 +803,6 @@ internal void ReportStatistics(string heading)
                 Console.WriteLine("##########Top Rejected Strings: \n{0} ", string.Join("\n==============\n", topRejectedString.ToArray()));
             }
 
-            private bool TryInternHardcodedString<T>(T candidate, string str, ref string interned) where T : IInternable
-            {
-                Debug.Assert(candidate.Length == str.Length);
-
-                if (candidate.StartsWithStringByOrdinalComparison(str))
-                {
-                    interned = str;
-                    return true;
-                }
-                return false;
-            }
-
             /// <summary>
             /// Try to intern the string.
             /// Return true if an interned value could be returned.
@@ -805,84 +818,14 @@ private bool TryInternHardcodedString<T>(T candidate, string str, ref string int
                 // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.
                 if (!_dontTrack)
                 {
-                    if (length == 2)
-                    {
-                        if (candidate[1] == '#')
-                        {
-                            if (candidate[0] == 'C')
-                            {
-                                interned = "C#";
-                                return true;
-                            }
-
-                            if (candidate[0] == 'F')
-                            {
-                                interned = "F#";
-                                return true;
-                            }
-                        }
-
-                        if (candidate[0] == 'V' && candidate[1] == 'B')
-                        {
-                            interned = "VB";
-                            return true;
-                        }
-                    }
-                    else if (length == 4)
+                    bool? hardcodedMatchResult = TryMatchHardcodedStrings(candidate, out interned);
+                    if (hardcodedMatchResult != false)
                     {
-                        if (TryInternHardcodedString(candidate, "TRUE", ref interned) ||
-                            TryInternHardcodedString(candidate, "True", ref interned) ||
-                            TryInternHardcodedString(candidate, "Copy", ref interned) ||
-                            TryInternHardcodedString(candidate, "true", ref interned) ||
-                            TryInternHardcodedString(candidate, "v4.0", ref interned))
-                        {
-                            return true;
-                        }
+                        // Either matched a hardcoded string or is explicitly not to be interned.
+                        return hardcodedMatchResult;
                     }
-                    else if (length == 5)
-                    {
-                        if (TryInternHardcodedString(candidate, "FALSE", ref interned) ||
-                            TryInternHardcodedString(candidate, "false", ref interned) ||
-                            TryInternHardcodedString(candidate, "Debug", ref interned) ||
-                            TryInternHardcodedString(candidate, "Build", ref interned) ||
-                            TryInternHardcodedString(candidate, "Win32", ref interned))
-                        {
-                            return true;
-                        }
-                    }
-                    else if (length == 6)
-                    {
-                        if (TryInternHardcodedString(candidate, "''!=''", ref interned) ||
-                            TryInternHardcodedString(candidate, "AnyCPU", ref interned))
-                        {
-                            return true;
-                        }
-                    }
-                    else if (length == 7)
-                    {
-                        if (TryInternHardcodedString(candidate, "Library", ref interned) ||
-                            TryInternHardcodedString(candidate, "MSBuild", ref interned) ||
-                            TryInternHardcodedString(candidate, "Release", ref interned))
-                        {
-                            return true;
-                        }
-                    }
-                    // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty
-                    else if (length > MSBuildConstants.MSBuildDummyGlobalPropertyHeader.Length &&
-                            candidate.StartsWithStringByOrdinalComparison(MSBuildConstants.MSBuildDummyGlobalPropertyHeader))
-                    {
-                        // don't want to leak unique strings into the cache
-                        interned = candidate.ExpensiveConvertToString();
-                        return null;
-                    }
-                    else if (length == 24)
-                    {
-                        if (TryInternHardcodedString(candidate, "ResolveAssemblyReference", ref interned))
-                        {
-                            return true;
-                        }
-                    }
-                    else if (length > _ginormousThreshold)
+
+                    if (length > _ginormousThreshold)
                     {
                         lock (_ginormous)
                         {
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index 9e49658e8b4..9c6f2361554 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -77,6 +77,29 @@ params object[] args
             VerifyThrowInvalidProjectFile(condition, null, projectFile, resourceName, args);
         }
 
+        /// <summary>
+        /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
+        /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
+        /// 
+        /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
+        /// </summary>
+        /// <param name="condition">The condition to check.</param>
+        /// <param name="errorSubCategoryResourceName">The resource string for the error sub-category (can be null).</param>
+        /// <param name="projectFile">The invalid project file.</param>
+        /// <param name="resourceName">The resource string for the error message.</param>
+        /// <param name="args">Extra arguments for formatting the error message.</param>
+        internal static void ThrowInvalidProjectFile
+        (
+            string errorSubCategoryResourceName,
+            BuildEventFileInfo projectFile,
+            string resourceName,
+            params object[] args
+        )
+        {
+            VerifyThrowInvalidProjectFile(false, errorSubCategoryResourceName, projectFile, null, resourceName, args);
+        }
+
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index ad6b7925fc1..fd568252430 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -262,10 +262,22 @@
     <value>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</value>
     <comment></comment>
   </data>
+  <data name="SolutionFilterJsonParsingError" Visibility="Public">
+    <value>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</value>
+    <comment>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</comment>
+  </data>
+  <data name="SolutionFilterMissingSolutionError" Visibility="Public">
+    <value>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</value>
+    <comment>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</comment>
+  </data>
+  <data name="SolutionFilterFilterContainsProjectNotInSolution" Visibility="Public">
+    <value>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</value>
+    <comment>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</comment>
+  </data>
   <!--
         The shared message bucket is: MSB5001 - MSB5999
 
-        Next message code should be MSB5025
+        Next message code should be MSB5029
 
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 5d65ee0a93b..00a783fd1db 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Cesta: {0} překračuje maximální limit pro cestu k OS. Plně kvalifikovaný název souboru musí být kratší než {1} znaků.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Verze nástrojů {0} je neznámá. Dostupné verze nástrojů jsou {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 0a0fce1dbb9..e3bd8284ae0 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Der Pfad "{0}" überschreitet das maximale Pfadlimit des Betriebssystems. Der vollqualifizierte Dateiname muss weniger als {1} Zeichen umfassen.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Die Toolsversion "{0}" ist unbekannt. Verfügbare Toolversionen sind {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.en.xlf b/src/Shared/Resources/xlf/Strings.shared.en.xlf
index 89e1330b798..cf10e5c095a 100644
--- a/src/Shared/Resources/xlf/Strings.shared.en.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.en.xlf
@@ -70,6 +70,21 @@
         <target state="new">Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 62c0b3ef027..0860cf5f017 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -65,6 +65,21 @@
         <target state="translated">La ruta de acceso {0} supera el límite máximo para la ruta de acceso del sistema operativo. El nombre de archivo completo debe ser inferior a {1} caracteres.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: No se reconoce la versión de herramientas "{0}". Las versiones de herramientas disponibles son {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 09edfc73b93..b0ee0eaf271 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Le chemin {0} dépasse la limite maximale de chemin du système d'exploitation. Le nom du fichier qualifié complet doit contenir moins de {1} caractères.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: La version des outils "{0}" n'est pas reconnue. Les versions disponibles sont {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 33fb3b72d80..fa13a591797 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Il percorso {0} supera il limite massimo dei percorsi del sistema operativo. Il nome completo del file deve essere composto da meno di {1}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: versione degli strumenti "{0}" non riconosciuta. Le versioni disponibili sono {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index d38f7aba8ed..d4c5be36d60 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -4,47 +4,67 @@
     <body>
       <trans-unit id="BuildAborted">
         <source>MSB4188: Build was canceled.</source>
-        <target state="translated">MSB4188: ビルドが取り消されました。</target>
+        <target state="new">MSB4188: Build was canceled.</target>
         <note>{StrBegin="MSB4188: "} Error when the build stops suddenly for some reason. For example, because a child node died.</note>
       </trans-unit>
       <trans-unit id="BuildEngineCallbacksInTaskHostUnsupported">
         <source>MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</source>
-        <target state="translated">MSB5022: MSBuild タスク ホストは、IBuildEngine コールバックを実行するタスクの実行をサポートしていません。これらの操作を実行する場合は、タスクをコア MSBuild プロセスで実行してください。UsingTask の属性として設定されている "Runtime" または "Architecture" の値、あるいはタスク呼び出しの属性として設定されている "MSBuildRuntime" または "MSBuildArchitecture" の値が MSBuild の現在のランタイムまたはアーキテクチャと一致しない場合、タスクは自動的にタスク ホストで実行されます。</target>
+        <target state="new">MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</target>
         <note>{StrBegin="MSB5022: "} "Runtime", "Architecture", "MSBuildRuntime", and "MSBuildArchitecture" are all attributes in the project file, and thus should not be localized.</note>
       </trans-unit>
       <trans-unit id="BuildStarted">
         <source>Build started.</source>
-        <target state="translated">ビルドを開始しました。</target>
+        <target state="new">Build started.</target>
         <note />
       </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
-        <target state="translated">MSB4008: タスク アセンブリ "{0}" に対して競合しているアセンブリが "{1}" で見つかりました。</target>
+        <target state="new">MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DirectoryNotFound">
+        <source>Could not find directory path: {0}</source>
+        <target state="new">Could not find directory path: {0}</target>
+        <note>Directory must exist</note>
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
-        <target state="translated">イベントの種類 "{0}" は .NET シリアライザーを使用してシリアル化可能であることが想定されていましたが、シリアル化可能でなかったため無視されました。</target>
+        <target state="new">Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</target>
         <note />
       </trans-unit>
       <trans-unit id="FileLocation">
         <source>{0} ({1},{2})</source>
-        <target state="translated">{0} ({1},{2})</target>
+        <target state="new">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
-        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
-        <target state="translated">親ノードから受け取った環境をタスク ホストに適用する前に、次の変更を行っています:</target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
+        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
+        <target state="new">When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</target>
+        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
-        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
-        <target state="translated">  '{0}' を親環境の値 '{2}' ではなく '{1}' に設定しています。</target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
+        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
+        <target state="new">.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
+        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
+        <target state="new">.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
+        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
+        <target state="new">Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="InvalidLogFileFormat">
+        <source>MSB4233: There was an exception while reading the log file: {0}</source>
+        <target state="new">MSB4233: There was an exception while reading the log file: {0}</target>
+        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
       </trans-unit>
       <trans-unit id="InvalidProjectFile">
         <source>MSB4025: The project file could not be loaded. {0}</source>
-        <target state="translated">MSB4025: プロジェクト ファイルを読み込めませんでした。{0}</target>
+        <target state="new">MSB4025: The project file could not be loaded. {0}</target>
         <note>{StrBegin="MSB4025: "}UE: This message is shown when the project file given to the engine cannot be loaded because the filename/path is
     invalid, or due to lack of permissions, or incorrect XML. The project filename is not part of the message because it is
     provided separately to loggers.
@@ -52,241 +72,236 @@
       </trans-unit>
       <trans-unit id="InvalidVerbosity">
         <source>MSB4103: "{0}" is not a valid logger verbosity level.</source>
-        <target state="translated">MSB4103: "{0}" は有効なロガー詳細レベルではありません。</target>
+        <target state="new">MSB4103: "{0}" is not a valid logger verbosity level.</target>
         <note>{StrBegin="MSB4103: "}</note>
       </trans-unit>
       <trans-unit id="MissingProject">
         <source>MSBuild is expecting a valid "{0}" object.</source>
-        <target state="translated">MSBuild は有効な "{0}" オブジェクトを必要としています。</target>
+        <target state="new">MSBuild is expecting a valid "{0}" object.</target>
         <note />
       </trans-unit>
-      <trans-unit id="Shared.PathTooLong">
-        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
-        <target state="translated">パス: {0} は OS のパスの上限を越えています。完全修飾のファイル名は {1} 文字以下にする必要があります。</target>
-        <note />
+      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
+        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
+        <target state="new">Making the following modifications to the environment received from the parent node before applying it to the task host:</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
-      <trans-unit id="UnrecognizedToolsVersion">
-        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
-        <target state="translated">MSB4132: ツール バージョン "{0}" が認識されません。使用可能なツール バージョンは {1} です。</target>
-        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
+      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
+        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
+        <target state="new">  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
       <trans-unit id="NameInvalid">
         <source>MSB5016: The name "{0}" contains an invalid character "{1}".</source>
-        <target state="translated">MSB5016: 名前 "{0}" は無効な文字 "{1}" を含んでいます。</target>
+        <target state="new">MSB5016: The name "{0}" contains an invalid character "{1}".</target>
         <note>{StrBegin="MSB5016: "}</note>
       </trans-unit>
+      <trans-unit id="OM_NotSupportedReadOnlyCollection">
+        <source>This collection is read-only.</source>
+        <target state="new">This collection is read-only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
+        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
+        <target state="new">MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</target>
+        <note>{StrBegin="MSB5024: "}</note>
+      </trans-unit>
       <trans-unit id="Shared.CannotChangeItemSpecModifiers">
         <source>"{0}" is a reserved item metadata, and cannot be modified or deleted.</source>
-        <target state="translated">"{0}" は予約された項目メタデータです。変更または削除することはできません。</target>
+        <target state="new">"{0}" is a reserved item metadata, and cannot be modified or deleted.</target>
         <note>UE: Tasks and OM users are not allowed to remove or change the value of the built-in metadata on items e.g. the meta-data "FullPath", "RelativeDir", etc. are reserved.</note>
       </trans-unit>
       <trans-unit id="Shared.CannotConvertStringToBool">
         <source>The string "{0}" cannot be converted to a boolean (true/false) value.</source>
-        <target state="translated">文字列 "{0}" をブール値 (true/false) に変換することはできません。</target>
+        <target state="new">The string "{0}" cannot be converted to a boolean (true/false) value.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.FailedCreatingTempFile">
         <source>MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</source>
-        <target state="translated">MSB5003: 一時ファイルを作成できませんでした。一時ファイル フォルダーがいっぱいであるか、またはそのパスが正しくありません。{0}</target>
+        <target state="new">MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</target>
         <note>{StrBegin="MSB5003: "}</note>
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1}</source>
-        <target state="translated">MSB5018: 一時ファイル "{0}" を削除できませんでした。{1}</target>
+        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
         <source>The item metadata "%({0})" cannot be applied to the path "{1}". {2}</source>
-        <target state="translated">項目メタデータ "%({0})" をパス "{1}" に適用できません。{2}</target>
+        <target state="new">The item metadata "%({0})" cannot be applied to the path "{1}". {2}</target>
         <note>UE: This message is shown when the user tries to perform path manipulations using one of the built-in item metadata e.g. %(RootDir), on an item-spec that's not a valid path. LOCALIZATION: "{2}" is a localized message from a CLR/FX exception.</note>
       </trans-unit>
-      <trans-unit id="TaskNotMarshalByRef">
-        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="translated">MSB4077: "{0}" タスクに属性 LoadInSeparateAppDomain が設定されていますが、MarshalByRefObject から派生していません。そのタスクが MarshalByRefObject または AppDomainIsolatedTask から派生していることを確認してください。</target>
-        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
-        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
-        <target state="translated">.NET Framework のバージョン "{0}" はサポートされていません。列挙 Microsoft.Build.Utilities.TargetDotNetFrameworkVersion から値を指定してください。</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
-        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
-        <target state="translated">Windows SDK を明示的にターゲットとする場合、.NET Framework のバージョン "{0}" はサポートされません。Windows SDK は、.NET 4.5 以降でのみサポートされています。列挙 Microsoft.Build.Utilities.TargetDotNetFrameworkVersion から Version45 以上の値を指定してください。</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
-        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
-        <target state="translated">Visual Studio のバージョン "{0}" はサポートされていません。列挙 Microsoft.Build.Utilities.VisualStudioVersion から値を指定してください。</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
-        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
-        <target state="translated">参照アセンブリ パスをパス "{0}" とフレームワーク モニカー "{1}" から生成しようとしたときに、エラーが発生しました。{2}</target>
-        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
-      </trans-unit>
-      <trans-unit id="DirectoryNotFound">
-        <source>Could not find directory path: {0}</source>
-        <target state="translated">ディレクトリ パスが見つかりませんでした: {0}</target>
-        <note>Directory must exist</note>
-      </trans-unit>
-      <trans-unit id="UnauthorizedAccess">
-        <source>You do not have access to: {0}</source>
-        <target state="translated">{0} へのアクセス権がありません</target>
-        <note>Directory must have access</note>
-      </trans-unit>
-      <trans-unit id="SubCategoryForSchemaValidationErrors">
-        <source>Schema validation</source>
-        <target state="translated">スキーマの検証</target>
-        <note>
-      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
-      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
-      "MSBUILD : Schema validation error MSB0000: This is an error."
-      LOCALIZATION: This fragment needs to be localized.
-    </note>
+      <trans-unit id="Shared.InvalidProjectFile">
+        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
+        <target state="new">MSB5019: The project file is malformed: "{0}". {1}</target>
+        <note>{StrBegin="MSB5019: "}</note>
       </trans-unit>
       <trans-unit id="Shared.KillingProcess">
         <source>MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</source>
-        <target state="translated">MSB5002: 実行可能なタスク "{0}" は、指定された制限 ({1} ミリ秒) 内で完了しなかったため、終了しています。</target>
+        <target state="new">MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</target>
         <note>{StrBegin="MSB5002: "}</note>
       </trans-unit>
+      <trans-unit id="Shared.KillingProcessByCancellation">
+        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
+        <target state="new">MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</target>
+        <note>{StrBegin="MSB5021: "}</note>
+      </trans-unit>
       <trans-unit id="Shared.ParameterCannotBeNull">
         <source>Parameter "{0}" cannot be null.</source>
-        <target state="translated">パラメーター "{0}" を null にすることはできません。</target>
+        <target state="new">Parameter "{0}" cannot be null.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
+        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
+        <target state="new">Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParameterCannotHaveZeroLength">
         <source>Parameter "{0}" cannot have zero length.</source>
-        <target state="translated">パラメーター "{0}" の長さを 0 にすることはできません。</target>
+        <target state="new">Parameter "{0}" cannot have zero length.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParametersMustHaveTheSameLength">
         <source>Parameters "{0}" and "{1}" must have the same number of elements.</source>
-        <target state="translated">パラメーター "{0}" と "{1}" の要素数は同じである必要があります。</target>
+        <target state="new">Parameters "{0}" and "{1}" must have the same number of elements.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Shared.PathTooLong">
+        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
+        <target state="new">Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
+        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
+        <target state="new">MSB5020: Could not load the project file: "{0}". {1}</target>
+        <note>{StrBegin="MSB5020: "}</note>
+      </trans-unit>
       <trans-unit id="Shared.TaskResourceNotFound">
         <source>The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</source>
-        <target state="translated">"{1}" タスクのリソース文字列 "{0}" が見つかりません。リソース名 "{0}" のスペルが正しいこと、およびリソースがタスクのアセンブリ内に存在することを確認してください。</target>
+        <target state="new">The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.TaskResourcesNotRegistered">
         <source>The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</source>
-        <target state="translated">"{0}" タスクのリソースが登録されていません。"TaskLoggingHelper.FormatResourceString()" メソッドを使用するためには、構築時に、または "TaskResources" プロパティを通じて、このタスクのリソースを登録する必要があります。</target>
+        <target state="new">The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</target>
         <note>LOCALIZATION: "TaskLoggingHelper.FormatResourceString()" and "TaskResources" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="SolutionParseDuplicateProject">
         <source>MSB5004: The solution file has two projects named "{0}".</source>
-        <target state="translated">MSB5004: ソリューション ファイルには "{0}" という名前のプロジェクトが 2 つあります。</target>
+        <target state="new">MSB5004: The solution file has two projects named "{0}".</target>
         <note>{StrBegin="MSB5004: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameCharacters">
         <source>MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</source>
-        <target state="translated">MSB5005: プロジェクト "{0}" のプロジェクト セクションを解析中にエラーが発生しました。プロジェクトのファイル名 "{1}" に無効な文字が使用されています。</target>
+        <target state="new">MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</target>
         <note>{StrBegin="MSB5005: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameEmpty">
         <source>MSB5006: Error parsing project section for project "{0}". The project file name is empty.</source>
-        <target state="translated">MSB5006: プロジェクト "{0}" のプロジェクト セクションを解析中にエラーが発生しました。プロジェクトのファイル名が空です。</target>
+        <target state="new">MSB5006: Error parsing project section for project "{0}". The project file name is empty.</target>
         <note>{StrBegin="MSB5006: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectSolutionConfigurationEntry">
         <source>MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="translated">MSB5007: ソリューション ファイル内のプロジェクト構成セクションを解析中にエラーが発生しました。エントリ "{0}" は無効です。</target>
+        <target state="new">MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</target>
         <note>{StrBegin="MSB5007: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidSolutionConfigurationEntry">
         <source>MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="translated">MSB5008: ソリューション ファイル内のソリューション構成セクションを解析中にエラーが発生しました。エントリ "{0}" は無効です。</target>
+        <target state="new">MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</target>
         <note>{StrBegin="MSB5008: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: ソリューション ファイル内の入れ子にされたプロジェクト セクションを解析中にエラーが発生しました。</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
         <source>MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</source>
-        <target state="translated">MSB5023: ソリューション ファイルの入れ子になったプロジェクト セクションを解析中にエラーが発生しました。GUID "{0}" のプロジェクトは、プロジェクト "{1}" 下に入れ子として表示されていますが、ソリューション内に存在しません。</target>
+        <target state="new">MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</target>
         <note>{StrBegin="MSB5023: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNoHeaderError">
         <source>MSB5010: No file format header found.</source>
-        <target state="translated">MSB5010: ファイル形式のヘッダーが見つかりませんでした。</target>
+        <target state="new">MSB5010: No file format header found.</target>
         <note>{StrBegin="MSB5010: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectDepGuidError">
         <source>MSB5011: Parent project GUID not found in "{0}" project dependency section.</source>
-        <target state="translated">MSB5011: 親プロジェクト GUID が "{0}" プロジェクト依存セクションで見つかりませんでした。</target>
+        <target state="new">MSB5011: Parent project GUID not found in "{0}" project dependency section.</target>
         <note>{StrBegin="MSB5011: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectEofError">
         <source>MSB5012: Unexpected end-of-file reached inside "{0}" project section.</source>
-        <target state="translated">MSB5012: "{0}" プロジェクト セクション内で、予期しない EOF に到達しました。</target>
+        <target state="new">MSB5012: Unexpected end-of-file reached inside "{0}" project section.</target>
         <note>{StrBegin="MSB5012: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectError">
         <source>MSB5013: Error parsing a project section.</source>
-        <target state="translated">MSB5013: プロジェクト セクションを解析中にエラーが発生しました。</target>
+        <target state="new">MSB5013: Error parsing a project section.</target>
         <note>{StrBegin="MSB5013: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseVersionMismatchError">
         <source>MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</source>
-        <target state="translated">MSB5014: ファイル形式のバージョンを認識できません。MSBuild で読み取ることができるのは、バージョン {0}.0 ～ {1}.0 のソリューション ファイルだけです。</target>
+        <target state="new">MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</target>
         <note>{StrBegin="MSB5014: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseWebProjectPropertiesError">
         <source>MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</source>
-        <target state="translated">MSB5015: "{0}" プロジェクトの WebsiteProperties セクションからプロパティを読み取れませんでした。</target>
+        <target state="new">MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</target>
         <note>{StrBegin="MSB5015: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
-      <trans-unit id="UnrecognizedSolutionComment">
-        <source>Unrecognized solution version "{0}", attempting to continue.</source>
-        <target state="translated">"{0}" は認識できないソリューション バージョンです。続行を試みます。</target>
-        <note />
+      <trans-unit id="SubCategoryForSchemaValidationErrors">
+        <source>Schema validation</source>
+        <target state="new">Schema validation</target>
+        <note>
+      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
+      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
+      "MSBUILD : Schema validation error MSB0000: This is an error."
+      LOCALIZATION: This fragment needs to be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SubCategoryForSolutionParsingErrors">
         <source>Solution file</source>
-        <target state="translated">ソリューション ファイル</target>
+        <target state="new">Solution file</target>
         <note>UE: this fragment is used to describe errors found while parsing solution files. For example, if a normal error is
       displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from solution parsing would look like this:
       "MSBUILD : Solution file error MSB0000: This is an error."
       LOCALIZATION: This fragment needs to be localized.</note>
       </trans-unit>
-      <trans-unit id="Shared.InvalidProjectFile">
-        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
-        <target state="translated">MSB5019: プロジェクト ファイルの形式が正しくありません: "{0}"。{1}</target>
-        <note>{StrBegin="MSB5019: "}</note>
-      </trans-unit>
-      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
-        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
-        <target state="translated">MSB5020: プロジェクト ファイル "{0}" を読み込めませんでした。{1}</target>
-        <note>{StrBegin="MSB5020: "}</note>
+      <trans-unit id="TaskNotMarshalByRef">
+        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
+        <target state="new">MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</target>
+        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
       </trans-unit>
-      <trans-unit id="Shared.KillingProcessByCancellation">
-        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
-        <target state="translated">MSB5021: ビルドが取り消されたため、実行可能なタスク "{0}" とその子プロセスを終了しています。</target>
-        <note>{StrBegin="MSB5021: "}</note>
+      <trans-unit id="UnauthorizedAccess">
+        <source>You do not have access to: {0}</source>
+        <target state="new">You do not have access to: {0}</target>
+        <note>Directory must have access</note>
       </trans-unit>
-      <trans-unit id="OM_NotSupportedReadOnlyCollection">
-        <source>This collection is read-only.</source>
-        <target state="translated">このコレクションは読み取り専用です。</target>
+      <trans-unit id="UnrecognizedSolutionComment">
+        <source>Unrecognized solution version "{0}", attempting to continue.</source>
+        <target state="new">Unrecognized solution version "{0}", attempting to continue.</target>
         <note />
       </trans-unit>
-      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
-        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
-        <target state="translated">MSB5024: MSBuild への有効な場所が決定できませんでした。Visual Studio の開発者コマンド プロンプトからこのプロセスを実行してください。</target>
-        <note>{StrBegin="MSB5024: "}</note>
-      </trans-unit>
-      <trans-unit id="InvalidLogFileFormat">
-        <source>MSB4233: There was an exception while reading the log file: {0}</source>
-        <target state="translated">MSB4233: ログ ファイルの読み取り中に例外が発生しました: {0}</target>
-        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
-      </trans-unit>
-      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
-        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
-        <target state="translated">値 "{1}" が割り当てられたパラメーター "{0}" には、無効なパスまたは無効なファイル内の文字を指定することはできません。</target>
-        <note />
+      <trans-unit id="UnrecognizedToolsVersion">
+        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
+        <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
+        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
       </trans-unit>
     </body>
   </file>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 3ec69e93682..0a9784913d7 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -65,6 +65,21 @@
         <target state="translated">경로: {0}은(는) OS 최대 경로 제한을 초과합니다. 정규화된 파일 이름은 {1}자 이하여야 합니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: 도구 버전 "{0}"을(를) 인식할 수 없습니다. 사용할 수 있는 도구 버전은 {1}입니다.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 2d38506af57..6d6f964b8a2 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Ścieżka: {0} przekracza limit maksymalnej długości ścieżki w systemie operacyjnym. W pełni kwalifikowana nazwa pliku musi się składać z mniej niż {1} znaków.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Wersja narzędzi „{0}” nie została rozpoznana. Dostępne wersje narzędzi to {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 4aa21acdb48..f2b419f77df 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Caminho: {0} excede o limite máximo do caminho do SO. O nome do arquivo totalmente qualificado deve ter menos de {1} caracteres.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: A versão das ferramentas "{0}" não é reconhecida. As versões das ferramentas disponíveis são {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index d37b4d76c6c..111a49830f4 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Длина пути {0} превышает максимально допустимую в ОС. Символов в полном имени файла должно быть не больше {1}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: версия инструментов "{0}" не распознана. Доступные версии инструментов: {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 24caa67ffa5..b0b741a3960 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Yol: {0}, işletim sisteminin en yüksek yol sınırını aşıyor. Tam dosya adı en fazla {1} karakter olmalıdır.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Araçlar sürümü "{0}" tanınmıyor. Kullanılabilir araç sürümleri şunlardır: {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 78941fb4a60..398938a8677 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -65,6 +65,21 @@
         <target state="translated">路径: {0} 超过 OS 最大路径限制。完全限定的文件名必须少于 {1} 个字符。</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: 无法识别工具版本“{0}”。可用的工具版本为 {1}。</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 8053d2d6e4b..418a2c2a06b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -65,6 +65,21 @@
         <target state="translated">路徑: {0} 超過 OS 路徑上限。完整檔案名稱必須少於 {1} 個字元。</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: 工具版本 "{0}" 無法辨認。可用的工具版本為 {1}。</target>
diff --git a/src/Shared/ReuseableStringBuilder.cs b/src/Shared/ReuseableStringBuilder.cs
index 655a43c9ddb..8f295e0b263 100644
--- a/src/Shared/ReuseableStringBuilder.cs
+++ b/src/Shared/ReuseableStringBuilder.cs
@@ -6,10 +6,8 @@
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
-using System.Reflection;
 using System.Text;
 using System.Threading;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Shared
 {
@@ -19,7 +17,7 @@ namespace Microsoft.Build.Shared
     /// <remarks>
     /// You can add any properties or methods on the real StringBuilder that are needed.
     /// </remarks>
-    internal sealed class ReuseableStringBuilder : IDisposable, OpportunisticIntern.IInternable
+    internal sealed class ReuseableStringBuilder : IDisposable, IInternable
     {
         /// <summary>
         /// Captured string builder.
@@ -63,7 +61,7 @@ public int Length
         /// <summary>
         /// Indexer into the target. Presumed to be fast.
         /// </summary>
-        char OpportunisticIntern.IInternable.this[int index]
+        char IInternable.this[int index]
         {
             get
             {
@@ -75,7 +73,7 @@ char OpportunisticIntern.IInternable.this[int index]
         /// <summary>
         /// Convert target to string. Presumed to be slow (and will be called just once).
         /// </summary>
-        string OpportunisticIntern.IInternable.ExpensiveConvertToString()
+        string IInternable.ExpensiveConvertToString()
         {
             if( _cachedString == null)
             {
@@ -96,14 +94,14 @@ string OpportunisticIntern.IInternable.ExpensiveConvertToString()
         /// <summary>
         /// Compare target to string. 
         /// </summary>
-        bool OpportunisticIntern.IInternable.StartsWithStringByOrdinalComparison(string other)
+        bool IInternable.StartsWithStringByOrdinalComparison(string other)
         {
 #if DEBUG
             ErrorUtilities.VerifyThrow(other.Length <= _borrowedBuilder.Length, "should be at most as long as target");
 #endif
             if (other.Length > MaxByCharCompareLength)
             {
-                return ((OpportunisticIntern.IInternable) this).ExpensiveConvertToString().StartsWith(other, StringComparison.Ordinal);
+                return ((IInternable) this).ExpensiveConvertToString().StartsWith(other, StringComparison.Ordinal);
             }
             // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
             // For example, C:\project1, C:\project2
@@ -121,7 +119,7 @@ bool OpportunisticIntern.IInternable.StartsWithStringByOrdinalComparison(string
         /// <summary>
         /// Never reference equals to string.
         /// </summary>
-        bool OpportunisticIntern.IInternable.ReferenceEquals(string other)
+        bool IInternable.ReferenceEquals(string other)
         {
             return false;
         }
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 2b816c7eaee..f826bb92f90 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -43,9 +43,14 @@ public Traits()
         public readonly bool CacheFileExistence = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildCacheFileExistence"));
 
         /// <summary>
-        /// Eliminate locking in OpportunisticIntern at the expense of memory
+        /// Use the legacy string interning implementation based on MRU lists.
         /// </summary>
-        public readonly bool UseSimpleInternConcurrency = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildUseSimpleInternConcurrency"));
+        public readonly bool UseLegacyStringInterner = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildUseLegacyStringInterner"));
+
+        /// <summary>
+        /// Eliminate locking in OpportunisticIntern at the expense of memory (in effect only if UseLegacyStringInterner is set).
+        /// </summary>
+        public readonly bool UseSimpleInternConcurrency = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildUseSimpleInternConcurrency"));
 
         public readonly bool UseSimpleProjectRootElementCacheConcurrency = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildUseSimpleProjectRootElementCacheConcurrency"));
 
@@ -61,6 +66,11 @@ public Traits()
         /// </summary>
         public readonly bool EnableRestoreFirst = Environment.GetEnvironmentVariable("MSBUILDENABLERESTOREFIRST") == "1";
 
+        /// <summary>
+        /// Allow the user to specify that two processes should not be communicating via an environment variable.
+        /// </summary>
+        public static readonly string MSBuildNodeHandshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+
         /// <summary>
         /// Setting the associated environment variable to 1 restores the pre-15.8 single
         /// threaded (slower) copy behavior. Zero implies Int32.MaxValue, less than zero
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
new file mode 100644
index 00000000000..20a1a75f2fa
--- /dev/null
+++ b/src/Shared/TranslatorHelpers.cs
@@ -0,0 +1,109 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// This class provides helper methods to adapt from <see cref="NodePacketValueFactory{T}"/> to
+    /// <see cref="ObjectTranslator{T}"/>.
+    /// </summary>
+    internal static class TranslatorHelpers
+    {
+        /// <summary>
+        /// Translates an object implementing <see cref="ITranslatable"/> which does not expose a
+        /// public parameterless constructor.
+        /// </summary>
+        /// <typeparam name="T">The reference type.</typeparam>
+        /// <param name="translator">The translator</param>
+        /// <param name="instance">The value to be translated.</param>
+        /// <param name="factory">The factory method used to instantiate values of type T.</param>
+        public static void Translate<T>(
+            this ITranslator translator,
+            ref T instance,
+            NodePacketValueFactory<T> valueFactory) where T : ITranslatable
+        {
+            if (!translator.TranslateNullable(instance))
+            {
+                return;
+            }
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                instance = valueFactory(translator);
+            }
+            else
+            {
+                instance.Translate(translator);
+            }
+        }
+
+        static ObjectTranslator<T> AdaptFactory<T>(NodePacketValueFactory<T> valueFactory) where T : ITranslatable
+        {
+            void Translate(ITranslator translator, ref T objectToTranslate)
+            {
+                TranslatorHelpers.Translate<T>(translator, ref objectToTranslate, valueFactory);
+            }
+
+            return Translate;
+        }
+
+        public static void Translate<T>(
+            this ITranslator translator,
+            ref List<T> list,
+            NodePacketValueFactory<T> valueFactory) where T : class, ITranslatable
+        {
+            translator.Translate(ref list, AdaptFactory(valueFactory));
+        }
+
+        public static void Translate<T, L>(
+            this ITranslator translator,
+            ref IList<T> list,
+            NodePacketValueFactory<T> valueFactory,
+            NodePacketCollectionCreator<L> collectionFactory) where L : IList<T> where T : ITranslatable
+        {
+            translator.Translate(ref list, AdaptFactory(valueFactory), collectionFactory);
+        }
+
+        public static void TranslateArray<T>(
+            this ITranslator translator,
+            ref T[] array,
+            NodePacketValueFactory<T> valueFactory) where T : class, ITranslatable
+        {
+            translator.TranslateArray(ref array, AdaptFactory(valueFactory));
+        }
+
+        public static void TranslateDictionary<T>(
+            this ITranslator translator,
+            ref Dictionary<string, T> dictionary,
+            IEqualityComparer<string> comparer,
+            NodePacketValueFactory<T> valueFactory) where T : class, ITranslatable
+        {
+            translator.TranslateDictionary(ref dictionary, comparer, AdaptFactory(valueFactory));
+        }
+
+        public static void TranslateDictionary<D, T>(
+            this ITranslator translator,
+            ref D dictionary,
+            NodePacketValueFactory<T> valueFactory)
+            where D : IDictionary<string, T>, new()
+            where T : class, ITranslatable
+        {
+            translator.TranslateDictionary(ref dictionary, AdaptFactory(valueFactory));
+        }
+
+        public static void TranslateDictionary<D, T>(
+            this ITranslator translator,
+            ref D dictionary,
+            NodePacketValueFactory<T> valueFactory,
+            NodePacketCollectionCreator<D> collectionCreator)
+            where D : IDictionary<string, T>
+            where T : class, ITranslatable
+        {
+            translator.TranslateDictionary(ref dictionary, AdaptFactory(valueFactory), collectionCreator);
+        }
+    }
+}
diff --git a/src/Shared/UnitTests/MockEngine.cs b/src/Shared/UnitTests/MockEngine.cs
index 2cf1154d834..bd745cab9e2 100644
--- a/src/Shared/UnitTests/MockEngine.cs
+++ b/src/Shared/UnitTests/MockEngine.cs
@@ -52,6 +52,8 @@ internal MockEngine() : this(false)
 
         internal int Errors { get; set; }
 
+        public bool AllowFailureWithoutError { get; set; } = true;
+
         public BuildErrorEventArgs[] ErrorEvents => _errorEvents.ToArray();
 
         public Dictionary<string, string> GlobalProperties { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 42d56c62448..62db95267d0 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1248,14 +1248,14 @@ internal static void AssertDictionariesEqual(IDictionary<string, string> x, IDic
                 });
         }
 
-        internal static void ShouldBeEquivalentTo<K, V>(this IDictionary<K, V> a, IReadOnlyDictionary<K, V> b)
+        internal static void ShouldBeSameIgnoringOrder<K, V>(this IDictionary<K, V> a, IReadOnlyDictionary<K, V> b)
         {
             a.ShouldBeSubsetOf(b);
             b.ShouldBeSubsetOf(a);
             a.Count.ShouldBe(b.Count);
         }
 
-        internal static void ShouldBeEquivalentTo<K>(this IEnumerable<K> a, IEnumerable<K> b)
+        internal static void ShouldBeSameIgnoringOrder<K>(this IEnumerable<K> a, IEnumerable<K> b)
         {
             a.ShouldBeSubsetOf(b);
             b.ShouldBeSubsetOf(a);
@@ -1293,11 +1293,9 @@ internal static void AssertEnumerationsValueEqual<T>(IEnumerable<T> one, IEnumer
         /// Build a project with the provided content in memory.
         /// Assert that it succeeded, and return the mock logger with the output.
         /// </summary>
-        internal static MockLogger BuildProjectWithNewOMExpectSuccess(string content, Dictionary<string, string> globalProperties = null)
+        internal static MockLogger BuildProjectWithNewOMExpectSuccess(string content, Dictionary<string, string> globalProperties = null, MockLogger logger = null)
         {
-            MockLogger logger;
-            bool result;
-            BuildProjectWithNewOM(content, out logger, out result, false, globalProperties);
+            BuildProjectWithNewOM(content, ref logger, out bool result, false, globalProperties);
             Assert.True(result);
 
             return logger;
@@ -1306,14 +1304,16 @@ internal static MockLogger BuildProjectWithNewOMExpectSuccess(string content, Di
         /// <summary>
         /// Build a project in memory using the new OM
         /// </summary>
-        private static void BuildProjectWithNewOM(string content, out MockLogger logger, out bool result, bool allowTaskCrash, Dictionary<string, string> globalProperties = null)
+        private static void BuildProjectWithNewOM(string content, ref MockLogger logger, out bool result, bool allowTaskCrash, Dictionary<string, string> globalProperties = null)
         {
             // Replace the crazy quotes with real ones
             content = ObjectModelHelpers.CleanupFileContents(content);
 
             Project project = new Project(XmlReader.Create(new StringReader(content)), globalProperties, toolsVersion: null);
-            logger = new MockLogger();
-            logger.AllowTaskCrashes = allowTaskCrash;
+            logger ??= new MockLogger
+            {
+                AllowTaskCrashes = allowTaskCrash
+            };
             List<ILogger> loggers = new List<ILogger>();
             loggers.Add(logger);
             result = project.Build(loggers);
@@ -1375,11 +1375,10 @@ public static BuildResult BuildProjectFileUsingBuildManager(string projectFile,
         /// Build a project with the provided content in memory.
         /// Assert that it fails, and return the mock logger with the output.
         /// </summary>
-        internal static MockLogger BuildProjectWithNewOMExpectFailure(string content, bool allowTaskCrash)
+        internal static MockLogger BuildProjectWithNewOMExpectFailure(string content, bool allowTaskCrash, MockLogger logger = null)
         {
-            MockLogger logger;
             bool result;
-            BuildProjectWithNewOM(content, out logger, out result, allowTaskCrash);
+            BuildProjectWithNewOM(content, ref logger, out result, allowTaskCrash);
             Assert.False(result);
             return logger;
         }
@@ -1567,6 +1566,34 @@ internal static TransientTestFile CreateProjectFile(
             return env.CreateFile(projectNumber + ".proj", sb.ToString());
         }
 
+        internal static ProjectGraph CreateProjectGraph(
+            TestEnvironment env,
+            IDictionary<int, int[]> dependencyEdges,
+            IDictionary<int, string> extraContentPerProjectNumber,
+            string extraContentForAllNodes = null)
+        {
+            return CreateProjectGraph(
+                env: env,
+                dependencyEdges: dependencyEdges,
+                globalProperties: null,
+                createProjectFile: (environment, projectNumber, references, projectReferenceTargets, defaultTargets, extraContent) =>
+                {
+                    extraContent = extraContentPerProjectNumber != null && extraContentPerProjectNumber.TryGetValue(projectNumber, out var content)
+                        ? content
+                        : string.Empty;
+
+                    extraContent += extraContentForAllNodes ?? string.Empty;
+
+                    return CreateProjectFile(
+                        environment,
+                        projectNumber,
+                        references,
+                        projectReferenceTargets,
+                        defaultTargets,
+                        extraContent.Cleanup());
+                });
+        }
+
         internal static ProjectGraph CreateProjectGraph(
             TestEnvironment env,
             // direct dependencies that the kvp.key node has on the nodes represented by kvp.value
diff --git a/src/Shared/WeakStringCache.Concurrent.cs b/src/Shared/WeakStringCache.Concurrent.cs
new file mode 100644
index 00000000000..310964fdd2d
--- /dev/null
+++ b/src/Shared/WeakStringCache.Concurrent.cs
@@ -0,0 +1,133 @@
+﻿
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+
+namespace Microsoft.Build
+{
+    /// <summary>
+    /// Implements the WeakStringCache functionality on modern .NET versions where ConcurrentDictionary is available.
+    /// </summary>
+    internal sealed partial class WeakStringCache : IDisposable
+    {
+        private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;
+
+        public WeakStringCache()
+        {
+            _stringsByHashCode = new ConcurrentDictionary<int, StringWeakHandle>(Environment.ProcessorCount, _initialCapacity);
+        }
+
+        /// <summary>
+        /// Main entrypoint of this cache. Tries to look up a string that matches the given internable. If it succeeds, returns
+        /// the string and sets cacheHit to true. If the string is not found, calls ExpensiveConvertToString on the internable,
+        /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
+        /// </summary>
+        /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <returns>A string matching the given internable.</returns>
+        /// <remarks>
+        /// This method performs one operation on the underlying ConcurrentDictionary on cache hit, and two or three operations on cache miss.
+        /// 1. It checks whether the dictionary has a matching entry. This operations is common to all code paths.
+        ///    If there is a matching entry we are done.
+        /// 2. If the dictionary doesn't have an entry for the given hash code, we make a new one and add it (the second operation).
+        ///    Note that we could do 1. and 2. together using GetOrAdd() with the valueFactory callback but it wouldn't be much faster
+        ///    and would require allocating a closure object to share data with the callback.
+        /// 3. If the dictionary has an entry for the given hash code but it doesn't match the argument because it's either already
+        ///    collected or there is a hash collision, we have to first remove the existing handle to prevent other threads from
+        ///    freeing it (second operation). Only then can it have the target set to the new string and be added back to the dictionary
+        ///    (third operation).
+        /// </remarks>
+        public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IInternable
+        {
+            int hashCode = GetInternableHashCode(internable);
+
+            StringWeakHandle handle;
+            string result;
+            bool addingNewHandle = false;
+
+            if (_stringsByHashCode.TryGetValue(hashCode, out handle))
+            {
+                result = handle.GetString(internable);
+                if (result != null)
+                {
+                    cacheHit = true;
+                    return result;
+                }
+            }
+            else
+            {
+                handle = new StringWeakHandle();
+                addingNewHandle = true;
+            }
+
+            // We don't have the string in the cache - create it.
+            result = internable.ExpensiveConvertToString();
+
+            // If the handle is new, we have to add it to the cache. We do it after removing unused handles if our heuristic
+            // indicates that it would be productive. Note that the _capacity field accesses are not protected from races. Being
+            // atomic (as guaranteed by the 32-bit data type) is enough here.
+            if (addingNewHandle)
+            {
+                // Prevent the dictionary from growing forever with GC handles that don't reference live strings anymore.
+                if (_stringsByHashCode.Count >= _scavengeThreshold)
+                {
+                    // Get rid of unused handles.
+                    Scavenge();
+                    // And do this again when the number of handles reaches double the current after-scavenge number.
+                    _scavengeThreshold = _stringsByHashCode.Count * 2;
+                }
+            }
+            else
+            {
+                // If the handle is already in the cache, we have to be careful because other threads may be operating on it.
+                // In particular the Scavenge method may free the handle from underneath us if we leave it in the cache.
+                if (!_stringsByHashCode.TryRemove(hashCode, out handle))
+                {
+                    // The handle is no longer in the cache so we're creating a new one after all.
+                    handle = new StringWeakHandle();
+                }
+            }
+
+            // Set the handle to reference the new string and put it in the cache.
+            handle.SetString(result);
+            if (!_stringsByHashCode.TryAdd(hashCode, handle))
+            {
+                // If somebody beat us to it and the new handle has not been added, free it.
+                handle.Free();
+            }
+
+            cacheHit = false;
+            return result;
+        }
+
+        /// <summary>
+        /// Iterates over the cache and removes unused GC handles, i.e. handles that don't reference live strings.
+        /// This is expensive so try to call such that the cost is amortized to O(1) per GetOrCreateEntry() invocation.
+        /// </summary>
+        public void Scavenge()
+        {
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                if (!entry.Value.IsUsed && _stringsByHashCode.TryRemove(entry.Key, out StringWeakHandle removedHandle))
+                {
+                    // Note that the removed handle may be different from the one we got from the enumerator so check again
+                    // and try to put it back if it's still in use.
+                    if (!removedHandle.IsUsed || !_stringsByHashCode.TryAdd(entry.Key, removedHandle))
+                    {
+                        removedHandle.Free();
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Returns internal debug counters calculated based on the current state of the cache.
+        /// </summary>
+        public DebugInfo GetDebugInfo()
+        {
+            return GetDebugInfoImpl();
+        }
+    }
+}
diff --git a/src/Shared/WeakStringCache.cs b/src/Shared/WeakStringCache.cs
new file mode 100644
index 00000000000..22021e1a08a
--- /dev/null
+++ b/src/Shared/WeakStringCache.cs
@@ -0,0 +1,149 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Runtime.InteropServices;
+
+namespace Microsoft.Build
+{
+    /// <summary>
+    /// A cache of weak GC handles pointing to strings. Weak GC handles are functionally equivalent to WeakReference's but have less overhead
+    /// (they're a struct as opposed to WR which is a finalizable class) at the expense of requiring manual lifetime management. As long as
+    /// a string has an ordinary strong GC root elsewhere in the process and another string with the same hashcode hasn't reused the entry,
+    /// the cache has a reference to it and can match it to an internable. When the string is collected, it is also automatically "removed"
+    /// from the cache by becoming unrecoverable from the GC handle. GC handles that do not reference a live string anymore are freed lazily.
+    /// </summary>
+    internal sealed partial class WeakStringCache : IDisposable
+    {
+        /// <summary>
+        /// Debug stats returned by GetDebugInfo().
+        /// </summary>
+        public struct DebugInfo
+        {
+            public int LiveStringCount;
+            public int CollectedStringCount;
+        }
+
+        /// <summary>
+        /// Holds a weak GC handle to a string. Shared by all strings with the same hash code and referencing the last such string we've seen.
+        /// </summary>
+        private struct StringWeakHandle
+        {
+            /// <summary>
+            /// Weak GC handle to the last string of the given hashcode we've seen.
+            /// </summary>
+            public GCHandle WeakHandle;
+
+            /// <summary>
+            /// Returns true if the string referenced by the handle is still alive.
+            /// </summary>
+            public bool IsUsed => WeakHandle.Target != null;
+
+            /// <summary>
+            /// Returns the string referenced by this handle if it is equal to the given internable.
+            /// </summary>
+            /// <param name="internable">The internable describing the string we're looking for.</param>
+            /// <returns>The string matching the internable or null if the handle is referencing a collected string or the string is different.</returns>
+            public string GetString<T>(T internable) where T : IInternable
+            {
+                if (WeakHandle.IsAllocated && WeakHandle.Target is string str)
+                {
+                    if (internable.Length == str.Length &&
+                        internable.StartsWithStringByOrdinalComparison(str))
+                    {
+                        return str;
+                    }
+                }
+                return null;
+            }
+
+            /// <summary>
+            /// Sets the handle to the given string. If the handle is still referencing another live string, that string is effectively forgotten.
+            /// </summary>
+            /// <param name="str">The string to set.</param>
+            public void SetString(string str)
+            {
+                if (!WeakHandle.IsAllocated)
+                {
+                    // The handle is not allocated - allocate it.
+                    WeakHandle = GCHandle.Alloc(str, GCHandleType.Weak);
+                }
+                else
+                {
+                    WeakHandle.Target = str;
+                }
+            }
+
+            /// <summary>
+            /// Frees the GC handle.
+            /// </summary>
+            public void Free()
+            {
+                WeakHandle.Free();
+            }
+        }
+
+        /// <summary>
+        /// Initial capacity of the underlying dictionary.
+        /// </summary>
+        private const int _initialCapacity = 503;
+
+        /// <summary>
+        /// The maximum size we let the collection grow before scavenging unused entries.
+        /// </summary>
+        private int _scavengeThreshold = _initialCapacity;
+
+        /// <summary>
+        /// Implements the simple yet very decently performing djb2 hash function (xor version).
+        /// </summary>
+        /// <param name="internable">The internable to compute the hash code for.</param>
+        /// <returns>The 32-bit hash code.</returns>
+        internal static int GetInternableHashCode<T>(T internable) where T : IInternable
+        {
+            int hashCode = 5381;
+            for (int i = 0; i < internable.Length; i++)
+            {
+                unchecked
+                {
+                    hashCode = hashCode * 33 ^ internable[i];
+                }
+            }
+            return hashCode;
+        }
+
+        /// <summary>
+        /// Frees all GC handles and clears the cache.
+        /// </summary>
+        public void Dispose()
+        {
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                entry.Value.Free();
+            }
+            _stringsByHashCode.Clear();
+        }
+
+        /// <summary>
+        /// Returns internal debug counters calculated based on the current state of the cache.
+        /// </summary>
+        private DebugInfo GetDebugInfoImpl()
+        {
+            DebugInfo debugInfo = new DebugInfo();
+
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                if (entry.Value.IsUsed)
+                {
+                    debugInfo.LiveStringCount++;
+                }
+                else
+                {
+                    debugInfo.CollectedStringCount++;
+                }
+            }
+
+            return debugInfo;
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs b/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
index 8dd512df8e7..4cf2b992ef4 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
@@ -93,7 +93,7 @@ public void AssemblyFoldersFromConfigPlatformSpecificAssemblyFirstTest()
         }
 
         [Fact]
-        public void AasemblyFoldersFromConfigNormalizeNetFrameworkVersion()
+        public void AssemblyFoldersFromConfigNormalizeNetFrameworkVersion()
         {
             var assemblyConfig = Path.GetTempFileName();
             File.WriteAllText(assemblyConfig, TestFile);
diff --git a/src/Tasks/FileIO/GetFileHash.cs b/src/Tasks/FileIO/GetFileHash.cs
index c9c17c6e23d..39ad392e8f8 100644
--- a/src/Tasks/FileIO/GetFileHash.cs
+++ b/src/Tasks/FileIO/GetFileHash.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Security.Cryptography;
+using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -19,6 +20,13 @@ public sealed class GetFileHash : TaskExtension
         internal const string _defaultFileHashAlgorithm = "SHA256";
         internal const string _hashEncodingHex = "hex";
         internal const string _hashEncodingBase64 = "base64";
+        internal static readonly Dictionary<string, Func<HashAlgorithm>> SupportedAlgorithms
+            = new Dictionary<string, Func<HashAlgorithm>>(StringComparer.OrdinalIgnoreCase)
+            {
+                ["SHA256"] = SHA256.Create,
+                ["SHA384"] = SHA384.Create,
+                ["SHA512"] = SHA512.Create,
+            };
 
         /// <summary>
         /// The files to be hashed.
@@ -55,7 +63,7 @@ public sealed class GetFileHash : TaskExtension
 
         public override bool Execute()
         {
-            if (!SupportsAlgorithm(Algorithm))
+            if (!SupportedAlgorithms.TryGetValue(Algorithm, out var algorithmFactory))
             {
                 Log.LogErrorWithCodeFromResources("FileHash.UnrecognizedHashAlgorithm", Algorithm);
                 return false;
@@ -67,26 +75,34 @@ public override bool Execute()
                 return false;
             }
 
-            foreach (var file in Files)
+            var writeLock = new object();
+            Parallel.For(0, Files.Length, index =>
             {
+                var file = Files[index];
+
                 if (!FileSystems.Default.FileExists(file.ItemSpec))
                 {
                     Log.LogErrorWithCodeFromResources("FileHash.FileNotFound", file.ItemSpec);
+                    return;
                 }
-            }
+
+                var hash = ComputeHash(algorithmFactory, file.ItemSpec);
+                var encodedHash = EncodeHash(encoding, hash);
+
+                lock (writeLock)
+                {
+                    // We cannot guarantee Files instances are unique. Write to it inside a lock to
+                    // avoid concurrent edits.
+                    file.SetMetadata("FileHashAlgorithm", Algorithm);
+                    file.SetMetadata(MetadataName, encodedHash);
+                }
+            });
 
             if (Log.HasLoggedErrors)
             {
                 return false;
             }
 
-            foreach (var file in Files)
-            {
-                var hash = ComputeHash(Algorithm, file.ItemSpec);
-                file.SetMetadata("FileHashAlgorithm", Algorithm);
-                file.SetMetadata(MetadataName, EncodeHash(encoding, hash));
-            }
-
             Items = Files;
 
             if (Files.Length == 1)
@@ -113,39 +129,13 @@ internal static string EncodeHash(HashEncoding encoding, byte[] hash)
         internal static bool TryParseHashEncoding(string value, out HashEncoding encoding)
             => Enum.TryParse<HashEncoding>(value, /*ignoreCase:*/ true, out encoding);
 
-        internal static bool SupportsAlgorithm(string algorithmName)
-            => _supportedAlgorithms.Contains(algorithmName);
-
-        internal static byte[] ComputeHash(string algorithmName, string filePath)
+        internal static byte[] ComputeHash(Func<HashAlgorithm> algorithmFactory, string filePath)
         {
             using (var stream = File.OpenRead(filePath))
-            using (var algorithm = CreateAlgorithm(algorithmName))
+            using (var algorithm = algorithmFactory())
             {
                 return algorithm.ComputeHash(stream);
             }
         }
-
-        private static readonly HashSet<string> _supportedAlgorithms
-            = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
-            {
-                "SHA256",
-                "SHA384",
-                "SHA512",
-            };
-
-        private static HashAlgorithm CreateAlgorithm(string algorithmName)
-        {
-            switch (algorithmName.ToUpperInvariant())
-            {
-                case "SHA256":
-                    return SHA256.Create();
-                case "SHA384":
-                    return SHA384.Create();
-                case "SHA512":
-                    return SHA512.Create();
-                default:
-                    throw new ArgumentOutOfRangeException();
-            }
-        }
     }
 }
diff --git a/src/Tasks/FileIO/VerifyFileHash.cs b/src/Tasks/FileIO/VerifyFileHash.cs
index 9f3b30540dd..5addbea5571 100644
--- a/src/Tasks/FileIO/VerifyFileHash.cs
+++ b/src/Tasks/FileIO/VerifyFileHash.cs
@@ -44,7 +44,7 @@ public override bool Execute()
                 return false;
             }
 
-            if (!GetFileHash.SupportsAlgorithm(Algorithm))
+            if (!GetFileHash.SupportedAlgorithms.TryGetValue(Algorithm, out var algorithmFactory))
             {
                 Log.LogErrorWithCodeFromResources("FileHash.UnrecognizedHashAlgorithm", Algorithm);
                 return false;
@@ -56,7 +56,7 @@ public override bool Execute()
                 return false;
             }
 
-            byte[] hash = GetFileHash.ComputeHash(Algorithm, File);
+            byte[] hash = GetFileHash.ComputeHash(algorithmFactory, File);
             string actualHash = GetFileHash.EncodeHash(encoding, hash);
             var comparison = encoding == Tasks.HashEncoding.Hex
                 ? StringComparison.OrdinalIgnoreCase
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 9f65aed2c43..5cd0ab89409 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -81,6 +81,15 @@
     <Compile Include="..\Shared\NGen.cs">
       <Link>NGen.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IInternable.cs">
+      <Link>IInternable.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.cs">
+      <Link>WeakStringCache.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
+      <Link>WeakStringCache.Concurrent.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\OpportunisticIntern.cs">
       <Link>OpportunisticIntern.cs</Link>
     </Compile>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 794392b6202..9f6a5fae91d 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -86,8 +86,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <PropertyGroup>
-    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == ''">Windows</TargetPlatformIdentifier>
-    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == ''">7.0</TargetPlatformVersion>
+    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == '' and '$(_EnableDefaultWindowsPlatform)' != 'false'">Windows</TargetPlatformIdentifier>
+    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == '' and '$(_EnableDefaultWindowsPlatform)' != 'false'">7.0</TargetPlatformVersion>
     <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == '' and '$(TargetPlatformSdkRootOverride)' != ''">$(TargetPlatformSdkRootOverride)\</TargetPlatformSdkPath>
     <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and '$(OS)' == 'Windows_NT' and '$(MSBuildRuntimeType)' != 'Core'">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\Software\Microsoft\Microsoft SDKs\Windows\v$(TargetPlatformVersion)', InstallationFolder, null, RegistryView.Registry32, RegistryView.Default))</TargetPlatformSdkPath>
     <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKLocation($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformSdkPath>
@@ -2666,7 +2666,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
         [IN]
         @(COMReference) - The list of COM references
-        $(BaseIntermediateOutputPath) - The output directory in which to generate wrapper assemblies
+        $(InteropOutputPath) - The output directory in which to generate wrapper assemblies
+                               When $(InteropOutputPath) is not set, then it defaults to $(IntermediateOutputPath).
 
         [OUT]
         @(ReferencePath) - Paths to referenced wrappers.
@@ -4572,6 +4573,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="TargetOutputs" ItemName="_ThisProjectItemsToCopyToOutputDirectory" />
     </CallTarget>
 
+    <ItemGroup Condition="'$(CopyConflictingTransitiveContent)' == 'false'">
+      <_TransitiveItemsToCopyToOutputDirectory Remove="@(_ThisProjectItemsToCopyToOutputDirectory)" MatchOnMetadata="TargetPath" MatchOnMetadataOptions="PathLike" />
+    </ItemGroup>
+
     <ItemGroup>
       <_TransitiveItemsToCopyToOutputDirectoryAlways               KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='Always'"/>
       <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest       KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='PreserveNewest'"/>
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index e78168f28b0..89e402b0582 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -174,4 +174,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <NuGetPropsFile Condition="'$(NuGetPropsFile)'==''">$(MSBuildToolsPath)\NuGet.props</NuGetPropsFile>
   </PropertyGroup>
   <Import Condition="Exists('$(NuGetPropsFile)')" Project="$(NuGetPropsFile)" />
+
+  <PropertyGroup Condition=" '$(MSBuildLogVerboseTaskParameters)' != 'true' ">
+    <DisableLogTaskParameter_ConvertToAbsolutePath_Path>true</DisableLogTaskParameter_ConvertToAbsolutePath_Path>
+    <DisableLogTaskParameter_FindUnderPath_OutOfPath>true</DisableLogTaskParameter_FindUnderPath_OutOfPath>
+    <DisableLogTaskParameter_RemoveDuplicates_Inputs>true</DisableLogTaskParameter_RemoveDuplicates_Inputs>
+    <DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>true</DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>
+    <DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>true</DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>
+    <DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>true</DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>
+    <DisableLogTaskParameterItemMetadata_Copy_SourceFiles>true</DisableLogTaskParameterItemMetadata_Copy_SourceFiles>
+    <DisableLogTaskParameterItemMetadata_FindUnderPath_Files>true</DisableLogTaskParameterItemMetadata_FindUnderPath_Files>
+    <DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>true</DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>
+    <DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>true</DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>
+    <DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>true</DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>
+    <DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>true</DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>
+    <DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>true</DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>
+  </PropertyGroup>
 </Project>
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index c372dcbd388..243c49179e2 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -20,13 +20,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
    </PropertyGroup>
 
    <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
-      <!-- Microsoft.Net.Sdk adds all transitive project references to ProjectReference. It does this at build time
-           via a target. This fails the undeclared msbuild reference /isolate constraint, so disable transitive
-           references.
-           Do not disable transitive references if BuildProjectReferences is false. If building references is false,
-           then MSBuild won't try to build the transitive references, which won't trigger undeclared reference constraints.
-          -->
-      <DisableTransitiveProjectReferences Condition="'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''">true</DisableTransitiveProjectReferences>
+      <AddTransitiveProjectReferencesInStaticGraph Condition="'$(AddTransitiveProjectReferencesInStaticGraph)' == '' and '$(UsingMicrosoftNETSdk)' == 'true' and '$(DisableTransitiveProjectReferences)' != 'true'">true</AddTransitiveProjectReferencesInStaticGraph>
    </PropertyGroup>
 
    <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
@@ -43,7 +37,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     Properties for extension of ProjectReferenceTargets.
     Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
   -->
-  <PropertyGroup>
+  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
     <!-- Empty case is for outer builds which do not import the target files that set BuildProjectReferences -->
     <_MainReferenceTarget Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTarget>
     <_MainReferenceTarget Condition="'$(_MainReferenceTarget)' == ''">GetTargetPath</_MainReferenceTarget>
@@ -61,7 +55,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
   </PropertyGroup>
 
-  <ItemGroup>
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true"/>
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
 
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets b/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
index 1df60920670..e39ebb16d75 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
@@ -123,8 +123,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />
     </ItemGroup>
 
-    <Message Importance="Low" Text="Including @(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />
-
   </Target>
 
 
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 7519a6f4fc3..9598c9d6157 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: Úloha {0} se ve verzi MSBuildu .NET Core nepodporuje. Použijte místo ní balíček Microsoft XML Serializer Generator. Další informace najdete na adrese https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index f7321dd89e8..69c726c62a4 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: Die Aufgabe "{0}" wird in der .NET Core-Version von MSBuild nicht unterstützt. Verwenden Sie stattdessen das Microsoft XML Serializer Generator-Paket. Weitere Informationen finden Sie unter https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 21f8661c841..e34aa053c3e 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: La tarea "{0}" no se admite en la versión .NET Core de MSBuild. En su lugar, use el paquete del Generador de serializador XML de Microsoft. Consulte https://go.microsoft.com/fwlink/?linkid=858594 para obtener más información.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 38b460aadf1..9720b69bf5f 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: la tâche "{0}" n'est pas prise en charge dans la version .NET Core de MSBuild. Utilisez le package Microsoft XML Serializer Generator à la place. Pour plus d'informations, consultez https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index ec92efbf907..99cc118cd38 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: l'attività "{0}" non è supportata nella versione .NET Core di MSBuild. Usare il pacchetto dello strumento Microsoft per la generazione di serializzatori XML. Per altre informazioni, vedere https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 5b9101c3bbe..e209c62b2f7 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: タスク "{0}" は、MSBuild の .NET Core バージョンではサポートされていません。代わりに Microsoft XML Serializer Generator パッケージを使用してください。詳細については、https://go.microsoft.com/fwlink/?linkid=858594 をご覧ください。</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 07683139d84..2e70e167585 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: MSBuild .NET Core 버전에서는 "{0}" 작업이 지원되지 않습니다. Microsoft XML Serializer Generator 패키지를 대신 사용합니다. 자세한 내용은 https://go.microsoft.com/fwlink/?linkid=858594를 참조하세요.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 9216490676c..6b53dc24fb7 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: zadanie „{0}” nie jest obsługiwane w wersji platformy .NET Core programu MSBuild. Zamiast tego użyj pakietu narzędzia Microsoft XML Serializer Generator. Aby uzyskać więcej informacji, zobacz https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index b9ce1ded3e1..0d31dafd981 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: Não há suporte para a tarefa "{0}" na versão .NET Core do MSBuild. Nesse caso, use o pacote do XML Serializer Generator da Microsoft. Confira https://go.microsoft.com/fwlink/?linkid=858594 para obter mais informações.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index e114c230d35..29fe42402d0 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: задача "{0}" не поддерживается в версии .NET Core MSBuild. Используйте вместо нее пакет Microsoft XML Serializer Generator. Дополнительные сведения см. на странице https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 071ee4d4150..5076d987e41 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: "{0}" görevi, MSBuild'in .NET Core sürümünde desteklenmiyor. Bunun yerine Microsoft XML Serileştiricisi Oluşturma paketini kullanın. Daha fazla bilgi için bkz. https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 6741ccbae04..2797e21cd0b 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: MSBuild 的 .NET Core 版本上不支持任务“{0}”。请改用 Microsoft XML 序列化程序生成器包。有关详细信息，请参阅 https://go.microsoft.com/fwlink/?linkid=858594。</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 631aefccbe8..05c4f11672b 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: MSBuild 的 .NET Core 版本不支援工作 "{0}"。請改用 Microsoft XML 序列化程式產生器套件。如需詳細資訊，請參閱 https://go.microsoft.com/fwlink/?linkid=858594。</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 3843a338df1..30db3703d9b 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -63,6 +63,15 @@
     <Compile Include="..\Shared\NativeMethodsShared.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IInternable.cs">
+      <Link>IInternable.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.cs">
+      <Link>WeakStringCache.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
+      <Link>WeakStringCache.Concurrent.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\OpportunisticIntern.cs">
       <Link>OpportunisticIntern.cs</Link>
     </Compile>
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 58d4be5273c..9dda37aa360 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -117,6 +117,10 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                 successfulExit = p.ExitCode == 0;
             }
 
+            outputHelper?.WriteLine("==== OUTPUT ====");
+            outputHelper?.WriteLine(output);
+            outputHelper?.WriteLine("==============");
+
             Console.WriteLine("==== OUTPUT ====");
             Console.WriteLine(output);
             Console.WriteLine("==============");
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index e77bd5df12b..e8b84435ca2 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -127,6 +127,15 @@
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>Shared\InprocTrackingNativeMethods.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IInternable.cs">
+      <Link>Shared\IInternable.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.cs">
+      <Link>Shared\WeakStringCache.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
+      <Link>Shared\WeakStringCache.Concurrent.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\OpportunisticIntern.cs">
       <Link>Shared\OpportunisticIntern.cs</Link>
     </Compile>
