diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 844fec05dbb..6d60820d15a 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -33,18 +33,19 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/log/Debug'
-      ArtifactName: 'FullOnWindows build logs'
+      targetPath: 'artifacts/log/Debug'
+      artifact: 'FullOnWindows build logs'
+      publishLocation: 'pipeline'
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'FullOnWindows test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'FullOnWindows test logs'
     continueOnError: true
     condition: always()
 
@@ -78,18 +79,18 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/log/Debug'
-      ArtifactName: 'CoreOnWindows build logs'
+      path: 'artifacts/log/Debug'
+      artifactName: 'CoreOnWindows build logs'
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'CoreOnWindows test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'CoreOnWindows test logs'
     continueOnError: true
     condition: always()
 
@@ -123,18 +124,18 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/Log/Release'
-      ArtifactName: 'FullOnWindows Release build logs'
+      path: 'artifacts/Log/Release'
+      artifactName: 'FullOnWindows Release build logs'
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'FullOnWindows Release test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'FullOnWindows Release test logs'
     continueOnError: true
     condition: always()
 
@@ -155,18 +156,18 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/log/Debug'
-      ArtifactName: 'CoreOnLinux build logs'
+      path: 'artifacts/log/Debug'
+      artifactName: 'CoreOnLinux build logs'
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'CoreOnLinux test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'CoreOnLinux test logs'
     continueOnError: true
     condition: always()
 
@@ -187,18 +188,18 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/log/Debug'
-      ArtifactName: 'CoreOnMac build logs'
+      path: 'artifacts/log/Debug'
+      artifactName: 'CoreOnMac build logs'
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'CoreOnMac test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'CoreOnMac test logs'
     continueOnError: true
     condition: always()
 
@@ -227,16 +228,16 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: logs'
     inputs:
-      PathtoPublish: 'artifacts/log'
-      ArtifactName: 'MonoOnMac build logs'
+      path: 'artifacts/log'
+      artifactName: 'MonoOnMac build logs'
     condition: always()
-  - task: PublishBuildArtifacts@1
+  - task: PublishPipelineArtifact@1
     displayName: 'Publish Artifact: TestResults'
     inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'MonoOnMac test logs'
+      path: 'artifacts/TestResults'
+      artifactName: 'MonoOnMac test logs'
     continueOnError: true
     condition: always()
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 0ce3034d70b..b54fe9462e0 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -31,7 +31,6 @@ stages:
       name: VSEng-MicroBuildVS2019
       demands:
       - agent.os -equals Windows_NT
-      - VSTS_OS -equals Windows_Server_2019_Data_Center_with_Containers
 
     timeoutInMinutes: 180
 
@@ -133,26 +132,25 @@ stages:
       condition: succeeded()
 
     # Publish bootstrapper info
-    - task: PublishBuildArtifacts@1
+    - task: PublishPipelineArtifact@1
       inputs:
-        PathtoPublish: $(Build.StagingDirectory)\MicroBuild\Output
-        ArtifactName: MicroBuildOutputs
-        ArtifactType: Container
+        path: $(Build.StagingDirectory)\MicroBuild\Output
+        artifactName: MicroBuildOutputs
       displayName: 'OptProf - Publish Artifact: MicroBuildOutputs'
       condition: succeeded()
 
-    - task: PublishBuildArtifacts@1
+    - task: PublishPipelineArtifact@1
       displayName: 'Publish Artifact: logs'
       inputs:
-        PathtoPublish: 'artifacts\log\$(BuildConfiguration)'
-        ArtifactName: logs
+        path: 'artifacts\log\$(BuildConfiguration)'
+        artifactName: logs
       condition: succeededOrFailed()
 
-    - task: PublishBuildArtifacts@1
-      displayName: 'Publish Artifact: symbols'
+    - task: PublishPipelineArtifact@1
+      displayName: 'Publish Artifact: bin'
       inputs:
-        PathtoPublish: 'artifacts\bin'
-        ArtifactName: symbols
+        path: 'artifacts\bin'
+        artifactName: bin
       condition: succeededOrFailed()
 
     # Publishes setup VSIXes to a drop.
@@ -165,29 +163,11 @@ stages:
       condition: succeeded()
 
     # Publish an artifact that the RoslynInsertionTool is able to find by its name.
-    - task: PublishBuildArtifacts@1
+    - task: PublishPipelineArtifact@1
       displayName: 'Publish Artifact: VSSetup'
       inputs:
-        PathtoPublish: 'artifacts\VSSetup\$(BuildConfiguration)'
-        ArtifactName: VSSetup
-      condition: succeeded()
-
-    # Archive NuGet packages to DevOps.
-    # Publish our NuPkgs as an artifact. The name of this artifact must be PackageArtifacts as the 
-    # arcade templates depend on the name.
-    - task: PublishBuildArtifacts@1
-      displayName: 'Publish Artifact: packages'
-      inputs:
-        PathtoPublish: 'artifacts\packages\$(BuildConfiguration)'
-        ArtifactName: PackageArtifacts
-      condition: succeeded()
-
-    # Publish Asset Manifests for Build Asset Registry job
-    - task: PublishBuildArtifacts@1
-      displayName: Publish Asset Manifests
-      inputs:
-        PathtoPublish: '$(Build.SourcesDirectory)/artifacts/log/$(BuildConfiguration)/AssetManifest'
-        ArtifactName: AssetManifests
+        path: 'artifacts\VSSetup\$(BuildConfiguration)'
+        artifactName: VSSetup
       condition: succeeded()
 
     # Tag the build at the very end when we know it's been successful.
diff --git a/Directory.Build.targets b/Directory.Build.targets
index 289480d734a..177373cd81e 100644
--- a/Directory.Build.targets
+++ b/Directory.Build.targets
@@ -15,4 +15,16 @@
   </PropertyGroup>
   <Import Project="Sdk.targets" Sdk="Microsoft.Build.CentralPackageVersions" />
   <Import Project="Sdk.targets" Sdk="Microsoft.DotNet.Arcade.Sdk" />
+
+  <Target Name="DeleteDevPackage" AfterTargets="GenerateNuspec">
+    <!-- If package just built was already in global packages folder, delete it.  This helps support a local dev cycle where you are consuming
+         a package from another repo without having to update the package version each time. -->
+    
+    <PropertyGroup>
+      <_PackageFolderInGlobalPackages>$(NuGetPackageRoot)$(PackageId.ToLowerInvariant())\$(PackageVersion)</_PackageFolderInGlobalPackages>
+    </PropertyGroup>
+
+    <RemoveDir Directories="$(_PackageFolderInGlobalPackages)"
+               Condition="Exists('$(_PackageFolderInGlobalPackages)')" />
+  </Target>
 </Project>
diff --git a/MSBuild.Dev.sln b/MSBuild.Dev.sln
index 2c02e70c642..8fc92510fca 100644
--- a/MSBuild.Dev.sln
+++ b/MSBuild.Dev.sln
@@ -3,6 +3,12 @@ Microsoft Visual Studio Solution File, Format Version 12.00
 # Visual Studio 15
 VisualStudioVersion = 15.0.27004.2009
 MinimumVisualStudioVersion = 10.0.40219.1
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
+	ProjectSection(SolutionItems) = preProject
+		..\NuGet.Config = ..\NuGet.Config
+		..\targets\xunit.runner.json = ..\targets\xunit.runner.json
+	EndProjectSection
+EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build", "src\Build\Microsoft.Build.csproj", "{69BE05E2-CBDA-4D27-9733-44E12B0F5627}"
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Engine.OM.UnitTests", "src\Build.OM.UnitTests\Microsoft.Build.Engine.OM.UnitTests.csproj", "{5C53E4FD-0985-432D-B9E4-7BC354A057E5}"
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 39880a118e9..03b9e7d5087 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -25,8 +25,8 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 
 One can run MSBuild with eventing using the following command:
 
-`PerfView /OnlyProviders=*Microsoft-VisualStudio-Common run MSBuild.exe <project to build>`
+`PerfView /OnlyProviders=*Microsoft-Build run MSBuild.exe <project to build>`
 
 For example, if PerfView is one level up from my current directory (which has MSBuild.exe), and I want to build MSBuild.sln on Windows, I would use the following command:
 
-`..\PerfView /OnlyProviders=*Microsoft-VisualStudio-Common run .\MSBuild.exe .\MSBuild.sln`
+`..\PerfView /OnlyProviders=*Microsoft-Build run .\MSBuild.exe .\MSBuild.sln`
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index e4f4b600c6d..e1895c63eba 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -82,7 +82,7 @@ It is a `GZipStream`-compressed binary stream of serialized `BuildEventArgs` obj
 
 ## Incrementing the file format
 
-Every .binlog file has the first three bytes that indicate the file version. The current file format version is 2 (`00 00 02`).
+Every .binlog file has the first three bytes that indicate the file version. The current file format version is 9 (`00 00 09`).
 
 When incrementing the file format, keep this in mind:
  * Increment the version and add a summary of the changes: https://github.com/Microsoft/msbuild/blob/master/src/Build/Logging/BinaryLogger/BinaryLogger.cs#L22
diff --git a/documentation/wiki/Localization.md b/documentation/wiki/Localization.md
index 9a65e553f65..e0d31a285b8 100644
--- a/documentation/wiki/Localization.md
+++ b/documentation/wiki/Localization.md
@@ -1,4 +1,7 @@
+# Localizing MSBuild
+
 ## Localizable resource structure
+
 - Neutral resources: [*resx](https://github.com/search?utf8=%E2%9C%93&q=repo%3AMicrosoft%2Fmsbuild+extension%3Aresx&type=Code&ref=advsearch&l=&l=)
 - `Strings.shared.resx` is a shared resource and gets embedded into all msbuild dlls
 - each neutral resource has a directory named `xlf` besides it which contains its localized strings in .xlf format
@@ -6,18 +9,43 @@
 - the logical name for a resource is: `<Assembly Name>.<Neutral Resx File Name>.resources`. In the ResourceManager this appears as `<Assembly Name>.<Neutral Resx File Name>` (without the trailing `.resources`). For example, the `Microsoft.Build` assembly uses the `Microsoft.Build.Strings.resources` [logical resource name](https://github.com/Microsoft/msbuild/blob/master/src/XMakeBuildEngine/Microsoft.Build.csproj#L659) (the resource file is `Strings.resx`), and its corresponding [ResourceManager](https://github.com/Microsoft/msbuild/blob/master/src/XMakeBuildEngine/Resources/AssemblyResources.cs#L116) uses `Microsoft.Build.Strings`.
 
 ## How to edit a resource
+
 - if you need to add / remove / update a resource, only do so in the neutral resx files. xlf files get automatically updated during localized builds.
 
 ## What a localized build does
+
 - converts xlf files to localized resx files
 - the localized resx files are generated into the `$(IntermediaryOutputPath)`
 - produces satellite assemblies for each language
- - satellite assemblies are used even on English machines. This is for testing purposes, to ensure that English builds are not different than non English builds
+- satellite assemblies are used even on English machines. This is for testing purposes, to ensure that English builds are not different than non English builds
 
 ## Process for interacting with the localization team
+
 - 3 weeks cadence for master, initiated by loc team
 - on demand for master / release branches, initiated by msbuild team
 
 ## Contributing a better translation
+
 - send a PR with an updated `<target>` element of the xlf resource (do not include other non-localization changes)
 - we will notify the localization team, which will then take over and review the PR
+
+## Localizing XSD "IntelliSense"
+
+Code completion ("IntelliSense") for MSBuild project files is provided minimally in Visual Studio by XML Schema files like [`Microsoft.Build.CommonTypes.xsd`](https://github.com/microsoft/msbuild/blob/ba9a1d64a7abf15a8505827c00413156a3eb7f62/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd). These files are English-only in the GitHub repo; their localization is managed in the Microsoft-internal `VS` repo.
+
+### If there is a bug in XSD localization
+
+File xsd localization bugs in this repo. The MSBuild team will coordinate with the Visual Studio localization team to redirect it appropriately.
+
+### When an XSD has been updated
+
+After updating an XSD in the GitHub repo, someone with internal access must update the copy in the `VS` repo. To do so:
+
+1. Locally clone VS following the standard instructions.
+2. Locally update your clone of the GitHub msbuild repo to include the merge of the change.
+3. Start a new branch in the VS repository from the current working branch (probably `master`).
+4. Copy from the msbuild path `src/MSBuild/MSBuild/*.xsd` to the VS path `src/xmake/XMakeCommandLine`.
+5. Ensure that the commit message has a full link to the commit used to update the `.xsd` files, like `https://github.com/microsoft/msbuild/commit/ba9a1d64a7abf15a8505827c00413156a3eb7f62`.
+6. Push and submit through the usual VS PR process, including the `MSBuild` team as reviewers.
+
+Example PR doing this: https://dev.azure.com/devdiv/DevDiv/_git/VS/pullrequest/186890.
diff --git a/documentation/wiki/ResolveAssemblyReference.md b/documentation/wiki/ResolveAssemblyReference.md
index 2a1b7060e85..cd0e51172b3 100644
--- a/documentation/wiki/ResolveAssemblyReference.md
+++ b/documentation/wiki/ResolveAssemblyReference.md
@@ -9,7 +9,7 @@ If you notice the ordering, ResolveAssemblyReferences is happening before Compil
 
 ## Source Code
 You can browse Microsoft's MSBuild targets online at:
-http://source.roslyn.io/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.CurrentVersion.targets,1820
+https://github.com/microsoft/msbuild/blob/a936b97e30679dcea4d99c362efa6f732c9d3587/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1991-L2140
 This is where the RAR task is invoked in the targets file.
 
 The source code for RAR is at:
@@ -149,4 +149,4 @@ There were recent fixes made to RAR to alleviate the situation. You can control
 
 A common situation is MSBuild gives a warning about different versions of the same assembly being used by different references. The solution often involves adding a binding redirect to the app.config file. 
 
-A useful way to investigate these conflicts is to search in MSBuild Structured Log Viewer for "There was a conflict". It will show you detailed information about which references needed which versions of the assembly in question.
\ No newline at end of file
+A useful way to investigate these conflicts is to search in MSBuild Structured Log Viewer for "There was a conflict". It will show you detailed information about which references needed which versions of the assembly in question.
diff --git a/eng/Packages.props b/eng/Packages.props
index b8ebc96c259..d3ac170588d 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -18,6 +18,7 @@
     <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="1.16.30" />
     <PackageReference Update="Microsoft.Win32.Registry" Version="4.3.0" />
     <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
+    <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="PdbGit" Version="3.0.41" />
     <PackageReference Update="Shouldly" Version="3.0.0" />
     <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
@@ -40,6 +41,7 @@
     <PackageReference Update="System.Security.Permissions" Version="4.7.0" />
     <PackageReference Update="System.Security.Principal.Windows" Version="4.7.0" />
     <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
+    <PackageReference Update="System.Text.Json" Version="4.7.0" />
     <PackageReference Update="System.Threading.Tasks.Dataflow" Version="4.9.0" />
     <PackageReference Update="System.Threading.Thread" Version="4.0.0" />
     <PackageReference Update="System.Xml.XPath" Version="4.3.0" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 3aa465663ec..5c670906e71 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20215.5">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20302.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>36fd49bf87b14b78d722179b787e6518b5205518</Sha>
+      <Sha>9b71be0663493cd0e111b55536a2e1eeb272f54c</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 1aedd883c78..e20df56fead 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -30,6 +30,9 @@
     <UsingToolVisualStudioIbcTraining>true</UsingToolVisualStudioIbcTraining>
     <UsingToolSymbolUploader>true</UsingToolSymbolUploader>
     <UsingToolVSSDK>true</UsingToolVSSDK>
+    <!-- Override Arcade's default VSSDK version with one that supports client enablement.
+         Can be removed after Arcade moves up. -->
+    <MicrosoftVSSDKBuildToolsVersion>16.7.13</MicrosoftVSSDKBuildToolsVersion>
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
diff --git a/eng/common/darc-init.ps1 b/eng/common/darc-init.ps1
index b94c2f4e411..435e7641341 100644
--- a/eng/common/darc-init.ps1
+++ b/eng/common/darc-init.ps1
@@ -1,13 +1,14 @@
 param (
     $darcVersion = $null,
-    $versionEndpoint = "https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16",
-    $verbosity = "m"
+    $versionEndpoint = 'https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16',
+    $verbosity = 'minimal',
+    $toolpath = $null
 )
 
 . $PSScriptRoot\tools.ps1
 
-function InstallDarcCli ($darcVersion) {
-  $darcCliPackageName = "microsoft.dotnet.darc"
+function InstallDarcCli ($darcVersion, $toolpath) {
+  $darcCliPackageName = 'microsoft.dotnet.darc'
 
   $dotnetRoot = InitializeDotNetCli -install:$true
   $dotnet = "$dotnetRoot\dotnet.exe"
@@ -23,11 +24,24 @@ function InstallDarcCli ($darcVersion) {
     $darcVersion = $(Invoke-WebRequest -Uri $versionEndpoint -UseBasicParsing).Content
   }
 
-  $arcadeServicesSource = 'https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json'
+  $arcadeServicesSource = 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
 
   Write-Host "Installing Darc CLI version $darcVersion..."
-  Write-Host "You may need to restart your command window if this is the first dotnet tool you have installed."
-  & "$dotnet" tool install $darcCliPackageName --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g --framework netcoreapp2.1
+  Write-Host 'You may need to restart your command window if this is the first dotnet tool you have installed.'
+  if (-not $toolpath) {
+    Write-Host "'$dotnet' tool install $darcCliPackageName --version $darcVersion --add-source '$arcadeServicesSource' -v $verbosity -g"
+    & "$dotnet" tool install $darcCliPackageName --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g
+  }else {
+    Write-Host "'$dotnet' tool install $darcCliPackageName --version $darcVersion --add-source '$arcadeServicesSource' -v $verbosity --tool-path '$toolpath'"
+    & "$dotnet" tool install $darcCliPackageName --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity --tool-path "$toolpath"
+  }
 }
 
-InstallDarcCli $darcVersion
+try {
+  InstallDarcCli $darcVersion $toolpath
+}
+catch {
+  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Category 'Darc' -Message $_
+  ExitWithExitCode 1
+}
\ No newline at end of file
diff --git a/eng/common/templates/post-build/common-variables.yml b/eng/common/templates/post-build/common-variables.yml
index 216d043e4e3..1883d2b1700 100644
--- a/eng/common/templates/post-build/common-variables.yml
+++ b/eng/common/templates/post-build/common-variables.yml
@@ -29,14 +29,6 @@ variables:
   - name: NetCore_3_Tools_Channel_Id
     value: 344
 
-  # .NET Core 3.0 Internal Servicing
-  - name: InternalServicing_30_Channel_Id
-    value: 184
-
-  # .NET Core 3.0 Release
-  - name: PublicRelease_30_Channel_Id
-    value: 19
-
   # .NET Core 3.1 Release
   - name: PublicRelease_31_Channel_Id
     value: 129
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index 3c69186f03a..e1cff6e7029 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -103,18 +103,6 @@ stages:
         continueOnError: ${{ parameters.SDLValidationParameters.continueOnError }}
         artifactNames: ${{ parameters.SDLValidationParameters.artifactNames }}
 
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_Dev5_Publish'
-    channelName: '.NET Core 5 Dev'
-    channelId: 131
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-symbols/nuget/v3/index.json'
-
 - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
   parameters:
     artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
@@ -175,18 +163,6 @@ stages:
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json'
     symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng-symbols/nuget/v3/index.json'
 
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_Release30_Publish'
-    channelName: '.NET Core 3.0 Release'
-    channelId: 19
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3-symbols/nuget/v3/index.json'
-
 - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
   parameters:
     artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
@@ -211,18 +187,6 @@ stages:
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-blazor/nuget/v3/index.json'
     symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-blazor-symbols/nuget/v3/index.json'
 
-- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NetCore_30_Internal_Servicing_Publishing'
-    channelName: '.NET Core 3.0 Internal Servicing'
-    channelId: 184
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal-symbols/nuget/v3/index.json'
-
 - template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
   parameters:
     artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
@@ -271,30 +235,6 @@ stages:
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
     symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
 
-- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_301xx_Publishing'
-    channelName: '.NET Core SDK 3.0.1xx'
-    channelId: 556
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3-symbols/nuget/v3/index.json'
-
-- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
-  parameters:
-    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-    stageName: 'NETCore_SDK_301xx_Internal_Publishing'
-    channelName: '.NET Core SDK 3.0.1xx Internal'
-    channelId: 555
-    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal-transport/nuget/v3/index.json'
-    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3-internal-symbols/nuget/v3/index.json'
-
 - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
   parameters:
     artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
@@ -365,4 +305,64 @@ stages:
     channelId: 760
     transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
-    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
\ No newline at end of file
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
+    
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'NETCore_SDK_314xx_Publishing'
+    channelName: '.NET Core SDK 3.1.4xx'
+    channelId: 921
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
+
+- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'NETCore_SDK_314xx_Internal_Publishing'
+    channelName: '.NET Core SDK 3.1.4xx Internal'
+    channelId: 922
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
+
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'VS16_6_Publishing'
+    channelName: 'VS 16.6'
+    channelId: 1010
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'VS16_7_Publishing'
+    channelName: 'VS 16.7'
+    channelId: 1011
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'VS_Master_Publishing'
+    channelName: 'VS Master'
+    channelId: 1012
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
\ No newline at end of file
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 92a053bd16b..bc228dfdf9f 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -119,7 +119,9 @@ function InitializeDotNetCli([bool]$install) {
 
   # Find the first path on %PATH% that contains the dotnet.exe
   if ($useInstalledDotNetCli -and (-not $globalJsonHasRuntimes) -and ($env:DOTNET_INSTALL_DIR -eq $null)) {
-    $dotnetCmd = Get-Command "dotnet.exe" -ErrorAction SilentlyContinue
+    $dotnetExecutable = GetExecutableFileName 'dotnet'
+    $dotnetCmd = Get-Command $dotnetExecutable -ErrorAction SilentlyContinue
+
     if ($dotnetCmd -ne $null) {
       $env:DOTNET_INSTALL_DIR = Split-Path $dotnetCmd.Path -Parent
     }
@@ -243,6 +245,10 @@ function InstallDotNet([string] $dotnetRoot,
 # Throws on failure.
 #
 function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements = $null) {
+  if (-not (IsWindowsPlatform)) {
+    throw "Cannot initialize Visual Studio on non-Windows"
+  }
+
   if (Test-Path variable:global:_MSBuildExe) {
     return $global:_MSBuildExe
   }
@@ -344,7 +350,11 @@ function InitializeXCopyMSBuild([string]$packageVersion, [bool]$install) {
 # or $null if no instance meeting the requirements is found on the machine.
 #
 function LocateVisualStudio([object]$vsRequirements = $null){
-  if (Get-Member -InputObject $GlobalJson.tools -Name "vswhere") {
+  if (-not (IsWindowsPlatform)) {
+    throw "Cannot run vswhere on non-Windows platforms."
+  }
+
+  if (Get-Member -InputObject $GlobalJson.tools -Name 'vswhere') {
     $vswhereVersion = $GlobalJson.tools.vswhere
   } else {
     $vswhereVersion = "2.5.2"
@@ -404,7 +414,8 @@ function InitializeBuildTool() {
       Write-PipelineTelemetryError -Category "InitializeToolset" -Message "/global.json must specify 'tools.dotnet'."
       ExitWithExitCode 1
     }
-    $buildTool = @{ Path = Join-Path $dotnetRoot "dotnet.exe"; Command = "msbuild"; Tool = "dotnet"; Framework = "netcoreapp2.1" }
+    $dotnetPath = Join-Path $dotnetRoot (GetExecutableFileName 'dotnet')
+    $buildTool = @{ Path = $dotnetPath; Command = 'msbuild'; Tool = 'dotnet'; Framework = 'netcoreapp2.1' }
   } elseif ($msbuildEngine -eq "vs") {
     try {
       $msbuildPath = InitializeVisualStudioMSBuild -install:$restore
@@ -610,6 +621,19 @@ function GetMSBuildBinaryLogCommandLineArgument($arguments) {
   return $null
 }
 
+function GetExecutableFileName($baseName) {
+  if (IsWindowsPlatform) {
+    return "$baseName.exe"
+  }
+  else {
+    return $baseName
+  }
+}
+
+function IsWindowsPlatform() {
+  return [environment]::OSVersion.Platform -eq [PlatformID]::Win32NT
+}
+
 . $PSScriptRoot\pipeline-logging-functions.ps1
 
 $RepoRoot = Resolve-Path (Join-Path $PSScriptRoot "..\..")
diff --git a/global.json b/global.json
index aae65e77550..fc53c0de68f 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20215.5"
+    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20302.3"
   }
 }
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 691916c7c90..c826858733e 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -205,6 +205,7 @@ public partial interface IBuildEngine6 : Microsoft.Build.Framework.IBuildEngine,
     }
     public partial interface IBuildEngine7 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6
     {
+        bool AllowFailureWithoutError { get; set; }
         void ReleaseCores(int coresToRelease);
         int RequestCores(int requestedCores);
     }
@@ -497,7 +498,10 @@ protected SdkResolverContext() { }
     public abstract partial class SdkResult
     {
         protected SdkResult() { }
+        public virtual System.Collections.Generic.IList<string> AdditionalPaths { get { throw null; } set { } }
+        public virtual System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> ItemsToAdd { get { throw null; } protected set { } }
         public virtual string Path { get { throw null; } protected set { } }
+        public virtual System.Collections.Generic.IDictionary<string, string> PropertiesToAdd { get { throw null; } protected set { } }
         public virtual Microsoft.Build.Framework.SdkReference SdkReference { get { throw null; } protected set { } }
         public virtual bool Success { get { throw null; } protected set { } }
         public virtual string Version { get { throw null; } protected set { } }
@@ -506,8 +510,18 @@ public abstract partial class SdkResultFactory
     {
         protected SdkResultFactory() { }
         public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings=null);
+        public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd=null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd=null, System.Collections.Generic.IEnumerable<string> warnings=null);
         public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings=null);
     }
+    public partial class SdkResultItem
+    {
+        public SdkResultItem() { }
+        public SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) { }
+        public string ItemSpec { get { throw null; } set { } }
+        public System.Collections.Generic.Dictionary<string, string> Metadata { get { throw null; } }
+        public override bool Equals(object obj) { throw null; }
+        public override int GetHashCode() { throw null; }
+    }
     public enum TargetBuiltReason
     {
         AfterTargets = 3,
@@ -572,6 +586,8 @@ public TaskFinishedEventArgs(string message, string helpKeyword, string projectF
     public partial class TaskPropertyInfo
     {
         public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
+        public bool Log { get { throw null; } set { } }
+        public bool LogItemMetadata { get { throw null; } set { } }
         public string Name { get { throw null; } }
         public bool Output { get { throw null; } }
         public System.Type PropertyType { get { throw null; } }
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index f06e6f1b929..3d157409013 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -205,6 +205,7 @@ public partial interface IBuildEngine6 : Microsoft.Build.Framework.IBuildEngine,
     }
     public partial interface IBuildEngine7 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6
     {
+        bool AllowFailureWithoutError { get; set; }
         void ReleaseCores(int coresToRelease);
         int RequestCores(int requestedCores);
     }
@@ -496,7 +497,10 @@ protected SdkResolverContext() { }
     public abstract partial class SdkResult
     {
         protected SdkResult() { }
+        public virtual System.Collections.Generic.IList<string> AdditionalPaths { get { throw null; } set { } }
+        public virtual System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> ItemsToAdd { get { throw null; } protected set { } }
         public virtual string Path { get { throw null; } protected set { } }
+        public virtual System.Collections.Generic.IDictionary<string, string> PropertiesToAdd { get { throw null; } protected set { } }
         public virtual Microsoft.Build.Framework.SdkReference SdkReference { get { throw null; } protected set { } }
         public virtual bool Success { get { throw null; } protected set { } }
         public virtual string Version { get { throw null; } protected set { } }
@@ -505,8 +509,18 @@ public abstract partial class SdkResultFactory
     {
         protected SdkResultFactory() { }
         public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings=null);
+        public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd=null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd=null, System.Collections.Generic.IEnumerable<string> warnings=null);
         public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings=null);
     }
+    public partial class SdkResultItem
+    {
+        public SdkResultItem() { }
+        public SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) { }
+        public string ItemSpec { get { throw null; } set { } }
+        public System.Collections.Generic.Dictionary<string, string> Metadata { get { throw null; } }
+        public override bool Equals(object obj) { throw null; }
+        public override int GetHashCode() { throw null; }
+    }
     public enum TargetBuiltReason
     {
         AfterTargets = 3,
@@ -571,6 +585,8 @@ public TaskFinishedEventArgs(string message, string helpKeyword, string projectF
     public partial class TaskPropertyInfo
     {
         public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
+        public bool Log { get { throw null; } set { } }
+        public bool LogItemMetadata { get { throw null; } set { } }
         public string Name { get { throw null; } }
         public bool Output { get { throw null; } }
         public System.Type PropertyType { get { throw null; } }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 5e4da25caa7..7915650703a 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -967,6 +967,7 @@ public partial class BuildParameters
     {
         public BuildParameters() { }
         public BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
+        public bool AllowFailureWithoutError { get { throw null; } set { } }
         public System.Collections.Generic.IDictionary<string, string> BuildProcessEnvironment { get { throw null; } }
         public System.Threading.ThreadPriority BuildThreadPriority { get { throw null; } set { } }
         public System.Globalization.CultureInfo Culture { get { throw null; } set { } }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 9744334fb4e..fb016e00783 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -963,6 +963,7 @@ public partial class BuildParameters
     {
         public BuildParameters() { }
         public BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
+        public bool AllowFailureWithoutError { get { throw null; } set { } }
         public System.Collections.Generic.IDictionary<string, string> BuildProcessEnvironment { get { throw null; } }
         public System.Globalization.CultureInfo Culture { get { throw null; } set { } }
         public string DefaultToolsVersion { get { throw null; } set { } }
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index a1c01d9bd6c..a4e0c79e34e 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.Construction
@@ -16,6 +17,72 @@ namespace Microsoft.Build.UnitTests.Construction
     /// </summary>
     public class SolutionFile_Tests
     {
+        [Theory]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects2"": [
+                      ""src\\Build\\Microsoft.Build.csproj"",
+                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
+                      ""src\\MSBuild\\MSBuild.csproj"",
+                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                [{
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      ""src\\Build\\Microsoft.Build.csproj"",
+                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
+                      ""src\\MSBuild\\MSBuild.csproj"",
+                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
+                    ]
+                    }
+                }]
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
+                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
+                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
+                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath2\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
+                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
+                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
+                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterMissingSolutionError")]
+        public void InvalidSolutionFilters(string slnfValue, string exceptionReason)
+        {
+            Assert.False(File.Exists("C:\\notAPath2\\MSBuild.Dev.sln"));
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "Dev.sln");
+                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf", slnfValue.Replace(@"C:\\notAPath\\MSBuild.Dev.sln", sln.Path.Replace("\\", "\\\\")));
+                InvalidProjectFileException e = Should.Throw<InvalidProjectFileException>(() => SolutionFile.Parse(slnf.Path));
+                e.HelpKeyword.ShouldBe(exceptionReason);
+            }
+        }
+
         /// <summary>
         /// Test that a project with the C++ project guid and an extension of vcproj is seen as invalid.
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 0dc21b3faf8..1f887d229ee 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -13,8 +13,18 @@
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
   </PropertyGroup>
 
+  <PropertyGroup>
+    <NuGetCommandLinePackageVersion>4.1.0</NuGetCommandLinePackageVersion>
+</PropertyGroup>
+
   <ItemGroup>
     <PackageReference Include="Shouldly" />
+    <PackageDownload Include="NuGet.CommandLine" Version="[$(NuGetCommandLinePackageVersion)]" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <!-- GeneratePathProperty currently isn't enabled for PackageDownload. -->
+    <Content Condition="'$(MSBuildRuntimeType)' != 'Core' and '$(Configuration)' == 'Release'" Include="$(NuGetPackageRoot)\nuget.commandline\$(NuGetCommandLinePackageVersion)\tools\NuGet.exe" CopyToOutputDirectory="PreserveNewest" Link="nuget\NuGet.exe" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
@@ -87,6 +97,9 @@
     <Compile Include="..\Shared\StringBuilderCache.cs">
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\IInternable.cs" />
+    <Compile Include="..\Shared\WeakStringCache.cs" />
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
     <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
@@ -94,6 +107,7 @@
     <Compile Include="..\Shared\UnitTests\TestData\GlobbingTestData.cs">
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
+    <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
new file mode 100644
index 00000000000..64be9580f68
--- /dev/null
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -0,0 +1,57 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using System.IO;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Engine.OM.UnitTests
+{
+    public sealed class NugetRestoreTests
+    {
+        private ITestOutputHelper _output;
+        public NugetRestoreTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        // This NuGet version cannot locate other assemblies when parsing solutions at restore time. This includes localized strings required in debug mode.
+        // NuGet version 4.1.0 was somewhat arbitrarily chosen. 3.5 breaks with an unrelated error, and 4.8.2 does not fail when a new dependency is introduced. This is a safe middle point.
+#if !DEBUG
+        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [Fact]
+        public void TestOldNuget()
+        {
+            string msbuildExePath = Path.GetDirectoryName(RunnerUtilities.PathToCurrentlyRunningMsBuildExe);
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+            // The content of the solution isn't known to matter, but having a custom solution makes it easier to add requirements should they become evident.
+            TransientTestFile sln = testEnvironment.CreateFile(folder, "test.sln",
+                @"
+Microsoft Visual Studio Solution File, Format Version 12.00
+\# Visual Studio 15
+VisualStudioVersion = 15.0.26124.0
+MinimumVisualStudioVersion = 15.0.26124.0
+Global
+GlobalSection(SolutionConfigurationPlatforms) = preSolution
+	Debug|Any CPU = Debug|Any CPU
+	Debug|x64 = Debug|x64
+	Debug|x86 = Debug|x86
+	Release|Any CPU = Release|Any CPU
+	Release|x64 = Release|x64
+	Release|x86 = Release|x86
+EndGlobalSection
+GlobalSection(SolutionProperties) = preSolution
+	HideSolutionNode = FALSE
+EndGlobalSection
+EndGlobal
+");
+            RunnerUtilities.RunProcessAndGetOutput(Path.Combine(msbuildExePath, "nuget", "NuGet.exe"), "restore " + sln.Path + " -MSBuildPath \"" + msbuildExePath + "\"", out bool success, outputHelper: _output);
+            success.ShouldBeTrue();
+        }
+#endif
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index 0db697ff651..af9bf647c5d 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -10,8 +10,8 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
+using Shouldly;
 using Xunit;
-
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 namespace Microsoft.Build.UnitTests.BackEnd
diff --git a/src/Build.UnitTests/BackEnd/FailingTask.cs b/src/Build.UnitTests/BackEnd/FailingTask.cs
new file mode 100644
index 00000000000..c42f912d679
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/FailingTask.cs
@@ -0,0 +1,20 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class FailingTask : Task
+    {
+        public override bool Execute()
+        {
+            BuildEngine.GetType().GetProperty("AllowFailureWithoutError").SetValue(BuildEngine, EnableDefaultFailure);
+            return false;
+        }
+
+        [Required]
+        public bool EnableDefaultFailure { get; set; }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
index 861d10cd4b6..338cc793c8e 100644
--- a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
@@ -4,8 +4,10 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
+using Shouldly;
 using System;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -14,29 +16,36 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class LoggingContext_Tests
     {
+        private readonly ITestOutputHelper _output;
+
+        public LoggingContext_Tests(ITestOutputHelper outputHelper)
+        {
+            _output = outputHelper;
+        }
+
         /// <summary>
         /// A few simple tests for NodeLoggingContexts. 
         /// </summary>
         [Fact]
         public void CreateValidNodeLoggingContexts()
         {
-            NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(), 1, true);
-            Assert.True(context.IsInProcNode);
-            Assert.True(context.IsValid);
+            NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(_output.WriteLine), 1, true);
+            context.IsInProcNode.ShouldBeTrue();
+            context.IsValid.ShouldBeTrue();
 
             context.LogBuildFinished(true);
-            Assert.False(context.IsValid);
+            context.IsValid.ShouldBeFalse();
 
-            Assert.Equal(1, context.BuildEventContext.NodeId);
+            context.BuildEventContext.NodeId.ShouldBe(1);
 
-            NodeLoggingContext context2 = new NodeLoggingContext(new MockLoggingService(), 2, false);
-            Assert.False(context2.IsInProcNode);
-            Assert.True(context2.IsValid);
+            NodeLoggingContext context2 = new NodeLoggingContext(new MockLoggingService(_output.WriteLine), 2, false);
+            context2.IsInProcNode.ShouldBeFalse();
+            context2.IsValid.ShouldBeTrue();
 
             context2.LogBuildFinished(true);
-            Assert.False(context2.IsValid);
+            context2.IsValid.ShouldBeFalse();
 
-            Assert.Equal(2, context2.BuildEventContext.NodeId);
+            context2.BuildEventContext.NodeId.ShouldBe(2);
         }
 
         /// <summary>
@@ -49,9 +58,25 @@ public void InvalidNodeIdOnNodeLoggingContext()
         {
             Assert.Throws<InternalErrorException>(() =>
             {
-                NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(), -2, true);
+                _ = new NodeLoggingContext(new MockLoggingService(), -2, true);
             }
            );
         }
+
+        [Fact]
+        public void HasLoggedErrors()
+        {
+            NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(_output.WriteLine), 1, true);
+            context.HasLoggedErrors.ShouldBeFalse();
+
+            context.LogCommentFromText(Framework.MessageImportance.High, "Test message");
+            context.HasLoggedErrors.ShouldBeFalse();
+
+            context.LogWarningFromText(null, null, null, null, "Test warning");
+            context.HasLoggedErrors.ShouldBeFalse();
+
+            context.LogErrorFromText(null, null, null, null, "Test error");
+            context.HasLoggedErrors.ShouldBeTrue();
+        }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index 191f8573567..745a3e91b04 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -11,6 +11,9 @@
 using System.Xml;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using System.Reflection;
+using Shouldly;
+using System.Linq;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -559,6 +562,29 @@ public void OutOfOrderOnError()
            );
         }
 
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ErrorWhenTaskFailsWithoutLoggingErrorEscapeHatch(bool emitError)
+        {
+            MockLogger logger = ObjectModelHelpers.BuildProjectExpectFailure($@"
+<Project>
+    <UsingTask TaskName=""FailingTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
+    <Target Name=""MyTarget"">
+        <FailingTask EnableDefaultFailure=""{emitError}"" />
+    </Target>
+</Project>");
+            if (emitError)
+            {
+                logger.ErrorCount.ShouldBe(1);
+                logger.Errors.First().Code.ShouldBe("MSB4181");
+            }
+            else
+            {
+                logger.ErrorCount.ShouldBe(0);
+            }
+        }
+
         #region Postbuild
         /*
          * Method:  PostBuildBasic
diff --git a/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs b/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs
new file mode 100644
index 00000000000..8d9b0b8b436
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs
@@ -0,0 +1,26 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Utilities;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+namespace Microsoft.Build.UnitTests
+{
+    /// <summary>
+    /// This task was created for https://github.com/microsoft/msbuild/issues/2036
+    /// </summary>
+    public class ReturnFailureWithoutLoggingErrorTask : Task
+    {
+        /// <summary>
+        /// Intentionally return false without logging an error to test proper error catching.
+        /// </summary>
+        /// <returns></returns>
+        public override bool Execute()
+        {
+            return false;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index a06af07a61c..b6fa324c806 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -1,4 +1,7 @@
-using Microsoft.Build.BackEnd.Logging;
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
@@ -217,6 +220,223 @@ public void CachingWrapperShouldWarnWhenMultipleVersionsAreReferenced()
             resolver.ResolvedCalls.Count.ShouldBe(1);
         }
 
+        private void CreateMockSdkResultPropertiesAndItems(out Dictionary<string, string> propertiesToAdd, out Dictionary<string, SdkResultItem> itemsToAdd)
+        {
+            propertiesToAdd = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                {
+                    {"PropertyFromSdkResolver", "ValueFromSdkResolver" }
+                };
+
+            itemsToAdd = new Dictionary<string, SdkResultItem>(StringComparer.OrdinalIgnoreCase)
+                {
+                    { "ItemNameFromSdkResolver", new SdkResultItem( "ItemValueFromSdkResolver",
+                        new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                        {
+                            { "MetadataName", "MetadataValue" }
+                        })
+                    }
+                };
+        }
+
+        private void ValidateExpectedPropertiesAndItems(bool includePropertiesAndItems, SdkResultBase result)
+        {
+            if (includePropertiesAndItems)
+            {
+                result.PropertiesToAdd.Count.ShouldBe(1);
+                result.PropertiesToAdd["PropertyFromSdkResolver"].ShouldBe("ValueFromSdkResolver");
+
+                result.ItemsToAdd.Count().ShouldBe(1);
+                result.ItemsToAdd.Keys.Single().ShouldBe("ItemNameFromSdkResolver");
+                result.ItemsToAdd.Values.Single().ItemSpec.ShouldBe("ItemValueFromSdkResolver");
+                var metadata = result.ItemsToAdd.Values.Single().Metadata;
+                metadata.ShouldBeSameIgnoringOrder(new[] { new KeyValuePair<string, string>("MetadataName", "MetadataValue") });
+            }
+            else
+            {
+                result.PropertiesToAdd.ShouldBeNull();
+                result.ItemsToAdd.ShouldBeNull();
+            }
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
+        {
+            var sdk = new SdkReference("foo", null, null);
+
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            if (includePropertiesAndItems)
+            {
+                CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+            }
+
+            var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
+                new SdkResultImpl(
+                    sdk,
+                    Enumerable.Empty<string>(),
+                    version: null,
+                    propertiesToAdd,
+                    itemsToAdd,
+                    warnings: null
+                    ));
+
+            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+
+            result.Success.ShouldBeTrue();
+            result.Path.ShouldBeNull();
+            result.Version.ShouldBeNull();
+
+            result.AdditionalPaths.ShouldBeNull();
+
+            ValidateExpectedPropertiesAndItems(includePropertiesAndItems, result);
+
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Fact]
+        public void SdkResultCanReturnPropertiesAndItems()
+        {
+            string expectedPath = "Path/To/Return/From/Resolver";
+
+            var sdk = new SdkReference("foo", null, null);
+
+            Dictionary<string, string> propertiesToAdd;
+            Dictionary<string, SdkResultItem> itemsToAdd;
+           
+            CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+
+            var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
+                new SdkResultImpl(
+                    sdk,
+                    new[] { expectedPath },
+                    version: "1.0",
+                    propertiesToAdd,
+                    itemsToAdd,
+                    warnings: null
+                    ));
+
+            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+
+            result.Success.ShouldBeTrue();
+            result.Path.ShouldBe(expectedPath);
+            result.Version.ShouldBe("1.0");
+
+            result.AdditionalPaths.ShouldBeNull();
+
+            ValidateExpectedPropertiesAndItems(true, result);
+
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SdkResultCanReturnMultiplePaths(bool includePropertiesAndItems)
+        {
+            string expectedPath1 = "First/Path/To/Return/From/Resolver";
+            string expectedPath2 = "Second/Path/To/Return/From/Resolver";
+
+            var sdk = new SdkReference("foo", "1.0", null);
+
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            if (includePropertiesAndItems)
+            {
+                CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+            }
+
+            var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
+                new SdkResultImpl(
+                    sdk,
+                    new []
+                    {
+                        expectedPath1,
+                        expectedPath2
+                    },
+                    version: "1.0",
+                    propertiesToAdd,
+                    itemsToAdd,
+                    warnings: null
+                    ));
+
+            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+
+            result.Success.ShouldBeTrue();
+
+            var resultPaths = new List<string>();
+            resultPaths.Add(result.Path);
+            resultPaths.AddRange(result.AdditionalPaths);
+
+            resultPaths.ShouldBeSameIgnoringOrder(new[]
+            {
+                expectedPath1,
+                expectedPath2
+            });
+
+            ValidateExpectedPropertiesAndItems(includePropertiesAndItems, result);
+
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Fact]
+        public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersionWithMultipleReturnPaths()
+        {
+            var expectedPath1 = "First/Path/To/Return/From/Resolver";
+            var expectedPath2 = "Second/Path/To/Return/From/Resolver";
+
+            var sdk = new SdkReference("foo", "1.0", null);
+
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+            
+            CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+
+            var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
+                new SdkResultImpl(
+                    sdk,
+                    new[]
+                    {
+                        expectedPath1,
+                        expectedPath2
+                    },
+                    version: "1.1",
+                    propertiesToAdd,
+                    itemsToAdd,
+                    warnings: null
+                    ));
+
+            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false);
+
+            result.Success.ShouldBeTrue();
+
+            var resultPaths = new List<string>();
+            resultPaths.Add(result.Path);
+            resultPaths.AddRange(result.AdditionalPaths);
+
+            resultPaths.ShouldBeSameIgnoringOrder(new[]
+            {
+                expectedPath1,
+                expectedPath2
+            });
+
+            ValidateExpectedPropertiesAndItems(true, result);
+
+            _logger.WarningCount.ShouldBe(1);
+            _logger.Warnings.First().Code.ShouldStartWith("MSB4241");
+        }
+
         /// <summary>
         /// Verifies that an SDK resolver is only called once per build per SDK.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
new file mode 100644
index 00000000000..8fd40d75ddc
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -0,0 +1,281 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Unittest;
+using Microsoft.Build.UnitTests.Definition;
+using Shouldly;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Xml;
+using Xunit;
+using Xunit.Abstractions;
+using static Microsoft.Build.UnitTests.ObjectModelHelpers;
+
+namespace Microsoft.Build.UnitTests.BackEnd
+{
+    public class SdkResultOutOfProc_Tests : IDisposable
+    {
+        /// <summary>
+        /// The mock logger for testing.
+        /// </summary>
+        private readonly MockLogger _logger;
+
+        /// <summary>
+        /// The standard build manager for each test.
+        /// </summary>
+        private readonly BuildManager _buildManager;
+
+        /// <summary>
+        /// The build parameters.
+        /// </summary>
+        private readonly BuildParameters _parameters;
+
+        /// <summary>
+        /// The project collection used.
+        /// </summary>
+        private readonly ProjectCollection _projectCollection;
+
+        private readonly TestEnvironment _env;
+        private readonly ITestOutputHelper _output;
+
+        public SdkResultOutOfProc_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+            // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.
+            BuildManager.DefaultBuildManager.Dispose();
+
+            _logger = new MockLogger(output);
+            _parameters = new BuildParameters
+            {
+                ShutdownInProcNodeOnBuildFinish = true,
+                Loggers = new ILogger[] { _logger },
+                EnableNodeReuse = false
+            };
+            _buildManager = new BuildManager();
+            _projectCollection = new ProjectCollection();
+
+            _env = TestEnvironment.Create(output);
+            _env.SetEnvironmentVariable("MSBUILDINPROCENVCHECK", "1");
+            _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+
+            // Need to set this env variable to enable Process.GetCurrentProcess().Id in the project file.
+            _env.SetEnvironmentVariable("MSBUILDENABLEALLPROPERTYFUNCTIONS", "1");
+
+            //  Set this if you need to debug the out of process build
+            //_env.SetEnvironmentVariable("MSBUILDDEBUGONSTART", "1");
+        }
+
+        public void Dispose()
+        {
+            _buildManager.Dispose();
+            _projectCollection.Dispose();
+            _env.Dispose();
+            EvaluationContext.TestOnlyHookOnCreate = null;
+        }
+
+        private const string GetCurrentProcessIdTarget = @"<Target Name='GetCurrentProcessId' Returns='@(CurrentProcessId)'>
+    <ItemGroup>
+       <CurrentProcessId Include='$([System.Diagnostics.Process]::GetCurrentProcess().Id)'/>
+    </ItemGroup>
+    <Message Text='[success]'/>
+ </Target>";
+
+        private const string GetResolverResultsTarget = @"<Target Name='GetResolverResults' Returns='@(ResolverResult)'>
+    <ItemGroup>
+       <ResolverResult Include='$(PropertyNameFromResolver)' Type='PropertyNameFromResolver' />
+       <ResolverResult Include='@(ItemFromResolver)' Type='ItemFromResolver' />
+       <ResolverResult Include='@(SdksImported)' Type='SdksImported' />
+    </ItemGroup>
+ </Target>";
+
+        [Fact]
+        public void RunOutOfProcBuild()
+        {
+            string contents = $@"
+<Project>
+<Import Project='Sdk.props' Sdk='TestSdk' />
+{GetCurrentProcessIdTarget}
+{GetResolverResultsTarget}
+</Project>
+";
+
+            string projectFolder = _env.CreateFolder().Path;
+
+            string projectPath = Path.Combine(projectFolder, "TestProject.proj");
+            File.WriteAllText(projectPath, CleanupFileContents(contents));
+
+            ProjectInstance projectInstance = CreateProjectInstance(projectPath, MSBuildDefaultToolsVersion, _projectCollection);
+
+            var data = new BuildRequestData(projectInstance, new[] { "GetCurrentProcessId", "GetResolverResults" }, _projectCollection.HostServices);
+            var customparameters = new BuildParameters { EnableNodeReuse = false, Loggers = new ILogger[] { _logger } };
+
+            BuildResult result = _buildManager.Build(customparameters, data);
+
+            result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            ValidateRanInSeparateProcess(result);
+            ValidateResolverResults(result);
+        }
+
+        //  Test scenario where using an SdkResolver in a project that hasn't been evaluated
+        //  in the main node (which is where the SdkResolver runs).  This validates that
+        //  the SdkResult is correctly transferred between nodes.
+        [Fact]
+        public void RunOutOfProcBuildWithTwoProjects()
+        {
+            string entryProjectContents = $@"
+<Project>
+ {GetCurrentProcessIdTarget}
+<Target Name='GetResolverResults' Returns='@(ResolverResults)'>
+    <MSBuild Projects='ProjectWithSdkImport.proj'
+             Targets='GetResolverResults'>
+        <Output TaskParameter='TargetOutputs' ItemName='ResolverResults' />
+    </MSBuild>
+ </Target>
+</Project>
+";
+            string projectFolder = _env.CreateFolder().Path;
+
+            string entryProjectPath = Path.Combine(projectFolder, "EntryProject.proj");
+            File.WriteAllText(entryProjectPath, CleanupFileContents(entryProjectContents));
+
+            string projectWithSdkImportContents = $@"
+<Project>
+<Import Project='Sdk.props' Sdk='TestSdk' />
+{GetResolverResultsTarget}
+</Project>
+";
+
+            string projectWithSdkImportPath = Path.Combine(projectFolder, "ProjectWithSdkImport.proj");
+            File.WriteAllText(projectWithSdkImportPath, CleanupFileContents(projectWithSdkImportContents));
+
+            ProjectInstance projectInstance = CreateProjectInstance(entryProjectPath, MSBuildDefaultToolsVersion, _projectCollection);
+
+            var data = new BuildRequestData(projectInstance, new[] { "GetCurrentProcessId", "GetResolverResults" }, _projectCollection.HostServices);
+            var customparameters = new BuildParameters { EnableNodeReuse = false, Loggers = new ILogger[] { _logger } };
+
+            BuildResult result = _buildManager.Build(customparameters, data);
+
+
+            result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            ValidateRanInSeparateProcess(result);
+            ValidateResolverResults(result);
+        }
+
+
+        private void ValidateRanInSeparateProcess(BuildResult result)
+        {
+            TargetResult targetresult = result.ResultsByTarget["GetCurrentProcessId"];
+            ITaskItem[] item = targetresult.Items;
+
+            item.ShouldHaveSingleItem();
+
+            int.TryParse(item[0].ItemSpec, out int processId)
+                .ShouldBeTrue($"Process ID passed from the 'test' target is not a valid integer (actual is '{item[0].ItemSpec}')");
+            processId.ShouldNotBe(Process.GetCurrentProcess().Id);
+        }
+
+        private void ValidateResolverResults(BuildResult result)
+        {
+            TargetResult targetresult = result.ResultsByTarget["GetResolverResults"];
+
+            IEnumerable<string> GetResolverResults(string type)
+            {
+                return targetresult.Items.Where(i => i.GetMetadata("Type").Equals(type, StringComparison.OrdinalIgnoreCase))
+                    .Select(i => i.ItemSpec)
+                    .ToList();
+            }
+
+            GetResolverResults("PropertyNameFromResolver").ShouldBeSameIgnoringOrder(new[] { "PropertyValueFromResolver" });
+            GetResolverResults("ItemFromResolver").ShouldBeSameIgnoringOrder(new[] { "ItemValueFromResolver" });
+            GetResolverResults("SdksImported").ShouldBeSameIgnoringOrder(new[] { "Sdk1", "Sdk2" });
+        }
+
+        private ProjectInstance CreateProjectInstance(string projectPath, string toolsVersion, ProjectCollection projectCollection)
+        {
+            var sdkResolver = SetupSdkResolver(Path.GetDirectoryName(projectPath));
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(sdkResolver);
+
+            projectOptions.ProjectCollection = projectCollection;
+            projectOptions.ToolsVersion = toolsVersion;
+
+            ProjectRootElement projectRootElement = ProjectRootElement.Open(projectPath, _projectCollection);
+
+            Project project = Project.FromProjectRootElement(projectRootElement, projectOptions);
+
+            return project.CreateProjectInstance(ProjectInstanceSettings.None, projectOptions.EvaluationContext);
+        }
+
+        private SdkResolver SetupSdkResolver(string projectFolder)
+        {
+            Directory.CreateDirectory(Path.Combine(projectFolder, "Sdk1"));
+            Directory.CreateDirectory(Path.Combine(projectFolder, "Sdk2"));
+
+            string sdk1propsContents = @"
+<Project>
+    <ItemGroup>
+        <SdksImported Include='Sdk1' />
+    </ItemGroup>
+</Project>";
+
+            string sdk2propsContents = @"
+<Project>
+    <ItemGroup>
+        <SdksImported Include='Sdk2' />
+    </ItemGroup>
+</Project>";
+
+            File.WriteAllText(Path.Combine(projectFolder, "Sdk1", "Sdk.props"), CleanupFileContents(sdk1propsContents));
+            File.WriteAllText(Path.Combine(projectFolder, "Sdk2", "Sdk.props"), CleanupFileContents(sdk2propsContents));
+
+            var sdkResolver = new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestSdk", null, null),
+                        new[]
+                        {
+                            Path.Combine(projectFolder, "Sdk1"),
+                            Path.Combine(projectFolder, "Sdk2")
+                        },
+                        version: null,
+                        propertiesToAdd: new Dictionary<string, string>()
+                            { {"PropertyNameFromResolver","PropertyValueFromResolver" } },
+                        itemsToAdd: new Dictionary<string, SdkResultItem>()
+                            {
+                                { "ItemFromResolver", new SdkResultItem("ItemValueFromResolver", null) }
+                            },
+                        warnings: null
+                    ));
+
+            EvaluationContext.TestOnlyHookOnCreate = context =>
+            {
+                var sdkService = (SdkResolverService)context.SdkResolverService;
+
+                sdkService.InitializeForTests(null, new List<SdkResolver> { sdkResolver });
+            };
+
+            ((IBuildComponentHost)_buildManager).RegisterFactory(BuildComponentType.SdkResolverService, type =>
+            {
+                var resolverService = new MainNodeSdkResolverService();
+                resolverService.InitializeForTests(null, new List<SdkResolver> { sdkResolver });
+                return resolverService;
+            });
+
+            return sdkResolver;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Collections/OMcollections_tests.cs b/src/Build.UnitTests/Collections/OMcollections_tests.cs
index 0421b05453d..a2c9c2ac165 100644
--- a/src/Build.UnitTests/Collections/OMcollections_tests.cs
+++ b/src/Build.UnitTests/Collections/OMcollections_tests.cs
@@ -16,6 +16,7 @@
 using Shouldly;
 using ObjectModel = System.Collections.ObjectModel;
 using Xunit;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.OM.Collections
 {
diff --git a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
index 43d62d5c4dd..dd48d7391e5 100644
--- a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
@@ -18,6 +18,7 @@
 using System.Reflection;
 using Xunit;
 using System.Text;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.Construction
 {
diff --git a/src/Build.UnitTests/Construction/ProjectImportElement_Tests.cs b/src/Build.UnitTests/Construction/ProjectImportElement_Tests.cs
new file mode 100644
index 00000000000..4450f83c458
--- /dev/null
+++ b/src/Build.UnitTests/Construction/ProjectImportElement_Tests.cs
@@ -0,0 +1,207 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
+using Shouldly;
+using System;
+using System.Linq;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests.Construction
+{
+    public class ProjectImportElement_Tests
+    {
+        [Fact]
+        public void SdkReferenceIsCorrect_CreatedFromOnDiskProject_SdkAndVersionAttributeSet()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFile projectFile = testEnvironment.CreateFile(
+                    "test.proj",
+                    @"
+<Project>
+  <Import Project=""Sdk.props"" Sdk=""My.Sdk"" Version=""1.2.0"" />
+</Project>");
+                ProjectRootElement rootElement = ProjectRootElement.Open(projectFile.Path);
+
+                ProjectImportElement importElement = rootElement.Imports.First();
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Sdk = "My.Sdk");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Version = "1.2.0");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.MinimumVersion = "1.0.0", "Set Import Minimum Version 1.0.0");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.MinimumVersion = "1.0.0");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Sdk = "Some.Other.Sdk", "Set Import Sdk Some.Other.Sdk");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+            }
+        }
+
+        [Fact]
+        public void SdkReferenceIsCorrect_CreatedFromOnDiskProject_SdkAttributeSet()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFile projectFile = testEnvironment.CreateFile(
+                    "test.proj",
+                    @"
+<Project>
+  <Import Project=""Sdk.props"" Sdk=""My.Sdk"" />
+</Project>");
+                ProjectRootElement rootElement = ProjectRootElement.Open(projectFile.Path);
+
+                ProjectImportElement importElement = rootElement.Imports.First();
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBeNull();
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Sdk = "My.Sdk");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Version = "1.2.0", "Set Import Version 1.2.0");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Version = "1.2.0");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.MinimumVersion = "1.0.0", "Set Import Minimum Version 1.0.0");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.MinimumVersion = "1.0.0");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+            }
+        }
+
+        /// <summary>
+        /// Verifies that the <see cref="ProjectImportElement.SdkReference" /> object is correctly set when creating <see cref="ProjectImportElement" /> objects.
+        /// </summary>
+        [Fact]
+        public void SdkReferenceIsCorrect_CreatedInMemory()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                ProjectRootElement rootElement = ProjectRootElement.Create(NewProjectFileOptions.None);
+
+                ProjectImportElement importElement = rootElement.AddImport("Sdk.props");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Sdk = "My.Sdk", "Set Import Sdk My.Sdk");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Sdk = "My.Sdk");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBeNull();
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Version = "1.2.0", "Set Import Version 1.2.0");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Version = "1.2.0");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.MinimumVersion = "1.0.0", "Set Import Minimum Version 1.0.0");
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.MinimumVersion = "1.0.0");
+
+                importElement.SdkReference.Name.ShouldBe("My.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+
+                rootElement.Save(env.GetTempFile(".csproj").Path);
+
+                SetPropertyAndExpectProjectXmlChangedEventToNotFire(rootElement, () => importElement.Sdk = "My.Sdk");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Sdk = "Some.Other.Sdk", "Set Import Sdk Some.Other.Sdk");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBe("1.2.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+
+                rootElement.Save();
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Version = "4.0.0", "Set Import Version 4.0.0");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBe("4.0.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("1.0.0");
+
+                rootElement.Save();
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.MinimumVersion = "2.0.0", "Set Import Minimum Version 2.0.0");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBe("4.0.0");
+                importElement.SdkReference.MinimumVersion.ShouldBe("2.0.0");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.Version = null, "Set Import Version ");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBeNull();
+                importElement.SdkReference.MinimumVersion.ShouldBe("2.0.0");
+
+                SetPropertyAndExpectProjectXmlChangedEventToFire(rootElement, () => importElement.MinimumVersion = null, "Set Import Minimum Version ");
+
+                importElement.SdkReference.Name.ShouldBe("Some.Other.Sdk");
+                importElement.SdkReference.Version.ShouldBeNull();
+                importElement.SdkReference.MinimumVersion.ShouldBeNull();
+            }
+        }
+
+        private void SetPropertyAndExpectProjectXmlChangedEventToFire(ProjectRootElement rootElement, Action action, string expectedReason)
+        {
+            ProjectXmlChangedEventArgs projectXmlChangedEventArgs = null;
+
+            void OnProjectXmlChanged(object sender, ProjectXmlChangedEventArgs args)
+            {
+                projectXmlChangedEventArgs = args;
+            }
+
+            rootElement.OnProjectXmlChanged += OnProjectXmlChanged;
+            try
+            {
+                action();
+            }
+            finally
+            {
+                rootElement.OnProjectXmlChanged -= OnProjectXmlChanged;
+            }
+
+            projectXmlChangedEventArgs.ShouldNotBeNull();
+            projectXmlChangedEventArgs.Reason.ShouldBe(expectedReason);
+        }
+
+        private void SetPropertyAndExpectProjectXmlChangedEventToNotFire(ProjectRootElement rootElement, Action action)
+        {
+            ProjectXmlChangedEventArgs projectXmlChangedEventArgs = null;
+
+            void OnProjectXmlChanged(object sender, ProjectXmlChangedEventArgs args)
+            {
+                projectXmlChangedEventArgs = args;
+            }
+
+            rootElement.OnProjectXmlChanged += OnProjectXmlChanged;
+            try
+            {
+                action();
+            }
+            finally
+            {
+                rootElement.OnProjectXmlChanged -= OnProjectXmlChanged;
+            }
+
+            projectXmlChangedEventArgs.ShouldBeNull();
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index c9b10410185..e9dc6951439 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -17,6 +17,64 @@ namespace Microsoft.Build.UnitTests.Construction
 {
     public class SolutionFile_Tests
     {
+        /// <summary>
+        /// Test that a solution filter file is parsed correctly, and it can accurately respond as to whether a project should be filtered out.
+        /// </summary>
+        [Fact]
+        public void ParseSolutionFilter()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder src = testEnvironment.CreateFolder(Path.Combine(folder.Path, "src"), createFolder: true);
+                TransientTestFile microsoftBuild = testEnvironment.CreateFile(src, "Microsoft.Build.csproj");
+                TransientTestFile msbuild = testEnvironment.CreateFile(src, "MSBuild.csproj");
+                TransientTestFile commandLineUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.CommandLine.UnitTests.csproj");
+                TransientTestFile tasksUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.Tasks.UnitTests.csproj");
+                // The important part of this .sln is that it has references to each of the four projects we just created.
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "Microsoft.Build.Dev.sln",
+                    @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio 15
+                    VisualStudioVersion = 15.0.27004.2009
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build"", """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)) + @""", ""{69BE05E2-CBDA-4D27-9733-44E12B0F5627}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""MSBuild"", """ + Path.Combine("src", Path.GetFileName(msbuild.Path)) + @""", ""{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.CommandLine.UnitTests"", """ + Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)) + @""", ""{0ADDBC02-0076-4159-B351-2BF33FAA46B2}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.Tasks.UnitTests"", """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)) + @""", ""{CF999BDE-02B3-431B-95E6-E88D621D9CBF}""
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(ExtensibilityGlobals) = postSolution
+                    EndGlobalSection
+                    EndGlobal
+                    ");
+                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf",
+                    @"
+                    {
+                      ""solution"": {
+                        ""path"": """ + sln.Path.Replace("\\", "\\\\") + @""",
+                        ""projects"": [
+                          """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)).Replace("\\", "\\\\") + @""",
+                          """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)).Replace("\\", "\\\\") + @"""
+                        ]
+                        }
+                    }");
+                SolutionFile sp = SolutionFile.Parse(slnf.Path);
+                Assert.True(sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(microsoftBuild.Path))) && sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(tasksUnitTests.Path))));
+                Assert.False(sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path))) || sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(msbuild.Path))) || sp.ProjectShouldBuild(Path.Combine("src", "notAProject.csproj")));
+            }
+        }
+
         /// <summary>
         /// Test just the most basic, plain vanilla first project line.
         /// </summary>
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 655a4ad71c3..4cc129d7abd 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -60,6 +60,121 @@ public void Dispose()
             ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
         }
 
+        /// <summary>
+        /// Test that if a before.{sln}>.targets or after.{sln}.targets file has one of the default targets (Build, Clean, etc.) that it includes only the user-defined target.
+        /// </summary>
+        [Theory]
+        [InlineData("before.MySln.sln.targets")]
+        [InlineData("after.MySln.sln.targets")]
+        [InlineData("name.that.does.Not.Affect.The.Build.targets")]
+        public void SolutionProjectIgnoresDuplicateDefaultTargets(string name)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "MySln.sln", @"Microsoft Visual Studio Solution File, Format Version 16.00");
+                TransientTestFile targetsFile = testEnvironment.CreateFile(folder, name,
+                    @"<Project>
+                        <Target Name=""Build"" AfterTargets=""NonsenseTarget"">
+                        </Target>
+                      </Project>");
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(SolutionFile.Parse(sln.Path), null, null, _buildEventContext, CreateMockLoggingService());
+                instances.ShouldHaveSingleItem();
+                instances[0].Targets["Build"].AfterTargets.ShouldBe(string.Empty);
+                MockLogger logger = new MockLogger(output);
+                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
+            }
+        }
+
+        /// <summary>
+        /// Test that a solution filter file excludes projects not covered by its list of projects or their dependencies.
+        /// </summary>
+        [Fact]
+        public void SolutionFilterFiltersProjects()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);              
+                TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "ClassLibrary"), createFolder: true);
+                TransientTestFolder classLibSubFolder = testEnvironment.CreateFolder(Path.Combine(classLibFolder.Path, "ClassLibrary"), createFolder: true);
+                TransientTestFile classLibrary = testEnvironment.CreateFile(classLibSubFolder, "ClassLibrary.csproj",
+                    @"<Project>
+                  <Target Name=""ClassLibraryTarget"">
+                      <Message Text=""ClassLibraryBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "SimpleProject"), createFolder: true);
+                TransientTestFolder simpleProjectSubFolder = testEnvironment.CreateFolder(Path.Combine(simpleProjectFolder.Path, "SimpleProject"), createFolder: true);
+                TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectSubFolder, "SimpleProject.csproj",
+                    @"<Project DefaultTargets=""SimpleProjectTarget"">
+                  <Target Name=""SimpleProjectTarget"">
+                      <Message Text=""SimpleProjectBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+                TransientTestFile solutionFile = testEnvironment.CreateFile(simpleProjectFolder, "SimpleProject.sln",
+                    @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.0.29326.124
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", """ + Path.Combine("SimpleProject", "SimpleProject.csproj") + @""", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", """ + Path.Combine("..", "ClassLibrary", "ClassLibrary", "ClassLibrary.csproj") + @""", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|Any CPU = Debug|Any CPU
+                            Release|Any CPU = Release|Any CPU
+                            EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.Build.0 = Release|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.Build.0 = Release|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.Build.0 = Release|Any CPU
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                        GlobalSection(ExtensibilityGlobals) = postSolution
+                            SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
+                        EndGlobalSection
+                    EndGlobal
+                ");
+                TransientTestFile filterFile = testEnvironment.CreateFile(folder, "solutionFilter.slnf",
+                    @"
+                {
+                  ""solution"": {
+                    ""path"": """ + solutionFile.Path.Replace("\\", "\\\\") + @""",
+                    ""projects"": [
+                      """ + Path.Combine("SimpleProject", "SimpleProject.csproj").Replace("\\", "\\\\") + @"""
+                    ]
+                    }
+                }
+                ");
+                SolutionFile solution = SolutionFile.Parse(filterFile.Path);
+                ILoggingService mockLogger = CreateMockLoggingService();
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, mockLogger);
+                instances.ShouldHaveSingleItem();
+
+                // Check that dependencies are built, and non-dependencies in the .sln are not.
+                MockLogger logger = new MockLogger(output);
+                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
+                logger.AssertLogContains(new string[] { "SimpleProjectBuilt" });
+                logger.AssertLogDoesntContain("ClassLibraryBuilt");
+            }
+        }
+
         /// <summary>
         /// Verify the AddNewErrorWarningMessageElement method
         /// </summary>
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index 4d62dca5bca..f476576b44f 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -58,6 +58,13 @@ override public bool Execute()
 
     public class SimpleScenarios : IDisposable
     {
+        private readonly ITestOutputHelper _output;
+
+        public SimpleScenarios(ITestOutputHelper testOutputHelper)
+        {
+            _output = testOutputHelper;
+        }
+
         /// <summary>
         /// Since we create a project with the same name in many of these tests, and two projects with
         /// the same name cannot be loaded in a ProjectCollection at the same time, we should unload the
@@ -84,7 +91,7 @@ public void SemicolonInPropertyPassedIntoStringParam()
                         <Message Text=`Property value is '$(MyPropertyWithSemicolons)'` />
                     </Target>
                 </Project>
-                ");
+                ", logger: new MockLogger(_output));
 
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
@@ -108,7 +115,7 @@ public void SemicolonInPropertyPassedIntoStringParam_UsingTaskHost()
                         <Message Text=`Property value is '$(MyPropertyWithSemicolons)'` />
                     </Target>
                 </Project>
-                ");
+                ", logger: new MockLogger(_output));
 
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
@@ -138,7 +145,8 @@ public void SemicolonInPropertyPassedIntoITaskItemParam()
 
                 </Project>
 
-                ", new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath));
+                ", new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath),
+                logger: new MockLogger(_output));
 
             logger.AssertLogContains("Received TaskItemParam: 123 abc ; def ; ghi 789");
         }
@@ -167,7 +175,8 @@ public void SemicolonInPropertyPassedIntoITaskItemParam_UsingTaskHost()
 
                 </Project>
 
-                ", new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath));
+                ", new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath),
+                logger: new MockLogger(_output));
 
             logger.AssertLogContains("Received TaskItemParam: 123 abc ; def ; ghi 789");
         }
@@ -544,7 +553,8 @@ public void InferEscapedOutputsFromTask()
 
                 </Project>
 
-                ", inputFile, outputFile));
+                ", inputFile, outputFile),
+                logger: new MockLogger(_output));
 
                 logger.AssertLogContains("Resources = aaa%3bbbb.resx;ccc%3bddd.resx");
             }
@@ -575,7 +585,7 @@ public void ItemTransformContainingSemicolon()
                     </Target>
                 </Project>
 
-                ");
+                ", logger: new MockLogger(_output));
 
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
@@ -604,7 +614,7 @@ public void ItemTransformContainingSemicolon_InTaskHost()
                     </Target>
                 </Project>
 
-                ");
+                ", logger: new MockLogger(_output));
 
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 6766d6124cf..2009a9b3f55 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -2489,7 +2489,7 @@ public void PropertyStaticFunctionAllEnabled()
         /// Expand property function that is defined (on CoreFX) in an assembly named after its full namespace.
         /// </summary>
         [Fact]
-        public void PropertyStaticFunctioLocatedFromAssemblyWithNamespaceName()
+        public void PropertyStaticFunctionLocatedFromAssemblyWithNamespaceName()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
 
@@ -2777,6 +2777,27 @@ public void PropertyFunctionRuntimeInformation(string propertyFunction, string e
             Assert.Equal(expectedExpansion, result);
         }
 
+        [Theory]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x', 1))", "3")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x45', 1))", "3")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x', 1, 4))", "3")]
+        // 9 is not a valid StringComparison enum value
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x', 9))", "10")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('X', 'StringComparison.Ordinal'))", "-1")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('X', 'StringComparison.OrdinalIgnoreCase'))", "0")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('X4', 'StringComparison.OrdinalIgnoreCase'))", "3")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('X4', 1, 'StringComparison.OrdinalIgnoreCase'))", "3")]
+        [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('X', 1, 3, 'StringComparison.OrdinalIgnoreCase'))", "3")]
+        public void StringIndexOfTests(string propertyName, string properyValue, string propertyFunction, string expectedExpansion)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>
+                {[propertyName] = ProjectPropertyInstance.Create(propertyName, properyValue)};
+
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expectedExpansion);
+        }
+
         [Fact]
         public void IsOsPlatformShouldBeCaseInsensitiveToParameter()
         {
@@ -2800,34 +2821,23 @@ public void PropertyFunctionVersionComparisonsFailsWithInvalidArguments(string b
             var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
             string expectedMessage = ResourceUtilities.GetResourceString("InvalidVersionFormat");
 
-            AssertThrows($"$([MSBuild]::VersionGreaterThan('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionGreaterThan('1.0.0', '{badVersion}'))");
+            AssertThrows(expander, $"$([MSBuild]::VersionGreaterThan('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionGreaterThan('1.0.0', '{badVersion}'))", expectedMessage);
 
-            AssertThrows($"$([MSBuild]::VersionGreaterThanOrEquals('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionGreaterThanOrEquals('1.0.0', '{badVersion}'))");
+            AssertThrows(expander, $"$([MSBuild]::VersionGreaterThanOrEquals('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionGreaterThanOrEquals('1.0.0', '{badVersion}'))", expectedMessage);
 
-            AssertThrows($"$([MSBuild]::VersionLessThan('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionLessThan('1.0.0', '{badVersion}'))");
+            AssertThrows(expander, $"$([MSBuild]::VersionLessThan('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionLessThan('1.0.0', '{badVersion}'))", expectedMessage);
 
-            AssertThrows($"$([MSBuild]::VersionLessThanOrEquals('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionLessThanOrEquals('1.0.0', '{badVersion}'))");
+            AssertThrows(expander, $"$([MSBuild]::VersionLessThanOrEquals('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionLessThanOrEquals('1.0.0', '{badVersion}'))", expectedMessage);
 
-            AssertThrows($"$([MSBuild]::VersionEquals('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionEquals('1.0.0', '{badVersion}'))");
+            AssertThrows(expander, $"$([MSBuild]::VersionEquals('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionEquals('1.0.0', '{badVersion}'))", expectedMessage);
 
-            AssertThrows($"$([MSBuild]::VersionNotEquals('{badVersion}', '1.0.0'))");
-            AssertThrows($"$([MSBuild]::VersionNotEquals('1.0.0', '{badVersion}'))");
-
-            void AssertThrows(string expression)
-            {
-                var ex = Assert.Throws<InvalidProjectFileException>(
-                    () => expander.ExpandPropertiesLeaveTypedAndEscaped(
-                        expression,
-                        ExpanderOptions.ExpandProperties,
-                        MockElementLocation.Instance));
-
-                Assert.Contains(expectedMessage, ex.Message);
-            }
+            AssertThrows(expander, $"$([MSBuild]::VersionNotEquals('{badVersion}', '1.0.0'))", expectedMessage);
+            AssertThrows(expander, $"$([MSBuild]::VersionNotEquals('1.0.0', '{badVersion}'))", expectedMessage);
         }
 
         [Theory]
@@ -2843,22 +2853,64 @@ public void PropertyFunctionVersionComparisons(string a, string b, int expectedS
             var pg = new PropertyDictionary<ProjectPropertyInstance>();
             var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
 
-            AssertSuccess(expectedSign >  0, $"$([MSBuild]::VersionGreaterThan('{a}', '{b}'))");
-            AssertSuccess(expectedSign >= 0, $"$([MSBuild]::VersionGreaterThanOrEquals('{a}', '{b}'))");
-            AssertSuccess(expectedSign <  0, $"$([MSBuild]::VersionLessThan('{a}', '{b}'))");
-            AssertSuccess(expectedSign <= 0, $"$([MSBuild]::VersionLessThanOrEquals('{a}', '{b}'))");
-            AssertSuccess(expectedSign == 0, $"$([MSBuild]::VersionEquals('{a}', '{b}'))");
-            AssertSuccess(expectedSign != 0, $"$([MSBuild]::VersionNotEquals('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign >  0, $"$([MSBuild]::VersionGreaterThan('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign >= 0, $"$([MSBuild]::VersionGreaterThanOrEquals('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign <  0, $"$([MSBuild]::VersionLessThan('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign <= 0, $"$([MSBuild]::VersionLessThanOrEquals('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign == 0, $"$([MSBuild]::VersionEquals('{a}', '{b}'))");
+            AssertSuccess(expander, expectedSign != 0, $"$([MSBuild]::VersionNotEquals('{a}', '{b}'))");
+        }
 
-            void AssertSuccess(bool expected, string expression)
-            {
-                bool actual = (bool)expander.ExpandPropertiesLeaveTypedAndEscaped(
+        [Theory]
+        [InlineData("net45", ".NETFramework", "4.5")]
+        [InlineData("netcoreapp3.1", ".NETCoreApp", "3.1")]
+        [InlineData("netstandard2.1", ".NETStandard", "2.1")]
+        [InlineData("foo", "Unsupported", "0.0")]
+        public void PropertyFunctionTargetFrameworkParsing(string tfm, string expectedIdentifier, string expectedVersion)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            AssertSuccess(expander, expectedIdentifier, $"$([MSBuild]::GetTargetFrameworkIdentifier('{tfm}'))");
+            AssertSuccess(expander, expectedVersion, $"$([MSBuild]::GetTargetFrameworkVersion('{tfm}'))");
+        }
+
+        [Theory]
+        [InlineData("net5.0", "net5.0", true)]
+        [InlineData("net45", "net46", false)]
+        [InlineData("net46", "net45", true)]
+        [InlineData("netcoreapp3.1", "netcoreapp1.0", true)]
+        [InlineData("netstandard1.6", "netstandard2.1", false)]
+        [InlineData("netcoreapp3.0", "netstandard2.1", true)]
+        [InlineData("net461", "netstandard1.0", true)]
+        [InlineData("foo", "netstandard1.0", false)]
+        public void PropertyFunctionTargetFrameworkComparisons(string tfm1, string tfm2, bool expectedFrameworkCompatible)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            AssertSuccess(expander, expectedFrameworkCompatible, $"$([MSBuild]::IsTargetFrameworkCompatible('{tfm1}', '{tfm2}'))");
+        }
+
+        private void AssertThrows(Expander<ProjectPropertyInstance, ProjectItemInstance> expander, string expression, string expectedMessage)
+        {
+            var ex = Assert.Throws<InvalidProjectFileException>(
+                () => expander.ExpandPropertiesLeaveTypedAndEscaped(
                     expression,
                     ExpanderOptions.ExpandProperties,
-                    MockElementLocation.Instance);
+                    MockElementLocation.Instance));
 
-                Assert.Equal(expected, actual);
-            }
+            Assert.Contains(expectedMessage, ex.Message);
+        }
+
+        private void AssertSuccess(Expander<ProjectPropertyInstance, ProjectItemInstance> expander, object expected, string expression)
+        {
+            var actual = expander.ExpandPropertiesLeaveTypedAndEscaped(
+                expression,
+                ExpanderOptions.ExpandProperties,
+                MockElementLocation.Instance);
+
+            Assert.Equal(expected, actual);
         }
 
         /// <summary>
@@ -3432,6 +3484,26 @@ public void PropertyFunctionConsumingItemMetadata()
             Assert.Equal(Path.Combine(s_rootPathPrefix, "some", "path", "fOo.Cs"), result);
         }
 
+        /// <summary>
+        /// Expand a property function which is a string constructor referencing item metadata.
+        /// </summary>
+        /// <remarks>
+        /// Note that referencing a non-existent metadatum results in binding to a parameter-less String constructor. This constructor
+        /// does not exist in BCL but it is special-cased in the expander logic and handled to return an empty string.
+        /// </remarks>
+        [Theory]
+        [InlineData("language", "english")]
+        [InlineData("nonexistent", "")]
+        public void PropertyStringConstructorConsumingItemMetadata(string metadatumName, string metadatumValue)
+        {
+            ProjectHelpers.CreateEmptyProjectInstance();
+            var expander = CreateItemFunctionExpander();
+
+            string result = expander.ExpandIntoStringLeaveEscaped($"$([System.String]::new(%({metadatumName})))", ExpanderOptions.ExpandAll, MockElementLocation.Instance);
+
+            result.ShouldBe(metadatumValue);
+        }
+
         /// <summary>
         /// A whole bunch error check tests
         /// </summary>
diff --git a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
index c6573a00527..8585455ea7f 100644
--- a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
@@ -12,6 +12,8 @@
 using Microsoft.Build.Definition;
 using Microsoft.Build.Unittest;
 using Xunit;
+using Microsoft.Build.Framework;
+using System.Linq;
 
 namespace Microsoft.Build.UnitTests.Preprocessor
 {
@@ -927,6 +929,122 @@ This import was added implicitly because the Project element's Sdk attribute spe
             }
         }
 
+        [Fact]
+        public void SdkResolverItemsAndPropertiesAreInPreprocessedOutput()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                string testDirectory = env.CreateFolder().Path;
+
+                var propertiesToAdd = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                {
+                    {"PropertyFromSdkResolver", "ValueFromSdkResolver" }
+                };
+
+                var itemsToAdd = new Dictionary<string, SdkResultItem>(StringComparer.OrdinalIgnoreCase)
+                {
+                    { "ItemNameFromSdkResolver", new SdkResultItem( "ItemValueFromSdkResolver",
+                        new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                        {
+                            { "MetadataName", "MetadataValue" }
+                        })
+                    }
+                };
+
+                var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                    new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        new [] { testDirectory},
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                        )));
+
+                string content = @"<Project>
+<Import Project='Import.props' Sdk='TestPropsAndItemsFromResolverSdk' />
+<PropertyGroup>
+<p>v1</p>
+</PropertyGroup>
+</Project>";
+
+                string importedPropsPath = Path.Combine(testDirectory, "Import.props");
+                File.WriteAllText(importedPropsPath, @"<Project>
+    <PropertyGroup>
+        <SdkPropsImported>true</SdkPropsImported>
+    </PropertyGroup>
+</Project>");
+
+                string projectPath = Path.Combine(testDirectory, "TestProject.csproj");
+                File.WriteAllText(projectPath, content);
+
+                var project = Project.FromFile(projectPath, projectOptions);
+
+                StringWriter writer = new StringWriter();
+
+                project.SaveLogicalProject(writer);
+
+                string actual = writer.ToString();
+
+                //  File names for the projects including the properties and items from the SDK resolvers are based on a hash of
+                //  the values, so look up the filename here.
+                //  Sample filename: projectPath + ".SdkResolver.-171948414.proj"
+                var virtualImport = project.Imports.First(i => i.ImportedProject.FullPath.StartsWith(projectPath + ".SdkResolver"));
+                string virtualProjectPath = virtualImport.ImportedProject.FullPath;
+
+                string expected = ObjectModelHelpers.CleanupFileContents(
+                    $@"<?xml version=""1.0"" encoding=""utf-16""?>
+<!--
+============================================================================================================================================
+{projectPath.Replace("--", "__")}
+============================================================================================================================================
+-->
+<Project>
+  <!--
+============================================================================================================================================
+  <Import Project=""Import.props"" Sdk=""TestPropsAndItemsFromResolverSdk"">
+
+{virtualProjectPath.Replace("--", "__")}
+============================================================================================================================================
+-->
+  <PropertyGroup xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+    <PropertyFromSdkResolver>ValueFromSdkResolver</PropertyFromSdkResolver>
+  </PropertyGroup>
+  <ItemGroup xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+    <ItemNameFromSdkResolver Include=""ItemValueFromSdkResolver"">
+      <MetadataName>MetadataValue</MetadataName>
+    </ItemNameFromSdkResolver>
+  </ItemGroup>
+  <!--
+============================================================================================================================================
+  </Import>
+============================================================================================================================================
+-->
+  <!--
+============================================================================================================================================
+  <Import Project=""Import.props"" Sdk=""TestPropsAndItemsFromResolverSdk"">
+
+{importedPropsPath.Replace("--", "__")}
+============================================================================================================================================
+-->
+  <PropertyGroup>
+    <SdkPropsImported>true</SdkPropsImported>
+  </PropertyGroup>
+  <!--
+============================================================================================================================================
+  </Import>
+
+{projectPath.Replace("--", "__")}
+============================================================================================================================================
+-->
+  <PropertyGroup>
+    <p>v1</p>
+  </PropertyGroup>
+</Project>");
+                Helpers.VerifyAssertLineByLine(expected, actual);
+            }
+        }
+
         [Fact]
         public void ImportedProjectsSdkImportsAreInPreprocessedOutput()
         {
diff --git a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
index 1311582de2a..659ce98e4bc 100644
--- a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
@@ -511,9 +511,9 @@ public void ImplicitImportsShouldHaveParsedSdkInfo(
                 var import = imports[i];
                 var importingElement = import.ImportingElement;
                 importingElement.Sdk.ShouldBe(SdkName + $"/{version}");
-                importingElement.ParsedSdkReference.Name.ShouldBe(SdkName);
-                importingElement.ParsedSdkReference.Version.ShouldBe(expectedVersion);
-                importingElement.ParsedSdkReference.MinimumVersion.ShouldBe(expectedMinimumVersion);
+                importingElement.SdkReference.Name.ShouldBe(SdkName);
+                importingElement.SdkReference.Version.ShouldBe(expectedVersion);
+                importingElement.SdkReference.MinimumVersion.ShouldBe(expectedMinimumVersion);
                 importingElement.SdkLocation.ShouldBe(ElementLocation.EmptyLocation);
                 importingElement.OriginalElement.ShouldBeOfType(expectedOriginalElementType);
 
@@ -523,7 +523,7 @@ public void ImplicitImportsShouldHaveParsedSdkInfo(
 
                 importingElement.ImplicitImportLocation.ShouldBe(implicitLocation);
 
-                import.SdkResult.SdkReference.ShouldBeSameAs(importingElement.ParsedSdkReference);
+                import.SdkResult.SdkReference.ShouldBeSameAs(importingElement.SdkReference);
 
                 var expectedSdkPath = i == 0
                     ? _sdkPropsPath
@@ -554,7 +554,7 @@ private void VerifyPropertyFromImplicitImport(Project project, string propertyNa
 
         private SdkReference GetParsedSdk(ProjectImportElement element)
         {
-            PropertyInfo parsedSdkInfo = typeof(ProjectImportElement).GetProperty("ParsedSdkReference", BindingFlags.Instance | BindingFlags.NonPublic);
+            PropertyInfo parsedSdkInfo = typeof(ProjectImportElement).GetProperty("SdkReference", BindingFlags.Instance | BindingFlags.NonPublic);
             return (SdkReference)parsedSdkInfo.GetValue(element);
         }
     }
diff --git a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
new file mode 100644
index 00000000000..ee2a51e78b8
--- /dev/null
+++ b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
@@ -0,0 +1,471 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Unittest;
+using Shouldly;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.UnitTests.Evaluation
+{
+    public class SdkResultEvaluation_Tests : IDisposable
+    {
+        private TestEnvironment _env;
+        private readonly string _testFolder;
+        private MockLogger _logger;
+        private ProjectCollection _projectCollection;
+        private ITestOutputHelper _log;
+        private bool _originalWarnOnUnitializedProperty;
+
+        public SdkResultEvaluation_Tests(ITestOutputHelper log)
+        {
+            _log = log;
+    
+            _env = TestEnvironment.Create();
+
+            _originalWarnOnUnitializedProperty = BuildParameters.WarnOnUninitializedProperty;
+            BuildParameters.WarnOnUninitializedProperty = false;
+
+            _testFolder = _env.CreateFolder().Path;
+            _logger = new MockLogger();
+            _projectCollection = _env.CreateProjectCollection().Collection;
+            _projectCollection.RegisterLogger(_logger);
+        }
+
+        private Project CreateProject(string projectPath, ProjectOptions projectOptions)
+        {
+            ProjectRootElement projectRootElement = ProjectRootElement.Open(projectPath, _projectCollection);
+
+            projectOptions.ProjectCollection = _projectCollection;
+
+            var project = Project.FromProjectRootElement(projectRootElement, projectOptions);
+
+            return project;
+        }
+
+        private void CreateMockSdkResultPropertiesAndItems(out Dictionary<string, string> propertiesToAdd, out Dictionary<string, SdkResultItem> itemsToAdd)
+        {
+            propertiesToAdd = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                {
+                    {"PropertyFromSdkResolver", "ValueFromSdkResolver" }
+                };
+
+            itemsToAdd = new Dictionary<string, SdkResultItem>(StringComparer.OrdinalIgnoreCase)
+                {
+                    { "ItemNameFromSdkResolver", new SdkResultItem( "ItemValueFromSdkResolver",
+                        new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                        {
+                            { "MetadataName", "MetadataValue" }
+                        })
+                    }
+                };
+        }
+
+        private void ValidateExpectedPropertiesAndItems(bool includePropertiesAndItems, Project project, int expectedItemCount = 1)
+        {
+            if (includePropertiesAndItems)
+            {
+                project.GetPropertyValue("PropertyFromSdkResolver").ShouldBe("ValueFromSdkResolver");
+
+                var itemsFromResolver = project.GetItems("ItemNameFromSdkResolver");
+                itemsFromResolver.Count.ShouldBe(expectedItemCount);
+                foreach (var item in itemsFromResolver)
+                {
+                    ValidateItemFromResolver(item);
+                }
+            }
+            else
+            {
+                project.GetProperty("PropertyFromSdkResolver").ShouldBeNull();
+                project.GetItems("ItemNameFromSdkResolver").ShouldBeEmpty();
+            }
+        }
+
+        private void ValidateItemFromResolver(ProjectItem item)
+        {
+            item.EvaluatedInclude.ShouldBe("ItemValueFromSdkResolver");
+            item.Metadata.Select(m => (m.Name, m.EvaluatedValue))
+                .ShouldBeSameIgnoringOrder(new[] { (Name: "MetadataName", EvaluatedValue: "MetadataValue") });
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
+        {
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            if (includePropertiesAndItems)
+            {
+                CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+            }
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        Enumerable.Empty<string>(),
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                    ))
+                );
+
+            string projectContent = @"
+                    <Project>
+                        <Import Project=""Sdk.props"" Sdk=""TestPropsAndItemsFromResolverSdk""/>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            var project = CreateProject(projectPath, projectOptions);
+
+            ValidateExpectedPropertiesAndItems(includePropertiesAndItems, project);
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SdkResolverCanReturnSinglePath(bool includePropertiesAndItems)
+        {
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            if (includePropertiesAndItems)
+            {
+                CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+            }
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        new[] { Path.Combine(_testFolder, "Sdk") },
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                    ))
+                );
+
+            string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <ValueFromResolverBefore>Value=$(PropertyFromSdkResolver)</ValueFromResolverBefore>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <ItemsFromSdkResolverBefore Include=""@(ItemNameFromSdkResolver)"" />
+                        </ItemGroup>
+                        <Import Project=""Sdk.props"" Sdk=""TestPropsAndItemsFromResolverSdk""/>
+                        <PropertyGroup>
+                            <ValueFromResolverAfter>Value=$(PropertyFromSdkResolver)</ValueFromResolverAfter>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <ItemsFromSdkResolverAfter Include=""@(ItemNameFromSdkResolver)"" />
+                        </ItemGroup>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            string sdkImportContents = @"
+                    <Project>
+                        <PropertyGroup>
+                            <PropertyFromImportedSdk>ValueFromImportedSdk</PropertyFromImportedSdk>
+                        </PropertyGroup>
+                    </Project>";
+
+            string sdkPropsPath = Path.Combine(_testFolder, "Sdk", "Sdk.props");
+            Directory.CreateDirectory(Path.Combine(_testFolder, "Sdk"));
+            File.WriteAllText(sdkPropsPath, sdkImportContents);
+
+            var project = CreateProject(projectPath, projectOptions);
+
+            ValidateExpectedPropertiesAndItems(includePropertiesAndItems, project);
+
+            project.GetPropertyValue("ValueFromResolverBefore").ShouldBe("Value=");
+            if (includePropertiesAndItems)
+            {
+                project.GetPropertyValue("ValueFromResolverAfter").ShouldBe("Value=ValueFromSdkResolver");
+            }
+            else
+            {
+                project.GetPropertyValue("ValueFromResolverAfter").ShouldBe("Value=");
+            }
+
+            project.GetPropertyValue("PropertyFromImportedSdk").ShouldBe("ValueFromImportedSdk");
+
+            project.GetItems("ItemsFromSdkResolverBefore").ShouldBeEmpty();
+            if (includePropertiesAndItems)
+            {
+                var items = project.GetItems("ItemsFromSdkResolverAfter");
+                items.Count.ShouldBe(1);
+                ValidateItemFromResolver(items.Single());
+            }
+            else
+            {
+                project.GetItems("ItemsFromSdkResolverAfter").ShouldBeEmpty();
+            }
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SdkResolverCanReturnMultiplePaths(bool includePropertiesAndItems)
+        {
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            if (includePropertiesAndItems)
+            {
+                CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+            }
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        new[] {
+                            Path.Combine(_testFolder, "Sdk1"),
+                            Path.Combine(_testFolder, "Sdk2")
+                        },
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                    ))
+                );
+
+            string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <ValueFromResolverBefore>Value=$(PropertyFromSdkResolver)</ValueFromResolverBefore>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <ItemsFromSdkResolverBefore Include=""@(ItemNameFromSdkResolver)"" />
+                        </ItemGroup>
+                        <Import Project=""Sdk.props"" Sdk=""TestPropsAndItemsFromResolverSdk""/>
+                        <PropertyGroup>
+                            <ValueFromResolverAfter>Value=$(PropertyFromSdkResolver)</ValueFromResolverAfter>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <ItemsFromSdkResolverAfter Include=""@(ItemNameFromSdkResolver)"" />
+                        </ItemGroup>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            string sdk1ImportContents = @"
+                    <Project>
+                        <PropertyGroup>
+                            <PropertyFromImportedSdk1>ValueFromImportedSdk1</PropertyFromImportedSdk1>
+                        </PropertyGroup>
+                    </Project>";
+
+            string sdk1PropsPath = Path.Combine(_testFolder, "Sdk1", "Sdk.props");
+            Directory.CreateDirectory(Path.Combine(_testFolder, "Sdk1"));
+            File.WriteAllText(sdk1PropsPath, sdk1ImportContents);
+
+            string sdk2ImportContents = @"
+                    <Project>
+                        <PropertyGroup>
+                            <PropertyFromImportedSdk2>ValueFromImportedSdk2</PropertyFromImportedSdk2>
+                        </PropertyGroup>
+                    </Project>";
+
+            string sdk2PropsPath = Path.Combine(_testFolder, "Sdk2", "Sdk.props");
+            Directory.CreateDirectory(Path.Combine(_testFolder, "Sdk2"));
+            File.WriteAllText(sdk2PropsPath, sdk2ImportContents);
+
+            var project = CreateProject(projectPath, projectOptions);
+
+            ValidateExpectedPropertiesAndItems(includePropertiesAndItems, project);
+
+            project.GetPropertyValue("ValueFromResolverBefore").ShouldBe("Value=");
+            if (includePropertiesAndItems)
+            {
+                project.GetPropertyValue("ValueFromResolverAfter").ShouldBe("Value=ValueFromSdkResolver");
+            }
+            else
+            {
+                project.GetPropertyValue("ValueFromResolverAfter").ShouldBe("Value=");
+            }
+
+            project.GetPropertyValue("PropertyFromImportedSdk1").ShouldBe("ValueFromImportedSdk1");
+            project.GetPropertyValue("PropertyFromImportedSdk2").ShouldBe("ValueFromImportedSdk2");
+
+            project.GetItems("ItemsFromSdkResolverBefore").ShouldBeEmpty();
+            if (includePropertiesAndItems)
+            {
+                var items = project.GetItems("ItemsFromSdkResolverAfter");
+                items.Count.ShouldBe(1);
+                ValidateItemFromResolver(items.Single());
+            }
+            else
+            {
+                project.GetItems("ItemsFromSdkResolverAfter").ShouldBeEmpty();
+            }
+
+            if (_logger.ErrorCount > 0 || _logger.WarningCount > 0)
+            {
+                _log.WriteLine(_logger.FullLog);
+            }
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        //  When two different SdkResults (ie from the Sdk.props and Sdk.targets imports) return the same combination of items / properties:
+        //  - Test that there aren't warnings for duplicate imports
+        //  - Test that items from resolver are duplicated in final evaluation result
+        [Fact]
+        public void SdkResolverCanReturnTheSamePropertiesAndItemsMultipleTimes()
+        {
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        new[] { Path.Combine(_testFolder, "Sdk") },
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                    ))
+                );
+
+            string projectContent = @"
+                    <Project Sdk=""TestPropsAndItemsFromResolverSdk"">
+                        <PropertyGroup>
+                            <ValueFromResolverInProjectBody>Value=$(PropertyFromSdkResolver)</ValueFromResolverInProjectBody>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <ItemsFromSdkResolverInProjectBody Include=""@(ItemNameFromSdkResolver)"" />
+                        </ItemGroup>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            string sdkPropsContents = @"
+                    <Project>
+                        <PropertyGroup>
+                            <PropertyFromSdkProps>PropertyFromSdkPropsValue</PropertyFromSdkProps>
+                        </PropertyGroup>
+                    </Project>";
+
+            string sdkPropsPath = Path.Combine(_testFolder, "Sdk", "Sdk.props");
+            Directory.CreateDirectory(Path.Combine(_testFolder, "Sdk"));
+            File.WriteAllText(sdkPropsPath, sdkPropsContents);
+
+            string sdkTargetsContents = @"
+                    <Project>
+                        <PropertyGroup>
+                            <PropertyFromSdkTargets>PropertyFromSdkTargetsValue</PropertyFromSdkTargets>
+                        </PropertyGroup>
+                    </Project>";
+
+            string sdkTargetsPath = Path.Combine(_testFolder, "Sdk", "Sdk.targets");
+            File.WriteAllText(sdkTargetsPath, sdkTargetsContents);
+
+            var project = CreateProject(projectPath, projectOptions);
+
+            ValidateExpectedPropertiesAndItems(true, project, expectedItemCount: 2);
+
+            project.GetPropertyValue("ValueFromResolverInProjectBody").ShouldBe("Value=ValueFromSdkResolver");
+            project.GetPropertyValue("PropertyFromSdkProps").ShouldBe("PropertyFromSdkPropsValue");
+            project.GetPropertyValue("PropertyFromSdkTargets").ShouldBe("PropertyFromSdkTargetsValue");
+
+            var itemsFromBody = project.GetItems("ItemsFromSdkResolverInProjectBody");
+            itemsFromBody.Count.ShouldBe(1);
+            ValidateItemFromResolver(itemsFromBody.Single());
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
+        }
+
+        [Fact]
+        public void SdkResolverCanReturnSpecialCharacters()
+        {
+            //  %3B - semicolon
+            //  %24 - $
+            //  %0A - LF
+
+            string specialString = "%3B;%24$%0A\\\"'";
+
+            Dictionary<string, string> propertiesToAdd = new Dictionary<string, string>()
+            {
+                { "PropertyName", "PropertyValue" + specialString }
+            };
+
+            Dictionary<string, SdkResultItem> itemsToAdd = new Dictionary<string, SdkResultItem>()
+            {
+                {
+                    "ItemName",
+                    new SdkResultItem(itemSpec: "ItemValue" + specialString, new Dictionary<string, string>()
+                        { { "MetadataName", "MetadataValue" + specialString } })
+                }
+            };
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestSpecialCharactersFromSdkResolver", null, null),
+                        Enumerable.Empty<string>(),
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null
+                    ))
+                );
+
+            string projectContent = @"
+                    <Project>
+                        <Import Project=""Sdk.props"" Sdk=""TestSpecialCharactersFromSdkResolver""/>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            var project = CreateProject(projectPath, projectOptions);
+
+            project.GetPropertyValue("PropertyName").ShouldBe("PropertyValue" + specialString);
+
+            var itemsFromResolver = project.GetItems("ItemName");
+            var item = itemsFromResolver.ShouldHaveSingleItem();
+            item.EvaluatedInclude.ShouldBe("ItemValue" + specialString);
+            item.Metadata.Select(m => (m.Name, m.EvaluatedValue))
+                .ShouldBeSameIgnoringOrder(new[] { (Name: "MetadataName", EvaluatedValue: "MetadataValue" + specialString) });
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
+
+        }
+
+        public void Dispose()
+        {
+            _env.Dispose();
+            BuildParameters.WarnOnUninitializedProperty = _originalWarnOnUnitializedProperty;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 8a15d66ec99..6ae0368da58 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -581,8 +581,8 @@ public void SolutionEdgesShouldNotOverwriteMultitargetingEdges()
                 Projects = new Dictionary<string, string>
                 {
                     {"1", GraphTestingUtilities.CreateProjectFile(_env, 1, new[] {2}).Path},
-                    {"2", GraphTestingUtilities.CreateProjectFile(_env, 2, extraContent: MultitargetingSpecification).Path},
-                    {"3", GraphTestingUtilities.CreateProjectFile(_env, 3, new[] {4}, extraContent: MultitargetingSpecification).Path},
+                    {"2", GraphTestingUtilities.CreateProjectFile(_env, 2, extraContent: MultitargetingSpecificationPropertyGroup).Path},
+                    {"3", GraphTestingUtilities.CreateProjectFile(_env, 3, new[] {4}, extraContent: MultitargetingSpecificationPropertyGroup).Path},
                     {"4", GraphTestingUtilities.CreateProjectFile(_env, 4).Path}
                 },
                 SolutionDependencies = new[] {("1", "2"), ("3", "4")}
@@ -687,10 +687,10 @@ private void AssertSolutionBasedGraph(
             if (projectConfigurations == null || graphFromSolution.ProjectNodes.All(n => n.ProjectReferences.Count == 0))
             {
                 graphFromSolution.GraphRoots.Select(GetProjectPath)
-                    .ShouldBeEquivalentTo(graph.GraphRoots.Select(GetProjectPath));
+                    .ShouldBeSameIgnoringOrder(graph.GraphRoots.Select(GetProjectPath));
 
                 graphFromSolution.ProjectNodes.Select(GetProjectPath)
-                    .ShouldBeEquivalentTo(graph.ProjectNodes.Select(GetProjectPath));
+                    .ShouldBeSameIgnoringOrder(graph.ProjectNodes.Select(GetProjectPath));
             }
 
             var expectedCurrentConfiguration = currentSolutionConfiguration ?? solutionConfigurations.First();
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index b52763372bf..4cde1fc90bc 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -1,6 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.IO;
@@ -17,12 +18,22 @@ internal static class GraphTestingUtilities
         public static readonly ImmutableDictionary<string, string> EmptyGlobalProperties = new Dictionary<string, string> {{PropertyNames.IsGraphBuild, "true"}}.ToImmutableDictionary();
 
         public static readonly string InnerBuildPropertyName = "InnerBuild";
+        public static readonly string InnerBuildPropertiesName = "InnerBuildProperties";
 
-        public static readonly string MultitargetingSpecification = $@"<PropertyGroup>
+        public static readonly string MultitargetingSpecificationPropertyGroup = $@"<PropertyGroup>
                                                                         <InnerBuildProperty>{InnerBuildPropertyName}</InnerBuildProperty>
-                                                                        <InnerBuildPropertyValues>InnerBuildProperties</InnerBuildPropertyValues>
-                                                                        <InnerBuildProperties>a;b</InnerBuildProperties>
+                                                                        <InnerBuildPropertyValues>{InnerBuildPropertiesName}</InnerBuildPropertyValues>
+                                                                        <{InnerBuildPropertiesName}>a;b</{InnerBuildPropertiesName}>
                                                                      </PropertyGroup>";
+        public static readonly string HardCodedInnerBuildWithMultitargetingSpecification = $@"<PropertyGroup>
+                                                                        <InnerBuildProperty>{InnerBuildPropertyName}</InnerBuildProperty>
+                                                                        <InnerBuildPropertyValues>{InnerBuildPropertiesName}</InnerBuildPropertyValues>
+                                                                        <{InnerBuildPropertyName}>a</{InnerBuildPropertyName}>
+                                                                     </PropertyGroup>";
+
+        public static readonly string EnableTransitiveProjectReferencesPropertyGroup = @"<PropertyGroup>
+                                                                                            <AddTransitiveProjectReferencesInStaticGraph>true</AddTransitiveProjectReferencesInStaticGraph>
+                                                                                         </PropertyGroup>";
 
         public static void AssertOuterBuildAsNonRoot(
             ProjectGraphNode outerBuild,
@@ -30,7 +41,7 @@ public static void AssertOuterBuildAsNonRoot(
             Dictionary<string, string> additionalGlobalProperties = null,
             int expectedInnerBuildCount = 2)
         {
-            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>();
 
             AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
 
@@ -54,7 +65,7 @@ public static void AssertOuterBuildAsNonRoot(
                     innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);
                     innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);
 
-                    graph.TestOnly_Edges.TestOnly_HasEdge((outerBuild, innerBuild)).ShouldBeFalse();
+                    graph.TestOnly_Edges.HasEdge((outerBuild, innerBuild)).ShouldBeFalse();
 
                     var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
                     var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
@@ -69,7 +80,7 @@ public static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary
             additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
 
             IsNotMultitargeting(node).ShouldBeTrue();
-            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
+            node.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
             node.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();
         }
 
@@ -81,7 +92,7 @@ public static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dicti
             IsInnerBuild(outerBuild).ShouldBeFalse();
 
             outerBuild.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();
-            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
         }
 
         public static void AssertInnerBuildEvaluation(
@@ -100,7 +111,7 @@ public static void AssertInnerBuildEvaluation(
 
             if (InnerBuildPropertyIsSetViaGlobalProperty)
             {
-                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(
+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(
                     EmptyGlobalProperties
                         .Add(InnerBuildPropertyName, innerBuildPropertyValue)
                         .AddRange(additionalGlobalProperties));
@@ -205,5 +216,37 @@ internal static TransientTestFile CreateProjectFile(
                 defaultTargets ?? "Build",
                 extraContent);
         }
+
+        internal static IEnumerable<ProjectGraphNode> ComputeClosure(ProjectGraphNode node)
+        {
+            return ComputeClosureRecursive(node).ToHashSet();
+
+            IEnumerable<ProjectGraphNode> ComputeClosureRecursive(ProjectGraphNode projectGraphNode)
+            {
+                foreach (var reference in projectGraphNode.ProjectReferences)
+                {
+                    yield return reference;
+
+                    foreach (var closureReference in ComputeClosureRecursive(reference))
+                    {
+                        yield return closureReference;
+                    }
+                }
+            }
+        }
+
+        internal static void AssertReferencesIgnoringOrder(this ProjectGraph graph, Dictionary<int, int[]> expectedReferencesForNode)
+        {
+            foreach (var kvp in expectedReferencesForNode)
+            {
+                var node = GetFirstNodeWithProjectNumber(graph, kvp.Key);
+                node.AssertReferencesIgnoringOrder(kvp.Value);
+            }
+        }
+
+        internal static void AssertReferencesIgnoringOrder(this ProjectGraphNode node, int[] expectedReferences)
+        {
+            node.ProjectReferences.Select(GetProjectNumber).ShouldBeSameIgnoringOrder(expectedReferences);
+        }
     }
 }
diff --git a/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs b/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
index 119edea8b05..234f6f3a47d 100644
--- a/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
+++ b/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
@@ -247,7 +247,7 @@ private void TestParallelWorkSet(ParallelWorkSetTestCase tt)
 
             _workSet.WaitForAllWorkAndComplete();
             _workSet.IsCompleted.ShouldBeTrue();
-            _workSet.CompletedWork.ShouldBeEquivalentTo((IReadOnlyCollection<KeyValuePair<string, string>>) tt.ExpectedCompletedWork);
+            _workSet.CompletedWork.ShouldBeSameIgnoringOrder((IReadOnlyCollection<KeyValuePair<string, string>>) tt.ExpectedCompletedWork);
         }
     }
 }
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 84edacaf9c7..7e7022e5622 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -33,7 +33,7 @@ public class ProjectGraphTests : IDisposable
         private static string[] NonOuterBuildTargets = {"AHelperOuter", "AHelperInner", "A"};
         private static string[] OuterBuildTargets = {"AHelperOuter"};
 
-        private static readonly string OuterBuildSpecificationWithProjectReferenceTargets = MultitargetingSpecification + ProjectReferenceTargetsWithMultitargeting;
+        private static readonly string OuterBuildSpecificationWithProjectReferenceTargets = MultitargetingSpecificationPropertyGroup + ProjectReferenceTargetsWithMultitargeting;
 
         public ProjectGraphTests(ITestOutputHelper outputHelper)
         {
@@ -114,13 +114,13 @@ public void UpdatingReferencesIsBidirectional()
                 node.AddProjectReference(reference1, referenceItem1, edges);
                 node.AddProjectReference(reference2, referenceItem2, edges);
 
-                node.ProjectReferences.ShouldBeEquivalentTo(new []{reference1, reference2});
+                node.ProjectReferences.ShouldBeSameIgnoringOrder(new []{reference1, reference2});
                 node.ReferencingProjects.ShouldBeEmpty();
 
-                reference1.ReferencingProjects.ShouldBeEquivalentTo(new[] {node});
+                reference1.ReferencingProjects.ShouldBeSameIgnoringOrder(new[] {node});
                 reference1.ProjectReferences.ShouldBeEmpty();
 
-                reference2.ReferencingProjects.ShouldBeEquivalentTo(new[] {node});
+                reference2.ReferencingProjects.ShouldBeSameIgnoringOrder(new[] {node});
                 reference2.ProjectReferences.ShouldBeEmpty();
 
                 edges[(node, reference1)].ShouldBe(referenceItem1);
@@ -336,16 +336,16 @@ public void ProjectCollectionShouldNotInfluenceGlobalProperties()
             var root1 = GetFirstNodeWithProjectNumber(graph, 1);
             var globalPropertiesFor1 = new Dictionary<string, string> { ["B"] = "EntryPointB", ["C"] = "EntryPointC", ["IsGraphBuild"] = "true" };
 
-            root1.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor1);
-            root1.ProjectReferences.First(r => GetProjectNumber(r) == 3).ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor1);
-            root1.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor1);
+            root1.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
+            root1.ProjectReferences.First(r => GetProjectNumber(r) == 3).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
+            root1.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
 
             var root2 = GetFirstNodeWithProjectNumber(graph, 2);
             var globalPropertiesFor2 = new Dictionary<string, string> { ["IsGraphBuild"] = "true" };
 
-            root2.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor2);
-            root2.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor2);
-            root2.ProjectReferences.First(r => GetProjectNumber(r) == 5).ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(globalPropertiesFor2);
+            root2.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
+            root2.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
+            root2.ProjectReferences.First(r => GetProjectNumber(r) == 5).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
         }
 
         [Fact]
@@ -375,7 +375,7 @@ public void ConstructWithDifferentGlobalProperties()
                 // Projects 2 and 3 both reference project 4, but with different properties, so they should not point to the same node.
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ShouldNotBe(GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First());
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("4.proj");
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties);
                 GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("4.proj");
                 GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First().ProjectInstance.GlobalProperties.Count.ShouldBeGreaterThan(1);
             }
@@ -972,7 +972,7 @@ public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBui
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: "D1",
-                extraContent: MultitargetingSpecification +
+                extraContent: MultitargetingSpecificationPropertyGroup +
                               projectReferenceTargetsProtocol +
 $@"
 <ItemGroup>
@@ -998,7 +998,7 @@ public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBui
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: "D3",
-                extraContent: MultitargetingSpecification + projectReferenceTargetsProtocol);
+                extraContent: MultitargetingSpecificationPropertyGroup + projectReferenceTargetsProtocol);
 
             var graph = new ProjectGraph(entryProject);
 
@@ -1373,6 +1373,17 @@ public static IEnumerable<object[]> Graphs
                     }
                 };
 
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{4, 2}},
+                        {2, new []{3}},
+                        {3, new []{4}},
+                        {4, new []{5}}
+                    }
+                };
+
                 yield return new object[]
                 {
                     new Dictionary<int, int[]>
@@ -1394,6 +1405,19 @@ public static IEnumerable<object[]> Graphs
                     }
                 };
 
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{2, 4, 3, 5} },
+                        {2, new []{5} },
+                        {3, new []{5} },
+                        {4, new []{6} },
+                        {5, new []{7} },
+                        {6, new []{5} }
+                    },
+                };
+
                 yield return new object[]
                 {
                     new Dictionary<int, int[]>
@@ -1499,7 +1523,7 @@ private static void AssertOuterBuildAsRoot(
         [Fact]
         public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
         {
-            var projectFile = _env.CreateTestProjectWithFiles($@"<Project>{MultitargetingSpecification}</Project>").ProjectFile;
+            var projectFile = _env.CreateTestProjectWithFiles($@"<Project>{MultitargetingSpecificationPropertyGroup}</Project>").ProjectFile;
 
             var graph = new ProjectGraph(projectFile);
 
@@ -1525,7 +1549,7 @@ public void OuterBuildAsNonRootShouldNotReferenceInnerBuilds()
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: null,
-                extraContent: MultitargetingSpecification);
+                extraContent: MultitargetingSpecificationPropertyGroup);
 
 
             var graph = new ProjectGraph(entryProject);
@@ -1559,7 +1583,7 @@ public void InnerBuildsFromNonRootOuterBuildInheritEdgesToOuterBuild()
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: null,
-                extraContent: MultitargetingSpecification);
+                extraContent: MultitargetingSpecificationPropertyGroup);
 
 
             var graph = new ProjectGraph(entryProject);
@@ -1587,7 +1611,7 @@ public void InnerBuildsFromNonRootOuterBuildInheritEdgesToOuterBuild()
         public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
         {
             // multitarget to duplicate monikers
-            var multitargetingSpecification = MultitargetingSpecification +
+            var multitargetingSpecification = MultitargetingSpecificationPropertyGroup +
                                               @"<PropertyGroup>
                                                     <InnerBuildProperties>a;a</InnerBuildProperties>
                                                 </PropertyGroup>";
@@ -1611,7 +1635,7 @@ public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
         [Fact]
         public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGlobalProperties()
         {
-            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification).Path;
+            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
             CreateProjectFile(env: _env, projectNumber: 2);
 
             var graph = new ProjectGraph(root);
@@ -1630,7 +1654,7 @@ public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGl
         [Fact]
         public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildPropertyToReference()
         {
-            var innerBuildViaLocalProperty = MultitargetingSpecification + $"<PropertyGroup><{InnerBuildPropertyName}>foo</{InnerBuildPropertyName}></PropertyGroup>";
+            var innerBuildViaLocalProperty = MultitargetingSpecificationPropertyGroup + $"<PropertyGroup><{InnerBuildPropertyName}>foo</{InnerBuildPropertyName}></PropertyGroup>";
 
             var root = CreateProjectFile(
                 env: _env,
@@ -1658,7 +1682,7 @@ public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildProperty
         [Fact]
         public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropertyToReference()
         {
-            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification).Path;
+            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
             CreateProjectFile(env: _env, projectNumber: 2);
 
             var graph = new ProjectGraph(root, new Dictionary<string, string>{{InnerBuildPropertyName, "foo"}});
@@ -1677,10 +1701,10 @@ public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropert
         [Fact]
         public void NonMultitargetingProjectsAreCompatibleWithMultitargetingProjects()
         {
-            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2, 3}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification).Path;
+            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2, 3}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
             CreateProjectFile(env: _env, projectNumber: 2, projectReferences: new[] {4});
             CreateProjectFile(env: _env, projectNumber: 3, projectReferences: new[] {4});
-            CreateProjectFile(env: _env, projectNumber: 4, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification);
+            CreateProjectFile(env: _env, projectNumber: 4, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup);
 
             var graph = new ProjectGraph(root);
 
@@ -1698,15 +1722,15 @@ public void NonMultitargetingProjectsAreCompatibleWithMultitargetingProjects()
         [Fact]
         public void InnerBuildsCanHaveSeparateReferences()
         {
-            var extraInnerBuildReferenceSpec = MultitargetingSpecification +
+            var extraInnerBuildReferenceSpec = MultitargetingSpecificationPropertyGroup +
                                           $@"<ItemGroup>
                                                 <ProjectReference Condition=`'$({InnerBuildPropertyName})'=='b'` Include=`4.proj;5.proj`/>
                                             </ItemGroup>".Cleanup();
 
             var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2, 3}, projectReferenceTargets: null, defaultTargets: null, extraContent: extraInnerBuildReferenceSpec).Path;
-            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification);
+            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup);
             CreateProjectFile(env: _env, projectNumber: 3);
-            CreateProjectFile(env: _env, projectNumber: 4, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification);
+            CreateProjectFile(env: _env, projectNumber: 4, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup);
             CreateProjectFile(env: _env, projectNumber: 5);
 
             var graph = new ProjectGraph(root);
@@ -1726,13 +1750,13 @@ public void InnerBuildsCanHaveSeparateReferences()
 
             innerBuildWithCommonReferences.ProjectReferences.Count.ShouldBe(4);
             var referenceNumbersSet = innerBuildWithCommonReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstance.FullPath)).ToHashSet();
-            referenceNumbersSet.ShouldBeEquivalentTo(new HashSet<string>{"2", "3"});
+            referenceNumbersSet.ShouldBeSameIgnoringOrder(new HashSet<string>{"2", "3"});
 
             var innerBuildWithAdditionalReferences = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GlobalProperties.TryGetValue(InnerBuildPropertyName, out string p) && p == "b");
 
             innerBuildWithAdditionalReferences.ProjectReferences.Count.ShouldBe(8);
             referenceNumbersSet = innerBuildWithAdditionalReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstance.FullPath)).ToHashSet();
-            referenceNumbersSet.ShouldBeEquivalentTo(new HashSet<string>{"2", "3", "4", "5"});
+            referenceNumbersSet.ShouldBeSameIgnoringOrder(new HashSet<string>{"2", "3", "4", "5"});
         }
 
         [Fact]
@@ -1746,7 +1770,7 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
 
             var graph = new ProjectGraph(new []
             {
-                CreateProjectFile(env: _env, projectNumber: 1, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification).Path,
+                CreateProjectFile(env: _env, projectNumber: 1, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path,
                 CreateProjectFile(env: _env, projectNumber: 2, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: referenceToInnerBuild).Path
             },
             additionalGlobalProperties);
@@ -1767,7 +1791,7 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
             two.ProjectReferences.ShouldHaveSingleItem();
             two.ProjectReferences.First().ShouldBe(referencedInnerBuild);
 
-            referencedInnerBuild.ReferencingProjects.ShouldBeEquivalentTo(new []{two, outerBuild});
+            referencedInnerBuild.ReferencingProjects.ShouldBeSameIgnoringOrder(new []{two, outerBuild});
         }
 
         [Fact]
@@ -1778,7 +1802,7 @@ public void StandaloneInnerBuildsCanBeReferencedWithoutOuterBuilds()
                                            </ItemGroup>";
 
             var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: referenceToInnerBuild).Path;
-            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: new []{3}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecification + $"<PropertyGroup><{InnerBuildPropertyName}>a</{InnerBuildPropertyName}></PropertyGroup>");
+            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: new []{3}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup + $"<PropertyGroup><{InnerBuildPropertyName}>a</{InnerBuildPropertyName}></PropertyGroup>");
             CreateProjectFile(env: _env, projectNumber: 3);
 
             var additionalGlobalProperties = new Dictionary<string, string>{{"x", "y"}};
@@ -1816,7 +1840,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: null,
-                extraContent: MultitargetingSpecification + referenceToInnerBuild)
+                extraContent: MultitargetingSpecificationPropertyGroup + referenceToInnerBuild)
                 .Path;
 
             CreateProjectFile(
@@ -1825,7 +1849,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
                 projectReferences: null,
                 projectReferenceTargets: null,
                 defaultTargets: null,
-                extraContent: MultitargetingSpecification);
+                extraContent: MultitargetingSpecificationPropertyGroup);
 
             var graph = new ProjectGraph(new [] { root }, additionalGlobalProperties);
 
@@ -1852,7 +1876,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
             // the outer build is necessary as the referencing inner build can still call targets on it
             GetNodesWithProjectNumber(graph, 2).Count().ShouldBe(2);
 
-            innerBuild1WithReferenceToInnerBuild2.ProjectReferences.ShouldBeEquivalentTo(new []{outerBuild2, innerBuild2});
+            innerBuild1WithReferenceToInnerBuild2.ProjectReferences.ShouldBeSameIgnoringOrder(new []{outerBuild2, innerBuild2});
         }
 
         public static IEnumerable<object[]> AllNodesShouldHaveGraphBuildGlobalPropertyData
@@ -1953,7 +1977,7 @@ public void AllNodesShouldHaveGraphBuildGlobalProperty(Dictionary<int, int[]> ed
 
                 foreach (var node in projectGraph.ProjectNodes)
                 {
-                    node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(expectedGlobalProperties);
+                    node.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(expectedGlobalProperties);
                 }
             }
         }
@@ -1972,6 +1996,320 @@ public void UserValuesForIsGraphBuildGlobalPropertyShouldBePreserved()
             }
         }
 
+        [Theory]
+        [MemberData(nameof(Graphs))]
+        public void GraphShouldSupportTransitiveReferences(Dictionary<int, int[]> edges)
+        {
+            var graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: edges,
+                extraContentPerProjectNumber: null,
+                extraContentForAllNodes: EnableTransitiveProjectReferencesPropertyGroup
+                );
+
+            foreach (var node in graph.ProjectNodes)
+            {
+                var expectedClosure = ComputeClosure(node);
+
+                node.ProjectReferences.ShouldBeSameIgnoringOrder(expectedClosure);
+            }
+        }
+
+        public static IEnumerable<object[]> TransitiveReferencesAreDefinedPerProjectTestData
+        {
+            get
+            {
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3}},
+                        {2, new[] {3}},
+                        {3, new[] {4}}
+                    },
+                    new Dictionary<int, string>(),
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3}},
+                        {2, new[] {3}}
+                    }
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}},
+                        {2, new[] {3}},
+                        {3, new[] {4}}
+                    },
+                    new Dictionary<int, string>
+                    {
+                        {1, EnableTransitiveProjectReferencesPropertyGroup}
+                    },
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2, 3, 4}},
+                        {2, new[] {3}},
+                        {3, new[] {4}},
+                        {4, new int[0]}
+                    }
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3}},
+                        {2, new[] {3}},
+                        {3, new[] {4}}
+                    },
+                    new Dictionary<int, string>
+                    {
+                        {1, EnableTransitiveProjectReferencesPropertyGroup}
+                    },
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3, 4}},
+                        {2, new[] {3}}
+                    }
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3}},
+                        {2, new[] {3}},
+                        {3, new[] {4}}
+                    },
+                    new Dictionary<int, string>
+                    {
+                        {1, EnableTransitiveProjectReferencesPropertyGroup},
+                        {2, EnableTransitiveProjectReferencesPropertyGroup}
+                    },
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {3, 4}},
+                        {2, new[] {3, 4}}
+                    }
+                };
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}},
+                        {2, new[] {3}},
+                        {3, new[] {4}},
+                        {4, new[] {5}},
+                        {5, new[] {6}}
+                    },
+                    new Dictionary<int, string>
+                    {
+                        {1, EnableTransitiveProjectReferencesPropertyGroup},
+                        {3, EnableTransitiveProjectReferencesPropertyGroup},
+                        {5, EnableTransitiveProjectReferencesPropertyGroup}
+                    },
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2, 3, 4, 5, 6}},
+                        {2, new[] {3}},
+                        {3, new[] {4, 5, 6}},
+                        {4, new[] {5}},
+                        {5, new[] {6}},
+                        {6, new int[0]},
+                    }
+                };
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(TransitiveReferencesAreDefinedPerProjectTestData))]
+        public void TransitiveReferencesAreDefinedPerProject(
+            Dictionary<int, int[]> edges,
+            Dictionary<int, string> extraContentPerProjectNumber,
+            Dictionary<int, int[]> expectedReferences
+            )
+        {
+            var graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: edges,
+                extraContentPerProjectNumber: extraContentPerProjectNumber
+            );
+
+            graph.AssertReferencesIgnoringOrder(expectedReferences);
+        }
+
+        [Fact]
+        public void TransitiveReferencesShouldNotBeAddedToOuterBuilds()
+        {
+            var graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: new Dictionary<int, int[]>
+                {
+                    {1, new []{3, 4} },
+                    {2, new []{3, 4} },
+                    {3, new []{4} },
+                    {4, new []{5} },
+                    {5, new []{6} }
+                },
+                extraContentPerProjectNumber: new Dictionary<int, string>
+                {
+                    {
+                        1,
+                        EnableTransitiveProjectReferencesPropertyGroup +
+                        MultitargetingSpecificationPropertyGroup
+                    },
+                    {
+                        2,
+                        EnableTransitiveProjectReferencesPropertyGroup +
+                        HardCodedInnerBuildWithMultitargetingSpecification
+                    },
+                    {
+                        4,
+                        EnableTransitiveProjectReferencesPropertyGroup +
+                        MultitargetingSpecificationPropertyGroup
+                    },
+                    {
+                        5,
+                        HardCodedInnerBuildWithMultitargetingSpecification
+                    },
+                    {
+                        6,
+                        MultitargetingSpecificationPropertyGroup
+                    }
+                }
+            );
+
+            GetOuterBuild(graph, 1).AssertReferencesIgnoringOrder(new []{1, 1});
+
+            var innerBuilds1 = GetInnerBuilds(graph, 1);
+            innerBuilds1.Count.ShouldBe(2);
+
+            foreach (var innerBuild in innerBuilds1)
+            {
+                innerBuild.AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
+            }
+
+            GetFirstNodeWithProjectNumber(graph, 2).AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
+
+            GetOuterBuild(graph, 4).AssertReferencesIgnoringOrder(new int[0]);
+
+            var innerBuilds4 = GetInnerBuilds(graph, 4);
+            innerBuilds4.Count.ShouldBe(2);
+
+            foreach (var innerBuild in innerBuilds4)
+            {
+                innerBuild.AssertReferencesIgnoringOrder(new []{5, 6, 6, 6});
+            }
+        }
+
+        [Fact]
+        public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
+        {
+            var graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: new Dictionary<int, int[]>()
+                {
+                    {1, new[] {2}},
+                    {2, new[] {3}}
+                },
+                extraContentPerProjectNumber: new Dictionary<int, string>()
+                {
+                    {
+                        1,
+                        $@"
+<PropertyGroup>
+    <{InnerBuildPropertiesName}>1A;1B</{InnerBuildPropertiesName}>
+</PropertyGroup>
+
+<ItemGroup>
+    <ProjectReference Update='@(ProjectReference)' Targets='1ATarget' Condition=`'$({InnerBuildPropertyName})' == '1A'` />
+    <ProjectReference Update='@(ProjectReference)' Targets='1BTarget' Condition=`'$({InnerBuildPropertyName})' == '1B'` />
+</ItemGroup>"
+                    },
+                    {
+                        2,
+                        $@"
+<PropertyGroup>
+    <{InnerBuildPropertiesName}>2A;2B</{InnerBuildPropertiesName}>
+</PropertyGroup>
+
+<ItemGroup>
+    <ProjectReference Update='@(ProjectReference)' Targets='2ATarget' Condition=`'$({InnerBuildPropertyName})' == '2A'` />
+    <ProjectReference Update='@(ProjectReference)' Targets='2BTarget' Condition=`'$({InnerBuildPropertyName})' == '2B'` />
+</ItemGroup>"
+                    },
+                    {
+                        3,
+                        $@"
+<PropertyGroup>
+    <{InnerBuildPropertiesName}>3A;3B</{InnerBuildPropertiesName}>
+</PropertyGroup>"
+                    }
+                },
+                extraContentForAllNodes: @$"
+<PropertyGroup>
+    <{ProjectInterpretation.AddTransitiveProjectReferencesInStaticGraphPropertyName}>true</{ProjectInterpretation.AddTransitiveProjectReferencesInStaticGraphPropertyName}>
+</PropertyGroup>
+
+<PropertyGroup>
+    <InnerBuildProperty>{InnerBuildPropertyName}</InnerBuildProperty>
+    <InnerBuildPropertyValues>{InnerBuildPropertiesName}</InnerBuildPropertyValues>
+</PropertyGroup>
+
+<ItemGroup>
+    <ProjectReferenceTargets Include='Build' Targets='Build;{MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker}' />
+    <ProjectReferenceTargets Include='Build' Targets='BuildForOuterBuild' OuterBuild='true' />
+</ItemGroup>");
+
+            var targetLists = graph.GetTargetLists(new[] {"Build"});
+
+            var outerBuild1 = GetOuterBuild(graph, 1);
+            targetLists[outerBuild1].ShouldBe(new[] {"Build"});
+
+            AssertOuterBuildAsRoot(outerBuild1, graph, expectedInnerBuildCount: 2);
+
+            var innerBuildsFor1 = GetInnerBuilds(graph, 1);
+            innerBuildsFor1.Count.ShouldBe(2);
+
+            foreach (var inner1 in innerBuildsFor1)
+            {
+                // Outer build targets are added to inner builds because 
+                targetLists[inner1].ShouldBe(new[] {"BuildForOuterBuild", "Build"});
+            }
+
+            var outerBuild2 = GetOuterBuild(graph, 2);
+            targetLists[outerBuild2].ShouldBe(new[] {"BuildForOuterBuild"});
+            AssertOuterBuildAsNonRoot(outerBuild2, graph, expectedInnerBuildCount: 2);
+
+            var innerBuildsFor2 = GetInnerBuilds(graph, 2);
+            innerBuildsFor2.Count.ShouldBe(2);
+
+            foreach (var inner2 in innerBuildsFor2)
+            {
+                targetLists[inner2].ShouldBe(new[] {"BuildForOuterBuild", "Build", "1ATarget", "1BTarget"});
+            }
+
+            var outerBuild3 = GetOuterBuild(graph, 3);
+            targetLists[outerBuild3].ShouldBe(new[] { "BuildForOuterBuild" });
+
+            outerBuild3.ReferencingProjects.Count.ShouldBe(4);
+
+            AssertOuterBuildAsNonRoot(outerBuild3, graph, expectedInnerBuildCount: 2);
+            var innerBuildsFor3 = GetInnerBuilds(graph, 3);
+            innerBuildsFor3.Count.ShouldBe(2);
+
+            foreach (var inner3 in innerBuildsFor3)
+            {
+                inner3.ReferencingProjects.Count.ShouldBe(4);
+
+                // 3 does not get called with 1ATarget or 1BTarget because those apply only to direct references
+                targetLists[inner3]
+                    .ShouldBe(new[] { "BuildForOuterBuild", "Build", "2ATarget", "2BTarget" });
+            }
+        }
+
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
index 88a009211a3..1611340705b 100644
--- a/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.OM.Instance
 {
diff --git a/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
index ab9d4e89982..1f8544a3eb4 100644
--- a/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.OM.Instance
 {
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 24110272103..e387e719ad6 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Framework;
 using System.IO;
 using Xunit;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.OM.Instance
 {
diff --git a/src/Build.UnitTests/InternalEngineHelpers.cs b/src/Build.UnitTests/InternalEngineHelpers.cs
index 74717d25628..833539345c7 100644
--- a/src/Build.UnitTests/InternalEngineHelpers.cs
+++ b/src/Build.UnitTests/InternalEngineHelpers.cs
@@ -68,11 +68,60 @@ public override Framework.SdkResult Resolve(SdkReference sdkReference, SdkResolv
                 ResolvedCalls.AddOrUpdate(sdkReference.Name, k => 1, (k, c) => c + 1);
 
                 return _resultMap.TryGetValue(sdkReference.Name, out var result)
-                    ? new SdkResult(sdkReference, result.Path, result.Version, null)
+                    ? CloneSdkResult(result)
                     : null;
             }
 
+            private SdkResult CloneSdkResult(SdkResult sdkResult)
+            {
+                if (!sdkResult.Success)
+                {
+                    return new SdkResult(sdkResult.SdkReference, sdkResult.Warnings, sdkResult.Errors);
+                }
+
+                IEnumerable<string> sdkResultPaths;
+                if (sdkResult.Path == null)
+                {
+                    sdkResultPaths = Enumerable.Empty<string>();
+                }
+                else
+                {
+                    List<string> pathList = new List<string>();
+                    pathList.Add(sdkResult.Path);
+                    if (sdkResult.AdditionalPaths != null)
+                    {
+                        pathList.AddRange(sdkResult.AdditionalPaths);
+                    }
+                    sdkResultPaths = pathList;
+                }
 
+                Dictionary<string, SdkResultItem> sdkResultItems;
+
+                if (sdkResult.ItemsToAdd == null)
+                {
+                    sdkResultItems = null;
+                }
+                else
+                {
+                    sdkResultItems = new Dictionary<string, SdkResultItem>(StringComparer.OrdinalIgnoreCase);
+                    foreach (var item in sdkResult.ItemsToAdd)
+                    {
+                        Dictionary<string, string> newMetadata = null;
+                        if (item.Value.Metadata != null)
+                        {
+                            newMetadata = new Dictionary<string, string>(item.Value.Metadata, StringComparer.OrdinalIgnoreCase);
+                        }
+                        sdkResultItems.Add(item.Key, new SdkResultItem(item.Value.ItemSpec, newMetadata));
+                    }
+                }
+
+                return new SdkResult(sdkResult.SdkReference,
+                                     sdkResultPaths,
+                                     version: sdkResult.Version,
+                                     sdkResult.PropertiesToAdd == null ? null : new Dictionary<string, string>(sdkResult.PropertiesToAdd, StringComparer.OrdinalIgnoreCase),
+                                     sdkResultItems,
+                                     sdkResult.Warnings);
+            }
         }
 
         internal class FileBasedMockSdkResolver : SdkResolver
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 5806db2d3e6..c36a51b66b8 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -11,12 +11,17 @@
     
     <!-- Define a constant so we can skip tests that require MSBuildTaskHost -->
     <DefineConstants Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(MonoBuild)' == 'true'">$(DefineConstants);NO_MSBUILDTASKHOST</DefineConstants>
+
+    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
   </PropertyGroup>
 
   <ItemGroup>
     <PackageReference Include="System.Collections.Concurrent" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
+    <PackageReference Include="NuGet.Frameworks" >
+      <PrivateAssets>all</PrivateAssets>
+    </PackageReference>
 
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
diff --git a/src/Build.UnitTests/OpportunisticIntern_Tests.cs b/src/Build.UnitTests/OpportunisticIntern_Tests.cs
index cae14b38b49..fd7f70ba885 100644
--- a/src/Build.UnitTests/OpportunisticIntern_Tests.cs
+++ b/src/Build.UnitTests/OpportunisticIntern_Tests.cs
@@ -7,12 +7,25 @@
 using Microsoft.Build;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
 {
-    public class OpportunisticIntern_Tests
+    public abstract class OpportunisticInternTestBase : IDisposable
     {
-        private static bool IsInternable(OpportunisticIntern.IInternable internable)
+        protected TestEnvironment _env;
+
+        public void Dispose()
+        {
+            _env.Dispose();
+        }
+
+        protected OpportunisticInternTestBase(ITestOutputHelper testOutput)
+        {
+            _env = TestEnvironment.Create(testOutput);
+        }
+
+        private static bool IsInternable(IInternable internable)
         {
             string i1 = OpportunisticIntern.InternableToString(internable);
             string i2 = OpportunisticIntern.InternableToString(internable);
@@ -20,19 +33,19 @@ private static bool IsInternable(OpportunisticIntern.IInternable internable)
             return Object.ReferenceEquals(i1, i2);
         }
 
-        private static void AssertInternable(OpportunisticIntern.IInternable internable)
+        private static void AssertInternable(IInternable internable)
         {
             Assert.True(IsInternable(internable));
         }
 
         private static void AssertInternable(StringBuilder sb)
         {
-            AssertInternable(new OpportunisticIntern.StringBuilderInternTarget(sb));
+            AssertInternable(new StringBuilderInternTarget(sb));
         }
 
         private static string AssertInternable(char[] ch, int startIndex, int count)
         {
-            var target = new OpportunisticIntern.CharArrayInternTarget(ch, startIndex, count);
+            var target = new CharArrayInternTarget(ch, startIndex, count);
             AssertInternable(target);
             Assert.Equal(target.Length, count);
 
@@ -45,22 +58,22 @@ private static void AssertInternable(string value)
             AssertInternable(value.ToCharArray(), 0, value.ToCharArray().Length);
         }
 
-        private static void AssertNotInternable(OpportunisticIntern.IInternable internable)
+        private static void AssertNotInternable(IInternable internable)
         {
             Assert.False(IsInternable(internable));
         }
 
         private static void AssertNotInternable(StringBuilder sb)
         {
-            AssertNotInternable(new OpportunisticIntern.StringBuilderInternTarget(sb));
+            AssertNotInternable(new StringBuilderInternTarget(sb));
         }
 
         private static void AssertNotInternable(char[] ch)
         {
-            AssertNotInternable(new OpportunisticIntern.CharArrayInternTarget(ch, ch.Length));
+            AssertNotInternable(new CharArrayInternTarget(ch, ch.Length));
         }
 
-        private static void AssertNotInternable(string value)
+        protected static void AssertNotInternable(string value)
         {
             AssertNotInternable(new StringBuilder(value));
             AssertNotInternable(value.ToCharArray());
@@ -88,24 +101,6 @@ public void SubArray2()
             Assert.Equal("true", result);
         }
 
-        /// <summary>
-        /// Test a single know-to-intern tiny string to verify the mechanism.
-        /// </summary>
-        [Fact]
-        public void InternableTinyString()
-        {
-            AssertInternable("true");
-        }
-
-        /// <summary>
-        /// Test a single known-to-not-intern tiny string to verify the mechanism.
-        /// </summary>
-        [Fact]
-        public void NonInternableTinyString()
-        {
-            AssertNotInternable("1234");
-        }
-
         /// <summary>
         /// Unique strings should not be interned
         /// </summary>
@@ -173,4 +168,52 @@ public void DoubleDoubleQuotes()
             AssertInternable("");
         }
     }
+
+    /// <summary>
+    /// Tests the new (default) implementation of OpportunisticIntern.
+    /// </summary>
+    public class OpportunisticIntern_Tests : OpportunisticInternTestBase
+    {
+        public OpportunisticIntern_Tests(ITestOutputHelper testOutput)
+            : base(testOutput)
+        {
+            OpportunisticIntern.ResetForTests();
+        }
+    }
+
+    /// <summary>
+    /// Tests the legacy implementation of OpportunisticIntern.
+    /// </summary>
+    public class OpportunisticInternLegacy_Tests : OpportunisticInternTestBase
+    {
+        public OpportunisticInternLegacy_Tests(ITestOutputHelper testOutput)
+            : base(testOutput)
+        {
+            _env.SetEnvironmentVariable("MSBuildUseLegacyStringInterner", "1");
+            OpportunisticIntern.ResetForTests();
+        }
+
+        /// <summary>
+        /// The legacy implementation does not intern tiny strings unless they are on the hard-coded list.
+        /// </summary>
+        [Fact]
+        public void NonInternableTinyString()
+        {
+            AssertNotInternable("1234");
+        }
+    }
+
+    /// <summary>
+    /// Tests the legacy implementation of OpportunisticIntern with simple concurrency enabled.
+    /// </summary>
+    public class OpportunisticInternLegacySimpleConcurrecy_Tests : OpportunisticInternTestBase
+    {
+        public OpportunisticInternLegacySimpleConcurrecy_Tests(ITestOutputHelper testOutput)
+            : base(testOutput)
+        {
+            _env.SetEnvironmentVariable("MSBuildUseLegacyStringInterner", "1");
+            _env.SetEnvironmentVariable("MSBuildUseSimpleInternConcurrency", "1");
+            OpportunisticIntern.ResetForTests();
+        }
+    }
 }
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index 0c8aa4a2da8..6cde0e901df 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -4,7 +4,9 @@
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.UnitTests;
+using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.Engine.UnitTests
 {
@@ -13,6 +15,13 @@ public sealed class WarningsAsMessagesAndErrorsTests
         private const string ExpectedEventMessage = "03767942CDB147B98D0ECDBDE1436DA3";
         private const string ExpectedEventCode = "0BF68998";
 
+        ITestOutputHelper _output;
+
+        public WarningsAsMessagesAndErrorsTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
         [Fact]
         public void TreatAllWarningsAsErrors()
         {
@@ -29,7 +38,7 @@ public void TreatAllWarningsAsErrors()
         [Fact]
         public void TreatWarningsAsErrorsWhenBuildingSameProjectMultipleTimes()
         {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            using (TestEnvironment testEnvironment = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles project2 = testEnvironment.CreateTestProjectWithFiles($@"
                 <Project xmlns=""msbuildnamespace"">
@@ -123,7 +132,7 @@ public void TreatWarningsAsMessagesWhenSpecified()
         [Fact]
         public void TreatWarningsAsMessagesWhenBuildingSameProjectMultipleTimes()
         {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            using (TestEnvironment testEnvironment = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles project2 = testEnvironment.CreateTestProjectWithFiles($@"
                 <Project xmlns=""msbuildnamespace"">
@@ -263,5 +272,111 @@ private string GetTestProject(bool? treatAllWarningsAsErrors = null, string warn
                 </Target>
             </Project>";
         }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.AssertLogContains("MSB4181");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""WarnAndContinue""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+
+                logger.WarningCount.ShouldBe(1);
+
+                logger.AssertLogContains("MSB4181");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""true""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+
+                logger.AssertLogContains("MSB4181");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_ErrorAndStop()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""ErrorAndStop""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.AssertLogContains("MSB4181");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_False()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""false""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.AssertLogContains("MSB4181");
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/WeakStringCache_Tests.cs b/src/Build.UnitTests/WeakStringCache_Tests.cs
new file mode 100644
index 00000000000..ece79899fd0
--- /dev/null
+++ b/src/Build.UnitTests/WeakStringCache_Tests.cs
@@ -0,0 +1,185 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Linq;
+using System.Runtime.CompilerServices;
+using System.Text;
+
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class WeakStringCache_Tests : IDisposable
+    {
+        /// <summary>
+        /// The weak string cache under test.
+        /// </summary>
+        private WeakStringCache _cache = new WeakStringCache();
+
+        public void Dispose()
+        {
+            _cache.Dispose();
+        }
+
+        /// <summary>
+        /// Adds a string to the cache under test.
+        /// </summary>
+        /// <param name="strPart1">Part one of the string (split to prevent runtime interning and unintended GC roots).</param>
+        /// <param name="strPart2">Part two of the string (split to prevent runtime interning and unintended GC roots).</param>
+        /// <param name="callbackToRunWithTheStringAlive">Callback to be invoked after the string has been added but before the strong GC ref is released.</param>
+        /// <returns>The hash code of the string as calculated by WeakStringCache.</returns>
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        private int AddString(string strPart1, string strPart2, Action<string> callbackToRunWithTheStringAlive)
+        {
+            // Compose the string with SB so it doesn't get interned by the runtime.
+            string testString = new StringBuilder(strPart1).Append(strPart2).ToString();
+            StringInternTarget testStringTarget = new StringInternTarget(testString);
+
+            int hashCode = WeakStringCache.GetInternableHashCode(testStringTarget);
+
+            string cachedString = _cache.GetOrCreateEntry(testStringTarget, out bool cacheHit);
+            cacheHit.ShouldBeFalse();
+            cachedString.ShouldBeSameAs(testString);
+
+            callbackToRunWithTheStringAlive(cachedString);
+
+            // Verify that the string is really in the cache and the cache returns the interned instance.
+            string testStringCopy = new StringBuilder(strPart1).Append(strPart2).ToString();
+            cachedString = _cache.GetOrCreateEntry(new StringInternTarget(testStringCopy), out cacheHit);
+            cacheHit.ShouldBeTrue();
+            cachedString.ShouldBeSameAs(testString);
+
+            // Trigger full GC and verify that nothing has changed since we're still keeping testString alive.
+            GC.Collect();
+
+            callbackToRunWithTheStringAlive(cachedString);
+
+            cachedString = _cache.GetOrCreateEntry(new StringInternTarget(testStringCopy), out cacheHit);
+            cacheHit.ShouldBeTrue();
+            cachedString.ShouldBeSameAs(testString);
+
+            return hashCode;
+        }
+
+        /// <summary>
+        /// Adds strings that are known to have a hash code collision to the cache under test.
+        /// </summary>
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        private void AddStringsWithSameHashCode(int numberOfStrings)
+        {
+            string[] cachedStrings = new string[numberOfStrings];
+            int[] hashCodes = new int[numberOfStrings];
+
+            for (int i = 0; i < numberOfStrings; i++)
+            {
+                string strPart2 = "1" + String.Concat(Enumerable.Repeat("4428939786", i));
+                hashCodes[i] = AddString("Random string ", strPart2, (string cachedString) =>
+                {
+                    _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+                    {
+                        LiveStringCount = 1,
+                        CollectedStringCount = 0,
+                    });
+                    cachedStrings[i] = cachedString;
+                });
+
+                if (i > 0)
+                {
+                    // The strings have been carefully constructed to have the same hash code.
+                    hashCodes[i].ShouldBe(hashCodes[i - 1]);
+                }
+            }
+
+            // There are no cache hits when iterating over our strings again because the last one always wins and steals the slot.
+            for (int i = 0; i < numberOfStrings; i++)
+            {
+                StringBuilder sb = new StringBuilder(cachedStrings[i]);
+                string cachedStringFromCache =_cache.GetOrCreateEntry(new StringBuilderInternTarget(sb), out bool cacheHit);
+                cacheHit.ShouldBeFalse();
+                cachedStringFromCache.ShouldNotBeSameAs(cachedStrings[i]);
+            }
+        }
+
+        /// <summary>
+        /// Simple test case to verify that:
+        /// 1. A string added to the cache stays in the cache as long as it's alive.
+        /// 2. The string is no longer retrievable after all strong GC refs are gone.
+        /// 3. The cache completely removes the handle after calling Scavenge on it.
+        /// </summary>
+        /// <remarks>
+        /// Disabled on MacOS Mono because it doesn't play well with conservative GC scanning.
+        /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
+        /// </remarks>
+        [Fact]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "doesn't play well with conservative GC scanning")]
+        public void RetainsStringUntilCollected()
+        {
+            // Add a string to the cache using a non-inlinable method to make sure it's not reachable from a GC root.
+            AddString("Random string ", "test", (string cachedString) =>
+            {
+                _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+                {
+                    LiveStringCount = 1,
+                    CollectedStringCount = 0,
+                });
+            });
+
+            // Trigger full GC.
+            GC.Collect();
+
+            // The handle is still in the cache but it's unused now as the string has been collected.
+            _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+            {
+                LiveStringCount = 0,
+                CollectedStringCount = 1,
+            });
+
+            // Ask the cache to get rid of unused handles.
+            _cache.Scavenge();
+
+            // The cache should be empty now.
+            _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+            {
+                LiveStringCount = 0,
+                CollectedStringCount = 0,
+            });
+        }
+
+        /// <summary>
+        /// Same as RetainsStringUntilCollected but with multiple strings sharing the same hash code.
+        /// </summary>
+        /// <remarks>
+        /// Disabled on MacOS Mono because it doesn't play well with conservative GC scanning.
+        /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
+        /// </remarks>
+        [Fact]
+        [Trait("Category", "mono-osx-failing")]
+        public void RetainsLastStringWithGivenHashCode()
+        {
+            // Add 3 strings with the same hash code.
+            AddStringsWithSameHashCode(3);
+
+            // Trigger full GC.
+            GC.Collect();
+
+            // The handle is still in the cache but it's unused now as the strings have been collected.
+            _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+            {
+                LiveStringCount = 0,
+                CollectedStringCount = 1,
+            });
+
+            // Ask the cache to get rid of unused handles.
+            _cache.Scavenge();
+
+            // The cache should be empty now.
+            _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
+            {
+                LiveStringCount = 0,
+                CollectedStringCount = 0,
+            });
+        }
+    }
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index b2157cf4e07..9f435bb36ba 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -406,7 +406,7 @@ public void BeginBuild(BuildParameters parameters)
 
                 if (BuildParameters.DumpOpportunisticInternStats)
                 {
-                    OpportunisticIntern.EnableStatisticsGathering();
+                    OpportunisticIntern.Instance.EnableStatisticsGathering();
                 }
 
                 _overallBuildSuccess = true;
@@ -824,7 +824,7 @@ public void EndBuild()
 
                     if (BuildParameters.DumpOpportunisticInternStats)
                     {
-                        OpportunisticIntern.ReportStatistics();
+                        OpportunisticIntern.Instance.ReportStatistics();
                     }
                 }
             }
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 090cb82acf9..b86d476910f 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -318,6 +318,12 @@ public bool UseSynchronousLogging
             set => _useSynchronousLogging = value;
         }
 
+
+        /// <summary>
+        /// Indicates whether to emit a default error if a task returns false without logging an error.
+        /// </summary>
+        public bool AllowFailureWithoutError { get; set; } = true;
+
         /// <summary>
         /// Gets the environment variables which were set when this build was created.
         /// </summary>
diff --git a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
index e0e300403cf..1df6a64b42b 100644
--- a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
+++ b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
@@ -44,12 +44,12 @@ private static IDictionary<string, List<string>> CreateItemMetadataDictionary(in
             return new Dictionary<string, List<string>>(capacity, StringComparer.OrdinalIgnoreCase);
         }
 
-        private static void TranslateMetadataForItem(ref List<string> list, ITranslator translator)
+        private static void TranslateMetadataForItem(ITranslator translator, ref List<string> list)
         {
             translator.Translate(ref list);
         }
 
-        private static void TranslateString(ref string s, ITranslator translator)
+        private static void TranslateString(ITranslator translator, ref string s)
         {
             translator.Translate(ref s);
         }
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index b6989894a6b..2645a3feba6 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -348,8 +348,8 @@ public void Translate(ITranslator translator)
         {
             translator.TranslateDictionary(
                 ref _configurations,
-                (ref int configId, ITranslator aTranslator) => aTranslator.Translate(ref configId),
-                (ref BuildRequestConfiguration configuration, ITranslator aTranslator) =>
+                (ITranslator aTranslator, ref int configId) => aTranslator.Translate(ref configId),
+                (ITranslator aTranslator, ref BuildRequestConfiguration configuration) =>
                 {
                     if (translator.Mode == TranslationDirection.WriteToStream)
                     {
@@ -365,8 +365,8 @@ public void Translate(ITranslator translator)
 
             translator.TranslateDictionary(
                 ref _configurationIdsByMetadata,
-                (ref ConfigurationMetadata configMetadata, ITranslator aTranslator) => aTranslator.Translate(ref configMetadata, ConfigurationMetadata.FactoryForDeserialization),
-                (ref int configId, ITranslator aTranslator) => aTranslator.Translate(ref configId),
+                (ITranslator aTranslator, ref ConfigurationMetadata configMetadata) => aTranslator.Translate(ref configMetadata, ConfigurationMetadata.FactoryForDeserialization),
+                (ITranslator aTranslator, ref int configId) => aTranslator.Translate(ref configId),
                 capacity => new Dictionary<ConfigurationMetadata, int>(capacity));
         }
 
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 36e1a24824e..64db389a8ed 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -243,8 +243,8 @@ public void Translate(ITranslator translator)
 
             translator.TranslateDictionary(
                 ref localReference,
-                (ref int i, ITranslator aTranslator) => aTranslator.Translate(ref i),
-                (ref BuildResult result, ITranslator aTranslator) => aTranslator.Translate(ref result),
+                (ITranslator aTranslator, ref int i) => aTranslator.Translate(ref i),
+                (ITranslator aTranslator, ref BuildResult result) => aTranslator.Translate(ref result),
                 capacity => new ConcurrentDictionary<int, BuildResult>(Environment.ProcessorCount, capacity));
 
             if (translator.Mode == TranslationDirection.ReadFromStream)
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 20660afd183..a1b4c7ae411 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -77,7 +77,7 @@ protected override long GetHostHandshake()
         /// </summary>
         protected override long GetClientHandshake()
         {
-            return NodeProviderOutOfProc.GetClientHandshake();
+            return NodeProviderOutOfProc.GetClientHandshake(_enableReuse, _lowPriority);
         }
 
         #region Structs
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index e7048a57870..e94c194e33d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -3,26 +3,18 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
-using System.Text;
-using System.IO;
-using System.IO.Pipes;
 using System.Diagnostics;
-using System.Threading;
-using System.Runtime.InteropServices;
-using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.AccessControl;
 #endif
-using System.Security.Principal;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -80,27 +72,17 @@ public int AvailableNodes
         /// <param name="enableLowPriority">Is the build running at low priority?</param>
         internal static long GetHostHandshake(bool enableNodeReuse, bool enableLowPriority)
         {
-            long baseHandshake = Constants.AssemblyTimestamp;
-
-            baseHandshake = baseHandshake*17 + EnvironmentUtilities.Is64BitProcess.GetHashCode();
-
-            baseHandshake = baseHandshake*17 + enableNodeReuse.GetHashCode();
-
-            baseHandshake = baseHandshake*17 + enableLowPriority.GetHashCode();
-
-            return CommunicationsUtilities.GenerateHostHandshakeFromBase(baseHandshake, GetClientHandshake());
+            CommunicationsUtilities.Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", enableNodeReuse={2}, enableLowPriority={3}", Traits.MSBuildNodeHandshakeSalt, BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, enableNodeReuse, enableLowPriority);
+            return CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
         }
 
         /// <summary>
         /// Magic number sent by the client to the host during the handshake.
         /// Munged version of the host handshake.
         /// </summary>
-        internal static long GetClientHandshake()
+        internal static long GetClientHandshake(bool enableNodeReuse, bool enableLowPriority)
         {
-            // Mask out the first byte. That's because old
-            // builds used a single, non zero initial byte,
-            // and we don't want to risk communicating with them
-            return (Constants.AssemblyTimestamp ^ Int64.MaxValue) & 0x00FFFFFFFFFFFFFF;
+            return CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetHandshakeOptions(false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
         }
 
         /// <summary>
@@ -126,7 +108,7 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
             CommunicationsUtilities.Trace("Starting to acquire a new or existing node to establish node ID {0}...", nodeId);
 
             long hostHandShake = NodeProviderOutOfProc.GetHostHandshake(ComponentHost.BuildParameters.EnableNodeReuse, ComponentHost.BuildParameters.LowPriority);
-            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandShake, NodeProviderOutOfProc.GetClientHandshake(), NodeContextTerminated);
+            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandShake, NodeProviderOutOfProc.GetClientHandshake(ComponentHost.BuildParameters.EnableNodeReuse, ComponentHost.BuildParameters.LowPriority), NodeContextTerminated);
 
             if (null != context)
             {
@@ -188,11 +170,7 @@ public void ShutdownAllNodes()
             // down all the nodes on exit, we will attempt to shutdown
             // all matching nodes with and without the priority bit set.
             // This means we need both versions of the handshake.
-            ShutdownAllNodes(
-                NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: false),
-                NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: true),
-                NodeProviderOutOfProc.GetClientHandshake(),
-                NodeContextTerminated);
+            ShutdownAllNodes(nodeReuse, NodeContextTerminated);
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 898c3f432fe..cc8507b4645 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -106,7 +106,7 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool
         /// <param name="hostHandshakeWithLowPriority">host handshake key with low priority added</param>
         /// <param name="clientHandshake">client handshake key</param>
         /// <param name="terminateNode">Delegate used to tell the node provider that a context has terminated</param>
-        protected void ShutdownAllNodes(long hostHandshake, long hostHandshakeWithLowPriority, long clientHandshake, NodeContextTerminateDelegate terminateNode)
+        protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate terminateNode)
         {
             // INodePacketFactory
             INodePacketFactory factory = new NodePacketFactory();
@@ -126,12 +126,12 @@ protected void ShutdownAllNodes(long hostHandshake, long hostHandshakeWithLowPri
                 int timeout = 30;
 
                 // Attempt to connect to the process with the handshake without low priority.
-                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, hostHandshake, clientHandshake);
+                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHostHandshake(nodeReuse, false), NodeProviderOutOfProc.GetClientHandshake(nodeReuse, false));
 
                 if (null == nodeStream)
                 {
                     // If we couldn't connect attempt to connect to the process with the handshake including low priority.
-                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, hostHandshakeWithLowPriority, clientHandshake);
+                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHostHandshake(nodeReuse, true), NodeProviderOutOfProc.GetClientHandshake(nodeReuse, true));
                 }
 
                 if (null != nodeStream)
@@ -356,7 +356,7 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHand
                 nodeStream.WriteLongForHandshake(hostHandshake);
 
                 CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
                 long handshake = nodeStream.ReadLongForHandshake(timeout);
 #else
                 long handshake = nodeStream.ReadLongForHandshake();
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 2ec94b46b8a..e0aebf0ade8 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -90,7 +90,7 @@ internal class NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase, INodeP
         /// <summary>
         /// A mapping of all the nodes managed by this provider.
         /// </summary>
-        private Dictionary<TaskHostContext, NodeContext> _nodeContexts;
+        private Dictionary<HandshakeOptions, NodeContext> _nodeContexts;
 
         /// <summary>
         /// A mapping of all of the INodePacketFactories wrapped by this provider.
@@ -186,7 +186,7 @@ public void SendData(int nodeId, INodePacket packet)
         /// </summary>
         /// <param name="hostContext">The node to which data shall be sent.</param>
         /// <param name="packet">The packet to send.</param>
-        public void SendData(TaskHostContext hostContext, INodePacket packet)
+        public void SendData(HandshakeOptions hostContext, INodePacket packet)
         {
             ErrorUtilities.VerifyThrow(_nodeContexts.ContainsKey(hostContext), "Invalid host context specified: {0}.", hostContext.ToString());
 
@@ -226,11 +226,7 @@ public void ShutdownAllNodes()
             long hostHandshake = NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: false);
             long hostHandshakeWithLow = NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: true);
 
-            ShutdownAllNodes(
-                hostHandshake,
-                hostHandshakeWithLow,
-                NodeProviderOutOfProc.GetClientHandshake(),
-                NodeContextTerminated);
+            ShutdownAllNodes(nodeReuse, NodeContextTerminated);
         }
         #endregion
 
@@ -243,7 +239,7 @@ public void ShutdownAllNodes()
         public void InitializeComponent(IBuildComponentHost host)
         {
             this.ComponentHost = host;
-            _nodeContexts = new Dictionary<TaskHostContext, NodeContext>();
+            _nodeContexts = new Dictionary<HandshakeOptions, NodeContext>();
             _nodeIdToPacketFactory = new Dictionary<int, INodePacketFactory>();
             _nodeIdToPacketHandler = new Dictionary<int, INodePacketHandler>();
             _activeNodes = new HashSet<int>();
@@ -388,9 +384,13 @@ internal static void ClearCachedTaskHostPaths()
         /// <summary>
         /// Given a TaskHostContext, returns the name of the executable we should be searching for.
         /// </summary>
-        internal static string GetTaskHostNameFromHostContext(TaskHostContext hostContext)
+        internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostContext)
         {
-            if (hostContext == TaskHostContext.X64CLR4 || hostContext == TaskHostContext.X32CLR4)
+            ErrorUtilities.VerifyThrowInternalErrorUnreachable((hostContext & HandshakeOptions.TaskHost) == HandshakeOptions.TaskHost);
+            if ((hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2) {
+                return TaskHostNameForClr2TaskHost;
+            }
+            else
             {
                 if (s_msbuildName == null)
                 {
@@ -404,15 +404,6 @@ internal static string GetTaskHostNameFromHostContext(TaskHostContext hostContex
 
                 return s_msbuildName;
             }
-            else if (hostContext == TaskHostContext.X32CLR2 || hostContext == TaskHostContext.X64CLR2)
-            {
-                return TaskHostNameForClr2TaskHost;
-            }
-            else
-            {
-                ErrorUtilities.ThrowInternalErrorUnreachable();
-                return null;
-            }
         }
 
         /// <summary>
@@ -420,60 +411,59 @@ internal static string GetTaskHostNameFromHostContext(TaskHostContext hostContex
         /// executable (MSBuild or MSBuildTaskHost) that we wish to use, or null
         /// if that location cannot be resolved.
         /// </summary>
-        internal static string GetMSBuildLocationFromHostContext(TaskHostContext hostContext)
+        internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostContext)
         {
             string toolName = GetTaskHostNameFromHostContext(hostContext);
-            string toolPath = null;
+            string toolPath;
 
             s_baseTaskHostPath = BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
             s_baseTaskHostPath64 = BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64;
+            ErrorUtilities.VerifyThrowInternalErrorUnreachable((hostContext & HandshakeOptions.TaskHost) == HandshakeOptions.TaskHost);
 
-            switch (hostContext)
+            if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64 && (hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
             {
-                case TaskHostContext.X32CLR2:
-                    if (s_pathToX32Clr2 == null)
-                    {
-                        s_pathToX32Clr2 = Environment.GetEnvironmentVariable("MSBUILDTASKHOSTLOCATION");
-                        if (s_pathToX32Clr2 == null || !FileUtilities.FileExistsNoThrow(Path.Combine(s_pathToX32Clr2, toolName)))
-                        {
-                            s_pathToX32Clr2 = s_baseTaskHostPath;
-                        }
-                    }
+                if (s_pathToX64Clr2 == null)
+                {
+                    s_pathToX64Clr2 = Environment.GetEnvironmentVariable("MSBUILDTASKHOSTLOCATION64");
 
-                    toolPath = s_pathToX32Clr2;
-                    break;
-                case TaskHostContext.X64CLR2:
-                    if (s_pathToX64Clr2 == null)
+                    if (s_pathToX64Clr2 == null || !FileUtilities.FileExistsNoThrow(Path.Combine(s_pathToX64Clr2, toolName)))
                     {
-                        s_pathToX64Clr2 = Environment.GetEnvironmentVariable("MSBUILDTASKHOSTLOCATION64");
-
-                        if (s_pathToX64Clr2 == null || !FileUtilities.FileExistsNoThrow(Path.Combine(s_pathToX64Clr2, toolName)))
-                        {
-                            s_pathToX64Clr2 = s_baseTaskHostPath64;
-                        }
+                        s_pathToX64Clr2 = s_baseTaskHostPath64;
                     }
+                }
 
-                    toolPath = s_pathToX64Clr2;
-                    break;
-                case TaskHostContext.X32CLR4:
-                    if (s_pathToX32Clr4 == null)
+                toolPath = s_pathToX64Clr2;
+            }
+            else if ((hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
+            {
+                if (s_pathToX32Clr2 == null)
+                {
+                    s_pathToX32Clr2 = Environment.GetEnvironmentVariable("MSBUILDTASKHOSTLOCATION");
+                    if (s_pathToX32Clr2 == null || !FileUtilities.FileExistsNoThrow(Path.Combine(s_pathToX32Clr2, toolName)))
                     {
-                        s_pathToX32Clr4 = s_baseTaskHostPath;
+                        s_pathToX32Clr2 = s_baseTaskHostPath;
                     }
+                }
 
-                    toolPath = s_pathToX32Clr4;
-                    break;
-                case TaskHostContext.X64CLR4:
-                    if (s_pathToX64Clr4 == null)
-                    {
-                        s_pathToX64Clr4 = s_baseTaskHostPath64;
-                    }
+                toolPath = s_pathToX32Clr2;
+            }
+            else if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64)
+            {
+                if (s_pathToX64Clr4 == null)
+                {
+                    s_pathToX64Clr4 = s_baseTaskHostPath64;
+                }
+
+                toolPath = s_pathToX64Clr4;
+            }
+            else
+            {
+                if (s_pathToX32Clr4 == null)
+                {
+                    s_pathToX32Clr4 = s_baseTaskHostPath;
+                }
 
-                    toolPath = s_pathToX64Clr4;
-                    break;
-                default:
-                    ErrorUtilities.ThrowInternalErrorUnreachable();
-                    break;
+                toolPath = s_pathToX32Clr4;
             }
 
             if (toolName != null && toolPath != null)
@@ -487,7 +477,7 @@ internal static string GetMSBuildLocationFromHostContext(TaskHostContext hostCon
         /// <summary>
         /// Make sure a node in the requested context exists.
         /// </summary>
-        internal bool AcquireAndSetUpHost(TaskHostContext hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
+        internal bool AcquireAndSetUpHost(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
             NodeContext context = null;
             bool nodeCreationSucceeded = false;
@@ -519,7 +509,7 @@ internal bool AcquireAndSetUpHost(TaskHostContext hostContext, INodePacketFactor
         /// <summary>
         /// Expected to be called when TaskHostTask is done with host of the given context.
         /// </summary>
-        internal void DisconnectFromHost(TaskHostContext hostContext)
+        internal void DisconnectFromHost(HandshakeOptions hostContext)
         {
             ErrorUtilities.VerifyThrow(_nodeIdToPacketFactory.ContainsKey((int)hostContext) && _nodeIdToPacketHandler.ContainsKey((int)hostContext), "Why are we trying to disconnect from a context that we already disconnected from?  Did we call DisconnectFromHost twice?");
 
@@ -530,7 +520,7 @@ internal void DisconnectFromHost(TaskHostContext hostContext)
         /// <summary>
         /// Instantiates a new MSBuild or MSBuildTaskHost process acting as a child node.
         /// </summary>
-        internal bool CreateNode(TaskHostContext hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
+        internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
             ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
             ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context!  Did we forget to call DisconnectFromHost somewhere?");
@@ -590,7 +580,7 @@ private void NodeContextTerminated(int nodeId)
         {
             lock (_nodeContexts)
             {
-                _nodeContexts.Remove((TaskHostContext)nodeId);
+                _nodeContexts.Remove((HandshakeOptions)nodeId);
             }
 
             // May also be removed by unnatural termination, so don't assume it's there
diff --git a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
index 49f31354b1c..888ba5a557c 100644
--- a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
@@ -65,6 +65,7 @@ internal void LogFatalTaskError(Exception exception, BuildEventFileInfo file, st
         {
             ErrorUtilities.VerifyThrow(IsValid, "must be valid");
             LoggingService.LogFatalTaskError(BuildEventContext, exception, file, taskName);
+            _hasLoggedErrors = true;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 51edfe927d6..2ba4ef2be8c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -28,6 +28,8 @@ internal class LoggingContext
         /// </summary>
         private bool _isValid;
 
+        protected bool _hasLoggedErrors;
+
         /// <summary>
         /// Constructs the logging context from a logging service and an event context.
         /// </summary>
@@ -41,6 +43,7 @@ public LoggingContext(ILoggingService loggingService, BuildEventContext eventCon
             _loggingService = loggingService;
             _eventContext = eventContext;
             _isValid = false;
+            _hasLoggedErrors = false;
         }
 
         /// <summary>
@@ -106,6 +109,8 @@ protected set
             }
         }
 
+        internal bool HasLoggedErrors { get { return _hasLoggedErrors; } set { _hasLoggedErrors = value; } }
+
         /// <summary>
         ///  Helper method to create a message build event from a string resource and some parameters
         /// </summary>
@@ -139,6 +144,7 @@ internal void LogError(BuildEventFileInfo file, string messageResourceName, para
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogError(_eventContext, file, messageResourceName, messageArgs);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -152,6 +158,7 @@ internal void LogErrorWithSubcategory(string subcategoryResourceName, BuildEvent
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogError(_eventContext, subcategoryResourceName, file, messageResourceName, messageArgs);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -166,6 +173,7 @@ internal void LogErrorFromText(string subcategoryResourceName, string errorCode,
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogErrorFromText(_eventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -176,6 +184,7 @@ internal void LogInvalidProjectFileError(InvalidProjectFileException invalidProj
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogInvalidProjectFileError(_eventContext, invalidProjectFileException);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -189,6 +198,7 @@ internal void LogFatalError(Exception exception, BuildEventFileInfo file, string
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogFatalError(_eventContext, exception, file, messageResourceName, messageArgs);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -237,6 +247,7 @@ internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file)
         {
             ErrorUtilities.VerifyThrow(IsValid, "must be valid");
             LoggingService.LogFatalBuildError(BuildEventContext, exception, file);
+            _hasLoggedErrors = true;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 35d669162f1..f528cadbfaf 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -220,7 +220,8 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
                     ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix,
                     child.ItemType,
-                    itemsToAdd);
+                    itemsToAdd,
+                    logItemMetadata: true);
                 LoggingContext.LogCommentFromText(MessageImportance.Low, itemGroupText);
             }
 
@@ -261,7 +262,8 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
                         ItemGroupLoggingHelper.ItemGroupRemoveLogMessage,
                         child.ItemType,
-                        itemsToRemove);
+                        itemsToRemove,
+                        logItemMetadata: true);
                     LoggingContext.LogCommentFromText(MessageImportance.Low, itemGroupText);
                 }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index 848c183ebb4..84eaa27f0e7 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -27,14 +27,6 @@ internal static class ItemGroupLoggingHelper
         /// </summary>
         internal static int parameterLimit = 200;
 
-        /// <summary>
-        /// Gets a text serialized value of a parameter for logging.
-        /// </summary>
-        internal static string GetParameterText(string prefix, string parameterName, params object[] parameterValues)
-        {
-            return GetParameterText(prefix, parameterName, (IList)parameterValues);
-        }
-
         internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString("ItemGroupIncludeLogMessagePrefix");
         internal static string ItemGroupRemoveLogMessage = ResourceUtilities.GetResourceString("ItemGroupRemoveLogMessage");
         internal static string OutputItemParameterMessagePrefix = ResourceUtilities.GetResourceString("OutputItemParameterMessagePrefix");
@@ -43,7 +35,7 @@ internal static string GetParameterText(string prefix, string parameterName, par
         /// <summary>
         /// Gets a text serialized value of a parameter for logging.
         /// </summary>
-        internal static string GetParameterText(string prefix, string parameterName, IList parameterValue)
+        internal static string GetParameterText(string prefix, string parameterName, IList parameterValue, bool logItemMetadata = true)
         {
             if (parameterValue == null || parameterValue.Count == 0)
             {
@@ -94,7 +86,7 @@ internal static string GetParameterText(string prefix, string parameterName, ILi
                         sb.Append("        ");
                     }
 
-                    AppendStringFromParameterValue(sb, parameterValue[i]);
+                    AppendStringFromParameterValue(sb, parameterValue[i], logItemMetadata);
 
                     if (!specialTreatmentForSingle && i < parameterValue.Count - 1)
                     {
@@ -118,7 +110,7 @@ internal static string GetParameterText(string prefix, string parameterName, ILi
         /// First line is already indented.
         /// Indent of any subsequent line should be 12 spaces.
         /// </summary>
-        internal static string GetStringFromParameterValue(object parameterValue)
+        internal static string GetStringFromParameterValue(object parameterValue, bool logItemMetadata = true)
         {
             // fast path for the common case
             if (parameterValue is string valueText)
@@ -128,7 +120,7 @@ internal static string GetStringFromParameterValue(object parameterValue)
 
             using (var sb = new ReuseableStringBuilder())
             {
-                AppendStringFromParameterValue(sb, parameterValue);
+                AppendStringFromParameterValue(sb, parameterValue, logItemMetadata);
                 return sb.ToString();
             }
         }
@@ -138,7 +130,7 @@ internal static string GetStringFromParameterValue(object parameterValue)
         [ThreadStatic]
         private static List<KeyValuePair<string, string>> keyValuePairList;
 
-        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue)
+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue, bool logItemMetadata = true)
         {
             if (parameterValue is string text)
             {
@@ -148,6 +140,11 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob
             {
                 sb.Append(item.ItemSpec);
 
+                if (!logItemMetadata)
+                {
+                    return;
+                }
+
                 var customMetadata = item.CloneCustomMetadata();
                 int count = customMetadata.Count;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 4cca645d906..c34edb8c8e7 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -1081,7 +1081,7 @@ private async Task<BuildResult> BuildProject()
 
             if (MSBuildEventSource.Log.IsEnabled())
             {
-                MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath, allTargets.Aggregate((f, s) => f + ", " + s));
+                MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath, string.Join(", ", allTargets));
             }
 
             return result;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index bd9849a4217..2a9dfd95217 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -324,12 +324,6 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 // Loop through each of the batch buckets and execute them one at a time
                 for (int i = 0; i < buckets.Count; i++)
                 {
-                    // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
-                    if (MSBuildEventSource.Log.IsEnabled())
-                    {
-                        TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
-                        MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-                    }
                     // Execute the batch bucket, pass in which bucket we are executing so that we know when to get a new taskId for the bucket.
                     taskResult = await ExecuteBucket(taskHost, (ItemBucket)buckets[i], mode, lookupHash);
 
@@ -339,12 +333,6 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                     {
                         break;
                     }
-                    // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
-                    if (MSBuildEventSource.Log.IsEnabled())
-                    {
-                        TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
-                        MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-                    }
                 }
 
                 taskResult = aggregateResult;
@@ -400,6 +388,13 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 return taskResult;
             }
 
+            // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
+            if (MSBuildEventSource.Log.IsEnabled())
+            {
+                TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
+            }
+
             // If this is an Intrinsic task, it gets handled in a special fashion.
             if (_taskNode == null)
             {
@@ -507,6 +502,13 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 }
             }
 
+            // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
+            if (MSBuildEventSource.Log.IsEnabled())
+            {
+                TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
+            }
+
             return taskResult;
         }
 
@@ -763,6 +765,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     if (taskType == typeof(MSBuild))
                     {
                         MSBuild msbuildTask = host.TaskInstance as MSBuild;
+
                         ErrorUtilities.VerifyThrow(msbuildTask != null, "Unexpected MSBuild internal task.");
 
                         var undeclaredProjects = GetUndeclaredProjects(msbuildTask);
@@ -940,6 +943,29 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     }
                 }
 
+                // When a task fails it must log an error. If a task fails to do so,
+                // that is logged as an error. MSBuild tasks are an exception because
+                // errors are not logged directly from them, but the tasks spawned by them.
+                IBuildEngine be = host.TaskInstance.BuildEngine;
+                if (taskReturned && !taskResult && !taskLoggingContext.HasLoggedErrors && (be is TaskHost th ? th.BuildRequestsSucceeded : false) && (be is IBuildEngine7 be7 ? be7.AllowFailureWithoutError : true))
+                {
+                    if (_continueOnError == ContinueOnError.WarnAndContinue)
+                    {
+                        taskLoggingContext.LogWarning(null,
+                            new BuildEventFileInfo(_targetChildInstance.Location),
+                            "TaskReturnedFalseButDidNotLogError",
+                            _taskNode.Name);
+
+                        taskLoggingContext.LogComment(MessageImportance.Normal, "ErrorConvertedIntoWarning");
+                    }
+                    else
+                    {
+                        taskLoggingContext.LogError(new BuildEventFileInfo(_targetChildInstance.Location),
+                            "TaskReturnedFalseButDidNotLogError",
+                            _taskNode.Name);
+                    }
+                }
+
                 // If the task returned attempt to gather its outputs.  If gathering outputs fails set the taskResults
                 // to false
                 if (taskReturned)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 884a150edd2..1e591e8ce29 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -38,7 +38,7 @@ internal class TaskHost :
         IBuildEngine7
     {
         /// <summary>
-        /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set. 
+        /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set.
         /// </summary>
         private static bool s_onlyUseOutOfProcNodes = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
 
@@ -132,7 +132,7 @@ public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, Elemen
         /// Returns true in the multiproc case
         /// </summary>
         /// <comment>
-        /// If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.  
+        /// If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.
         /// </comment>
         public bool IsRunningMultipleNodes
         {
@@ -321,7 +321,7 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
         #region IBuildEngine3 Members
 
         /// <summary>
-        /// Builds multiple project files in parallel. 
+        /// Builds multiple project files in parallel.
         /// Thread safe.
         /// </summary>
         /// <param name="projectFileNames">The list of projects to build</param>
@@ -329,7 +329,7 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
         /// <param name="globalProperties">The global properties to use for each project</param>
         /// <param name="undefineProperties">The list of global properties to undefine</param>
         /// <param name="toolsVersion">The tools versions to use</param>
-        /// <param name="returnTargetOutputs">Should the target outputs be returned in teh BuildEngineResult</param>
+        /// <param name="returnTargetOutputs">Should the target outputs be returned in the BuildEngineResult</param>
         /// <returns>A structure containing the result of the build, success or failure and the list of target outputs per project</returns>
         public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs)
         {
@@ -413,8 +413,8 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -423,7 +423,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
 
                 if (_convertErrorsToWarnings)
                 {
-                    // Convert the error into a warning.  We do this because the whole point of 
+                    // Convert the error into a warning.  We do this because the whole point of
                     // ContinueOnError is that a project author expects that the task might fail,
                     // but wants to ignore the failures.  This implies that we shouldn't be logging
                     // errors either, because you should never have a successful build with errors.
@@ -451,6 +451,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                 {
                     e.BuildEventContext = _taskLoggingContext.BuildEventContext;
                     _taskLoggingContext.LoggingService.LogBuildEvent(e);
+                    _taskLoggingContext.HasLoggedErrors = true;
                 }
             }
         }
@@ -483,8 +484,8 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -524,8 +525,8 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -565,8 +566,8 @@ public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -675,6 +676,8 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
 
         #endregion
 
+        #region IBuildEngine7 Members
+
         int runningTotal = 0;
 
         public int RequestCores(int requestedCores)
@@ -719,6 +722,12 @@ internal void ReleaseAllCores()
             runningTotal = 0;
         }
 
+        /// <summary>
+        /// Enables or disables emitting a default error when a task fails without logging errors
+        /// </summary>
+        public bool AllowFailureWithoutError { get; set; } = true;
+        #endregion
+
         /// <summary>
         /// Called by the internal MSBuild task.
         /// Does not take the lock because it is called by another request builder thread.
@@ -768,7 +777,7 @@ public async Task<BuildEngineResult> InternalBuildProjects(string[] projectFileN
 #if FEATURE_APPDOMAIN
         /// <inheritdoc />
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         /// <returns>The lease object to control this object's lifetime.</returns>
@@ -783,7 +792,7 @@ public override object InitializeLifetimeService()
                 ILease lease = (ILease)base.InitializeLifetimeService();
 
                 // Set how long a lease should be initially. Once a lease expires
-                // the remote object will be disconnected and it will be marked as being availiable 
+                // the remote object will be disconnected and it will be marked as being availiable
                 // for garbage collection
                 int initialLeaseTime = 1;
 
@@ -805,7 +814,7 @@ public override object InitializeLifetimeService()
                 // increase the lease time allowing the object to stay in memory
                 _sponsor = new ClientSponsor();
 
-                // When a new lease is requested lets make it last 1 minutes longer. 
+                // When a new lease is requested lets make it last 1 minutes longer.
                 int leaseExtensionTime = 1;
 
                 string leaseExtensionTimeFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDENGINEPROXYLEASEEXTENSIONTIME");
@@ -842,7 +851,7 @@ internal void MarkAsInactive()
                 ReleaseAllCores();
 
                 // Since the task has a pointer to this class it may store it in a static field. Null out
-                // internal data so the leak of this object doesn't lead to a major memory leak.            
+                // internal data so the leak of this object doesn't lead to a major memory leak.
                 _host = null;
                 _requestEntry = null;
 
@@ -892,7 +901,7 @@ internal bool IsEventSerializable(BuildEventArgs e)
         /// <param name="globalProperties">The global properties to use for each project</param>
         /// <param name="undefineProperties">The list of global properties to undefine</param>
         /// <param name="toolsVersion">The tools versions to use</param>
-        /// <param name="returnTargetOutputs">Should the target outputs be returned in teh BuildEngineResult</param>
+        /// <param name="returnTargetOutputs">Should the target outputs be returned in the BuildEngineResult</param>
         /// <param name="skipNonexistentTargets">If set, skip targets that are not defined in the projects to be built.</param>
         /// <returns>A Task returning a structure containing the result of the build, success or failure and the list of target outputs per project</returns>
         private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets = false)
@@ -933,7 +942,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                 }
                 else
                 {
-                    // UNDONE: (Refactor) Investigate making this a ReadOnly collection of some sort.  
+                    // UNDONE: (Refactor) Investigate making this a ReadOnly collection of some sort.
                     PropertyDictionary<ProjectPropertyInstance>[] propertyDictionaries = new PropertyDictionary<ProjectPropertyInstance>[projectFileNames.Length];
 
                     for (int i = 0; i < projectFileNames.Length; i++)
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 096ea1c4d84..37c708c8d14 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -58,6 +58,12 @@ public static IBuildComponent CreateComponent(BuildComponentType type)
             return new MainNodeSdkResolverService();
         }
 
+        //  Test hook
+        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<SdkResolver> resolvers = null)
+        {
+            ((CachingSdkResolverService)_cachedSdkResolver).InitializeForTests(resolverLoader, resolvers);
+        }
+
         /// <inheritdoc cref="ISdkResolverService.ClearCache"/>
         public override void ClearCache(int submissionId)
         {
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 36c1f8d2696..3d1813a7727 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -69,7 +69,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                 key =>
                 {
                     var result = RequestSdkPathFromMainNode(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive);
-                    return new SdkResult(null, result.Path, result.Version, null);
+                    return result;
                 });
 
             if (sdkResult.Version != null && !SdkResolverService.IsReferenceSameVersion(sdk, sdkResult.Version))
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
index 7df27e04020..3ab79ea3fbc 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
@@ -1,8 +1,11 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
+using System;
 using System.Collections.Generic;
-
+using System.Linq;
+using System.Runtime.Versioning;
 using SdkReference = Microsoft.Build.Framework.SdkReference;
 using SdkResultBase = Microsoft.Build.Framework.SdkResult;
 
@@ -13,9 +16,6 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// </summary>
     internal sealed class SdkResult : SdkResultBase, INodePacket
     {
-        private string _path;
-        private string _version;
-
         public SdkResult(ITranslator translator)
         {
             Translate(translator);
@@ -33,30 +33,62 @@ public SdkResult(SdkReference sdkReference, string path, string version, IEnumer
         {
             Success = true;
             SdkReference = sdkReference;
-            _path = path;
-            _version = version;
+            Path = path;
+            Version = version;
             Warnings = warnings;
         }
 
         public SdkResult()
         {
+
         }
 
-        public Construction.ElementLocation ElementLocation { get; set; }
+        public SdkResult(SdkReference sdkReference, IEnumerable<string> paths, string version, IDictionary<string, string> propertiesToAdd,
+                         IDictionary<string, SdkResultItem> itemsToAdd, IEnumerable<string> warnings)
+        {
+            Success = true;
+            SdkReference = sdkReference;
+            if (paths != null)
+            {
+                var firstPath = paths.FirstOrDefault();
+                if (firstPath != null)
+                {
+                    Path = firstPath;
+                }
+                if (paths.Count() > 1)
+                {
+                    AdditionalPaths = paths.Skip(1).ToList();
+                }
+            }
 
-        public IEnumerable<string> Errors { get; }
+            Version = version;
 
-        public override string Path => _path;
+            //  Note: these dictionaries should use StringComparison.OrdinalIgnoreCase
+            PropertiesToAdd = propertiesToAdd;
+            ItemsToAdd = itemsToAdd;
 
-        public override SdkReference SdkReference { get; protected set; }
+            Warnings = warnings;
+        }
 
-        public override string Version => _version;
+        public Construction.ElementLocation ElementLocation { get; set; }
+
+        public IEnumerable<string> Errors { get; }
 
         public IEnumerable<string> Warnings { get; }
         public void Translate(ITranslator translator)
         {
+            translator.Translate(ref _success);
             translator.Translate(ref _path);
             translator.Translate(ref _version);
+
+            translator.Translate(ref _additionalPaths, (ITranslator t, ref string s) => t.Translate(ref s), count => new List<string>(count));
+            translator.TranslateDictionary(ref _propertiesToAdd, count => new Dictionary<string, string>(count, StringComparer.OrdinalIgnoreCase));
+            translator.TranslateDictionary(ref _itemsToAdd,
+                                           keyTranslator: (ITranslator t, ref string s) => t.Translate(ref s),
+                                           valueTranslator: SdkResultTranslationHelpers.Translate,
+                                           dictionaryCreator: count => new Dictionary<string, SdkResultItem>(count, StringComparer.OrdinalIgnoreCase));
+
+            translator.Translate(ref _sdkReference);
         }
 
         public NodePacketType Type => NodePacketType.ResolveSdkResponse;
@@ -65,5 +97,91 @@ public static INodePacket FactoryForDeserialization(ITranslator translator)
         {
             return new SdkResult(translator);
         }
+
+        public override bool Equals(object obj)
+        {
+            if (obj is SdkResult result &&
+                  _success == result._success &&
+                  StringComparer.OrdinalIgnoreCase.Equals(_path, result._path) &&
+                  StringComparer.OrdinalIgnoreCase.Equals(_version, result._version) &&
+                  _additionalPaths?.Count == result._additionalPaths?.Count &&
+                  _propertiesToAdd?.Count == result._propertiesToAdd?.Count &&
+                  _itemsToAdd?.Count == result._propertiesToAdd?.Count &&
+                  EqualityComparer<SdkReference>.Default.Equals(_sdkReference, result._sdkReference))
+            {
+                if (_additionalPaths != null)
+                {
+                    for (int i = 0; i < _additionalPaths.Count; i++)
+                    {
+                        if (!_additionalPaths[i].Equals(result._additionalPaths[i], StringComparison.OrdinalIgnoreCase))
+                        {
+                            return false;
+                        }
+                    }
+                }
+
+                if (_propertiesToAdd != null)
+                {
+                    foreach (var propertyToAdd in _propertiesToAdd)
+                    {
+                        if (result._propertiesToAdd[propertyToAdd.Key] != propertyToAdd.Value)
+                        {
+                            return false;
+                        }
+                    }
+                }
+
+                if (_itemsToAdd != null)
+                {
+                    foreach (var itemToAdd in _itemsToAdd)
+                    {
+                        if (!result._itemsToAdd[itemToAdd.Key].Equals(itemToAdd.Value))
+                        {
+                            return false;
+                        }
+                    }
+                }
+
+                return true;
+            }
+
+
+            return false;
+        }
+
+        public override int GetHashCode()
+        {
+            int hashCode = -1043047289;
+            hashCode = hashCode * -1521134295 + _success.GetHashCode();
+            hashCode = hashCode * -1521134295 + StringComparer.OrdinalIgnoreCase.GetHashCode(_path);
+            hashCode = hashCode * -1521134295 + StringComparer.OrdinalIgnoreCase.GetHashCode(_version);
+            hashCode = hashCode * -1521134295 + EqualityComparer<SdkReference>.Default.GetHashCode(_sdkReference);
+
+            if (_additionalPaths != null)
+            {
+                foreach (var additionalPath in _additionalPaths)
+                {
+                    hashCode = hashCode * -1521134295 + StringComparer.OrdinalIgnoreCase.GetHashCode(additionalPath);
+                }
+            }
+            if (_propertiesToAdd != null)
+            {
+                foreach (var propertyToAdd in _propertiesToAdd)
+                {
+                    hashCode = hashCode * -1521134295 + propertyToAdd.Key.GetHashCode();
+                    hashCode = hashCode * -1521134295 + propertyToAdd.Value.GetHashCode();
+                }
+            }
+            if (_itemsToAdd != null)
+            {
+                foreach (var itemToAdd in _itemsToAdd)
+                {
+                    hashCode = hashCode * -1521134295 + itemToAdd.Key.GetHashCode();
+                    hashCode = hashCode * -1521134295 + itemToAdd.Value.GetHashCode();
+                }
+            }
+
+            return hashCode;
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
index 1cb4360a9e1..7e4f0d898b6 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
@@ -1,6 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using System.Collections.Generic;
 
 using SdkReference = Microsoft.Build.Framework.SdkReference;
@@ -30,5 +31,14 @@ public override SdkResultBase IndicateSuccess(string path, string version, IEnum
         {
             return new SdkResult(_sdkReference, path, version, warnings);
         }
+
+        public override SdkResultBase IndicateSuccess(IEnumerable<string> paths,
+                                                      string version,
+                                                      IDictionary<string, string> propertiesToAdd = null,
+                                                      IDictionary<string, SdkResultItem> itemsToAdd = null,
+                                                      IEnumerable<string> warnings = null)
+        {
+            return new SdkResult(_sdkReference, paths, version, propertiesToAdd, itemsToAdd, warnings);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/TranslationHelpers.cs b/src/Build/BackEnd/Components/SdkResolution/TranslationHelpers.cs
new file mode 100644
index 00000000000..2a518c1b9e2
--- /dev/null
+++ b/src/Build/BackEnd/Components/SdkResolution/TranslationHelpers.cs
@@ -0,0 +1,55 @@
+using Microsoft.Build.Framework;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.BackEnd.SdkResolution
+{
+    static class SdkResultTranslationHelpers
+    {
+        public static void Translate(this ITranslator t, ref SdkReference sdkReference)
+        {
+            string name = null;
+            string version = null;
+            string minimumVersion = null;
+
+            if (t.Mode == TranslationDirection.WriteToStream)
+            {
+                name = sdkReference.Name;
+                version = sdkReference.Version;
+                minimumVersion = sdkReference.MinimumVersion;
+            }
+
+            t.Translate(ref name);
+            t.Translate(ref version);
+            t.Translate(ref minimumVersion);
+
+            if (t.Mode == TranslationDirection.ReadFromStream)
+            {
+                sdkReference = new SdkReference(name, version, minimumVersion);
+            }
+        }
+
+        public static void Translate(this ITranslator t, ref SdkResultItem item)
+        {
+            string itemSpec = null;
+            Dictionary<string, string> metadata = null;
+
+            if (t.Mode == TranslationDirection.WriteToStream)
+            {
+                itemSpec = item.ItemSpec;
+                metadata = item.Metadata;
+            }
+
+            t.Translate(ref itemSpec);
+            t.TranslateDictionary(ref metadata, StringComparer.InvariantCultureIgnoreCase);
+
+            if (t.Mode == TranslationDirection.ReadFromStream)
+            {
+                item = new SdkResultItem(itemSpec, metadata);
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index f53958658e0..d7bddbdc133 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -425,13 +425,7 @@ private void OnEngineException(Exception e)
         /// </summary>
         private NodeEngineShutdownReason HandleShutdown(out Exception exception)
         {
-            if (_debugCommunications)
-            {
-                using (StreamWriter writer = File.CreateText(String.Format(CultureInfo.CurrentCulture, Path.Combine(Path.GetTempPath(), @"MSBuild_NodeShutdown_{0}.txt"), Process.GetCurrentProcess().Id)))
-                {
-                    writer.WriteLine("Node shutting down with reason {0} and exception: {1}", _shutdownReason, _shutdownException);
-                }
-            }
+            CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}.", _shutdownReason, _shutdownException);
 
             // Clean up the engine
             if (null != _buildRequestEngine && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
@@ -515,6 +509,8 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
                 CleanupCaches();
             }
 
+            CommunicationsUtilities.Trace("Shut down complete.");
+
             return _shutdownReason;
         }
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 4fd9e940ac1..81183622bb9 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -427,15 +427,17 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                 // grab the outputs from the task's designated output parameter (which is a .NET property)
                 Type type = parameter.PropertyType;
 
+                EnsureParameterInitialized(parameter, _batchBucket.Lookup);
+
                 if (TaskParameterTypeVerifier.IsAssignableToITask(type))
                 {
                     ITaskItem[] outputs = GetItemOutputs(parameter);
-                    GatherTaskItemOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation);
+                    GatherTaskItemOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation, parameter);
                 }
                 else if (TaskParameterTypeVerifier.IsValueTypeOutputParameter(type))
                 {
                     string[] outputs = GetValueOutputs(parameter);
-                    GatherArrayStringAndValueOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation);
+                    GatherArrayStringAndValueOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation, parameter);
                 }
                 else
                 {
@@ -1042,6 +1044,8 @@ out bool parameterSet
                 {
                     Type parameterType = parameter.PropertyType;
 
+                    EnsureParameterInitialized(parameter, _batchBucket.Lookup);
+
                     // try to set the parameter
                     if (TaskParameterTypeVerifier.IsValidScalarInputParameter(parameterType))
                     {
@@ -1222,6 +1226,29 @@ ex is FormatException || // bad string representation of a type
             return success;
         }
 
+        private void EnsureParameterInitialized(TaskPropertyInfo parameter, Lookup lookup)
+        {
+            if (parameter.Initialized)
+            {
+                return;
+            }
+
+            parameter.Initialized = true;
+
+            string taskAndParameterName = _taskName + "_" + parameter.Name;
+            string key = "DisableLogTaskParameter_" + taskAndParameterName;
+            string metadataKey = "DisableLogTaskParameterItemMetadata_" + taskAndParameterName;
+
+            if (string.Equals(lookup.GetProperty(key)?.EvaluatedValue, "true", StringComparison.OrdinalIgnoreCase))
+            {
+                parameter.Log = false;
+            }
+            else if (string.Equals(lookup.GetProperty(metadataKey)?.EvaluatedValue, "true", StringComparison.OrdinalIgnoreCase))
+            {
+                parameter.LogItemMetadata = false;
+            }
+        }
+
         /// <summary>
         /// Given an instantiated task, this helper method sets the specified vector parameter. Vector parameters can be composed
         /// of multiple item vectors. The semicolon is the only separator allowed, and white space around the semicolon is
@@ -1283,12 +1310,16 @@ out bool taskParameterSet
         /// </remarks>
         private bool InternalSetTaskParameter(TaskPropertyInfo parameter, IList parameterValue)
         {
-            if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && parameterValue.Count > 0)
+            if (LogTaskInputs &&
+                !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents &&
+                parameterValue.Count > 0 &&
+                parameter.Log)
             {
                 string parameterText = ItemGroupLoggingHelper.GetParameterText(
                     ItemGroupLoggingHelper.TaskParameterPrefix,
                     parameter.Name,
-                    parameterValue);
+                    parameterValue,
+                    parameter.LogItemMetadata);
                 _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
             }
 
@@ -1370,7 +1401,7 @@ object parameterValue
         /// <summary>
         /// Gets task item outputs
         /// </summary>
-        private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetName, ITaskItem[] outputs, ElementLocation parameterLocation)
+        private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetName, ITaskItem[] outputs, ElementLocation parameterLocation, TaskPropertyInfo parameter)
         {
             // if the task has generated outputs (if it didn't, don't do anything)
             if (outputs != null)
@@ -1425,12 +1456,13 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                         }
                     }
 
-                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0)
+                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0 && parameter.Log)
                     {
                         string parameterText = ItemGroupLoggingHelper.GetParameterText(
                             ItemGroupLoggingHelper.OutputItemParameterMessagePrefix,
                             outputTargetName,
-                            outputs);
+                            outputs,
+                            parameter.LogItemMetadata);
 
                         _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
                     }
@@ -1483,7 +1515,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
         /// <summary>
         /// Gather task outputs in array form
         /// </summary>
-        private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string outputTargetName, string[] outputs, ElementLocation parameterLocation)
+        private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string outputTargetName, string[] outputs, ElementLocation parameterLocation, TaskPropertyInfo parameter)
         {
             // if the task has generated outputs (if it didn't, don't do anything)            
             if (outputs != null)
@@ -1501,12 +1533,13 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         }
                     }
 
-                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0)
+                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0 && parameter.Log)
                     {
                         string parameterText = ItemGroupLoggingHelper.GetParameterText(
                             ItemGroupLoggingHelper.OutputItemParameterMessagePrefix,
                             outputTargetName,
-                            outputs);
+                            outputs,
+                            parameter.LogItemMetadata);
                         _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
                     }
                 }
diff --git a/src/Build/Construction/ProjectImportElement.cs b/src/Build/Construction/ProjectImportElement.cs
index 676677dd9a8..0260a1eae46 100644
--- a/src/Build/Construction/ProjectImportElement.cs
+++ b/src/Build/Construction/ProjectImportElement.cs
@@ -6,8 +6,6 @@
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -36,7 +34,7 @@ internal ProjectImportElement(XmlElementWithLocation xmlElement, ProjectElementC
             : base(xmlElement, parent, containingProject)
         {
             ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
-            ParsedSdkReference = sdkReference;
+            SdkReference = sdkReference;
         }
 
         /// <summary>
@@ -75,12 +73,10 @@ public string Sdk
             set
             {
                 ErrorUtilities.VerifyThrowArgumentLength(value, XMakeAttributes.sdk);
-                // TODO: here and other setters. Confirm that CheckUpdatedSdk() ussage is
-                //       really the intended one. Currently it does check for equality  before updating the attribute
-                //       so setter will only take effect if "ParsedSdkReference" is not updated. Currently it might work by accident
-                //       if all "Set" calls are different and no ParsedSdkReference is triggered in between.
-                if (!CheckUpdatedSdk()) return;
-                SetOrRemoveAttribute(XMakeAttributes.sdk, value, "Set Import Sdk {0}", value);
+                if (UpdateSdkReference(name: value, SdkReference?.Version, SdkReference?.MinimumVersion))
+                {
+                    SetOrRemoveAttribute(XMakeAttributes.sdk, value, "Set Import Sdk {0}", value);
+                }
             }
         }
 
@@ -92,8 +88,10 @@ public string Version
             get => GetAttributeValue(XMakeAttributes.sdkVersion);
             set
             {
-                if (!CheckUpdatedSdk()) return;
-                SetOrRemoveAttribute(XMakeAttributes.sdkVersion, value, "Set Import Version {0}", value);
+                if (UpdateSdkReference(SdkReference?.Name, version: value, SdkReference?.MinimumVersion))
+                {
+                    SetOrRemoveAttribute(XMakeAttributes.sdkVersion, value, "Set Import Version {0}", value);
+                }
             }
         }
 
@@ -105,8 +103,10 @@ public string MinimumVersion
             get => GetAttributeValue(XMakeAttributes.sdkMinimumVersion);
             set
             {
-                if (!CheckUpdatedSdk()) return;
-                SetOrRemoveAttribute(XMakeAttributes.sdkMinimumVersion, value, "Set Import Minimum Version {0}", value);
+                if (UpdateSdkReference(SdkReference?.Name, SdkReference?.Version, minimumVersion: value))
+                {
+                    SetOrRemoveAttribute(XMakeAttributes.sdkMinimumVersion, value, "Set Import Minimum Version {0}", value);
+                }
             }
         }
 
@@ -130,9 +130,9 @@ public string MinimumVersion
 
 
         /// <summary>
-        /// <see cref="SdkReference"/> if applicable to this import element.
+        /// <see cref="Framework.SdkReference"/> if applicable to this import element.
         /// </summary>
-        internal SdkReference ParsedSdkReference { get; set; }
+        internal SdkReference SdkReference { get; set; }
 
         /// <summary>
         /// Creates an unparented ProjectImportElement, wrapping an unparented XmlElement.
@@ -162,7 +162,7 @@ internal static ProjectImportElement CreateImplicit(
                 Project = project,
                 Sdk = sdkReference.ToString(),
                 ImplicitImportLocation = implicitImportLocation,
-                ParsedSdkReference = sdkReference,
+                SdkReference = sdkReference,
                 OriginalElement = originalElement
             };
         }
@@ -183,23 +183,20 @@ protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         }
 
         /// <summary>
-        /// Helper method to extract attribute values and update the ParsedSdkReference property if
-        /// necessary (update only when changed).
+        /// Helper method to update the <see cref="SdkReference" /> property if necessary (update only when changed).
         /// </summary>
-        /// <returns>True if the ParsedSdkReference was updated, otherwise false (no update necessary).</returns>
-        private bool CheckUpdatedSdk()
+        /// <returns>True if the <see cref="SdkReference" /> property was updated, otherwise false (no update necessary).</returns>
+        private bool UpdateSdkReference(string name, string version, string minimumVersion)
         {
-            var sdk = new SdkReference(
-                GetAttributeValue(XMakeAttributes.sdk, true),
-                GetAttributeValue(XMakeAttributes.sdkVersion, true),
-                GetAttributeValue(XMakeAttributes.sdkMinimumVersion, true));
+            SdkReference sdk = new SdkReference(name, version, minimumVersion);
 
-            if (sdk.Equals(ParsedSdkReference))
+            if (sdk.Equals(SdkReference))
             {
                 return false;
             }
 
-            ParsedSdkReference = sdk;
+            SdkReference = sdk;
+
             return true;
         }
     }
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 840be8683f2..b43999f8a97 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -8,6 +8,7 @@
 using System.Text;
 using System.Globalization;
 using System.Security;
+using System.Text.Json;
 using System.Text.RegularExpressions;
 
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
@@ -17,6 +18,8 @@
 using ResourceUtilities = Microsoft.Build.Shared.ResourceUtilities;
 using ExceptionUtilities = Microsoft.Build.Shared.ExceptionHandling;
 using System.Collections.ObjectModel;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Construction
 {
@@ -85,6 +88,7 @@ public sealed class SolutionFile
         #endregion
         #region Member data
         private string _solutionFile;                 // Could be absolute or relative path to the .SLN file.
+        private HashSet<string> _solutionFilter;     // The project files to include in loading the solution.
         private bool _parsingForConversionOnly;      // Are we parsing this solution to get project reference data during
                                                      // conversion, or in preparation for actually building the solution?
 
@@ -195,7 +199,15 @@ internal string FullPath
             {
                 // Should already be canonicalized to a full path
                 ErrorUtilities.VerifyThrowInternalRooted(value);
-                _solutionFile = value;
+                if (FileUtilities.IsSolutionFilterFilename(value))
+                {
+                    ParseSolutionFilter(value);
+                }
+                else
+                {
+                    _solutionFile = value;
+                    _solutionFilter = null;
+                }
             }
         }
 
@@ -218,6 +230,11 @@ internal string FullPath
 
         #region Methods
 
+        internal bool ProjectShouldBuild(string projectFile)
+        {
+            return _solutionFilter == null || _solutionFilter.Contains(projectFile);
+        }
+
         /// <summary>
         /// This method takes a path to a solution file, parses the projects and project dependencies
         /// in the solution file, and creates internal data structures representing the projects within
@@ -286,9 +303,8 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
 
                         if (!System.Version.TryParse(fileVersionFromHeader, out Version version))
                         {
-                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                            ProjectFileErrorUtilities.ThrowInvalidProjectFile
                                 (
-                                    false /* just throw the exception */,
                                     "SubCategoryForSolutionParsingErrors",
                                     new BuildEventFileInfo(solutionFile),
                                     "SolutionParseVersionMismatchError",
@@ -334,15 +350,52 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
             }
 
             // Didn't find the header in lines 1-4, so the solution file is invalid.
-            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+            ProjectFileErrorUtilities.ThrowInvalidProjectFile
                 (
-                    false /* just throw the exception */,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(solutionFile),
                     "SolutionParseNoHeaderError"
                  );
         }
 
+        private void ParseSolutionFilter(string solutionFilterFile)
+        {
+            try
+            {
+                using JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile));
+                JsonElement solution = text.RootElement.GetProperty("solution");
+                _solutionFile = Path.GetFullPath(solution.GetProperty("path").GetString());
+                if (!FileSystems.Default.FileExists(_solutionFile))
+                {
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile
+                    (
+                        "SubCategoryForSolutionParsingErrors",
+                        new BuildEventFileInfo(_solutionFile),
+                        "SolutionFilterMissingSolutionError",
+                        solutionFilterFile,
+                        _solutionFile
+                    );
+                }
+                _solutionFilter = new HashSet<string>(NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
+                foreach (JsonElement project in solution.GetProperty("projects").EnumerateArray())
+                {
+                    _solutionFilter.Add(project.GetString());
+                }
+            }
+            catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
+            {
+                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                (
+                    false, /* Just throw the exception */
+                    "SubCategoryForSolutionParsingErrors",
+                    new BuildEventFileInfo(solutionFilterFile),
+                    e,
+                    "SolutionFilterJsonParsingError",
+                    solutionFilterFile
+                );
+            }
+        }
+
         /// <summary>
         /// Adds a configuration to this solution
         /// </summary>
@@ -461,6 +514,30 @@ internal void ParseSolution()
                 }
             }
 
+            if (_solutionFilter != null)
+            {
+                HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
+                foreach (ProjectInSolution project in _projectsInOrder)
+                {
+                    projectPaths.Add(project.RelativePath);
+                }
+                foreach (string project in _solutionFilter)
+                {
+                    if (!projectPaths.Contains(project))
+                    {
+                        ProjectFileErrorUtilities.ThrowInvalidProjectFile
+                        (
+                            "SubCategoryForSolutionParsingErrors",
+                            new BuildEventFileInfo(project),
+                            "SolutionFilterFilterContainsProjectNotInSolution",
+                            _solutionFilter,
+                            project,
+                            _solutionFile
+                        );
+                    }
+                }
+            }
+
             if (rawProjectConfigurationsEntries != null)
             {
                 ProcessProjectConfigurationSection(rawProjectConfigurationsEntries);
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 5edc192921f..b1f32e3a5d0 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -637,6 +637,12 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionFile so
         /// </summary>
         private static bool WouldProjectBuild(SolutionFile solutionFile, string selectedSolutionConfiguration, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration)
         {
+            // If the solution filter does not contain this project, do not build it.
+            if (!solutionFile.ProjectShouldBuild(project.RelativePath))
+            {
+                return false;
+            }
+
             if (projectConfiguration == null)
             {
                 if (project.ProjectType == SolutionProjectType.WebProject)
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 9004c89b90f..15c91a6f68e 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -139,7 +139,14 @@ public override void Load(XmlReader reader)
         {
             if (reader.BaseURI.Length > 0)
             {
-                DetermineWhetherToLoadReadOnly(new Uri(reader.BaseURI).LocalPath);
+                string adjustedLocalPath = null;
+
+                if (Uri.TryCreate(reader.BaseURI, UriKind.RelativeOrAbsolute, out Uri uri))
+                {
+                    adjustedLocalPath = uri.LocalPath;
+                }
+
+                DetermineWhetherToLoadReadOnly(adjustedLocalPath);
             }
 
             // Set the line info source if it is available given the specific implementation of XmlReader
@@ -340,7 +347,7 @@ private void DetermineWhetherToLoadReadOnly(string fullPath)
                 {
                     _loadAsReadOnly = true;
                 }
-                else if (s_readOnlyFlags == ReadOnlyLoadFlags.LoadReadOnlyIfAppropriate)
+                else if (s_readOnlyFlags == ReadOnlyLoadFlags.LoadReadOnlyIfAppropriate && fullPath is object)
                 {
                     // Only files from Microsoft
                     if (Path.GetFileName(fullPath).StartsWith("Microsoft.", StringComparison.OrdinalIgnoreCase))
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 8e90acfa61d..449d9e4f3c2 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1776,7 +1776,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
 
             string project = importElement.Project;
 
-            if (importElement.ParsedSdkReference != null)
+            if (importElement.SdkReference != null)
             {
                 // Try to get the path to the solution and project being built. The solution path is not directly known
                 // in MSBuild. It is passed in as a property either by the VS project system or by MSBuild's solution
@@ -1788,7 +1788,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                 var projectPath = _data.GetProperty(ReservedPropertyNames.projectFullPath)?.EvaluatedValue;
 
                 // Combine SDK path with the "project" relative path
-                sdkResult = _sdkResolverService.ResolveSdk(_submissionId, importElement.ParsedSdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive);
+                sdkResult = _sdkResolverService.ResolveSdk(_submissionId, importElement.SdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive);
 
                 if (!sdkResult.Success)
                 {
@@ -1798,7 +1798,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                             importElement.Location.Line,
                             importElement.Location.Column,
                             ResourceUtilities.GetResourceString("CouldNotResolveSdk"),
-                            importElement.ParsedSdkReference.ToString())
+                            importElement.SdkReference.ToString())
                         {
                             BuildEventContext = _evaluationLoggingContext.BuildEventContext,
                             UnexpandedProject = importElement.Project,
@@ -1814,14 +1814,135 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                         return;
                     }
 
-                    ProjectErrorUtilities.ThrowInvalidProject(importElement.SdkLocation, "CouldNotResolveSdk", importElement.ParsedSdkReference.ToString());
+                    ProjectErrorUtilities.ThrowInvalidProject(importElement.SdkLocation, "CouldNotResolveSdk", importElement.SdkReference.ToString());
                 }
 
-                project = Path.Combine(sdkResult.Path, project);
+                if (sdkResult.Path == null)
+                {
+                    projects = new List<ProjectRootElement>();
+                }
+                else
+                {
+                    ExpandAndLoadImportsFromUnescapedImportExpression(directoryOfImportingFile, importElement, Path.Combine(sdkResult.Path, project),
+                        throwOnFileNotExistsError, out projects);
+
+                    if (sdkResult.AdditionalPaths != null)
+                    {
+                        foreach (var additionalPath in sdkResult.AdditionalPaths)
+                        {
+                            ExpandAndLoadImportsFromUnescapedImportExpression(directoryOfImportingFile, importElement, Path.Combine(additionalPath, project),
+                                throwOnFileNotExistsError, out var additionalProjects);
+
+                            projects.AddRange(additionalProjects);
+                        }
+                    }
+                }
+
+                if ((sdkResult.PropertiesToAdd != null && sdkResult.PropertiesToAdd.Any()) ||
+                    (sdkResult.ItemsToAdd != null && sdkResult.ItemsToAdd.Any()))
+                {
+                    //  Inserting at the beginning will mean that the properties or items from the SdkResult will be evaluated before
+                    //  any projects from paths returned by the SDK Resolver.
+                    projects.Insert(0, CreateProjectForSdkResult(sdkResult));
+                }
+            }
+            else
+            {
+                ExpandAndLoadImportsFromUnescapedImportExpression(directoryOfImportingFile, importElement, project,
+                    throwOnFileNotExistsError, out projects);
+            }
+        }
+
+        //  Creates a project to set the properties and include the items from an SdkResult
+        private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
+        {
+            int propertiesAndItemsHash;
+
+#if NETCOREAPP
+            HashCode hash = new HashCode();
+#else
+            propertiesAndItemsHash = -849885975;
+#endif
+
+            if (sdkResult.PropertiesToAdd != null)
+            {
+                foreach (var property in sdkResult.PropertiesToAdd)
+                {
+#if NETCOREAPP
+                    hash.Add(property.Key);
+                    hash.Add(property.Value);
+#else
+                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + property.Key.GetHashCode();
+                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + property.Value.GetHashCode();
+#endif
+                }
+            }
+            if (sdkResult.ItemsToAdd != null)
+            {
+                foreach (var item in sdkResult.ItemsToAdd)
+                {
+#if NETCOREAPP
+                    hash.Add(item.Key);
+                    hash.Add(item.Value);
+#else
+                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + item.Key.GetHashCode();
+                    propertiesAndItemsHash = propertiesAndItemsHash * -1521134295 + item.Value.GetHashCode();
+#endif
+
+                }
+            }
+
+#if NETCOREAPP
+            propertiesAndItemsHash = hash.ToHashCode();
+#endif
+
+            //  Generate a unique filename for the generated project for each unique set of properties and items.
+            string projectPath = _projectRootElement.FullPath + ".SdkResolver." + propertiesAndItemsHash + ".proj";
+
+            ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
+            {
+                ProjectRootElement project = ProjectRootElement.Create();
+                project.FullPath = projectPath;
+
+                if (sdkResult.PropertiesToAdd != null && sdkResult.PropertiesToAdd.Any())
+                {
+                    var propertyGroup = project.AddPropertyGroup();
+                    foreach (var propertyNameAndValue in sdkResult.PropertiesToAdd)
+                    {
+                        propertyGroup.AddProperty(propertyNameAndValue.Key, EscapingUtilities.Escape(propertyNameAndValue.Value));
+                    }
+                }
+
+                if (sdkResult.ItemsToAdd != null && sdkResult.ItemsToAdd.Any())
+                {
+                    var itemGroup = project.AddItemGroup();
+                    foreach (var item in sdkResult.ItemsToAdd)
+                    {
+                        Dictionary<string, string> escapedMetadata = null;
+
+                        if (item.Value.Metadata != null)
+                        {
+                            escapedMetadata = new Dictionary<string, string>(item.Value.Metadata.Count, StringComparer.OrdinalIgnoreCase);
+                            foreach (var metadata in item.Value.Metadata)
+                            {
+                                escapedMetadata[metadata.Key] = EscapingUtilities.Escape(metadata.Value);
+                            }
+                        }
+
+                        itemGroup.AddItem(item.Key, EscapingUtilities.Escape(item.Value.ItemSpec), escapedMetadata);
+                    }
+                }
+
+                _projectRootElementCache.AddEntry(project);
+
+                return project;
             }
 
-            ExpandAndLoadImportsFromUnescapedImportExpression(directoryOfImportingFile, importElement, project,
-                throwOnFileNotExistsError, out projects);
+            return _projectRootElementCache.Get(
+                projectPath,
+                InnerCreate,
+                _projectRootElement.IsExplicitlyLoaded,
+                preserveFormatting: null);
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index c066300ffe8..d9eb06311f0 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -3341,7 +3341,10 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     // need to locate an appropriate constructor and invoke it
                     if (String.Equals("new", _methodMethodName, StringComparison.OrdinalIgnoreCase))
                     {
-                        functionResult = LateBindExecute(null /* no previous exception */, BindingFlags.Public | BindingFlags.Instance, null /* no instance for a constructor */, args, true /* is constructor */);
+                        if (!TryExecuteWellKnownConstructorNoThrow(out functionResult, args))
+                        {
+                            functionResult = LateBindExecute(null /* no previous exception */, BindingFlags.Public | BindingFlags.Instance, null /* no instance for a constructor */, args, true /* is constructor */);
+                        }
                     }
                     else
                     {
@@ -3534,6 +3537,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             return true;
                         }
                     }
+                    else if (string.Equals(_methodMethodName, nameof(string.IndexOf), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (TryGetArgs(args, out string arg0, out StringComparison arg1))
+                        {
+                            returnVal = text.IndexOf(arg0, arg1);
+                            return true;
+                        }
+                    }
                     else if (string.Equals(_methodMethodName, nameof(string.IndexOfAny), StringComparison.OrdinalIgnoreCase))
                     {
                         if (TryGetArg(args, out string arg0))
@@ -3554,20 +3565,10 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             returnVal = text.LastIndexOf(arg0, startIndex);
                             return true;
                         }
-                        else if (TryGetArgs(args, out arg0, out string arg1))
+                        else if (TryGetArgs(args, out arg0, out StringComparison arg1))
                         {
-                            string comparisonType = arg1;
-
-                            // Allow fully-qualified enum, e.g. "System.StringComparison.OrdinalIgnoreCase"
-                            if (comparisonType.Contains("."))
-                            {
-                                comparisonType = arg1.Replace("System.StringComparison.", "").Replace("StringComparison.", "");
-                            }
-                            if (Enum.TryParse<StringComparison>(comparisonType, out StringComparison comparison))
-                            {
-                                returnVal = text.LastIndexOf(arg0, comparison);
-                                return true;
-                            }
+                            returnVal = text.LastIndexOf(arg0, arg1);
+                            return true;
                         }
                     }
                     else if (string.Equals(_methodMethodName, nameof(string.Length), StringComparison.OrdinalIgnoreCase))
@@ -3913,6 +3914,30 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetFrameworkIdentifier), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetFrameworkIdentifier(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetFrameworkVersion), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsTargetFrameworkCompatible), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out string arg0, out string arg1))
+                            {
+                                returnVal = IntrinsicFunctions.IsTargetFrameworkCompatible(arg0, arg1);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Path))
                     {
@@ -4043,6 +4068,33 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                 return false;
             }
 
+            /// <summary>
+            /// Shortcut to avoid calling into binding if we recognize some most common constructors.
+            /// Analogous to TryExecuteWellKnownFunction but guaranteed to not throw.
+            /// </summary>
+            /// <param name="returnVal">The instance as created by the constructor call.</param>
+            /// <param name="args">Arguments.</param>
+            /// <returns>True if the well known constructor call binding was successful.</returns>
+            private bool TryExecuteWellKnownConstructorNoThrow(out object returnVal, object[] args)
+            {
+                returnVal = null;
+
+                if (_receiverType == typeof(string))
+                {
+                    if (args.Length == 0)
+                    {
+                        returnVal = String.Empty;
+                        return true;
+                    }
+                    if (TryGetArg(args, out string arg0))
+                    {
+                        returnVal = arg0;
+                        return true;
+                    }
+                }
+                return false;
+            }
+
             private bool ElementsOfType(object[] args, Type type)
             {
                 for (var i = 0; i < args.Length; i++)
@@ -4212,6 +4264,34 @@ private static bool TryGetArg(object[] args, out string arg0)
                 return arg0 != null;
             }
 
+            private static bool TryGetArgs(object[] args, out string arg0, out StringComparison arg1)
+            {
+                if (args.Length != 2)
+                {
+                    arg0 = null;
+                    arg1 = default;
+
+                    return false;
+                }
+
+                arg0 = args[0] as string;
+
+                // reject enums as ints. In C# this would require a cast, which is not supported in msbuild expressions
+                if (arg0 == null || !(args[1] is string comparisonTypeName) || int.TryParse(comparisonTypeName, out _))
+                {
+                    arg1 = default;
+                    return false;
+                }
+
+                // Allow fully-qualified enum, e.g. "System.StringComparison.OrdinalIgnoreCase"
+                if (comparisonTypeName.Contains('.'))
+                {
+                    comparisonTypeName = comparisonTypeName.Replace("System.StringComparison.", "").Replace("StringComparison.", "");
+                }
+
+                return Enum.TryParse(comparisonTypeName, out arg1);
+            }
+
             private static bool TryGetArgs(object[] args, out int arg0, out int arg1)
             {
                 arg0 = 0;
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index e532306e5c2..55f9e185226 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Text.RegularExpressions;
 
@@ -32,6 +30,8 @@ internal static class IntrinsicFunctions
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
 #endif // FEATURE_WIN32_REGISTRY
 
+        private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => new NuGetFrameworkWrapper());
+
         /// <summary>
         /// Add two doubles
         /// </summary>
@@ -379,7 +379,7 @@ internal static bool DoesTaskHostExist(string runtime, string architecture)
             parameters.Add(XMakeAttributes.runtime, runtime);
             parameters.Add(XMakeAttributes.architecture, architecture);
 
-            TaskHostContext desiredContext = CommunicationsUtilities.GetTaskHostContext(parameters);
+            HandshakeOptions desiredContext = CommunicationsUtilities.GetHandshakeOptions(taskHost: true, taskHostParameters: parameters);
             string taskHostLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(desiredContext);
 
             if (taskHostLocation != null && FileUtilities.FileExistsNoThrow(taskHostLocation))
@@ -480,6 +480,21 @@ internal static bool VersionLessThanOrEquals(string a, string b)
             return SimpleVersion.Parse(a) <= SimpleVersion.Parse(b);
         }
 
+        internal static string GetTargetFrameworkIdentifier(string tfm)
+        {
+            return NuGetFramework.Value.GetTargetFrameworkIdentifier(tfm);
+        }
+
+        internal static string GetTargetFrameworkVersion(string tfm)
+        {
+            return NuGetFramework.Value.GetTargetFrameworkVersion(tfm);
+        }
+
+        internal static bool IsTargetFrameworkCompatible(string target, string candidate)
+        {
+            return NuGetFramework.Value.IsCompatible(target, candidate);
+        }
+
         public static string GetCurrentToolsDirectory()
         {
             return BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index cdd16bf54e6..89f99c08aee 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -100,7 +100,7 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                         string[] includeSplitFilesEscaped;
                         if (MSBuildEventSource.Log.IsEnabled())
                         {
-                            MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, excludePatternsForGlobs.ToList().Aggregate((f, s) => f + ", " + s));
+                            MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
                         }
                         using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
                         {
@@ -112,7 +112,7 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                         }
                         if (MSBuildEventSource.Log.IsEnabled())
                         {
-                            MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, excludePatternsForGlobs.ToList().Aggregate((f, s) => f + ", " + s));
+                            MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
                         }
 
                         foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 45866736036..21bdd300107 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -323,6 +323,27 @@ protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElem
 
                 return needToExpandMetadataForEachItem;
             }
+
+            protected static bool ItemspecContainsASingleItemReference(ItemSpec<P, I> itemSpec, string referencedItemType)
+            {
+                if (itemSpec.Fragments.Count != 1)
+                {
+                    return false;
+                }
+
+                var itemExpressionFragment = itemSpec.Fragments[0] as ItemSpec<P, I>.ItemExpressionFragment;
+                if (itemExpressionFragment == null)
+                {
+                    return false;
+                }
+
+                if (!itemExpressionFragment.Capture.ItemType.Equals(referencedItemType, StringComparison.OrdinalIgnoreCase))
+                {
+                    return false;
+                }
+
+                return true;
+            }
         }
     }
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index fdd5b3e312d..fe2dcf43a85 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -23,9 +23,14 @@ public RemoveOperation(RemoveOperationBuilder builder, LazyItemEvaluator<P, I, M
                 _matchOnMetadataOptions = builder.MatchOnMetadataOptions;
             }
 
-            // todo port the self referencing matching optimization (e.g. <I Remove="@(I)">) from Update to Remove as well. Ideally make one mechanism for both. https://github.com/Microsoft/msbuild/issues/2314
-            // todo Perf: do not match against the globs: https://github.com/Microsoft/msbuild/issues/2329
-            protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+            /// <summary>
+            /// Apply the Remove operation.
+            /// </summary>
+            /// <remarks>
+            /// This operation is mostly implemented in terms of the default <see cref="LazyItemOperation.ApplyImpl(ImmutableList{ItemData}.Builder, ImmutableHashSet{string})"/>.
+            /// This override exists to apply the removing-everything short-circuit.
+            /// </remarks>
+            protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
                 var matchOnMetadataValid = !_matchOnMetadata.IsEmpty && _itemSpec.Fragments.Count == 1
                     && _itemSpec.Fragments.First() is ItemSpec<ProjectProperty, ProjectItem>.ItemExpressionFragment;
@@ -34,6 +39,20 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                     new BuildEventFileInfo(string.Empty),
                     "OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
 
+                if (_matchOnMetadata.IsEmpty && ItemspecContainsASingleItemReference(_itemSpec, _itemElement.ItemType))
+                {
+                    // Perf optimization: If the Remove operation references itself (e.g. <I Remove="@(I)"/>)
+                    // then all items are removed and matching is not necessary
+                    listBuilder.Clear();
+                    return;
+                }
+
+                base.ApplyImpl(listBuilder, globsToIgnore);
+            }
+
+            // todo Perf: do not match against the globs: https://github.com/Microsoft/msbuild/issues/2329
+            protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+            {
                 var items = ImmutableHashSet.CreateBuilder<I>();
                 foreach (ItemData item in listBuilder)
                 {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index 24b3d9a375b..025f247cfec 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -134,27 +134,6 @@ private static bool ItemSpecContainsItemReferences(ItemSpec<P, I> itemSpec)
             {
                 return itemSpec.Fragments.Any(f => f is ItemSpec<P,I>.ItemExpressionFragment);
             }
-
-            private static bool ItemspecContainsASingleItemReference(ItemSpec<P, I> itemSpec, string referencedItemType)
-            {
-                if (itemSpec.Fragments.Count != 1)
-                {
-                    return false;
-                }
-
-                var itemExpressionFragment = itemSpec.Fragments[0] as ItemSpec<P,I>.ItemExpressionFragment;
-                if (itemExpressionFragment == null)
-                {
-                    return false;
-                }
-
-                if (!itemExpressionFragment.Capture.ItemType.Equals(referencedItemType, StringComparison.OrdinalIgnoreCase))
-                {
-                    return false;
-                }
-
-                return true;
-            }
         }
     }
 }
diff --git a/src/Build/Evaluation/SemiColonTokenizer.cs b/src/Build/Evaluation/SemiColonTokenizer.cs
index ceac85a143e..3d3c0791baa 100644
--- a/src/Build/Evaluation/SemiColonTokenizer.cs
+++ b/src/Build/Evaluation/SemiColonTokenizer.cs
@@ -145,7 +145,7 @@ private string GetExpressionSubstring(int startIndex, int length)
                 }
                 if (startIndex < endIndex)
                 {
-                    var target = new OpportunisticIntern.SubstringInternTarget(_expression, startIndex, endIndex - startIndex);
+                    var target = new SubstringInternTarget(_expression, startIndex, endIndex - startIndex);
                     return OpportunisticIntern.InternableToString(target);
                 }
                 return null;
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 0fb077ab7e9..546fcc45a68 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -78,6 +78,7 @@ public void BuildGraph()
             {
                 return;
             }
+
             var allParsedProjects = FindGraphNodes();
             
             AddEdges(allParsedProjects);
@@ -110,28 +111,78 @@ private static IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyColl
         private void AddEdges(Dictionary<ConfigurationMetadata, ParsedProject> allParsedProjects)
         {
             Edges = new GraphEdges();
-            AddEdgesFromProjectFileReferences(allParsedProjects, Edges);
-            _projectInterpretation.PostProcess(allParsedProjects, this);
+
+            AddEdgesFromProjectReferenceItems(allParsedProjects, Edges);
+
+            _projectInterpretation.ReparentInnerBuilds(allParsedProjects, this);
+
             if (_solutionDependencies != null && _solutionDependencies.Count != 0)
             {
                 AddEdgesFromSolution(allParsedProjects, _solutionDependencies, Edges);
             }
         }
 
-        private static void AddEdgesFromProjectFileReferences(Dictionary<ConfigurationMetadata, ParsedProject> allParsedProjects, GraphEdges edges)
+        private void AddEdgesFromProjectReferenceItems(Dictionary<ConfigurationMetadata, ParsedProject> allParsedProjects, GraphEdges edges)
         {
+            var transitiveReferenceCache = new Dictionary<ProjectGraphNode, HashSet<ProjectGraphNode>>(allParsedProjects.Count);
+
             foreach (var parsedProject in allParsedProjects)
             {
+                var currentNode = parsedProject.Value.GraphNode;
+
+                var requiresTransitiveProjectReferences = _projectInterpretation.RequiresTransitiveProjectReferences(currentNode.ProjectInstance);
+
                 foreach (var referenceInfo in parsedProject.Value.ReferenceInfos)
                 {
-                    ErrorUtilities.VerifyThrow(
-                        allParsedProjects.ContainsKey(referenceInfo.ReferenceConfiguration),
-                        "all references should have been parsed");
-
-                    parsedProject.Value.GraphNode.AddProjectReference(
+                    // Always add direct references.
+                    currentNode.AddProjectReference(
                         allParsedProjects[referenceInfo.ReferenceConfiguration].GraphNode,
                         referenceInfo.ProjectReferenceItem,
                         edges);
+
+                    // Add transitive references only if the project requires it.
+                    if (requiresTransitiveProjectReferences)
+                    {
+                        foreach (var transitiveProjectReference in GetTransitiveProjectReferencesExcludingSelf(allParsedProjects[referenceInfo.ReferenceConfiguration]))
+                        {
+                            currentNode.AddProjectReference(
+                                transitiveProjectReference,
+                                new ProjectItemInstance(
+                                    project: currentNode.ProjectInstance,
+                                    itemType: ProjectInterpretation.TransitiveReferenceItemName,
+                                    includeEscaped: referenceInfo.ReferenceConfiguration.ProjectFullPath,
+                                    directMetadata: null,
+                                    definingFileEscaped: currentNode.ProjectInstance.FullPath
+                                ),
+                                edges);
+                        }
+                    }
+                }
+            }
+
+            HashSet<ProjectGraphNode> GetTransitiveProjectReferencesExcludingSelf(ParsedProject parsedProject)
+            {
+                if (transitiveReferenceCache.TryGetValue(parsedProject.GraphNode, out HashSet<ProjectGraphNode> cachedTransitiveReferences))
+                {
+                    return cachedTransitiveReferences;
+                }
+                else
+                {
+                    var transitiveReferences = new HashSet<ProjectGraphNode>();
+
+                    foreach (var referenceInfo in parsedProject.ReferenceInfos)
+                    {
+                        transitiveReferences.Add(allParsedProjects[referenceInfo.ReferenceConfiguration].GraphNode);
+
+                        foreach (var transitiveReference in GetTransitiveProjectReferencesExcludingSelf(allParsedProjects[referenceInfo.ReferenceConfiguration]))
+                        {
+                            transitiveReferences.Add(transitiveReference);
+                        }
+                    }
+
+                    transitiveReferenceCache.Add(parsedProject.GraphNode, transitiveReferences);
+
+                    return transitiveReferences;
                 }
             }
         }
@@ -582,6 +633,9 @@ public void RemoveEdge((ProjectGraphNode node, ProjectGraphNode reference) key)
                 ReferenceItems.TryRemove(key, out _);
             }
 
+            internal bool HasEdge((ProjectGraphNode node, ProjectGraphNode reference) key) => ReferenceItems.ContainsKey(key);
+            internal bool TryGetEdge((ProjectGraphNode node, ProjectGraphNode reference) key, out ProjectItemInstance edge) => ReferenceItems.TryGetValue(key, out edge);
+
             internal IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> TestOnly_AsConfigurationMetadata()
             {
                 return ReferenceItems.ToImmutableDictionary(
@@ -589,8 +643,6 @@ public void RemoveEdge((ProjectGraphNode node, ProjectGraphNode reference) key)
                     kvp => kvp.Value
                     );
             }
-
-            internal bool TestOnly_HasEdge((ProjectGraphNode node, ProjectGraphNode reference) key) => ReferenceItems.ContainsKey(key);
         }
 
         private enum NodeVisitationState
diff --git a/src/Build/Graph/ProjectGraphNode.cs b/src/Build/Graph/ProjectGraphNode.cs
index 24772ceadf3..0a2280a1758 100644
--- a/src/Build/Graph/ProjectGraphNode.cs
+++ b/src/Build/Graph/ProjectGraphNode.cs
@@ -58,6 +58,14 @@ internal void AddProjectReference(ProjectGraphNode reference, ProjectItemInstanc
             edges[(this, reference)] = projectReferenceItem;
         }
 
+        internal void RemoveReference(ProjectGraphNode reference, GraphBuilder.GraphEdges edges)
+        {
+            _projectReferences.Remove(reference);
+            reference._referencingProjects.Remove(reference);
+
+            edges.RemoveEdge((this, reference));
+        }
+
         internal void RemoveReferences(GraphBuilder.GraphEdges edges)
         {
             foreach (var reference in _projectReferences)
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 298f4ea4721..cd9b85686e5 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -24,7 +24,9 @@ internal sealed class ProjectInterpretation
         private const string SetTargetFrameworkMetadataName = "SetTargetFramework";
         private const string GlobalPropertiesToRemoveMetadataName = "GlobalPropertiesToRemove";
         private const string ProjectReferenceTargetIsOuterBuildMetadataName = "OuterBuild";
-        internal const string InnerBuildReferenceItemName = "_ProjectSelfReference";
+        private const string InnerBuildReferenceItemName = "_ProjectSelfReference";
+        internal static string TransitiveReferenceItemName = "_TransitiveProjectReference";
+        internal const string AddTransitiveProjectReferencesInStaticGraphPropertyName = "AddTransitiveProjectReferencesInStaticGraph";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
@@ -132,10 +134,10 @@ internal static ProjectType GetProjectType(ProjectInstance project)
         /// However, at build time, for non root outer builds, the inner builds are NOT referenced by the outer build, but by the nodes referencing the
         /// outer build. Change the graph to mimic this behaviour.
         /// Examples
-        /// OuterAsRoot -> Inner stays the same
-        /// Node -> Outer -> Inner goes to: Node -> Outer; Node->Inner; Outer -> empty
+        /// OuterAsRoot -> Inner go to OuterAsRoot -> Inner. Inner builds remain the same, parented to their outer build
+        /// Node -> Outer -> Inner go to: Node -> Outer; Node->Inner; Outer -> empty. Inner builds get reparented to Node
         /// </summary>
-        public void PostProcess(Dictionary<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder)
+        public void ReparentInnerBuilds(Dictionary<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder)
         {
             foreach (var node in allNodes)
             {
@@ -153,6 +155,20 @@ public void PostProcess(Dictionary<ConfigurationMetadata, ParsedProject> allNode
                             // targets to call on the references.
                             var newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
 
+                            if (outerBuildReferencingProject.ProjectReferences.Contains(innerBuild))
+                            {
+                                graphBuilder.Edges.TryGetEdge((outerBuildReferencingProject, innerBuild), out var existingEdge);
+
+                                ErrorUtilities.VerifyThrow(
+                                    graphBuilder.Edges[(outerBuildReferencingProject, innerBuild)]
+                                        .ItemType.Equals(
+                                            TransitiveReferenceItemName,
+                                            StringComparison.OrdinalIgnoreCase),
+                                    "Only transitive references may reference inner builds that got generated by outer builds");
+
+                                outerBuildReferencingProject.RemoveReference(innerBuild, graphBuilder.Edges);
+                            }
+
                             outerBuildReferencingProject.AddProjectReference(innerBuild, newInnerBuildEdge, graphBuilder.Edges);
                         }
                     }
@@ -173,11 +189,11 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
             foreach (var globalPropertyValue in ExpressionShredder.SplitSemiColonSeparatedList(globalPropertyValues))
             {
                 yield return new ProjectItemInstance(
-                    outerBuild,
-                    InnerBuildReferenceItemName,
-                    outerBuild.FullPath,
-                    new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")},
-                    outerBuild.FullPath);
+                    project: outerBuild,
+                    itemType: InnerBuildReferenceItemName,
+                    includeEscaped: outerBuild.FullPath,
+                    directMetadata: new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")},
+                    definingFileEscaped: outerBuild.FullPath);
             }
         }
 
@@ -386,7 +402,7 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj
                         {
                             var targetsMetadataValue = projectReferenceTarget.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
 
-                            var targetsAreForOuterBuild = projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName).Equals("true", StringComparison.OrdinalIgnoreCase);
+                            var targetsAreForOuterBuild = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName));
 
                             var targets = ExpressionShredder.SplitSemiColonSeparatedList(targetsMetadataValue).ToArray();
 
@@ -420,5 +436,31 @@ public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance re
                 }
             }
         }
+
+        public bool RequiresTransitiveProjectReferences(ProjectInstance projectInstance)
+        {
+            // Outer builds do not get edges based on ProjectReference or their transitive closure, only inner builds do.
+            if (GetProjectType(projectInstance) == ProjectType.OuterBuild)
+            {
+                return false;
+            }
+
+            // special case for Quickbuild which updates msbuild binaries independent of props/targets. Remove this when all QB repos will have
+            // migrated to new enough Visual Studio versions whose Microsoft.Managed.After.Targets enable transitive references.
+            if (string.IsNullOrWhiteSpace(projectInstance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName)) &&
+                MSBuildStringIsTrue(projectInstance.GetPropertyValue("UsingMicrosoftNETSdk")) &&
+                MSBuildStringIsFalse(projectInstance.GetPropertyValue("DisableTransitiveProjectReferences")))
+            {
+                return true;
+            }
+
+            return MSBuildStringIsTrue(
+                projectInstance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName));
+        }
+
+        private static bool MSBuildStringIsTrue(string msbuildString) =>
+            ConversionUtilities.ConvertStringToBool(msbuildString, nullOrWhitespaceIsFalse: true);
+
+        private static bool MSBuildStringIsFalse(string msbuildString) => !MSBuildStringIsTrue(msbuildString);
     }
 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index ac9d3200de3..17b0520b4f3 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -10,6 +10,7 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.CompilerServices;
+using System.Text.Json;
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
@@ -2045,13 +2046,13 @@ private void TranslateTargets(ITranslator translator)
         }
 
         // todo move to nested function after c#7
-        private static void TranslatorForTargetSpecificDictionaryKey(ref string key, ITranslator translator)
+        private static void TranslatorForTargetSpecificDictionaryKey(ITranslator translator, ref string key)
         {
             translator.Translate(ref key);
         }
 
         // todo move to nested function after c#7
-        private static void TranslatorForTargetSpecificDictionaryValue(ref List<TargetSpecification> value, ITranslator translator)
+        private static void TranslatorForTargetSpecificDictionaryValue(ITranslator translator, ref List<TargetSpecification> value)
         {
             translator.Translate(ref value, TargetSpecification.FactoryForDeserialization);
         }
@@ -2142,9 +2143,29 @@ internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, Prope
             // we should be generating a 4.0+ or a 3.5-style wrapper project based on the version of the solution. 
             else
             {
-                int solutionVersion;
-                int visualStudioVersion;
-                SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(projectFile, out solutionVersion, out visualStudioVersion);
+                string solutionFile = projectFile;
+                if (FileUtilities.IsSolutionFilterFilename(projectFile))
+                {
+                    try
+                    {
+                        using JsonDocument text = JsonDocument.Parse(File.ReadAllText(projectFile));
+                        JsonElement solution = text.RootElement.GetProperty("solution");
+                        solutionFile = Path.GetFullPath(solution.GetProperty("path").GetString());
+                    }
+                    catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
+                    {
+                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                        (
+                            false, /* Just throw the exception */
+                            "SubCategoryForSolutionParsingErrors",
+                            new BuildEventFileInfo(projectFile),
+                            e,
+                            "SolutionFilterJsonParsingError",
+                            projectFile
+                        );
+                    }
+                }
+                SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFile, out int solutionVersion, out int visualStudioVersion);
 
                 // If we get to this point, it's because it's a valid version.  Map the solution version 
                 // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old 
@@ -2172,7 +2193,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, Prope
 
                     string toolsVersionToUse = Utilities.GenerateToolsVersionToUse(
                         explicitToolsVersion: null,
-                        toolsVersionFromProject: toolsVersion,
+                        toolsVersionFromProject: FileUtilities.IsSolutionFilterFilename(projectFile) ? "Current" : toolsVersion,
                         getToolset: buildParameters.GetToolset,
                         defaultToolsVersion: Constants.defaultSolutionWrapperProjectToolsVersion,
                         usingDifferentToolsVersionFromProjectFile: out _);
diff --git a/src/Build/Instance/ProjectTaskInstance.cs b/src/Build/Instance/ProjectTaskInstance.cs
index 3c5a256de29..98b42dc76ce 100644
--- a/src/Build/Instance/ProjectTaskInstance.cs
+++ b/src/Build/Instance/ProjectTaskInstance.cs
@@ -390,12 +390,12 @@ void ITranslatable.Translate(ITranslator translator)
             }
         }
 
-        private static void ParametersKeyTranslator(ref string key, ITranslator translator)
+        private static void ParametersKeyTranslator(ITranslator translator, ref string key)
         {
             translator.Translate(ref key);
         }
 
-        private static void ParametersValueTranslator(ref (string, ElementLocation) value, ITranslator translator)
+        private static void ParametersValueTranslator(ITranslator translator, ref (string, ElementLocation) value)
         {
             if (translator.Mode == TranslationDirection.WriteToStream)
             {
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index ead6986c715..072b94052e9 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -89,7 +89,7 @@ internal class TaskHostTask : IGeneratedTask, ICancelableTask, INodePacketFactor
         /// The task host context of the task host we're launching -- used to 
         /// communicate with the task host. 
         /// </summary>
-        private TaskHostContext _requiredContext = TaskHostContext.Invalid;
+        private HandshakeOptions _requiredContext = HandshakeOptions.None;
 
         /// <summary>
         /// True if currently connected to the task host; false otherwise. 
@@ -281,7 +281,7 @@ public bool Execute()
             {
                 lock (_taskHostLock)
                 {
-                    _requiredContext = CommunicationsUtilities.GetTaskHostContext(_taskHostParameters);
+                    _requiredContext = CommunicationsUtilities.GetHandshakeOptions(taskHost: true, taskHostParameters: _taskHostParameters);
                     _connectedToTaskHost = _taskHostProvider.AcquireAndSetUpHost(_requiredContext, this, this, hostConfiguration);
                 }
 
@@ -549,30 +549,12 @@ private void HandleLoggedMessage(LogMessagePacket logMessagePacket)
         /// Since we log that we weren't able to connect to the task host in a couple of different places,
         /// extract it out into a separate method. 
         /// </summary>
-        private void LogErrorUnableToCreateTaskHost(TaskHostContext requiredContext, string runtime, string architecture, NodeFailedToLaunchException e)
+        private void LogErrorUnableToCreateTaskHost(HandshakeOptions requiredContext, string runtime, string architecture, NodeFailedToLaunchException e)
         {
-            string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext);
-
-            if (msbuildLocation == null)
-            {
+            string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext) ??
                 // We don't know the path -- probably we're trying to get a 64-bit assembly on a 
                 // 32-bit machine.  At least give them the exe name to look for, though ...
-                switch (requiredContext)
-                {
-                    case TaskHostContext.X32CLR2:
-                    case TaskHostContext.X64CLR2:
-                        msbuildLocation = "MSBuildTaskHost.exe";
-                        break;
-                    case TaskHostContext.X32CLR4:
-                    case TaskHostContext.X64CLR4:
-                        msbuildLocation = "MSBuild.exe";
-                        break;
-                    case TaskHostContext.Invalid:
-                    default:
-                        ErrorUtilities.ThrowInternalErrorUnreachable();
-                        break;
-                }
-            }
+                ((requiredContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2 ? "MSBuildTaskHost.exe" : "MSBuild.exe");
 
             if (e == null)
             {
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 7a83bd9f59b..3d261b4cf46 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -1707,13 +1707,13 @@ public void Translate(ITranslator translator)
                 }
 
                 // todo move to nested function after C# 7
-                private static void TranslatorForTaskParametersKey(ref string key, ITranslator translator)
+                private static void TranslatorForTaskParametersKey(ITranslator translator, ref string key)
                 {
                     translator.Translate(ref key);
                 }
 
                 // todo move to nested function after C# 7
-                private static void TranslatorForTaskParameterValue(ref TaskPropertyInfo taskPropertyInfo, ITranslator translator)
+                private static void TranslatorForTaskParameterValue(ITranslator translator, ref TaskPropertyInfo taskPropertyInfo)
                 {
                     string name = null;
                     string propertyTypeName = null;
@@ -1783,13 +1783,13 @@ public void Translate(ITranslator translator)
         }
 
         //todo make nested after C# 7
-        void TranslateTaskRegistrationKey(ref RegisteredTaskIdentity taskIdentity, ITranslator translator)
+        void TranslateTaskRegistrationKey(ITranslator translator, ref RegisteredTaskIdentity taskIdentity)
         {
             translator.Translate(ref taskIdentity);
         }
 
         //todo make nested after C# 7
-        void TranslateTaskRegistrationValue(ref List<RegisteredTaskRecord> taskRecords, ITranslator translator)
+        void TranslateTaskRegistrationValue(ITranslator translator, ref List<RegisteredTaskRecord> taskRecords)
         {
             translator.Translate(ref taskRecords, RegisteredTaskRecord.FactoryForDeserialization);
         }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 4b5a55262d5..a80444cecbc 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -34,6 +34,7 @@
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
     <PackageReference Include="System.Memory" />
+    <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
   </ItemGroup>
@@ -137,6 +138,7 @@
     </Compile>
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\TaskParameterTypeVerifier.cs" />
+    <Compile Include="..\Shared\TranslatorHelpers.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
@@ -155,6 +157,8 @@
     <Compile Include="BackEnd\Components\Caching\ConfigCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ResourceManager\ResourceManagerService.cs" />
+    <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
+    <Compile Include="Utilities\NuGetFrameworkWrapper.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskParameterElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ExternalProjectsProvider.cs" />
     <Compile Include="ObjectModelRemoting\LinkedObjectFactory.cs" />
@@ -352,6 +356,9 @@
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="Collections\ConvertingEnumerable.cs" />
     <Compile Include="Collections\CopyOnReadEnumerable.cs" />
+    <Compile Include="..\Shared\IInternable.cs" />
+    <Compile Include="..\Shared\WeakStringCache.cs" />
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
     <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
       <Link>Collections\CopyOnWriteDictionary.cs</Link>
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index 5cd809d1166..6f2353241c9 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -135,11 +135,6 @@ internal static class Constants
         /// </summary>
         internal const string Dev10SubToolsetValue = "10.0";
 
-        /// <summary>
-        /// Number representing the current assembly's timestamp
-        /// </summary>
-        internal static long assemblyTimestamp;
-
         /// <summary>
         /// Current version of this MSBuild Engine assembly in the 
         /// form, e.g, "4.0"
@@ -152,29 +147,6 @@ internal static string AssemblyVersion
             }
         }
 
-
-        /// <summary>
-        /// Number representing the current assembly's timestamp
-        /// </summary>
-        internal static long AssemblyTimestamp
-        {
-            get
-            {
-                if (assemblyTimestamp == 0)
-                {
-                    // Get the file version from the currently executing assembly.
-                    // Use .CodeBase instead of .Location, because .Location doesn't
-                    // work when Microsoft.Build.dll has been shadow-copied, for example
-                    // in scenarios where NUnit is loading Microsoft.Build.
-                    string path = FileUtilities.ExecutingAssemblyPath;
-
-                    assemblyTimestamp = new FileInfo(path).LastWriteTime.Ticks;
-                }
-
-                return assemblyTimestamp;
-            }
-        }
-
         // Name of the environment variable that always points to 32-bit program files.
         internal const string programFilesx86 = "ProgramFiles(x86)";
 
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 4b0fe42ac90..846868e1a22 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1101,9 +1101,9 @@
       LOCALIZATION: "{2}" is a localized message from a CLR/FX exception. Also, Microsoft.Build.Framework should not be localized
     </comment>
   </data>
-  <data name="TaskReturnedFalseButDidNotLogError" xml:space="preserve">
-    <value>MSB4132: The "{0}" task returned false but did not log an error.</value>
-    <comment>{StrBegin="MSB4132: "}</comment>
+  <data name="TaskReturnedFalseButDidNotLogError">
+    <value>MSB4181: The "{0}" task returned false but did not log an error.</value>
+    <comment>{StrBegin="MSB4181: "}</comment>
   </data>
   <data name="LoggerCreationError" xml:space="preserve">
     <value>MSB1021: Cannot create an instance of the logger. {0}</value>
@@ -1661,6 +1661,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>MSB4231: ProjectRootElement can't reload if it contains unsaved changes.</value>
     <comment>{StrBegin="MSB4231: "}</comment>
   </data>
+  <data name="LogTaskInputs.Truncated">
+    <value>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</value>
+  </data>
   <data name="MetaprojectGenerated" xml:space="preserve">
     <value>Metaproject "{0}" generated.</value>
   </data>
@@ -1822,4 +1825,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="PropertyAssignment" xml:space="preserve">
     <value>Property initial value: $({0})="{1}" Source: {2}</value>
   </data>
+  <data name="NuGetAssemblyNotFound" xml:space="preserve">
+    <value>A required NuGet assembly was not found. Expected Path: {0}</value>
+  </data>
 </root>
\ No newline at end of file
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 262a0f64993..245e60f730e 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Od tohoto msta dle jsou parametry zkrcen. Pokud si chcete zobrazit vechny parametry, vymate promnnou prosted MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Metaprojekt {0} byl vygenerovn.</target>
@@ -117,6 +122,11 @@
         <target state="translated">Operaci nelze dokonit, protoe funkce BeginBuild jet nebyla zavolna.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Uivatelem zadan zptn voln ProjectInstanceFactoryFunc vrtilo odkaz null. To nen ppustn.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: loha {0} vrtila false, ale do protokolu se nezaznamenala chyba.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 64073a3496c..ec4322d75e3 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Die Parameter wurden ber diesen Punkt hinaus abgeschnitten. Um alle Parameter anzuzeigen, lschen Sie die Umgebungsvariable MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Das Metaprojekt "{0}" wurde generiert.</target>
@@ -117,6 +122,11 @@
         <target state="translated">Der Vorgang kann nicht abgeschlossen werden, da BeginBuild noch nicht aufgerufen wurde.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Ein benutzerseitig angegebener ProjectInstanceFactoryFunc-Rckruf hat einen NULL-Verweis zurckgegeben. Dies ist nicht zulssig.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: Die Aufgabe "{0}" hat FALSE zurckgegeben, jedoch keinen Fehler protokolliert.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index 1891ae50769..ca1dd2da57a 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="new">The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="new">Metaproject "{0}" generated.</target>
@@ -117,6 +122,11 @@
         <target state="new">The operation cannot be completed because BeginBuild has not yet been called.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="new">MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4181: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 6211b592508..2c081aa56d0 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Los parmetros se han truncado a partir de este punto. Para ver todos los parmetros, borre la variable de entorno MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Se gener el metaproyecto "{0}".</target>
@@ -117,6 +122,11 @@
         <target state="translated">La operacin no se puede completar porque todava no se llam a BeginBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Se devolvi una referencia nula de una devolucin de llamada de ProjectInstanceFactoryFunc proporcionada por el usuario, y no se permite.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: La tarea "{0}" devolvi false, pero no registr un error.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 10c3dc7f551..16a7024cede 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Les paramtres ont t tronqus au-del de ce point. Pour voir tous les paramtres, dsactivez la variable d'environnement MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Le mtaprojet "{0}" a t gnr.</target>
@@ -117,6 +122,11 @@
         <target state="translated">Impossible d'effectuer l'opration car la mthode BeginBuild n'a pas encore t appele.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Une rfrence null a t retourne  partir d'un rappel ProjectInstanceFactoryFunc fourni par l'utilisateur. Ceci n'est pas autoris.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: la tche "{0}" a retourn false mais n'a pas journalis d'erreur.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 30f528b6661..7cf9c7da35c 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">I parametri oltre questo punto sono stati troncati. Per visualizzare tutti i parametri, cancellare la variabile di ambiente MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Il metaprogetto "{0}"  stato generato.</target>
@@ -117,6 +122,11 @@
         <target state="translated">Non  possibile completare l'operazione perch BeginBuild non  stato ancora chiamato.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253:  stato restituito un riferimento Null da un callback ProjectInstanceFactoryFunc fornito dall'utente. Questa operazione non  consentita.</target>
@@ -200,13 +210,13 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: l'attivit "{0}" ha restituito false, ma non  stato registrato alcun errore.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: il task MSBuild compila progetti "{0}" che non sono specificati nell'elemento ProjectReference. Nelle compilazioni isolate questa condizione indica probabilmente che i riferimenti non sono specificati in modo esplicito come elemento ProjectReference in "{1}"</target>
+        <target state="translated">MSB4254: l'attivit MSBuild compila progetti "{0}" che non sono specificati nell'elemento ProjectReference. Nelle compilazioni isolate questa condizione indica probabilmente che i riferimenti non sono specificati in modo esplicito come elemento ProjectReference in "{1}"</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 50fc9bd8263..269832f4806 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">MSBUILDTRUNCATETASKINPUTLOGGING </target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated"> "{0}" </target>
@@ -117,6 +122,11 @@
         <target state="translated">BeginBuild </target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253:  ProjectInstanceFactoryFunc  null </target>
@@ -200,13 +210,13 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: "{0}"  false </target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: ProjectReference  "{0}"  MSBuild task  "{1}"  ProjectReference </target>
+        <target state="translated">MSB4254: ProjectReference  "{0}"  MSBuild  "{1}"  ProjectReference </target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index f3d92995264..d969c555020 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">     .     MSBUILDTRUNCATETASKINPUTLOGGING   .</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated"> "{0}"() .</target>
@@ -117,6 +122,11 @@
         <target state="translated">BeginBuild       .</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253:   ProjectInstanceFactoryFunc  Null  .   .</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: "{0}"  false    .</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b9c95988257..01ed823e267 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Parametry zostay obcite za tym punktem. Aby wywietli wszystkie parametry, wyczy zmienn rodowiskow MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Wygenerowano metaprojekt {0}.</target>
@@ -117,6 +122,11 @@
         <target state="translated">Nie mona zakoczy operacji, poniewa metoda BeginBuild nie zostaa jeszcze wywoana.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Z podanego przez uytkownika wywoania zwrotnego ProjectInstanceFactoryFunc zostaa zwrcona pusta referencja. Jest to niedozwolone.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: Zadanie {0} zwrcio warto false, ale nie zarejestrowao bdu.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index f857a832d90..1ebadba8527 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Os parmetros foram truncados alm deste ponto. Para exibir todos os parmetros, limpe a varivel de ambiente MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">Metaprojeto "{0}" gerado.</target>
@@ -117,6 +122,11 @@
         <target state="translated">A operao no pode ser concluda porque BeginBuild ainda no foi chamado.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Uma referncia nula foi devolvida de um retorno de chamada do ProjectInstanceFactoryFunc fornecido pelo usurio. Isso no  permitido.</target>
@@ -200,13 +210,13 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: a tarefa "{0}" retornou false, mas no registrou um erro.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: a task MSBuild est criando projetos "{0}" que no esto especificados no item ProjectReference. Nos builds isolados isso provavelmente significa que as referncias no esto explicitamente especificadas como um item ProjectReference em "{1}"</target>
+        <target state="translated">MSB4254: a tarefa MSBuild est criando projetos "{0}" que no esto especificados no item ProjectReference. Nos builds isolados, isso provavelmente significa que as referncias no esto explicitamente especificadas como um item ProjectReference em "{1}"</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 2ae481c61d9..0e8728ed6ca 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">   .    ,    MSBUILDTRUNCATETASKINPUTLOGGING.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">  "{0}".</target>
@@ -117,6 +122,11 @@
         <target state="translated">   ,       BeginBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253:    NULL       ProjectInstanceFactoryFunc.  .</target>
@@ -200,13 +210,13 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181:  "{0}"   false,    .</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254:  MSBuild  () {0},      ProjectReference.      ,        ProjectReference  "{1}".</target>
+        <target state="translated">MSB4254:  MSBuild  () {0}, ()  ()   ProjectReference.      ,        ProjectReference  "{1}".</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 248b8565c6f..19de9e7a29a 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated">Parametreler bu noktann tesinde ksaltld. Tm parametreleri grntlemek iin MSBUILDTRUNCATETASKINPUTLOGGING ortam deikenini temizleyin.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">"{0}" meta projesi oluturuldu.</target>
@@ -117,6 +122,11 @@
         <target state="translated">BeginBuild henz arlmad iin ilem tamamlanamyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253: Kullanc tarafndan salanan bir ProjectInstanceFactoryFunc geri aramasnda null bavuru var. Buna izin verilmez.</target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: "{0}" grevi false deerini dndrd ancak gnle hata kaydetmedi.</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index fd1afbf8728..3b1f23c2414 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated"> MSBUILDTRUNCATETASKINPUTLOGGING </target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated">{0}</target>
@@ -117,6 +122,11 @@
         <target state="translated"> BeginBuild</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253:  ProjectInstanceFactoryFunc </target>
@@ -200,13 +210,13 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: {0} false</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: MSBuild  ProjectReference {0}{1} ProjectReference </target>
+        <target state="translated">MSB4254: MSBuild task  ProjectReference {0}{1} ProjectReference </target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 6c6f3879ab2..b8349400ff0 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -107,6 +107,11 @@
       LOCALIZATION: {0} is an enum value of LoggerVerbosity.
     </note>
       </trans-unit>
+      <trans-unit id="LogTaskInputs.Truncated">
+        <source>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</source>
+        <target state="translated"> MSBUILDTRUNCATETASKINPUTLOGGING </target>
+        <note />
+      </trans-unit>
       <trans-unit id="MetaprojectGenerated">
         <source>Metaproject "{0}" generated.</source>
         <target state="translated"> "{0}"</target>
@@ -117,6 +122,11 @@
         <target state="translated"> BeginBuild</target>
         <note />
       </trans-unit>
+      <trans-unit id="NuGetAssemblyNotFound">
+        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
+        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
         <source>MSB4253: A null reference was returned from a user-provided ProjectInstanceFactoryFunc callback. This is not allowed.</source>
         <target state="translated">MSB4253:  ProjectInstanceFactoryFunc  null </target>
@@ -200,9 +210,9 @@
     </note>
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
-        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
-        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
-        <note>{StrBegin="MSB4132: "}</note>
+        <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
+        <target state="translated">MSB4181: "{0}"  false</target>
+        <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
diff --git a/src/Build/System.Text.Encodings.Web.pkgdef b/src/Build/System.Text.Encodings.Web.pkgdef
new file mode 100644
index 00000000000..bee4d6921fe
--- /dev/null
+++ b/src/Build/System.Text.Encodings.Web.pkgdef
@@ -0,0 +1,7 @@
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{1A1A9DA4-9F25-4AC8-89BF-BCEF74875CA8}]
+"name"="System.Text.Encodings.Web"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\System.Text.Encodings.Web.dll"
+"publicKeyToken"="cc7b13ffcd2ddd51"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-4.0.5.0"
+"newVersion"="4.0.5.0"
diff --git a/src/Build/System.Text.Json.pkgdef b/src/Build/System.Text.Json.pkgdef
new file mode 100644
index 00000000000..f20fee293fd
--- /dev/null
+++ b/src/Build/System.Text.Json.pkgdef
@@ -0,0 +1,7 @@
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{1F1A9DA4-9F25-4AB8-89BF-BCEF73875178}]
+"name"="System.Text.Json"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\System.Text.Json.dll"
+"publicKeyToken"="cc7b13ffcd2ddd51"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-4.0.1.0"
+"newVersion"="4.0.1.0"
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
new file mode 100644
index 00000000000..117e85acd93
--- /dev/null
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -0,0 +1,69 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO;
+using System.Reflection;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Evaluation
+{
+    /// <summary>
+    /// Wraps the NuGet.Frameworks assembly, which is referenced by reflection.
+    /// </summary>
+    internal class NuGetFrameworkWrapper
+    {
+        /// <summary>
+        /// NuGet Types
+        /// </summary>
+        private static MethodInfo ParseMethod;
+        private static MethodInfo IsCompatibleMethod;
+        private static object DefaultCompatibilityProvider;
+        private static PropertyInfo FrameworkProperty;
+        private static PropertyInfo VersionProperty;
+
+        public NuGetFrameworkWrapper()
+        {
+            /// Resolve the location of the NuGet.Frameworks assembly
+            var assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
+                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
+                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
+            try
+            {
+                var NuGetAssembly = Assembly.LoadFile(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
+                var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
+                var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
+                var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
+                ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
+                IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
+                DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, new object[] { });
+                FrameworkProperty = NuGetFramework.GetProperty("Framework");
+                VersionProperty = NuGetFramework.GetProperty("Version");
+            }
+            catch
+            {
+                throw new InternalErrorException(string.Format(AssemblyResources.GetString("NuGetAssemblyNotFound"), assemblyDirectory));
+            }
+        }
+
+        private object Parse(string tfm)
+        {
+            return ParseMethod.Invoke(null, new object[] { tfm });
+        }
+
+        public string GetTargetFrameworkIdentifier(string tfm)
+        {
+            return FrameworkProperty.GetValue(Parse(tfm)) as string;
+        }
+
+        public string GetTargetFrameworkVersion(string tfm)
+        {
+            return (VersionProperty.GetValue(Parse(tfm)) as Version).ToString(2);
+        }
+
+        public bool IsCompatible(string target, string candidate)
+        {
+            return Convert.ToBoolean(IsCompatibleMethod.Invoke(DefaultCompatibilityProvider, new object[] { Parse(target), Parse(candidate) }));
+        }
+    }
+}
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 1953f6976a4..7d4b6537997 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -17,7 +17,10 @@
     <!-- Set output type of test projects to EXE.  This will allow us to run tests on .NET Core via F5 or "dotnet run" -->
     <OutputType>Exe</OutputType>
     <GenerateProgramFile>false</GenerateProgramFile>
-
+    
+    <!-- Makes xunit print all test names in stdout -->
+    <XunitOptions>$(XunitOptions) -diagnostics</XunitOptions>
+    
     <!-- Respect the traits set up by PlatformSpecific attribute. -->
     <XunitOptions Condition="'$(OsEnvironment)'=='windows'">$(XunitOptions) -notrait category=nonwindowstests</XunitOptions>
     <XunitOptions Condition="'$(OsEnvironment)'=='linux'">$(XunitOptions) -notrait category=nonlinuxtests</XunitOptions>
@@ -38,6 +41,10 @@
     <TestRunnerAdditionalArguments>$(XunitOptions)</TestRunnerAdditionalArguments>
     
     <PackageOutputPath Condition="'$(IsVisualStudioInsertionPackage)' == 'true'">$(DevDivPackagesDir)</PackageOutputPath>
+
+    <!-- Arcade sdk also carries an xunit.runner.json which sometimes overrides the one in this repo. Assign a value to the arcade properties XUnitDesktopSettingsFile and XUnitCoreSettingsFile to prevent the arcade version of the file being added. -->
+    <XUnitDesktopSettingsFile>$(MSBuildThisFileDirectory)Shared\UnitTests\xunit.runner.json</XUnitDesktopSettingsFile>
+    <XUnitCoreSettingsFile>$(XUnitDesktopSettingsFile)</XUnitCoreSettingsFile>
   </PropertyGroup>
 
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true'">
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index f233d9bc446..0d39dc25f6e 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -43,6 +43,9 @@
     <Compile Include="..\Shared\ExceptionHandling.cs" />
     <Compile Include="..\Shared\VisualStudioLocationHelper.cs" />
     <Compile Include="..\Shared\StringBuilderCache.cs" />
+    <Compile Include="..\Shared\IInternable.cs" />
+    <Compile Include="..\Shared\WeakStringCache.cs" />
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
     <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
     <Compile Include="..\Shared\UnitTests\AssemblyResources.cs" />
diff --git a/src/Framework.UnitTests/SdkReference_Tests.cs b/src/Framework.UnitTests/SdkReference_Tests.cs
index b4d641ca926..a6d9238c30a 100644
--- a/src/Framework.UnitTests/SdkReference_Tests.cs
+++ b/src/Framework.UnitTests/SdkReference_Tests.cs
@@ -84,9 +84,9 @@ public void VerifySdkReferenceEquality()
             sdk.ShouldNotBe(new SdkReference("Name", "Version", null));
             sdk.ShouldNotBe(new SdkReference("Name", null, "Min"));
             sdk.ShouldNotBe(new SdkReference("Name", null, null));
-            sdk.ShouldNotBe(new SdkReference("Name", "version", "Min"));
-            sdk.ShouldNotBe(new SdkReference("name", "Version", "Min"));
-            sdk.ShouldNotBe(new SdkReference("Name", "Version", "min"));
+            sdk.ShouldBe(new SdkReference("Name", "version", "Min"));
+            sdk.ShouldBe(new SdkReference("name", "Version", "Min"));
+            sdk.ShouldBe(new SdkReference("Name", "Version", "min"));
             sdk.ShouldNotBe(new SdkReference("Name2", "Version", "Min"));
         }
     }
diff --git a/src/Framework/IBuildEngine7.cs b/src/Framework/IBuildEngine7.cs
index 0d826f2ca14..025b60a6fbc 100644
--- a/src/Framework/IBuildEngine7.cs
+++ b/src/Framework/IBuildEngine7.cs
@@ -1,16 +1,16 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// This interface extends IBuildEngine6 to allow tasks and build scheduler to coordinate resource (cores) usage.
+    /// This interface extends <see cref="IBuildEngine6" /> to allow tasks to set whether they want to
+    /// log an error when a task returns without logging an error.
     /// </summary>
-
     public interface IBuildEngine7 : IBuildEngine6
     {
+        public bool AllowFailureWithoutError { get; set; }
+
         /// <summary>
         /// If a task launches multiple parallel processes, it should ask how many cores it can use.
         /// </summary>
@@ -24,5 +24,6 @@ public interface IBuildEngine7 : IBuildEngine6
         /// </summary>
         /// <param name="coresToRelease">Number of cores no longer in use.</param>
         void ReleaseCores(int coresToRelease);
+
     }
 }
diff --git a/src/Framework/Sdk/SdkReference.cs b/src/Framework/Sdk/SdkReference.cs
index 2fc413d4e65..9be25528bcc 100644
--- a/src/Framework/Sdk/SdkReference.cs
+++ b/src/Framework/Sdk/SdkReference.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Diagnostics;
 using System.Linq;
 using Microsoft.Build.Shared;
 
@@ -10,6 +11,7 @@ namespace Microsoft.Build.Framework
     /// <summary>
     ///     Represents a software development kit (SDK) that is referenced in a &lt;Project /&gt; or &lt;Import /&gt; element.
     /// </summary>
+    [DebuggerDisplay("Name={Name} Version={Version} MinimumVersion={MinimumVersion}")]
     public sealed class SdkReference : IEquatable<SdkReference>
     {
         /// <summary>
@@ -50,8 +52,9 @@ public bool Equals(SdkReference other)
         {
             if (ReferenceEquals(null, other)) return false;
             if (ReferenceEquals(this, other)) return true;
-            return string.Equals(Name, other.Name) && string.Equals(Version, other.Version) &&
-                   string.Equals(MinimumVersion, other.MinimumVersion);
+            return string.Equals(Name, other.Name, StringComparison.OrdinalIgnoreCase) &&
+                   string.Equals(Version, other.Version, StringComparison.OrdinalIgnoreCase) &&
+                   string.Equals(MinimumVersion, other.MinimumVersion, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -101,9 +104,9 @@ public override int GetHashCode()
         {
             unchecked
             {
-                var hashCode = (Name != null ? Name.GetHashCode() : 0);
-                hashCode = (hashCode * 397) ^ (Version != null ? Version.GetHashCode() : 0);
-                hashCode = (hashCode * 397) ^ (MinimumVersion != null ? MinimumVersion.GetHashCode() : 0);
+                var hashCode = (Name != null ? Name.ToLowerInvariant().GetHashCode() : 0);
+                hashCode = (hashCode * 397) ^ (Version != null ? Version.ToLowerInvariant().GetHashCode() : 0);
+                hashCode = (hashCode * 397) ^ (MinimumVersion != null ? MinimumVersion.ToLowerInvariant().GetHashCode() : 0);
                 return hashCode;
             }
         }
diff --git a/src/Framework/Sdk/SdkResult.cs b/src/Framework/Sdk/SdkResult.cs
index c98dfcf6281..12cf5db0eac 100644
--- a/src/Framework/Sdk/SdkResult.cs
+++ b/src/Framework/Sdk/SdkResult.cs
@@ -1,6 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
+
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -12,17 +14,26 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public abstract class SdkResult
     {
+        //  Explicit backing fields so that implementation in Microsoft.Build.dll can use them for translation
+        private protected bool _success;
+        private protected string _path;
+        private protected string _version;
+        private protected IList<string> _additionalPaths;
+        private protected IDictionary<string, string> _propertiesToAdd;
+        private protected IDictionary<string, SdkResultItem> _itemsToAdd;
+        private protected SdkReference _sdkReference;
+
         /// <summary>
         ///     Indicates the resolution was successful.
         /// </summary>
-        public virtual bool Success { get; protected set; }
+        public virtual bool Success { get => _success; protected set => _success = value; }
 
         /// <summary>
         ///     Resolved path to the SDK.
         /// 
         ///     Null if <see cref="Success"/> == false
         /// </summary>
-        public virtual string Path { get; protected set; }
+        public virtual string Path { get => _path; protected set => _path = value; }
 
         /// <summary>
         ///     Resolved version of the SDK.
@@ -30,11 +41,29 @@ public abstract class SdkResult
         /// 
         ///     Null if <see cref="Success"/> == false
         /// </summary>
-        public virtual string Version { get; protected set; }
+        public virtual string Version { get => _version; protected set => _version = value; }
+
+        /// <summary>
+        /// Additional resolved SDK paths beyond the one specified in <see cref="Path"/>
+        /// </summary>
+        /// <remarks>
+        /// This allows an SDK resolver to return multiple SDK paths, which will all be imported.
+        /// </remarks>
+        public virtual IList<string> AdditionalPaths { get => _additionalPaths; set => _additionalPaths = value; }
+
+        /// <summary>
+        /// Properties that should be added to the evaluation.  This allows an SDK resolver to provide information to the build
+        /// </summary>
+        public virtual IDictionary<string, string> PropertiesToAdd { get => _propertiesToAdd; protected set => _propertiesToAdd = value; }
+
+        /// <summary>
+        /// Items that should be added to the evaluation.  This allows an SDK resolver to provide information to the build
+        /// </summary>
+        public virtual IDictionary<string, SdkResultItem> ItemsToAdd { get => _itemsToAdd; protected set => _itemsToAdd = value; }
 
         /// <summary>
         ///     The Sdk reference
         /// </summary>
-        public virtual SdkReference SdkReference { get; protected set; }
+        public virtual SdkReference SdkReference { get => _sdkReference; protected set => _sdkReference = value; }
     }
 }
diff --git a/src/Framework/Sdk/SdkResultFactory.cs b/src/Framework/Sdk/SdkResultFactory.cs
index cca970e6d0e..3ed0eda1700 100644
--- a/src/Framework/Sdk/SdkResultFactory.cs
+++ b/src/Framework/Sdk/SdkResultFactory.cs
@@ -20,6 +20,26 @@ public abstract class SdkResultFactory
         /// <returns></returns>
         public abstract SdkResult IndicateSuccess(string path, string version, IEnumerable<string> warnings = null);
 
+        /// <summary>
+        ///     Create an <see cref="SdkResolver" /> object indicating success.
+        /// </summary>
+        /// <remarks>
+        /// This overload allows any number (zero, one, or many) of SDK paths to be returned.  This means a "successful" result
+        /// may not resolve to any SDKs.  The resolver can also supply properties or items to communicate information to the build.  This
+        /// can allow resolvers to report SDKs that could not be resolved without hard-failing the evaluation, which can allow other
+        /// components to take more appropriate action (for example installing optional workloads or downloading NuGet SDKs).
+        /// </remarks>
+        /// <param name="paths">SDK paths which should be imported</param>
+        /// <param name="propertiesToAdd">Properties to set in the evaluation</param>
+        /// <param name="itemsToAdd">Items to add to the evaluation</param>
+        /// <param name="warnings">Optional warnings to display during resolution.</param>
+        /// <returns></returns>
+        public abstract SdkResult IndicateSuccess(IEnumerable<string> paths,
+            string version,
+            IDictionary<string, string> propertiesToAdd = null,
+            IDictionary<string, SdkResultItem> itemsToAdd = null,
+            IEnumerable<string> warnings = null);
+
         /// <summary>
         ///     Create an <see cref="SdkResolver" /> object indicating failure resolving the SDK.
         /// </summary>
diff --git a/src/Framework/Sdk/SdkResultItem.cs b/src/Framework/Sdk/SdkResultItem.cs
new file mode 100644
index 00000000000..0ed9de3114e
--- /dev/null
+++ b/src/Framework/Sdk/SdkResultItem.cs
@@ -0,0 +1,75 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// The value of an item and any associated metadata to be added by an SDK resolver.  See <see cref="SdkResult.ItemsToAdd"/>
+    /// </summary>
+    public class SdkResultItem
+    {
+        public string ItemSpec { get; set; }
+        public Dictionary<string, string> Metadata { get;}
+
+        public SdkResultItem()
+        {
+            Metadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+        }
+
+        /// <summary>
+        /// Creates an <see cref="SdkResultItem"/>
+        /// </summary>
+        /// <param name="itemSpec">The value (itemspec) for the item</param>
+        /// <param name="metadata">A dictionary of item metadata.  This should be created with <see cref="StringComparer.OrdinalIgnoreCase"/> for the comparer.</param>
+        public SdkResultItem(string itemSpec, Dictionary<string, string> metadata)
+        {
+            ItemSpec = itemSpec;
+            Metadata = metadata;
+        }
+
+        public override bool Equals(object obj)
+        {
+            if (obj is SdkResultItem item &&
+                   ItemSpec == item.ItemSpec &&
+                   Metadata?.Count == item.Metadata?.Count)
+            {
+                if (Metadata != null)
+                {
+                    foreach (var kvp in Metadata)
+                    {
+                        if (item.Metadata[kvp.Key] != kvp.Value)
+                        {
+                            return false;
+                        }
+                    }
+                }
+
+                return true;
+            }
+            return false;
+        }
+
+        public override int GetHashCode()
+        {
+            int hashCode = -849885975;
+            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(ItemSpec);
+
+            if (Metadata != null)
+            {
+                foreach (var kvp in Metadata)
+                {
+                    hashCode = hashCode * -1521134295 + kvp.Key.GetHashCode();
+                    hashCode = hashCode * -1521134295 + kvp.Value.GetHashCode();
+                }
+            }
+
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Framework/TaskPropertyInfo.cs b/src/Framework/TaskPropertyInfo.cs
index 07567a482d2..eb5808ef40b 100644
--- a/src/Framework/TaskPropertyInfo.cs
+++ b/src/Framework/TaskPropertyInfo.cs
@@ -46,5 +46,20 @@ public TaskPropertyInfo(string name, Type typeOfParameter, bool output, bool req
         /// This task parameter is required (analogous to the [Required] attribute)
         /// </summary>
         public bool Required { get; private set; }
+
+        /// <summary>
+        /// This task parameter should be logged when LogTaskInputs is set. Defaults to true.
+        /// </summary>
+        public bool Log { get; set; } = true;
+
+        /// <summary>
+        /// When this task parameter is an item list, determines whether to log item metadata. Defaults to true.
+        /// </summary>
+        public bool LogItemMetadata { get; set; } = true;
+
+        /// <summary>
+        /// Whether the Log and LogItemMetadata properties have been assigned already.
+        /// </summary>
+        internal bool Initialized = false;
     }
 }
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index b2acd9e5646..6c4a2e79218 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -1215,7 +1215,7 @@ public void ResponseFileSupportsThisFileDirectory()
         /// <summary>
         /// Test that low priority builds actually execute with low priority.
         /// </summary>
-        [Fact]
+        [Fact(Skip = "https://github.com/microsoft/msbuild/issues/5229")]
         public void LowPriorityBuild()
         {
             RunPriorityBuildTest(expectedPrority: ProcessPriorityClass.BelowNormal, arguments: "/low");
@@ -1224,7 +1224,7 @@ public void LowPriorityBuild()
         /// <summary>
         /// Test that normal builds execute with normal priority.
         /// </summary>
-        [Fact]
+        [Fact(Skip = "https://github.com/microsoft/msbuild/issues/5229")]
         public void NormalPriorityBuild()
         {
             // In case we are already running at a  different priority, validate
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 75f5ca314aa..0d230763e6b 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -126,9 +126,13 @@
     <Compile Include="..\Shared\INodePacketHandler.cs" />
     <Compile Include="..\Shared\ITranslatable.cs" />
     <Compile Include="..\Shared\ITranslator.cs" />
+    <Compile Include="..\Shared\TranslatorHelpers.cs" />
     <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
+    <Compile Include="..\Shared\IInternable.cs" />
+    <Compile Include="..\Shared\WeakStringCache.cs" />
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs" />
     <Compile Include="..\Shared\OpportunisticIntern.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
     <Compile Include="..\Shared\TaskHostTaskComplete.cs" />
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 9e1c7b7b557..3f21a504d85 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1141,6 +1141,16 @@ elementFormDefault="qualified">
             </xs:complexContent>
         </xs:complexType>
     </xs:element>
+    <xs:element name="AndroidResource" substitutionGroup="msb:Item">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="AndroidResource" _locComment="" -->Android resource files to be used within a Xamarin.Android project.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="ProguardConfiguration" substitutionGroup="msb:Item">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="ProguardConfiguration" _locComment="" -->ProGuard configuration files to be used within a Xamarin.Android project.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <!-- ======================== PROPERTIES =====================================-->
     <!-- Possible Types include StringPropertyType (text with no subelements), GenericPropertyType (any content), or something more specific.-->
 
@@ -2054,6 +2064,79 @@ elementFormDefault="qualified">
       </xs:annotation>
     </xs:element>
 
+    <!-- ======================== XAMARIN.ANDROID PROPERTIES ======================== -->
+
+    <xs:element name="AndroidApplication" type="msb:boolean" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidApplication" _locComment="" -->Used by Xamarin.Android projects. A boolean value that indicates whether the project is for an Android Application (True) or for an Android Library Project (False or not present).</xs:documentation>
+      </xs:annotation>
+    </xs:element>
+    <xs:element name="AndroidDexTool" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidDexTool" _locComment="" -->Used by Xamarin.Android projects. A string property that indicates which Android dex compiler is used during the Xamarin.Android build process.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="d8" />
+          <xs:enumeration value="dx" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
+    <xs:element name="AndroidEnableProfiledAot" type="msb:boolean" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidEnableProfiledAot" _locComment="" -->Used by Xamarin.Android projects. A boolean property that determines whether or not AOT profiles are used during Ahead-of-Time compilation.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
+    <xs:element name="AndroidLinkMode" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidLinkMode" _locComment="" -->Used by Xamarin.Android projects. A string property that specifies which type of linking should be performed on assemblies contained within the Android package. Only used in Android Application projects.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="None" />
+          <xs:enumeration value="SdkOnly" />
+          <xs:enumeration value="Full" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
+    <xs:element name="AndroidLinkTool" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidLinkTool" _locComment="" -->Used by Xamarin.Android projects. A string property that indicates which code shrinker is used for Java code.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="r8" />
+          <xs:enumeration value="proguard" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
+    <xs:element name="AndroidLinkSkip" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidLinkSkip" _locComment="" -->Used by Xamarin.Android projects. Specifies a semicolon-delimited (;) list of assembly names, without file extensions, of assemblies that should not be linked.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
+    <xs:element name="AndroidPackageFormat" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidPackageFormat" _locComment="" -->Used by Xamarin.Android projects. A string property that indicates if you want to package the Android application as an APK file or Android App Bundle.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="apk" />
+          <xs:enumeration value="aab" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
+    <xs:element name="AndroidSupportedAbis" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AndroidSupportedAbis" _locComment="" -->Used by Xamarin.Android projects. A string property that contains a semicolon (;)-delimited list of ABIs which should be included into the application.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
+    <xs:element name="AotAssemblies" type="msb:boolean" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AotAssemblies" _locComment="" -->Used by Xamarin.Android projects. A boolean property that determines whether or not assemblies will be Ahead-of-Time compiled into native code.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
+
     <!-- ======================== TASKS =====================================-->
     <xs:element name="AL" substitutionGroup="msb:Task">
         <xs:complexType>
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index 622d8cef56a..e3ea73f69f8 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -32,8 +32,7 @@ internal NodeEndpointOutOfProcTaskHost(string pipeName)
         /// </summary>
         protected override long GetHostHandshake()
         {
-            long hostHandshake = CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetCurrentTaskHostContext());
-            return hostHandshake;
+            return CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
         }
 
         /// <summary>
@@ -41,8 +40,7 @@ protected override long GetHostHandshake()
         /// </summary>
         protected override long GetClientHandshake()
         {
-            long clientHandshake = CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetCurrentTaskHostContext());
-            return clientHandshake;
+            return CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
         }
     }
 }
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index f29eff427fb..da75a8716a6 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -37,7 +37,7 @@ internal class OutOfProcTaskHostNode :
 #if CLR2COMPATIBILITY
         IBuildEngine3
 #else
-        IBuildEngine6
+        IBuildEngine7
 #endif
     {
         /// <summary>
@@ -268,6 +268,13 @@ public bool IsRunningMultipleNodes
 
         #endregion // IBuildEngine2 Implementation (Properties)
 
+        #region IBuildEngine7 Implementation
+        /// <summary>
+        /// Enables or disables emitting a default error when a task fails without logging errors
+        /// </summary>
+        public bool AllowFailureWithoutError { get; set; } = true;
+        #endregion
+
         #region IBuildEngine Implementation (Methods)
 
         /// <summary>
@@ -455,7 +462,6 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
         }
 
         #endregion
-
 #endif
 
         #region INodePacketFactory Members
@@ -1166,5 +1172,15 @@ private void LogErrorFromResource(string messageResource)
 
             LogErrorEvent(error);
         }
+
+        public int RequestCores(int requestedCores)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void ReleaseCores(int coresToRelease)
+        {
+            throw new NotImplementedException();
+        }
     }
 }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index f4a29c07fab..31ea76ac5d5 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -626,10 +626,13 @@ string [] commandLine
                         Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
                     }
 
-                    // Honor the low priority flag, we place our selves below normal
-                    // priority and let sub processes inherit that priority.
-                    ProcessPriorityClass priority = lowPriority ? ProcessPriorityClass.BelowNormal : ProcessPriorityClass.Normal;
-                    Process.GetCurrentProcess().PriorityClass = priority;
+                    // Honor the low priority flag, we place our selves below normal priority and let sub processes inherit
+                    // that priority. Idle priority would prevent the build from proceeding as the user does normal actions.
+                    // We avoid increasing priority because that causes failures on mac/linux.
+                    if (lowPriority && Process.GetCurrentProcess().PriorityClass != ProcessPriorityClass.Idle)
+                    {
+                        Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.BelowNormal;
+                    }
 
                     DateTime t1 = DateTime.Now;
 
@@ -3740,7 +3743,7 @@ private static void ThrowInvalidToolsVersionInitializationException(IEnumerable<
         private static void DisplayCopyrightMessage()
         {
 #if RUNTIME_TYPE_NETCORE
-            const string frameworkName = ".NET Core";
+            const string frameworkName = ".NET";
 #elif MONO
             const string frameworkName = "Mono";
 #else
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 2e10ebdd3fd..4fcb3ad7d8d 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -92,6 +92,7 @@
     <Compile Include="..\Shared\ITranslator.cs">
       <Link>ITranslator.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\TranslatorHelpers.cs" />
     <Compile Include="..\Shared\InternalErrorException.cs">
       <Link>InternalErrorException.cs</Link>
     </Compile>
@@ -125,6 +126,12 @@
     <Compile Include="..\Shared\NodeShutdown.cs">
       <Link>NodeShutdown.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IInternable.cs">
+      <Link>IInternable.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.cs">
+      <Link>WeakStringCache.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\OpportunisticIntern.cs">
       <Link>OpportunisticIntern.cs</Link>
     </Compile>
@@ -158,6 +165,7 @@
     <Compile Include="Concurrent\ConcurrentQueue.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="TypeLoader.cs" />
+    <Compile Include="WeakStringCache.Locking.cs" />
     <Compile Include="..\MSBuild\LogMessagePacket.cs">
       <Link>LogMessagePacket.cs</Link>
     </Compile>
diff --git a/src/MSBuildTaskHost/WeakStringCache.Locking.cs b/src/MSBuildTaskHost/WeakStringCache.Locking.cs
new file mode 100644
index 00000000000..d26dd984963
--- /dev/null
+++ b/src/MSBuildTaskHost/WeakStringCache.Locking.cs
@@ -0,0 +1,125 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build
+{
+    /// <summary>
+    /// Implements the WeakStringCache functionality on .NET Framework 3.5 where ConcurrentDictionary is not available.
+    /// </summary>
+    internal sealed partial class WeakStringCache : IDisposable
+    {
+        private readonly Dictionary<int, StringWeakHandle> _stringsByHashCode;
+
+        public WeakStringCache()
+        {
+            _stringsByHashCode = new Dictionary<int, StringWeakHandle>(_initialCapacity);
+        }
+
+        /// <summary>
+        /// Main entrypoint of this cache. Tries to look up a string that matches the given internable. If it succeeds, returns
+        /// the string and sets cacheHit to true. If the string is not found, calls ExpensiveConvertToString on the internable,
+        /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
+        /// </summary>
+        /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <returns>A string matching the given internable.</returns>
+        public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IInternable
+        {
+            int hashCode = GetInternableHashCode(internable);
+
+            StringWeakHandle handle;
+            string result;
+            bool addingNewHandle = false;
+
+            lock (_stringsByHashCode)
+            {
+                if (_stringsByHashCode.TryGetValue(hashCode, out handle))
+                {
+                    result = handle.GetString(internable);
+                    if (result != null)
+                    {
+                        cacheHit = true;
+                        return result;
+                    }
+                }
+                else
+                {
+                    handle = new StringWeakHandle();
+                    addingNewHandle = true;
+                }
+
+                // We don't have the string in the cache - create it.
+                result = internable.ExpensiveConvertToString();
+
+                // Set the handle to reference the new string.
+                handle.SetString(result);
+
+                if (addingNewHandle)
+                {
+                    // Prevent the dictionary from growing forever with GC handles that don't reference live strings anymore.
+                    if (_stringsByHashCode.Count >= _scavengeThreshold)
+                    {
+                        // Get rid of unused handles.
+                        ScavengeNoLock();
+                        // And do this again when the number of handles reaches double the current after-scavenge number.
+                        _scavengeThreshold = _stringsByHashCode.Count * 2;
+                    }
+                }
+                _stringsByHashCode[hashCode] = handle;
+            }
+
+            cacheHit = false;
+            return result;
+        }
+
+        /// <summary>
+        /// Iterates over the cache and removes unused GC handles, i.e. handles that don't reference live strings.
+        /// This is expensive so try to call such that the cost is amortized to O(1) per GetOrCreateEntry() invocation.
+        /// Assumes the lock is taken by the caller.
+        /// </summary>
+        private void ScavengeNoLock()
+        {
+            List<int> keysToRemove = null;
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                if (!entry.Value.IsUsed)
+                {
+                    entry.Value.Free();
+                    keysToRemove ??= new List<int>();
+                    keysToRemove.Add(entry.Key);
+                }
+            }
+            if (keysToRemove != null)
+            {
+                for (int i = 0; i < keysToRemove.Count; i++)
+                {
+                    _stringsByHashCode.Remove(keysToRemove[i]);
+                }
+            }
+        }
+
+        /// <summary>
+        /// Public version of ScavengeUnderLock() which takes the lock.
+        /// </summary>
+        public void Scavenge()
+        {
+            lock (_stringsByHashCode)
+            {
+                ScavengeNoLock();
+            }
+        }
+
+        /// <summary>
+        /// Returns internal debug counters calculated based on the current state of the cache.
+        /// </summary>
+        public DebugInfo GetDebugInfo()
+        {
+            lock (_stringsByHashCode)
+            {
+                return GetDebugInfoImpl();
+            }
+        }
+    }
+}
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index e2ae215109f..f2132af28e6 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -30,6 +30,12 @@
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.Bcl.AsyncInterfaces.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Buffers.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Text.Encodings.Web.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Threading.Tasks.Extensions.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.ValueTuple.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Numerics.Vectors.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin" />
@@ -78,6 +84,12 @@
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.Bcl.AsyncInterfaces.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Buffers.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Text.Encodings.Web.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Threading.Tasks.Extensions.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.ValueTuple.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Numerics.Vectors.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin/amd64" />
diff --git a/src/Package/MSBuild.VSSetup/MSBuild.clientenabledpkg b/src/Package/MSBuild.VSSetup/MSBuild.clientenabledpkg
new file mode 100644
index 00000000000..489e2745d8c
--- /dev/null
+++ b/src/Package/MSBuild.VSSetup/MSBuild.clientenabledpkg
@@ -0,0 +1,7 @@
+Microsoft.Build.Framework.pkgdef
+Microsoft.Build.pkgdef
+Microsoft.Build.Tasks.Core.pkgdef
+System.Resources.Extensions.pkgdef
+Microsoft.Build.Utilities.Core.pkgdef
+Microsoft.Build.Conversion.Core.pkgdef
+Microsoft.Build.Engine.pkgdef
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index bdff4bb1c63..44277b783c7 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -38,6 +38,11 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.ValueTuple.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
@@ -182,6 +187,11 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.ValueTuple.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
@@ -305,8 +315,11 @@ folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hant
   file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
 
 folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
+  file source=$(SourceDir)Package\MSBuild.VSSetup\MSBuild.clientenabledpkg
   file source=$(SourceDir)Framework\Microsoft.Build.Framework.pkgdef
   file source=$(SourceDir)Build\Microsoft.Build.pkgdef
+  file source=$(SourceDir)Build\System.Text.Encodings.Web.pkgdef
+  file source=$(SourceDir)Build\System.Text.Json.pkgdef
   file source=$(SourceDir)Tasks\Microsoft.Build.Tasks.Core.pkgdef
   file source=$(SourceDir)Tasks\System.Resources.Extensions.pkgdef
   file source=$(SourceDir)Utilities\Microsoft.Build.Utilities.Core.pkgdef
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 3dce827846d..d8bd3da94f8 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -259,19 +259,19 @@ public void Translate(ref List<string> list)
             }
 
             /// <summary>
-            /// Translates a list of T where T implements INodePacketTranslateable
+            /// Translates a list of T using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
             /// <param name="list">The list to be translated.</param>
-            /// <param name="factory">Factory to deserialize T</param>
+            /// <param name="objectTranslator">The translator to use for the items in the list</param>
             /// <typeparam name="T">TaskItem type</typeparam>
-            public void Translate<T>(ref List<T> list, NodePacketValueFactory<T> factory) where T : ITranslatable
+            public void Translate<T>(ref List<T> list, ObjectTranslator<T> objectTranslator)
             {
                 IList<T> listAsInterface = list;
-                Translate(ref listAsInterface, factory, count => new List<T>(count));
+                Translate(ref listAsInterface, objectTranslator, count => new List<T>(count));
                 list = (List<T>) listAsInterface;
             }
 
-            public void Translate<T, L>(ref IList<T> list, NodePacketValueFactory<T> factory, NodePacketCollectionCreator<L> collectionFactory) where T : ITranslatable where L : IList<T>
+            public void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : IList<T>
             {
                 if (!TranslateNullable(list))
                 {
@@ -285,12 +285,7 @@ public void Translate<T, L>(ref IList<T> list, NodePacketValueFactory<T> factory
                 {
                     T value = default(T);
 
-                    if (!TranslateNullable(value))
-                    {
-                        continue;
-                    }
-
-                    value = factory(this);
+                    objectTranslator(this, ref value);
                     list.Add(value);
                 }
             }
@@ -444,24 +439,6 @@ public void Translate<T>(ref T value)
                 value.Translate(this);
             }
 
-            /// <summary>
-            /// Translates an object implementing INodePacketTranslatable which does not expose a
-            /// public parameterless constructor.
-            /// </summary>
-            /// <typeparam name="T">The reference type.</typeparam>
-            /// <param name="value">The value to be translated.</param>
-            /// <param name="factory">The factory method used to instantiate values of type T.</param>
-            public void Translate<T>(ref T value, NodePacketValueFactory<T> factory)
-                where T : ITranslatable
-            {
-                if (!TranslateNullable(value))
-                {
-                    return;
-                }
-
-                value = factory(this);
-            }
-
             /// <summary>
             /// Translates an array of objects implementing INodePacketTranslatable.
             /// </summary>
@@ -486,13 +463,12 @@ public void TranslateArray<T>(ref T[] array)
             }
 
             /// <summary>
-            /// Translates an array of objects implementing INodePacketTranslatable requiring a factory to create.
+            /// Translates an array of objects using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
             /// <typeparam name="T">The reference type.</typeparam>
             /// <param name="array">The array to be translated.</param>
-            /// <param name="factory">The factory method used to instantiate values of type T.</param>
-            public void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
-                where T : ITranslatable
+            /// <param name="objectTranslator">The translator to use for the elements in the array</param>
+            public void TranslateArray<T>(ref T[] array, ObjectTranslator<T> objectTranslator)
             {
                 if (!TranslateNullable(array))
                 {
@@ -504,7 +480,7 @@ public void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
 
                 for (int i = 0; i < count; i++)
                 {
-                    array[i] = factory(this);
+                    objectTranslator(this, ref array[i]);
                 }
             }
 
@@ -546,8 +522,8 @@ public void TranslateDictionary(ref IDictionary<string, string> dictionary, Node
 
             public void TranslateDictionary<K, V>(
                 ref IDictionary<K, V> dictionary,
-                Translator<K> keyTranslator,
-                Translator<V> valueTranslator,
+                ObjectTranslator<K> keyTranslator,
+                ObjectTranslator<V> valueTranslator,
                 NodePacketCollectionCreator<IDictionary<K, V>> dictionaryCreator)
             {
                 if (!TranslateNullable(dictionary))
@@ -561,9 +537,9 @@ public void TranslateDictionary<K, V>(
                 for (int i = 0; i < count; i++)
                 {
                     K key = default(K);
-                    keyTranslator.Invoke(ref key, this);
+                    keyTranslator(this, ref key);
                     V value = default(V);
-                    valueTranslator(ref value, this);
+                    valueTranslator(this, ref value);
                     dictionary[key] = value;
                 }
             }
@@ -571,12 +547,12 @@ public void TranslateDictionary<K, V>(
             /// <summary>
             /// Translates a dictionary of { string, T }.  
             /// </summary>
-            /// <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
+            /// <typeparam name="T">The reference type for the values</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
             /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-            public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, NodePacketValueFactory<T> valueFactory)
-                where T : class, ITranslatable
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
+            public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, ObjectTranslator<T> objectTranslator)
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -591,7 +567,7 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali
                     string key = null;
                     Translate(ref key);
                     T value = null;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                     dictionary[key] = value;
                 }
             }
@@ -602,10 +578,10 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali
             /// <typeparam name="D">The reference type for the dictionary.</typeparam>
             /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-            public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory)
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
+            public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator)
                 where D : IDictionary<string, T>, new()
-                where T : class, ITranslatable
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -620,7 +596,7 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
                     string key = null;
                     Translate(ref key);
                     T value = null;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                     dictionary[key] = value;
                 }
             }
@@ -631,11 +607,11 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
             /// <typeparam name="D">The reference type for the dictionary.</typeparam>
             /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
             /// <param name="dictionaryCreator">The delegate used to instantiate the dictionary.</param>
-            public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory, NodePacketCollectionCreator<D> dictionaryCreator)
+            public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<D> dictionaryCreator)
                 where D : IDictionary<string, T>
-                where T : class, ITranslatable
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -650,7 +626,7 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
                     string key = null;
                     Translate(ref key);
                     T value = null;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                     dictionary[key] = value;
                 }
             }
@@ -858,12 +834,12 @@ public void Translate(ref HashSet<string> set)
             }
 
             /// <summary>
-            /// Translates a list of T where T implements INodePacketTranslateable
+            /// Translates a list of T using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
             /// <param name="list">The list to be translated.</param>
-            /// <param name="factory">factory to create type T</param>
+            /// <param name="objectTranslator">The translator to use for the items in the list</param>
             /// <typeparam name="T">A TaskItemType</typeparam>
-            public void Translate<T>(ref List<T> list, NodePacketValueFactory<T> factory) where T : ITranslatable
+            public void Translate<T>(ref List<T> list, ObjectTranslator<T> objectTranslator)
             {
                 if (!TranslateNullable(list))
                 {
@@ -876,19 +852,19 @@ public void Translate<T>(ref List<T> list, NodePacketValueFactory<T> factory) wh
                 for (int i = 0; i < count; i++)
                 {
                     T value = list[i];
-                    Translate<T>(ref value, factory);
+                    objectTranslator(this, ref value);
                 }
             }
 
             /// <summary>
-            /// Translates a list of T where T implements INodePacketTranslateable
+            /// Translates a list of T using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
             /// <param name="list">The list to be translated.</param>
-            /// <param name="factory">factory to create type T</param>
+            /// <param name="objectTranslator">The translator to use for the items in the list</param>
             /// <param name="collectionFactory">factory to create the IList</param>
             /// <typeparam name="T">A TaskItemType</typeparam>
             /// <typeparam name="L">IList subtype</typeparam>
-            public void Translate<T, L>(ref IList<T> list, NodePacketValueFactory<T> factory, NodePacketCollectionCreator<L> collectionFactory) where T : ITranslatable where L : IList<T>
+            public void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : IList<T>
             {
                 if (!TranslateNullable(list))
                 {
@@ -901,7 +877,7 @@ public void Translate<T, L>(ref IList<T> list, NodePacketValueFactory<T> factory
                 for (int i = 0; i < count; i++)
                 {
                     T value = list[i];
-                    Translate<T>(ref value, factory);
+                    objectTranslator(this, ref value);
                 }
             }
 
@@ -1016,24 +992,6 @@ public void Translate<T>(ref T value)
                 value.Translate(this);
             }
 
-            /// <summary>
-            /// Translates an object implementing INodePacketTranslatable which does not expose a
-            /// public parameterless constructor.
-            /// </summary>
-            /// <typeparam name="T">The reference type.</typeparam>
-            /// <param name="value">The value to be translated.</param>
-            /// <param name="factory">The factory method used to instantiate values of type T.</param>
-            public void Translate<T>(ref T value, NodePacketValueFactory<T> factory)
-                where T : ITranslatable
-            {
-                if (!TranslateNullable(value))
-                {
-                    return;
-                }
-
-                value.Translate(this);
-            }
-
             /// <summary>
             /// Translates a byte array
             /// </summary>
@@ -1076,13 +1034,12 @@ public void TranslateArray<T>(ref T[] array)
             }
 
             /// <summary>
-            /// Translates an array of objects implementing INodePacketTranslatable requiring a factory to create.
+            /// Translates an array of objects using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
             /// <typeparam name="T">The reference type.</typeparam>
             /// <param name="array">The array to be translated.</param>
-            /// <param name="factory">The factory method used to instantiate values of type T.</param>
-            public void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
-                where T : ITranslatable
+            /// <param name="objectTranslator">The translator to use for the elements in the array</param>
+            public void TranslateArray<T>(ref T[] array, ObjectTranslator<T> objectTranslator)
             {
                 if (!TranslateNullable(array))
                 {
@@ -1094,7 +1051,7 @@ public void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
 
                 for (int i = 0; i < count; i++)
                 {
-                    array[i].Translate(this);
+                    objectTranslator(this, ref array[i]);
                 }
             }
 
@@ -1130,8 +1087,8 @@ public void TranslateDictionary(ref IDictionary<string, string> dictionary, Node
 
             public void TranslateDictionary<K, V>(
                 ref IDictionary<K, V> dictionary,
-                Translator<K> keyTranslator,
-                Translator<V> valueTranslator,
+                ObjectTranslator<K> keyTranslator,
+                ObjectTranslator<V> valueTranslator,
                 NodePacketCollectionCreator<IDictionary<K, V>> collectionCreator)
             {
                 if (!TranslateNullable(dictionary))
@@ -1145,9 +1102,9 @@ public void TranslateDictionary<K, V>(
                 foreach (KeyValuePair<K, V> pair in dictionary)
                 {
                     K key = pair.Key;
-                    keyTranslator.Invoke(ref key, this);
+                    keyTranslator(this, ref key);
                     V value = pair.Value;
-                    valueTranslator.Invoke(ref value, this);
+                    valueTranslator(this, ref value);
                 }
             }
 
@@ -1157,9 +1114,9 @@ public void TranslateDictionary<K, V>(
             /// <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
             /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-            public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, NodePacketValueFactory<T> valueFactory)
-                where T : class, ITranslatable
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
+            public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, ObjectTranslator<T> objectTranslator)
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -1174,7 +1131,7 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali
                     string key = pair.Key;
                     Translate(ref key);
                     T value = pair.Value;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                 }
             }
 
@@ -1184,10 +1141,10 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali
             /// <typeparam name="D">The reference type for the dictionary.</typeparam>
             /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-            public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory)
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
+            public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator)
                 where D : IDictionary<string, T>, new()
-                where T : class, ITranslatable
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -1202,7 +1159,7 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
                     string key = pair.Key;
                     Translate(ref key);
                     T value = pair.Value;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                 }
             }
 
@@ -1212,11 +1169,11 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
             /// <typeparam name="D">The reference type for the dictionary.</typeparam>
             /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
-            /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
+            /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
             /// <param name="dictionaryCreator">The delegate used to instantiate the dictionary.</param>
-            public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory, NodePacketCollectionCreator<D> dictionaryCreator)
+            public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<D> dictionaryCreator)
                 where D : IDictionary<string, T>
-                where T : class, ITranslatable
+                where T : class
             {
                 if (!TranslateNullable(dictionary))
                 {
@@ -1231,7 +1188,7 @@ public void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T
                     string key = pair.Key;
                     Translate(ref key);
                     T value = pair.Value;
-                    Translate(ref value, valueFactory);
+                    objectTranslator(this, ref value);
                 }
             }
 
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 9217837e7e6..35131046269 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -13,8 +13,6 @@
 
 using Microsoft.Build.Shared;
 using System.Reflection;
-using System.Security.Cryptography;
-using System.Text;
 
 #if !FEATURE_APM
 using System.Threading.Tasks;
@@ -23,34 +21,37 @@
 namespace Microsoft.Build.Internal
 {
     /// <summary>
-    /// Enumeration of all possible (currently supported) types of task host context.
+    /// Enumeration of all possible (currently supported) options for handshakes.
     /// </summary>
-    internal enum TaskHostContext
+    [Flags]
+    internal enum HandshakeOptions
     {
+        None = 0,
+
         /// <summary>
-        /// 32-bit Intel process, using the 2.0 CLR.
+        /// Process is a TaskHost
         /// </summary>
-        X32CLR2,
+        TaskHost = 1,
 
         /// <summary>
-        /// 64-bit Intel process, using the 2.0 CLR.
+        /// Using the 2.0 CLR
         /// </summary>
-        X64CLR2,
+        CLR2 = 2,
 
         /// <summary>
-        /// 32-bit Intel process, using the 4.0 CLR.
+        /// 64-bit Intel process
         /// </summary>
-        X32CLR4,
+        X64 = 4,
 
         /// <summary>
-        /// 64-bit Intel process, using the 4.0 CLR.
+        /// Node reuse enabled
         /// </summary>
-        X64CLR4,
+        NodeReuse = 8,
 
         /// <summary>
-        /// Invalid task host context
+        /// Building with BelowNormal priority
         /// </summary>
-        Invalid
+        LowPriority = 16
     }
 
     /// <summary>
@@ -292,9 +293,8 @@ internal static void SetEnvironment(IDictionary<string, string> newEnvironment)
 
         /// <summary>
         /// Given a base handshake, generates the real handshake based on e.g. elevation level.  
-        /// Client handshake required for comparison purposes only.  Returns the update handshake.  
         /// </summary>
-        internal static long GenerateHostHandshakeFromBase(long baseHandshake, long clientHandshake)
+        private static long GenerateHostHandshakeFromBase(long baseHandshake)
         {
 #if FEATURE_SECURITY_PRINCIPAL_WINDOWS
             // If we are running in elevated privs, we will only accept a handshake from an elevated process as well.
@@ -309,17 +309,12 @@ internal static long GenerateHostHandshakeFromBase(long baseHandshake, long clie
                 {
                     baseHandshake = baseHandshake ^ 0x5c5c5c5c5c5c5c5c + Process.GetCurrentProcess().SessionId;
                 }
-
-                if ((baseHandshake & 0x00FFFFFFFFFFFFFF) == clientHandshake)
-                {
-                    baseHandshake = ~baseHandshake;
-                }
             }
 #endif
 
-            // Mask out the first byte. That's because old
-            // builds used a single, non zero initial byte,
-            // and we don't want to risk communicating with them
+            // Mask out the first byte. Modern builds expect the first byte to be zero to indicate that they are modern
+            // and should be treated as such. Older builds used a non-zero initial byte. See here:
+            // https://github.com/microsoft/msbuild/blob/584ca5f11b28971f5651b4b8de5f173ad1cb2786/src/Shared/NodeEndpointOutOfProcBase.cs#L403.
             return baseHandshake & 0x00FFFFFFFFFFFFFF;
         }
 
@@ -327,23 +322,31 @@ internal static long GenerateHostHandshakeFromBase(long baseHandshake, long clie
         /// Magic number sent by the host to the client during the handshake.
         /// Derived from the binary timestamp to avoid mixing binary versions.
         /// </summary>
-        internal static long GetHostHandshake(TaskHostContext hostContext)
+        internal static long GetHostHandshake(HandshakeOptions nodeType)
         {
-            long baseHandshake = GenerateHostHandshakeFromBase(GetBaseHandshakeForContext(hostContext), GetClientHandshake(hostContext));
-            return baseHandshake;
+            string salt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+            string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
+            int nodeHandshakeSalt = GetHandshakeHashCode(salt + toolsDirectory);
+
+            Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", nodeType={2}, FileVersionHash={3}", salt, toolsDirectory, nodeType, FileVersionHash);
+
+            //FileVersionHash (32 bits) is shifted 8 bits to avoid session ID collision
+            //nodeType (4 bits) is shifted just after the FileVersionHash
+            //nodeHandshakeSalt (32 bits) is shifted just after hostContext
+            //the most significant byte (leftmost 8 bits) will get zero'd out to avoid connecting to older builds.
+            //| masked out | nodeHandshakeSalt | hostContext |              fileVersionHash             | SessionID
+            //  0000 0000     0000 0000 0000        0000        0000 0000 0000 0000 0000 0000 0000 0000   0000 0000
+            long baseHandshake = ((long)nodeHandshakeSalt << 44) | ((long)nodeType << 40) | ((long)FileVersionHash << 8);
+            return GenerateHostHandshakeFromBase(baseHandshake);
         }
 
         /// <summary>
         /// Magic number sent by the client to the host during the handshake.
         /// Munged version of the host handshake.
         /// </summary>
-        internal static long GetClientHandshake(TaskHostContext hostContext)
+        internal static long GetClientHandshake(HandshakeOptions hostContext)
         {
-            // Mask out the first byte. That's because old
-            // builds used a single, non zero initial byte,
-            // and we don't want to risk communicating with them
-            long clientHandshake = ((GetBaseHandshakeForContext(hostContext) ^ Int64.MaxValue) & 0x00FFFFFFFFFFFFFF);
-            return clientHandshake;
+            return ~GetHostHandshake(hostContext);
         }
 
         /// <summary>
@@ -369,13 +372,13 @@ internal static void WriteLongForHandshake(this PipeStream stream, long value)
         /// Extension method to read a series of bytes from a stream
         /// </summary>
         internal static long ReadLongForHandshake(this PipeStream stream
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
             , int handshakeReadTimeout
 #endif
             )
         {
             return stream.ReadLongForHandshake((byte[])null, 0
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
                 , handshakeReadTimeout
 #endif
                 );
@@ -387,14 +390,14 @@ internal static long ReadLongForHandshake(this PipeStream stream
         /// </summary>
         internal static long ReadLongForHandshake(this PipeStream stream, byte[] leadingBytesToReject,
             byte rejectionByteToReturn
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
             , int timeout
 #endif
             )
         {
             byte[] bytes = new byte[8];
 
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
             if (!NativeMethodsShared.IsWindows)
             {
                 // Enforce a minimum timeout because the Windows code can pass
@@ -488,86 +491,47 @@ internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int byte
 #endif
 
         /// <summary>
-        /// Given the appropriate information, return the equivalent TaskHostContext.  
+        /// Given the appropriate information, return the equivalent HandshakeOptions.
         /// </summary>
-        internal static TaskHostContext GetTaskHostContext(IDictionary<string, string> taskHostParameters)
+        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit = false, int clrVersion = 0, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
         {
-            ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.runtime), "Should always have an explicit runtime when we call this method.");
-            ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.architecture), "Should always have an explicit architecture when we call this method.");
-
-            string runtime = taskHostParameters[XMakeAttributes.runtime];
-            string architecture = taskHostParameters[XMakeAttributes.architecture];
-
-            bool is64BitProcess = false;
-            int clrVersion = 0;
+            HandshakeOptions context = taskHost ? HandshakeOptions.TaskHost : HandshakeOptions.None;
 
-            if (architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64, StringComparison.OrdinalIgnoreCase))
+            // We don't know about the TaskHost. Figure it out.
+            if (taskHost && clrVersion == 0)
             {
-                is64BitProcess = true;
+                // Take the current TaskHost context
+                if (taskHostParameters == null)
+                {
+                    clrVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version.Major;
+                    is64Bit = XMakeAttributes.GetCurrentMSBuildArchitecture().Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
+                }
+                else
+                {
+                    ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.runtime), "Should always have an explicit runtime when we call this method.");
+                    ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.architecture), "Should always have an explicit architecture when we call this method.");
+
+                    clrVersion = taskHostParameters[XMakeAttributes.runtime].Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;
+                    is64Bit = taskHostParameters[XMakeAttributes.architecture].Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
+                }
             }
-            else if (architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x86, StringComparison.OrdinalIgnoreCase))
+            if (is64Bit)
             {
-                is64BitProcess = false;
+                context |= HandshakeOptions.X64;
             }
-            else
+            if (clrVersion == 2)
             {
-                ErrorUtilities.ThrowInternalError("Should always have an explicit architecture when calling this method");
+                context |= HandshakeOptions.CLR2;
             }
-
-            if (runtime.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))
+            if (nodeReuse)
             {
-                clrVersion = 4;
+                context |= HandshakeOptions.NodeReuse;
             }
-            else if (runtime.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))
+            if (lowPriority)
             {
-                clrVersion = 2;
+                context |= HandshakeOptions.LowPriority;
             }
-            else
-            {
-                ErrorUtilities.ThrowInternalError("Should always have an explicit runtime when calling this method");
-            }
-
-            TaskHostContext hostContext = GetTaskHostContext(is64BitProcess, clrVersion);
-            return hostContext;
-        }
-
-        /// <summary>
-        /// Given the appropriate information, return the equivalent TaskHostContext.  
-        /// </summary>
-        internal static TaskHostContext GetTaskHostContext(bool is64BitProcess, int clrVersion)
-        {
-            TaskHostContext hostContext = TaskHostContext.Invalid;
-            switch (clrVersion)
-            {
-                case 2:
-                    hostContext = is64BitProcess ? TaskHostContext.X64CLR2 : TaskHostContext.X32CLR2;
-                    break;
-                case 4:
-                    hostContext = is64BitProcess ? TaskHostContext.X64CLR4 : TaskHostContext.X32CLR4;
-                    break;
-                default:
-                    ErrorUtilities.ThrowInternalErrorUnreachable();
-                    hostContext = TaskHostContext.Invalid;
-                    break;
-            }
-
-            return hostContext;
-        }
-
-        /// <summary>
-        /// Returns the TaskHostContext corresponding to this process
-        /// </summary>
-        internal static TaskHostContext GetCurrentTaskHostContext()
-        {
-            // We know that whichever assembly is executing this code -- whether it's MSBuildTaskHost.exe or 
-            // Microsoft.Build.dll -- is of the version of the CLR that this process is running.  So grab
-            // the version of mscorlib currently in use and call that good enough.  
-            Version mscorlibVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version;
-
-            string currentMSBuildArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
-            TaskHostContext hostContext = GetTaskHostContext(currentMSBuildArchitecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64), mscorlibVersion.Major);
-
-            return hostContext;
+            return context;
         }
 
         /// <summary>
@@ -645,31 +609,6 @@ internal static void Trace(int nodeId, string format, params object[] args)
             }
         }
 
-        /// <summary>
-        /// Add the task host context to this handshake, to make sure that task hosts with different contexts 
-        /// will have different handshakes. Shift it into the upper 32-bits to avoid running into the 
-        /// session ID. The connection may be salted to allow MSBuild to only connect to nodes that come from the same
-        /// test environment.
-        /// </summary>
-        /// <param name="hostContext">TaskHostContext</param>
-        /// <returns>Base Handshake</returns>
-        private static long GetBaseHandshakeForContext(TaskHostContext hostContext)
-        {
-            string salt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT") + BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
-            long nodeHandshakeSalt = GetHandshakeHashCode(salt);
-
-            Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", hostContext={2}, FileVersionHash={3}", Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT"), BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, hostContext, FileVersionHash);
-
-            //FileVersionHash (32 bits) is shifted 8 bits to avoid session ID collision
-            //hostContext (4 bits) is shifted just after the FileVersionHash
-            //nodeHandshakeSalt (32 bits) is shifted just after hostContext
-            //the most significant byte (leftmost 8 bits) will get zero'd out to avoid connecting to older builds.
-            //| masked out | nodeHandshakeSalt | hostContext |              fileVersionHash             | SessionID
-            //  0000 0000     0000 0000 0000        0000        0000 0000 0000 0000 0000 0000 0000 0000   0000 0000
-            long baseHandshake = (nodeHandshakeSalt << 44) | ((long)hostContext << 40) | ((long)FileVersionHash << 8);
-            return baseHandshake;
-        }
-
         /// <summary>
         /// Gets a hash code for this string.  If strings A and B are such that A.Equals(B), then
         /// they will return the same hash code.
@@ -677,7 +616,7 @@ private static long GetBaseHandshakeForContext(TaskHostContext hostContext)
         /// but stripped out architecture specific defines
         /// that causes the hashcode to be different and this causes problem in cross-architecture handshaking
         /// </summary>
-        private static int GetHandshakeHashCode(string fileVersion)
+        internal static int GetHandshakeHashCode(string fileVersion)
         {
             unsafe
             {
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index eb27fe8b372..14cf1d2d866 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -38,6 +38,16 @@ internal static bool ConvertStringToBool(string parameterValue)
             }
         }
 
+        internal static bool ConvertStringToBool(string parameterValue, bool nullOrWhitespaceIsFalse)
+        {
+            if (nullOrWhitespaceIsFalse && string.IsNullOrWhiteSpace(parameterValue))
+            {
+                return false;
+            }
+
+            return ConvertStringToBool(parameterValue);
+        }
+
         /// <summary>
         /// Returns a hex representation of a byte array.
         /// </summary>
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 9e170951cb3..641980fc490 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -84,6 +84,19 @@ internal static void ThrowInternalErrorUnreachable()
             }
         }
 
+        /// <summary>
+        /// Throws InternalErrorException. 
+        /// Indicates the code path followed should not have been possible.
+        /// This is only for situations that would mean that there is a bug in MSBuild itself.
+        /// </summary>
+        internal static void VerifyThrowInternalErrorUnreachable(bool condition)
+        {
+            if (s_throwExceptions && !condition)
+            {
+                throw new InternalErrorException("Unreachable?");
+            }
+        }
+
         /// <summary>
         /// Throws InternalErrorException. 
         /// Indicates the code path followed should not have been possible.
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index be4f2f5cd6e..a02cf5c4582 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -977,12 +977,21 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
         }
 
         /// <summary>
-        /// This method returns true if the specified filename is a solution file (.sln), otherwise
-        /// it returns false.
+        /// This method returns true if the specified filename is a solution file (.sln) or
+        /// solution filter file (.slnf); otherwise, it returns false.
         /// </summary>
+        /// <remarks>
+        /// Solution filters are included because they are a thin veneer over solutions, just
+        /// with a more limited set of projects to build, and should be treated the same way.
+        /// </remarks>
         internal static bool IsSolutionFilename(string filename)
         {
-            return HasExtension(filename, ".sln");
+            return HasExtension(filename, ".sln") || HasExtension(filename, ".slnf");
+        }
+
+        internal static bool IsSolutionFilterFilename(string filename)
+        {
+            return HasExtension(filename, ".slnf");
         }
 
         /// <summary>
diff --git a/src/Shared/IInternable.cs b/src/Shared/IInternable.cs
new file mode 100644
index 00000000000..f4f810f8f2e
--- /dev/null
+++ b/src/Shared/IInternable.cs
@@ -0,0 +1,341 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Text;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build
+{
+    #region IInternable
+    /// <summary>
+    /// Define the methods needed to intern something.
+    /// </summary>
+    internal interface IInternable
+    {
+        /// <summary>
+        /// The length of the target.
+        /// </summary>
+        int Length { get; }
+
+        /// <summary>
+        /// Indexer into the target. Presumed to be fast.
+        /// </summary>
+        char this[int index] { get; }
+
+        /// <summary>
+        /// Convert target to string. Presumed to be slow (and will be called just once).
+        /// </summary>
+        string ExpensiveConvertToString();
+
+        /// <summary>
+        /// Compare target to string. Assumes string is of equal or smaller length than target.
+        /// </summary>
+        bool StartsWithStringByOrdinalComparison(string other);
+
+        /// <summary>
+        /// Reference compare target to string. If target is non-string this should return false.
+        /// </summary>
+        bool ReferenceEquals(string other);
+    }
+    #endregion
+
+
+    #region IInternable Implementations
+    /// <summary>
+    /// A wrapper over StringBuilder.
+    /// </summary>
+    internal readonly struct StringBuilderInternTarget : IInternable
+    {
+        /// <summary>
+        /// The held StringBuilder
+        /// </summary>
+        private readonly StringBuilder _target;
+
+        /// <summary>
+        /// Pointless comment about constructor.
+        /// </summary>
+        internal StringBuilderInternTarget(StringBuilder target)
+        {
+            _target = target;
+        }
+
+        /// <summary>
+        /// The length of the target.
+        /// </summary>
+        public int Length => _target.Length;
+
+        /// <summary>
+        /// Indexer into the target. Presumed to be fast.
+        /// </summary>
+        public char this[int index] => _target[index];
+
+        /// <summary>
+        /// Never reference equals to string.
+        /// </summary>
+        public bool ReferenceEquals(string other) => false;
+
+        /// <summary>
+        /// Convert target to string. Presumed to be slow (and will be called just once).
+        /// </summary>
+        public string ExpensiveConvertToString()
+        {
+            // PERF NOTE: This will be an allocation hot-spot because the StringBuilder is finally determined to
+            // not be internable. There is still only one conversion of StringBuilder into string it has just
+            // moved into this single spot.
+            return _target.ToString();
+        }
+
+        /// <summary>
+        /// Compare target to string. Assumes string is of equal or smaller length than target.
+        /// </summary>
+        public bool StartsWithStringByOrdinalComparison(string other)
+        {
+#if DEBUG
+            ErrorUtilities.VerifyThrow(other.Length <= _target.Length, "should be at most as long as target");
+#endif
+            int length = other.Length;
+
+            // Backwards because the end of the string is more likely to be different earlier in the loop.
+            // For example, C:\project1, C:\project2
+            for (int i = length - 1; i >= 0; --i)
+            {
+                if (_target[i] != other[i])
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Don't use this function. Use ExpensiveConvertToString
+        /// </summary>
+        public override string ToString() => throw new InvalidOperationException();
+    }
+
+    /// <summary>
+    /// A wrapper over char[].
+    /// </summary>
+    internal readonly struct CharArrayInternTarget : IInternable
+    {
+        /// <summary>
+        /// Start index for the string
+        /// </summary>
+        private readonly int _startIndex;
+
+        /// <summary>
+        /// The held array
+        /// </summary>
+        private readonly char[] _target;
+
+        /// <summary>
+        /// Pointless comment about constructor.
+        /// </summary>
+        internal CharArrayInternTarget(char[] target, int count)
+            : this(target, 0, count)
+        {
+        }
+
+        /// <summary>
+        /// Pointless comment about constructor.
+        /// </summary>
+        internal CharArrayInternTarget(char[] target, int startIndex, int count)
+        {
+#if DEBUG
+            if (startIndex + count > target.Length)
+            {
+                ErrorUtilities.ThrowInternalError("wrong length");
+            }
+#endif
+            _target = target;
+            _startIndex = startIndex;
+            Length = count;
+        }
+
+        /// <summary>
+        /// The length of the target.
+        /// </summary>
+        public int Length { get; }
+
+        /// <summary>
+        /// Indexer into the target. Presumed to be fast.
+        /// </summary>
+        public char this[int index]
+        {
+            get
+            {
+                return _target[index + _startIndex];
+            }
+        }
+
+        /// <summary>
+        /// Convert target to string. Presumed to be slow (and will be called just once).
+        /// </summary>
+        public bool ReferenceEquals(string other)
+        {
+            return false;
+        }
+
+        /// <summary>
+        /// Convert target to string. Presumed to be slow (and will be called just once).
+        /// </summary>
+        public string ExpensiveConvertToString()
+        {
+            // PERF NOTE: This will be an allocation hot-spot because the char[] is finally determined to
+            // not be internable. There is still only one conversion of char[] into string it has just
+            // moved into this single spot.
+            return new string(_target, _startIndex, Length);
+        }
+
+        /// <summary>
+        /// Compare target to string. Assumes string is of equal or smaller length than target.
+        /// </summary>
+        public bool StartsWithStringByOrdinalComparison(string other)
+        {
+#if DEBUG
+            ErrorUtilities.VerifyThrow(other.Length <= Length, "should be at most as long as target");
+#endif
+            // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
+            // For example, C:\project1, C:\project2
+            for (int i = other.Length - 1; i >= 0; --i)
+            {
+                if (_target[i + _startIndex] != other[i])
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Don't use this function. Use ExpensiveConvertToString
+        /// </summary>
+        public override string ToString()
+        {
+            throw new InvalidOperationException();
+        }
+    }
+
+    /// <summary>
+    /// Wrapper over a string.
+    /// </summary>
+    internal readonly struct StringInternTarget : IInternable
+    {
+        /// <summary>
+        /// Stores the wrapped string.
+        /// </summary>
+        private readonly string _target;
+
+        /// <summary>
+        /// Constructor of the class
+        /// </summary>
+        /// <param name="target">The string to wrap</param>
+        internal StringInternTarget(string target)
+        {
+            ErrorUtilities.VerifyThrowArgumentLength(target, nameof(target));
+            _target = target;
+        }
+
+        /// <summary>
+        /// Gets the length of the target string.
+        /// </summary>
+        public int Length => _target.Length;
+
+        /// <summary>
+        /// Gets the n character in the target string.
+        /// </summary>
+        /// <param name="index">Index of the character to gather.</param>
+        /// <returns>The character in the position marked by index.</returns>
+        public char this[int index] => _target[index];
+
+        /// <summary>
+        /// Returns the target which is already a string.
+        /// </summary>
+        /// <returns>The target string.</returns>
+        public string ExpensiveConvertToString() => _target;
+
+        /// <summary>
+        /// Compare target to string. Assumes string is of equal or smaller length than target.
+        /// </summary>
+        /// <param name="other">The string to compare with the target.</param>
+        /// <returns>True if target starts with <paramref name="other"/>, false otherwise.</returns>
+        public bool StartsWithStringByOrdinalComparison(string other) => _target.StartsWith(other, StringComparison.Ordinal);
+
+        /// <summary>
+        /// Verifies if the reference of the target string is the same of the given string.
+        /// </summary>
+        /// <param name="other">The string reference to compare to.</param>
+        /// <returns>True if both references are equal, false otherwise.</returns>
+        public bool ReferenceEquals(string other) => ReferenceEquals(_target, other);
+    }
+
+    /// <summary>
+    /// Wrapper over a substring of a string.
+    /// </summary>
+    internal readonly struct SubstringInternTarget : IInternable
+    {
+        /// <summary>
+        /// Stores the wrapped string.
+        /// </summary>
+        private readonly string _target;
+
+        /// <summary>
+        /// Start index of the substring within the wrapped string.
+        /// </summary>
+        private readonly int _startIndex;
+
+        /// <summary>
+        /// Constructor of the class
+        /// </summary>
+        /// <param name="target">The string to wrap.</param>
+        /// <param name="startIndex">Start index of the substring within <paramref name="target"/>.</param>
+        /// <param name="length">Length of the substring.</param>
+        internal SubstringInternTarget(string target, int startIndex, int length)
+        {
+#if DEBUG
+            if (startIndex + length > target.Length)
+            {
+                ErrorUtilities.ThrowInternalError("wrong length");
+            }
+#endif
+            _target = target;
+            _startIndex = startIndex;
+            Length = length;
+        }
+
+        /// <summary>
+        /// Gets the length of the target substring.
+        /// </summary>
+        public int Length { get; }
+
+        /// <summary>
+        /// Gets the n character in the target substring.
+        /// </summary>
+        /// <param name="index">Index of the character to gather.</param>
+        /// <returns>The character in the position marked by index.</returns>
+        public char this[int index] => _target[index + _startIndex];
+
+        /// <summary>
+        /// Returns the target substring as a string.
+        /// </summary>
+        /// <returns>The substring.</returns>
+        public string ExpensiveConvertToString() => _target.Substring(_startIndex, Length);
+
+        /// <summary>
+        /// Compare target substring to a string. Assumes string is of equal or smaller length than the target substring.
+        /// </summary>
+        /// <param name="other">The string to compare with the target substring.</param>
+        /// <returns>True if target substring starts with <paramref name="other"/>, false otherwise.</returns>
+        public bool StartsWithStringByOrdinalComparison(string other) => (String.CompareOrdinal(_target, _startIndex, other, 0, other.Length) == 0);
+
+        /// <summary>
+        /// Never reference equals to string.
+        /// </summary>
+        public bool ReferenceEquals(string other) => false;
+    }
+
+    #endregion
+}
diff --git a/src/Shared/ITranslatable.cs b/src/Shared/ITranslatable.cs
index 1ddeb30a6f6..a235e30aa2e 100644
--- a/src/Shared/ITranslatable.cs
+++ b/src/Shared/ITranslatable.cs
@@ -3,13 +3,6 @@
 
 namespace Microsoft.Build.BackEnd
 {
-    /// <summary>
-    /// Delegate for users that want to translate an arbitrary structure that cannot implement <see cref="ITranslatable"/> (e.g. translating a complex collection)
-    /// </summary>
-    /// <param name="translator">the translator</param>
-    /// <param name="obj">the object to translate</param>
-    internal delegate void Translator<T>(ref T obj, ITranslator translator);
-
     /// <summary>
     /// An interface representing an object which may be serialized by the node packet serializer.
     /// </summary>
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 088ffef172d..47b7770b797 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -16,6 +16,13 @@ namespace Microsoft.Build.BackEnd
     /// <typeparam name="T">The type to be translated.</typeparam>
     internal delegate T NodePacketValueFactory<T>(ITranslator translator);
 
+    /// <summary>
+    /// Delegate for users that want to translate an arbitrary structure that doesn't implement <see cref="ITranslatable"/> (e.g. translating a complex collection)
+    /// </summary>
+    /// <param name="translator">the translator</param>
+    /// <param name="objectToTranslate">the object to translate</param>
+    internal delegate void ObjectTranslator<T>(ITranslator translator, ref T objectToTranslate);
+
     /// <summary>
     /// This delegate is used to create arbitrary collection types for serialization.
     /// </summary>
@@ -156,22 +163,22 @@ BinaryWriter Writer
         void Translate(ref HashSet<string> set);
 
         /// <summary>
-        /// Translates a list of T where T implements INodePacketTranslateable
+        /// Translates a list of T using an <see cref="ObjectTranslator{T}"/>
         /// </summary>
         /// <param name="list">The list to be translated.</param>
-        /// <param name="factory">factory to create type T</param>
+        /// <param name="objectTranslator">The translator to use for the items in the list</param>
         /// <typeparam name="T">A TaskItemType</typeparam>
-        void Translate<T>(ref List<T> list, NodePacketValueFactory<T> factory) where T : ITranslatable;
+        void Translate<T>(ref List<T> list, ObjectTranslator<T> objectTranslator);
 
         /// <summary>
-        /// Translates a list of T where T implements INodePacketTranslateable using a collection factory
+        /// Translates a list of T using an <see cref="ObjectTranslator{T}"/> anda collection factory
         /// </summary>
         /// <param name="list">The list to be translated.</param>
-        /// <param name="factory">factory to create type T</param>
+        /// <param name="objectTranslator">The translator to use for the items in the list</param>
         /// <typeparam name="T">An ITranslatable subtype</typeparam>
         /// <typeparam name="L">An IList subtype</typeparam>
         /// <param name="collectionFactory">factory to create a collection</param>
-        void Translate<T, L>(ref IList<T> list, NodePacketValueFactory<T> factory, NodePacketCollectionCreator<L> collectionFactory) where T : ITranslatable where L : IList<T>;
+        void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : IList<T>;
 
         /// <summary>
         /// Translates a DateTime.
@@ -240,16 +247,6 @@ BinaryWriter Writer
         void Translate<T>(ref T value)
             where T : ITranslatable, new();
 
-        /// <summary>
-        /// Translates an object implementing INodePacketTranslatable which does not expose a
-        /// public parameterless constructor.
-        /// </summary>
-        /// <typeparam name="T">The reference type.</typeparam>
-        /// <param name="value">The value to be translated.</param>
-        /// <param name="factory">The factory method used to instantiate values of type T.</param>
-        void Translate<T>(ref T value, NodePacketValueFactory<T> factory)
-            where T : ITranslatable;
-
         /// <summary>
         /// Translates a culture
         /// </summary>
@@ -271,13 +268,12 @@ void TranslateArray<T>(ref T[] array)
             where T : ITranslatable, new();
 
         /// <summary>
-        /// Translates an array of objects implementing INodePacketTranslatable requiring a factory to create.
+        /// Translates an array of objects using an <see cref="ObjectTranslator{T}"/>.
         /// </summary>
         /// <typeparam name="T">The reference type.</typeparam>
         /// <param name="array">The array to be translated.</param>
-        /// <param name="factory">The factory method used to instantiate values of type T.</param>
-        void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
-            where T : ITranslatable;
+        /// <param name="objectTranslator">The translator to use for the elements in the array.</param>
+        void TranslateArray<T>(ref T[] array, ObjectTranslator<T> objectTranslator);
 
         /// <summary>
         /// Translates a dictionary of { string, string }.
@@ -288,7 +284,7 @@ void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
 
         void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> collectionCreator);
 
-        void TranslateDictionary<K, V>(ref IDictionary<K, V> dictionary, Translator<K> keyTranslator, Translator<V> valueTranslator, NodePacketCollectionCreator<IDictionary<K, V>> dictionaryCreator);
+        void TranslateDictionary<K, V>(ref IDictionary<K, V> dictionary, ObjectTranslator<K> keyTranslator, ObjectTranslator<V> valueTranslator, NodePacketCollectionCreator<IDictionary<K, V>> dictionaryCreator);
 
         /// <summary>
         /// Translates a dictionary of { string, T }.  
@@ -296,9 +292,9 @@ void TranslateArray<T>(ref T[] array, NodePacketValueFactory<T> factory)
         /// <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
         /// <param name="dictionary">The dictionary to be translated.</param>
         /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
-        /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-        void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, NodePacketValueFactory<T> valueFactory)
-            where T : class, ITranslatable;
+        /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
+        void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityComparer<string> comparer, ObjectTranslator<T> objectTranslator)
+            where T : class;
 
         /// <summary>
         /// Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.
@@ -306,10 +302,10 @@ void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEqualityCompa
         /// <typeparam name="D">The reference type for the dictionary.</typeparam>
         /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
         /// <param name="dictionary">The dictionary to be translated.</param>
-        /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
-        void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory)
+        /// <param name="objectTranslator">The translator to use for the values in the dictionary.</param>
+        void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator)
             where D : IDictionary<string, T>, new()
-            where T : class, ITranslatable;
+            where T : class;
 
         /// <summary>
         /// Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.
@@ -317,11 +313,11 @@ void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> value
         /// <typeparam name="D">The reference type for the dictionary.</typeparam>
         /// <typeparam name="T">The reference type for values in the dictionary.</typeparam>
         /// <param name="dictionary">The dictionary to be translated.</param>
-        /// <param name="valueFactory">The factory used to instantiate values in the dictionary.</param>
+        /// <param name="objectTranslator">The translator to use for the values in the dictionary</param>
         /// <param name="collectionCreator">A factory used to create the dictionary.</param>
-        void TranslateDictionary<D, T>(ref D dictionary, NodePacketValueFactory<T> valueFactory, NodePacketCollectionCreator<D> collectionCreator)
+        void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<D> collectionCreator)
             where D : IDictionary<string, T>
-            where T : class, ITranslatable;
+            where T : class;
 
         /// <summary>
         /// Translates the boolean that says whether this value is null or not
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index c2f69cf67c5..6bc94246966 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -670,6 +670,11 @@ internal static string GetOSNameForExtensionsPath()
             return IsOSX ? "osx" : IsUnixLike ? "unix" : "windows";
         }
 
+        internal static bool OSUsesCaseSensitivePaths
+        {
+            get { return IsLinux; }
+        }
+
         /// <summary>
         /// The base directory for all framework paths in Mono
         /// </summary>
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 8278f878092..8f24e1c56c8 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -38,12 +38,12 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
     {
         #region Private Data
 
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
         /// <summary>
         /// The amount of time to wait for the client to connect to the host.
         /// </summary>
         private const int ClientConnectTimeout = 60000;
-#endif // NETCOREAPP2_1
+#endif // NETCOREAPP2_1 || MONO
 
         /// <summary>
         /// The size of the buffers to use for named pipes
@@ -401,7 +401,7 @@ private void PacketPumpProc()
                     try
                     {
                         long handshake = localReadPipe.ReadLongForHandshake(/* reject these leads */ new byte[] { 0x5F, 0x60 }, 0xFF /* this will disconnect the host; it expects leading 00 or F5 or 06 */
-#if NETCOREAPP2_1
+#if NETCOREAPP2_1 || MONO
                             , ClientConnectTimeout /* wait a long time for the handshake from this side */
 #endif
                             );
diff --git a/src/Shared/OpportunisticIntern.cs b/src/Shared/OpportunisticIntern.cs
index 7761a103d8d..6da9e42a34c 100644
--- a/src/Shared/OpportunisticIntern.cs
+++ b/src/Shared/OpportunisticIntern.cs
@@ -21,116 +21,138 @@ namespace Microsoft.Build
     ///
     ///     string interned = OpportunisticIntern.Intern(String.Join(",",someStrings));
     ///
-    /// This class uses heuristics to decide whether it will be efficient to intern a string or not. There is no
+    /// There are currently two underlying implementations. The new default one in WeakStringCacheInterner is based on weak GC handles.
+    /// The legacy one in BucketedPrioritizedStringList is available only as an escape hatch by setting an environment variable.
+    ///
+    /// The legacy implementation uses heuristics to decide whether it will be efficient to intern a string or not. There is no
     /// guarantee that a string will intern.
     ///
     /// The thresholds and sizes were determined by experimentation to give the best number of bytes saved
     /// at reasonable elapsed time cost.
+    ///
+    /// The new implementation interns all strings but maintains only weak references so it doesn't keep the strings alive.
     /// </summary>
-    internal static class OpportunisticIntern
+    internal sealed class OpportunisticIntern
     {
-        private static readonly bool s_useSimpleConcurrency = Traits.Instance.UseSimpleInternConcurrency;
+        /// <summary>
+        /// Defines the interner interface as we currently implement more than one.
+        /// </summary>
+        private interface IInternerImplementation
+        {
+            /// <summary>
+            /// Converts the given internable candidate to its string representation. Efficient implementions have side-effects
+            /// of caching the results to end up with as few duplicates on the managed heap as practical.
+            /// </summary>
+            string InterningToString<T>(T candidate) where T : IInternable;
+
+            /// <summary>
+            /// Prints implementation specific interning statistics to the console.
+            /// </summary>
+            /// <param name="heading">A string identifying the interner in the output.</param>
+            void ReportStatistics(string heading);
+        }
+
+        /// <summary>
+        /// The singleton instance of OpportunisticIntern.
+        /// </summary>
+        private static OpportunisticIntern _instance = new OpportunisticIntern();
+        internal static OpportunisticIntern Instance => _instance;
+
+        private readonly bool _useLegacyInterner = Traits.Instance.UseLegacyStringInterner;
+        private readonly bool _useSimpleConcurrency = Traits.Instance.UseSimpleInternConcurrency;
 
         /// <summary>
         /// The size of the small mru list.
         /// </summary>
-        private static readonly int s_smallMruSize = AssignViaEnvironment("MSBUILDSMALLINTERNSIZE", 50);
+        private readonly int _smallMruSize;
 
         /// <summary>
         /// The size of the large mru list.
         /// </summary>
-        private static readonly int s_largeMruSize = AssignViaEnvironment("MSBUILDLARGEINTERNSIZE", 100);
+        private readonly int _largeMruSize;
 
         /// <summary>
         /// The size of the huge mru list.
         /// </summary>
-        private static readonly int s_hugeMruSize = AssignViaEnvironment("MSBUILDHUGEINTERNSIZE", 100);
+        private readonly int _hugeMruSize;
 
         /// <summary>
         /// The smallest size a string can be to be considered small.
         /// </summary>
-        private static readonly int s_smallMruThreshold = AssignViaEnvironment("MSBUILDSMALLINTERNTHRESHOLD", 50);
+        private readonly int _smallMruThreshold;
 
         /// <summary>
         /// The smallest size a string can be to be considered large.
         /// </summary>
-        private static readonly int s_largeMruThreshold = AssignViaEnvironment("MSBUILDLARGEINTERNTHRESHOLD", 70);
+        private readonly int _largeMruThreshold;
 
         /// <summary>
         /// The smallest size a string can be to be considered huge.
         /// </summary>
-        private static readonly int s_hugeMruThreshold = AssignViaEnvironment("MSBUILDHUGEINTERNTHRESHOLD", 200);
+        private readonly int _hugeMruThreshold;
 
         /// <summary>
         /// The smallest size a string can be to be ginormous.
         /// 8K for large object heap.
         /// </summary>
-        private static readonly int s_ginormousThreshold = AssignViaEnvironment("MSBUILDGINORMOUSINTERNTHRESHOLD", 8000);
+        private readonly int _ginormousThreshold;
 
         /// <summary>
-        /// Manages the separate MRU lists.
+        /// The interner implementation in use.
         /// </summary>
-        private static BucketedPrioritizedStringList s_si = new BucketedPrioritizedStringList(/*gatherStatistics*/ false, s_smallMruSize, s_largeMruSize, s_hugeMruSize, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
+        private IInternerImplementation _interner;
 
         #region Statistics
         /// <summary>
         /// What if Mru lists were infinitely long?
         /// </summary>
-        private static BucketedPrioritizedStringList s_whatIfInfinite;
+        private BucketedPrioritizedStringList _whatIfInfinite;
 
         /// <summary>
         /// What if we doubled the size of the Mru lists?
         /// </summary>
-        private static BucketedPrioritizedStringList s_whatIfDoubled;
+        private BucketedPrioritizedStringList _whatIfDoubled;
 
         /// <summary>
         /// What if we halved the size of the Mru lists?
         /// </summary>
-        private static BucketedPrioritizedStringList s_whatIfHalved;
+        private BucketedPrioritizedStringList _whatIfHalved;
 
         /// <summary>
         /// What if the size of Mru lists was zero? (We still intern tiny strings in this case)
         /// </summary>
-        private static BucketedPrioritizedStringList s_whatIfZero;
+        private BucketedPrioritizedStringList _whatIfZero;
         #endregion
 
-        #region IInternable
+        private OpportunisticIntern()
+        {
+            _smallMruSize = AssignViaEnvironment("MSBUILDSMALLINTERNSIZE", 50);
+            _largeMruSize = AssignViaEnvironment("MSBUILDLARGEINTERNSIZE", 100);
+            _hugeMruSize = AssignViaEnvironment("MSBUILDHUGEINTERNSIZE", 100);
+            _smallMruThreshold = AssignViaEnvironment("MSBUILDSMALLINTERNTHRESHOLD", 50);
+            _largeMruThreshold = AssignViaEnvironment("MSBUILDLARGEINTERNTHRESHOLD", 70);
+            _hugeMruThreshold = AssignViaEnvironment("MSBUILDHUGEINTERNTHRESHOLD", 200);
+            _ginormousThreshold = AssignViaEnvironment("MSBUILDGINORMOUSINTERNTHRESHOLD", 8000);
+
+            _interner = _useLegacyInterner
+               ? (IInternerImplementation)new BucketedPrioritizedStringList(gatherStatistics: false, _smallMruSize, _largeMruSize, _hugeMruSize,
+                    _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency)
+               : (IInternerImplementation)new WeakStringCacheInterner(gatherStatistics: false);
+        }
+
         /// <summary>
-        /// Define the methods needed to intern something.
+        /// Recreates the singleton instance based on the current environment (test only).
         /// </summary>
-        internal interface IInternable
+        internal static void ResetForTests()
         {
-            /// <summary>
-            /// The length of the target.
-            /// </summary>
-            int Length { get; }
-
-            /// <summary>
-            /// Indexer into the target. Presumed to be fast.
-            /// </summary>
-            char this[int index] { get; }
-
-            /// <summary>
-            /// Convert target to string. Presumed to be slow (and will be called just once).
-            /// </summary>
-            string ExpensiveConvertToString();
-
-            /// <summary>
-            /// Compare target to string. Assumes string is of equal or smaller length than target.
-            /// </summary>
-            bool StartsWithStringByOrdinalComparison(string other);
-
-            /// <summary>
-            /// Reference compare target to string. If target is non-string this should return false.
-            /// </summary>
-            bool ReferenceEquals(string other);
+            Debug.Assert(BuildEnvironmentHelper.Instance.RunningTests);
+            _instance = new OpportunisticIntern();
         }
-        #endregion
 
         /// <summary>
         /// Assign an int from an environment variable. If its not present, use the default.
         /// </summary>
-        internal static int AssignViaEnvironment(string env, int @default)
+        private int AssignViaEnvironment(string env, int @default)
         {
             string threshold = Environment.GetEnvironmentVariable(env);
             if (!string.IsNullOrEmpty(threshold))
@@ -147,14 +169,21 @@ internal static int AssignViaEnvironment(string env, int @default)
         /// <summary>
         /// Turn on statistics gathering.
         /// </summary>
-        internal static void EnableStatisticsGathering()
+        internal void EnableStatisticsGathering()
         {
-            // Statistics include several 'what if' scenarios such as doubling the size of the MRU lists.
-            s_si = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize, s_largeMruSize, s_hugeMruSize, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
-            s_whatIfInfinite = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, int.MaxValue, int.MaxValue, int.MaxValue, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
-            s_whatIfDoubled = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize * 2, s_largeMruSize * 2, s_hugeMruSize * 2, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
-            s_whatIfHalved = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize / 2, s_largeMruSize / 2, s_hugeMruSize / 2, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
-            s_whatIfZero = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, 0, 0, 0, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
+            if (_useLegacyInterner)
+            {
+                // Statistics include several 'what if' scenarios such as doubling the size of the MRU lists.
+                _interner = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize, _largeMruSize, _hugeMruSize, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
+                _whatIfInfinite = new BucketedPrioritizedStringList(gatherStatistics: true, int.MaxValue, int.MaxValue, int.MaxValue, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
+                _whatIfDoubled = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize * 2, _largeMruSize * 2, _hugeMruSize * 2, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
+                _whatIfHalved = new BucketedPrioritizedStringList(gatherStatistics: true, _smallMruSize / 2, _largeMruSize / 2, _hugeMruSize / 2, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
+                _whatIfZero = new BucketedPrioritizedStringList(gatherStatistics: true, 0, 0, 0, _smallMruThreshold, _largeMruThreshold, _hugeMruThreshold, _ginormousThreshold, _useSimpleConcurrency);
+            }
+            else
+            {
+                _interner = new WeakStringCacheInterner(gatherStatistics: true);
+            }
         }
 
         /// <summary>
@@ -162,23 +191,7 @@ internal static void EnableStatisticsGathering()
         /// </summary>
         internal static string InternableToString<T>(T candidate) where T : IInternable
         {
-            if (s_whatIfInfinite != null)
-            {
-                s_whatIfInfinite.InterningToString(candidate);
-                s_whatIfDoubled.InterningToString(candidate);
-                s_whatIfHalved.InterningToString(candidate);
-                s_whatIfZero.InterningToString(candidate);
-            }
-
-            string result = s_si.InterningToString(candidate);
-#if DEBUG
-            string expected = candidate.ExpensiveConvertToString();
-            if (!String.Equals(result, expected))
-            {
-                ErrorUtilities.ThrowInternalError("Interned string {0} should have been {1}", result, expected);
-            }
-#endif
-            return result;
+            return Instance.InternableToStringImpl(candidate);
         }
 
         /// <summary>
@@ -186,7 +199,7 @@ internal static string InternableToString<T>(T candidate) where T : IInternable
         /// </summary>
         internal static string StringBuilderToString(StringBuilder candidate)
         {
-            return InternableToString(new StringBuilderInternTarget(candidate));
+            return Instance.InternableToStringImpl(new StringBuilderInternTarget(candidate));
         }
 
         /// <summary>
@@ -194,7 +207,7 @@ internal static string StringBuilderToString(StringBuilder candidate)
         /// </summary>
         internal static string CharArrayToString(char[] candidate, int count)
         {
-            return InternableToString(new CharArrayInternTarget(candidate, count));
+            return Instance.InternableToStringImpl(new CharArrayInternTarget(candidate, count));
         }
 
         /// <summary>
@@ -202,7 +215,7 @@ internal static string CharArrayToString(char[] candidate, int count)
         /// </summary>
         internal static string CharArrayToString(char[] candidate, int startIndex, int count)
         {
-            return InternableToString(new CharArrayInternTarget(candidate, startIndex, count));
+            return Instance.InternableToStringImpl(new CharArrayInternTarget(candidate, startIndex, count));
         }
 
         /// <summary>
@@ -212,330 +225,348 @@ internal static string CharArrayToString(char[] candidate, int startIndex, int c
         /// <returns>The interned string, or the same string if it could not be interned.</returns>
         internal static string InternStringIfPossible(string candidate)
         {
-            return InternableToString(new StringInternTarget(candidate));
+            return Instance.InternableToStringImpl(new StringInternTarget(candidate));
         }
 
         /// <summary>
-        /// Report statistics about interning. Don't call unless GatherStatistics has been called beforehand.
-        /// </summary>
-        internal static void ReportStatistics()
-        {
-            s_si.ReportStatistics("Main");
-            s_whatIfInfinite.ReportStatistics("if Infinite");
-            s_whatIfDoubled.ReportStatistics("if Doubled");
-            s_whatIfHalved.ReportStatistics("if Halved");
-            s_whatIfZero.ReportStatistics("if Zero");
-            Console.WriteLine(" * Even for MRU size of zero there will still be some intern hits because of the tiny ");
-            Console.WriteLine("   string matching (eg. 'true')");
-        }
-
-        #region IInternable Implementations
-        /// <summary>
-        /// A wrapper over StringBuilder.
+        /// Intern the given internable.
         /// </summary>
-        internal struct StringBuilderInternTarget : IInternable
+        private string InternableToStringImpl<T>(T candidate) where T : IInternable
         {
-            /// <summary>
-            /// The held StringBuilder
-            /// </summary>
-            private readonly StringBuilder _target;
-
-            /// <summary>
-            /// Pointless comment about constructor.
-            /// </summary>
-            internal StringBuilderInternTarget(StringBuilder target)
+            if (candidate.Length == 0)
             {
-                _target = target;
+                // As in the case that a property or itemlist has evaluated to empty.
+                return string.Empty;
             }
 
-            /// <summary>
-            /// The length of the target.
-            /// </summary>
-            public int Length => _target.Length;
-
-            /// <summary>
-            /// Indexer into the target. Presumed to be fast.
-            /// </summary>
-            public char this[int index] => _target[index];
-
-            /// <summary>
-            /// Never reference equals to string.
-            /// </summary>
-            public bool ReferenceEquals(string other) => false;
-
-            /// <summary>
-            /// Convert target to string. Presumed to be slow (and will be called just once).
-            /// </summary>
-            public string ExpensiveConvertToString()
+            if (_whatIfInfinite != null)
             {
-                // PERF NOTE: This will be an allocation hot-spot because the StringBuilder is finally determined to
-                // not be internable. There is still only one conversion of StringBuilder into string it has just
-                // moved into this single spot.
-                return _target.ToString();
+                _whatIfInfinite.InterningToString(candidate);
+                _whatIfDoubled.InterningToString(candidate);
+                _whatIfHalved.InterningToString(candidate);
+                _whatIfZero.InterningToString(candidate);
             }
 
-            /// <summary>
-            /// Compare target to string. Assumes string is of equal or smaller length than target.
-            /// </summary>
-            public bool StartsWithStringByOrdinalComparison(string other)
-            {
+            string result = _interner.InterningToString(candidate);
 #if DEBUG
-                ErrorUtilities.VerifyThrow(other.Length <= _target.Length, "should be at most as long as target");
-#endif
-                int length = other.Length;
-
-                // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
-                // For example, C:\project1, C:\project2
-                for (int i = length - 1; i >= 0; --i)
-                {
-                    if (_target[i] != other[i])
-                    {
-                        return false;
-                    }
-                }
-
-                return true;
+            string expected = candidate.ExpensiveConvertToString();
+            if (!String.Equals(result, expected))
+            {
+                ErrorUtilities.ThrowInternalError("Interned string {0} should have been {1}", result, expected);
             }
-
-            /// <summary>
-            /// Don't use this function. Use ExpensiveConvertToString
-            /// </summary>
-            public override string ToString() => throw new InvalidOperationException();
+#endif
+            return result;
         }
 
         /// <summary>
-        /// A wrapper over char[].
+        /// Report statistics about interning. Don't call unless GatherStatistics has been called beforehand.
         /// </summary>
-        internal struct CharArrayInternTarget : IInternable
+        internal void ReportStatistics()
         {
-            /// <summary>
-            /// Start index for the string
-            /// </summary>
-            private readonly int _startIndex;
-
-            /// <summary>
-            /// The held array
-            /// </summary>
-            private readonly char[] _target;
-
-            /// <summary>
-            /// Pointless comment about constructor.
-            /// </summary>
-            internal CharArrayInternTarget(char[] target, int count)
-                : this(target, 0, count)
+            _interner.ReportStatistics("Main");
+            if (_useLegacyInterner)
             {
+                _whatIfInfinite.ReportStatistics("if Infinite");
+                _whatIfDoubled.ReportStatistics("if Doubled");
+                _whatIfHalved.ReportStatistics("if Halved");
+                _whatIfZero.ReportStatistics("if Zero");
+                Console.WriteLine(" * Even for MRU size of zero there will still be some intern hits because of the tiny ");
+                Console.WriteLine("   string matching (eg. 'true')");
             }
+        }
 
-            /// <summary>
-            /// Pointless comment about constructor.
-            /// </summary>
-            internal CharArrayInternTarget(char[] target, int startIndex, int count)
+        private static bool TryInternHardcodedString<T>(T candidate, string str, ref string interned) where T : IInternable
+        {
+            Debug.Assert(candidate.Length == str.Length);
+
+            if (candidate.StartsWithStringByOrdinalComparison(str))
             {
-#if DEBUG
-                if (startIndex + count > target.Length)
-                {
-                    ErrorUtilities.ThrowInternalError("wrong length");
-                }
-#endif
-                _target = target;
-                _startIndex = startIndex;
-                Length = count;
+                interned = str;
+                return true;
             }
+            return false;
+        }
 
-            /// <summary>
-            /// The length of the target.
-            /// </summary>
-            public int Length { get; }
+        /// <summary>
+        /// Try to match the candidate with small number of hardcoded interned string literals.
+        /// The return value indicates how the string was interned (if at all).
+        /// </summary>
+        /// <returns>
+        /// True if the candidate matched a hardcoded literal, null if it matched a "do not intern" string, false otherwise.
+        /// </returns>
+        private static bool? TryMatchHardcodedStrings<T>(T candidate, out string interned) where T : IInternable
+        {
+            int length = candidate.Length;
+            interned = null;
 
-            /// <summary>
-            /// Indexer into the target. Presumed to be fast.
-            /// </summary>
-            public char this[int index]
+            // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.
+            if (length == 2)
             {
-                get
+                if (candidate[1] == '#')
                 {
-                    if (index > _startIndex + Length - 1 || index < 0)
+                    if (candidate[0] == 'C')
                     {
-                        ErrorUtilities.ThrowInternalError("past end");
+                        interned = "C#";
+                        return true;
                     }
 
-                    return _target[index + _startIndex];
+                    if (candidate[0] == 'F')
+                    {
+                        interned = "F#";
+                        return true;
+                    }
                 }
-            }
 
-            /// <summary>
-            /// Convert target to string. Presumed to be slow (and will be called just once).
-            /// </summary>
-            public bool ReferenceEquals(string other)
+                if (candidate[0] == 'V' && candidate[1] == 'B')
+                {
+                    interned = "VB";
+                    return true;
+                }
+            }
+            else if (length == 4)
             {
-                return false;
+                if (TryInternHardcodedString(candidate, "TRUE", ref interned) ||
+                    TryInternHardcodedString(candidate, "True", ref interned) ||
+                    TryInternHardcodedString(candidate, "Copy", ref interned) ||
+                    TryInternHardcodedString(candidate, "true", ref interned) ||
+                    TryInternHardcodedString(candidate, "v4.0", ref interned))
+                {
+                    return true;
+                }
             }
-
-            /// <summary>
-            /// Convert target to string. Presumed to be slow (and will be called just once).
-            /// </summary>
-            public string ExpensiveConvertToString()
+            else if (length == 5)
             {
-                // PERF NOTE: This will be an allocation hot-spot because the char[] is finally determined to
-                // not be internable. There is still only one conversion of char[] into string it has just
-                // moved into this single spot.
-                return new string(_target, _startIndex, Length);
+                if (TryInternHardcodedString(candidate, "FALSE", ref interned) ||
+                    TryInternHardcodedString(candidate, "false", ref interned) ||
+                    TryInternHardcodedString(candidate, "Debug", ref interned) ||
+                    TryInternHardcodedString(candidate, "Build", ref interned) ||
+                    TryInternHardcodedString(candidate, "Win32", ref interned))
+                {
+                    return true;
+                }
             }
-
-            /// <summary>
-            /// Compare target to string. Assumes string is of equal or smaller length than target.
-            /// </summary>
-            public bool StartsWithStringByOrdinalComparison(string other)
+            else if (length == 6)
             {
-#if DEBUG
-                ErrorUtilities.VerifyThrow(other.Length <= Length, "should be at most as long as target");
-#endif
-                // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
-                // For example, C:\project1, C:\project2
-                for (int i = other.Length - 1; i >= 0; --i)
+                if (TryInternHardcodedString(candidate, "''!=''", ref interned) ||
+                    TryInternHardcodedString(candidate, "AnyCPU", ref interned))
                 {
-                    if (_target[i + _startIndex] != other[i])
-                    {
-                        return false;
-                    }
+                    return true;
                 }
-
-                return true;
             }
-
-            /// <summary>
-            /// Don't use this function. Use ExpensiveConvertToString
-            /// </summary>
-            public override string ToString()
+            else if (length == 7)
             {
-                throw new InvalidOperationException();
+                if (TryInternHardcodedString(candidate, "Library", ref interned) ||
+                    TryInternHardcodedString(candidate, "MSBuild", ref interned) ||
+                    TryInternHardcodedString(candidate, "Release", ref interned))
+                {
+                    return true;
+                }
             }
+            // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty
+            else if (length > MSBuildConstants.MSBuildDummyGlobalPropertyHeader.Length &&
+                    candidate.StartsWithStringByOrdinalComparison(MSBuildConstants.MSBuildDummyGlobalPropertyHeader))
+            {
+                // don't want to leak unique strings into the cache
+                interned = candidate.ExpensiveConvertToString();
+                return null;
+            }
+            else if (length == 24)
+            {
+                if (TryInternHardcodedString(candidate, "ResolveAssemblyReference", ref interned))
+                {
+                    return true;
+                }
+            }
+            return false;
         }
 
         /// <summary>
-        /// Wrapper over a string.
+        /// Implements interning based on a WeakStringCache (new implementation).
         /// </summary>
-        internal struct StringInternTarget : IInternable
+        private class WeakStringCacheInterner : IInternerImplementation
         {
             /// <summary>
-            /// Stores the wrapped string.
+            /// Enumerates the possible interning results.
             /// </summary>
-            private readonly string _target;
+            private enum InternResult
+            {
+                MatchedHardcodedString,
+                FoundInWeakStringCache,
+                AddedToWeakStringCache,
+                RejectedFromInterning
+            }
 
             /// <summary>
-            /// Constructor of the class
+            /// The cache to keep strings in.
             /// </summary>
-            /// <param name="target">The string to wrap</param>
-            internal StringInternTarget(string target)
-            {
-                ErrorUtilities.VerifyThrowArgumentLength(target, nameof(target));
-                _target = target;
-            }
+            private readonly WeakStringCache _weakStringCache = new WeakStringCache();
 
+#region Statistics
             /// <summary>
-            /// Gets the length of the target string.
+            /// Whether or not to gather statistics.
             /// </summary>
-            public int Length => _target.Length;
+            private readonly bool _gatherStatistics;
 
             /// <summary>
-            /// Gets the n character in the target string.
+            /// Number of times interning with hardcoded string literals worked.
             /// </summary>
-            /// <param name="index">Index of the character to gather.</param>
-            /// <returns>The character in the position marked by index.</returns>
-            public char this[int index] => _target[index];
+            private int _hardcodedInternHits;
 
             /// <summary>
-            /// Returns the target which is already a string.
+            /// Number of times the regular interning path found the string in the cache.
             /// </summary>
-            /// <returns>The target string.</returns>
-            public string ExpensiveConvertToString() => _target;
+            private int _regularInternHits;
 
             /// <summary>
-            /// Compare target to string. Assumes string is of equal or smaller length than target.
+            /// Number of times the regular interning path added the string to the cache.
             /// </summary>
-            /// <param name="other">The string to compare with the target.</param>
-            /// <returns>True if target starts with <paramref name="other"/>, false otherwise.</returns>
-            public bool StartsWithStringByOrdinalComparison(string other) => _target.StartsWith(other, StringComparison.Ordinal);
+            private int _regularInternMisses;
 
             /// <summary>
-            /// Verifies if the reference of the target string is the same of the given string.
+            /// Number of times interning wasn't attempted.
             /// </summary>
-            /// <param name="other">The string reference to compare to.</param>
-            /// <returns>True if both references are equal, false otherwise.</returns>
-            public bool ReferenceEquals(string other) => ReferenceEquals(_target, other);
-        }
+            private int _rejectedStrings;
 
-        /// <summary>
-        /// Wrapper over a substring of a string.
-        /// </summary>
-        internal struct SubstringInternTarget : IInternable
-        {
             /// <summary>
-            /// Stores the wrapped string.
+            /// Total number of strings eliminated by interning.
             /// </summary>
-            private readonly string _target;
+            private int _internEliminatedStrings;
 
             /// <summary>
-            /// Start index of the substring within the wrapped string.
+            /// Total number of chars eliminated across all strings.
             /// </summary>
-            private readonly int _startIndex;
+            private int _internEliminatedChars;
 
             /// <summary>
-            /// Constructor of the class
+            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been
+            /// seen. The higher the number the better the payoff if the string had been hardcoded.
             /// </summary>
-            /// <param name="target">The string to wrap.</param>
-            /// <param name="startIndex">Start index of the substring within <paramref name="target"/>.</param>
-            /// <param name="length">Length of the substring.</param>
-            internal SubstringInternTarget(string target, int startIndex, int length)
+            private Dictionary<string, int> _missedHardcodedStrings;
+
+#endregion
+
+            public WeakStringCacheInterner(bool gatherStatistics)
             {
-#if DEBUG
-                if (startIndex + length > target.Length)
+                if (gatherStatistics)
                 {
-                    ErrorUtilities.ThrowInternalError("wrong length");
+                    _missedHardcodedStrings = new Dictionary<string, int>();
                 }
-#endif
-                _target = target;
-                _startIndex = startIndex;
-                Length = length;
+                _gatherStatistics = gatherStatistics;
             }
 
             /// <summary>
-            /// Gets the length of the target substring.
+            /// Intern the given internable.
             /// </summary>
-            public int Length { get; }
+            public string InterningToString<T>(T candidate) where T : IInternable
+            {
+                if (_gatherStatistics)
+                {
+                    return InternWithStatistics(candidate);
+                }
+                else
+                {
+                    TryIntern(candidate, out string result);
+                    return result;
+                }
+            }
 
             /// <summary>
-            /// Gets the n character in the target substring.
+            /// Report statistics to the console.
             /// </summary>
-            /// <param name="index">Index of the character to gather.</param>
-            /// <returns>The character in the position marked by index.</returns>
-            public char this[int index] => _target[index + _startIndex];
+            public void ReportStatistics(string heading)
+            {
+                string title = "Opportunistic Intern (" + heading + ")";
+                Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title);
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Hardcoded Hits", _hardcodedInternHits, "hits");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Hardcoded Rejects", _rejectedStrings, "rejects");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Hits", _regularInternHits, "hits");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Misses", _regularInternMisses, "misses");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes");
+                Console.WriteLine("Elimination assumes that strings provided were unique objects.");
+                Console.WriteLine("|---------------------------------------------------------------------------------|");
 
-            /// <summary>
-            /// Returns the target substring as a string.
-            /// </summary>
-            /// <returns>The substring.</returns>
-            public string ExpensiveConvertToString() => _target.Substring(_startIndex, Length);
+                IEnumerable<string> topMissingHardcodedString =
+                    _missedHardcodedStrings
+                    .OrderByDescending(kv => kv.Value * kv.Key.Length)
+                    .Take(15)
+                    .Where(kv => kv.Value > 1)
+                    .Select(kv => string.Format(CultureInfo.InvariantCulture, "({1} instances x each {2} chars)\n{0}", kv.Key, kv.Value, kv.Key.Length));
+
+                Console.WriteLine("##########Top Missing Hardcoded Strings:  \n{0} ", string.Join("\n==============\n", topMissingHardcodedString.ToArray()));
+                Console.WriteLine();
+
+                WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();
+                Console.WriteLine("WeakStringCache statistics:");
+                Console.WriteLine("String count live/collected/total = {0}/{1}/{2}", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount);
+            }
 
             /// <summary>
-            /// Compare target substring to a string. Assumes string is of equal or smaller length than the target substring.
+            /// Try to intern the string.
+            /// The return value indicates the how the string was interned (if at all).
             /// </summary>
-            /// <param name="other">The string to compare with the target substring.</param>
-            /// <returns>True if target substring starts with <paramref name="other"/>, false otherwise.</returns>
-            public bool StartsWithStringByOrdinalComparison(string other) => (String.CompareOrdinal(_target, _startIndex, other, 0, other.Length) == 0);
+            private InternResult TryIntern<T>(T candidate, out string interned) where T : IInternable
+            {
+                // First, try the hard coded intern strings.
+                bool? hardcodedMatchResult = TryMatchHardcodedStrings(candidate, out interned);
+                if (hardcodedMatchResult != false)
+                {
+                    // Either matched a hardcoded string or is explicitly not to be interned.
+                    return hardcodedMatchResult.HasValue ? InternResult.MatchedHardcodedString : InternResult.RejectedFromInterning;
+                }
+
+                interned = _weakStringCache.GetOrCreateEntry(candidate, out bool cacheHit);
+                return cacheHit ? InternResult.FoundInWeakStringCache : InternResult.AddedToWeakStringCache;
+            }
 
             /// <summary>
-            /// Never reference equals to string.
+            /// Version of Intern that gathers statistics
             /// </summary>
-            public bool ReferenceEquals(string other) => false;
-        }
+            private string InternWithStatistics<T>(T candidate) where T : IInternable
+            {
+                lock (_missedHardcodedStrings)
+                {
+                    InternResult internResult = TryIntern(candidate, out string result);
 
-        #endregion
+                    switch (internResult)
+                    {
+                        case InternResult.MatchedHardcodedString:
+                            _hardcodedInternHits++;
+                            break;
+                        case InternResult.FoundInWeakStringCache:
+                            _regularInternHits++;
+                            break;
+                        case InternResult.AddedToWeakStringCache:
+                            _regularInternMisses++;
+                            break;
+                        case InternResult.RejectedFromInterning:
+                            _rejectedStrings++;
+                            break;
+                    }
+
+                    if (internResult != InternResult.MatchedHardcodedString && internResult != InternResult.RejectedFromInterning)
+                    {
+                        _missedHardcodedStrings.TryGetValue(result, out int priorCount);
+                        _missedHardcodedStrings[result] = priorCount + 1;
+                    }
+
+                    if (!candidate.ReferenceEquals(result))
+                    {
+                        // Reference changed so 'candidate' is now released and should save memory.
+                        _internEliminatedStrings++;
+                        _internEliminatedChars += candidate.Length;
+                    }
+
+                    return result;
+                }
+            }
+        }
 
         /// <summary>
-        /// Manages a set of mru lists that hold strings in varying size ranges.
+        /// Manages a set of mru lists that hold strings in varying size ranges (legacy implementation).
         /// </summary>
-        private class BucketedPrioritizedStringList
+        private class BucketedPrioritizedStringList : IInternerImplementation
         {
             /// <summary>
             /// The small string Mru list.
@@ -588,7 +619,7 @@ private class BucketedPrioritizedStringList
             private readonly ConcurrentDictionary<string, string> _internedStrings = new ConcurrentDictionary<string, string>(Environment.ProcessorCount, InitialCapacity, StringComparer.Ordinal);
 #endif
 
-            #region Statistics
+#region Statistics
             /// <summary>
             /// Whether or not to gather statistics
             /// </summary>
@@ -661,7 +692,7 @@ private class BucketedPrioritizedStringList
             /// </summary>
             private const int GinormousSize = 10;
 
-            #endregion
+#endregion
 
             /// <summary>
             /// Construct.
@@ -699,14 +730,8 @@ internal BucketedPrioritizedStringList(bool gatherStatistics, int smallMruSize,
             /// <summary>
             /// Intern the given internable.
             /// </summary>
-            internal string InterningToString<T>(T candidate) where T : IInternable
+            public string InterningToString<T>(T candidate) where T : IInternable
             {
-                if (candidate.Length == 0)
-                {
-                    // As in the case that a property or itemlist has evaluated to empty.
-                    return string.Empty;
-                }
-
                 if (_gatherStatistics)
                 {
                     return InternWithStatistics(candidate);
@@ -721,30 +746,30 @@ internal string InterningToString<T>(T candidate) where T : IInternable
             /// <summary>
             /// Report statistics to the console.
             /// </summary>
-            internal void ReportStatistics(string heading)
+            public void ReportStatistics(string heading)
             {
                 string title = "Opportunistic Intern (" + heading + ")";
                 Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title);
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Hits", _internHits, "hits");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Misses", _internMisses, "misses");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Rejects (as shorter than " + s_smallMruThreshold + " bytes)", _internRejects, "rejects");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Rejects (as shorter than " + _smallMruThreshold + " bytes)", _internRejects, "rejects");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes");
                 Console.WriteLine("Elimination assumes that strings provided were unique objects.");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
                 KeyValuePair<int, int> held = _smallMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings MRU Size", s_smallMruSize, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings MRU Size", Instance._smallMruSize, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings (>=" + _smallMruThreshold + " chars) Held", held.Key, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Estimated Bytes Held", held.Value * 2, "bytes");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
                 held = _largeMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings MRU Size", s_largeMruSize, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings MRU Size", Instance._largeMruSize, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings  (>=" + _largeMruThreshold + " chars) Held", held.Key, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Estimated Bytes Held", held.Value * 2, "bytes");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
                 held = _hugeMru.Statistics();
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings MRU Size", s_hugeMruSize, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings MRU Size", Instance._hugeMruSize, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings  (>=" + _hugeMruThreshold + " chars) Held", held.Key, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Estimated Bytes Held", held.Value * 2, "bytes");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
@@ -778,18 +803,6 @@ internal void ReportStatistics(string heading)
                 Console.WriteLine("##########Top Rejected Strings: \n{0} ", string.Join("\n==============\n", topRejectedString.ToArray()));
             }
 
-            private bool TryInternHardcodedString<T>(T candidate, string str, ref string interned) where T : IInternable
-            {
-                Debug.Assert(candidate.Length == str.Length);
-
-                if (candidate.StartsWithStringByOrdinalComparison(str))
-                {
-                    interned = str;
-                    return true;
-                }
-                return false;
-            }
-
             /// <summary>
             /// Try to intern the string.
             /// Return true if an interned value could be returned.
@@ -805,84 +818,14 @@ private bool TryInternHardcodedString<T>(T candidate, string str, ref string int
                 // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.
                 if (!_dontTrack)
                 {
-                    if (length == 2)
-                    {
-                        if (candidate[1] == '#')
-                        {
-                            if (candidate[0] == 'C')
-                            {
-                                interned = "C#";
-                                return true;
-                            }
-
-                            if (candidate[0] == 'F')
-                            {
-                                interned = "F#";
-                                return true;
-                            }
-                        }
-
-                        if (candidate[0] == 'V' && candidate[1] == 'B')
-                        {
-                            interned = "VB";
-                            return true;
-                        }
-                    }
-                    else if (length == 4)
+                    bool? hardcodedMatchResult = TryMatchHardcodedStrings(candidate, out interned);
+                    if (hardcodedMatchResult != false)
                     {
-                        if (TryInternHardcodedString(candidate, "TRUE", ref interned) ||
-                            TryInternHardcodedString(candidate, "True", ref interned) ||
-                            TryInternHardcodedString(candidate, "Copy", ref interned) ||
-                            TryInternHardcodedString(candidate, "true", ref interned) ||
-                            TryInternHardcodedString(candidate, "v4.0", ref interned))
-                        {
-                            return true;
-                        }
+                        // Either matched a hardcoded string or is explicitly not to be interned.
+                        return hardcodedMatchResult;
                     }
-                    else if (length == 5)
-                    {
-                        if (TryInternHardcodedString(candidate, "FALSE", ref interned) ||
-                            TryInternHardcodedString(candidate, "false", ref interned) ||
-                            TryInternHardcodedString(candidate, "Debug", ref interned) ||
-                            TryInternHardcodedString(candidate, "Build", ref interned) ||
-                            TryInternHardcodedString(candidate, "Win32", ref interned))
-                        {
-                            return true;
-                        }
-                    }
-                    else if (length == 6)
-                    {
-                        if (TryInternHardcodedString(candidate, "''!=''", ref interned) ||
-                            TryInternHardcodedString(candidate, "AnyCPU", ref interned))
-                        {
-                            return true;
-                        }
-                    }
-                    else if (length == 7)
-                    {
-                        if (TryInternHardcodedString(candidate, "Library", ref interned) ||
-                            TryInternHardcodedString(candidate, "MSBuild", ref interned) ||
-                            TryInternHardcodedString(candidate, "Release", ref interned))
-                        {
-                            return true;
-                        }
-                    }
-                    // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty
-                    else if (length > MSBuildConstants.MSBuildDummyGlobalPropertyHeader.Length &&
-                            candidate.StartsWithStringByOrdinalComparison(MSBuildConstants.MSBuildDummyGlobalPropertyHeader))
-                    {
-                        // don't want to leak unique strings into the cache
-                        interned = candidate.ExpensiveConvertToString();
-                        return null;
-                    }
-                    else if (length == 24)
-                    {
-                        if (TryInternHardcodedString(candidate, "ResolveAssemblyReference", ref interned))
-                        {
-                            return true;
-                        }
-                    }
-                    else if (length > _ginormousThreshold)
+
+                    if (length > _ginormousThreshold)
                     {
                         lock (_ginormous)
                         {
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index 9e49658e8b4..9c6f2361554 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -77,6 +77,29 @@ params object[] args
             VerifyThrowInvalidProjectFile(condition, null, projectFile, resourceName, args);
         }
 
+        /// <summary>
+        /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
+        /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
+        /// 
+        /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
+        /// </summary>
+        /// <param name="condition">The condition to check.</param>
+        /// <param name="errorSubCategoryResourceName">The resource string for the error sub-category (can be null).</param>
+        /// <param name="projectFile">The invalid project file.</param>
+        /// <param name="resourceName">The resource string for the error message.</param>
+        /// <param name="args">Extra arguments for formatting the error message.</param>
+        internal static void ThrowInvalidProjectFile
+        (
+            string errorSubCategoryResourceName,
+            BuildEventFileInfo projectFile,
+            string resourceName,
+            params object[] args
+        )
+        {
+            VerifyThrowInvalidProjectFile(false, errorSubCategoryResourceName, projectFile, null, resourceName, args);
+        }
+
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index ad6b7925fc1..fd568252430 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -262,10 +262,22 @@
     <value>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</value>
     <comment></comment>
   </data>
+  <data name="SolutionFilterJsonParsingError" Visibility="Public">
+    <value>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</value>
+    <comment>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</comment>
+  </data>
+  <data name="SolutionFilterMissingSolutionError" Visibility="Public">
+    <value>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</value>
+    <comment>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</comment>
+  </data>
+  <data name="SolutionFilterFilterContainsProjectNotInSolution" Visibility="Public">
+    <value>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</value>
+    <comment>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</comment>
+  </data>
   <!--
         The shared message bucket is: MSB5001 - MSB5999
 
-        Next message code should be MSB5025
+        Next message code should be MSB5029
 
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 5d65ee0a93b..00a783fd1db 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Cesta: {0} pekrauje maximln limit pro cestu k OS. Pln kvalifikovan nzev souboru mus bt krat ne {1} znak.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Verze nstroj {0} je neznm. Dostupn verze nstroj jsou {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 0a0fce1dbb9..e3bd8284ae0 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Der Pfad "{0}" berschreitet das maximale Pfadlimit des Betriebssystems. Der vollqualifizierte Dateiname muss weniger als {1} Zeichen umfassen.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Die Toolsversion "{0}" ist unbekannt. Verfgbare Toolversionen sind {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.en.xlf b/src/Shared/Resources/xlf/Strings.shared.en.xlf
index 89e1330b798..cf10e5c095a 100644
--- a/src/Shared/Resources/xlf/Strings.shared.en.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.en.xlf
@@ -70,6 +70,21 @@
         <target state="new">Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 62c0b3ef027..0860cf5f017 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -65,6 +65,21 @@
         <target state="translated">La ruta de acceso {0} supera el lmite mximo para la ruta de acceso del sistema operativo. El nombre de archivo completo debe ser inferior a {1} caracteres.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: No se reconoce la versin de herramientas "{0}". Las versiones de herramientas disponibles son {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 09edfc73b93..b0ee0eaf271 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Le chemin {0} dpasse la limite maximale de chemin du systme d'exploitation. Le nom du fichier qualifi complet doit contenir moins de {1} caractres.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: La version des outils "{0}" n'est pas reconnue. Les versions disponibles sont {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 33fb3b72d80..fa13a591797 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Il percorso {0} supera il limite massimo dei percorsi del sistema operativo. Il nome completo del file deve essere composto da meno di {1}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: versione degli strumenti "{0}" non riconosciuta. Le versioni disponibili sono {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index d38f7aba8ed..d4c5be36d60 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -4,47 +4,67 @@
     <body>
       <trans-unit id="BuildAborted">
         <source>MSB4188: Build was canceled.</source>
-        <target state="translated">MSB4188: </target>
+        <target state="new">MSB4188: Build was canceled.</target>
         <note>{StrBegin="MSB4188: "} Error when the build stops suddenly for some reason. For example, because a child node died.</note>
       </trans-unit>
       <trans-unit id="BuildEngineCallbacksInTaskHostUnsupported">
         <source>MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</source>
-        <target state="translated">MSB5022: MSBuild  IBuildEngine  MSBuild UsingTask  "Runtime"  "Architecture"  "MSBuildRuntime"  "MSBuildArchitecture"  MSBuild  </target>
+        <target state="new">MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</target>
         <note>{StrBegin="MSB5022: "} "Runtime", "Architecture", "MSBuildRuntime", and "MSBuildArchitecture" are all attributes in the project file, and thus should not be localized.</note>
       </trans-unit>
       <trans-unit id="BuildStarted">
         <source>Build started.</source>
-        <target state="translated"></target>
+        <target state="new">Build started.</target>
         <note />
       </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
-        <target state="translated">MSB4008:   "{0}"  "{1}" </target>
+        <target state="new">MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DirectoryNotFound">
+        <source>Could not find directory path: {0}</source>
+        <target state="new">Could not find directory path: {0}</target>
+        <note>Directory must exist</note>
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
-        <target state="translated"> "{0}"  .NET </target>
+        <target state="new">Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</target>
         <note />
       </trans-unit>
       <trans-unit id="FileLocation">
         <source>{0} ({1},{2})</source>
-        <target state="translated">{0} ({1},{2})</target>
+        <target state="new">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
-        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
-        <target state="translated"> :</target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
+        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
+        <target state="new">When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</target>
+        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
-        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
-        <target state="translated">  '{0}'  '{2}'  '{1}' </target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
+        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
+        <target state="new">.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
+        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
+        <target state="new">.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
+        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
+        <target state="new">Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="InvalidLogFileFormat">
+        <source>MSB4233: There was an exception while reading the log file: {0}</source>
+        <target state="new">MSB4233: There was an exception while reading the log file: {0}</target>
+        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
       </trans-unit>
       <trans-unit id="InvalidProjectFile">
         <source>MSB4025: The project file could not be loaded. {0}</source>
-        <target state="translated">MSB4025:  {0}</target>
+        <target state="new">MSB4025: The project file could not be loaded. {0}</target>
         <note>{StrBegin="MSB4025: "}UE: This message is shown when the project file given to the engine cannot be loaded because the filename/path is
     invalid, or due to lack of permissions, or incorrect XML. The project filename is not part of the message because it is
     provided separately to loggers.
@@ -52,241 +72,236 @@
       </trans-unit>
       <trans-unit id="InvalidVerbosity">
         <source>MSB4103: "{0}" is not a valid logger verbosity level.</source>
-        <target state="translated">MSB4103: "{0}" </target>
+        <target state="new">MSB4103: "{0}" is not a valid logger verbosity level.</target>
         <note>{StrBegin="MSB4103: "}</note>
       </trans-unit>
       <trans-unit id="MissingProject">
         <source>MSBuild is expecting a valid "{0}" object.</source>
-        <target state="translated">MSBuild  "{0}" </target>
+        <target state="new">MSBuild is expecting a valid "{0}" object.</target>
         <note />
       </trans-unit>
-      <trans-unit id="Shared.PathTooLong">
-        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
-        <target state="translated">: {0}  OS  {1} </target>
-        <note />
+      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
+        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
+        <target state="new">Making the following modifications to the environment received from the parent node before applying it to the task host:</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
-      <trans-unit id="UnrecognizedToolsVersion">
-        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
-        <target state="translated">MSB4132:   "{0}"   {1} </target>
-        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
+      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
+        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
+        <target state="new">  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
       <trans-unit id="NameInvalid">
         <source>MSB5016: The name "{0}" contains an invalid character "{1}".</source>
-        <target state="translated">MSB5016:  "{0}"  "{1}" </target>
+        <target state="new">MSB5016: The name "{0}" contains an invalid character "{1}".</target>
         <note>{StrBegin="MSB5016: "}</note>
       </trans-unit>
+      <trans-unit id="OM_NotSupportedReadOnlyCollection">
+        <source>This collection is read-only.</source>
+        <target state="new">This collection is read-only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
+        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
+        <target state="new">MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</target>
+        <note>{StrBegin="MSB5024: "}</note>
+      </trans-unit>
       <trans-unit id="Shared.CannotChangeItemSpecModifiers">
         <source>"{0}" is a reserved item metadata, and cannot be modified or deleted.</source>
-        <target state="translated">"{0}" </target>
+        <target state="new">"{0}" is a reserved item metadata, and cannot be modified or deleted.</target>
         <note>UE: Tasks and OM users are not allowed to remove or change the value of the built-in metadata on items e.g. the meta-data "FullPath", "RelativeDir", etc. are reserved.</note>
       </trans-unit>
       <trans-unit id="Shared.CannotConvertStringToBool">
         <source>The string "{0}" cannot be converted to a boolean (true/false) value.</source>
-        <target state="translated"> "{0}"  (true/false) </target>
+        <target state="new">The string "{0}" cannot be converted to a boolean (true/false) value.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.FailedCreatingTempFile">
         <source>MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</source>
-        <target state="translated">MSB5003:  {0}</target>
+        <target state="new">MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</target>
         <note>{StrBegin="MSB5003: "}</note>
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1}</source>
-        <target state="translated">MSB5018:  "{0}" {1}</target>
+        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
         <source>The item metadata "%({0})" cannot be applied to the path "{1}". {2}</source>
-        <target state="translated"> "%({0})"  "{1}" {2}</target>
+        <target state="new">The item metadata "%({0})" cannot be applied to the path "{1}". {2}</target>
         <note>UE: This message is shown when the user tries to perform path manipulations using one of the built-in item metadata e.g. %(RootDir), on an item-spec that's not a valid path. LOCALIZATION: "{2}" is a localized message from a CLR/FX exception.</note>
       </trans-unit>
-      <trans-unit id="TaskNotMarshalByRef">
-        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="translated">MSB4077: "{0}"  LoadInSeparateAppDomain MarshalByRefObject  MarshalByRefObject  AppDomainIsolatedTask </target>
-        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
-        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
-        <target state="translated">.NET Framework  "{0}"  Microsoft.Build.Utilities.TargetDotNetFrameworkVersion </target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
-        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
-        <target state="translated">Windows SDK .NET Framework  "{0}" Windows SDK .NET 4.5  Microsoft.Build.Utilities.TargetDotNetFrameworkVersion  Version45 </target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
-        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
-        <target state="translated">Visual Studio  "{0}"  Microsoft.Build.Utilities.VisualStudioVersion </target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
-        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
-        <target state="translated">  "{0}"   "{1}" {2}</target>
-        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
-      </trans-unit>
-      <trans-unit id="DirectoryNotFound">
-        <source>Could not find directory path: {0}</source>
-        <target state="translated"> : {0}</target>
-        <note>Directory must exist</note>
-      </trans-unit>
-      <trans-unit id="UnauthorizedAccess">
-        <source>You do not have access to: {0}</source>
-        <target state="translated">{0} </target>
-        <note>Directory must have access</note>
-      </trans-unit>
-      <trans-unit id="SubCategoryForSchemaValidationErrors">
-        <source>Schema validation</source>
-        <target state="translated"></target>
-        <note>
-      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
-      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
-      "MSBUILD : Schema validation error MSB0000: This is an error."
-      LOCALIZATION: This fragment needs to be localized.
-    </note>
+      <trans-unit id="Shared.InvalidProjectFile">
+        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
+        <target state="new">MSB5019: The project file is malformed: "{0}". {1}</target>
+        <note>{StrBegin="MSB5019: "}</note>
       </trans-unit>
       <trans-unit id="Shared.KillingProcess">
         <source>MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</source>
-        <target state="translated">MSB5002:  "{0}"  ({1} ) </target>
+        <target state="new">MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</target>
         <note>{StrBegin="MSB5002: "}</note>
       </trans-unit>
+      <trans-unit id="Shared.KillingProcessByCancellation">
+        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
+        <target state="new">MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</target>
+        <note>{StrBegin="MSB5021: "}</note>
+      </trans-unit>
       <trans-unit id="Shared.ParameterCannotBeNull">
         <source>Parameter "{0}" cannot be null.</source>
-        <target state="translated"> "{0}"  null </target>
+        <target state="new">Parameter "{0}" cannot be null.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
+        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
+        <target state="new">Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParameterCannotHaveZeroLength">
         <source>Parameter "{0}" cannot have zero length.</source>
-        <target state="translated"> "{0}"  0 </target>
+        <target state="new">Parameter "{0}" cannot have zero length.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParametersMustHaveTheSameLength">
         <source>Parameters "{0}" and "{1}" must have the same number of elements.</source>
-        <target state="translated"> "{0}"  "{1}" </target>
+        <target state="new">Parameters "{0}" and "{1}" must have the same number of elements.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Shared.PathTooLong">
+        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
+        <target state="new">Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
+        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
+        <target state="new">MSB5020: Could not load the project file: "{0}". {1}</target>
+        <note>{StrBegin="MSB5020: "}</note>
+      </trans-unit>
       <trans-unit id="Shared.TaskResourceNotFound">
         <source>The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</source>
-        <target state="translated">"{1}"  "{0}"  "{0}" </target>
+        <target state="new">The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.TaskResourcesNotRegistered">
         <source>The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</source>
-        <target state="translated">"{0}" "TaskLoggingHelper.FormatResourceString()"  "TaskResources" </target>
+        <target state="new">The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</target>
         <note>LOCALIZATION: "TaskLoggingHelper.FormatResourceString()" and "TaskResources" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="SolutionParseDuplicateProject">
         <source>MSB5004: The solution file has two projects named "{0}".</source>
-        <target state="translated">MSB5004:   "{0}"  2 </target>
+        <target state="new">MSB5004: The solution file has two projects named "{0}".</target>
         <note>{StrBegin="MSB5004: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameCharacters">
         <source>MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</source>
-        <target state="translated">MSB5005:  "{0}"   "{1}" </target>
+        <target state="new">MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</target>
         <note>{StrBegin="MSB5005: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameEmpty">
         <source>MSB5006: Error parsing project section for project "{0}". The project file name is empty.</source>
-        <target state="translated">MSB5006:  "{0}"  </target>
+        <target state="new">MSB5006: Error parsing project section for project "{0}". The project file name is empty.</target>
         <note>{StrBegin="MSB5006: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectSolutionConfigurationEntry">
         <source>MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="translated">MSB5007:   "{0}" </target>
+        <target state="new">MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</target>
         <note>{StrBegin="MSB5007: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidSolutionConfigurationEntry">
         <source>MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="translated">MSB5008:   "{0}" </target>
+        <target state="new">MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</target>
         <note>{StrBegin="MSB5008: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009:   </target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
         <source>MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</source>
-        <target state="translated">MSB5023:   GUID "{0}"  "{1}" </target>
+        <target state="new">MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</target>
         <note>{StrBegin="MSB5023: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNoHeaderError">
         <source>MSB5010: No file format header found.</source>
-        <target state="translated">MSB5010: </target>
+        <target state="new">MSB5010: No file format header found.</target>
         <note>{StrBegin="MSB5010: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectDepGuidError">
         <source>MSB5011: Parent project GUID not found in "{0}" project dependency section.</source>
-        <target state="translated">MSB5011:  GUID  "{0}" </target>
+        <target state="new">MSB5011: Parent project GUID not found in "{0}" project dependency section.</target>
         <note>{StrBegin="MSB5011: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectEofError">
         <source>MSB5012: Unexpected end-of-file reached inside "{0}" project section.</source>
-        <target state="translated">MSB5012: "{0}"   EOF </target>
+        <target state="new">MSB5012: Unexpected end-of-file reached inside "{0}" project section.</target>
         <note>{StrBegin="MSB5012: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectError">
         <source>MSB5013: Error parsing a project section.</source>
-        <target state="translated">MSB5013:  </target>
+        <target state="new">MSB5013: Error parsing a project section.</target>
         <note>{StrBegin="MSB5013: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseVersionMismatchError">
         <source>MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</source>
-        <target state="translated">MSB5014: MSBuild  {0}.0  {1}.0  </target>
+        <target state="new">MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</target>
         <note>{StrBegin="MSB5014: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseWebProjectPropertiesError">
         <source>MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</source>
-        <target state="translated">MSB5015: "{0}"  WebsiteProperties </target>
+        <target state="new">MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</target>
         <note>{StrBegin="MSB5015: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
-      <trans-unit id="UnrecognizedSolutionComment">
-        <source>Unrecognized solution version "{0}", attempting to continue.</source>
-        <target state="translated">"{0}"  </target>
-        <note />
+      <trans-unit id="SubCategoryForSchemaValidationErrors">
+        <source>Schema validation</source>
+        <target state="new">Schema validation</target>
+        <note>
+      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
+      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
+      "MSBUILD : Schema validation error MSB0000: This is an error."
+      LOCALIZATION: This fragment needs to be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SubCategoryForSolutionParsingErrors">
         <source>Solution file</source>
-        <target state="translated"> </target>
+        <target state="new">Solution file</target>
         <note>UE: this fragment is used to describe errors found while parsing solution files. For example, if a normal error is
       displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from solution parsing would look like this:
       "MSBUILD : Solution file error MSB0000: This is an error."
       LOCALIZATION: This fragment needs to be localized.</note>
       </trans-unit>
-      <trans-unit id="Shared.InvalidProjectFile">
-        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
-        <target state="translated">MSB5019:  : "{0}"{1}</target>
-        <note>{StrBegin="MSB5019: "}</note>
-      </trans-unit>
-      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
-        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
-        <target state="translated">MSB5020:   "{0}" {1}</target>
-        <note>{StrBegin="MSB5020: "}</note>
+      <trans-unit id="TaskNotMarshalByRef">
+        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
+        <target state="new">MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</target>
+        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
       </trans-unit>
-      <trans-unit id="Shared.KillingProcessByCancellation">
-        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
-        <target state="translated">MSB5021:  "{0}" </target>
-        <note>{StrBegin="MSB5021: "}</note>
+      <trans-unit id="UnauthorizedAccess">
+        <source>You do not have access to: {0}</source>
+        <target state="new">You do not have access to: {0}</target>
+        <note>Directory must have access</note>
       </trans-unit>
-      <trans-unit id="OM_NotSupportedReadOnlyCollection">
-        <source>This collection is read-only.</source>
-        <target state="translated"></target>
+      <trans-unit id="UnrecognizedSolutionComment">
+        <source>Unrecognized solution version "{0}", attempting to continue.</source>
+        <target state="new">Unrecognized solution version "{0}", attempting to continue.</target>
         <note />
       </trans-unit>
-      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
-        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
-        <target state="translated">MSB5024: MSBuild Visual Studio  </target>
-        <note>{StrBegin="MSB5024: "}</note>
-      </trans-unit>
-      <trans-unit id="InvalidLogFileFormat">
-        <source>MSB4233: There was an exception while reading the log file: {0}</source>
-        <target state="translated">MSB4233:  : {0}</target>
-        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
-      </trans-unit>
-      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
-        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
-        <target state="translated"> "{1}"  "{0}" </target>
-        <note />
+      <trans-unit id="UnrecognizedToolsVersion">
+        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
+        <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
+        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
       </trans-unit>
     </body>
   </file>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 3ec69e93682..0a9784913d7 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -65,6 +65,21 @@
         <target state="translated">: {0}() OS    .    {1}  .</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132:   "{0}"()   .      {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 2d38506af57..6d6f964b8a2 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -65,6 +65,21 @@
         <target state="translated">cieka: {0} przekracza limit maksymalnej dugoci cieki w systemie operacyjnym. W peni kwalifikowana nazwa pliku musi si skada z mniej ni {1} znakw.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Wersja narzdzi {0} nie zostaa rozpoznana. Dostpne wersje narzdzi to {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 4aa21acdb48..f2b419f77df 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Caminho: {0} excede o limite mximo do caminho do SO. O nome do arquivo totalmente qualificado deve ter menos de {1} caracteres.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: A verso das ferramentas "{0}" no  reconhecida. As verses das ferramentas disponveis so {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index d37b4d76c6c..111a49830f4 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -65,6 +65,21 @@
         <target state="translated">  {0}    .          {1}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132:   "{0}"  .   : {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 24caa67ffa5..b0b741a3960 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Yol: {0}, iletim sisteminin en yksek yol snrn ayor. Tam dosya ad en fazla {1} karakter olmaldr.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Aralar srm "{0}" tannmyor. Kullanlabilir ara srmleri unlardr: {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 78941fb4a60..398938a8677 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -65,6 +65,21 @@
         <target state="translated">: {0}  OS  {1} </target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: {0} {1}</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 8053d2d6e4b..418a2c2a06b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -65,6 +65,21 @@
         <target state="translated">: {0}  OS  {1} </target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132:  "{0}"  {1}</target>
diff --git a/src/Shared/ReuseableStringBuilder.cs b/src/Shared/ReuseableStringBuilder.cs
index 655a43c9ddb..8f295e0b263 100644
--- a/src/Shared/ReuseableStringBuilder.cs
+++ b/src/Shared/ReuseableStringBuilder.cs
@@ -6,10 +6,8 @@
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
-using System.Reflection;
 using System.Text;
 using System.Threading;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Shared
 {
@@ -19,7 +17,7 @@ namespace Microsoft.Build.Shared
     /// <remarks>
     /// You can add any properties or methods on the real StringBuilder that are needed.
     /// </remarks>
-    internal sealed class ReuseableStringBuilder : IDisposable, OpportunisticIntern.IInternable
+    internal sealed class ReuseableStringBuilder : IDisposable, IInternable
     {
         /// <summary>
         /// Captured string builder.
@@ -63,7 +61,7 @@ public int Length
         /// <summary>
         /// Indexer into the target. Presumed to be fast.
         /// </summary>
-        char OpportunisticIntern.IInternable.this[int index]
+        char IInternable.this[int index]
         {
             get
             {
@@ -75,7 +73,7 @@ char OpportunisticIntern.IInternable.this[int index]
         /// <summary>
         /// Convert target to string. Presumed to be slow (and will be called just once).
         /// </summary>
-        string OpportunisticIntern.IInternable.ExpensiveConvertToString()
+        string IInternable.ExpensiveConvertToString()
         {
             if( _cachedString == null)
             {
@@ -96,14 +94,14 @@ string OpportunisticIntern.IInternable.ExpensiveConvertToString()
         /// <summary>
         /// Compare target to string. 
         /// </summary>
-        bool OpportunisticIntern.IInternable.StartsWithStringByOrdinalComparison(string other)
+        bool IInternable.StartsWithStringByOrdinalComparison(string other)
         {
 #if DEBUG
             ErrorUtilities.VerifyThrow(other.Length <= _borrowedBuilder.Length, "should be at most as long as target");
 #endif
             if (other.Length > MaxByCharCompareLength)
             {
-                return ((OpportunisticIntern.IInternable) this).ExpensiveConvertToString().StartsWith(other, StringComparison.Ordinal);
+                return ((IInternable) this).ExpensiveConvertToString().StartsWith(other, StringComparison.Ordinal);
             }
             // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
             // For example, C:\project1, C:\project2
@@ -121,7 +119,7 @@ bool OpportunisticIntern.IInternable.StartsWithStringByOrdinalComparison(string
         /// <summary>
         /// Never reference equals to string.
         /// </summary>
-        bool OpportunisticIntern.IInternable.ReferenceEquals(string other)
+        bool IInternable.ReferenceEquals(string other)
         {
             return false;
         }
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 2b816c7eaee..f826bb92f90 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -43,9 +43,14 @@ public Traits()
         public readonly bool CacheFileExistence = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildCacheFileExistence"));
 
         /// <summary>
-        /// Eliminate locking in OpportunisticIntern at the expense of memory
+        /// Use the legacy string interning implementation based on MRU lists.
         /// </summary>
-        public readonly bool UseSimpleInternConcurrency = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildUseSimpleInternConcurrency"));
+        public readonly bool UseLegacyStringInterner = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildUseLegacyStringInterner"));
+
+        /// <summary>
+        /// Eliminate locking in OpportunisticIntern at the expense of memory (in effect only if UseLegacyStringInterner is set).
+        /// </summary>
+        public readonly bool UseSimpleInternConcurrency = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildUseSimpleInternConcurrency"));
 
         public readonly bool UseSimpleProjectRootElementCacheConcurrency = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildUseSimpleProjectRootElementCacheConcurrency"));
 
@@ -61,6 +66,11 @@ public Traits()
         /// </summary>
         public readonly bool EnableRestoreFirst = Environment.GetEnvironmentVariable("MSBUILDENABLERESTOREFIRST") == "1";
 
+        /// <summary>
+        /// Allow the user to specify that two processes should not be communicating via an environment variable.
+        /// </summary>
+        public static readonly string MSBuildNodeHandshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+
         /// <summary>
         /// Setting the associated environment variable to 1 restores the pre-15.8 single
         /// threaded (slower) copy behavior. Zero implies Int32.MaxValue, less than zero
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
new file mode 100644
index 00000000000..20a1a75f2fa
--- /dev/null
+++ b/src/Shared/TranslatorHelpers.cs
@@ -0,0 +1,109 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// This class provides helper methods to adapt from <see cref="NodePacketValueFactory{T}"/> to
+    /// <see cref="ObjectTranslator{T}"/>.
+    /// </summary>
+    internal static class TranslatorHelpers
+    {
+        /// <summary>
+        /// Translates an object implementing <see cref="ITranslatable"/> which does not expose a
+        /// public parameterless constructor.
+        /// </summary>
+        /// <typeparam name="T">The reference type.</typeparam>
+        /// <param name="translator">The translator</param>
+        /// <param name="instance">The value to be translated.</param>
+        /// <param name="factory">The factory method used to instantiate values of type T.</param>
+        public static void Translate<T>(
+            this ITranslator translator,
+            ref T instance,
+            NodePacketValueFactory<T> valueFactory) where T : ITranslatable
+        {
+            if (!translator.TranslateNullable(instance))
+            {
+                return;
+            }
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                instance = valueFactory(translator);
+            }
+            else
+            {
+                instance.Translate(translator);
+            }
+        }
+
+        static ObjectTranslator<T> AdaptFactory<T>(NodePacketValueFactory<T> valueFactory) where T : ITranslatable
+        {
+            void Translate(ITranslator translator, ref T objectToTranslate)
+            {
+                TranslatorHelpers.Translate<T>(translator, ref objectToTranslate, valueFactory);
+            }
+
+            return Translate;
+        }
+
+        public static void Translate<T>(
+            this ITranslator translator,
+            ref List<T> list,
+            NodePacketValueFactory<T> valueFactory) where T : class, ITranslatable
+        {
+            translator.Translate(ref list, AdaptFactory(valueFactory));
+        }
+
+        public static void Translate<T, L>(
+            this ITranslator translator,
+            ref IList<T> list,
+            NodePacketValueFactory<T> valueFactory,
+            NodePacketCollectionCreator<L> collectionFactory) where L : IList<T> where T : ITranslatable
+        {
+            translator.Translate(ref list, AdaptFactory(valueFactory), collectionFactory);
+        }
+
+        public static void TranslateArray<T>(
+            this ITranslator translator,
+            ref T[] array,
+            NodePacketValueFactory<T> valueFactory) where T : class, ITranslatable
+        {
+            translator.TranslateArray(ref array, AdaptFactory(valueFactory));
+        }
+
+        public static void TranslateDictionary<T>(
+            this ITranslator translator,
+            ref Dictionary<string, T> dictionary,
+            IEqualityComparer<string> comparer,
+            NodePacketValueFactory<T> valueFactory) where T : class, ITranslatable
+        {
+            translator.TranslateDictionary(ref dictionary, comparer, AdaptFactory(valueFactory));
+        }
+
+        public static void TranslateDictionary<D, T>(
+            this ITranslator translator,
+            ref D dictionary,
+            NodePacketValueFactory<T> valueFactory)
+            where D : IDictionary<string, T>, new()
+            where T : class, ITranslatable
+        {
+            translator.TranslateDictionary(ref dictionary, AdaptFactory(valueFactory));
+        }
+
+        public static void TranslateDictionary<D, T>(
+            this ITranslator translator,
+            ref D dictionary,
+            NodePacketValueFactory<T> valueFactory,
+            NodePacketCollectionCreator<D> collectionCreator)
+            where D : IDictionary<string, T>
+            where T : class, ITranslatable
+        {
+            translator.TranslateDictionary(ref dictionary, AdaptFactory(valueFactory), collectionCreator);
+        }
+    }
+}
diff --git a/src/Shared/UnitTests/MockEngine.cs b/src/Shared/UnitTests/MockEngine.cs
index 2cf1154d834..bd745cab9e2 100644
--- a/src/Shared/UnitTests/MockEngine.cs
+++ b/src/Shared/UnitTests/MockEngine.cs
@@ -52,6 +52,8 @@ internal MockEngine() : this(false)
 
         internal int Errors { get; set; }
 
+        public bool AllowFailureWithoutError { get; set; } = true;
+
         public BuildErrorEventArgs[] ErrorEvents => _errorEvents.ToArray();
 
         public Dictionary<string, string> GlobalProperties { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 42d56c62448..62db95267d0 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1248,14 +1248,14 @@ internal static void AssertDictionariesEqual(IDictionary<string, string> x, IDic
                 });
         }
 
-        internal static void ShouldBeEquivalentTo<K, V>(this IDictionary<K, V> a, IReadOnlyDictionary<K, V> b)
+        internal static void ShouldBeSameIgnoringOrder<K, V>(this IDictionary<K, V> a, IReadOnlyDictionary<K, V> b)
         {
             a.ShouldBeSubsetOf(b);
             b.ShouldBeSubsetOf(a);
             a.Count.ShouldBe(b.Count);
         }
 
-        internal static void ShouldBeEquivalentTo<K>(this IEnumerable<K> a, IEnumerable<K> b)
+        internal static void ShouldBeSameIgnoringOrder<K>(this IEnumerable<K> a, IEnumerable<K> b)
         {
             a.ShouldBeSubsetOf(b);
             b.ShouldBeSubsetOf(a);
@@ -1293,11 +1293,9 @@ internal static void AssertEnumerationsValueEqual<T>(IEnumerable<T> one, IEnumer
         /// Build a project with the provided content in memory.
         /// Assert that it succeeded, and return the mock logger with the output.
         /// </summary>
-        internal static MockLogger BuildProjectWithNewOMExpectSuccess(string content, Dictionary<string, string> globalProperties = null)
+        internal static MockLogger BuildProjectWithNewOMExpectSuccess(string content, Dictionary<string, string> globalProperties = null, MockLogger logger = null)
         {
-            MockLogger logger;
-            bool result;
-            BuildProjectWithNewOM(content, out logger, out result, false, globalProperties);
+            BuildProjectWithNewOM(content, ref logger, out bool result, false, globalProperties);
             Assert.True(result);
 
             return logger;
@@ -1306,14 +1304,16 @@ internal static MockLogger BuildProjectWithNewOMExpectSuccess(string content, Di
         /// <summary>
         /// Build a project in memory using the new OM
         /// </summary>
-        private static void BuildProjectWithNewOM(string content, out MockLogger logger, out bool result, bool allowTaskCrash, Dictionary<string, string> globalProperties = null)
+        private static void BuildProjectWithNewOM(string content, ref MockLogger logger, out bool result, bool allowTaskCrash, Dictionary<string, string> globalProperties = null)
         {
             // Replace the crazy quotes with real ones
             content = ObjectModelHelpers.CleanupFileContents(content);
 
             Project project = new Project(XmlReader.Create(new StringReader(content)), globalProperties, toolsVersion: null);
-            logger = new MockLogger();
-            logger.AllowTaskCrashes = allowTaskCrash;
+            logger ??= new MockLogger
+            {
+                AllowTaskCrashes = allowTaskCrash
+            };
             List<ILogger> loggers = new List<ILogger>();
             loggers.Add(logger);
             result = project.Build(loggers);
@@ -1375,11 +1375,10 @@ public static BuildResult BuildProjectFileUsingBuildManager(string projectFile,
         /// Build a project with the provided content in memory.
         /// Assert that it fails, and return the mock logger with the output.
         /// </summary>
-        internal static MockLogger BuildProjectWithNewOMExpectFailure(string content, bool allowTaskCrash)
+        internal static MockLogger BuildProjectWithNewOMExpectFailure(string content, bool allowTaskCrash, MockLogger logger = null)
         {
-            MockLogger logger;
             bool result;
-            BuildProjectWithNewOM(content, out logger, out result, allowTaskCrash);
+            BuildProjectWithNewOM(content, ref logger, out result, allowTaskCrash);
             Assert.False(result);
             return logger;
         }
@@ -1567,6 +1566,34 @@ internal static TransientTestFile CreateProjectFile(
             return env.CreateFile(projectNumber + ".proj", sb.ToString());
         }
 
+        internal static ProjectGraph CreateProjectGraph(
+            TestEnvironment env,
+            IDictionary<int, int[]> dependencyEdges,
+            IDictionary<int, string> extraContentPerProjectNumber,
+            string extraContentForAllNodes = null)
+        {
+            return CreateProjectGraph(
+                env: env,
+                dependencyEdges: dependencyEdges,
+                globalProperties: null,
+                createProjectFile: (environment, projectNumber, references, projectReferenceTargets, defaultTargets, extraContent) =>
+                {
+                    extraContent = extraContentPerProjectNumber != null && extraContentPerProjectNumber.TryGetValue(projectNumber, out var content)
+                        ? content
+                        : string.Empty;
+
+                    extraContent += extraContentForAllNodes ?? string.Empty;
+
+                    return CreateProjectFile(
+                        environment,
+                        projectNumber,
+                        references,
+                        projectReferenceTargets,
+                        defaultTargets,
+                        extraContent.Cleanup());
+                });
+        }
+
         internal static ProjectGraph CreateProjectGraph(
             TestEnvironment env,
             // direct dependencies that the kvp.key node has on the nodes represented by kvp.value
diff --git a/src/Shared/WeakStringCache.Concurrent.cs b/src/Shared/WeakStringCache.Concurrent.cs
new file mode 100644
index 00000000000..310964fdd2d
--- /dev/null
+++ b/src/Shared/WeakStringCache.Concurrent.cs
@@ -0,0 +1,133 @@
+
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+
+namespace Microsoft.Build
+{
+    /// <summary>
+    /// Implements the WeakStringCache functionality on modern .NET versions where ConcurrentDictionary is available.
+    /// </summary>
+    internal sealed partial class WeakStringCache : IDisposable
+    {
+        private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;
+
+        public WeakStringCache()
+        {
+            _stringsByHashCode = new ConcurrentDictionary<int, StringWeakHandle>(Environment.ProcessorCount, _initialCapacity);
+        }
+
+        /// <summary>
+        /// Main entrypoint of this cache. Tries to look up a string that matches the given internable. If it succeeds, returns
+        /// the string and sets cacheHit to true. If the string is not found, calls ExpensiveConvertToString on the internable,
+        /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
+        /// </summary>
+        /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <returns>A string matching the given internable.</returns>
+        /// <remarks>
+        /// This method performs one operation on the underlying ConcurrentDictionary on cache hit, and two or three operations on cache miss.
+        /// 1. It checks whether the dictionary has a matching entry. This operations is common to all code paths.
+        ///    If there is a matching entry we are done.
+        /// 2. If the dictionary doesn't have an entry for the given hash code, we make a new one and add it (the second operation).
+        ///    Note that we could do 1. and 2. together using GetOrAdd() with the valueFactory callback but it wouldn't be much faster
+        ///    and would require allocating a closure object to share data with the callback.
+        /// 3. If the dictionary has an entry for the given hash code but it doesn't match the argument because it's either already
+        ///    collected or there is a hash collision, we have to first remove the existing handle to prevent other threads from
+        ///    freeing it (second operation). Only then can it have the target set to the new string and be added back to the dictionary
+        ///    (third operation).
+        /// </remarks>
+        public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IInternable
+        {
+            int hashCode = GetInternableHashCode(internable);
+
+            StringWeakHandle handle;
+            string result;
+            bool addingNewHandle = false;
+
+            if (_stringsByHashCode.TryGetValue(hashCode, out handle))
+            {
+                result = handle.GetString(internable);
+                if (result != null)
+                {
+                    cacheHit = true;
+                    return result;
+                }
+            }
+            else
+            {
+                handle = new StringWeakHandle();
+                addingNewHandle = true;
+            }
+
+            // We don't have the string in the cache - create it.
+            result = internable.ExpensiveConvertToString();
+
+            // If the handle is new, we have to add it to the cache. We do it after removing unused handles if our heuristic
+            // indicates that it would be productive. Note that the _capacity field accesses are not protected from races. Being
+            // atomic (as guaranteed by the 32-bit data type) is enough here.
+            if (addingNewHandle)
+            {
+                // Prevent the dictionary from growing forever with GC handles that don't reference live strings anymore.
+                if (_stringsByHashCode.Count >= _scavengeThreshold)
+                {
+                    // Get rid of unused handles.
+                    Scavenge();
+                    // And do this again when the number of handles reaches double the current after-scavenge number.
+                    _scavengeThreshold = _stringsByHashCode.Count * 2;
+                }
+            }
+            else
+            {
+                // If the handle is already in the cache, we have to be careful because other threads may be operating on it.
+                // In particular the Scavenge method may free the handle from underneath us if we leave it in the cache.
+                if (!_stringsByHashCode.TryRemove(hashCode, out handle))
+                {
+                    // The handle is no longer in the cache so we're creating a new one after all.
+                    handle = new StringWeakHandle();
+                }
+            }
+
+            // Set the handle to reference the new string and put it in the cache.
+            handle.SetString(result);
+            if (!_stringsByHashCode.TryAdd(hashCode, handle))
+            {
+                // If somebody beat us to it and the new handle has not been added, free it.
+                handle.Free();
+            }
+
+            cacheHit = false;
+            return result;
+        }
+
+        /// <summary>
+        /// Iterates over the cache and removes unused GC handles, i.e. handles that don't reference live strings.
+        /// This is expensive so try to call such that the cost is amortized to O(1) per GetOrCreateEntry() invocation.
+        /// </summary>
+        public void Scavenge()
+        {
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                if (!entry.Value.IsUsed && _stringsByHashCode.TryRemove(entry.Key, out StringWeakHandle removedHandle))
+                {
+                    // Note that the removed handle may be different from the one we got from the enumerator so check again
+                    // and try to put it back if it's still in use.
+                    if (!removedHandle.IsUsed || !_stringsByHashCode.TryAdd(entry.Key, removedHandle))
+                    {
+                        removedHandle.Free();
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Returns internal debug counters calculated based on the current state of the cache.
+        /// </summary>
+        public DebugInfo GetDebugInfo()
+        {
+            return GetDebugInfoImpl();
+        }
+    }
+}
diff --git a/src/Shared/WeakStringCache.cs b/src/Shared/WeakStringCache.cs
new file mode 100644
index 00000000000..22021e1a08a
--- /dev/null
+++ b/src/Shared/WeakStringCache.cs
@@ -0,0 +1,149 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Runtime.InteropServices;
+
+namespace Microsoft.Build
+{
+    /// <summary>
+    /// A cache of weak GC handles pointing to strings. Weak GC handles are functionally equivalent to WeakReference's but have less overhead
+    /// (they're a struct as opposed to WR which is a finalizable class) at the expense of requiring manual lifetime management. As long as
+    /// a string has an ordinary strong GC root elsewhere in the process and another string with the same hashcode hasn't reused the entry,
+    /// the cache has a reference to it and can match it to an internable. When the string is collected, it is also automatically "removed"
+    /// from the cache by becoming unrecoverable from the GC handle. GC handles that do not reference a live string anymore are freed lazily.
+    /// </summary>
+    internal sealed partial class WeakStringCache : IDisposable
+    {
+        /// <summary>
+        /// Debug stats returned by GetDebugInfo().
+        /// </summary>
+        public struct DebugInfo
+        {
+            public int LiveStringCount;
+            public int CollectedStringCount;
+        }
+
+        /// <summary>
+        /// Holds a weak GC handle to a string. Shared by all strings with the same hash code and referencing the last such string we've seen.
+        /// </summary>
+        private struct StringWeakHandle
+        {
+            /// <summary>
+            /// Weak GC handle to the last string of the given hashcode we've seen.
+            /// </summary>
+            public GCHandle WeakHandle;
+
+            /// <summary>
+            /// Returns true if the string referenced by the handle is still alive.
+            /// </summary>
+            public bool IsUsed => WeakHandle.Target != null;
+
+            /// <summary>
+            /// Returns the string referenced by this handle if it is equal to the given internable.
+            /// </summary>
+            /// <param name="internable">The internable describing the string we're looking for.</param>
+            /// <returns>The string matching the internable or null if the handle is referencing a collected string or the string is different.</returns>
+            public string GetString<T>(T internable) where T : IInternable
+            {
+                if (WeakHandle.IsAllocated && WeakHandle.Target is string str)
+                {
+                    if (internable.Length == str.Length &&
+                        internable.StartsWithStringByOrdinalComparison(str))
+                    {
+                        return str;
+                    }
+                }
+                return null;
+            }
+
+            /// <summary>
+            /// Sets the handle to the given string. If the handle is still referencing another live string, that string is effectively forgotten.
+            /// </summary>
+            /// <param name="str">The string to set.</param>
+            public void SetString(string str)
+            {
+                if (!WeakHandle.IsAllocated)
+                {
+                    // The handle is not allocated - allocate it.
+                    WeakHandle = GCHandle.Alloc(str, GCHandleType.Weak);
+                }
+                else
+                {
+                    WeakHandle.Target = str;
+                }
+            }
+
+            /// <summary>
+            /// Frees the GC handle.
+            /// </summary>
+            public void Free()
+            {
+                WeakHandle.Free();
+            }
+        }
+
+        /// <summary>
+        /// Initial capacity of the underlying dictionary.
+        /// </summary>
+        private const int _initialCapacity = 503;
+
+        /// <summary>
+        /// The maximum size we let the collection grow before scavenging unused entries.
+        /// </summary>
+        private int _scavengeThreshold = _initialCapacity;
+
+        /// <summary>
+        /// Implements the simple yet very decently performing djb2 hash function (xor version).
+        /// </summary>
+        /// <param name="internable">The internable to compute the hash code for.</param>
+        /// <returns>The 32-bit hash code.</returns>
+        internal static int GetInternableHashCode<T>(T internable) where T : IInternable
+        {
+            int hashCode = 5381;
+            for (int i = 0; i < internable.Length; i++)
+            {
+                unchecked
+                {
+                    hashCode = hashCode * 33 ^ internable[i];
+                }
+            }
+            return hashCode;
+        }
+
+        /// <summary>
+        /// Frees all GC handles and clears the cache.
+        /// </summary>
+        public void Dispose()
+        {
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                entry.Value.Free();
+            }
+            _stringsByHashCode.Clear();
+        }
+
+        /// <summary>
+        /// Returns internal debug counters calculated based on the current state of the cache.
+        /// </summary>
+        private DebugInfo GetDebugInfoImpl()
+        {
+            DebugInfo debugInfo = new DebugInfo();
+
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                if (entry.Value.IsUsed)
+                {
+                    debugInfo.LiveStringCount++;
+                }
+                else
+                {
+                    debugInfo.CollectedStringCount++;
+                }
+            }
+
+            return debugInfo;
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs b/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
index 8dd512df8e7..4cf2b992ef4 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
@@ -93,7 +93,7 @@ public void AssemblyFoldersFromConfigPlatformSpecificAssemblyFirstTest()
         }
 
         [Fact]
-        public void AasemblyFoldersFromConfigNormalizeNetFrameworkVersion()
+        public void AssemblyFoldersFromConfigNormalizeNetFrameworkVersion()
         {
             var assemblyConfig = Path.GetTempFileName();
             File.WriteAllText(assemblyConfig, TestFile);
diff --git a/src/Tasks/FileIO/GetFileHash.cs b/src/Tasks/FileIO/GetFileHash.cs
index c9c17c6e23d..39ad392e8f8 100644
--- a/src/Tasks/FileIO/GetFileHash.cs
+++ b/src/Tasks/FileIO/GetFileHash.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Security.Cryptography;
+using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -19,6 +20,13 @@ public sealed class GetFileHash : TaskExtension
         internal const string _defaultFileHashAlgorithm = "SHA256";
         internal const string _hashEncodingHex = "hex";
         internal const string _hashEncodingBase64 = "base64";
+        internal static readonly Dictionary<string, Func<HashAlgorithm>> SupportedAlgorithms
+            = new Dictionary<string, Func<HashAlgorithm>>(StringComparer.OrdinalIgnoreCase)
+            {
+                ["SHA256"] = SHA256.Create,
+                ["SHA384"] = SHA384.Create,
+                ["SHA512"] = SHA512.Create,
+            };
 
         /// <summary>
         /// The files to be hashed.
@@ -55,7 +63,7 @@ public sealed class GetFileHash : TaskExtension
 
         public override bool Execute()
         {
-            if (!SupportsAlgorithm(Algorithm))
+            if (!SupportedAlgorithms.TryGetValue(Algorithm, out var algorithmFactory))
             {
                 Log.LogErrorWithCodeFromResources("FileHash.UnrecognizedHashAlgorithm", Algorithm);
                 return false;
@@ -67,26 +75,34 @@ public override bool Execute()
                 return false;
             }
 
-            foreach (var file in Files)
+            var writeLock = new object();
+            Parallel.For(0, Files.Length, index =>
             {
+                var file = Files[index];
+
                 if (!FileSystems.Default.FileExists(file.ItemSpec))
                 {
                     Log.LogErrorWithCodeFromResources("FileHash.FileNotFound", file.ItemSpec);
+                    return;
                 }
-            }
+
+                var hash = ComputeHash(algorithmFactory, file.ItemSpec);
+                var encodedHash = EncodeHash(encoding, hash);
+
+                lock (writeLock)
+                {
+                    // We cannot guarantee Files instances are unique. Write to it inside a lock to
+                    // avoid concurrent edits.
+                    file.SetMetadata("FileHashAlgorithm", Algorithm);
+                    file.SetMetadata(MetadataName, encodedHash);
+                }
+            });
 
             if (Log.HasLoggedErrors)
             {
                 return false;
             }
 
-            foreach (var file in Files)
-            {
-                var hash = ComputeHash(Algorithm, file.ItemSpec);
-                file.SetMetadata("FileHashAlgorithm", Algorithm);
-                file.SetMetadata(MetadataName, EncodeHash(encoding, hash));
-            }
-
             Items = Files;
 
             if (Files.Length == 1)
@@ -113,39 +129,13 @@ internal static string EncodeHash(HashEncoding encoding, byte[] hash)
         internal static bool TryParseHashEncoding(string value, out HashEncoding encoding)
             => Enum.TryParse<HashEncoding>(value, /*ignoreCase:*/ true, out encoding);
 
-        internal static bool SupportsAlgorithm(string algorithmName)
-            => _supportedAlgorithms.Contains(algorithmName);
-
-        internal static byte[] ComputeHash(string algorithmName, string filePath)
+        internal static byte[] ComputeHash(Func<HashAlgorithm> algorithmFactory, string filePath)
         {
             using (var stream = File.OpenRead(filePath))
-            using (var algorithm = CreateAlgorithm(algorithmName))
+            using (var algorithm = algorithmFactory())
             {
                 return algorithm.ComputeHash(stream);
             }
         }
-
-        private static readonly HashSet<string> _supportedAlgorithms
-            = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
-            {
-                "SHA256",
-                "SHA384",
-                "SHA512",
-            };
-
-        private static HashAlgorithm CreateAlgorithm(string algorithmName)
-        {
-            switch (algorithmName.ToUpperInvariant())
-            {
-                case "SHA256":
-                    return SHA256.Create();
-                case "SHA384":
-                    return SHA384.Create();
-                case "SHA512":
-                    return SHA512.Create();
-                default:
-                    throw new ArgumentOutOfRangeException();
-            }
-        }
     }
 }
diff --git a/src/Tasks/FileIO/VerifyFileHash.cs b/src/Tasks/FileIO/VerifyFileHash.cs
index 9f3b30540dd..5addbea5571 100644
--- a/src/Tasks/FileIO/VerifyFileHash.cs
+++ b/src/Tasks/FileIO/VerifyFileHash.cs
@@ -44,7 +44,7 @@ public override bool Execute()
                 return false;
             }
 
-            if (!GetFileHash.SupportsAlgorithm(Algorithm))
+            if (!GetFileHash.SupportedAlgorithms.TryGetValue(Algorithm, out var algorithmFactory))
             {
                 Log.LogErrorWithCodeFromResources("FileHash.UnrecognizedHashAlgorithm", Algorithm);
                 return false;
@@ -56,7 +56,7 @@ public override bool Execute()
                 return false;
             }
 
-            byte[] hash = GetFileHash.ComputeHash(Algorithm, File);
+            byte[] hash = GetFileHash.ComputeHash(algorithmFactory, File);
             string actualHash = GetFileHash.EncodeHash(encoding, hash);
             var comparison = encoding == Tasks.HashEncoding.Hex
                 ? StringComparison.OrdinalIgnoreCase
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 9f65aed2c43..5cd0ab89409 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -81,6 +81,15 @@
     <Compile Include="..\Shared\NGen.cs">
       <Link>NGen.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IInternable.cs">
+      <Link>IInternable.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.cs">
+      <Link>WeakStringCache.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
+      <Link>WeakStringCache.Concurrent.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\OpportunisticIntern.cs">
       <Link>OpportunisticIntern.cs</Link>
     </Compile>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 794392b6202..9f6a5fae91d 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -86,8 +86,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <PropertyGroup>
-    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == ''">Windows</TargetPlatformIdentifier>
-    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == ''">7.0</TargetPlatformVersion>
+    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == '' and '$(_EnableDefaultWindowsPlatform)' != 'false'">Windows</TargetPlatformIdentifier>
+    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == '' and '$(_EnableDefaultWindowsPlatform)' != 'false'">7.0</TargetPlatformVersion>
     <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == '' and '$(TargetPlatformSdkRootOverride)' != ''">$(TargetPlatformSdkRootOverride)\</TargetPlatformSdkPath>
     <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and '$(OS)' == 'Windows_NT' and '$(MSBuildRuntimeType)' != 'Core'">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\Software\Microsoft\Microsoft SDKs\Windows\v$(TargetPlatformVersion)', InstallationFolder, null, RegistryView.Registry32, RegistryView.Default))</TargetPlatformSdkPath>
     <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKLocation($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformSdkPath>
@@ -2666,7 +2666,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
         [IN]
         @(COMReference) - The list of COM references
-        $(BaseIntermediateOutputPath) - The output directory in which to generate wrapper assemblies
+        $(InteropOutputPath) - The output directory in which to generate wrapper assemblies
+                               When $(InteropOutputPath) is not set, then it defaults to $(IntermediateOutputPath).
 
         [OUT]
         @(ReferencePath) - Paths to referenced wrappers.
@@ -4572,6 +4573,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="TargetOutputs" ItemName="_ThisProjectItemsToCopyToOutputDirectory" />
     </CallTarget>
 
+    <ItemGroup Condition="'$(CopyConflictingTransitiveContent)' == 'false'">
+      <_TransitiveItemsToCopyToOutputDirectory Remove="@(_ThisProjectItemsToCopyToOutputDirectory)" MatchOnMetadata="TargetPath" MatchOnMetadataOptions="PathLike" />
+    </ItemGroup>
+
     <ItemGroup>
       <_TransitiveItemsToCopyToOutputDirectoryAlways               KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='Always'"/>
       <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest       KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='PreserveNewest'"/>
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index e78168f28b0..89e402b0582 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -174,4 +174,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <NuGetPropsFile Condition="'$(NuGetPropsFile)'==''">$(MSBuildToolsPath)\NuGet.props</NuGetPropsFile>
   </PropertyGroup>
   <Import Condition="Exists('$(NuGetPropsFile)')" Project="$(NuGetPropsFile)" />
+
+  <PropertyGroup Condition=" '$(MSBuildLogVerboseTaskParameters)' != 'true' ">
+    <DisableLogTaskParameter_ConvertToAbsolutePath_Path>true</DisableLogTaskParameter_ConvertToAbsolutePath_Path>
+    <DisableLogTaskParameter_FindUnderPath_OutOfPath>true</DisableLogTaskParameter_FindUnderPath_OutOfPath>
+    <DisableLogTaskParameter_RemoveDuplicates_Inputs>true</DisableLogTaskParameter_RemoveDuplicates_Inputs>
+    <DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>true</DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>
+    <DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>true</DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>
+    <DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>true</DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>
+    <DisableLogTaskParameterItemMetadata_Copy_SourceFiles>true</DisableLogTaskParameterItemMetadata_Copy_SourceFiles>
+    <DisableLogTaskParameterItemMetadata_FindUnderPath_Files>true</DisableLogTaskParameterItemMetadata_FindUnderPath_Files>
+    <DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>true</DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>
+    <DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>true</DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>
+    <DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>true</DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>
+    <DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>true</DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>
+    <DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>true</DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>
+  </PropertyGroup>
 </Project>
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index c372dcbd388..243c49179e2 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -20,13 +20,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
    </PropertyGroup>
 
    <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
-      <!-- Microsoft.Net.Sdk adds all transitive project references to ProjectReference. It does this at build time
-           via a target. This fails the undeclared msbuild reference /isolate constraint, so disable transitive
-           references.
-           Do not disable transitive references if BuildProjectReferences is false. If building references is false,
-           then MSBuild won't try to build the transitive references, which won't trigger undeclared reference constraints.
-          -->
-      <DisableTransitiveProjectReferences Condition="'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''">true</DisableTransitiveProjectReferences>
+      <AddTransitiveProjectReferencesInStaticGraph Condition="'$(AddTransitiveProjectReferencesInStaticGraph)' == '' and '$(UsingMicrosoftNETSdk)' == 'true' and '$(DisableTransitiveProjectReferences)' != 'true'">true</AddTransitiveProjectReferencesInStaticGraph>
    </PropertyGroup>
 
    <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
@@ -43,7 +37,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     Properties for extension of ProjectReferenceTargets.
     Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
   -->
-  <PropertyGroup>
+  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
     <!-- Empty case is for outer builds which do not import the target files that set BuildProjectReferences -->
     <_MainReferenceTarget Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTarget>
     <_MainReferenceTarget Condition="'$(_MainReferenceTarget)' == ''">GetTargetPath</_MainReferenceTarget>
@@ -61,7 +55,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
   </PropertyGroup>
 
-  <ItemGroup>
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true"/>
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
 
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets b/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
index 1df60920670..e39ebb16d75 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
@@ -123,8 +123,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />
     </ItemGroup>
 
-    <Message Importance="Low" Text="Including @(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />
-
   </Target>
 
 
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 7519a6f4fc3..9598c9d6157 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: loha {0} se ve verzi MSBuildu .NET Core nepodporuje. Pouijte msto n balek Microsoft XML Serializer Generator. Dal informace najdete na adrese https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index f7321dd89e8..69c726c62a4 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: Die Aufgabe "{0}" wird in der .NET Core-Version von MSBuild nicht untersttzt. Verwenden Sie stattdessen das Microsoft XML Serializer Generator-Paket. Weitere Informationen finden Sie unter https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 21f8661c841..e34aa053c3e 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: La tarea "{0}" no se admite en la versin .NET Core de MSBuild. En su lugar, use el paquete del Generador de serializador XML de Microsoft. Consulte https://go.microsoft.com/fwlink/?linkid=858594 para obtener ms informacin.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 38b460aadf1..9720b69bf5f 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: la tche "{0}" n'est pas prise en charge dans la version .NET Core de MSBuild. Utilisez le package Microsoft XML Serializer Generator  la place. Pour plus d'informations, consultez https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index ec92efbf907..99cc118cd38 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: l'attivit "{0}" non  supportata nella versione .NET Core di MSBuild. Usare il pacchetto dello strumento Microsoft per la generazione di serializzatori XML. Per altre informazioni, vedere https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 5b9101c3bbe..e209c62b2f7 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474:  "{0}" MSBuild  .NET Core  Microsoft XML Serializer Generator https://go.microsoft.com/fwlink/?linkid=858594 </target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 07683139d84..2e70e167585 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: MSBuild .NET Core  "{0}"   . Microsoft XML Serializer Generator   .   https://go.microsoft.com/fwlink/?linkid=858594 .</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 9216490676c..6b53dc24fb7 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: zadanie {0} nie jest obsugiwane w wersji platformy .NET Core programu MSBuild. Zamiast tego uyj pakietu narzdzia Microsoft XML Serializer Generator. Aby uzyska wicej informacji, zobacz https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index b9ce1ded3e1..0d31dafd981 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: No h suporte para a tarefa "{0}" na verso .NET Core do MSBuild. Nesse caso, use o pacote do XML Serializer Generator da Microsoft. Confira https://go.microsoft.com/fwlink/?linkid=858594 para obter mais informaes.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index e114c230d35..29fe42402d0 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474:  "{0}"     .NET Core MSBuild.     Microsoft XML Serializer Generator.   .   https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 071ee4d4150..5076d987e41 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: "{0}" grevi, MSBuild'in .NET Core srmnde desteklenmiyor. Bunun yerine Microsoft XML Seriletiricisi Oluturma paketini kullann. Daha fazla bilgi iin bkz. https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 6741ccbae04..2797e21cd0b 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: MSBuild  .NET Core {0} Microsoft XML  https://go.microsoft.com/fwlink/?linkid=858594</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 631aefccbe8..05c4f11672b 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="new">MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</target>
+        <target state="translated">MSB3474: MSBuild  .NET Core  "{0}" Microsoft XML  https://go.microsoft.com/fwlink/?linkid=858594</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 3843a338df1..30db3703d9b 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -63,6 +63,15 @@
     <Compile Include="..\Shared\NativeMethodsShared.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IInternable.cs">
+      <Link>IInternable.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.cs">
+      <Link>WeakStringCache.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
+      <Link>WeakStringCache.Concurrent.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\OpportunisticIntern.cs">
       <Link>OpportunisticIntern.cs</Link>
     </Compile>
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 58d4be5273c..9dda37aa360 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -117,6 +117,10 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                 successfulExit = p.ExitCode == 0;
             }
 
+            outputHelper?.WriteLine("==== OUTPUT ====");
+            outputHelper?.WriteLine(output);
+            outputHelper?.WriteLine("==============");
+
             Console.WriteLine("==== OUTPUT ====");
             Console.WriteLine(output);
             Console.WriteLine("==============");
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index e77bd5df12b..e8b84435ca2 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -127,6 +127,15 @@
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>Shared\InprocTrackingNativeMethods.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IInternable.cs">
+      <Link>Shared\IInternable.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.cs">
+      <Link>Shared\WeakStringCache.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\WeakStringCache.Concurrent.cs">
+      <Link>Shared\WeakStringCache.Concurrent.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\OpportunisticIntern.cs">
       <Link>Shared\OpportunisticIntern.cs</Link>
     </Compile>
