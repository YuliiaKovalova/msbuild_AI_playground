diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index 1b94ac3357f..1135d50d69e 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -3,8 +3,10 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Engine.UnitTests.TestComparers;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
@@ -343,9 +345,242 @@ public void TestTranslation()
             Assert.True(TranslationHelpers.CompareCollections(result["omega"].Items, deserializedResult["omega"].Items, TaskItemComparer.Instance));
         }
 
-        private BuildRequest CreateNewBuildRequest(int configurationId, string[] targets)
+        [Fact]
+        public void TestMergeResultsWithProjectItems()
+        {
+            BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
+            BuildResult result1 = new BuildResult(request);
+            BuildResult result2 = new BuildResult(request);
+
+            ProjectInstance project1 = new ProjectInstance(ProjectRootElement.Create());
+            var item1 = project1.AddItem("B", "test");
+            item1.SetMetadata("Meta1", "Value1");
+            result1.ProjectStateAfterBuild = project1;
+
+            ProjectInstance project2 = new ProjectInstance(ProjectRootElement.Create());
+            var item2 = project2.AddItem("B", "test");
+            item2.SetMetadata("Meta2", "Value2");
+            item2.SetMetadata("Meta1", "UpdatedValue2");
+            result2.ProjectStateAfterBuild = project2;
+
+            result1.MergeResults(result2);
+
+            var mergedItems = result1.ProjectStateAfterBuild.GetItems("B").ToList();
+            Assert.Equal(1, mergedItems.Count);
+
+            var mergedItem = mergedItems.FirstOrDefault(i => i.EvaluatedInclude == "test");
+            Assert.NotNull(mergedItem);
+            Assert.Equal("UpdatedValue2", mergedItem.GetMetadataValue("Meta1"));
+            Assert.Equal("Value2", mergedItem.GetMetadataValue("Meta2"));
+        }
+
+        [Fact]
+        public void TestMergeResultsWithProjectProperties()
+        {
+            BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
+            BuildResult result1 = new BuildResult(request);
+            BuildResult result2 = new BuildResult(request);
+
+            ProjectInstance project1 = new ProjectInstance(ProjectRootElement.Create());
+            var property1 = project1.SetProperty("A", "test1");
+            result1.ProjectStateAfterBuild = project1;
+
+            ProjectInstance project2 = new ProjectInstance(ProjectRootElement.Create());
+            var property2 = project2.SetProperty("B", "test2");
+            result2.ProjectStateAfterBuild = project2;
+
+            result1.MergeResults(result2);
+
+            var mergedProperty1 = result1.ProjectStateAfterBuild.GetProperty("A");
+            Assert.NotNull(mergedProperty1);
+            Assert.Equal("test1", mergedProperty1.EvaluatedValue);
+
+            var mergedProperty2 = result1.ProjectStateAfterBuild.GetProperty("B");
+            Assert.NotNull(mergedProperty2);
+            Assert.Equal("test2", mergedProperty2.EvaluatedValue);
+        }
+
+        [Fact]
+        public void TestMergeResultsWithRequestedProjectStatePropertyFilters()
+        {
+            // Create a request and two build results
+            BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
+            BuildResult result1 = new BuildResult(request);
+            BuildResult result2 = new BuildResult(request);
+
+            var filter1 = new RequestedProjectState();
+            filter1.PropertyFilters = new List<string> { "Prop1" };
+            filter1.ItemFilters = new Dictionary<string, List<string>>() { };
+
+            var filter2 = new RequestedProjectState();
+            filter2.PropertyFilters = new List<string> { "Prop2" };
+            filter2.ItemFilters = new Dictionary<string, List<string>>() { };
+
+            ProjectInstance project1 = new ProjectInstance(ProjectRootElement.Create());
+            project1.SetProperty("Prop1", "Value1");
+            project1.DefaultTargets.Add("Build");
+
+            ProjectInstance project2 = new ProjectInstance(ProjectRootElement.Create());
+            project2.SetProperty("Prop2", "Value2");
+            project2.SetProperty("Prop3", "Value3");
+            project2.DefaultTargets.Add("Build");
+
+            result1.ProjectStateAfterBuild = project1.FilteredCopy(filter1);
+            result2.ProjectStateAfterBuild = project2.FilteredCopy(filter2);
+
+            result1.MergeResults(result2);
+
+            var mergedFilter = result1.ProjectStateAfterBuild.RequestedProjectStateFilter;
+            Assert.Contains("Prop1", mergedFilter.PropertyFilters);
+            Assert.Contains("Prop2", mergedFilter.PropertyFilters);
+            Assert.NotNull(result1.ProjectStateAfterBuild.GetProperty("Prop1"));
+            Assert.NotNull(result1.ProjectStateAfterBuild.GetProperty("Prop2"));
+
+            Assert.Null(result1.ProjectStateAfterBuild.GetProperty("Prop3"));
+        }
+
+        [Fact]
+        public void TestMergeResultsWithItemFilters()
+        {
+            BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
+            BuildResult result1 = new BuildResult(request);
+            BuildResult result2 = new BuildResult(request);
+
+            ProjectInstance project1 = new ProjectInstance(ProjectRootElement.Create());
+            project1.AddItem("Compile", "File1.cs", new Dictionary<string, string> { { "CustomMetadata1", "Value1" }, });
+
+            ProjectInstance project2 = new ProjectInstance(ProjectRootElement.Create());
+            project2.AddItem("Resource1", "Resource1.resx", new Dictionary<string, string> { { "CustomMetadata2", "Value2" }, { "CustomMetadata3", "Value3" } });
+            project2.AddItem("Resource2", "Resource2.resx", new Dictionary<string, string> { });
+
+            var filter1 = new RequestedProjectState();
+            filter1.ItemFilters = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase) { { "Compile", new List<string>() { "CustomMetadata1" } }, };
+
+            var filter2 = new RequestedProjectState();
+            filter2.ItemFilters = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase) { { "Resource1", new List<string>() { "CustomMetadata3" } }, };
+
+            result1.ProjectStateAfterBuild = project1.FilteredCopy(filter1);
+            result2.ProjectStateAfterBuild = project2.FilteredCopy(filter2);
+
+            result1.MergeResults(result2);
+
+            // Validate merged filters
+            var mergedFilter = result1.ProjectStateAfterBuild.RequestedProjectStateFilter;
+            Assert.Contains("Compile", mergedFilter.ItemFilters.Keys);
+            Assert.Contains("Resource1", mergedFilter.ItemFilters.Keys);
+            Assert.DoesNotContain("Resource2", mergedFilter.ItemFilters.Keys);
+
+            // validate the filtered instance
+            var mergedCompileItem = result1.ProjectStateAfterBuild.GetItems("Compile").ToList();
+            Assert.Equal(1, mergedCompileItem.Count);
+            Assert.Equal("File1.cs", mergedCompileItem.First().EvaluatedInclude);
+            Assert.Equal("Value1", mergedCompileItem.First().GetMetadataValue("CustomMetadata1"));
+
+            var mergedResourceItem = result1.ProjectStateAfterBuild.GetItems("Resource1").ToList();
+            Assert.Equal(1, mergedResourceItem.Count);
+            Assert.Equal("Resource1.resx", mergedResourceItem.First().EvaluatedInclude);
+            Assert.Equal("Value3", mergedResourceItem.First().GetMetadataValue("CustomMetadata3"));
+            Assert.Empty(mergedResourceItem.First().GetMetadataValue("CustomMetadata2"));
+        }
+
+        [Fact]
+        public void TestMergeResultsWithOverlappingItemFilters()
+        {
+            // Create a request and two build results
+            BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
+            BuildResult result1 = new BuildResult(request);
+            BuildResult result2 = new BuildResult(request);
+
+            ProjectInstance project1 = new ProjectInstance(ProjectRootElement.Create());
+            ProjectInstance project2 = new ProjectInstance(ProjectRootElement.Create());
+
+            // Create filters with overlapping item types but different metadata
+            var filter1 = new RequestedProjectState();
+            filter1.ItemFilters = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase)
+            {
+                { "Compile", new List<string> { "CustomMetadata1" } }
+            };
+
+            var filter2 = new RequestedProjectState();
+            filter2.ItemFilters = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase)
+            {
+                { "Compile", new List<string> { "CustomMetadata2" } }
+            };
+
+            // Create filtered copies
+            var filteredProject1 = project1.FilteredCopy(filter1);
+            var filteredProject2 = project2.FilteredCopy(filter2);
+
+            // Assign filtered projects to results
+            result1.ProjectStateAfterBuild = filteredProject1;
+            result2.ProjectStateAfterBuild = filteredProject2;
+
+            // Merge results
+            result1.MergeResults(result2);
+
+            // Verify the merged state has combined filters
+            Assert.NotNull(result1.ProjectStateAfterBuild);
+            Assert.NotNull(result1.ProjectStateAfterBuild.RequestedProjectStateFilter);
+
+            // The merged filter should contain both metadata for the Compile item type
+            var mergedFilter = result1.ProjectStateAfterBuild.RequestedProjectStateFilter;
+            Assert.Contains("CustomMetadata1", mergedFilter.ItemFilters["Compile"]);
+            Assert.Contains("CustomMetadata2", mergedFilter.ItemFilters["Compile"]);
+            Assert.Equal(2, mergedFilter.ItemFilters["Compile"].Count);
+        }
+
+        [Fact]
+        public void TestMergeResultsWithBothPropertyAndItemFilters()
         {
-            return new BuildRequest(1 /* submissionId */, _nodeRequestId++, configurationId, targets, null, BuildEventContext.Invalid, null);
+            // Create a request and two build results
+            BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
+            BuildResult result1 = new BuildResult(request);
+            BuildResult result2 = new BuildResult(request);
+
+            // Create ProjectInstances
+            ProjectInstance project1 = new ProjectInstance(ProjectRootElement.Create());
+            ProjectInstance project2 = new ProjectInstance(ProjectRootElement.Create());
+
+            // Create filter with property filters
+            var filter1 = new RequestedProjectState();
+            filter1.PropertyFilters = new List<string> { "Prop1", "Prop2" };
+
+            // Create filter with item filters
+            var filter2 = new RequestedProjectState();
+            filter2.ItemFilters = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase)
+            {
+                { "Compile", new List<string> { "CustomMetadata1" } }
+            };
+
+            // Create filtered copies
+            var filteredProject1 = project1.FilteredCopy(filter1);
+            var filteredProject2 = project2.FilteredCopy(filter2);
+
+            // Assign filtered projects to results
+            result1.ProjectStateAfterBuild = filteredProject1;
+            result2.ProjectStateAfterBuild = filteredProject2;
+
+            // Merge results
+            result1.MergeResults(result2);
+
+            // Verify the merged state has both property and item filters
+            Assert.NotNull(result1.ProjectStateAfterBuild);
+            Assert.NotNull(result1.ProjectStateAfterBuild.RequestedProjectStateFilter);
+
+            // The merged filter should have both property and item filters
+            var mergedFilter = result1.ProjectStateAfterBuild.RequestedProjectStateFilter;
+            Assert.NotNull(mergedFilter.PropertyFilters);
+            Assert.NotNull(mergedFilter.ItemFilters);
+
+            // Check property filters
+            Assert.Contains("Prop1", mergedFilter.PropertyFilters);
+            Assert.Contains("Prop2", mergedFilter.PropertyFilters);
+
+            // Check item filters
+            Assert.Contains("Compile", mergedFilter.ItemFilters.Keys);
+            Assert.Contains("CustomMetadata1", mergedFilter.ItemFilters["Compile"]);
         }
+
+        private BuildRequest CreateNewBuildRequest(int configurationId, string[] targets) => new BuildRequest(1 /* submissionId */, _nodeRequestId++, configurationId, targets, null, BuildEventContext.Invalid, null);
     }
 }
diff --git a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
index fa324777269..c25377390c7 100644
--- a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
+++ b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
@@ -44,17 +44,107 @@ internal RequestedProjectState DeepClone()
             RequestedProjectState result = new RequestedProjectState();
             if (PropertyFilters is not null)
             {
-                result.PropertyFilters = new List<string>(PropertyFilters);
+                result.PropertyFilters = [.. PropertyFilters];
             }
+
             if (ItemFilters is not null)
             {
                 result.ItemFilters = ItemFilters.ToDictionary(
                     kvp => kvp.Key,
                     kvp => kvp.Value == null ? null : new List<string>(kvp.Value));
             }
+
             return result;
         }
 
+        /// <summary>
+        /// Returns a new RequestedProjectState that contains the union of filters from this instance and another.
+        /// </summary>
+        /// <param name="other">The other RequestedProjectState to merge with.</param>
+        /// <returns>A new RequestedProjectState representing the merged filters.</returns>
+        internal RequestedProjectState Merge(RequestedProjectState other)
+        {
+            // If either is null, return a clone of the non-null one
+            if (other == null)
+            {
+                return DeepClone();
+            }
+
+            RequestedProjectState result = new RequestedProjectState();
+
+            // Merge property filters
+            if (PropertyFilters != null || other.PropertyFilters != null)
+            {
+                HashSet<string> mergedProperties = new(StringComparer.OrdinalIgnoreCase);
+                if (PropertyFilters != null)
+                {
+                    foreach (var prop in PropertyFilters)
+                    {
+                        mergedProperties.Add(prop);
+                    }
+                }
+
+                if (other.PropertyFilters != null)
+                {
+                    foreach (var prop in other.PropertyFilters)
+                    {
+                        mergedProperties.Add(prop);
+                    }
+                }
+
+                if (mergedProperties.Count > 0)
+                {
+                    result.PropertyFilters = mergedProperties?.ToList();
+                }
+            }
+
+            // Merge item filters
+            if (ItemFilters != null || other.ItemFilters != null)
+            {
+                Dictionary<string, List<string>> mergedItems = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+
+                // Add items from both filters
+                MergeItemFiltersFrom(mergedItems, ItemFilters);
+                MergeItemFiltersFrom(mergedItems, other.ItemFilters);
+
+                if (mergedItems.Count > 0)
+                {
+                    result.ItemFilters = mergedItems;
+                }
+            }
+
+            return result;
+
+            // Helper method to add item filters from a source to the merged result
+            void MergeItemFiltersFrom(Dictionary<string, List<string>> mergedItems, IDictionary<string, List<string>> source)
+            {
+                if (source == null)
+                {
+                    return;
+                }
+
+                foreach (var itemType in source)
+                {
+                    if (!mergedItems.TryGetValue(itemType.Key, out List<string> metadataList))
+                    {
+                        metadataList = new List<string>();
+                        mergedItems[itemType.Key] = metadataList;
+                    }
+
+                    if (itemType.Value != null)
+                    {
+                        foreach (var metadata in itemType.Value)
+                        {
+                            if (!metadataList.Contains(metadata, StringComparer.OrdinalIgnoreCase))
+                            {
+                                metadataList.Add(metadata);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
         /// <summary>
         /// Returns true if this instance contains all property and item filters present in another instance.
         /// </summary>
@@ -72,7 +162,7 @@ internal bool IsSubsetOf(RequestedProjectState another)
             }
             else if (another.PropertyFilters is not null)
             {
-                HashSet<string> anotherPropertyFilters = new HashSet<string>(another.PropertyFilters);
+                HashSet<string> anotherPropertyFilters = new(another.PropertyFilters);
                 foreach (string propertyFilter in PropertyFilters)
                 {
                     if (!anotherPropertyFilters.Contains(propertyFilter))
@@ -99,6 +189,7 @@ internal bool IsSubsetOf(RequestedProjectState another)
                         // The instance to compare against doesn't have this item -> not a subset.
                         return false;
                     }
+
                     if (kvp.Value is null)
                     {
                         if (metadata is not null)
@@ -109,7 +200,7 @@ internal bool IsSubsetOf(RequestedProjectState another)
                     }
                     else if (metadata is not null)
                     {
-                        HashSet<string> anotherMetadata = new HashSet<string>(metadata);
+                        HashSet<string> anotherMetadata = [.. metadata];
                         foreach (string metadatum in kvp.Value)
                         {
                             if (!anotherMetadata.Contains(metadatum))
@@ -130,19 +221,10 @@ void ITranslatable.Translate(ITranslator translator)
             translator.TranslateDictionary(ref _itemFilters, TranslateString, TranslateMetadataForItem, CreateItemMetadataDictionary);
         }
 
-        private static IDictionary<string, List<string>> CreateItemMetadataDictionary(int capacity)
-        {
-            return new Dictionary<string, List<string>>(capacity, StringComparer.OrdinalIgnoreCase);
-        }
+        private static IDictionary<string, List<string>> CreateItemMetadataDictionary(int capacity) => new Dictionary<string, List<string>>(capacity, StringComparer.OrdinalIgnoreCase);
 
-        private static void TranslateMetadataForItem(ITranslator translator, ref List<string> list)
-        {
-            translator.Translate(ref list);
-        }
+        private static void TranslateMetadataForItem(ITranslator translator, ref List<string> list) => translator.Translate(ref list);
 
-        private static void TranslateString(ITranslator translator, ref string s)
-        {
-            translator.Translate(ref s);
-        }
+        private static void TranslateString(ITranslator translator, ref string s) => translator.Translate(ref s);
     }
 }
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 60b8a0dc12c..103c4c20c67 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -35,26 +35,14 @@ internal class ResultsCache : IResultsCache
         /// <summary>
         /// Creates an empty results cache.
         /// </summary>
-        public ResultsCache()
-        {
-            _resultsByConfiguration = new ConcurrentDictionary<int, BuildResult>();
-        }
+        public ResultsCache() => _resultsByConfiguration = new ConcurrentDictionary<int, BuildResult>();
 
-        public ResultsCache(ITranslator translator)
-        {
-            Translate(translator);
-        }
+        public ResultsCache(ITranslator translator) => Translate(translator);
 
         /// <summary>
         /// Returns the internal cache for testing purposes.
         /// </summary>
-        internal IDictionary<int, BuildResult> ResultsDictionary
-        {
-            get
-            {
-                return _resultsByConfiguration;
-            }
-        }
+        internal IDictionary<int, BuildResult> ResultsDictionary => _resultsByConfiguration;
 
         #region IResultsCache Members
 
@@ -357,34 +345,26 @@ private static bool AreBuildResultFlagsCompatible(BuildRequest buildRequest, Bui
                 return true;
             }
 
-            BuildRequestDataFlags buildRequestDataFlags = buildRequest.BuildRequestDataFlags;
-            BuildRequestDataFlags buildResultDataFlags = (BuildRequestDataFlags)buildResult.BuildRequestDataFlags;
+            BuildRequestDataFlags requestFlags = buildRequest.BuildRequestDataFlags;
+            BuildRequestDataFlags resultFlags = (BuildRequestDataFlags)buildResult.BuildRequestDataFlags;
 
-            if ((buildRequestDataFlags & FlagsAffectingBuildResults) != (buildResultDataFlags & FlagsAffectingBuildResults))
+            if ((requestFlags & FlagsAffectingBuildResults) != (resultFlags & FlagsAffectingBuildResults))
             {
                 // Mismatch in flags that can affect build results -> not compatible.
                 return false;
             }
 
-            if (HasProvideProjectStateAfterBuild(buildRequestDataFlags))
+            // ProvideProjectStateAfterBuild represents full state.
+            // If full state is requested, we must have full state in the cache result.
+            if (HasFlag(requestFlags, BuildRequestDataFlags.ProvideProjectStateAfterBuild))
             {
-                // If full state is requested, we must have full state in the result.
-                return HasProvideProjectStateAfterBuild(buildResultDataFlags);
+                return HasFlag(resultFlags, BuildRequestDataFlags.ProvideProjectStateAfterBuild);
             }
 
-            if (HasProvideSubsetOfStateAfterBuild(buildRequestDataFlags))
+            // ProvideSubsetOfStateAfterBuild represents a subset of state.
+            // Verify that the requested subset is compatible with the cache result.
+            if (HasFlag(requestFlags, BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild))
             {
-                // If partial state is requested, we must have full or partial-and-compatible state in the result.
-                if (HasProvideProjectStateAfterBuild(buildResultDataFlags))
-                {
-                    return true;
-                }
-                if (!HasProvideSubsetOfStateAfterBuild(buildResultDataFlags))
-                {
-                    return false;
-                }
-
-                // Verify that the requested subset is compatible with the result.
                 return buildRequest.RequestedProjectState is not null &&
                     buildResult.ProjectStateAfterBuild?.RequestedProjectStateFilter is not null &&
                     buildRequest.RequestedProjectState.IsSubsetOf(buildResult.ProjectStateAfterBuild.RequestedProjectStateFilter);
@@ -392,21 +372,11 @@ private static bool AreBuildResultFlagsCompatible(BuildRequest buildRequest, Bui
 
             return true;
 
-            static bool HasProvideProjectStateAfterBuild(BuildRequestDataFlags flags)
-                => (flags & BuildRequestDataFlags.ProvideProjectStateAfterBuild) == BuildRequestDataFlags.ProvideProjectStateAfterBuild;
-
-            static bool HasProvideSubsetOfStateAfterBuild(BuildRequestDataFlags flags)
-                => (flags & BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild) == BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;
+            static bool HasFlag(BuildRequestDataFlags flags, BuildRequestDataFlags flagToCheck) => (flags & flagToCheck) == flagToCheck;
         }
 
-        public IEnumerator<BuildResult> GetEnumerator()
-        {
-            return _resultsByConfiguration.Values.GetEnumerator();
-        }
+        public IEnumerator<BuildResult> GetEnumerator() => _resultsByConfiguration.Values.GetEnumerator();
 
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return GetEnumerator();
-        }
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
     }
 }
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 1ef8455bdf1..121d3f08fd3 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -588,6 +588,10 @@ public void MergeResults(BuildResult results)
                 _resultsByTarget![targetResult.Key] = targetResult.Value;
             }
 
+            _projectStateAfterBuild = MergeProjectStateAfterBuildInstances(results._buildRequestDataFlags, results._projectStateAfterBuild);
+
+            _buildRequestDataFlags = MergeBuildFlags(results._buildRequestDataFlags);
+
             // If there is an exception and we did not previously have one, add it in.
             _requestException ??= results.Exception;
         }
@@ -756,13 +760,153 @@ internal void SetOverallResult(bool overallResult)
         }
 
         /// <summary>
-        /// Creates the target result dictionary.
+        /// Merges two sets of BuildRequestDataFlags according to MSBuild's requirements.
         /// </summary>
-        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity)
+        /// <param name="newFlags">The new flags to merge with the existing flags.</param>
+        /// <returns>The merged BuildRequestDataFlags.</returns>
+        private BuildRequestDataFlags MergeBuildFlags(BuildRequestDataFlags? newFlags)
         {
-            return new ConcurrentDictionary<string, TargetResult>(1, capacity, StringComparer.OrdinalIgnoreCase);
+            // If we have ProvideProjectStateAfterBuild set, it means we have a full project instance, so we don't need to merge anything.
+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)
+            {
+                return _buildRequestDataFlags;
+            }
+
+            BuildRequestDataFlags mergedFlags = _buildRequestDataFlags | (newFlags ?? Execution.BuildRequestDataFlags.None);
+
+            // If ProvideProjectStateAfterBuild is set in new flags, it takes precedence over ProvideSubsetOfStateAfterBuild.
+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)
+            {
+                mergedFlags &= ~Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;
+            }
+
+            return mergedFlags;
         }
 
+        /// <summary>
+        /// Merges properties, items and RequestedProjectState from a new ProjectStateAfterBuild instance into the existing one.
+        /// </summary>
+        /// <param name="newFlags">The request flags.</param>
+        /// <param name="newProjectStateAfterBuild">The new ProjectStateAfterBuild instance to merge.</param>
+        /// <returns>A merged ProjectInstance containing properties and items from both instances, or null if both instances are null.</returns>
+        private ProjectInstance? MergeProjectStateAfterBuildInstances(BuildRequestDataFlags? newFlags, ProjectInstance? newProjectStateAfterBuild)
+        {
+            if ((_buildRequestDataFlags & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)
+            {
+                return _projectStateAfterBuild;
+            }
+
+            if (newFlags.HasValue && (newFlags.Value & Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild) != 0)
+            {
+                return newProjectStateAfterBuild;
+            }
+
+            if (newProjectStateAfterBuild == null)
+            {
+                return _projectStateAfterBuild;
+            }
+
+            if (_projectStateAfterBuild == null)
+            {
+                return newProjectStateAfterBuild;
+            }
+
+            // Create a deep copy of the existing ProjectStateAfterBuild
+            ProjectInstance mergedInstanceCandidate = _projectStateAfterBuild.DeepCopy(isImmutable: false);
+            MergeProperties(newProjectStateAfterBuild.Properties);
+            MergeItems(newProjectStateAfterBuild.Items);
+
+            // Merge RequestedProjectStateFilter
+            var sourceFilter = _projectStateAfterBuild.RequestedProjectStateFilter;
+            var newFilter = newProjectStateAfterBuild.RequestedProjectStateFilter;
+            if (sourceFilter != null || newFilter != null)
+            {
+                RequestedProjectState mergedFilter;
+
+                if (sourceFilter == null)
+                {
+                    mergedFilter = newFilter.DeepClone();
+                }
+                else if (newFilter == null)
+                {
+                    mergedFilter = sourceFilter.DeepClone();
+                }
+                else
+                {
+                    mergedFilter = sourceFilter.Merge(newFilter);
+                }
+
+                return mergedInstanceCandidate.FilteredCopy(mergedFilter);
+            }
+
+            return mergedInstanceCandidate;
+
+            void MergeProperties(ICollection<ProjectPropertyInstance> newProperties)
+            {
+                foreach (var property in newProperties)
+                {
+                    if (mergedInstanceCandidate.GetProperty(property.Name) == null)
+                    {
+                        mergedInstanceCandidate.SetProperty(property.Name, property.EvaluatedValue);
+                    }
+                }
+            }
+
+            void MergeItems(ICollection<ProjectItemInstance> newItems)
+            {
+                // Maps item types (e.g., "Compile") to a set of includes (e.g., "File1.cs")
+                var existingItemsByType = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);
+
+                // Maps a tuple of (item type, include) to the actual item instance
+                var existingItemsLookup = new Dictionary<(string, string), ProjectItemInstance>(ItemIdentityComparer.Instance);
+
+                foreach (var item in mergedInstanceCandidate.Items)
+                {
+                    if (!existingItemsByType.TryGetValue(item.ItemType, out var itemSet))
+                    {
+                        itemSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+                        existingItemsByType[item.ItemType] = itemSet;
+                    }
+
+                    itemSet.Add(item.EvaluatedInclude);
+                    existingItemsLookup[(item.ItemType, item.EvaluatedInclude)] = item;
+                }
+
+                // Add new items that don't already exist and merge metadata for existing ones
+                foreach (var item in newProjectStateAfterBuild.Items)
+                {
+                    if (existingItemsByType.TryGetValue(item.ItemType, out var existingItems) && existingItems.Contains(item.EvaluatedInclude))
+                    {
+                        var existingItem = existingItemsLookup[(item.ItemType, item.EvaluatedInclude)];
+
+                        // Merge metadata from the new item into the existing one
+                        foreach (var metadata in item.EnumerateMetadata())
+                        {
+                            existingItem.SetMetadata(metadata.Key, metadata.Value);
+                        }
+                    }
+                    // If the item doesn't exist, add it to the merged instance candidate and update the existing items dictionary
+                    else
+                    {
+                        mergedInstanceCandidate.AddItem(item.ItemType, item.EvaluatedInclude, item.EnumerateMetadata());
+
+                        if (existingItems == null)
+                        {
+                            existingItems = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+                            existingItemsByType[item.ItemType] = existingItems;
+                        }
+
+                        existingItems.Add(item.EvaluatedInclude);
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Creates the target result dictionary.
+        /// </summary>
+        private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionary(int capacity) => new(1, capacity, StringComparer.OrdinalIgnoreCase);
+
         /// <summary>
         /// Creates the target result dictionary and populates it with however many target results are
         /// available given the list of targets passed.
@@ -781,5 +925,29 @@ private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDict
 
             return resultsByTarget;
         }
+
+        /// <summary>
+        /// A specialized equality comparer for string tuples optimized for MSBuild item identity.
+        /// </summary>
+        private class ItemIdentityComparer : IEqualityComparer<(string, string)>
+        {
+            // Singleton instance for reuse
+            public static readonly ItemIdentityComparer Instance = new ItemIdentityComparer();
+
+            // Private constructor to enforce singleton pattern
+            private ItemIdentityComparer() { }
+
+            public bool Equals((string, string) x, (string, string) y) =>
+                StringComparer.OrdinalIgnoreCase.Equals(x.Item1, y.Item1) &&
+                StringComparer.OrdinalIgnoreCase.Equals(x.Item2, y.Item2);
+
+            public int GetHashCode((string, string) obj)
+            {
+                int hash = 17;
+                hash = hash * 23 + (obj.Item1 == null ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(obj.Item1));
+                hash = hash * 23 + (obj.Item2 == null ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(obj.Item2));
+                return hash;
+            }
+        }
     }
 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index f77da95817b..0ed160742c2 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -708,37 +708,44 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
 
             if (filter == null)
             {
-                _properties = new PropertyDictionary<ProjectPropertyInstance>(that._properties.Count);
+                _properties = that._properties is null
+                    ? new PropertyDictionary<ProjectPropertyInstance>(0)
+                    : new PropertyDictionary<ProjectPropertyInstance>(that._properties.Count);
 
                 foreach (ProjectPropertyInstance property in that.Properties)
                 {
                     _properties.Set(property.DeepClone(_isImmutable));
                 }
 
-                _items = new ItemDictionary<ProjectItemInstance>(that._items.Count);
+                _items = that._items is null
+                    ? new ItemDictionary<ProjectItemInstance>(0)
+                    : new ItemDictionary<ProjectItemInstance>(that._items.Count);
 
                 foreach (ProjectItemInstance item in that.Items)
                 {
                     _items.Add(item.DeepClone(this));
                 }
 
-                _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(that._globalProperties.Count);
+                _globalProperties = that._globalProperties is null
+                    ? new PropertyDictionary<ProjectPropertyInstance>(0)
+                    : new PropertyDictionary<ProjectPropertyInstance>(that._globalProperties.Count);
 
-                foreach (ProjectPropertyInstance globalProperty in that.GlobalPropertiesDictionary)
+                foreach (ProjectPropertyInstance globalProperty in that.GlobalPropertiesDictionary ?? new PropertyDictionary<ProjectPropertyInstance>(0))
                 {
                     _globalProperties.Set(globalProperty.DeepClone(_isImmutable));
                 }
 
-                _environmentVariableProperties =
-                    new PropertyDictionary<ProjectPropertyInstance>(that._environmentVariableProperties.Count);
+                _environmentVariableProperties = that._environmentVariableProperties is null
+                    ? new PropertyDictionary<ProjectPropertyInstance>(0)
+                    : new PropertyDictionary<ProjectPropertyInstance>(that._environmentVariableProperties.Count);
 
-                foreach (ProjectPropertyInstance environmentProperty in that._environmentVariableProperties)
+                foreach (ProjectPropertyInstance environmentProperty in that._environmentVariableProperties ?? new PropertyDictionary<ProjectPropertyInstance>(0))
                 {
                     _environmentVariableProperties.Set(environmentProperty.DeepClone(_isImmutable));
                 }
 
-                this.DefaultTargets = new List<string>(that.DefaultTargets);
-                this.InitialTargets = new List<string>(that.InitialTargets);
+                this.DefaultTargets = [.. that.DefaultTargets ?? []];
+                this.InitialTargets = [.. that.InitialTargets ?? []];
                 ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
                     ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(
                     ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
@@ -752,12 +759,12 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                 this.Toolset = that.Toolset;
                 this.SubToolsetVersion = that.SubToolsetVersion;
                 _targets = that._targets;
-                _itemDefinitions = that._itemDefinitions;
+                _itemDefinitions = that._itemDefinitions ?? new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(StringComparer.OrdinalIgnoreCase);
                 _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
-                _importPaths = that._importPaths;
-                ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
+                _importPaths = that._importPaths ?? new List<string>();
+                ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths ?? []);
                 _importPathsIncludingDuplicates = that._importPathsIncludingDuplicates;
-                ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
+                ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates ?? []);
 
                 this.EvaluatedItemElements = that.EvaluatedItemElements;
 
@@ -1935,7 +1942,7 @@ public ProjectPropertyInstance SetProperty(string name, string evaluatedValue)
         }
 
         /// <summary>
-        /// Adds an item with no metadata to the project
+        /// Adds an item with no metadata to the project.
         /// </summary>
         /// <remarks>
         /// We don't take a ProjectItemInstance to make sure we don't have one that's already
