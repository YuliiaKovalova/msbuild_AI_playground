diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 0faa9a25dbc..966fea17b1e 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -6,13 +6,13 @@
       <Sha>249a53452a198b19cf6d3ac90ad25265ee77ee59</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.1.0-preview.1.47">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.1.0-preview.1.62">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>c14b85a00c03933c708c7d38fefeda9898a21488</Sha>
+      <Sha>9187a50daec29061772a2057490697c6c0e4c354</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.1.0-2.21574.9">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.1.0-2.21605.2">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>16333a806a64c3546faf0320063b66ff32936eaa</Sha>
+      <Sha>f8ef87e10cb633f07803b5b5abee1ceaa4efc2fb</Sha>
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21573.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
diff --git a/eng/Versions.props b/eng/Versions.props
index 221ff51f5c4..11e6ece3772 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -34,8 +34,8 @@
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21573.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.1.0-2.21574.9</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.1.0-preview.1.47</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.1.0-2.21605.2</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.1.0-preview.1.62</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 36c8a20a7f0..00221821ec4 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -77,9 +77,6 @@
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\StringBuilderCache.cs">
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 4ac69f51f4f..ebbec93cd53 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -19,6 +19,7 @@
 
 using MockHost = Microsoft.Build.UnitTests.BackEnd.MockHost;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.Logging
 {
@@ -54,6 +55,7 @@ public void LogBuildEventNullEvent()
             }
            );
         }
+
         /// <summary>
         /// Test LogBuildevent by logging a number of events with both OnlyLogCriticalEvents On and Off
         /// </summary>
@@ -104,6 +106,7 @@ public void LogErrorNullMessageResource()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternlErrorException is thrown when an empty MessageResourceName is passed in.
         /// </summary>
@@ -117,6 +120,7 @@ public void LogErrorEmptyMessageResource()
             }
            );
         }
+
         /// <summary>
         /// Verify a message is logged when all of the parameters are filled out correctly.
         /// </summary>
@@ -154,6 +158,7 @@ public void LogInvalidProjectFileErrorNullEventContext()
             }
            );
         }
+
         /// <summary>
         /// Verify an exception is thrown when a null Invalid ProjectFile exception is passed in
         /// </summary>
@@ -167,6 +172,7 @@ public void LogInvalidProjectFileErrorNullException()
             }
            );
         }
+
         /// <summary>
         /// Verify a message is logged when both parameters are good and
         /// the exception has not been logged yet. Verify with and without OnlyLogCriticalEvents.
@@ -215,6 +221,7 @@ public void LogFatalErrorNullContext()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when fileInfo is null
         /// </summary>
@@ -228,6 +235,7 @@ public void LogFatalErrorNullFileInfo()
             }
            );
         }
+
         /// <summary>
         /// Verify a error message is correctly logged when  the exception is null.
         /// </summary>
@@ -260,6 +268,7 @@ public void LogFatalErrorNullMessageResourceName()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when messageResourceName is empty
         /// </summary>
@@ -274,6 +283,7 @@ public void LogFatalErrorEmptyMessageResourceName()
             }
            );
         }
+
         /// <summary>
         /// Verify a error message is correctly logged when all of the inputs are valid.
         /// </summary>
@@ -334,6 +344,7 @@ public void LogFatalTaskErrorNullTaskNameName()
             }
            );
         }
+
         /// <summary>
         /// Verify a error message is correctly logged when all of the inputs are valid.
         /// </summary>
@@ -374,6 +385,7 @@ public void LogErrorFromTextNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException when a null FileInfo is passed in
         /// </summary>
@@ -387,6 +399,7 @@ public void LogErrorFromTextNullFileInfo()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when a null message is passed in
         /// </summary>
@@ -400,6 +413,7 @@ public void LogErrorFromTextNullMessage()
             }
            );
         }
+
         /// <summary>
         /// Test LogErrorFromText with a number of different inputs
         /// </summary>
@@ -509,6 +523,7 @@ public void LogTaskWarningFromExceptionNullTaskName()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when taskName is empty
         /// </summary>
@@ -523,6 +538,7 @@ public void LogTaskWarningFromExceptionEmptyTaskName()
             }
            );
         }
+
         /// <summary>
         /// Verify a LogTaskWarningFromException with a null exception and a non null exception
         /// with all of the other fields properly filled out.
@@ -566,6 +582,7 @@ public void LogWarningNullMessageResource()
             }
            );
         }
+
         /// <summary>
         /// Verify an exception is when a empty MessageResourceName is passed in.
         /// </summary>
@@ -579,6 +596,7 @@ public void LogWarningEmptyMessageResource()
             }
            );
         }
+
         /// <summary>
         /// Verify a message is logged when all of the parameters are filled out
         /// </summary>
@@ -606,6 +624,7 @@ public void LogWarningFromTextNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when a null fileInfo is passed in
         /// </summary>
@@ -619,6 +638,7 @@ public void LogWarningFromTextNullFileInfo()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when a null message is passed in
         /// </summary>
@@ -632,6 +652,7 @@ public void LogWarningFromTextNullMessage()
             }
            );
         }
+
         /// <summary>
         /// Test LogWarningFromText with a number of different inputs
         /// </summary>
@@ -676,6 +697,7 @@ public void LogCommentNullMessageResourceName()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when a empty messageResource name is passed in
         /// </summary>
@@ -689,6 +711,7 @@ public void LogCommentEmptyMessageResourceName()
             }
            );
         }
+
         /// <summary>
         /// Verify LogComment by testing it with OnlyLogCriticalEvents On and Off when the rest of the fields are
         /// valid inputs.
@@ -729,6 +752,7 @@ public void LogCommentFromTextNullMessage()
             }
            );
         }
+
         /// <summary>
         /// Verify a message is logged when an empty message is passed in
         /// </summary>
@@ -752,6 +776,7 @@ public void LogCommentFromTextNullBuildEventContextMessage()
             }
            );
         }
+
         /// <summary>
         /// Make sure we can log a comment when everything should be working correctly
         /// </summary>
@@ -792,6 +817,7 @@ public void ProjectStartedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Expect an exception to be thrown if a null build event context is passed in
         /// and OnlyLogCriticalEvents is false
@@ -806,30 +832,157 @@ public void ProjectStartedNullParentBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the case where ProjectFile is good and TargetNames is null.
         /// Expect an event to be logged
         /// </summary>
+        [Theory]
+        [InlineData("ProjectFile", null)] // Good project File and null target names
+        [InlineData("ProjectFile", "")] // Good project File and empty target names
+        [InlineData(null, null)] // Null project file and null target names
+        [InlineData("", null)] // // Empty project file null target Names
+        [InlineData("", "")] // Empty project File and Empty target Names
+        [InlineData("ProjectFile", "TargetNames")] // Good inputs
+        public void ProjectStartedEventTests(string projectFile, string targetNames)
+        {
+            string message;
+            if (!String.IsNullOrEmpty(targetNames))
+            {
+                message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithTargetNames", Path.GetFileName(projectFile), targetNames);
+            }
+            else
+            {
+                message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", Path.GetFileName(projectFile));
+            }
+
+            MockHost componentHost = new MockHost();
+            ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
+            ConfigCache cache = (ConfigCache)componentHost.GetComponent(BuildComponentType.ConfigCache);
+
+            BuildRequestData data = new BuildRequestData("file", new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase), "toolsVersion", new string[0], null);
+            BuildRequestConfiguration config = new BuildRequestConfiguration(2, data, "4.0");
+            cache.AddConfiguration(config);
+
+            BuildEventContext context = service.LogProjectStarted(s_buildEventContext, 1, 2, s_buildEventContext, projectFile, targetNames, null, null);
+            BuildEventContext parentBuildEventContext = s_buildEventContext;
+            VerifyProjectStartedEventArgs(service, context.ProjectContextId, message, projectFile, targetNames, parentBuildEventContext, context);
+
+            service.ResetProcessedBuildEvent();
+        }
+
+        /// <summary>
+        /// Expect the returned BuildEventContext to have the provided ProjectContextId
+        /// </summary>
+        [Fact]
+        public void ProjectStartedProvidedProjectContextId()
+        {
+            const int SubmissionId = 1;
+            const int EvaluationId = 2;
+            const int ConfigurationId = 3;
+            const string ProjectFile = "SomeProjectFile";
+
+            MockHost componentHost = new MockHost();
+            ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
+            ConfigCache cache = (ConfigCache)componentHost.GetComponent(BuildComponentType.ConfigCache);
+
+            BuildRequestData data = new BuildRequestData(ProjectFile, new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase), "toolsVersion", Array.Empty<string>(), null);
+            BuildRequestConfiguration config = new BuildRequestConfiguration(ConfigurationId, data, "4.0");
+            cache.AddConfiguration(config);
+
+            BuildEventContext projectCacheBuildEventContext = service.CreateProjectCacheBuildEventContext(SubmissionId, EvaluationId, ConfigurationId, ProjectFile);
+            projectCacheBuildEventContext.NodeId.ShouldBe(Scheduler.InProcNodeId);
+            projectCacheBuildEventContext.ProjectContextId.ShouldNotBe(BuildEventContext.InvalidProjectContextId);
+
+            BuildEventContext nodeBuildEventContext = new BuildEventContext(Scheduler.InProcNodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+            BuildEventContext projectStartedBuildEventContext = service.LogProjectStarted(
+                nodeBuildEventContext,
+                submissionId: SubmissionId,
+                configurationId: ConfigurationId,
+                parentBuildEventContext: BuildEventContext.Invalid,
+                projectFile: ProjectFile,
+                targetNames: "TargetNames",
+                properties: null,
+                items: null,
+                evaluationId: EvaluationId,
+                projectContextId: projectCacheBuildEventContext.ProjectContextId);
+            projectStartedBuildEventContext.ProjectContextId.ShouldBe(projectCacheBuildEventContext.ProjectContextId);
+        }
+
+        /// <summary>
+        /// Expect an exception to be thrown if an unknown project context id is passed in for the in-proc node
+        /// </summary>
         [Fact]
-        public void ProjectStartedEventTests()
+        public void ProjectStartedProvidedUnknownProjectContextIdInProcNode()
         {
-            // Good project File and null target names
-            LogProjectStartedTestHelper("ProjectFile", null);
+            const int SubmissionId = 1;
+            const int EvaluationId = 2;
+            const int ConfigurationId = 3;
+            const string ProjectFile = "SomeProjectFile";
+            const int ProjectContextId = 123;
+
+            MockHost componentHost = new MockHost();
+            ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
+            ConfigCache cache = (ConfigCache)componentHost.GetComponent(BuildComponentType.ConfigCache);
+
+            BuildRequestData data = new BuildRequestData(ProjectFile, new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase), "toolsVersion", Array.Empty<string>(), null);
+            BuildRequestConfiguration config = new BuildRequestConfiguration(ConfigurationId, data, "4.0");
+            cache.AddConfiguration(config);
+
+            BuildEventContext nodeBuildEventContext = new BuildEventContext(Scheduler.InProcNodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+            Assert.Throws<InternalErrorException>(() =>
+            {
+                service.LogProjectStarted(
+                    nodeBuildEventContext,
+                    submissionId: SubmissionId,
+                    configurationId: ConfigurationId,
+                    parentBuildEventContext: BuildEventContext.Invalid,
+                    projectFile: ProjectFile,
+                    targetNames: "TargetNames",
+                    properties: null,
+                    items: null,
+                    evaluationId: EvaluationId,
+                    projectContextId: ProjectContextId);
+            });
+        }
 
-            // Good project File and empty target names
-            LogProjectStartedTestHelper("ProjectFile", string.Empty);
+        /// <summary>
+        /// Expect an unknown project context id to be accepted on an out-of-proc node.
+        /// </summary>
+        [Fact]
+        public void ProjectStartedProvidedUnknownProjectContextIdOutOfProcNode()
+        {
+            const int SubmissionId = 1;
+            const int EvaluationId = 2;
+            const int ConfigurationId = 3;
+            const string ProjectFile = "SomeProjectFile";
+            const int NodeId = 2;
+            const int ProjectContextId = 123;
 
-            // Null project file and null target names
-            LogProjectStartedTestHelper(null, null);
+            // Ensure we didn't pick the one bad const value
+            NodeId.ShouldNotBe(Scheduler.InProcNodeId);
 
-            // Empty project file null target Names
-            LogProjectStartedTestHelper(string.Empty, null);
+            MockHost componentHost = new MockHost();
+            ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
+            ConfigCache cache = (ConfigCache)componentHost.GetComponent(BuildComponentType.ConfigCache);
 
-            // Empty project File and Empty target Names
-            LogProjectStartedTestHelper(string.Empty, string.Empty);
+            BuildRequestData data = new BuildRequestData(ProjectFile, new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase), "toolsVersion", Array.Empty<string>(), null);
+            BuildRequestConfiguration config = new BuildRequestConfiguration(ConfigurationId, data, "4.0");
+            cache.AddConfiguration(config);
 
-            // TestGoodInputs
-            LogProjectStartedTestHelper("ProjectFile", "TargetNames");
+            BuildEventContext nodeBuildEventContext = new BuildEventContext(NodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+            BuildEventContext projectStartedBuildEventContext = service.LogProjectStarted(
+                nodeBuildEventContext,
+                submissionId: SubmissionId,
+                configurationId: ConfigurationId,
+                parentBuildEventContext: BuildEventContext.Invalid,
+                projectFile: ProjectFile,
+                targetNames: "TargetNames",
+                properties: null,
+                items: null,
+                evaluationId: EvaluationId,
+                projectContextId: ProjectContextId);
+            projectStartedBuildEventContext.ProjectContextId.ShouldBe(ProjectContextId);
         }
 
         #endregion
@@ -849,6 +1002,7 @@ public void ProjectFinishedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the project finished event
         /// </summary>
@@ -874,7 +1028,7 @@ public void ProjectFinished()
         public void LogBuildStarted()
         {
             ProcessBuildEventHelper service =
-                (ProcessBuildEventHelper) ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
+                (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
 
             service.LogBuildStarted();
 
@@ -885,7 +1039,7 @@ public void LogBuildStarted()
                     service.ProcessedBuildEvent.Timestamp);
 
             Assert.IsType<BuildStartedEventArgs>(service.ProcessedBuildEvent);
-            Assert.Equal(buildEvent, (BuildStartedEventArgs) service.ProcessedBuildEvent,
+            Assert.Equal(buildEvent, (BuildStartedEventArgs)service.ProcessedBuildEvent,
                 new EventArgsEqualityComparer<BuildStartedEventArgs>());
         }
 
@@ -896,7 +1050,7 @@ public void LogBuildStarted()
         public void LogBuildStartedCriticalOnly()
         {
             ProcessBuildEventHelper service =
-                (ProcessBuildEventHelper) ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
+                (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.OnlyLogCriticalEvents = true;
             service.LogBuildStarted();
 
@@ -906,7 +1060,7 @@ public void LogBuildStartedCriticalOnly()
                     null /* no help keyword */);
 
             Assert.IsType<BuildStartedEventArgs>(service.ProcessedBuildEvent);
-            Assert.Equal(buildEvent, (BuildStartedEventArgs) service.ProcessedBuildEvent,
+            Assert.Equal(buildEvent, (BuildStartedEventArgs)service.ProcessedBuildEvent,
                 new EventArgsEqualityComparer<BuildStartedEventArgs>());
         }
 
@@ -965,6 +1119,7 @@ public void TaskStartedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the case where TaskName
         /// </summary>
@@ -1000,6 +1155,7 @@ public void TaskFinishedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the case where TaskName is null.
         /// </summary>
@@ -1040,6 +1196,7 @@ public void TargetStartedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the target started event with a null target name.
         /// </summary>
@@ -1088,6 +1245,7 @@ public void TargetFinishedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the case where TargetName is null.
         /// </summary>
@@ -1427,36 +1585,6 @@ private void TestTargetStartedWithParentTargetEvent(string targetName, string pr
             Assert.Null(service.ProcessedBuildEvent);
         }
 
-        /// <summary>
-        /// Test LogProjectStarted
-        /// </summary>
-        private void LogProjectStartedTestHelper(string projectFile, string targetNames)
-        {
-            string message;
-            if (!String.IsNullOrEmpty(targetNames))
-            {
-                message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithTargetNames", Path.GetFileName(projectFile), targetNames);
-            }
-            else
-            {
-                message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", Path.GetFileName(projectFile));
-            }
-
-            MockHost componentHost = new MockHost();
-            ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
-            ConfigCache cache = (ConfigCache)componentHost.GetComponent(BuildComponentType.ConfigCache);
-
-            BuildRequestData data = new BuildRequestData("file", new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase), "toolsVersion", new string[0], null);
-            BuildRequestConfiguration config = new BuildRequestConfiguration(2, data, "4.0");
-            cache.AddConfiguration(config);
-
-            BuildEventContext context = service.LogProjectStarted(s_buildEventContext, 1, 2, s_buildEventContext, projectFile, targetNames, null, null);
-            BuildEventContext parentBuildEventContext = s_buildEventContext;
-            VerifyProjectStartedEventArgs(service, context.ProjectContextId, message, projectFile, targetNames, parentBuildEventContext, context);
-
-            service.ResetProcessedBuildEvent();
-        }
-
         /// <summary>
         /// Create a TargetFinished event to compare to the one which was passed into the ProcessedBuildEvent method.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index 2d4ed73b93d..9dfc0009db4 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -474,9 +474,11 @@ public void LogBuildFinished(bool success)
 
         /// <inheritdoc />
         public BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId)
-        {
-            return new BuildEventContext(0, 0, 0, 0, 0, 0, 0);
-        }
+            => new BuildEventContext(0, 0, 0, 0, 0, 0, 0);
+
+        /// <inheritdoc />
+        public BuildEventContext CreateProjectCacheBuildEventContext(int submissionId, int evaluationId, int projectInstanceId, string projectFile)
+            => new BuildEventContext(0, 0, 0, 0, 0, 0, 0);
 
         /// <inheritdoc />
         public void LogProjectEvaluationStarted(BuildEventContext eventContext, string projectFile)
@@ -499,7 +501,17 @@ public void LogProjectEvaluationFinished(
         /// <summary>
         /// Logs a project started event
         /// </summary>
-        public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items, int evaluationId = BuildEventContext.InvalidEvaluationId)
+        public BuildEventContext LogProjectStarted(
+            BuildEventContext nodeBuildEventContext,
+            int submissionId,
+            int configurationId,
+            BuildEventContext parentBuildEventContext,
+            string projectFile,
+            string targetNames,
+            IEnumerable<DictionaryEntry> properties,
+            IEnumerable<DictionaryEntry> items,
+            int evaluationId = BuildEventContext.InvalidEvaluationId,
+            int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
             return new BuildEventContext(0, 0, 0, 0);
         }
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 3b4d5164eb9..62674749d33 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -1632,7 +1632,7 @@ private ProjectInstance CreateTestProject(string projectBodyContents, string ini
         /// <returns>The context</returns>
         private ProjectLoggingContext GetProjectLoggingContext(BuildRequestEntry entry)
         {
-            return new ProjectLoggingContext(new NodeLoggingContext(_host, 1, false), entry, null);
+            return new ProjectLoggingContext(new NodeLoggingContext(_host, 1, false), entry);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 1fbec21d901..3446700cae3 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -1190,7 +1190,7 @@ private ProjectInstance CreateTestProject(bool returnsAttributeEnabled)
         /// <returns>The project logging context.</returns>
         private ProjectLoggingContext GetProjectLoggingContext(BuildRequestEntry entry)
         {
-            return new ProjectLoggingContext(new NodeLoggingContext(_host, 1, false), entry, null);
+            return new ProjectLoggingContext(new NodeLoggingContext(_host, 1, false), entry);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
new file mode 100644
index 00000000000..bdc7a99e972
--- /dev/null
+++ b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
@@ -0,0 +1,215 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using Microsoft.Build.Collections;
+
+using Shouldly;
+
+using Xunit;
+
+namespace Microsoft.Build.UnitTests.OM.Collections
+{
+    /// <summary>
+    /// Tests for <see cref="CopyOnWritePropertyDictionary{T}"/>.
+    /// </summary>
+    public class CopyOnWritePropertyDictionary_Tests
+    {
+        [Fact]
+        public void Count()
+        {
+            var dic = CreateInstance();
+
+            dic.Count.ShouldBe(0);
+
+            dic.Set(new("a"));
+
+            dic.Count.ShouldBe(1);
+
+            dic.Set(new("b"));
+
+            dic.Count.ShouldBe(2);
+
+            dic.Set(new("c"));
+
+            dic.Count.ShouldBe(3);
+
+            dic.Clear();
+
+            dic.Count.ShouldBe(0);
+        }
+
+        [Fact]
+        public void Indexer()
+        {
+            var dic = CreateInstance();
+
+            MockValue a = new("a");
+            MockValue b = new("b");
+
+            dic["a"].ShouldBeNull();
+            dic["b"].ShouldBeNull();
+
+            dic["a"] = a;
+
+            dic["a"].ShouldBeSameAs(a);
+            dic["b"].ShouldBeNull();
+
+            dic["b"] = b;
+
+            dic["a"].ShouldBeSameAs(a);
+            dic["b"].ShouldBeSameAs(b);
+
+            // Cannot set a null value
+            Assert.ThrowsAny<Exception>(() => dic["a"] = null);
+
+            // Value's key must match the specified key
+            Assert.ThrowsAny<Exception>(() => dic["a"] = b);
+        }
+
+        [Fact]
+        public void Contains()
+        {
+            var dic = CreateInstance();
+
+            MockValue a = new("a");
+            MockValue b = new("b");
+
+            dic.Contains("a").ShouldBeFalse();
+            dic.Contains("b").ShouldBeFalse();
+
+            dic["a"] = a;
+
+            dic.Contains("a").ShouldBeTrue();
+            dic.Contains("b").ShouldBeFalse();
+
+            dic["b"] = b;
+
+            dic.Contains("a").ShouldBeTrue();
+            dic.Contains("b").ShouldBeTrue();
+        }
+
+        [Fact]
+        public void Clear()
+        {
+            var dic = CreateInstance("a", "b", "c");
+
+            dic.Count.ShouldBe(3);
+
+            dic.Clear();
+
+            dic.Count.ShouldBe(0);
+        }
+
+        [Fact]
+        public void Enumeration()
+        {
+            var dic = CreateInstance();
+
+            MockValue a = new("a");
+            MockValue b = new("b");
+
+            dic.Set(a);
+            dic.Set(b);
+
+            dic.ShouldBeSetEquivalentTo(new[] { a, b });
+        }
+
+        [Fact]
+        public void Equal()
+        {
+            var dic1 = CreateInstance("a", "b", "c");
+            var dic2 = CreateInstance("a", "b", "c");
+            var dic3 = CreateInstance("c", "b", "a");      // reversed order
+            var dic4 = CreateInstance("a", "b");           // missing item
+            var dic5 = CreateInstance("a", "b", "c", "d"); // extra item
+
+            Test(dic1, dic1, true);
+            Test(dic1, dic2, true);
+            Test(dic1, dic3, true);
+
+            Test(dic1, dic4, false);
+            Test(dic1, dic5, false);
+
+            static void Test(CopyOnWritePropertyDictionary<MockValue> a, CopyOnWritePropertyDictionary<MockValue> b, bool expected)
+            {
+                if (expected)
+                {
+                    // Test equality in both directions
+                    a.ShouldBe(b);
+                    b.ShouldBe(a);
+                }
+                else
+                {
+                    // Test equality in both directions
+                    a.ShouldNotBe(b);
+                    b.ShouldNotBe(a);
+                }
+            }
+        }
+
+        [Fact]
+        public void Remove()
+        {
+            var dic = CreateInstance("a", "b", "c");
+
+            dic.Remove("ZZZ").ShouldBeFalse();
+
+            dic.Remove("a").ShouldBeTrue();
+            dic.Remove("a").ShouldBeFalse();
+            dic.Remove("b").ShouldBeTrue();
+            dic.Remove("c").ShouldBeTrue();
+
+            dic.Count.ShouldBe(0);
+        }
+
+        [Fact]
+        public void ImportProperties()
+        {
+            var dic = CreateInstance();
+
+            MockValue a = new("a");
+            MockValue b = new("b");
+
+            dic.ImportProperties(new[] { a, b });
+
+            dic.ShouldBeSetEquivalentTo(new[] { a, b });
+        }
+
+        [Fact]
+        public void DeepClone()
+        {
+            CopyOnWritePropertyDictionary<MockValue> source = CreateInstance("a", "b", "c");
+            CopyOnWritePropertyDictionary<MockValue> clone = source.DeepClone();
+
+            source.ShouldBe(clone);
+            source.ShouldNotBeSameAs(clone);
+        }
+
+        private static CopyOnWritePropertyDictionary<MockValue> CreateInstance(params string[] values)
+        {
+            CopyOnWritePropertyDictionary<MockValue> dic = new CopyOnWritePropertyDictionary<MockValue>();
+
+            foreach (string value in values)
+            {
+                dic.Set(new(value));
+            }
+
+            return dic;
+        }
+
+        private sealed class MockValue : IKeyed, IValued, IEquatable<MockValue>, IImmutable
+        {
+            public MockValue(string s) => Key = s;
+
+            public string Key { get; }
+
+            public string EscapedValue => Key;
+
+            public bool Equals(MockValue other)
+            {
+                return other != null && Key == other.Key;
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 115752d7e04..c4bd4727d4a 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -196,7 +196,6 @@ public void Metadata()
             metadata.Count.ShouldBe(2);
             metadata["a"].EvaluatedValue.ShouldBe("override");
             metadata["b"].EvaluatedValue.ShouldBe("base");
-            metadata.PropertyNames.ShouldBeSetEquivalentTo(new[] { "a", "b" });
 
             item.EnumerateMetadata().ShouldBeSetEquivalentTo(new KeyValuePair<string, string>[] { new("a", "override"), new("b", "base") });
 
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index cda8fa48311..95001217b5d 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -109,12 +109,14 @@
       <Link>TaskParameter_Tests.cs</Link>
     </Compile>
     <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs" />
-    <Compile Include="..\Shared\UnitTests\CopyOnWriteDictionary_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\CopyOnWriteDictionary_Tests.cs">
+      <Link>Collections\CopyOnWriteDictionary_Tests.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\UnitTests\TestData\GlobbingTestData.cs">
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
     <Compile Include="..\Shared\UnitTests\ImmutableDictionary_Tests.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' == 'Full' and '$(MonoBuild)' != 'true'">
-      <Link>ImmutableDictionary_Tests.cs</Link>
+      <Link>Collections\ImmutableDictionary_Tests.cs</Link>
     </Compile>
 
     <None Include="..\Shared\UnitTests\App.config">
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 98fc6c1a7fb..d1a29b8abaf 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1644,7 +1644,7 @@ private void HandleSubmissionException(GraphBuildSubmission submission, Exceptio
             }
         }
 
-        private static void AddBuildRequestToSubmission(BuildSubmission submission, int configurationId)
+        private static void AddBuildRequestToSubmission(BuildSubmission submission, int configurationId, int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
             submission.BuildRequest = new BuildRequest(
                 submission.SubmissionId,
@@ -1652,13 +1652,18 @@ private static void AddBuildRequestToSubmission(BuildSubmission submission, int
                 configurationId,
                 submission.BuildRequestData.TargetNames,
                 submission.BuildRequestData.HostServices,
-                BuildEventContext.Invalid,
-                null,
+                parentBuildEventContext: BuildEventContext.Invalid,
+                parentRequest: null,
                 submission.BuildRequestData.Flags,
-                submission.BuildRequestData.RequestedProjectState);
+                submission.BuildRequestData.RequestedProjectState,
+                projectContextId: projectContextId);
         }
 
-        private static void AddProxyBuildRequestToSubmission(BuildSubmission submission, int configurationId, ProxyTargets proxyTargets)
+        private static void AddProxyBuildRequestToSubmission(
+            BuildSubmission submission,
+            int configurationId,
+            ProxyTargets proxyTargets,
+            int projectContextId)
         {
             submission.BuildRequest = new BuildRequest(
                 submission.SubmissionId,
@@ -1667,7 +1672,8 @@ private static void AddProxyBuildRequestToSubmission(BuildSubmission submission,
                 proxyTargets,
                 submission.BuildRequestData.HostServices,
                 submission.BuildRequestData.Flags,
-                submission.BuildRequestData.RequestedProjectState);
+                submission.BuildRequestData.RequestedProjectState,
+                projectContextId);
         }
 
         /// <summary>
@@ -2285,7 +2291,7 @@ private BuildRequestConfiguration AddNewConfiguration(BuildRequestConfiguration
             return newConfiguration;
         }
 
-        internal void PostCacheResult(CacheRequest cacheRequest, CacheResult cacheResult)
+        internal void PostCacheResult(CacheRequest cacheRequest, CacheResult cacheResult, int projectContextId)
         {
             _workQueue.Post(() =>
             {
@@ -2310,14 +2316,14 @@ void HandleCacheResult()
                         if (cacheResult.ResultType != CacheResultType.CacheHit)
                         {
                             // Issue the real build request.
-                            AddBuildRequestToSubmission(submission, configuration.ConfigurationId);
+                            AddBuildRequestToSubmission(submission, configuration.ConfigurationId, projectContextId);
                             IssueBuildRequestForBuildSubmission(submission, configuration, allowMainThreadBuild: false);
                         }
                         else if (cacheResult.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)
                         {
                             // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid
                             // ProjectInstance serialization). The proxy target results are used as results for the real targets.
-                            AddProxyBuildRequestToSubmission(submission, configuration.ConfigurationId, cacheResult.ProxyTargets);
+                            AddProxyBuildRequestToSubmission(submission, configuration.ConfigurationId, cacheResult.ProxyTargets, projectContextId);
                             IssueBuildRequestForBuildSubmission(submission, configuration, allowMainThreadBuild: false);
                         }
                         else if (cacheResult.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)
@@ -2325,7 +2331,7 @@ void HandleCacheResult()
                             // Mark the build submission as complete with the provided results and return.
 
                             // There must be a build request for the results, so fake one.
-                            AddBuildRequestToSubmission(submission, configuration.ConfigurationId);
+                            AddBuildRequestToSubmission(submission, configuration.ConfigurationId, projectContextId);
                             var result = new BuildResult(submission.BuildRequest);
 
                             foreach (var cacheResult in cacheResult.BuildResult.ResultsByTarget)
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 096fb99283f..85538f7baa4 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -446,6 +446,16 @@ MessageImportance MinimumRequiredMessageImportance
         /// <returns></returns>
         BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId);
 
+        /// <summary>
+        /// Create a project cache context, by generating a new project context id.
+        /// </summary>
+        /// <param name="submissionId">The submission id</param>
+        /// <param name="evaluationId">The evaluation id</param>
+        /// <param name="projectInstanceId">The project instance id</param>
+        /// <param name="projectFile">Project file being built</param>
+        /// <returns></returns>
+        BuildEventContext CreateProjectCacheBuildEventContext(int submissionId, int evaluationId, int projectInstanceId, string projectFile);
+
         /// <summary>
         /// Logs that a project evaluation has started
         /// </summary>
@@ -477,15 +487,26 @@ void LogProjectEvaluationFinished(
         /// </summary>
         /// <param name="nodeBuildEventContext">The logging context of the node which is building this project.</param>
         /// <param name="submissionId">The id of the build submission.</param>
-        /// <param name="projectId">The id of the project instance which is about to start</param>
+        /// <param name="configurationId">The id of the project configuration which is about to start</param>
         /// <param name="parentBuildEventContext">The build context of the parent project which asked this project to build</param>
         /// <param name="projectFile">The project file path of the project about to be built</param>
         /// <param name="targetNames">The entrypoint target names for this project</param>
         /// <param name="properties">The initial properties of the project</param>
         /// <param name="items">The initial items of the project</param>
         /// <param name="evaluationId">EvaluationId of the project instance</param>
+        /// <param name="projectContextId">The project context id</param>
         /// <returns>The BuildEventContext to use for this project.</returns>
-        BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items, int evaluationId = BuildEventContext.InvalidEvaluationId);
+        BuildEventContext LogProjectStarted(
+            BuildEventContext nodeBuildEventContext,
+            int submissionId,
+            int configurationId,
+            BuildEventContext parentBuildEventContext,
+            string projectFile,
+            string targetNames,
+            IEnumerable<DictionaryEntry> properties,
+            IEnumerable<DictionaryEntry> items,
+            int evaluationId = BuildEventContext.InvalidEvaluationId,
+            int projectContextId = BuildEventContext.InvalidProjectContextId);
 
         /// <summary>
         /// Log that the project has finished
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index c5c3555f201..dcc79a8efcd 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -483,8 +483,28 @@ public void LogBuildFinished(bool success)
 
         /// <inheritdoc />
         public BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId)
+            => new BuildEventContext(submissionId, nodeId, NextEvaluationId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+
+        /// <inheritdoc />
+        public BuildEventContext CreateProjectCacheBuildEventContext(
+            int submissionId,
+            int evaluationId,
+            int projectInstanceId,
+            string projectFile)
         {
-            return new BuildEventContext(submissionId, nodeId, NextEvaluationId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+            lock (_lockObject)
+            {
+                int projectContextId = NextProjectId;
+
+                // In the future if some LogProjectCacheStarted event is created, move this there to align with evaluation and build execution.
+                _projectFileMap[projectContextId] = projectFile;
+
+                // Because the project cache runs in the BuildManager, it makes some sense to associate logging with the in-proc node.
+                // If a invalid node id is used the messages become deferred in the console logger and spit out at the end.
+                int nodeId = Scheduler.InProcNodeId;
+
+                return new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+            }
         }
 
         /// <inheritdoc />
@@ -545,35 +565,75 @@ public void LogProjectEvaluationFinished(
         /// </summary>
         /// <param name="nodeBuildEventContext">The event context of the node which is spawning this project.</param>
         /// <param name="submissionId">The id of the submission.</param>
-        /// <param name="projectInstanceId">Id of the project instance which is being started</param>
+        /// <param name="configurationId">The id of the project configuration which is about to start</param>
         /// <param name="parentBuildEventContext">BuildEventContext of the project who is requesting "projectFile" to build</param>
         /// <param name="projectFile">Project file to build</param>
         /// <param name="targetNames">Target names to build</param>
         /// <param name="properties">Initial property list</param>
         /// <param name="items">Initial items list</param>
         /// <param name="evaluationId">EvaluationId of the project instance</param>
+        /// <param name="projectContextId">The project context id</param>
         /// <returns>The build event context for the project.</returns>
         /// <exception cref="InternalErrorException">parentBuildEventContext is null</exception>
         /// <exception cref="InternalErrorException">projectBuildEventContext is null</exception>
-        public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectInstanceId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items, int evaluationId = BuildEventContext.InvalidEvaluationId)
+        public BuildEventContext LogProjectStarted(
+            BuildEventContext nodeBuildEventContext,
+            int submissionId,
+            int configurationId,
+            BuildEventContext parentBuildEventContext,
+            string projectFile,
+            string targetNames,
+            IEnumerable<DictionaryEntry> properties,
+            IEnumerable<DictionaryEntry> items,
+            int evaluationId = BuildEventContext.InvalidEvaluationId,
+            int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
             lock (_lockObject)
             {
                 ErrorUtilities.VerifyThrow(nodeBuildEventContext != null, "Need a nodeBuildEventContext");
-                BuildEventContext projectBuildEventContext = new BuildEventContext(submissionId, nodeBuildEventContext.NodeId, evaluationId, projectInstanceId, NextProjectId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
 
-                // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
-                if (_projectFileMap.ContainsKey(projectBuildEventContext.ProjectContextId))
+                if (projectContextId == BuildEventContext.InvalidProjectContextId)
                 {
-                    ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should not already be in the ID-to-file mapping!", projectBuildEventContext.ProjectContextId, projectFile);
+                    projectContextId = NextProjectId;
+
+                    // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
+                    if (_projectFileMap.ContainsKey(projectContextId))
+                    {
+                        ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should not already be in the ID-to-file mapping!", projectContextId, projectFile);
+                    }
+
+                    _projectFileMap[projectContextId] = projectFile;
+                }
+                else
+                {
+                    // A projectContextId was provided, so use it with some sanity checks
+                    if (_projectFileMap.TryGetValue(projectContextId, out string existingProjectFile))
+                    {
+                        if (!projectFile.Equals(existingProjectFile, StringComparison.OrdinalIgnoreCase))
+                        {
+                            ErrorUtilities.ThrowInternalError("ContextID {0} was already in the ID-to-project file mapping but the project file {1} did not match the provided one {2}!", projectContextId, existingProjectFile, projectFile);
+                        }
+                    }
+                    else
+                    {
+                        // Currently, an existing projectContextId can only be provided in the project cache scenario, which runs on the in-proc node.
+                        // If there was a cache miss and the build was scheduled on a worker node, it may not have seen this projectContextId yet.
+                        // So we only need this sanity check for the in-proc node.
+                        if (nodeBuildEventContext.NodeId == Scheduler.InProcNodeId)
+                        {
+                            ErrorUtilities.ThrowInternalError("ContextID {0} should have been in the ID-to-project file mapping but wasn't!", projectContextId);
+                        }
+
+                        _projectFileMap[projectContextId] = projectFile;
+                    }
                 }
 
-                _projectFileMap[projectBuildEventContext.ProjectContextId] = projectFile;
+                BuildEventContext projectBuildEventContext = new BuildEventContext(submissionId, nodeBuildEventContext.NodeId, evaluationId, configurationId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
 
                 ErrorUtilities.VerifyThrow(parentBuildEventContext != null, "Need a parentBuildEventContext");
 
-                ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectInstanceId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
-                var buildRequestConfiguration = _configCache.Value[projectInstanceId];
+                ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(configurationId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
+                var buildRequestConfiguration = _configCache.Value[configurationId];
 
                 // Always log GlobalProperties on ProjectStarted
                 // See https://github.com/dotnet/msbuild/issues/6341 for details
@@ -581,7 +641,7 @@ public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventConte
 
                 var buildEvent = new ProjectStartedEventArgs
                     (
-                        projectInstanceId,
+                        configurationId,
                         message: null,
                         helpKeyword: null,
                         projectFile,
diff --git a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
index 6852343e9be..870e358c69d 100644
--- a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
@@ -57,7 +57,7 @@ internal void LogBuildFinished(bool success)
         internal ProjectLoggingContext LogProjectStarted(BuildRequestEntry requestEntry)
         {
             ErrorUtilities.VerifyThrow(this.IsValid, "Build not started.");
-            return new ProjectLoggingContext(this, requestEntry, requestEntry.Request.ParentBuildEventContext);
+            return new ProjectLoggingContext(this, requestEntry);
         }
 
         /// <summary>
@@ -75,7 +75,7 @@ internal ProjectLoggingContext LogProjectStarted(BuildRequest request, BuildRequ
             // Order is important here because the Project getter will throw if IsCached.
             int evaluationId = (configuration != null && !configuration.IsCached && configuration.Project != null) ? configuration.Project.EvaluationId : BuildEventContext.InvalidEvaluationId;
 
-            return new ProjectLoggingContext(this, request, configuration.ProjectFullPath, configuration.ToolsVersion, request.ParentBuildEventContext, evaluationId);
+            return new ProjectLoggingContext(this, request, configuration.ProjectFullPath, configuration.ToolsVersion, evaluationId);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 4c5e5934c83..30ffe92df56 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -2,14 +2,14 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
-using Microsoft.Build.Framework;
+using System.Linq;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
-using System.Collections;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -23,15 +23,10 @@ internal class ProjectLoggingContext : BuildLoggingContext
         /// </summary>
         private string _projectFullPath;
 
-        /// <summary>
-        /// The parent node logging context this context was derived from.
-        /// </summary>
-        private NodeLoggingContext _nodeLoggingContext;
-
         /// <summary>
         /// Constructs a project logging context.
         /// </summary>
-        internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequestEntry requestEntry, BuildEventContext parentBuildEventContext)
+        internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequestEntry requestEntry)
             : this
             (
             nodeLoggingContext,
@@ -42,8 +37,9 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque
             requestEntry.RequestConfiguration.ToolsVersion,
             requestEntry.RequestConfiguration.Project.PropertiesToBuildWith,
             requestEntry.RequestConfiguration.Project.ItemsToBuildWith,
-            parentBuildEventContext,
-            requestEntry.RequestConfiguration.Project.EvaluationId
+            requestEntry.Request.ParentBuildEventContext,
+            requestEntry.RequestConfiguration.Project.EvaluationId,
+            requestEntry.Request.ProjectContextId
             )
         {
         }
@@ -51,7 +47,12 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque
         /// <summary>
         /// Constructs a project logging context.
         /// </summary>
-        internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequest request, string projectFullPath, string toolsVersion, BuildEventContext parentBuildEventContext, int evaluationId = BuildEventContext.InvalidEvaluationId)
+        internal ProjectLoggingContext(
+            NodeLoggingContext nodeLoggingContext,
+            BuildRequest request,
+            string projectFullPath,
+            string toolsVersion,
+            int evaluationId = BuildEventContext.InvalidEvaluationId)
             : this
             (
             nodeLoggingContext,
@@ -60,10 +61,11 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque
             projectFullPath,
             request.Targets,
             toolsVersion,
-            null,
-            null,
-            parentBuildEventContext,
-            evaluationId
+            projectProperties: null,
+            projectItems: null,
+            request.ParentBuildEventContext,
+            evaluationId,
+            request.ProjectContextId
             )
         {
         }
@@ -71,17 +73,27 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque
         /// <summary>
         /// Constructs a project logging contexts.
         /// </summary>
-        private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submissionId, int configurationId, string projectFullPath, List<string> targets, string toolsVersion, PropertyDictionary<ProjectPropertyInstance> projectProperties, ItemDictionary<ProjectItemInstance> projectItems, BuildEventContext parentBuildEventContext, int evaluationId = BuildEventContext.InvalidEvaluationId)
+        private ProjectLoggingContext(
+            NodeLoggingContext nodeLoggingContext,
+            int submissionId,
+            int configurationId,
+            string projectFullPath,
+            List<string> targets,
+            string toolsVersion,
+            PropertyDictionary<ProjectPropertyInstance> projectProperties,
+            ItemDictionary<ProjectItemInstance> projectItems,
+            BuildEventContext parentBuildEventContext,
+            int evaluationId,
+            int projectContextId)
             : base(nodeLoggingContext)
         {
-            _nodeLoggingContext = nodeLoggingContext;
             _projectFullPath = projectFullPath;
 
             ProjectPropertyInstanceEnumeratorProxy properties = null;
             ProjectItemInstanceEnumeratorProxy items = null;
 
-            IEnumerable<ProjectPropertyInstance> projectPropertiesEnumerator = projectProperties == null ? Array.Empty<ProjectPropertyInstance>() : null;
-            IEnumerable<ProjectItemInstance> projectItemsEnumerator = projectItems == null ? Array.Empty<ProjectItemInstance>() : null;
+            IEnumerable<ProjectPropertyInstance> projectPropertiesEnumerator = projectProperties == null ? Enumerable.Empty<ProjectPropertyInstance>() : null;
+            IEnumerable<ProjectItemInstance> projectItemsEnumerator = projectItems == null ? Enumerable.Empty<ProjectItemInstance>() : null;
 
             string[] propertiesToSerialize = LoggingService.PropertiesToSerialize;
 
@@ -131,10 +143,12 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
                 configurationId,
                 parentBuildEventContext,
                 projectFullPath,
-                String.Join(";", targets),
+                string.Join(";", targets),
                 properties,
                 items,
-                evaluationId);
+                evaluationId,
+                projectContextId
+                );
 
             // No need to log a redundant message in the common case
             if (toolsVersion != "Current")
@@ -145,17 +159,6 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
             this.IsValid = true;
         }
 
-        /// <summary>
-        /// Retrieves the node logging context.
-        /// </summary>
-        internal NodeLoggingContext NodeLoggingContext
-        {
-            get
-            {
-                return _nodeLoggingContext;
-            }
-        }
-
         /// <summary>
         /// Log that the project has finished
         /// </summary>
diff --git a/src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs b/src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs
index 15ae99e97f5..d6159906e8b 100644
--- a/src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs
@@ -11,16 +11,6 @@ namespace Microsoft.Build.Experimental.ProjectCache
     /// </summary>
     public abstract class PluginLoggerBase
     {
-        protected PluginLoggerBase(LoggerVerbosity verbosity)
-        {
-            Verbosity = verbosity;
-        }
-
-        /// <summary>
-        ///     See <see cref="ILogger.Verbosity" />
-        /// </summary>
-        private LoggerVerbosity Verbosity { get; }
-
         public abstract bool HasLoggedErrors { get; protected set; }
 
         public abstract void LogMessage(string message, MessageImportance? messageImportance = null);
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 42e912b95ae..1b69d9e04ba 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -4,7 +4,6 @@
 #nullable enable
 using System;
 using System.Collections.Generic;
-using System.Collections.Immutable;
 using System.Diagnostics;
 using System.Linq;
 using System.Reflection;
@@ -43,7 +42,7 @@ internal enum ProjectCacheServiceState
     internal class ProjectCacheService
     {
         private readonly BuildManager _buildManager;
-        private readonly Func<PluginLoggerBase> _loggerFactory;
+        private readonly ILoggingService _loggingService;
         private readonly ProjectCacheDescriptor _projectCacheDescriptor;
         private readonly CancellationToken _cancellationToken;
         private readonly ProjectCachePluginBase _projectCachePlugin;
@@ -65,14 +64,14 @@ private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }
         private ProjectCacheService(
             ProjectCachePluginBase projectCachePlugin,
             BuildManager buildManager,
-            Func<PluginLoggerBase> loggerFactory,
+            ILoggingService loggingService,
             ProjectCacheDescriptor projectCacheDescriptor,
             CancellationToken cancellationToken
         )
         {
             _projectCachePlugin = projectCachePlugin;
             _buildManager = buildManager;
-            _loggerFactory = loggerFactory;
+            _loggingService = loggingService;
             _projectCacheDescriptor = projectCacheDescriptor;
             _cancellationToken = cancellationToken;
         }
@@ -86,11 +85,7 @@ public static async Task<ProjectCacheService> FromDescriptorAsync(
             var plugin = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)
                 .ConfigureAwait(false);
 
-            // TODO: Detect and use the highest verbosity from all the user defined loggers. That's tricky because right now we can't query loggers about
-            // their verbosity levels.
-            var loggerFactory = new Func<PluginLoggerBase>(() => new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService));
-
-            var service = new ProjectCacheService(plugin, buildManager, loggerFactory, pluginDescriptor, cancellationToken);
+            var service = new ProjectCacheService(plugin, buildManager, loggingService, pluginDescriptor, cancellationToken);
 
             // TODO: remove the if after we change VS to set the cache descriptor via build parameters and always call BeginBuildAsync in FromDescriptorAsync.
             // When running under VS we can't initialize the plugin until we evaluate a project (any project) and extract
@@ -106,7 +101,10 @@ public static async Task<ProjectCacheService> FromDescriptorAsync(
         // TODO: remove vsWorkaroundOverrideDescriptor after we change VS to set the cache descriptor via build parameters.
         private async Task BeginBuildAsync(ProjectCacheDescriptor? vsWorkaroundOverrideDescriptor = null)
         {
-            var logger = _loggerFactory();
+            var logger = new LoggingServiceToPluginLoggerAdapter(
+                _loggingService,
+                BuildEventContext.Invalid,
+                BuildEventFileInfo.Empty);
 
             try
             {
@@ -127,7 +125,6 @@ await _projectCachePlugin.BeginBuildAsync(
                         new DefaultMSBuildFileSystem(),
                         projectDescriptor.ProjectGraph,
                         projectDescriptor.EntryPoints),
-                    // TODO: Detect verbosity from logging service.
                     logger,
                     _cancellationToken);
 
@@ -222,22 +219,22 @@ public void PostCacheRequest(CacheRequest cacheRequest)
             {
                 try
                 {
-                    var cacheResult = await ProcessCacheRequest(cacheRequest);
-                    _buildManager.PostCacheResult(cacheRequest, cacheResult);
+                    (CacheResult cacheResult, int projectContextId) = await ProcessCacheRequest(cacheRequest);
+                    _buildManager.PostCacheResult(cacheRequest, cacheResult, projectContextId);
                 }
                 catch (Exception e)
                 {
-                    _buildManager.PostCacheResult(cacheRequest, CacheResult.IndicateException(e));
+                    _buildManager.PostCacheResult(cacheRequest, CacheResult.IndicateException(e), BuildEventContext.InvalidProjectContextId);
                 }
             }, _cancellationToken);
 
-            async Task<CacheResult> ProcessCacheRequest(CacheRequest request)
+            async Task<(CacheResult Result, int ProjectContextId)> ProcessCacheRequest(CacheRequest request)
             {
                 // Prevent needless evaluation if design time builds detected.
                 if (_projectCacheDescriptor.VsWorkaround && DesignTimeBuildsDetected)
                 {
                     // The BuildManager should disable the cache when it finds its servicing design time builds.
-                    return CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss);
+                    return (CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss), BuildEventContext.InvalidProjectContextId);
                 }
 
                 EvaluateProjectIfNecessary(request);
@@ -260,7 +257,7 @@ async Task<CacheResult> ProcessCacheRequest(CacheRequest request)
                     if (DesignTimeBuildsDetected)
                     {
                         // The BuildManager should disable the cache when it finds its servicing design time builds.
-                        return CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss);
+                        return (CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss), BuildEventContext.InvalidProjectContextId);
                     }
                 }
 
@@ -289,10 +286,27 @@ LateInitializationForVSWorkaroundCompleted is null ||
                     _projectCacheDescriptor.VsWorkaround && LateInitializationForVSWorkaroundCompleted.Task.IsCompleted,
                     "Completion source should be null when this is not the VS workaround");
 
-                return await GetCacheResultAsync(
-                    new BuildRequestData(
-                        request.Configuration.Project,
-                        request.Submission.BuildRequestData.TargetNames.ToArray()));
+                BuildRequestData buildRequest = new BuildRequestData(
+                    cacheRequest.Configuration.Project,
+                    cacheRequest.Submission.BuildRequestData.TargetNames.ToArray());
+                BuildEventContext buildEventContext = _loggingService.CreateProjectCacheBuildEventContext(
+                    cacheRequest.Submission.SubmissionId,
+                    evaluationId: cacheRequest.Configuration.Project.EvaluationId,
+                    projectInstanceId: cacheRequest.Configuration.ConfigurationId,
+                    projectFile: cacheRequest.Configuration.Project.FullPath);
+
+                CacheResult cacheResult;
+                try
+                {
+                    cacheResult = await GetCacheResultAsync(buildRequest, buildEventContext);
+                }
+                catch (Exception ex)
+                {
+                    // Wrap the exception here so we can preserve the ProjectContextId
+                    cacheResult = CacheResult.IndicateException(ex);
+                }
+
+                return (cacheResult, buildEventContext.ProjectContextId);
             }
 
             static bool IsDesignTimeBuild(ProjectInstance project)
@@ -451,7 +465,7 @@ static bool MSBuildStringIsTrue(string msbuildString) =>
                 ConversionUtilities.ConvertStringToBool(msbuildString, nullOrWhitespaceIsFalse: true);
         }
 
-        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest)
+        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildEventContext buildEventContext)
         {
             lock (this)
             {
@@ -470,7 +484,11 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
                                    $"\n\tTargets:[{string.Join(", ", buildRequest.TargetNames)}]" +
                                    $"\n\tGlobal Properties: {{{string.Join(",", buildRequest.GlobalProperties.Select(kvp => $"{kvp.Name}={kvp.EvaluatedValue}"))}}}";
 
-            var logger = _loggerFactory();
+            var buildEventFileInfo = new BuildEventFileInfo(buildRequest.ProjectFullPath);
+            var logger = new LoggingServiceToPluginLoggerAdapter(
+                _loggingService,
+                buildEventContext,
+                buildEventFileInfo);
 
             logger.LogMessage(
                 "\n====== Querying project cache for project " + queryDescription,
@@ -517,7 +535,10 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
 
         public async Task ShutDown()
         {
-            var logger = _loggerFactory();
+            var logger = new LoggingServiceToPluginLoggerAdapter(
+                _loggingService,
+                BuildEventContext.Invalid,
+                BuildEventFileInfo.Empty);
 
             try
             {
@@ -609,19 +630,26 @@ private class LoggingServiceToPluginLoggerAdapter : PluginLoggerBase
         {
             private readonly ILoggingService _loggingService;
 
+            private readonly BuildEventContext _buildEventContext;
+
+            private readonly BuildEventFileInfo _buildEventFileInfo;
+
             public override bool HasLoggedErrors { get; protected set; }
 
             public LoggingServiceToPluginLoggerAdapter(
-                LoggerVerbosity verbosity,
-                ILoggingService loggingService) : base(verbosity)
+                ILoggingService loggingService,
+                BuildEventContext buildEventContext,
+                BuildEventFileInfo buildEventFileInfo)
             {
                 _loggingService = loggingService;
+                _buildEventContext = buildEventContext;
+                _buildEventFileInfo = buildEventFileInfo;
             }
 
             public override void LogMessage(string message, MessageImportance? messageImportance = null)
             {
                 _loggingService.LogCommentFromText(
-                    BuildEventContext.Invalid,
+                    _buildEventContext,
                     messageImportance ?? MessageImportance.Normal,
                     message);
             }
@@ -629,11 +657,11 @@ public override void LogMessage(string message, MessageImportance? messageImport
             public override void LogWarning(string warning)
             {
                 _loggingService.LogWarningFromText(
-                    BuildEventContext.Invalid,
+                    _buildEventContext,
                     null,
                     null,
                     null,
-                    BuildEventFileInfo.Empty,
+                    _buildEventFileInfo,
                     warning);
             }
 
@@ -642,7 +670,7 @@ public override void LogError(string error)
                 HasLoggedErrors = true;
 
                 _loggingService.LogErrorFromText(
-                    BuildEventContext.Invalid,
+                    _buildEventContext,
                     null,
                     null,
                     null,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 9da66ddcc95..7204146c1cd 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -1131,8 +1131,7 @@ private async Task<BuildResult> BuildProject()
                     _nodeLoggingContext,
                     _requestEntry.Request,
                     _requestEntry.RequestConfiguration.ProjectFullPath,
-                    _requestEntry.RequestConfiguration.ToolsVersion,
-                    _requestEntry.Request.ParentBuildEventContext
+                    _requestEntry.RequestConfiguration.ToolsVersion
                     );
 
                 throw;
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 2bde7843447..9f43e5b804b 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -42,6 +42,11 @@ internal class BuildRequest : INodePacket
         /// </summary>
         private int _configurationId;
 
+        /// <summary>
+        /// The project context id, if already determined.
+        /// </summary>
+        private int _projectContextId;
+
         /// <summary>
         /// The global build request id, assigned by the Build Manager
         /// </summary>
@@ -98,11 +103,13 @@ private BuildRequest(
             int nodeRequestId,
             int configurationId,
             HostServices hostServices,
-            BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
-            RequestedProjectState requestedProjectState = null)
+            BuildRequestDataFlags buildRequestDataFlags,
+            RequestedProjectState requestedProjectState,
+            int projectContextId)
         {
             _submissionId = submissionId;
             _configurationId = configurationId;
+            _projectContextId = projectContextId;
 
             HostServices = hostServices;
             _buildEventContext = BuildEventContext.Invalid;
@@ -114,7 +121,7 @@ private BuildRequest(
         }
 
         /// <summary>
-        /// Initializes a build request with a parent context.
+        /// Initializes a build request with proxy targets.
         /// </summary>
         /// <param name="submissionId">The id of the build submission.</param>
         /// <param name="nodeRequestId">The id of the node issuing the request</param>
@@ -123,6 +130,7 @@ private BuildRequest(
         /// <param name="hostServices">Host services if any. May be null.</param>
         /// <param name="buildRequestDataFlags">Additional flags for the request.</param>
         /// <param name="requestedProjectState">Filter for desired build results.</param>
+        /// <param name="projectContextId">The project context id</param>
         public BuildRequest(
             int submissionId,
             int nodeRequestId,
@@ -130,9 +138,9 @@ public BuildRequest(
             ProxyTargets proxyTargets,
             HostServices hostServices,
             BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
-            RequestedProjectState requestedProjectState = null)
-            : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags,
-                requestedProjectState)
+            RequestedProjectState requestedProjectState = null,
+            int projectContextId = BuildEventContext.InvalidProjectContextId)
+            : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags, requestedProjectState, projectContextId)
         {
             _proxyTargets = proxyTargets;
             _targets = proxyTargets.ProxyTargetToRealTargetMap.Keys.ToList();
@@ -155,6 +163,7 @@ public BuildRequest(
         /// <param name="skipStaticGraphIsolationConstraints"></param>
         /// <param name="buildRequestDataFlags">Additional flags for the request.</param>
         /// <param name="requestedProjectState">Filter for desired build results.</param>
+        /// <param name="projectContextId">The project context id</param>
         public BuildRequest(
             int submissionId,
             int nodeRequestId,
@@ -165,8 +174,9 @@ public BuildRequest(
             BuildRequest parentRequest,
             BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
             RequestedProjectState requestedProjectState = null,
-            bool skipStaticGraphIsolationConstraints = false)
-        : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags, requestedProjectState)
+            bool skipStaticGraphIsolationConstraints = false,
+            int projectContextId = BuildEventContext.InvalidProjectContextId)
+        : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags, requestedProjectState, projectContextId)
         {
             ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, "targets");
             ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, nameof(parentBuildEventContext));
@@ -222,6 +232,16 @@ public int ConfigurationId
             { return _configurationId; }
         }
 
+        /// <summary>
+        /// Returns the project context id
+        /// </summary>
+        public int ProjectContextId
+        {
+            [DebuggerStepThrough]
+            get
+            { return _projectContextId; }
+        }
+
         /// <summary>
         /// Gets the global request id
         /// </summary>
@@ -406,6 +426,7 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _requestedProjectState);
             translator.Translate(ref _hostServices);
             translator.Translate(ref _proxyTargets, ProxyTargets.FactoryForDeserialization);
+            translator.Translate(ref _projectContextId);
 
             // UNDONE: (Compat) Serialize the host object.
         }
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index b20e385b467..59bb01163fe 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -4,7 +4,9 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.Diagnostics;
+
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Collections
@@ -19,43 +21,35 @@ namespace Microsoft.Build.Collections
     /// </summary>
     /// <remarks>
     /// The value that this adds over IDictionary&lt;string, T&gt; is:
+    ///     - supports copy on write
     ///     - enforces that key = T.Name
     ///     - default enumerator is over values
     ///     - (marginal) enforces the correct key comparer
-    ///     - potentially makes copy on write possible
     /// 
     /// Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
     /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and 
     /// either not expose this collection or expose it through a readonly wrapper.
     ///
-    /// At various places in this class locks are taken on the backing collection.  The reason for this is to allow
-    /// this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will 
-    /// lock the backing collection when it does its deep cloning.  This prevents asynchronous access from corrupting
-    /// the state of the enumeration until the collection has been fully copied.
-    ///
-    /// The use of a CopyOnWriteDictionary does not reduce the concurrency of this collection, because CopyOnWriteDictionary
-    /// offers the same concurrency guarantees (concurrent readers OR single writer) for EACH user of the dictionary.
-    /// 
-    /// Since we use the mutable ignore case comparer we need to make sure that we lock our self before we call the comparer since the comparer can call back 
-    /// into this dictionary which could cause a deadlock if another thread is also accessing another method in the dictionary.
+    /// This collection is safe for concurrent readers and a single writer.
     /// </remarks>
     /// <typeparam name="T">Property or Metadata class type to store</typeparam>
     [DebuggerDisplay("#Entries={Count}")]
     internal sealed class CopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquatable<CopyOnWritePropertyDictionary<T>>, IDictionary<string, T>
         where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
     {
+        private static readonly ImmutableDictionary<string, T> NameComparerDictionaryPrototype = ImmutableDictionary.Create<string, T>(MSBuildNameIgnoreCaseComparer.Default);
+
         /// <summary>
         /// Backing dictionary
         /// </summary>
-        private readonly CopyOnWriteDictionary<T> _properties;
+        private ImmutableDictionary<string, T> _backing;
 
         /// <summary>
         /// Creates empty dictionary
         /// </summary>
         public CopyOnWritePropertyDictionary()
         {
-            // Tracing.Record("New COWD1");
-            _properties = new CopyOnWriteDictionary<T>(MSBuildNameIgnoreCaseComparer.Default);
+            _backing = NameComparerDictionaryPrototype;
         }
 
         /// <summary>
@@ -63,41 +57,18 @@ public CopyOnWritePropertyDictionary()
         /// </summary>
         private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         {
-            _properties = that._properties.Clone(); // copy on write!
+            _backing = that._backing;
         }
 
         /// <summary>
         /// Accessor for the list of property names
         /// </summary>
-        ICollection<string> IDictionary<string, T>.Keys => PropertyNames;
+        ICollection<string> IDictionary<string, T>.Keys => ((IDictionary<string, T>)_backing).Keys;
 
         /// <summary>
         /// Accessor for the list of properties
         /// </summary>
-        ICollection<T> IDictionary<string, T>.Values
-        {
-            get
-            {
-                lock (_properties)
-                {
-                    return _properties.Values;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Returns the number of properties in the collection
-        /// </summary>
-        int ICollection<KeyValuePair<string, T>>.Count
-        {
-            get
-            {
-                lock (_properties)
-                {
-                    return _properties.Count;
-                }
-            }
-        }
+        ICollection<T> IDictionary<string, T>.Values => ((IDictionary<string, T>)_backing).Values;
 
         /// <summary>
         /// Whether the collection is read-only.
@@ -105,32 +76,9 @@ int ICollection<KeyValuePair<string, T>>.Count
         bool ICollection<KeyValuePair<string, T>>.IsReadOnly => false;
 
         /// <summary>
-        /// Returns the number of property in the collection.
+        /// Returns the number of properties in the collection.
         /// </summary>
-        internal int Count
-        {
-            get
-            {
-                lock (_properties)
-                {
-                    return _properties.Count;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Retrieves a collection containing the names of all the properties present in the dictionary.
-        /// </summary>
-        internal ICollection<string> PropertyNames
-        {
-            get
-            {
-                lock (_properties)
-                {
-                    return _properties.Keys;
-                }
-            }
-        }
+        public int Count => _backing.Count;
 
         /// <summary>
         /// Get the property with the specified name, or null if none exists.
@@ -141,34 +89,13 @@ internal ICollection<string> PropertyNames
         /// This better matches the semantics of property, which are considered to have a blank value if they
         /// are not defined.
         /// </remarks>
-        T IDictionary<string, T>.this[string name]
-        {
-            // The backing properties dictionary is locked in the indexor
-            get => this[name];
-            set => this[name] = value;
-        }
-
-        /// <summary>
-        /// Get the property with the specified name, or null if none exists.
-        /// Sets the property with the specified name, overwriting it if already exists.
-        /// </summary>
-        /// <remarks>
-        /// Unlike Dictionary&lt;K,V&gt;[K], the getter returns null instead of throwing if the key does not exist.
-        /// This better matches the semantics of property, which are considered to have a blank value if they
-        /// are not defined.
-        /// </remarks>
-        internal T this[string name]
+        public T this[string name]
         {
             get
             {
                 // We don't want to check for a zero length name here, since that is a valid name
                 // and should return a null instance which will be interpreted as blank
-                T projectProperty;
-                lock (_properties)
-                {
-                    _properties.TryGetValue(name, out projectProperty);
-                }
-
+                _backing.TryGetValue(name, out T projectProperty);
                 return projectProperty;
             }
 
@@ -180,57 +107,30 @@ internal T this[string name]
             }
         }
 
-        /// <summary>
-        /// Returns an enumerable which clones the properties 
-        /// </summary>
-        /// <returns>Returns a cloning enumerable.</returns>
-        public IEnumerable<T> GetCopyOnReadEnumerable()
-        {
-            return new CopyOnReadEnumerable<T>(this, _properties);
-        }
-
         /// <summary>
         /// Returns true if a property with the specified name is present in the collection,
         /// otherwise false.
         /// </summary>
-        public bool Contains(string name)
-        {
-            return ((IDictionary<string, T>)this).ContainsKey(name);
-        }
+        public bool Contains(string name) => _backing.ContainsKey(name);
 
         /// <summary>
         /// Empties the collection
         /// </summary>
         public void Clear()
         {
-            lock (_properties)
-            {
-                _properties.Clear();
-            }
+            _backing = _backing.Clear();
         }
 
         /// <summary>
         /// Gets an enumerator over all the properties in the collection
         /// Enumeration is in undefined order
         /// </summary>
-        public IEnumerator<T> GetEnumerator()
-        {
-            lock (_properties)
-            {
-                return _properties.Values.GetEnumerator();
-            }
-        }
+        public IEnumerator<T> GetEnumerator() => _backing.Values.GetEnumerator();
 
         /// <summary>
         /// Get an enumerator over entries
         /// </summary>
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            lock (_properties)
-            {
-                return ((IEnumerable)_properties.Values).GetEnumerator();
-            }
-        }
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
 
         #region IEquatable<PropertyDictionary<T>> Members
 
@@ -247,25 +147,29 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
                 return false;
             }
 
-            if (ReferenceEquals(this, other))
+            // Copy both backing collections to locals 
+            ImmutableDictionary<string, T> thisBacking = _backing;
+            ImmutableDictionary<string, T> thatBacking = other._backing;
+
+            // If the backing collections are the same, we are equal.
+            // Note that with this check, we intentionally avoid the common reference
+            // comparison between 'this' and 'other'.
+            if (ReferenceEquals(thisBacking, thatBacking))
             {
                 return true;
             }
 
-            if (Count != other.Count)
+            if (thisBacking.Count != thatBacking.Count)
             {
                 return false;
             }
 
-            lock (_properties)
+            foreach (T thisProp in thisBacking.Values)
             {
-                foreach (T leftProp in this)
+                if (!thatBacking.TryGetValue(thisProp.Key, out T thatProp) ||
+                    !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
                 {
-                    T rightProp = other[leftProp.Key];
-                    if (rightProp == null || !EqualityComparer<T>.Default.Equals(leftProp, rightProp))
-                    {
-                        return false;
-                    }
+                    return false;
                 }
             }
 
@@ -281,6 +185,7 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
         /// </summary>
         void IDictionary<string, T>.Add(string key, T value)
         {
+            ErrorUtilities.VerifyThrowInternalNull(value, "Properties can't have null value");
             ErrorUtilities.VerifyThrow(key == value.Key, "Key must match value's key");
             Set(value);
         }
@@ -288,29 +193,12 @@ void IDictionary<string, T>.Add(string key, T value)
         /// <summary>
         /// Returns true if the dictionary contains the key
         /// </summary>
-        bool IDictionary<string, T>.ContainsKey(string key)
-        {
-            return _properties.ContainsKey(key);
-        }
-
-        /// <summary>
-        /// Removes a property
-        /// </summary>
-        bool IDictionary<string, T>.Remove(string key)
-        {
-            // Backing properties are locked in the remove method
-            return Remove(key);
-        }
+        bool IDictionary<string, T>.ContainsKey(string key) => _backing.ContainsKey(key);
 
         /// <summary>
         /// Attempts to retrieve the a property.
         /// </summary>
-        bool IDictionary<string, T>.TryGetValue(string key, out T value)
-        {
-            value = this[key];
-
-            return value != null;
-        }
+        bool IDictionary<string, T>.TryGetValue(string key, out T value) => _backing.TryGetValue(key, out value);
 
         #endregion
 
@@ -324,25 +212,14 @@ void ICollection<KeyValuePair<string, T>>.Add(KeyValuePair<string, T> item)
             ((IDictionary<string, T>)this).Add(item.Key, item.Value);
         }
 
-        /// <summary>
-        /// Clears the property collection
-        /// </summary>
-        void ICollection<KeyValuePair<string, T>>.Clear()
-        {
-            Clear();
-        }
-
         /// <summary>
         /// Checks for a property in the collection
         /// </summary>
         bool ICollection<KeyValuePair<string, T>>.Contains(KeyValuePair<string, T> item)
         {
-            lock (_properties)
+            if (_backing.TryGetValue(item.Key, out T value))
             {
-                if (_properties.TryGetValue(item.Key, out T value))
-                {
-                    return EqualityComparer<T>.Default.Equals(value, item.Value);
-                }
+                return EqualityComparer<T>.Default.Equals(value, item.Value);
             }
 
             return false;
@@ -362,7 +239,7 @@ void ICollection<KeyValuePair<string, T>>.CopyTo(KeyValuePair<string, T>[] array
         bool ICollection<KeyValuePair<string, T>>.Remove(KeyValuePair<string, T> item)
         {
             ErrorUtilities.VerifyThrow(item.Key == item.Value.Key, "Key must match value's key");
-            return ((IDictionary<string, T>)this).Remove(item.Key);
+            return Remove(item.Key);
         }
 
         #endregion
@@ -374,10 +251,7 @@ bool ICollection<KeyValuePair<string, T>>.Remove(KeyValuePair<string, T> item)
         /// </summary>
         IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator()
         {
-            lock (_properties)
-            {
-                return _properties.GetEnumerator();
-            }
+            return _backing.GetEnumerator();
         }
 
         #endregion
@@ -386,28 +260,11 @@ IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnu
         /// Removes any property with the specified name.
         /// Returns true if the property was in the collection, otherwise false.
         /// </summary>
-        internal bool Remove(string name)
-        {
-            return Remove(name, clearIfEmpty: false);
-        }
-
-        /// <summary>
-        /// Removes any property with the specified name.
-        /// Returns true if the property was in the collection, otherwise false.
-        /// </summary>
-        internal bool Remove(string name, bool clearIfEmpty)
+        public bool Remove(string name)
         {
             ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
-            lock (_properties)
-            {
-                bool result = _properties.Remove(name);
-                if (clearIfEmpty && _properties.Count == 0)
-                {
-                    _properties.Clear();
-                }
-                return result;
-            }
+            return ImmutableInterlocked.TryRemove(ref _backing, name, out _);
         }
 
         /// <summary>
@@ -419,10 +276,7 @@ internal void Set(T projectProperty)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectProperty, nameof(projectProperty));
 
-            lock (_properties)
-            {
-                _properties[projectProperty.Key] = projectProperty;
-            }
+            _backing = _backing.SetItem(projectProperty.Key, projectProperty);
         }
 
         /// <summary>
@@ -431,43 +285,15 @@ internal void Set(T projectProperty)
         /// <param name="other">An enumerator over the properties to add.</param>
         internal void ImportProperties(IEnumerable<T> other)
         {
-            // Properties are locked in the set method
-            foreach (T property in other)
-            {
-                Set(property);
-            }
-        }
-
-        /// <summary>
-        /// Removes the specified properties from this dictionary
-        /// </summary>
-        /// <param name="other">An enumerator over the properties to remove.</param>
-        internal void RemoveProperties(IEnumerable<T> other)
-        {
-            // Properties are locked in the remove method
-            foreach (T property in other)
-            {
-                Remove(property.Key);
-            }
-        }
+            _backing = _backing.SetItems(Items());
 
-        /// <summary>
-        /// Helper to convert into a read-only dictionary of string, string.
-        /// </summary>
-        internal IDictionary<string, string> ToDictionary()
-        {
-            Dictionary<string, string> dictionary;
-
-            lock (_properties)
+            IEnumerable<KeyValuePair<string, T>> Items()
             {
-                dictionary = new Dictionary<string, string>(_properties.Count, StringComparer.OrdinalIgnoreCase);
-                foreach (T property in this)
+                foreach (T property in other)
                 {
-                    dictionary[property.Key] = property.EscapedValue;
+                    yield return new(property.Key, property);
                 }
             }
-
-            return dictionary;
         }
 
         /// <summary>
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 514c3596b94..c3430ba548e 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -2812,7 +2812,7 @@ private void CreateTargetsSnapshot(
         /// </summary>
         private void CreateImportsSnapshot(IList<ResolvedImport> importClosure, IList<ResolvedImport> importClosureWithDuplicates)
         {
-            _importPaths = new List<string>(importClosure.Count - 1 /* outer project */);
+            _importPaths = new List<string>(Math.Max(0, importClosure.Count - 1) /* outer project */);
             foreach (var resolvedImport in importClosure)
             {
                 // Exclude outer project itself
@@ -2824,7 +2824,7 @@ private void CreateImportsSnapshot(IList<ResolvedImport> importClosure, IList<Re
 
             ImportPaths = _importPaths.AsReadOnly();
 
-            _importPathsIncludingDuplicates = new List<string>(importClosureWithDuplicates.Count - 1 /* outer project */);
+            _importPathsIncludingDuplicates = new List<string>(Math.Max(0, importClosureWithDuplicates.Count - 1) /* outer project */);
             foreach (var resolvedImport in importClosureWithDuplicates)
             {
                 // Exclude outer project itself
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 28e122fd4c8..36e23d8e45e 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1047,7 +1047,7 @@ public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
                 }
                 else
                 {
-                    return Array.Empty<KeyValuePair<string, string>>();
+                    return Enumerable.Empty<KeyValuePair<string, string>>();
                 }
             }
 
@@ -1342,8 +1342,7 @@ public void RemoveMetadata(string metadataName)
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
-                // If the metadata was all removed, toss the dictionary
-                _directMetadata?.Remove(metadataName, clearIfEmpty: true);
+                _directMetadata?.Remove(metadataName);
             }
 
             /// <summary>
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index cbfee6c66db..19c39093f3f 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -99,9 +99,6 @@
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs">
       <Link>Collections\ReadOnlyEmptyCollection.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\StringBuilderCache.cs">
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
     <Compile Include="..\Shared\TaskHostTaskCancelled.cs" />
@@ -140,7 +137,6 @@
     <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\ReuseableStringBuilder.cs" />
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="BackEnd\BuildManager\BuildManager.cs" />
diff --git a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
index 7b51af24c2f..027d79e6239 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
@@ -1320,7 +1320,6 @@ Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheMiss = 2 -> Micro
 Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheNotApplicable = 3 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
 Microsoft.Build.Experimental.ProjectCache.CacheResultType.None = 0 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
 Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase
-Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult() -> void
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) -> void
@@ -1819,4 +1818,4 @@ virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
\ No newline at end of file
+virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
index c095b7f8e50..9281b0c3cf8 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,5 +1,6 @@
 Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.get -> Microsoft.Build.FileSystem.IDirectoryCacheFactory
 Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.set -> void
+Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.PluginLoggerBase() -> void
 Microsoft.Build.FileSystem.FindPredicate
 Microsoft.Build.FileSystem.FindTransform<TResult>
 Microsoft.Build.FileSystem.IDirectoryCache
@@ -9,4 +10,4 @@ Microsoft.Build.FileSystem.IDirectoryCache.EnumerateFiles<TResult>(string path,
 Microsoft.Build.FileSystem.IDirectoryCache.FileExists(string path) -> bool
 Microsoft.Build.FileSystem.IDirectoryCacheFactory
 Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
-static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
\ No newline at end of file
+static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
index eb03a4d60f0..b2b3f82f392 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -1317,7 +1317,6 @@ Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheMiss = 2 -> Micro
 Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheNotApplicable = 3 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
 Microsoft.Build.Experimental.ProjectCache.CacheResultType.None = 0 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
 Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase
-Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult() -> void
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) -> void
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index c095b7f8e50..218e7d4593d 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,5 +1,6 @@
 Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.get -> Microsoft.Build.FileSystem.IDirectoryCacheFactory
 Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.set -> void
+Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.PluginLoggerBase() -> void
 Microsoft.Build.FileSystem.FindPredicate
 Microsoft.Build.FileSystem.FindTransform<TResult>
 Microsoft.Build.FileSystem.IDirectoryCache
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 2a840bfd7c2..bff6cc9053f 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -85,7 +85,7 @@
 
   <ItemGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true'">
     <!-- Ensure API stability for shipping packages -->
-    <PackageReference Include="Microsoft.CodeAnalysis.PublicApiAnalyzers" PrivateAssets="all" />
+    <PackageReference Include="Microsoft.CodeAnalysis.PublicApiAnalyzers" PrivateAssets="all" Condition="'$(DotNetBuildFromSource)' != 'true'" />
 
     <AdditionalFiles Include="PublicAPI/$(PublicApiTfm)/PublicAPI.Shipped.txt" />
     <AdditionalFiles Include="PublicAPI/$(PublicApiTfm)/PublicAPI.Unshipped.txt" />
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index 2ce98b0c404..da03486b433 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -41,7 +41,6 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs" />
     <Compile Include="..\Shared\ResourceUtilities.cs" />
     <Compile Include="..\Shared\ExceptionHandling.cs" />
-    <Compile Include="..\Shared\StringBuilderCache.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
     <Compile Include="..\Shared\UnitTests\AssemblyResources.cs" />
   </ItemGroup>
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index e32cb633fbc..f8587c129c4 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -490,6 +490,35 @@ public void CachedSdkResolverServiceResolveSdkStop(string sdkName, string soluti
             WriteEvent(67, sdkName, solutionPath, projectPath, success);
         }
 
-        #endregion
+        /// <remarks>
+        /// This events are quite frequent so they are collected by Debug binaries only.
+        /// </remarks>
+        [Event(68, Keywords = Keywords.All)]
+        public void ReusableStringBuilderFactoryStart(int hash, int newCapacity, int oldCapacity, string type)
+        {
+            WriteEvent(68, hash, newCapacity, oldCapacity, type);
+        }
+
+        /// <remarks>
+        /// This events are quite frequent so they are collected by Debug binaries only.
+        /// </remarks>
+        [Event(69, Keywords = Keywords.All)]
+        public void ReusableStringBuilderFactoryStop(int hash, int returningCapacity, int returningLength, string type)
+        {
+            WriteEvent(69, hash, returningCapacity, returningLength, type);
+        }
+
+        /// <remarks>
+        /// As oppose to other ReusableStringBuilderFactory events this one is expected to happens very un-frequently
+        ///    and if it is seen more than 100x per build it might indicates wrong usage patterns resulting into degrading
+        ///    efficiency of ReusableStringBuilderFactory. Hence it is collected in release build as well.
+        /// </remarks>
+        [Event(70, Keywords = Keywords.All)]
+        public void ReusableStringBuilderFactoryUnbalanced(int oldHash, int newHash)
+        {
+            WriteEvent(70, oldHash, newHash);
+        }
+
+#endregion
     }
 }
diff --git a/src/Framework/ReuseableStringBuilder.cs b/src/Framework/ReuseableStringBuilder.cs
new file mode 100644
index 00000000000..18457bee6f6
--- /dev/null
+++ b/src/Framework/ReuseableStringBuilder.cs
@@ -0,0 +1,355 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Diagnostics.CodeAnalysis;
+using System.Text;
+using System.Threading;
+using Microsoft.Build.Eventing;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// A StringBuilder lookalike that reuses its internal storage.
+    /// </summary>
+    /// <remarks>
+    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.
+    /// </remarks>
+    internal sealed class ReuseableStringBuilder : IDisposable
+    {
+        /// <summary>
+        /// Captured string builder.
+        /// </summary>
+        private StringBuilder? _borrowedBuilder;
+
+        /// <summary>
+        /// Capacity of borrowed string builder at the time of borrowing.
+        /// </summary>
+        private int _borrowedWithCapacity;
+
+        /// <summary>
+        /// Capacity to initialize the builder with.
+        /// </summary>
+        private int _capacity;
+
+        /// <summary>
+        /// Create a new builder, under the covers wrapping a reused one.
+        /// </summary>
+        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16
+        {
+            // lazy initialization of the builder
+            _capacity = capacity;
+        }
+
+        /// <summary>
+        /// The length of the target.
+        /// </summary>
+        public int Length
+        {
+            get { return _borrowedBuilder?.Length ?? 0; }
+            set
+            {
+                LazyPrepare();
+                _borrowedBuilder.Length = value;
+            }
+        }
+
+        /// <summary>
+        /// Convert to a string.
+        /// </summary>
+        public override string ToString()
+        {
+            if (_borrowedBuilder == null)
+            {
+                return String.Empty;
+            }
+
+            return _borrowedBuilder.ToString();
+        }
+
+        /// <summary>
+        /// Dispose, indicating you are done with this builder.
+        /// </summary>
+        public void Dispose()
+        {
+            if (_borrowedBuilder != null)
+            {
+                ReuseableStringBuilderFactory.Release(this);
+                _borrowedBuilder = null;
+                _capacity = -1;
+            }
+        }
+
+        /// <summary>
+        /// Append a character.
+        /// </summary>
+        internal ReuseableStringBuilder Append(char value)
+        {
+            LazyPrepare();
+            _borrowedBuilder.Append(value);
+            return this;
+        }
+
+        /// <summary>
+        /// Append a string.
+        /// </summary>
+        internal ReuseableStringBuilder Append(string value)
+        {
+            LazyPrepare();
+            _borrowedBuilder.Append(value);
+            return this;
+        }
+
+        /// <summary>
+        /// Append a substring.
+        /// </summary>
+        internal ReuseableStringBuilder Append(string value, int startIndex, int count)
+        {
+            LazyPrepare();
+            _borrowedBuilder.Append(value, startIndex, count);
+            return this;
+        }
+
+        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)
+        {
+            LazyPrepare();
+
+            var separatorsRemaining = strings.Count - 1;
+
+            foreach (var s in strings)
+            {
+                _borrowedBuilder.Append(s);
+
+                if (separatorsRemaining > 0)
+                {
+                    _borrowedBuilder.Append(separator);
+                }
+
+                separatorsRemaining--;
+            }
+
+            return this;
+        }
+
+        public ReuseableStringBuilder Clear()
+        {
+            LazyPrepare();
+            _borrowedBuilder.Clear();
+            return this;
+        }
+
+        /// <summary>
+        /// Remove a substring.
+        /// </summary>
+        internal ReuseableStringBuilder Remove(int startIndex, int length)
+        {
+            LazyPrepare();
+            _borrowedBuilder.Remove(startIndex, length);
+            return this;
+        }
+
+        /// <summary>
+        /// Grab a backing builder if necessary.
+        /// </summary>
+        [MemberNotNull(nameof(_borrowedBuilder))]
+        private void LazyPrepare()
+        {
+            if (_borrowedBuilder == null)
+            {
+                FrameworkErrorUtilities.VerifyThrow(_capacity != -1, "Reusing after dispose");
+
+                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);
+                _borrowedWithCapacity = _borrowedBuilder.Capacity;
+            }
+        }
+
+        /// <summary>
+        /// A utility class that mediates access to a shared string builder.
+        /// </summary>
+        /// <remarks>
+        /// If this shared builder is highly contended, this class could add
+        /// a second one and try both in turn.
+        /// </remarks>
+        private static class ReuseableStringBuilderFactory
+        {
+            /// <summary>
+            /// Made up limit beyond which we won't share the builder
+            /// because we could otherwise hold a huge builder indefinitely.
+            /// This was picked empirically to save at least 95% of allocated data size.
+            /// This constant has to be exactly 2^n (power of 2) where n = 4 ... 32 as GC is optimized to work with such block sizes.
+            /// Same approach is used in ArrayPool or RecyclableMemoryStream so having same uniform allocation sizes will
+            ///   reduce likelihood of heaps fragmentation.
+            /// </summary>
+            /// <remarks>
+            /// In order to collect and analyze ETW ReusableStringBuilderFactory events developer could follow these steps:
+            ///   - With compiled as Debug capture events by perfview; example: "perfview collect /NoGui /OnlyProviders=*Microsoft-Build"
+            ///   - Open Events view and filter for ReusableStringBuilderFactory and pick ReusableStringBuilderFactory/Stop
+            ///   - Display columns: returning length, type
+            ///   - Set MaxRet limit to 1_000_000
+            ///   - Right click and Open View in Excel
+            ///   - Use Excel data analytic tools to extract required data from it. I recommend to use
+            ///       Pivot Table/Chart with
+            ///         filter: type=[return-se,discarder];
+            ///         rows: returningLength grouped (right click and Group... into sufficient size bins)
+            ///         value: sum of returningLength
+            /// </remarks>
+            /// <remarks>
+            /// This constant might looks huge, but rather than lowering this constant,
+            /// we shall focus on eliminating code which requires creating such huge strings.
+            /// </remarks>
+            private const int MaxBuilderSizeBytes = 2 * 1024 * 1024; // ~1M chars
+            private const int MaxBuilderSizeCapacity = MaxBuilderSizeBytes / sizeof(char);
+
+            /// <summary>
+            /// The shared builder.
+            /// </summary>
+            private static StringBuilder? s_sharedBuilder;
+
+#if DEBUG && ASSERT_BALANCE
+            /// <summary>
+            /// Balance between calling Get and Release.
+            /// Shall be always 0 as Get and 1 at Release.
+            /// </summary>
+            private static int s_getVsReleaseBalance;
+#endif
+
+            /// <summary>
+            /// Obtains a string builder which may or may not already
+            /// have been used. 
+            /// Never returns null.
+            /// </summary>
+            internal static StringBuilder Get(int capacity)
+            {
+#if DEBUG && ASSERT_BALANCE
+                int balance = Interlocked.Increment(ref s_getVsReleaseBalance);
+                Debug.Assert(balance == 1, "Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.");
+#endif
+
+                StringBuilder? returned = Interlocked.Exchange(ref s_sharedBuilder, null);
+
+                if (returned == null)
+                {
+                    // Currently loaned out so return a new one with capacity in given bracket.
+                    // If user wants bigger capacity than maximum capacity, respect it.
+                    returned = new StringBuilder(SelectBracketedCapacity(capacity));
+#if DEBUG
+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity:capacity, oldCapacity:0, type:"miss");
+#endif
+                }
+                else if (returned.Capacity < capacity)
+                {
+                    // It's essential we guarantee the capacity because this
+                    // may be used as a buffer to a PInvoke call.
+                    int newCapacity = SelectBracketedCapacity(capacity);
+#if DEBUG
+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: newCapacity, oldCapacity: returned.Capacity, type: "miss-need-bigger");
+#endif
+                    // Let the current StringBuilder be collected and create new with bracketed capacity. This way it allocates only char[newCapacity]
+                    //   otherwise it would allocate char[new_capacity_of_last_chunk] (in set_Capacity) and char[newCapacity] (in Clear).
+                    returned = new StringBuilder(newCapacity);
+                }
+                else
+                {
+#if DEBUG
+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: returned.GetHashCode(), newCapacity: capacity, oldCapacity: returned.Capacity, type: "hit");
+#endif
+                }
+
+                return returned;
+            }
+
+            /// <summary>
+            /// Returns the shared builder for the next caller to use.
+            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **
+            /// </summary>
+            internal static void Release(ReuseableStringBuilder returning)
+            {
+#if DEBUG && ASSERT_BALANCE // Please define ASSERT_BALANCE if you need to analyze where we have cross thread competing usage of ReuseableStringBuilder
+                int balance = Interlocked.Decrement(ref s_getVsReleaseBalance);
+                Debug.Assert(balance == 0, "Unbalanced Get vs Release. Either forgotten Release or used from multiple threads concurrently.");
+#endif
+                FrameworkErrorUtilities.VerifyThrowInternalNull(returning._borrowedBuilder, nameof(returning._borrowedBuilder));
+
+                StringBuilder returningBuilder = returning._borrowedBuilder!;
+                int returningLength = returningBuilder.Length;
+
+                // It's possible for someone to cause the builder to
+                // enlarge to such an extent that this static field
+                // would be a leak. To avoid that, only accept
+                // the builder if it's no more than a certain size.
+                //
+                // If some code has a bug and forgets to return their builder
+                // (or we refuse it here because it's too big) the next user will
+                // get given a new one, and then return it soon after. 
+                // So the shared builder will be "replaced".
+                if (returningBuilder.Capacity > MaxBuilderSizeCapacity)
+                {
+                    // In order to free memory usage by huge string builder, do not pool this one and let it be collected.
+#if DEBUG
+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: "discard");
+#endif
+                }
+                else
+                {
+                    if (returningBuilder.Capacity != returning._borrowedWithCapacity)
+                    {
+                        Debug.Assert(returningBuilder.Capacity > returning._borrowedWithCapacity, "Capacity can only increase");
+
+                        // This builder used more than pre-allocated capacity bracket.
+                        // Let this builder be collected and put new builder, with reflecting bracket capacity, into the pool.
+                        // If we would just return this builder into pool as is, it would allocated new array[capacity] anyway (current implementation of returningBuilder.Clear() does it)
+                        //   and that could lead to unpredictable amount of LOH allocations and eventual LOH fragmentation.
+                        // Below implementation has predictable max Log2(MaxBuilderSizeBytes) string builder array re-allocations during whole process lifetime - unless MaxBuilderSizeCapacity is reached frequently.
+                        int newCapacity = SelectBracketedCapacity(returningBuilder.Capacity);
+                        returningBuilder = new StringBuilder(newCapacity);
+                    }
+
+                    returningBuilder.Clear(); // Clear before pooling
+
+                    var oldSharedBuilder = Interlocked.Exchange(ref s_sharedBuilder, returningBuilder);
+                    if (oldSharedBuilder != null)
+                    {
+                        // This can identify improper usage from multiple thread or bug in code - Get was reentered before Release.
+                        // User of ReuseableStringBuilder has to make sure that calling method call stacks do not also use ReuseableStringBuilder.
+                        // Look at stack traces of ETW events which contains reported string builder hashes.
+                        MSBuildEventSource.Log.ReusableStringBuilderFactoryUnbalanced(oldHash: oldSharedBuilder.GetHashCode(), newHash: returningBuilder.GetHashCode());
+                    }
+#if DEBUG
+                    MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: returningBuilder.GetHashCode(), returningCapacity: returningBuilder.Capacity, returningLength: returningLength, type: returning._borrowedBuilder != returningBuilder ? "return-new" : "return");
+#endif
+                }
+
+                // Ensure ReuseableStringBuilder can no longer use _borrowedBuilder
+                returning._borrowedBuilder = null;
+            }
+
+            private static int SelectBracketedCapacity(int requiredCapacity)
+            {
+                const int minimumCapacity = 0x100; // 256 characters, 512 bytes
+
+                if (requiredCapacity <= minimumCapacity)
+                    return minimumCapacity;
+
+                // If user wants bigger capacity than maximum respect it as it could be used as buffer in P/Invoke.
+                if (requiredCapacity >= MaxBuilderSizeCapacity)
+                    return requiredCapacity;
+
+                // Find next power of two http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
+                int v = requiredCapacity;
+
+                v--;
+                v |= v >> 1;
+                v |= v >> 2;
+                v |= v >> 4;
+                v |= v >> 8;
+                v |= v >> 16;
+                v++;
+
+                return v;
+            }
+        }
+    }
+}
diff --git a/src/Shared/StringBuilderCache.cs b/src/Framework/StringBuilderCache.cs
similarity index 61%
rename from src/Shared/StringBuilderCache.cs
rename to src/Framework/StringBuilderCache.cs
index 9bc6ffeb15d..abf23d07ff4 100644
--- a/src/Shared/StringBuilderCache.cs
+++ b/src/Framework/StringBuilderCache.cs
@@ -32,16 +32,18 @@
 ===========================================================*/
 
 using System;
+using System.Diagnostics;
 using System.Text;
+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+using Microsoft.Build.Eventing;
+#endif
 
-namespace Microsoft.Build.Shared
+namespace Microsoft.Build.Framework
 {
     internal static class StringBuilderCache
     {
-        // The value 360 was chosen in discussion with performance experts as a compromise between using
-        // as little memory (per thread) as possible and still covering a large part of short-lived
-        // StringBuilder creations on the startup path of VS designers.
-        private const int MAX_BUILDER_SIZE = 360;
+        // The value 512 was chosen empirically as 95% percentile of returning string length.
+        private const int MAX_BUILDER_SIZE = 512;
 
         [ThreadStatic]
         private static StringBuilder t_cachedInstance;
@@ -51,27 +53,41 @@ public static StringBuilder Acquire(int capacity = 16 /*StringBuilder.DefaultCap
             if (capacity <= MAX_BUILDER_SIZE)
             {
                 StringBuilder sb = StringBuilderCache.t_cachedInstance;
+                StringBuilderCache.t_cachedInstance = null;
                 if (sb != null)
                 {
                     // Avoid StringBuilder block fragmentation by getting a new StringBuilder
                     // when the requested size is larger than the current capacity
                     if (capacity <= sb.Capacity)
                     {
-                        StringBuilderCache.t_cachedInstance = null;
                         sb.Length = 0; // Equivalent of sb.Clear() that works on .Net 3.5
+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+                        MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: sb.GetHashCode(), newCapacity: capacity, oldCapacity: sb.Capacity, type: "sbc-hit");
+#endif
                         return sb;
                     }
                 }
             }
-            return new StringBuilder(capacity);
+
+            StringBuilder stringBuilder = new StringBuilder(capacity);
+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+            MSBuildEventSource.Log.ReusableStringBuilderFactoryStart(hash: stringBuilder.GetHashCode(), newCapacity: capacity, oldCapacity: stringBuilder.Capacity, type: "sbc-miss");
+#endif
+            return stringBuilder;
         }
 
         public static void Release(StringBuilder sb)
         {
             if (sb.Capacity <= MAX_BUILDER_SIZE)
             {
+                // Assert we are not replacing another string builder. That could happen when Acquire is reentered.
+                // User of StringBuilderCache has to make sure that calling method call stacks do not also use StringBuilderCache.
+                Debug.Assert(StringBuilderCache.t_cachedInstance == null, "Unexpected replacing of other StringBuilder.");
                 StringBuilderCache.t_cachedInstance = sb;
             }
+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+            MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: sb.GetHashCode(), returningCapacity: sb.Capacity, returningLength: sb.Length, type: sb.Capacity <= MAX_BUILDER_SIZE ? "sbc-return" :  "sbc-discard");
+#endif
         }
 
         public static string GetStringAndRelease(StringBuilder sb)
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 348be39ffa6..99a71a59e11 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -152,9 +152,6 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
-    <Compile Include="..\Shared\StringBuilderCache.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="AssemblyInfo.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index a2e79399940..cc9f10fdb27 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -139,7 +139,7 @@
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <Link>ResourceUtilities.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\StringBuilderCache.cs">
+    <Compile Include="..\Framework\StringBuilderCache.cs">
       <Link>StringBuilderCache.cs</Link>
     </Compile>
     <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index 309e39a2988..723a4df0139 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -6,6 +6,7 @@
 using System.Globalization;
 using System.Text;
 
+using Microsoft.Build.Framework;
 using Microsoft.NET.StringTools;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 536d31986cb..c398d3304a5 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Reflection;
 
 using Microsoft.Build.BackEnd;
@@ -1258,7 +1259,7 @@ private IEnumerable ReadProperties(ITranslator translator)
             int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
             if (count == 0)
             {
-                return Array.Empty<DictionaryEntry>();
+                return Enumerable.Empty<DictionaryEntry>();
             }
 
             var list = new ArrayList(count);
@@ -1280,7 +1281,7 @@ private IEnumerable ReadItems(ITranslator translator)
             int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
             if (count == 0)
             {
-                return Array.Empty<DictionaryEntry>();
+                return Enumerable.Empty<DictionaryEntry>();
             }
 
             var list = new ArrayList(count);
diff --git a/src/Shared/ReuseableStringBuilder.cs b/src/Shared/ReuseableStringBuilder.cs
deleted file mode 100644
index 8abf89a0093..00000000000
--- a/src/Shared/ReuseableStringBuilder.cs
+++ /dev/null
@@ -1,313 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Concurrent;
-using System.Collections.Generic;
-using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
-using System.Text;
-using System.Threading;
-
-namespace Microsoft.Build.Shared
-{
-    /// <summary>
-    /// A StringBuilder lookalike that reuses its internal storage.
-    /// </summary>
-    /// <remarks>
-    /// This class is being deprecated in favor of SpanBasedStringBuilder in StringTools. Avoid adding more uses.
-    /// </remarks>
-    internal sealed class ReuseableStringBuilder : IDisposable
-    {
-        /// <summary>
-        /// Captured string builder.
-        /// </summary>
-        private StringBuilder _borrowedBuilder;
-
-        /// <summary>
-        /// Capacity to initialize the builder with.
-        /// </summary>
-        private int _capacity;
-
-        /// <summary>
-        /// Create a new builder, under the covers wrapping a reused one.
-        /// </summary>
-        internal ReuseableStringBuilder(int capacity = 16) // StringBuilder default is 16
-        {
-            _capacity = capacity;
-
-            // lazy initialization of the builder
-        }
-
-        /// <summary>
-        /// The length of the target.
-        /// </summary>
-        public int Length
-        {
-            get { return (_borrowedBuilder == null) ? 0 : _borrowedBuilder.Length; }
-            set
-            {
-                LazyPrepare();
-                _borrowedBuilder.Length = value;
-            }
-        }
-
-        /// <summary>
-        /// Convert to a string.
-        /// </summary>
-        public override string ToString()
-        {
-            if (_borrowedBuilder == null)
-            {
-                return String.Empty;
-            }
-
-            return _borrowedBuilder.ToString();
-        }
-
-        /// <summary>
-        /// Dispose, indicating you are done with this builder.
-        /// </summary>
-        void IDisposable.Dispose()
-        {
-            if (_borrowedBuilder != null)
-            {
-                ReuseableStringBuilderFactory.Release(_borrowedBuilder);
-                _borrowedBuilder = null;
-                _capacity = -1;
-            }
-        }
-
-        /// <summary>
-        /// Append a character.
-        /// </summary>
-        internal ReuseableStringBuilder Append(char value)
-        {
-            LazyPrepare();
-            _borrowedBuilder.Append(value);
-            return this;
-        }
-
-        /// <summary>
-        /// Append a string.
-        /// </summary>
-        internal ReuseableStringBuilder Append(string value)
-        {
-            LazyPrepare();
-            _borrowedBuilder.Append(value);
-            return this;
-        }
-
-        /// <summary>
-        /// Append a substring.
-        /// </summary>
-        internal ReuseableStringBuilder Append(string value, int startIndex, int count)
-        {
-            LazyPrepare();
-            _borrowedBuilder.Append(value, startIndex, count);
-            return this;
-        }
-
-        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)
-        {
-            LazyPrepare();
-
-            var separatorsRemaining = strings.Count - 1;
-
-            foreach (var s in strings)
-            {
-                _borrowedBuilder.Append(s);
-
-                if (separatorsRemaining > 0)
-                {
-                    _borrowedBuilder.Append(separator);
-                }
-
-                separatorsRemaining--;
-            }
-
-            return this;
-        }
-
-        public ReuseableStringBuilder Clear()
-        {
-            LazyPrepare();
-            _borrowedBuilder.Clear();
-            return this;
-        }
-
-        /// <summary>
-        /// Remove a substring.
-        /// </summary>
-        internal ReuseableStringBuilder Remove(int startIndex, int length)
-        {
-            LazyPrepare();
-            _borrowedBuilder.Remove(startIndex, length);
-            return this;
-        }
-
-        /// <summary>
-        /// Grab a backing builder if necessary.
-        /// </summary>
-        private void LazyPrepare()
-        {
-            if (_borrowedBuilder == null)
-            {
-                ErrorUtilities.VerifyThrow(_capacity != -1, "Reusing after dispose");
-
-                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);
-            }
-        }
-
-        /// <summary>
-        /// A utility class that mediates access to a shared string builder.
-        /// </summary>
-        /// <remarks>
-        /// If this shared builder is highly contended, this class could add
-        /// a second one and try both in turn.
-        /// </remarks>
-        private static class ReuseableStringBuilderFactory
-        {
-            /// <summary>
-            /// Made up limit beyond which we won't share the builder
-            /// because we could otherwise hold a huge builder indefinitely.
-            /// This size seems reasonable for MSBuild uses (mostly expression expansion)
-            /// </summary>
-            private const int MaxBuilderSize = 1024;
-
-            /// <summary>
-            /// The shared builder.
-            /// </summary>
-            private static StringBuilder s_sharedBuilder;
-
-#if DEBUG
-            /// <summary>
-            /// Count of successful reuses
-            /// </summary>
-            private static int s_hits = 0;
-
-            /// <summary>
-            /// Count of failed reuses - a new builder was created
-            /// </summary>
-            private static int s_misses = 0;
-
-            /// <summary>
-            /// Count of times the builder capacity was raised to satisfy the caller's request
-            /// </summary>
-            private static int s_upsizes = 0;
-
-            /// <summary>
-            /// Count of times the returned builder was discarded because it was too large
-            /// </summary>
-            private static int s_discards = 0;
-
-            /// <summary>
-            /// Count of times the builder was returned.
-            /// </summary>
-            private static int s_accepts = 0;
-
-            /// <summary>
-            /// Aggregate capacity saved (aggregate midpoints of requested and returned)
-            /// </summary>
-            private static int s_saved = 0;
-
-            /// <summary>
-            /// Callstacks of those handed out and not returned yet
-            /// </summary>
-            private static ConcurrentDictionary<StringBuilder, string> s_handouts = new ConcurrentDictionary<StringBuilder, string>();
-#endif
-            /// <summary>
-            /// Obtains a string builder which may or may not already
-            /// have been used. 
-            /// Never returns null.
-            /// </summary>
-            internal static StringBuilder Get(int capacity)
-            {
-#if DEBUG
-                bool missed = false;
-#endif
-                var returned = Interlocked.Exchange(ref s_sharedBuilder, null);
-
-                if (returned == null)
-                {
-#if DEBUG
-                    missed = true;
-                    Interlocked.Increment(ref s_misses);
-#endif
-                    // Currently loaned out so return a new one
-                    returned = new StringBuilder(capacity);
-                }
-                else if (returned.Capacity < capacity)
-                {
-#if DEBUG
-                    Interlocked.Increment(ref s_upsizes);
-#endif
-                    // It's essential we guarantee the capacity because this
-                    // may be used as a buffer to a PInvoke call.
-                    returned.Capacity = capacity;
-                }
-
-#if DEBUG
-                Interlocked.Increment(ref s_hits);
-
-                if (!missed)
-                {
-                    Interlocked.Add(ref s_saved, (capacity + returned.Capacity) / 2);
-                }
-
-                // handouts.TryAdd(returned, Environment.StackTrace);
-#endif
-                return returned;
-            }
-
-            /// <summary>
-            /// Returns the shared builder for the next caller to use.
-            /// ** CALLERS, DO NOT USE THE BUILDER AFTER RELEASING IT HERE! **
-            /// </summary>
-            internal static void Release(StringBuilder returningBuilder)
-            {
-                // It's possible for someone to cause the builder to
-                // enlarge to such an extent that this static field
-                // would be a leak. To avoid that, only accept
-                // the builder if it's no more than a certain size.
-                //
-                // If some code has a bug and forgets to return their builder
-                // (or we refuse it here because it's too big) the next user will
-                // get given a new one, and then return it soon after. 
-                // So the shared builder will be "replaced".
-                if (returningBuilder.Capacity < MaxBuilderSize)
-                {
-                    // ErrorUtilities.VerifyThrow(handouts.TryRemove(returningBuilder, out dummy), "returned but not loaned");
-                    returningBuilder.Clear(); // Clear before pooling
-
-                    Interlocked.Exchange(ref s_sharedBuilder, returningBuilder);
-#if DEBUG
-                    Interlocked.Increment(ref s_accepts);
-                }
-                else
-                {
-                    Interlocked.Increment(ref s_discards);
-#endif
-                }
-            }
-
-#if DEBUG
-            /// <summary>
-            /// Debugging dumping
-            /// </summary>
-            [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Handy helper method that can be used to annotate ReuseableStringBuilder when debugging it, but is not hooked up usually for the sake of perf.")]
-            [SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId = "System.String.Format(System.IFormatProvider,System.String,System.Object[])", Justification = "Handy string that can be used to annotate ReuseableStringBuilder when debugging it, but is not hooked up usually.")]
-            internal static void DumpUnreturned()
-            {
-                String.Format(CultureInfo.CurrentUICulture, "{0} Hits of which\n    {1} Misses (was on loan)\n    {2} Upsizes (needed bigger) \n\n{3} Returns=\n{4}    Discards (returned too large)+\n    {5} Accepts\n\n{6} estimated bytes saved", s_hits, s_misses, s_upsizes, s_discards + s_accepts, s_discards, s_accepts, s_saved);
-
-                Console.WriteLine("Unreturned string builders were allocated here:");
-                foreach (var entry in s_handouts.Values)
-                {
-                    Console.WriteLine(entry + "\n");
-                }
-            }
-#endif
-        }
-    }
-}
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 171fd428e47..9dbd4f83802 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -774,10 +774,10 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
                 if (_customEscapedMetadata == null || _customEscapedMetadata.Count == 0)
                 {
 #if TASKHOST
-                    // MSBuildTaskHost.dll compiles against .NET 3.5 which doesn't have Array.Empty()
+                    // MSBuildTaskHost.dll compiles against .NET 3.5 which doesn't have Enumerable.Empty()
                     return new KeyValuePair<string, string>[0];
 #else
-                    return Array.Empty<KeyValuePair<string, string>>();
+                    return Enumerable.Empty<KeyValuePair<string, string>>();
 #endif
                 }
 
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 6baa852ba02..eaa1b3bfb89 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -306,8 +306,9 @@ protected override string GenerateFullPathToTool()
             if (String.IsNullOrEmpty(pathToTool) || !FileSystems.Default.FileExists(pathToTool))
             {
                 // The bitness of al.exe should match the platform being built
-                string archToLookFor =  Platform.Equals("x86", StringComparison.OrdinalIgnoreCase) ? Platform :
-                                        Platform.Equals("x64", StringComparison.OrdinalIgnoreCase) ? ProcessorArchitecture.AMD64 : // x64 maps to AMD64 in GeneratePathToTool
+                // Yoda condition prevents null reference exception if Platform is null.
+                string archToLookFor =  "x86".Equals(Platform, StringComparison.OrdinalIgnoreCase) ? Platform :
+                                        "x64".Equals(Platform, StringComparison.OrdinalIgnoreCase) ? ProcessorArchitecture.AMD64 : // x64 maps to AMD64 in GeneratePathToTool
                                         ProcessorArchitecture.CurrentProcessArchitecture;
 
                 pathToTool = SdkToolsPathUtility.GeneratePathToTool(f => SdkToolsPathUtility.FileInfoExists(f), archToLookFor, SdkToolsPath, ToolExe, Log, true);
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 53b19c17a62..5cb27a7ab28 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1087,7 +1087,10 @@ quiet at the engine level.
                             bool logWarning = idealAssemblyRemappingsIdentities.Any(i => i.assemblyName.FullName.Equals(fusionName) && i.reference.GetConflictVictims().Count == 0);
                             StringBuilder logConflict = StringBuilderCache.Acquire();
                             LogConflict(conflictCandidate, fusionName, logConflict);
-                            StringBuilder logDependencies = logWarning ? logConflict.AppendLine() : StringBuilderCache.Acquire();
+
+                            // If we are logging warnings append it into existing StringBuilder, otherwise build details by new StringBuilder.
+                            // Remark: There is no point to use StringBuilderCache.Acquire() here as at this point StringBuilderCache already rent StringBuilder for this thread
+                            StringBuilder logDependencies = logWarning ? logConflict.AppendLine() : new StringBuilder();
 
                             // Log the assemblies and primary source items which are related to the conflict which was just logged.
                             Reference victor = dependencyTable.GetReference(conflictCandidate.ConflictVictorName);
@@ -1108,7 +1111,7 @@ quiet at the engine level.
                             }
                             else
                             {
-                                details = StringBuilderCache.GetStringAndRelease(logDependencies);
+                                details = logDependencies.ToString();
                                 Log.LogMessage(ChooseReferenceLoggingImportance(conflictCandidate), output);
                                 Log.LogMessage(MessageImportance.Low, details);
                             }
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 29d5c673725..2e2bb8b2ab9 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -683,18 +683,24 @@ bool TryCacheAssemblyIdentityFromPath(string assemblyFile, out string candidateA
 
                 try
                 {
+                    // Framework and Utilities are default references but are often
+                    // specified in the UsingTask anyway; if so just ignore them.
+                    //
+                    // Do this with an explicit upfront check rather than loading the
+                    // assembly and then checking its name, because that can cause
+                    // the loader to have multiple copies of these assemblies as in
+                    // https://github.com/dotnet/msbuild/issues/7108.
+
+                    string name = AssemblyName.GetAssemblyName(assemblyFile).FullName;
+                    if (name == _msbuildFrameworkName ||
+                        name == _msbuildUtilitiesName)
+                    {
+                        return false;
+                    }
+
                     Assembly candidateAssembly = Assembly.UnsafeLoadFrom(assemblyFile);
                     if (candidateAssembly != null)
                     {
-                        string name = candidateAssembly.FullName;
-                        if (name == _msbuildFrameworkName ||
-                            name == _msbuildUtilitiesName)
-                        {
-                            // Framework and Utilities are default references but are often
-                            // specified in the UsingTask anyway; if so just ignore them.
-                            return false;
-                        }
-
                         candidateAssemblyLocation = candidateAssembly.Location;
                         s_knownReferenceAssemblies[candidateAssembly.FullName] = candidateAssembly;
                     }
diff --git a/src/Tasks/LC.cs b/src/Tasks/LC.cs
index ba7f7271ec5..9939247ea13 100644
--- a/src/Tasks/LC.cs
+++ b/src/Tasks/LC.cs
@@ -12,6 +12,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// The License Compiler task
     /// </summary>
+    [System.Diagnostics.CodeAnalysis.SuppressMessage("ApiDesign", "RS0022:Constructor make noninheritable base class inheritable", Justification = "Class structure has existed for a long time and shouldn't be adjusted.")]
     public class LC : ToolTaskExtension
     {
         #region Input/output properties
@@ -88,6 +89,21 @@ public string SdkToolsPath
         public string TargetFrameworkVersion { get; set; }
         #endregion
 
+#if !NETFRAMEWORK
+        /// <summary>
+        /// Override of Execute that errors, since <see cref="LC"/> is not expected to get
+        /// .NET Core support.
+        /// </summary>
+        /// <remarks>
+        /// See https://github.com/dotnet/winforms/issues/1462.
+        /// </remarks>
+        public override bool Execute()
+        {
+            Log.LogErrorFromResources("TaskRequiresFrameworkFailure", nameof(LC));
+            return false;
+        }
+#endif
+
         #region Class properties
 
         /// <summary>
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 19b5dde493f..1d84694b402 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -98,13 +98,6 @@
       <Link>RegistryHelper.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\StringBuilderCache.cs">
-      <Link>StringBuilderCache.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ReuseableStringBuilder.cs">
-      <Link>ReuseableStringBuilder.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\StrongNameHelpers.cs">
       <Link>StrongNameHelpers.cs</Link>
     </Compile>
@@ -449,6 +442,9 @@
     <Compile Include="InvalidParameterValueException.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="LC.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="ListOperators\FindUnderPath.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -499,6 +495,7 @@
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactoryCodeType.cs" />
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactoryCompilers.cs" />
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactoryTaskInfo.cs" />
+    <Compile Include="SdkToolsPathUtility.cs" />
     <Compile Include="SGen.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -608,9 +605,6 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="RCWForCurrentContext.cs" />
-    <Compile Include="LC.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="PiaReference.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -625,7 +619,6 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="ResolveSDKReference.cs" />
-    <Compile Include="SdkToolsPathUtility.cs" />
     <Compile Include="RequiresFramework35SP1Assembly.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index e69de29bb2d..23c8f38efd6 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -0,0 +1,24 @@
+Microsoft.Build.Tasks.LC
+Microsoft.Build.Tasks.LC.LC() -> void
+Microsoft.Build.Tasks.LC.LicenseTarget.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.LC.LicenseTarget.set -> void
+Microsoft.Build.Tasks.LC.NoLogo.get -> bool
+Microsoft.Build.Tasks.LC.NoLogo.set -> void
+Microsoft.Build.Tasks.LC.OutputDirectory.get -> string
+Microsoft.Build.Tasks.LC.OutputDirectory.set -> void
+Microsoft.Build.Tasks.LC.OutputLicense.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.LC.OutputLicense.set -> void
+Microsoft.Build.Tasks.LC.ReferencedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.LC.ReferencedAssemblies.set -> void
+Microsoft.Build.Tasks.LC.SdkToolsPath.get -> string
+Microsoft.Build.Tasks.LC.SdkToolsPath.set -> void
+Microsoft.Build.Tasks.LC.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.LC.Sources.set -> void
+Microsoft.Build.Tasks.LC.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.LC.TargetFrameworkVersion.set -> void
+override Microsoft.Build.Tasks.LC.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
+override Microsoft.Build.Tasks.LC.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
+override Microsoft.Build.Tasks.LC.Execute() -> bool
+override Microsoft.Build.Tasks.LC.GenerateFullPathToTool() -> string
+override Microsoft.Build.Tasks.LC.ToolName.get -> string
+override Microsoft.Build.Tasks.LC.ValidateParameters() -> bool
\ No newline at end of file
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 3cb8f7f10e4..5ad6f792355 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -57,9 +57,6 @@
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <Link>ResourceUtilities.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\StringBuilderCache.cs">
-      <Link>StringBuilderCache.cs</Link>
-    </Compile>
     <Compile Include="AssemblyResources.cs" />
     <Compile Include="RunnerUtilities.cs" />
   </ItemGroup>
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 065b9fc3233..4406635c278 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -131,12 +131,6 @@
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <Link>Shared\ResourceUtilities.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\ReuseableStringBuilder.cs">
-      <Link>Shared\ReuseableStringBuilder.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\StringBuilderCache.cs">
-      <Link>Shared\StringBuilderCache.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\TaskLoggingHelper.cs">
       <Link>Shared\TaskLoggingHelper.cs</Link>
     </Compile>
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 78b3f239533..ec7d74b763c 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -491,7 +491,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
         {
             if (_metadata == null)
             {
-                return Array.Empty<KeyValuePair<string, string>>();
+                return Enumerable.Empty<KeyValuePair<string, string>>();
             }
 
             int count = _metadata.Count;
