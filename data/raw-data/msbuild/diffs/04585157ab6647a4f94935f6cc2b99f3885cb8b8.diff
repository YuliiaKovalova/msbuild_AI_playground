diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index 392c88c6c77..52989661d31 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -890,7 +890,6 @@ public static IEnumerable<object[]> InsertMetadataElemenetAfterSiblingsTestData
                         <m>v</m>
                       </i>"
                 };
-
             }
         }
 
@@ -1014,7 +1013,6 @@ public static IEnumerable<object[]> InsertMetadataAttributeAfterSiblingsTestData
                         <b>value_b</b>
                       </i>"
                 };
-
             }
         }
 
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
index 9e15aa96ecd..3f387d1481a 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
@@ -458,7 +458,6 @@ public void ReadInvalidUpdateWithIncludeAndExclude(string project)
         {
             Assert.Throws<InvalidProjectFileException>(() =>
             {
-
                 ProjectRootElement.Create(XmlReader.Create(new StringReader(project)));
             }
            );
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index a14c3146016..7649b97ba02 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -905,7 +905,6 @@ public void ItemsEnumerator()
 
         public void SolutionCanNotBeOpened()
         {
-            
             Assert.Throws<InvalidProjectFileException>(() =>
             {
                 string solutionFile = null;
@@ -1034,7 +1033,6 @@ public void SolutionCorrupt()
         [PlatformSpecific(TestPlatforms.Windows)]  //This test is platform specific for Windows
         public void ConcurrentProjectOpenAndCloseThroughProject()
         {
-
             int iterations = 500;
             string[] paths = ObjectModelHelpers.GetTempFiles(iterations);
 
@@ -1743,7 +1741,6 @@ private void AssertProjectFileAfterReload(
             bool reloadProjectFromMemory,
             Action<string, string, string> projectFileAssert)
         {
-
             using (var env = TestEnvironment.Create())
             {
                 var projectCollection = env.CreateProjectCollection().Collection;
@@ -1900,7 +1897,6 @@ private void AssertReload(
                 Assert.Equal(childrenCount, projectElement.AllChildren.Count());
             }
 
-
             if (xmlChanged)
             {
                 Assert.NotEqual(xml, projectElement.RawXml);
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 1ee4bde1de2..c41249a0afc 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -900,7 +900,6 @@ public void ExcludeWithMissmatchingGlobCones(string includeString, string exclud
                 var testFiles = env.CreateTestProjectWithFiles(projectContents, files,relativePathFromRootToProject);
                 ObjectModelHelpers.AssertItems(expectedInclude, new Project(testFiles.ProjectFile, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, projectCollection).Items.ToList());
             }
-
         }
 
         [Theory(Skip = "https://github.com/Microsoft/msbuild/issues/1576")]
@@ -921,7 +920,6 @@ public void ExcludingRelativeItemToCurrentDirectoryShouldWorkWithAboveTheConeInc
                 var testFiles = env.CreateTestProjectWithFiles(projectContents, files, relativePathFromRootToProject);
                 ObjectModelHelpers.AssertItems(expectedInclude, new Project(testFiles.ProjectFile, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, projectCollection).Items.ToList());
             }
-
         }
 
         /// <summary>
@@ -2080,7 +2078,7 @@ public void RemoveGlob()
                 );
 
             Assert.Equal(2, items.Count);
-            Assert.Equal(@"a.txt;b.cs", string.Join(";", items.Select(i => i.EvaluatedInclude))); ;
+            Assert.Equal(@"a.txt;b.cs", string.Join(";", items.Select(i => i.EvaluatedInclude))); 
         }
 
         [Fact]
@@ -2093,7 +2091,7 @@ public void RemoveItemReference()
                 );
 
             Assert.Equal(2, items.Count);
-            Assert.Equal(@"a;c", string.Join(";", items.Select(i => i.EvaluatedInclude))); ;
+            Assert.Equal(@"a;c", string.Join(";", items.Select(i => i.EvaluatedInclude))); 
         }
 
         [Theory]
@@ -2558,7 +2556,6 @@ public void UpdateWithConditionShouldNotApplyOnItemsIgnoringCondition()
             ObjectModelHelpers.AssertItemHasMetadata(expectedUpdateFromUnconditionedElement, itemsIgnoringCondition[3]);
         }
 
-
         [Fact]
         public void LastUpdateWins()
         {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
index ec57b9901ab..b31ffbe17bb 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections.Generic;
     using System.Runtime.CompilerServices;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
index 0c1bf733a7e..aa285e5e98f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
@@ -57,7 +57,6 @@ public ElementLinkPair<CT> AppendNewLabeledChaildWithVerify<CT>(ObjectType where
         public ElementLinkPair<CT> AddNewChaildWithVerify<CT>(ObjectType where, string id, Func<T, string, CT> adder, Func<CT, string, bool> matcher)
             where CT : ProjectElement
         {
-
             var c1Where = adder(this.Get(where), id);
             Assert.NotNull(c1Where);
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
index fc833a00f64..fe148f879e4 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
@@ -245,7 +245,6 @@ private static void Verify(SdkReference view, SdkReference real, ValidationConte
             Assert.Equal(real.Name, view.Name);
             Assert.Equal(real.Version, view.Version);
             Assert.Equal(real.MinimumVersion, view.MinimumVersion);
-
         }
 
         private static void Verify(SdkResult view, SdkResult real, ValidationContext context = null)
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
index 80e5f60cdc0..25ef9caa625 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -41,7 +40,6 @@ public MyTestCollectionGroup()
         public MyTestCollectionGroup StdGroup { get; }
         public LinkedConstructionModify_Tests(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.Clear();
             this.StdGroup.Local.Importing = true;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
index 7dc33150768..9be5ab30462 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
@@ -3,7 +3,6 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -109,7 +108,6 @@ public void ProjectExtensionsElementReadOnly()
             Assert.Equal(realXml["b"], viewXml["b"]);
             Assert.Equal("x", viewXml["a"]);
             Assert.Equal("y", viewXml["b"]);
-
         }
 
         [Fact]
@@ -285,7 +283,6 @@ public void ProjectTaskElementReadOnly()
         [Fact]
         public void ProjectUsingTaskElementReadOnly()
         {
-
             var preReal = this.StdGroup.RealXml;
             var preView = this.StdGroup.ViewXml;
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
index ddea5990734..3c225aec6db 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -26,7 +25,6 @@ public MyTestCollectionGroup() : base(2, 1) { }
         public TestCollectionGroup StdGroup { get; }
         public LinkedEvaluationModify_Tests(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.Clear();
         }
@@ -105,7 +103,6 @@ public void ProjectModifyRenameAndSafeAs()
 
             // and finally just ensure that all is identical
             ViewValidation.Verify(viewProj, realProj);
-
         }
 
         [Fact]
@@ -130,7 +127,6 @@ public void ProjectItemModify()
             };
 
             /// test AddItems
-
             // add a new files in the view, ensure it is added correctly and also the real object will immediately reflect that add as well
             Assert.Null(pair.GetSingleItemWithVerify(ObjectType.View, "foo.cpp"));
             var fooView = pair.AddSingleItemWithVerify(ObjectType.View, "cpp", "foo.cpp");
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
index 355b0426ff8..5792411a2a7 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
@@ -3,7 +3,6 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
index d541acdb12b..52face4ec61 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections.Generic;
     using System.Collections.Immutable;
@@ -22,7 +21,6 @@ public MyTestCollectionGroup() : base(2, 4) { }
         public TestCollectionGroup StdGroup { get; }
         public LinkedProjectCollection_Tests(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.Clear();
         }
@@ -34,7 +32,7 @@ public void EnumerationBasic()
             var pcRemote = this.StdGroup.Remote[0];
 
             var proj1Path = this.StdGroup.StdProjectFiles[0];
-            var proj2Path = this.StdGroup.StdProjectFiles[1]; ;
+            var proj2Path = this.StdGroup.StdProjectFiles[1]; 
 
             var proj1 = pcLocal.LoadProject(proj1Path);
             var proj2 = pcRemote.LoadProject(proj2Path);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
index 04012fbb73a..bf3f9272979 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -80,7 +79,6 @@ public void ResetBeforeTests()
         public MyTestCollectionGroup StdGroup { get; }
         public LinkedSpecialCasesScenarios(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.ResetBeforeTests();
         }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
index e8e654a68ec..0c53fd5bed8 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
@@ -21,7 +21,6 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
     ///
     /// This approach with extension methods helps us put all implementation in one place, and only standard copy and pace "hookup" is needed for each classes.
     /// </summary>
-
     internal interface IProjectElementContainerLinkHelper
     {
         ProjectCollectionLinker Linker { get; }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
index ca4450dd0be..8080dd5afc7 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
@@ -101,5 +101,4 @@ public TemplateProjectElementContainerLink(MockProjectElementContainerLinkRemote
         public override void RemoveChild(ProjectElement child) => CImpl.RemoveChild(child);
         #endregion
     }
-
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
index b0889847c6f..93a45d29468 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
@@ -25,7 +25,6 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
         // ProjectMetadataElementLink support
         public string Value { get => MetadataXml.Value; set => MetadataXml.Value = value; }
         public void ChangeName(string newName) { MetadataXml.Name = newName; }
-
     }
 
     internal class MockProjectMetadataElementLink : ProjectMetadataElementLink, ILinkMock, IProjectElementLinkHelper
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
index b882f3fa9f4..8333d6cea58 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
@@ -25,7 +25,6 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
         // ProjectPropertyElementLink support
         public string Value { get => PropertyXml.Value; set => PropertyXml.Value = value; }
         public void ChangeName(string newName) { PropertyXml.Name = newName; }
-
     }
 
     internal class MockProjectPropertyElementLink : ProjectPropertyElementLink, ILinkMock, IProjectElementLinkHelper
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
index 51f5cd16e8a..49138cbd4cd 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
@@ -131,6 +131,5 @@ public static MockProjectElementLinkRemoter ExportElement(this ProjectCollection
 
             return factory(exporter, xml);
         }
-
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
index 235477ca636..253ceac7972 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
@@ -24,7 +24,6 @@ public override Project CreateLinkedObject(IImportHolder holder)
 
 
         ///  ProjectLink remoting
-
         public MockProjectElementLinkRemoter Xml => this.OwningCollection.ExportElement(this.Source.Xml);
 
         public bool ThrowInsteadOfSplittingItemElement { get => this.Source.ThrowInsteadOfSplittingItemElement; set => this.Source.ThrowInsteadOfSplittingItemElement = value; }
diff --git a/src/Build.OM.UnitTests/TransientIO.cs b/src/Build.OM.UnitTests/TransientIO.cs
index 020a2e07060..a4baa8399ca 100644
--- a/src/Build.OM.UnitTests/TransientIO.cs
+++ b/src/Build.OM.UnitTests/TransientIO.cs
@@ -88,7 +88,6 @@ public TransientIO GetSubFolder(string path)
             var subFolder = this.GetRelativePath(path);
             if (!this.Children.TryGetValue(subFolder, out var result))
             {
-
                 result  = new TransientIO(this, subFolder);
                 this.Children.Add(subFolder, result);
             }
@@ -131,6 +130,5 @@ public void Dispose()
             this.Clear();
             // this object still can be used ...
         }
-
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
index 8bd5360d434..ba2a1b00f57 100644
--- a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
@@ -67,7 +67,6 @@ public void CannotAddAfterAggregation()
                 });
                 e.Message.ShouldContain("Cannot add after aggregation");
             }
-
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index b4db76768f3..623b39580ca 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -1070,7 +1070,7 @@ private LoggerDescription CreateLoggerDescription(string loggerClassName, string
         {
             string eventsToForward = "CustomEvent";
 
-            if (forwardAllEvents == true)
+            if (forwardAllEvents)
             {
                 eventsToForward = "BuildStartedEvent;BuildFinishedEvent;ProjectStartedEvent;ProjectFinishedEvent;TargetStartedEvent;TargetFinishedEvent;TaskStartedEvent;TaskFinishedEvent;ErrorEvent;WarningEvent;HighMessageEvent;NormalMessageEvent;LowMessageEvent;CustomEvent;CommandLine";
             }
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 53f75663934..e39ca58c3df 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -1128,7 +1128,7 @@ public void LogTelemetryNullEventName()
                 service.LogTelemetry(
                     buildEventContext: null,
                     eventName: null,
-                    properties: new Dictionary<string, string>());;
+                    properties: new Dictionary<string, string>());
             });
 
             Assert.Contains("eventName is null", exception.Message);
@@ -1163,7 +1163,6 @@ private void TestLogTelemetry(BuildEventContext buildEventContext, string eventN
                 Properties = properties == null ? new Dictionary<string, string>() : new Dictionary<string, string>(properties),
             };
 
-
             TelemetryEventArgs actualEventArgs = (TelemetryEventArgs)service.ProcessedBuildEvent;
 
             Assert.Equal(expectedEventArgs.EventName, actualEventArgs.EventName);
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 3b383fe1a3f..5183dfd69b1 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -49,6 +49,5 @@ public void TaskNodesDieAfterBuild()
                 }
             }
         }
-
     }
 }
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 1e864a86580..7785cf334ff 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -334,7 +334,6 @@ public void TestItemsWithUnexpandableMetadata()
 </Project>", logger);
 
             sc.ToString().ShouldContain("\"a\\b\\%(Filename).c\"");
-
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 2bc362c5eab..33600b7d167 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -417,7 +417,6 @@ public void SolutionBasedSubToolsetVersionOverriddenByEnvironment()
             Assert.Equal("ABC", instances[0].GetPropertyValue("VisualStudioVersion"));
         }
 
-
         /// <summary>
         /// Test to make sure that even if the solution version corresponds to an existing sub-toolset version
         /// </summary>
@@ -501,7 +500,6 @@ public void SolutionPassesSubToolsetToChildProjects2()
                     EndGlobal
                 ";
 
-
             string solutionFileContentsDev11 = solutionFilePreambleV11 + solutionBodySingleProjectContents;
             string solutionFileContentsDev12 = solutionFilePreambleV12 + solutionBodySingleProjectContents;
 
@@ -620,7 +618,6 @@ public void SolutionDoesntPassSubToolsetToChildProjects()
                 List<ILogger> loggers = new List<ILogger>(1);
                 loggers.Add(logger);
 
-
                 instances[0].Build(loggers);
                 logger.AssertLogContains(String.Format(".[{0}].", ObjectModelHelpers.MSBuildDefaultToolsVersion));
             }
@@ -630,7 +627,6 @@ public void SolutionDoesntPassSubToolsetToChildProjects()
             }
         }
 
-
         /// <summary>
         /// Verify that we throw the appropriate error if the solution declares a dependency 
         /// on a project that doesn't exist.
@@ -1156,8 +1152,6 @@ public void Regress751742_SkipNonexistentProjects()
             }
         }
 
-
-
         /// <summary>
         /// Test that the in memory project created from a solution file exposes an MSBuild property which,
         /// if set when building a solution, will be specified as the ToolsVersion on the MSBuild task when
@@ -1707,7 +1701,6 @@ public void TestPredictSolutionConfigurationName()
             Assert.Null(SolutionProjectGenerator.PredictActiveSolutionConfigurationName(solution, globalProperties));
         }
 
-
         /// <summary>
         /// Verifies that the SolutionProjectGenerator will correctly escape project file paths
         /// </summary>
@@ -1972,7 +1965,6 @@ public void BadFrameworkMonkierExpectBuildToFail()
                 parameters.ShutdownInProcNodeOnBuildFinish = true;
                 buildManager = new BuildManager();
 
-
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>();
                 globalProperties["Configuration"] = "Release";
 
@@ -2064,7 +2056,6 @@ public void BadFrameworkMonkierExpectBuildToFail2()
                 parameters.ShutdownInProcNodeOnBuildFinish = true;
                 buildManager = new BuildManager();
 
-
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>();
                 globalProperties["Configuration"] = "Release";
 
@@ -2282,7 +2273,6 @@ public void IllegalUserTargetNamesDoNotThrow(bool forceCaseDifference)
                 Assert.Equal(12, instances[0].TargetsCount);
             }
 
-
             instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), new[] { "Foo" });
 
             Assert.Single(instances);
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index 1d1ab6bfd81..be35abeaf4e 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -266,7 +266,6 @@ public void VerifyTasksFilesAreInSortedOrder()
                 Assert.Equal(foundFiles[i], sortedTasksExpectedPaths[i]);
             }
 
-
             Assert.Equal(sortedOverrideExpectedPaths.Count, foundoverrideFiles.Length);
             for (int i = 0; i < foundoverrideFiles.Length; i++)
             {
diff --git a/src/Build.UnitTests/EndToEndCondition_Tests.cs b/src/Build.UnitTests/EndToEndCondition_Tests.cs
index 36c2a3380aa..488441d6817 100644
--- a/src/Build.UnitTests/EndToEndCondition_Tests.cs
+++ b/src/Build.UnitTests/EndToEndCondition_Tests.cs
@@ -72,6 +72,5 @@ public void FalseComparisonsInvolvingMSBuildToolsVersion(string condition)
 
             result.OverallResult.ShouldBe(BuildResultCode.Success);
         }
-
     }
 }
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 3d16f82ecf3..185930eccca 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4538,7 +4538,6 @@ public void VerifyPropertyTrackingLoggingDefault()
                         .AllBuildEvents
                         .OfType<PropertyInitialValueSetEventArgs>()
                         .ShouldBeEmpty();
-
                 });
         }
 
@@ -4568,7 +4567,6 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
                         .AllBuildEvents
                         .OfType<PropertyInitialValueSetEventArgs>()
                         .ShouldBeEmpty();
-
                 });
         }
 
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index fff798db3a8..7e112a07c26 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -3821,7 +3821,7 @@ public void Medley()
                     caughtException = true;
                 }
                 Assert.True(
-                        (success == false || caughtException == true),
+                        (success == false || caughtException),
                         "FAILURE: Expected '" + errorTests[i] + "' to not parse or not be evaluated but it evaluated to '" + result + "'"
                     );
             }
diff --git a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
index 2903374e8e0..d1158248164 100644
--- a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
@@ -668,7 +668,6 @@ public void ExtractItemVectorExpressionsSingleExpression2()
             List<ExpressionShredder.ItemExpressionCapture> expressions;
             ExpressionShredder.ItemExpressionCapture capture;
 
-
             expression = "@(Foo, ';')";
             expressions = ExpressionShredder.GetReferencedItemExpressions(expression);
             capture = expressions[0];
@@ -686,7 +685,6 @@ public void ExtractItemVectorExpressionsSingleExpression3()
             List<ExpressionShredder.ItemExpressionCapture> expressions;
             ExpressionShredder.ItemExpressionCapture capture;
 
-
             expression = "@(Foo->'%(Fullpath)')";
             expressions = ExpressionShredder.GetReferencedItemExpressions(expression);
             capture = expressions[0];
@@ -723,7 +721,6 @@ public void ExtractItemVectorExpressionsSingleExpression5()
             List<ExpressionShredder.ItemExpressionCapture> expressions;
             ExpressionShredder.ItemExpressionCapture capture;
 
-
             expression = "@(Foo->Bar(a,b))";
             expressions = ExpressionShredder.GetReferencedItemExpressions(expression);
             capture = expressions[0];
@@ -1092,7 +1089,6 @@ public void ExtractItemVectorExpressionsMultipleExpression4()
             Assert.Equal("\"()\", $(Boo), `)(\"`", capture.Captures[1].FunctionArguments);
         }
 
-
         [Fact]
         public void ExtractItemVectorExpressionsMultipleExpression5()
         {
diff --git a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
index 659ce98e4bc..7c94894f32f 100644
--- a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
@@ -230,7 +230,6 @@ public void ProjectWithSdkImportsIsCloneable(string projectFormatString)
             ProjectRootElement project = ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
 
             project.DeepClone();
-
         }
 
         [Theory]
@@ -267,7 +266,6 @@ public void ProjectWithSdkImportsIsRemoveable(string projectFormatString)
             clone.DeepCopyFrom(project);
 
             clone.RemoveAllChildren();
-
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
index 562516cb812..ed87a86ab7b 100644
--- a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
@@ -468,7 +468,6 @@ public void SdkResolverCanReturnSpecialCharacters()
 
             _logger.ErrorCount.ShouldBe(0);
             _logger.WarningCount.ShouldBe(0);
-
         }
 
         public void Dispose()
diff --git a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
index dec5777d189..93667018055 100644
--- a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
@@ -413,7 +413,6 @@ public void Dispose()
             {
                 if (File.Exists(file)) File.Delete(file);
             }
-
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 7358498e544..0fefab60bc5 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -13,8 +13,6 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 
-
-
 using EventSourceSink = Microsoft.Build.BackEnd.Logging.EventSourceSink;
 using Project = Microsoft.Build.Evaluation.Project;
 using Xunit;
@@ -66,7 +64,6 @@ public void BasicNoExistingFile()
                 SetUpFileLoggerAndLogMessage("logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 VerifyFileContent(log, "message here");
 
-
                 byte[] content = ReadRawBytes(log);
                 Assert.Equal((byte)109, content[0]); // 'm'
             }
diff --git a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
index e839f35708a..e44014ce596 100644
--- a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
+++ b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
@@ -355,7 +355,6 @@ public void UncPatternTrailingSlash()
 
             FileUtilitiesRegex.IsUncPattern(winDirectory).ShouldBe(false);
             FileUtilitiesRegex.IsUncPattern(unixDirectory).ShouldBe(false);
-
         }
 
         [Fact]
@@ -366,7 +365,6 @@ public void StartWithUncPatternTrailingSlash_LegacyRegex()
 
             StartsWithUncPattern.IsMatch(winDirectory).ShouldBeTrue();
             StartsWithUncPattern.IsMatch(unixDirectory).ShouldBeTrue();
-
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index 2a5495dc0ee..0bd541928cd 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -271,7 +271,6 @@ public void TestNonContradictoryAffinityAllowed()
         /// <summary>
         /// Test which ensures that setting a host object for a project with an out-of-proc affinity throws.
         /// </summary>
-
         [Fact]
         public void TestContraditcoryHostObjectCausesException_OutOfProc()
         {
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index 6743baf1a8d..6b294012cbb 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -285,7 +285,6 @@ public void UsingExplicitToolsVersionShouldBeFalseWhenNoToolsetIsReferencedInPro
                 );
 
             projectInstance.UsingDifferentToolsVersionFromProjectFile.ShouldBeFalse();
-
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
index fbb708842c8..d1c62096ca6 100644
--- a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
+++ b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
@@ -62,7 +62,6 @@ public static IEnumerable<object[]> GetProfilerResults()
                 {EvaluationLocation.CreateLocationForGlob(null, EvaluationPass.InitialProperties, "1", "myFile", 42, "glob description"),
                 new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2)}
             }) };
-
         }
     }
 }
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index f6c62d77ccd..2219cc6bb72 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -64,26 +64,6 @@ public void GetTextFromTextNodeWithXmlComment7()
             // Should get XML; note space after x added
             Assert.Equal("<!-- bar; baz; --><!-- bar --><x />", xmlContents);
         }
-
-        [Fact]
-        public void HandshakesDiffer()
-        {
-            int numHandshakeOptions = (int)Math.Pow(2, Enum.GetNames(typeof(HandshakeOptions)).Length - 1);
-            Dictionary<long, int> handshakes = new Dictionary<long, int>();
-            for (int i = 0; i < numHandshakeOptions; i++)
-            {
-                long nextKey = CommunicationsUtilities.GetHostHandshake((HandshakeOptions)i);
-                if (handshakes.TryGetValue(nextKey, out int collision))
-                {
-                    _output.WriteLine("There was a collision between {0} and {1}.", collision, i);
-                }
-                else
-                {
-                    handshakes.Add(nextKey, i);
-                }
-            }
-            handshakes.Count.ShouldBe(numHandshakeOptions, "two or more combinations of handshake options hashed to the same value");
-        }
     }
 
     public class UtilitiesTestReadOnlyLoad : UtilitiesTest
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index 6cde0e901df..9f5b6fa7f06 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -276,7 +276,6 @@ private string GetTestProject(bool? treatAllWarningsAsErrors = null, string warn
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -296,7 +295,6 @@ public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -319,7 +317,6 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -340,7 +337,6 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_ErrorAndStop()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -361,7 +357,6 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_ErrorAndStop()
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_False()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index a30017ca426..caeb65b2bce 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -1,6 +1,7 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd
@@ -50,17 +51,9 @@ internal NodeEndpointOutOfProc(
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected override long GetHostHandshake()
+        protected override Handshake GetHandshake()
         {
-            return NodeProviderOutOfProc.GetHostHandshake(_enableReuse, _lowPriority);
-        }
-
-        /// <summary>
-        /// Returns the client handshake for this node endpoint
-        /// </summary>
-        protected override long GetClientHandshake()
-        {
-            return NodeProviderOutOfProc.GetClientHandshake(_enableReuse, _lowPriority);
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess, nodeReuse: _enableReuse, lowPriority: _lowPriority));
         }
 
         #region Structs
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 63ca1cadc74..951d54fa83d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -63,19 +63,10 @@ public int AvailableNodes
         /// </summary>
         /// <param name="enableNodeReuse">Is reuse of build nodes allowed?</param>
         /// <param name="enableLowPriority">Is the build running at low priority?</param>
-        internal static long GetHostHandshake(bool enableNodeReuse, bool enableLowPriority)
+        internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPriority)
         {
             CommunicationsUtilities.Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", enableNodeReuse={2}, enableLowPriority={3}", Traits.MSBuildNodeHandshakeSalt, BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, enableNodeReuse, enableLowPriority);
-            return CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
-        }
-
-        /// <summary>
-        /// Magic number sent by the client to the host during the handshake.
-        /// Munged version of the host handshake.
-        /// </summary>
-        internal static long GetClientHandshake(bool enableNodeReuse, bool enableLowPriority)
-        {
-            return CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetHandshakeOptions(false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
         }
 
         /// <summary>
@@ -100,8 +91,8 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
             // Make it here.
             CommunicationsUtilities.Trace("Starting to acquire a new or existing node to establish node ID {0}...", nodeId);
 
-            long hostHandShake = NodeProviderOutOfProc.GetHostHandshake(ComponentHost.BuildParameters.EnableNodeReuse, ComponentHost.BuildParameters.LowPriority);
-            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandShake, NodeProviderOutOfProc.GetClientHandshake(ComponentHost.BuildParameters.EnableNodeReuse, ComponentHost.BuildParameters.LowPriority), NodeContextTerminated);
+            Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
+            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);
 
             if (null != context)
             {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 5c14d78a545..126b9f2609d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -126,12 +126,12 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
                 int timeout = 30;
 
                 // Attempt to connect to the process with the handshake without low priority.
-                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHostHandshake(nodeReuse, false), NodeProviderOutOfProc.GetClientHandshake(nodeReuse, false));
+                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, false));
 
                 if (null == nodeStream)
                 {
                     // If we couldn't connect attempt to connect to the process with the handshake including low priority.
-                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHostHandshake(nodeReuse, true), NodeProviderOutOfProc.GetClientHandshake(nodeReuse, true));
+                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, true));
                 }
 
                 if (null != nodeStream)
@@ -149,7 +149,7 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
         /// Finds or creates a child process which can act as a node.
         /// </summary>
         /// <returns>The pipe stream representing the node.</returns>
-        protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, long hostHandshake, long clientHandshake, NodeContextTerminateDelegate terminateNode)
+        protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, Handshake hostHandshake, NodeContextTerminateDelegate terminateNode)
         {
 #if DEBUG
             if (Execution.BuildManager.WaitForDebugger)
@@ -189,7 +189,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                     }
 
                     // Get the full context of this inspection so that we can always skip this process when we have the same taskhost context
-                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, clientHandshake, nodeProcess.Id);
+                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeProcess.Id);
                     if (_processesToIgnore.Contains(nodeLookupKey))
                     {
                         continue;
@@ -199,7 +199,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                     _processesToIgnore.Add(nodeLookupKey);
 
                     // Attempt to connect to each process in turn.
-                    Stream nodeStream = TryConnectToProcess(nodeProcess.Id, 0 /* poll, don't wait for connections */, hostHandshake, clientHandshake);
+                    Stream nodeStream = TryConnectToProcess(nodeProcess.Id, 0 /* poll, don't wait for connections */, hostHandshake);
                     if (nodeStream != null)
                     {
                         // Connection successful, use this node.
@@ -243,14 +243,14 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
 
                 // Create the node process
                 int msbuildProcessId = LaunchNode(msbuildLocation, commandLineArgs);
-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, clientHandshake, msbuildProcessId));
+                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcessId));
 
                 // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
                 // gotten back from CreateProcess is that of the debugger, which causes this to try to connect
                 // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
 
                 // Now try to connect to it.
-                Stream nodeStream = TryConnectToProcess(msbuildProcessId, TimeoutForNewNodeCreation, hostHandshake, clientHandshake);
+                Stream nodeStream = TryConnectToProcess(msbuildProcessId, TimeoutForNewNodeCreation, hostHandshake);
                 if (nodeStream != null)
                 {
                     // Connection successful, use this node.
@@ -293,9 +293,9 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
         /// Generate a string from task host context and the remote process to be used as key to lookup processes we have already
         /// attempted to connect to or are already connected to
         /// </summary>
-        private string GetProcessesToIgnoreKey(long hostHandshake, long clientHandshake, int nodeProcessId)
+        private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessId)
         {
-            return hostHandshake.ToString(CultureInfo.InvariantCulture) + "|" + clientHandshake.ToString(CultureInfo.InvariantCulture) + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
+            return hostHandshake.ToString() + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
         }
 
 #if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
@@ -322,7 +322,7 @@ private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStrea
         /// <summary>
         /// Attempts to connect to the specified process.
         /// </summary>
-        private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHandshake, long clientHandshake)
+        private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
         {
             // Try and connect to the process.
             string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + nodeProcessId);
@@ -348,26 +348,26 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHand
                     // remote node could set the owner to something else would also let it change owners on other objects, so
                     // this would be a security flaw upstream of us.
                     ValidateRemotePipeSecurityOnWindows(nodeStream);
-
                 }
 #endif
 
-                CommunicationsUtilities.Trace("Writing handshake to pipe {0}", pipeName);
-                nodeStream.WriteLongForHandshake(hostHandshake);
+                int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
+                for (int i = 0; i < handshakeComponents.Length; i++)
+                {
+                    CommunicationsUtilities.Trace("Writing handshake part {0} to pipe {1}", i, pipeName);
+                    nodeStream.WriteIntForHandshake(handshakeComponents[i]);
+                }
+
+                // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
+                nodeStream.WriteEndOfHandshakeSignal();
 
                 CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
+
 #if NETCOREAPP2_1 || MONO
-                long handshake = nodeStream.ReadLongForHandshake(timeout);
+                nodeStream.ReadEndOfHandshakeSignal(true, timeout);
 #else
-                long handshake = nodeStream.ReadLongForHandshake();
+                nodeStream.ReadEndOfHandshakeSignal(true);
 #endif
-
-                if (handshake != clientHandshake)
-                {
-                    CommunicationsUtilities.Trace("Handshake failed. Received {0} from client not {1}. Probably the client is a different MSBuild build.", handshake, clientHandshake);
-                    throw new InvalidOperationException();
-                }
-
                 // We got a connection.
                 CommunicationsUtilities.Trace("Successfully connected to pipe {0}...!", pipeName);
                 return nodeStream;
@@ -459,7 +459,6 @@ private int LaunchNode(string msbuildLocation, string commandLineArgs)
 
             if (!NativeMethodsShared.IsWindows)
             {
-
                 ProcessStartInfo processStartInfo = new ProcessStartInfo();
                 processStartInfo.FileName = exeName;
                 processStartInfo.Arguments = commandLineArgs;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 44a2de9a749..a0c30b87202 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -200,16 +200,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         /// </summary>
         public void ShutdownAllNodes()
         {
-            bool nodeReuse = ComponentHost.BuildParameters.EnableNodeReuse;
-
-            // To avoid issues with mismatched priorities not shutting
-            // down all the nodes on exit, we will attempt to shutdown
-            // all matching notes with and without the priroity bit set.
-            // So precompute both versions of the handshake now.
-            long hostHandshake = NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: false);
-            long hostHandshakeWithLow = NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: true);
-
-            ShutdownAllNodes(nodeReuse, NodeContextTerminated);
+            ShutdownAllNodes(ComponentHost.BuildParameters.EnableNodeReuse, NodeContextTerminated);
         }
         #endregion
 
@@ -535,8 +526,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
                                         commandLineArgs,
                                         (int)hostContext,
                                         this,
-                                        CommunicationsUtilities.GetHostHandshake(hostContext),
-                                        CommunicationsUtilities.GetClientHandshake(hostContext),
+                                        new Handshake(hostContext),
                                         NodeContextTerminated
                                     );
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 2c56e6ead22..569d6f7ad0b 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -137,7 +137,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         private List<LoggerDescription> _loggerDescriptions;
 
         /// <summary>
-        /// The event source to which filters will listen to to get the build events which are logged to the logging service through the 
+        /// The event source to which filters will listen to get the build events which are logged to the logging service through the 
         /// logging helper methods. Ie LogMessage and LogMessageEvent
         /// </summary>
         private EventSourceSink _filterEventSource;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index fef4a4d0676..0da7932c92c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -201,7 +201,6 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
             return resultsToReport;
         }
 
-
         #region IBuildComponent Members
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index c141a8cf4a4..59c6300ea50 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -460,7 +460,6 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfNoInputs()
                 _loggingService.LogComment(_buildEventContext, MessageImportance.Low, "BuildTargetCompletely", _targetToAnalyze.Name);
                 _loggingService.LogComment(_buildEventContext, MessageImportance.Low, "BuildTargetCompletelyNoInputsSpecified");
 
-
                 // otherwise, do a full build
                 result = DependencyAnalysisResult.FullBuild;
             }
@@ -1074,7 +1073,6 @@ internal static bool IsAnyOutOfDate<T>(out DependencyAnalysisLogDetail dependenc
             return false;
         }
 
-
         /// <summary>
         /// Record the unique input and output files so that the "up to date" message
         /// can list them in the log later.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 23a6fc8d5aa..8a55626d1d8 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -545,7 +545,6 @@ private IDictionary<string, string> GatherTaskIdentityParameters(Expander<Projec
             return taskIdentityParameters;
         }
 
-
 #if FEATURE_APARTMENT_STATE
         /// <summary>
         /// Executes the task using an STA thread.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 81e53c7ba6b..ccb05f13d13 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -987,7 +987,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
         /// </summary>
         private void VerifyActiveProxy()
         {
-            ErrorUtilities.VerifyThrow(_activeProxy == true, "Attempted to use an inactive task host.");
+            ErrorUtilities.VerifyThrow(_activeProxy, "Attempted to use an inactive task host.");
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 4ea8954c988..3f541b05568 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -12,7 +12,6 @@
 
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
-
     internal sealed class CachingSdkResolverService: SdkResolverService
     {
         /// <summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 96a9aba7954..0c52dddff33 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -121,7 +121,6 @@ private void HandleRequest(int node, SdkResolverRequest request)
 
                         // Create the thread which processes requests
                         _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);
-                        
                     }
                 }
             }
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
index bb66cd23cd0..55add7055bb 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
@@ -43,7 +43,6 @@ public SdkResult(SdkReference sdkReference, string path, string version, IEnumer
 
         public SdkResult()
         {
-
         }
 
         public SdkResult(SdkReference sdkReference, IEnumerable<string> paths, string version, IDictionary<string, string> propertiesToAdd,
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index ab48153c24a..70c892aac27 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -293,7 +293,6 @@ public RequestedProjectState RequestedProjectState
             set => _requestedProjectState = value;
         }
 
-
         /// <summary>
         /// The route for host-aware tasks back to the host
         /// </summary>
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index 44c8458b111..129e9ae3f35 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -392,7 +392,6 @@ public virtual void CopyFrom(ProjectElement element)
             }
             else
             {
-
                 // Copy over the attributes from the template element.
                 foreach (XmlAttribute attribute in element.XmlElement.Attributes)
                 {
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 287b965ab35..1d6ef6df34f 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -142,7 +142,6 @@ public class ProjectRootElement : ProjectElementContainer
         /// </summary>
         private string _dirtyParameter = String.Empty;
 
-
         internal ProjectRootElementLink RootLink => (ProjectRootElementLink)Link;
 
         /// <summary>
@@ -748,7 +747,6 @@ public static ProjectRootElement Create(ProjectCollection projectCollection, New
             return Create(projectCollection.ProjectRootElementCache, projectFileOptions);
         }
 
-
         /// <summary>
         /// Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
         /// Uses the global project collection.
diff --git a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
index 24858497373..0700c134ddb 100644
--- a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
@@ -10,7 +10,6 @@ namespace Microsoft.Build.Construction
     /// </summary>
     public sealed class ProjectConfigurationInSolution
     {
-
         /// <summary>
         /// Constructor
         /// </summary>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 66355f8040e..67bb768c735 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -609,7 +609,6 @@ internal void ParseSolution()
                     new BuildEventFileInfo(FullPath),
                     "SolutionParseDuplicateProject",
                     uniqueName);
-
             }
         } // ParseSolutionFile()
 
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index a15016a7ac0..88db148da8a 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -853,7 +853,6 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             ProjectImportElement importAfter = traversalProject.CreateImportElement(@"$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportAfter\*");
             importAfter.Condition = @"'$(ImportByWildcardBeforeSolution)' != 'false' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportAfter')"; // Avoids wildcard perf problem
 
-
             /* The code below adds the following XML:
 
             - TOP -
@@ -995,7 +994,7 @@ private void EmitMetaproject(ProjectRootElement metaproject, string path)
             {
                 metaproject.Save(path);
             }
-            if (_loggingService.IncludeEvaluationMetaprojects == true)
+            if (_loggingService.IncludeEvaluationMetaprojects)
             {
                 var xml = new StringBuilder();
                 using (var writer = new StringWriter(xml))
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 02bba78e5d9..7396c1c855e 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -1727,7 +1727,6 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
             ErrorUtilities.VerifyThrowInvalidOperation(ReferenceEquals(Xml, otherXml), "OM_CannotModifyEvaluatedObjectInImportedFile", otherXml.Location.File);
         }
 
-
         /// <summary>
         /// Internal project evaluation implementation
         /// </summary>
@@ -2386,7 +2385,6 @@ public override bool IsBuildEnabled
             /// </summary>
             internal ILoggingService LoggingService => ProjectCollection.LoggingService;
 
-
             /// <summary>
             /// See <see cref="ProjectLink.GetAllGlobs(EvaluationContext)"/>
             /// </summary>
@@ -3195,7 +3193,6 @@ public override string ExpandString(string unexpandedValue)
                 return result;
             }
 
-
             /// <summary>
             /// See <see cref="ProjectLink.CreateProjectInstance(ProjectInstanceSettings, EvaluationContext)"/>
             /// </summary>
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 06be3f47ec0..ce296a6a0cf 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -473,7 +473,6 @@ public static string DisplayVersion
                     s_assemblyDisplayVersion = plusIndex < 0
                                                     ? fullInformationalVersion
                                                     : fullInformationalVersion.Substring(startIndex: 0, length: plusIndex + 10);
-
                 }
 
                 return s_assemblyDisplayVersion;
@@ -809,7 +808,6 @@ public bool DisableMarkDirty
             }
         }
 
-
         /// <summary>
         /// Global collection id.
         /// Can be used for external providers to optimize the cross-site link exchange
@@ -820,7 +818,6 @@ public bool DisableMarkDirty
         /// External project support.
         /// Establish a remote project link for this collection.
         /// </summary>
-
         internal ExternalProjectsProvider Link
         {
             get => _link;
@@ -1090,7 +1087,6 @@ internal ICollection<Project> GetLoadedProjects(bool includeExternal, string ful
             return loaded;
         }
 
-
         /// <summary>
         /// Loads a project with the specified filename, using the collection's global properties and tools version.
         /// If a matching project is already loaded, it will be returned, otherwise a new project will be loaded.
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index 2408a1e6c18..56464949524 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -143,7 +143,6 @@ public string UnevaluatedValue
 
                 if (_evaluatedValueEscaped != null)
                 {
-
                     // Clear out the current value of this metadata, so the new value can't refer to the old one.
                     // The expansion call below otherwise passes in the parent item's metadata - including this one's
                     // current value.
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 5cb358fae95..5ce4eba9b86 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -629,7 +629,6 @@ public override bool IsImported
             }
         }
 
-
         /// <summary>
         /// External projects support
         /// </summary>
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 351c8f749bc..8ce8b05ed9d 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -284,7 +284,6 @@ internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary<Proje
             _environmentProperties = environmentProperties;
             _overrideTasksPath = msbuildOverrideTasksPath;
             _defaultOverrideToolsVersion = defaultOverrideToolsVersion;
-            
         }
 
         /// <summary>
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index a4732a17f7e..95507b8035e 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -756,7 +756,6 @@ private string ExpandRelativePathsRelativeToExeLocation(string path)
     /// </summary>
     internal struct MSBuildExtensionsPathReferenceKind
     {
-
         /// <summary>
         /// MSBuildExtensionsPathReferenceKind instance for property named "MSBuildExtensionsPath"
         /// </summary>
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index ca0a8f26a77..747d2ad293d 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -92,7 +92,7 @@ bool initializationException
             : base(message, innerException)
         {
             ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
-            ErrorUtilities.VerifyThrow(innerException != null || initializationException == true, "Need the logger exception.");
+            ErrorUtilities.VerifyThrow(innerException != null || initializationException, "Need the logger exception.");
             ErrorUtilities.VerifyThrow((errorCode != null) && (errorCode.Length > 0), "Must specify the error message code.");
             ErrorUtilities.VerifyThrow((helpKeyword != null) && (helpKeyword.Length > 0), "Must specify the help keyword for the IDE.");
 
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 9e31fb7754e..7331feccb1e 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -155,7 +155,6 @@ private List<string> ExpandArgumentAsFileList(GenericExpressionNode argumentNode
                 argument = FileUtilities.FixFilePath(argument);
             }
 
-
             IList<TaskItem> expanded = state.ExpandIntoTaskItems(argument);
             var expandedCount = expanded.Count;
 
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index 6e53b876075..3255b2b6d8a 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -131,7 +131,6 @@ private GenericExpressionNode Expr(string expression)
                 node = ExprPrime(expression, node);
             }
 
-
             #region REMOVE_COMPAT_WARNING
             // Check for potential change in behavior
             if (LoggingServices != null && !_warnedForExpression &&
@@ -237,7 +236,6 @@ private GenericExpressionNode RelationalExpr(string expression)
             }
         }
 
-
         private OperatorExpressionNode RelationalOperation(string expression)
         {
             OperatorExpressionNode node = null;
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index b38d2ee912d..13f712f4583 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -2197,7 +2197,6 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                                     _evaluationLoggingContext.LogBuildEvent(eventArgs);
                                 }
 
-
                                 continue;
                             }
 
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index b91daae440a..e64817750e8 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -27,7 +27,6 @@ internal interface IEvaluatorData<P, I, M, D> : IPropertyProvider<P>, IItemProvi
         where M : class, IMetadatum
         where D : class, IItemDefinition<M>
     {
-
         /// <summary>
         /// The ID of this evaluation
         /// </summary>
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 48965e7852d..79174f86b83 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -187,7 +187,6 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
             return GetRegistryValueFromView(keyName, valueName, defaultValue, new ArraySegment<object>(views));
         }
 
-
         /// <summary>
         /// Get the value of the registry key from one of the RegistryView's specified
         /// </summary>
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 550b876c290..4c88a6d976f 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -311,6 +311,5 @@ public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalPro
             }
         }
     }
-
     
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index ce9f84cd29d..58b2d1d661f 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -304,7 +304,6 @@ public ImmutableList<ItemData>.Builder GetItemData(ImmutableHashSet<string> glob
 
                     return ComputeItems(this, globsToIgnore);
                 }
-
             }
 
             private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyItemList, ImmutableHashSet<string> globsToIgnore)
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index cbdb79a738e..4d57990f847 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -54,7 +54,7 @@ internal class ProjectParser
         private static readonly HashSet<string> ValidAttributesOnTarget = new HashSet<string> { XMakeAttributes.condition, XMakeAttributes.label, XMakeAttributes.name, XMakeAttributes.inputs, XMakeAttributes.outputs, XMakeAttributes.keepDuplicateOutputs, XMakeAttributes.dependsOnTargets, XMakeAttributes.beforeTargets, XMakeAttributes.afterTargets, XMakeAttributes.returns };
 
         /// <summary>
-        /// Valid attributes on on error element
+        /// Valid attributes on error element
         /// </summary>
         private static readonly HashSet<string> ValidAttributesOnOnError = new HashSet<string> { XMakeAttributes.condition, XMakeAttributes.label, XMakeAttributes.executeTargets };
 
@@ -229,7 +229,6 @@ private ProjectPropertyGroupElement ParseProjectPropertyGroupElement(XmlElementW
             return propertyGroup;
         }
 
-
         /// <summary>
         /// Parse a ProjectItemGroupElement
         /// </summary>
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 1cba0713bb1..3258de63334 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -131,8 +131,6 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO
             LoadProjectsReadOnly = loadProjectsReadOnly;
         }
 
-
-
         /// <summary>
         /// Returns an existing ProjectRootElement for the specified file path, if any.
         /// If none exists, calls the provided delegate to load one, and adds that to the cache.
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 546fcc45a68..92d4aa212c9 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -347,7 +347,6 @@ IReadOnlyDictionary<string, IReadOnlyCollection<string>> GetSolutionDependencies
                     solutionDependencies[FileUtilities.NormalizePath(projectWithDependencies.AbsolutePath)] = projectWithDependencies.Dependencies.Select(
                         dependencyGuid =>
                         {
-
                             // code snippet cloned from SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration
 
                             if (!solutionFile.ProjectsByGuid.TryGetValue(dependencyGuid, out var dependencyProject))
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index 8c820643d32..328a8c2a1ba 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -128,7 +128,7 @@ public void RegisterHostObject(string projectFile, string targetName, string tas
             // We can only set the host object to a non-null value if the affinity for the project is not out of proc, or if it is, it is only implicitly
             // out of proc, in which case it will become in-proc after this call completes.  See GetNodeAffinity.
             bool isExplicit;
-            bool hasExplicitOutOfProcAffinity = (GetNodeAffinity(projectFile, out isExplicit) == NodeAffinity.OutOfProc) && (isExplicit == true);
+            bool hasExplicitOutOfProcAffinity = (GetNodeAffinity(projectFile, out isExplicit) == NodeAffinity.OutOfProc) && (isExplicit);
             ErrorUtilities.VerifyThrowInvalidOperation(!hasExplicitOutOfProcAffinity || hostObject == null, "InvalidHostObjectOnOutOfProcProject");
             _hostObjectMap = _hostObjectMap ?? new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
 
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index cff4feb6b66..946e5ca11e8 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -182,7 +182,6 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private bool _translateEntireState;
         private int _evaluationId = BuildEventContext.InvalidEvaluationId;
 
-
         /// <summary>
         /// Creates a ProjectInstance directly.
         /// No intermediate Project object is created.
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index f33856ecb9e..e04e915f2bb 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -196,7 +196,6 @@ List<ProjectItemGroupTaskMetadataInstance> metadata
 
         private ProjectItemGroupTaskItemInstance()
         {
-            
         }
 
         /// <summary>
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 62d541b85d1..60a30900e86 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -352,7 +352,7 @@ internal bool IsEventSerializable(BuildEventArgs e)
         /// </summary>
         private void VerifyActiveProxy()
         {
-            ErrorUtilities.VerifyThrow(_activeProxy == true, "Attempted to use an inactive task factory logging host.");
+            ErrorUtilities.VerifyThrow(_activeProxy, "Attempted to use an inactive task factory logging host.");
         }
     }
 }
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 3d261b4cf46..5896d6b46e7 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -663,7 +663,6 @@ private void RegisterTask(string taskName, AssemblyLoadInfo assemblyLoadInfo, st
 
         private static Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(int? capacity = null)
         {
-
             return capacity != null
                 ? new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(capacity.Value, RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact)
                 : new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
@@ -1007,7 +1006,6 @@ internal class RegisteredTaskRecord : ITranslatable
             /// </summary>
             internal const string XamlTaskFactory = "XamlTaskFactory";
 
-
             /// <summary>
             /// Lock for the taskFactoryTypeLoader
             /// </summary>
@@ -1290,7 +1288,6 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                     ITaskFactory factory = null;
                     LoadedType loadedType = null;
 
-
                     bool isAssemblyTaskFactory = String.Equals(TaskFactoryAttributeName, AssemblyTaskFactory, StringComparison.OrdinalIgnoreCase);
                     bool isTaskHostFactory = String.Equals(TaskFactoryAttributeName, TaskHostFactory, StringComparison.OrdinalIgnoreCase);
 
@@ -1475,7 +1472,6 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                         }
                     }
 
-
                     _taskFactoryWrapperInstance = new TaskFactoryWrapper(factory, loadedType, RegisteredName, TaskFactoryParameters);
                 }
 
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 1b265e7fb62..4bb3379dfcf 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -678,7 +678,6 @@ internal virtual void OutputItems(string itemType, ArrayList itemTypeList)
             resetColor();
         }
 
-
         /// <summary>
         /// Returns a performance counter for a given scope (either task name or target name)
         /// from the given table.
@@ -1180,7 +1179,6 @@ private bool ApplyVerbosityParameter(string parameterValue)
 
         internal bool runningWithCharacterFileType = false;
 
-
         #region Per-build Members
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index e67c64310af..5ee2af9780c 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -971,7 +971,6 @@ private EvaluationLocation ReadEvaluationLocation()
                 if (hasParent)
                 {
                     parentId = ReadInt64();
-
                 }
                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);
             }
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index 2f690d51fa6..b865a4764b0 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -58,7 +58,6 @@ public class ConsoleLogger : INodeLogger
         private bool _skipProjectStartedText = false;
         private bool? _showSummary;
 
-
         #region Constructors
 
         /// <summary>
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 80cc9789d0d..c9b9ca599f0 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -262,7 +262,6 @@ private void SetForwardingBasedOnVerbosity()
             }
         }
 
-
         /// <summary>
         /// Reset the states of per-build member variables.
         /// Used when a build is finished, but the logger might be needed for the next build.
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index cb25eb21b78..20b3e3b2862 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -576,7 +576,6 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
 
-
             // Get the project started event so we can use its information to properly display a project finished event
             ProjectStartedEventMinimumFields startedEvent = _buildEventManager.GetProjectStartedEvent(e.BuildEventContext);
             ErrorUtilities.VerifyThrow(startedEvent != null, "Project finished event for {0} received without matching start event", e.ProjectFile);
@@ -786,7 +785,6 @@ public override void TargetStartedHandler(object sender, TargetStartedEventArgs
             // later in the build
             _buildEventManager.AddTargetStartedEvent(e, _showTimeStamp || IsVerbosityAtLeast(LoggerVerbosity.Detailed));
 
-
             if (this.showPerfSummary)
             {
                 // Create a new performance counter for this target
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 3c095d561d1..7d148b1c912 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -648,7 +648,6 @@ internal ProjectFullKey(int projectKey, int entryPointKey)
         /// <summary>
         /// Output the projectKey or the projectKey and the entrypointKey depending on the verbosity level of the logger
         /// </summary>
-
         public string ToString(LoggerVerbosity verbosity)
         {
             string fullProjectKey;
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index db37ae85bf1..5d0ed444b07 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -143,7 +143,6 @@ internal ProfilerResult GetAggregatedResult(bool pruneSmallItems = true)
                 foreach (var pair in profiledResult.ProfiledLocations.OrderBy(p => p.Key.Id))
                 {
                     MergeItem(originalLocations, mergeMap, _aggregatedLocations, pair);
-
                 }
             }
 
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
index f5aca34ec3b..27f3067ecf7 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
@@ -6,7 +6,6 @@
 
 namespace Microsoft.Build.ObjectModelRemoting
 {
-
     /// <summary>
     /// External projects support.
     /// Allow for creating a local representation to external object of type <see cref="ProjectMetadata"/>
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
index 377daf47856..b0f9a943622 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
@@ -70,5 +70,4 @@ public static string GetEvaluatedValueEscaped(ProjectProperty property)
             return property.EvaluatedValueEscapedIntenral;
         }
     }
-
 }
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index d639aa819cd..5989bc53ffe 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -8,7 +8,6 @@
 
 namespace Microsoft.Build.ObjectModelRemoting
 {
-
     /// <summary>
     /// implemented by MSBuild objects that support remote linking;
     /// </summary>
@@ -270,7 +269,6 @@ internal LinkedProjectMetadata(object parent, ProjectMetadataLink link)
 
             internal override ProjectMetadataLink Link { get; }
             object ILinkableObject.Link => Link;
-
         }
 
         private class LinkedProjectProperty : ProjectProperty, ILinkableObject
@@ -315,5 +313,4 @@ public override string UnevaluatedValue
         #endregion
     }
 
-
 }
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 35030eefbac..32df574c3b5 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -42,7 +42,6 @@ public EngineFileUtilities(FileMatcher fileMatcher)
             _fileMatcher = fileMatcher;
         }
 
-
         /// <summary>
         /// Used for the purposes of evaluating an item specification. Given a filespec that may include wildcard characters * and
         /// ?, we translate it into an actual list of files. If the input filespec doesn't contain any wildcard characters, and it
diff --git a/src/Deprecated/Conversion/AdditionalOptionsParser.cs b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
index b99929a450e..6d256826243 100644
--- a/src/Deprecated/Conversion/AdditionalOptionsParser.cs
+++ b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
@@ -85,7 +85,7 @@ internal sealed class CompSwitchInfo
         internal object SwitchValue;
 
         /// <summary>
-        /// This is the the name of property in the project file in which the
+        /// This is the name of property in the project file in which the
         /// value of this switch is stored
         /// </summary>
         internal string SwitchProjectPropertyName;
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index 1fc578329d7..825aa3158d2 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -532,7 +532,6 @@ private void ConvertInMemoryToMSBuildProject()
                         listOfWFImportsToBeDeleted.Add(nextImport);
                         workflowImportsToAdd.Add(nextImport.Project.Replace(workflowOldOrcasTargetsPath, workflowNewTargetsPath));
                     }
-
                 }
 
                 // Now delete any matching imports
@@ -564,7 +563,6 @@ private void ConvertInMemoryToMSBuildProject()
                     changedProject = true;
                 }
 
-
                 // Re-add the workflow imports with the v4.0 targets.
                 foreach (string workflowImportToAdd in workflowImportsToAdd)
                 {
@@ -1072,7 +1070,6 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 //</Choose>
                 //<Import Project="$(FSharpTargetsPath)" Condition="Exists('$(FSharpTargetsPath)')" />           
 
-
                 var whenVsVersionIsDev11 = xmakeProject.CreateWhenElement("'$(VisualStudioVersion)' == '11.0'");
                 chooseElement.AppendChild(whenVsVersionIsDev11);
                 {
@@ -1225,7 +1222,6 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 fsharpCoreItem.Parent.RemoveChild(fsharpCoreItem);
             }
 
-
             return true;
         }
 
@@ -1518,7 +1514,7 @@ XmlElementWithLocation      languageElement
             // Get the project instance GUID for this project file.  It is required for
             // the main project file, but not for the .USER file.
             this.projectGuid = languageElement.GetAttribute(VSProjectAttributes.projectGuid);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((this.projectGuid != null) || (this.isUserFile == true),
+            ProjectErrorUtilities.VerifyThrowInvalidProject((this.projectGuid != null) || (this.isUserFile),
                 languageElement.Location, "MissingAttribute", languageElement.Name, VSProjectAttributes.projectGuid);
 
             // Get the project type for this project file.  We only support "Local".  We do not
@@ -1630,7 +1626,6 @@ XmlElementWithLocation      languageElement
                 }
             }
 
-
             // Loop through all the direct child elements of the language element.
             foreach(XmlNode languageChildNode in languageElement)
             {
@@ -3004,7 +2999,6 @@ XmlElementWithLocation      importsElement
                 {
                     ProjectXmlUtilities.ThrowProjectInvalidChildElement(importsChildNode.Name, importsElement.Name, importsElement.Location);
                 }
-
             }
         }
 
@@ -3250,7 +3244,6 @@ ProjectItemGroupElement filesItemGroup
                  && IsFilePresentButEmpty(relPath, linkPath))
                )
             {
-
                 // Add the new item to XMake.
                 if ((linkPath == null) || (linkPath.Length == 0))
                 {
diff --git a/src/Deprecated/Engine/Choose/GroupingCollection.cs b/src/Deprecated/Engine/Choose/GroupingCollection.cs
index 505f26fe41a..f241c75edae 100644
--- a/src/Deprecated/Engine/Choose/GroupingCollection.cs
+++ b/src/Deprecated/Engine/Choose/GroupingCollection.cs
@@ -9,7 +9,6 @@
 
 using Microsoft.Build.BuildEngine.Shared;
 
-
 using error = Microsoft.Build.BuildEngine.Shared.ErrorUtilities;
 
 namespace Microsoft.Build.BuildEngine
@@ -426,7 +425,6 @@ BuildItemGroup itemGroupToRemove
 
             ChangeItemGroupCount(-1);
             error.VerifyThrow(this.itemGroupCount >= 0, "Too many calls to RemoveItemGroup().");
-
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Choose/When.cs b/src/Deprecated/Engine/Choose/When.cs
index 9f1c919092e..de9263754cc 100644
--- a/src/Deprecated/Engine/Choose/When.cs
+++ b/src/Deprecated/Engine/Choose/When.cs
@@ -83,7 +83,6 @@ int nestingDepth
             }
 
             ProcessWhenChildren(whenElement, parentProject, importedFromAnotherProject, nestingDepth);
-
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
index 7e09548b102..1271b32f52f 100644
--- a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
+++ b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
@@ -11,7 +11,6 @@
 
 namespace Microsoft.Build.BuildEngine
 {
-
     /// <summary>
     /// A hashtable wrapper that defers copying until the data is written.
     /// </summary>
@@ -89,7 +88,6 @@ internal CopyOnWriteHashtable(IDictionary dictionary, StringComparer stringCompa
                     // this means a bug in the engine code somewhere.
                     throw new InternalErrorException("Bug: Changing the case-sensitiveness of a copied hash-table.");
                 }
-
             }
 
             // Can't defer this because we don't control what gets written to the dictionary exogenously.
@@ -193,7 +191,6 @@ public Object this[Object key]
                         }
                     }
                 }
-
             }
         }
 #endregion
diff --git a/src/Deprecated/Engine/Collections/DualQueue.cs b/src/Deprecated/Engine/Collections/DualQueue.cs
index 13afc4e393f..8770f3a7381 100644
--- a/src/Deprecated/Engine/Collections/DualQueue.cs
+++ b/src/Deprecated/Engine/Collections/DualQueue.cs
@@ -79,7 +79,6 @@ internal WaitHandle QueueEmptyEvent
         /// <returns></returns>
         internal int Count
         {
-
             get
             {
                 // Sum both as the number of items is the sum of items in both queues
diff --git a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
index b080102cca6..dfa1b8bba90 100644
--- a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
@@ -63,7 +63,6 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
 
                         return false;
                     }
-
                 }
 
                 // Both Exists functions return false if the value is null or empty
diff --git a/src/Deprecated/Engine/Conditionals/Parser.cs b/src/Deprecated/Engine/Conditionals/Parser.cs
index 9b1dec56f0c..f42eecf7285 100644
--- a/src/Deprecated/Engine/Conditionals/Parser.cs
+++ b/src/Deprecated/Engine/Conditionals/Parser.cs
@@ -125,7 +125,6 @@ private GenericExpressionNode Expr(string expression)
                 node = ExprPrime(expression, node);
             }
 
-
             #region REMOVE_COMPAT_WARNING
             // Check for potential change in behavior
             if (LoggingServices != null && !warnedForExpression &&
@@ -239,7 +238,6 @@ private GenericExpressionNode RelationalExpr(string expression)
             }
         }
 
-
         private OperatorExpressionNode RelationalOperation(string expression)
         {
             OperatorExpressionNode node = null;
@@ -398,6 +396,5 @@ private bool Same(string expression, Token.TokenType token)
             else
                 return false;
         }
-
     }
 }
diff --git a/src/Deprecated/Engine/Conditionals/Scanner.cs b/src/Deprecated/Engine/Conditionals/Scanner.cs
index 1863bf01524..bbf8ff1a366 100644
--- a/src/Deprecated/Engine/Conditionals/Scanner.cs
+++ b/src/Deprecated/Engine/Conditionals/Scanner.cs
@@ -437,7 +437,6 @@ private bool ParseInternalItemList()
             }
             if (parsePoint >= expression.Length)
             {
-                
                 errorPosition = start + 1;
                 if (fInReplacement)
                 {
diff --git a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
index a66656634ac..14542e15990 100644
--- a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
@@ -83,5 +83,4 @@ internal override void ResetState()
             cachedExpandedValue = null;
         }
     }
-
 }
diff --git a/src/Deprecated/Engine/Engine/BatchingEngine.cs b/src/Deprecated/Engine/Engine/BatchingEngine.cs
index 90d79845223..36bd21b33d1 100644
--- a/src/Deprecated/Engine/Engine/BatchingEngine.cs
+++ b/src/Deprecated/Engine/Engine/BatchingEngine.cs
@@ -414,7 +414,6 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
             return itemMetadataValues;
         }
 
-
         #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Engine/BuildResult.cs b/src/Deprecated/Engine/Engine/BuildResult.cs
index 8390e845add..f701828bcc9 100644
--- a/src/Deprecated/Engine/Engine/BuildResult.cs
+++ b/src/Deprecated/Engine/Engine/BuildResult.cs
@@ -343,7 +343,6 @@ internal void WriteToStream(BinaryWriter writer)
             #endregion
         }
 
-
         internal static BuildResult CreateFromStream(BinaryReader reader)
         {
             BuildResult buildResult = new BuildResult();
diff --git a/src/Deprecated/Engine/Engine/Engine.cs b/src/Deprecated/Engine/Engine/Engine.cs
index e9b5b85cf45..b58314b9423 100644
--- a/src/Deprecated/Engine/Engine/Engine.cs
+++ b/src/Deprecated/Engine/Engine/Engine.cs
@@ -95,7 +95,6 @@ public enum ToolsetDefinitionLocations
     [Obsolete("This class has been deprecated. Please use Microsoft.Build.Evaluation.ProjectCollection from the Microsoft.Build assembly instead.")]
     public class Engine
     {
-
         #region Member Data
 
         // For those folks who want to share a single Engine object across many projects
@@ -453,7 +452,6 @@ private void InitializeLocalNodeProvider(ToolsetDefinitionLocations locations)
             {
                 LocalNodeProvider localNodeProvider = new LocalNodeProvider();
 
-
                 string configuration = string.Empty;
                 if (localNodeProviderParameters.EndsWith(";", StringComparison.OrdinalIgnoreCase))
                 {
@@ -500,7 +498,6 @@ public string BinPath
             }
         }
 
-
         /// <summary>
         /// Is this engine in the process of building?
         /// </summary>
@@ -844,7 +841,6 @@ internal EngineCallback EngineCallback
             }
         }
 
-
         internal bool EnabledCentralLogging
         {
             get
@@ -902,7 +898,6 @@ internal ITaskRegistry GetTaskRegistry(BuildEventContext buildEventContext, stri
             return toolsetState.GetTaskRegistry(buildEventContext);
         }
 
-
         /// <summary>
         /// Adds a new toolset to the engine. Any pre-existing toolset with the same
         /// tools version is replaced with the provided toolset.
@@ -1007,7 +1002,6 @@ internal void PopulateToolsetStateMap(ToolsetDefinitionLocations locations)
                 // Now update the default tools version to 2.0
                 DefaultToolsVersion = Constants.defaultToolsVersion;
             }
-
         }
 
         /// <summary>
@@ -1332,7 +1326,6 @@ public void Shutdown()
             UnregisterAllLoggers();
         }
 
-
         /// <summary>
         /// Creates a new empty Project object that is associated with this engine. All projects must be associated with an
         /// engine, because they need loggers, global properties, reserved properties, etc.
@@ -1645,7 +1638,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
 
                 // See if we have anything to do without waiting on the handles which is expensive 
                 // for kernel mode objects.
-                if (this.engineAbortCachedValue == true)
+                if (this.engineAbortCachedValue)
                 {
                     eventType = 0;
                 }
@@ -2025,7 +2018,6 @@ private void BuildProjectInternalContinue(BuildRequest buildRequest, ProjectBuil
             project.ContinueBuild(buildContext, taskExecutionContext);
         }
 
-
         private void IncrementProjectsInProgress()
         {
             Interlocked.Increment(ref this.numberOfProjectsInProgress);
@@ -2331,7 +2323,6 @@ string [] toolVersions
             {
                 buildEventContext = project.ProjectBuildEventContext;
             }
-
             else // Dont have an already instantiated project, need to make a new context
             {
                 buildEventContext = new BuildEventContext(
diff --git a/src/Deprecated/Engine/Engine/EngineCallback.cs b/src/Deprecated/Engine/Engine/EngineCallback.cs
index 694e30dba15..c1a136d831a 100644
--- a/src/Deprecated/Engine/Engine/EngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/EngineCallback.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
@@ -87,7 +86,7 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
             buildRequest.NodeIndex = executionContext.NodeIndex;
 
             ErrorUtilities.VerifyThrow(buildRequest.ParentBuildEventContext != null, "Should not have a null parentBuildEventContext");
-            ErrorUtilities.VerifyThrow(buildRequest.IsGeneratedRequest == true, "Should not be sending a non generated request from the child node to the parent node");
+            ErrorUtilities.VerifyThrow(buildRequest.IsGeneratedRequest, "Should not be sending a non generated request from the child node to the parent node");
 
             // For buildRequests originating from the TEM  - additional initialization is necessary
             TaskExecutionContext taskExecutionContext = executionContext as TaskExecutionContext;
@@ -136,8 +135,6 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
                         // project.  This allows people to avoid passing in the Projects parameter on the MSBuild task.
                         Project projectToBuild = parentProject;
 
-
-
                         // If the parent project (the calling project) already has the same set of global properties
                         // as what is being requested, just re-use it.  Otherwise, we need to instantiate a new
                         // project object that has the same project contents but different global properties.
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
index 15ad1514da1..2f2fdd10e50 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
@@ -616,7 +616,6 @@ virtual internal void LogWarningFromText(BuildEventContext buildEventContext, st
                 subcategory = AssemblyResources.GetString(subcategoryResourceName);
             }
 
-
             BuildWarningEventArgs e = new BuildWarningEventArgs
                 (
                     subcategory,
@@ -1013,7 +1012,6 @@ internal bool FlushBuildEventsImmediatly
         /// </summary>
         protected ManualResetEvent flushRequestEvent;
 
-
         internal const int flushTimeoutInMS = 500;          // flush the queue at least every 1/2 second
         internal const int flushTimeoutInTicks = 500*10000; // flush the queue at least every 1/2 second
         internal const int flushQueueSize = 1000;            // flush the queue every time 1000 events accumulate
diff --git a/src/Deprecated/Engine/Engine/EngineProxy.cs b/src/Deprecated/Engine/Engine/EngineProxy.cs
index a1934f5d9b3..c23c0772578 100644
--- a/src/Deprecated/Engine/Engine/EngineProxy.cs
+++ b/src/Deprecated/Engine/Engine/EngineProxy.cs
@@ -144,7 +144,7 @@ BuildEventContext buildEventContext
         public void LogErrorEvent(BuildErrorEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -213,7 +213,7 @@ public void LogErrorEvent(BuildErrorEventArgs e)
         public void LogWarningEvent(BuildWarningEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -290,7 +290,7 @@ private static string GetUpdatedMessage(string file, string message, string pare
         public void LogMessageEvent(BuildMessageEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -307,7 +307,7 @@ public void LogMessageEvent(BuildMessageEventArgs e)
         public void LogCustomEvent(CustomBuildEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -327,7 +327,7 @@ public bool ContinueOnError
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 return this.continueOnError;
             }
@@ -351,7 +351,7 @@ public int LineNumberOfTaskNode
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 ComputeProjectFileLocationOfTaskNode();
                 return this.lineNumber;
@@ -367,7 +367,7 @@ public int ColumnNumberOfTaskNode
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 ComputeProjectFileLocationOfTaskNode();
                 return this.columnNumber;
@@ -381,7 +381,7 @@ public string ProjectFileOfTaskNode
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 return projectFileOfTaskNode;
             }
@@ -439,7 +439,7 @@ string toolsVersion
         {
             lock (callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 // Wrap the project name into an array
                 string[] projectFileNames = new string[1];
@@ -527,7 +527,7 @@ bool returnTargetOutputs
         {
             lock (callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, "projectFileNames");
                 ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalPropertiesPerProject");
@@ -605,7 +605,6 @@ public override object InitializeLifetimeService()
             return lease;
         }
 
-
         /// <summary>
         /// Indicates to the EngineProxy that it is no longer needed.
         /// Called by TaskEngine when the task using the EngineProxy is done.
diff --git a/src/Deprecated/Engine/Engine/Expander.cs b/src/Deprecated/Engine/Engine/Expander.cs
index a61a6701a5b..e00a01136da 100644
--- a/src/Deprecated/Engine/Engine/Expander.cs
+++ b/src/Deprecated/Engine/Engine/Expander.cs
@@ -1460,7 +1460,6 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
                 return null;
             }
 
-
             /// <summary>
             /// Get the specified type from the assembly partial name supplied
             /// </summary>
@@ -1594,7 +1593,7 @@ private static Function ConstructFunction(string expressionFunction, string expr
             private static string[] ExtractFunctionArguments(string expressionFunction, string argumentsContent)
             {
                 List<string> arguments = new List<string>();
-                StringBuilder argumentBuilder = new StringBuilder(argumentsContent.Length); ;
+                StringBuilder argumentBuilder = new StringBuilder(argumentsContent.Length); 
 
                 // Iterate over the contents of the arguments extracting the
                 // the individual arguments as we go
diff --git a/src/Deprecated/Engine/Engine/ImportedProject.cs b/src/Deprecated/Engine/Engine/ImportedProject.cs
index 3d0b9922958..480cdf9b62a 100644
--- a/src/Deprecated/Engine/Engine/ImportedProject.cs
+++ b/src/Deprecated/Engine/Engine/ImportedProject.cs
@@ -15,7 +15,6 @@ namespace Microsoft.Build.BuildEngine
     /// <owner>SumedhK</owner>
     internal sealed class ImportedProject
     {
-
         /// <summary>
         /// Creates an instance of this class for the specified project file.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/Node.cs b/src/Deprecated/Engine/Engine/Node.cs
index a16f21d38e1..eda9b1f24d0 100644
--- a/src/Deprecated/Engine/Engine/Node.cs
+++ b/src/Deprecated/Engine/Engine/Node.cs
@@ -387,7 +387,6 @@ bool useBreadthFirstTraversal
                 localEngine.LoggingServices.OnlyLogCriticalEvents = this.logOnlyCriticalEvents;
                 localEngine.PostEngineCommand( new ChangeTraversalTypeCommand( useBreadthFirstTraversal, true ));
             }
-
         }
 
         /// <summary>
@@ -436,7 +435,6 @@ internal void ReportUnhandledError(Exception originalException)
             {
                 try
                 {
-
                     PostStatusThrow(nodeStatus, true /* wait for the message to be sent before returning */);
                 }
                 catch (Exception ex)
diff --git a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
index b200bda4f0b..d32de91db4e 100644
--- a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
+++ b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
@@ -269,7 +269,6 @@ internal virtual void CreateFromStream(BinaryReader reader, Hashtable loggingTyp
                             resolver = null;
                         }
                     }
-                
             }
         }
         #endregion
diff --git a/src/Deprecated/Engine/Engine/NodeManager.cs b/src/Deprecated/Engine/Engine/NodeManager.cs
index 68183335a46..fe60e2a2a1b 100644
--- a/src/Deprecated/Engine/Engine/NodeManager.cs
+++ b/src/Deprecated/Engine/Engine/NodeManager.cs
@@ -153,7 +153,6 @@ internal NodeStatus[] RequestStatusForNodes(int responseTimeout)
             return statusForNodes;
         }
 
-
         internal void PostNodeStatus(int nodeId, NodeStatus nodeStatus)
         {
             ErrorUtilities.VerifyThrow( nodeStatus.RequestId != NodeStatus.UnrequestedStatus,
@@ -174,7 +173,6 @@ internal void PostNodeStatus(int nodeId, NodeStatus nodeStatus)
             statusMessageReceived.Set();
         }
 
-
         internal void PostCycleNotification
         (
             int nodeId, 
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index aedc23f0f48..c8b953f45b2 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -381,7 +381,6 @@ string toolsVersion
                 this.mainProjectElement = mainProjectEntireContents.CreateElement(XMakeElements.project, XMakeAttributes.defaultXmlNamespace);
                 this.mainProjectEntireContents.AppendChild(mainProjectElement);
 
-
                 // initialize all case-insensitive hash-tables
                 this.conditionedPropertiesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
                 this.evaluatedItemsByName = new Hashtable(StringComparer.OrdinalIgnoreCase);
@@ -727,7 +726,6 @@ public bool IsValidated
             }
         }
 
-
         /// <summary>
         /// Is this project in the process of building?
         /// </summary>
@@ -1714,7 +1712,6 @@ private void SetProjectFileReservedProperties
 
                 this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.projectDirectoryNoRoot,
                     EscapingUtilities.Escape(projectDirectoryNoRoot), PropertyType.ReservedProperty));
-                
             }
 
             this.projectDirectory = this.ReservedProperties[ReservedPropertyNames.projectDirectory].FinalValue;
@@ -1827,7 +1824,6 @@ ProjectLoadSettings projectLoadSettings
                         // on <MSBuild> task tags, and what MSBuildToolsPath to use when scanning child projects
                         // for dependency information.
                         SolutionWrapperProject.Generate(sp, this, toolsVersion, buildEventContext);
-
                     }
                     else if (IsVCProjFilename(projectFileName))
                     {
@@ -1852,7 +1848,6 @@ ProjectLoadSettings projectLoadSettings
                         InternalLoadFromXmlDocument(projectDocument, projectLoadSettings);
                     }
 
-
                     // This project just came off the disk, so it is certainly not dirty yet.
                     this.dirtyNeedToSaveProjectFile = false;
                 }
@@ -2019,7 +2014,6 @@ ProjectLoadSettings projectLoadSettings
             }
         }
 
-
         /// <summary>
         /// Reads in the contents of this project from an in-memory XmlDocument handed to us.
         /// </summary>
@@ -2103,7 +2097,6 @@ private void InternalLoadFromXmlDocument(XmlDocument projectXml, ProjectLoadSett
                 }
                 throw;
             }
-
         }
 
         /// <summary>
@@ -2513,7 +2506,6 @@ PropertyPosition position
                         matchingPropertyGroup = this.AddNewPropertyGroup(afterImportPosition);
                         matchingPropertyGroup.Condition = condition;
                     }
-
                 }
 
                 if (importedProperty)
@@ -3374,7 +3366,6 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                             }
                         }
 
-
                         buildContext.CurrentBuildContextState = ProjectBuildState.BuildContextState.BuildComplete;
                     }
 
@@ -4037,7 +4028,6 @@ bool importedProject
             }
         }
 
-
         /// <summary>
         /// Process the &lt;Import&gt; element by loading the child project file, and processing its &lt;Project&gt; element. In a
         /// given main project, the same file cannot be imported twice -- this is to prevent circular imports.
@@ -4135,7 +4125,6 @@ bool        importedProject
                             ProjectErrorUtilities.VerifyThrowInvalidProject((importedChildNode.Prefix.Length == 0) && (String.Equals(importedChildNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase)),
                                 importedChildNode, "ProjectMustBeInMSBuildXmlNamespace", XMakeAttributes.defaultXmlNamespace);
 
-
                             // We have the <Project> element, so process it.
                             this.ProcessProjectAttributes((XmlElement)importedChildNode,
                                 /* imported project */ true);
@@ -4310,7 +4299,6 @@ private void EvaluateProject(bool currentlyLoading)
                     // on conditions to work correctly, and for wildcards to evaluate relative to the project directory.
                     Project.PerThreadProjectDirectory = this.ProjectDirectory;
 
-
                     // In case we've just loaded the project file, we don't want to repeat all
                     // of the work done during ProcessProjectChildren(...) to evaluate the
                     // properties.
diff --git a/src/Deprecated/Engine/Engine/Scheduler.cs b/src/Deprecated/Engine/Engine/Scheduler.cs
index f872023873d..32a7cf4770b 100644
--- a/src/Deprecated/Engine/Engine/Scheduler.cs
+++ b/src/Deprecated/Engine/Engine/Scheduler.cs
@@ -100,7 +100,6 @@ internal int CalculateNodeForBuildRequest(BuildRequest currentRequest, int nodeI
                 // If we have not chosen an node yet, this can happen if the node was loaded previously on a child node
                 if (nodeUsed == EngineCallback.invalidNode)
                 {
-                    
                     if (useLoadBalancing)
                     {
                         #region UseLoadBalancing
@@ -283,7 +282,6 @@ internal void NotifyOfBuildResult(int nodeId, BuildResult buildResult)
                 // Dump some interesting information to the console if profile build is turned on by an environment variable
                 if (parentEngine.ProfileBuild && scheduleRecord != null && buildResult.TaskTime != 0 )
                 {
-
                     Console.WriteLine("N " + scheduleRecord.EvaluationNode + " Name " + scheduleRecord.ProjectName + ":" +
                                       scheduleRecord.ParentKey.HandleId + ":" + scheduleRecord.ParentKey.RequestId + 
                                       " Total " + buildResult.TotalTime + " Engine " + buildResult.EngineTime + " Task " + buildResult.TaskTime);
@@ -302,7 +300,7 @@ internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, i
             if (totalRequestsPerNode != null)
             {
                 // Check if it makes sense to switch from one traversal strategy to the other
-                if (parentEngine.NodeManager.TaskExecutionModule.UseBreadthFirstTraversal == true)
+                if (parentEngine.NodeManager.TaskExecutionModule.UseBreadthFirstTraversal)
                 {
                     // Check if a switch to depth first traversal is in order
                     bool useBreadthFirstTraversal = false;
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index 2678ee21234..29adb5a61c2 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -492,7 +492,6 @@ internal BuildState TargetBuildState
             }
         }
 
-
         internal TargetExecutionWrapper ExecutionState
         {
             get
diff --git a/src/Deprecated/Engine/Engine/TargetCollection.cs b/src/Deprecated/Engine/Engine/TargetCollection.cs
index ed38ed7f986..3b84e76f220 100644
--- a/src/Deprecated/Engine/Engine/TargetCollection.cs
+++ b/src/Deprecated/Engine/Engine/TargetCollection.cs
@@ -159,7 +159,6 @@ public IEnumerator GetEnumerator
             return this.targetTable.Values.GetEnumerator();
         }
 
-
         /// <summary>
         /// Adds a new Target to our collection.  This method does nothing
         /// to manipulate the project's XML content.
diff --git a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
index 377fe8f63ad..548448a827f 100644
--- a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
+++ b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
@@ -609,7 +609,6 @@ out Hashtable upToDateTargetInputs
 
                             for (int i = 0; i < inputItemsAssumedToBeUpToDate.Length; i++)
                             {
-
                                 // if we haven't already determined that this input item has changed
                                 if (inputItemsAssumedToBeUpToDate[i] != null)
                                 {
@@ -720,7 +719,6 @@ ArrayList targetOutputItemSpecs
                     loggingService.LogComment(buildEventContext, "BuildTargetCompletely", this.targetToAnalyze.Name);
                     loggingService.LogComment(buildEventContext, "BuildTargetCompletelyNoInputsSpecified");
 
-
                     // otherwise, do a full build
                     result = DependencyAnalysisResult.FullBuild;
                 }
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index 07229437bd5..481270209ea 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -665,7 +665,6 @@ private bool InitializeTaskParameters(ITask task, ItemBucket bucket)
             return taskInitialized;
         }
 
-
         /// <summary>
         /// Finds all the task properties that are required.
         /// Returns them as keys in a dictionary.
@@ -985,7 +984,6 @@ internal bool GatherGeneratedTaskOutputs
             return gatheredGeneratedOutputsSuccessfully;
         }
 
-
         private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutputSpecification, string itemName, string propertyName, PropertyInfo parameter, object outputs)
         {
             // if the task has generated outputs (if it didn't, don't do anything)
@@ -1224,7 +1222,6 @@ private List<TaskOutput> GetTaskOutputSpecifications(bool showWarnings)
             return taskOutputSpecifications;
         }
 
-
         /// <summary>
         /// Given an instantiated task, this helper method sets the specified parameter based on its type.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
index 9c1c984d50c..29ef370c0c2 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
@@ -226,7 +226,7 @@ BuildEventContext taskContext
 
                 buildRequests[i] = new BuildRequest(handleId, fullProjectName, targetNames, globalPropertiesPerProject[i],
                                                     toolsVersions[i], i, useResultsCache, unloadProjectsOnCompletion);
-                ErrorUtilities.VerifyThrow(buildRequests[i].IsGeneratedRequest == true, "Should not be sending non generated requests from TEM to engine");
+                ErrorUtilities.VerifyThrow(buildRequests[i].IsGeneratedRequest, "Should not be sending non generated requests from TEM to engine");
                 buildRequests[i].ParentBuildEventContext = taskContext;
             }
 
@@ -310,7 +310,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
         {
             // If the traversal strategy is breadth first and the number of requests is less than the batchRequestSize
             // or if there is only 1 build request then send ALL build requests to the parent engine and wait on the results.
-            if ((breadthFirstTraversal == true && buildRequests.Length < batchRequestSize) || buildRequests.Length == 1)
+            if ((breadthFirstTraversal && buildRequests.Length < batchRequestSize) || buildRequests.Length == 1)
             {
                 engineCallback.PostBuildRequestsToHost(buildRequests);
                 workerThread.WaitForResults(handleId, buildResultsLocal, buildRequests);
@@ -332,7 +332,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
                 while (currentRequestIndex < buildRequests.Length)
                 {
                     // If there is a breadth first traversal and there are more than batchRequestSize build requests, send the first batchRequestSize, then do the rest depth first
-                    if (breadthFirstTraversal == true)
+                    if (breadthFirstTraversal)
                     {
                         // Figure out how many requests to send, either the full batch size or only part of a batch
                         numberOfRequestsToSend = (buildRequests.Length - currentRequestIndex) <batchRequestSize ? (buildRequests.Length - currentRequestIndex) : batchRequestSize;
diff --git a/src/Deprecated/Engine/Engine/TaskRegistry.cs b/src/Deprecated/Engine/Engine/TaskRegistry.cs
index 69e52ef45ae..588c848c5b0 100644
--- a/src/Deprecated/Engine/Engine/TaskRegistry.cs
+++ b/src/Deprecated/Engine/Engine/TaskRegistry.cs
@@ -331,7 +331,6 @@ public void RegisterTask(UsingTask usingTask, Expander expander, EngineLoggingSe
                             "InvalidAttributeValueWithException", assemblyFile,
                             XMakeAttributes.assemblyFile, XMakeElements.usingTask, ex.Message);
                     }
-
                 }
 
                 AssemblyLoadInfo taskAssembly = new AssemblyLoadInfo(assemblyName, assemblyFile);
diff --git a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
index 4be9db73912..a804c1bfb93 100644
--- a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
+++ b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
@@ -313,7 +313,6 @@ private void NodeActionLoop
             BuildResult [] buildResults
         )
         {
-
             // Create an array of event to the node thread responds
             WaitHandle[] waitHandles = GetHandlesArray(executionMode);
 
diff --git a/src/Deprecated/Engine/Engine/ToolsetState.cs b/src/Deprecated/Engine/Engine/ToolsetState.cs
index 9a05b5a3dfe..9febd3edfea 100644
--- a/src/Deprecated/Engine/Engine/ToolsetState.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetState.cs
@@ -109,7 +109,6 @@ internal BuildPropertyGroup BuildProperties
             }
         }
 
-
         #endregion
 
         #region Methods
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index 54447515463..83f0e1772ee 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -94,7 +94,7 @@ bool initializationException
             : base(message, innerException)
         {
             ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
-            ErrorUtilities.VerifyThrow(innerException != null || initializationException == true, "Need the logger exception.");
+            ErrorUtilities.VerifyThrow(innerException != null || initializationException, "Need the logger exception.");
             ErrorUtilities.VerifyThrow((errorCode != null) && (errorCode.Length > 0), "Must specify the error message code.");
             ErrorUtilities.VerifyThrow((helpKeyword != null) && (helpKeyword.Length > 0), "Must specify the help keyword for the IDE.");
 
diff --git a/src/Deprecated/Engine/Introspector/Introspector.cs b/src/Deprecated/Engine/Introspector/Introspector.cs
index a829277fe83..1946f84a967 100644
--- a/src/Deprecated/Engine/Introspector/Introspector.cs
+++ b/src/Deprecated/Engine/Introspector/Introspector.cs
@@ -214,7 +214,6 @@ private void LogOrDumpError(string resourceName, params object[] args)
         /// </summary>
         private void AddTargetStatesToCycleDetector(NodeStatus[] nodeStatus, TargetCycleDetector cycleDetector)
         {
-
             for (int i = 0; i < nodeStatus.Length; i++)
             {
                cycleDetector.AddTargetsToGraph(nodeStatus[i].StateOfInProgressTargets);
@@ -230,7 +229,6 @@ private void GatherNodeInformationForShutdown(NodeStatus[] nodeStatus, NodeStatu
         {
             for (int i = 0; i < nodeStatus.Length; i++)
             {
-
                 TimeSpan timeSinceLastNodeTaskActivity = new TimeSpan(nodeStatus[i].TimeSinceLastTaskActivity);
                 TimeSpan timeSinceLastNodeLoopActivity = new TimeSpan(nodeStatus[i].TimeSinceLastLoopActivity);
  
@@ -253,7 +251,6 @@ private void GatherNodeInformationForShutdown(NodeStatus[] nodeStatus, NodeStatu
             }
 
             parentEngine.Scheduler.DumpState();
-
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
index a22fc5d11e8..a1277f31c80 100644
--- a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
+++ b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
@@ -138,7 +137,7 @@ internal bool FindCycles()
             // First try to perform the traversal from the roots (i.e nodes that are due to host requests)
             foreach (GraphNode node in dependencyGraph.Values)
             {
-                if (node.isRoot == true && node.traversalIndex == GraphNode.InvalidIndex)
+                if (node.isRoot && node.traversalIndex == GraphNode.InvalidIndex)
                 {
                     BreadthFirstTraversal(node);
                 }
diff --git a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
index 16ff5d488d6..3eb1fe9994a 100644
--- a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
+++ b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
@@ -254,7 +254,6 @@ out BuildRequest parentTriggeringRequest
             return null;
         }
 
-
         /// <summary>
         /// This function checks if the given ProjectBuildState is caused by a given parent target (via
         /// a dependency, onerror or IBuildEngine relationship)
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index 61259dd6489..703ebfa0563 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -1196,7 +1196,6 @@ BuildEventContext buildEventContext
 
                         // Add this metadata to the running table we're using, so that one piece of metadata can refer to another one above
                         expander.SetMetadataInMetadataTable(name, metadataElement.Name, evaluatedMetadataValue);
-
                     }
                 }
             }
diff --git a/src/Deprecated/Engine/Items/TaskItem.cs b/src/Deprecated/Engine/Items/TaskItem.cs
index afc43738a54..f30bd4b4077 100644
--- a/src/Deprecated/Engine/Items/TaskItem.cs
+++ b/src/Deprecated/Engine/Items/TaskItem.cs
@@ -12,7 +12,6 @@
 
 namespace Microsoft.Build.BuildEngine
 {
-
     /// <summary>
     /// This class wraps a project item, and provides a "view" on the item's BuildItem class that is suitable to expose to tasks.
     /// </summary>
@@ -98,7 +97,6 @@ public int MetadataCount
             }
         }
 
-
         /// <summary>
         /// Gets the names of custom metadata on the item
         /// </summary>
@@ -201,7 +199,6 @@ ITaskItem destinationItem
             }
         }
 
-
         /// <summary>
         /// Get the collection of metadata. This does not include built-in metadata.
         /// </summary>
diff --git a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
index 30fb00eb92b..670029293b2 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
@@ -61,7 +61,6 @@ namespace Microsoft.Build.BuildEngine
     /// </remarks>
     internal class Lookup
     {
-
         #region Fields
 
         /// <summary>
diff --git a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
index 0a1d5607bcc..689bbaaab8e 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
@@ -954,7 +954,6 @@ internal class LocalCallDescriptorForRequestStatus : LocalCallDescriptor
         #region Constructors
         internal LocalCallDescriptorForRequestStatus()
         {
-
         }
 
         internal LocalCallDescriptorForRequestStatus(int requestId)
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index 4b071b8da18..893cb321877 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -131,13 +131,11 @@ void StartCommunicationThreads()
             ErrorUtilities.VerifyThrow(this.sharedMemory.IsUsable,
                 "Failed to create shared memory for local node input.");
 
-
             // Start the thread that will be processing the calls from the parent engine
             ThreadStart threadState = new ThreadStart(this.SharedMemoryReaderThread);
             readerThread = new Thread(threadState);
             readerThread.Name = "MSBuild Child<-Parent Reader";
             readerThread.Start();
-            
         }
 
         /// <summary>
@@ -280,7 +278,7 @@ public static void StartLocalNodeServer(int nodeNumber)
                     waitHandlesActive[2] = notInUseEvent;
 
                     eventType = WaitHandle.WaitTimeout;
-                    while (eventType == WaitHandle.WaitTimeout && continueRunning == true)
+                    while (eventType == WaitHandle.WaitTimeout && continueRunning)
                     {
                         eventType = WaitHandle.WaitAny(waitHandlesActive, parentCheckInterval, false);
 
@@ -495,7 +493,6 @@ string parentStartupDirectory
             // Host the msbuild engine and system
             node = new Node(nodeId, nodeLoggers, engineCallback, parentGlobalProperties, toolsetSearchLocations, parentStartupDirectory);
 
-
             // Write the initialization complete event out directly
             LocalCallDescriptorForInitializationComplete callDescriptor =
                 new LocalCallDescriptorForInitializationComplete(Process.GetCurrentProcess().Id);
@@ -562,7 +559,6 @@ internal void ReportFatalCommunicationError(Exception originalException)
         /// <param name="originalException"></param>
         internal void ReportNonFatalCommunicationError(Exception originalException)
         {
-             
             if (node != null)
             {
                 try
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
index ba2972020e4..8d634635004 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
@@ -232,7 +232,6 @@ private void ReserveNextAvailableNodeNumber(int currentNodeNumber)
                         nodeReserveHandle = null;
                         currentNodeNumber++;
                     }
-
                 }
             }
         }
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
index 5476d2f93f2..f184f45ee0c 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
@@ -46,7 +46,6 @@ string startupDirectory
                 // Go through each of the parameter name value pairs and split them appart
                 for (int param = 0; param < parameters.Length; param++)
                 {
-
                     if (parameters[param].Length > 0)
                     {
                         string[] parameterComponents = parameters[param].Split(valueDelimiters);
@@ -130,7 +129,6 @@ public void ApplyParameter(string parameterName, string parameterValue)
                  try
                 {
                     this.cpuCount = Convert.ToInt32(parameterValue, CultureInfo.InvariantCulture);
-
                 }
                 catch (FormatException)
                 {
@@ -170,7 +168,6 @@ public void ApplyParameter(string parameterName, string parameterValue)
             }
         }
 
-
         public INodeDescription[] QueryNodeDescriptions()
         {
             return new INodeDescription[cpuCount-1];
@@ -383,7 +380,6 @@ bool useBreadthFirstTraversalSetting
                     UpdateSettings(i);
                 }
             }
-
         }
 
         private void UpdateSettings(int nodeIndex)
@@ -394,7 +390,6 @@ private void UpdateSettings(int nodeIndex)
             nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor);
         }
 
-
         public void PostIntrospectorCommand(int nodeIndex, TargetInProgessState child, TargetInProgessState parent)
         {
             // Send the updated settings once the node has initialized
@@ -457,7 +452,6 @@ private void TerminateChildNode(int processId)
         {
             try
             {
-
                 if (!Process.GetProcessById(processId).HasExited)
                 {
                     Process.GetProcessById(processId).Kill();
@@ -480,14 +474,13 @@ private void TerminateChildNode(int processId)
         private bool IsNodeProcessAliveOrUninitialized(int nodeId)
         {
             // If it's alive but not being communicated with anymore, that counts as not alive
-            if (nodeData[nodeId].CommunicationFailed == true)
+            if (nodeData[nodeId].CommunicationFailed)
             {
                 return false;
             }
             
             try
             {
- 
 
                 bool isUninitialized = nodeData[nodeId].ProcessId == LocalNodeInfo.unInitializedProcessId;
 
@@ -502,7 +495,6 @@ private bool IsNodeProcessAliveOrUninitialized(int nodeId)
                 {
                     return true;
                 }
-
            }
             catch (ArgumentException)
             {
@@ -812,7 +804,6 @@ private void LaunchNode(int nodeIndex)
                 {
                     exitedDueToError = false;
                 }
-
             }
             finally
             {
@@ -1003,7 +994,6 @@ private void SharedMemoryReaderThread()
         private int activeNodeCount;
         private int responseCount;
 
-
         private int cpuCount;
 
         private object nodeStateLock;
diff --git a/src/Deprecated/Engine/LocalProvider/NativeMethods.cs b/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
index 79783bfc6f2..c9a573e2814 100644
--- a/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
+++ b/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
@@ -92,7 +92,6 @@ internal static bool IsUserAdministrator()
             }
 
             return bRet;
-            
         }
 
         [DllImport("advapi32.dll", SetLastError = true)]
diff --git a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
index a5df97442c7..6c9d72ce068 100644
--- a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
+++ b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
@@ -255,7 +255,6 @@ private void InitializeStreams(SharedMemoryType streamType)
                 this.readStream = new MemoryStream(this.readBuffer);
                 this.binaryReader = new BinaryReader(this.readStream);
                 readLock = new object();
-
             }
             else if (streamType == SharedMemoryType.WriteOnly)
             {
@@ -267,7 +266,6 @@ private void InitializeStreams(SharedMemoryType streamType)
             {
                 ErrorUtilities.VerifyThrow(false, "Unknown shared memory type.");
             }
-
         }
 
         /// <summary>
@@ -328,13 +326,11 @@ protected virtual void Dispose(bool disposing)
             }
         }
 
-
         public void Dispose()
         {
             Dispose(true);
         }
 
-
         ~SharedMemory()
         {
             Dispose();
@@ -450,10 +446,10 @@ private void DecrementUnreadBatchCounter()
         }
 
         /// <summary>
-        /// This function write out a set of objects into the the shared buffer.
+        /// This function write out a set of objects into the shared buffer.
         /// In normal operation all the objects in the queue are serialized into
         /// the buffer followed by an end marker class. If the buffer is not big
-        /// enough to contain a single object the object is broken into into 
+        /// enough to contain a single object the object is broken into 
         /// multiple buffers as follows - first a frame marker is sent containing
         /// the size of the serialized object + size of end marker. The reader makes
         /// sure upon receiving the frame marker that its buffer is large enough 
diff --git a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
index eb841f4102b..c47dd3acf2b 100644
--- a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
@@ -566,7 +566,6 @@ internal SortedList ExtractItemList(IEnumerable items)
             return itemTypes;
         }
 
-
         internal virtual void OutputItems(string itemType, ArrayList itemTypeList)
         {
             // Write each item, one per line
@@ -590,7 +589,6 @@ internal virtual void OutputItems(string itemType, ArrayList itemTypeList)
             resetColor();
         }
 
-
         /// <summary>
         /// Returns a performance counter for a given scope (either task name or target name)
         /// from the given table.
@@ -719,7 +717,6 @@ internal  bool InScope
                             inScope = false;
 
                             elapsedTime += (System.DateTime.Now - scopeStartTime);
-
                         }
                         else if (!InScope && value)
                         {
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index bfa0c06f2e2..c6fceb7e57d 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -54,7 +54,6 @@ public class ConsoleLogger : INodeLogger
         private bool skipProjectStartedText = false;
         private bool? showSummary;
 
-
         #region Constructors
 
         /// <summary>
@@ -255,7 +254,6 @@ public bool ShowSummary
                 else
                 {
                     consoleLogger.ShowSummary = value;
-
                 }
             }
         }
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index d9c2240c7ac..5d4231797e6 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
@@ -191,7 +190,6 @@ public void Initialize(IEventSource eventSource, int nodeCount)
 
         private void SetForwardingBasedOnVerbosity()
         {
-
             forwardingTable[BuildStartedEventDescription] = 0;
             forwardingTable[BuildFinishedEventDescription] = 0;
 
@@ -254,7 +252,6 @@ private void SetForwardingBasedOnVerbosity()
             }
         }
 
-
         /// <summary>
         /// Reset the states of per-build member variables.
         /// Used when a build is finished, but the logger might be needed for the next build.
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index ad7f18d613f..b097b3a5bf3 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -112,7 +112,6 @@ public void Initialize(IEventSource eventSource)
             }
             catch (ArgumentException e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
-
                 if(nodeFileLogger != null)
                 {
                     nodeFileLogger.Shutdown();
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index 80c7e610897..0da754e4bfe 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -263,7 +263,6 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
         /// </summary>
         private static readonly char[] fileLoggerParameterValueSplitCharacter = { '=' };
 
-
         #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Logging/LoggerDescription.cs b/src/Deprecated/Engine/Logging/LoggerDescription.cs
index b505e646692..5ba629eaa17 100644
--- a/src/Deprecated/Engine/Logging/LoggerDescription.cs
+++ b/src/Deprecated/Engine/Logging/LoggerDescription.cs
@@ -332,7 +332,6 @@ internal void CreateFromStream(BinaryReader reader)
             }
             else
             {
-
                 string assemblyName = null;
                 string assemblyFile = null;
 
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 26b7ec11e11..24c98925566 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -376,7 +376,6 @@ private void ShowErrorWarningSummary<T>(ArrayList listToProcess) where T : Build
             // Loop through each of the warnings and put them into the correct buckets
             for (int listCount = 0; listCount < listToProcess.Count; listCount++)
             {
-
                 T errorWarningEventArgs = (T)listToProcess[listCount];
 
                 // Target event may be null for a couple of reasons:
@@ -1509,7 +1508,6 @@ internal void AddEventStarted(string projectTargetNames, BuildEventContext build
             /// </summary>
             internal void AddEventFinished(string projectTargetNames, BuildEventContext buildEventContext, DateTime eventTimeStamp)
             {
-
                 if (!string.IsNullOrEmpty(projectTargetNames))
                 {
                     MPPerformanceCounter entryPoint = GetPerformanceCounter(projectTargetNames, ref internalPerformanceCounters);
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 6adfe144867..b3f67fc1599 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -513,7 +513,6 @@ internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent)
             this.errorInTarget = false;
             this.buildEventContext = startedEvent.BuildEventContext;
             this.timeStamp = startedEvent.Timestamp;
-
         }
         #endregion
     }
@@ -657,7 +656,6 @@ public override bool Equals(object obj)
             ProjectFullKey compareKey = obj as ProjectFullKey;
             if (compareKey != null)
             {
-                
                 return ((compareKey.projectKey == this.projectKey) && (compareKey.entryPointKey == this.entryPointKey));
             }
             else
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index 8df12eb6d03..c0577714a4b 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -239,7 +239,6 @@ PropertyType propertyType
             this.propertyValue = propertyValue;
             this.finalValueEscaped = propertyValue;
             this.type = propertyType;
-
         }
 
         /// <summary>
@@ -306,7 +305,6 @@ PropertyType propertyType
 
             // Assign the property type.
             this.type = propertyType;
-
         }
 
         /// <summary>
@@ -633,7 +631,7 @@ private void MarkPropertyAsDirty
             {
                 ErrorUtilities.VerifyThrow(this.ParentPersistedPropertyGroup.ParentProject != null, "Persisted BuildPropertyGroup doesn't have parent project.");
                 this.ParentPersistedPropertyGroup.MarkPropertyGroupAsDirty();
-            };
+            }
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index 926104ed077..1df6f8937ad 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -1128,7 +1128,6 @@ internal void EnsureNoReservedProperties()
                 // Make sure this property doesn't override a reserved property
                 ProjectErrorUtilities.VerifyThrowInvalidProject(this.ParentProject.ReservedProperties[property.Name] == null,
                     property.PropertyElement, "CannotModifyReservedProperty", property.Name);
-
             }
         }
 
@@ -1277,7 +1276,7 @@ internal void MarkPropertyGroupAsDirty
                     // example, if a global property changes....
                     this.ParentProject.MarkProjectAsDirtyForReevaluation();
                 }
-            };
+            }
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index 399e9943f1a..dd92e681f9b 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -123,7 +123,6 @@ internal string Name
             }
         }
 
-
         /// <summary>
         /// The assembly's version number.
         /// </summary>
@@ -226,7 +225,6 @@ internal static AssemblyNameExtension UnnamedAssembly
         /// <returns></returns>
         internal int CompareTo(AssemblyNameExtension that)
         {
-
             // Are they identical?
             if (this.Equals(that))
             {
diff --git a/src/Deprecated/Engine/Shared/EscapingUtilities.cs b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
index 3baf1c1d815..998f7579669 100644
--- a/src/Deprecated/Engine/Shared/EscapingUtilities.cs
+++ b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
@@ -101,7 +101,7 @@ out bool escapingWasNecessary
         }
 
         /// <summary>
-        /// Adds instances of %XX in the input string where the char char to be escaped appears
+        /// Adds instances of %XX in the input string where the char to be escaped appears
         /// XX is the hex value of the ASCII code for the char.
         /// </summary>
         /// <param name="unescapedString"></param>
diff --git a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
index 4a86b11903b..53269f5305a 100644
--- a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
+++ b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
@@ -236,7 +236,6 @@ int threadId
             return formattedMessage.ToString();
         }
 
-
         /// <summary>
         /// Splits strings on 'newLines' with tolerance for Everett and Dogfood builds.
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/FileMatcher.cs b/src/Deprecated/Engine/Shared/FileMatcher.cs
index 14872e95a16..d62a375e52d 100644
--- a/src/Deprecated/Engine/Shared/FileMatcher.cs
+++ b/src/Deprecated/Engine/Shared/FileMatcher.cs
@@ -56,7 +56,6 @@ internal enum FileSystemEntity
         /// <returns>True if the directory exists.</returns>
         internal delegate bool DirectoryExists(string path);
 
-
         /// <summary>
         /// Determines whether the given path has any wild card characters.
         /// </summary>
@@ -253,7 +252,6 @@ internal static string GetLongPathName
             GetFileSystemEntries getFileSystemEntries
         )
         {
-
             if (path.IndexOf("~", StringComparison.Ordinal) == -1)
             {
                 // A path with no '~' must not be a short name.
@@ -308,7 +306,6 @@ GetFileSystemEntries getFileSystemEntries
                 }
                 else
                 {
-
                     if (parts[i].IndexOf("~", StringComparison.Ordinal) == -1)
                     {
                         // If there's no ~, don't hit the disk.
@@ -841,7 +838,6 @@ out bool isLegalFileSpec
 
             } while (matchFileExpression.Length < sizeBefore);
 
-
             /*
              * By definition, "**" must appear alone between directory slashes. If there is any remaining "**" then this is not
              * a valid filespec.
@@ -902,8 +898,6 @@ out bool isLegalFileSpec
             return matchFileExpression.ToString();
         }
 
-
-
         /// <summary>
         /// Given a filespec, get the information needed for file matching. 
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/FileUtilities.cs b/src/Deprecated/Engine/Shared/FileUtilities.cs
index 54c91248e62..4c088e00f9a 100644
--- a/src/Deprecated/Engine/Shared/FileUtilities.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilities.cs
@@ -12,7 +12,6 @@
 using System.Threading;
 using System.Runtime.InteropServices;
 
-
 namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
@@ -97,7 +96,6 @@ internal static bool IsItemSpecModifier(string name)
                 return false;
             }
 
-
             /* 
              * What follows requires some explanation.
              * 
diff --git a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
index 238f303656d..c0dd2160409 100644
--- a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
+++ b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
@@ -64,7 +64,6 @@ internal static class FrameworkLocationHelper
         internal const string fullDotNetFrameworkSdkRegistryKeyV40 = "HKEY_LOCAL_MACHINE\\" + dotNetFrameworkSdkRegistryPathV40;
         internal const string dotNetFrameworkSdkInstallKeyValueV40 = "InstallationFolder";
 
-
         private const string dotNetFrameworkAssemblyFoldersRegistryKeyV40 = dotNetFrameworkAssemblyFoldersRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV40;
         private const string secondaryDotNetFrameworkSdkRegistryPathV40 = "SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows";
         internal const string secondaryDotNetFrameworkSdkInstallKeyValueV40 = "CurrentInstallFolder";
@@ -85,7 +84,6 @@ internal static string PathToDotNetFrameworkV11
                     }
                     else
                     {
-
                         FrameworkLocationHelper.pathToDotNetFrameworkV11 =
                             FindDotNetFrameworkPath(
                                 Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName),
@@ -113,7 +111,6 @@ internal static string PathToDotNetFrameworkV20
                     }
                     else
                     {
-
                         FrameworkLocationHelper.pathToDotNetFrameworkV20 =
                             FindDotNetFrameworkPath(
                                 Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName),
@@ -141,7 +138,6 @@ internal static string PathToDotNetFrameworkV30
                     }
                     else
                     {
-
                         FrameworkLocationHelper.pathToDotNetFrameworkV30 =
                             FindDotNetFrameworkPath(
                                 Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName),
@@ -269,7 +265,6 @@ internal static string PathToDotNetFrameworkSdkV35
                             secondaryDotNetFrameworkSdkRegistryPathV35,
                             secondaryDotNetFrameworkSdkInstallKeyValueV35);
                     }
-
                 }
 
                 return FrameworkLocationHelper.pathToDotNetFrameworkSdkV35;
@@ -302,7 +297,6 @@ internal static string PathToDotNetFrameworkSdkV40
                             secondaryDotNetFrameworkSdkRegistryPathV40,
                             secondaryDotNetFrameworkSdkInstallKeyValueV40);
                     }
-
                 }
 
                 return FrameworkLocationHelper.pathToDotNetFrameworkSdkV40;
@@ -347,7 +341,6 @@ internal static string PathToDotNetFrameworkReferenceAssembliesV35
                     {
                         FrameworkLocationHelper.pathToDotNetFrameworkReferenceAssembliesV35 = GenerateReferenceAssemblyDirectory(dotNetFrameworkVersionFolderPrefixV35);
                     }
-
                 }
 
                 return FrameworkLocationHelper.pathToDotNetFrameworkReferenceAssembliesV35;
diff --git a/src/Deprecated/Engine/Shared/LoadedType.cs b/src/Deprecated/Engine/Shared/LoadedType.cs
index 47ec35d0174..6cbb2758453 100644
--- a/src/Deprecated/Engine/Shared/LoadedType.cs
+++ b/src/Deprecated/Engine/Shared/LoadedType.cs
@@ -205,6 +205,5 @@ internal AssemblyLoadInfo Assembly
 
         // whether the loadinseparateappdomain attribute is applied to this type
         private bool? hasLoadInSeparateAppDomainAttribute;
-
     }
 }
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 580f04487fb..06dbe0187e1 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -412,7 +412,6 @@ internal void ParseSolution()
                 // Update the hash table with this unique name
                 projectsByUniqueName[uniqueName] = proj;
             }
-
         } // ParseSolutionFile()
 
         /// <summary>
@@ -501,7 +500,6 @@ private void ValidateSolutionFileVersion(string versionString)
                 "SolutionParseVersionMismatchError", 
                 slnFileMinUpgradableVersion, slnFileMaxVersion);
 
-
             // If the solution file version is greater than the maximum one we will create a comment rather than warn
             // as users such as blend opening a dev10 project cannot do anything about it.
             if (this.slnFileActualVersion > slnFileMaxVersion)
@@ -1337,5 +1335,4 @@ internal string GetProjectRelativePathByGuid(string projectGuid)
 
         #endregion
     } // class SolutionParser
-
 } // namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Shared/XMakeAttributes.cs b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
index 20d4549d567..dd34b370cb4 100644
--- a/src/Deprecated/Engine/Shared/XMakeAttributes.cs
+++ b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
@@ -80,7 +80,6 @@ string attribute
                     (attribute == msbuildRuntime) ||
                     (attribute == msbuildArchitecture) ||
                     (attribute == xmlns));
-
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Shared/XMakeElements.cs b/src/Deprecated/Engine/Shared/XMakeElements.cs
index 23040d39c4e..5c886fe01d3 100644
--- a/src/Deprecated/Engine/Shared/XMakeElements.cs
+++ b/src/Deprecated/Engine/Shared/XMakeElements.cs
@@ -97,5 +97,4 @@ internal static Hashtable IllegalItemPropertyNames
             }
         }
     }
-
 }
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index d471956ec0a..36e07bd2cb8 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -104,7 +104,6 @@ static internal void Generate(SolutionParser solution, Project msbuildProject, s
 
             // Write a new cache file, hopefully we can use it next time
             UpdateCache(parentEngine, msbuildProject, solutionProjectCache, projectBuildEventContext);
-
         }
 
         /// <summary>
@@ -743,7 +742,6 @@ out string addedReferenceGuids
 
                         referenceGuids.Append(projectReferenceGuid);
                         addCreateItem = true;
-
                     }
                     else if (referencedProject.ProjectType == SolutionProjectType.VCProject)
                     {
@@ -867,7 +865,6 @@ string projectConfigurationName
                     proj.RelativePath, e.Message);
             }
 
-
             // Create the temporary VC project
             BuildTask createVCProjectTask = target.AddNewTask("CreateTemporaryVCProject");
             createVCProjectTask.SetParameterValue("ProjectFile", fullProjectPath, true /* treat as literal */);
@@ -2277,7 +2274,7 @@ static private void AssignDependencyLevels(SolutionParser solution, Dictionary<i
 
         /// <summary>
         /// Add virtual references for reference chains containing VC static library projects. 
-        /// Since static libraries have no link step, any references they have have to be passed
+        /// Since static libraries have no link step, any references they have to be passed
         /// to their parent project, if any. So for example, in a chain like
         /// native dll -> native static lib1 -> native static lib2
         /// we need to add a virtual reference between the native dll and the static lib2 
diff --git a/src/Deprecated/Engine/Solution/VCWrapperProject.cs b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
index 2bb2aefb038..427a6563474 100644
--- a/src/Deprecated/Engine/Solution/VCWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
@@ -228,7 +228,6 @@ static internal string VCBuildLocationHint
         /// <summary>
         /// constants for VS9 Pro and above SKUs
         /// </summary>
-
         // root registry key for VS9
         private const string vs9RegKey = @"SOFTWARE\Microsoft\VisualStudio\9.0";
         // the name of the value containing disk install directory for the IDE components 
@@ -242,7 +241,6 @@ static internal string VCBuildLocationHint
         /// <summary>
         /// constants for the VC9 Express SKU
         /// </summary>
-
         // root registry key for VC9
         private const string vc9RegKey = @"SOFTWARE\Microsoft\VCExpress\9.0";
         // the name of the value containing disk install directory for the IDE components 
diff --git a/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs b/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
index e496b4a57f8..f53abbf2461 100644
--- a/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
+++ b/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
@@ -38,7 +38,6 @@ internal BuildItemGroupChildXml(XmlDocument ownerDocument, string name, string i
         {
             this.element = ownerDocument.CreateElement(name, XMakeAttributes.defaultXmlNamespace);
             this.Include = include;
-
         }
 
         internal BuildItemGroupChildXml(XmlElement element, ChildType childTypeExpected)
@@ -362,5 +361,4 @@ internal enum ChildType
         /// </summary>
         Any = BuildItemAdd | BuildItemRemove | BuildItemModify
     }
-
 }
diff --git a/src/Framework.UnitTests/Attribute_Tests.cs b/src/Framework.UnitTests/Attribute_Tests.cs
index 448d3a9aa3e..e94e9d66173 100644
--- a/src/Framework.UnitTests/Attribute_Tests.cs
+++ b/src/Framework.UnitTests/Attribute_Tests.cs
@@ -18,7 +18,6 @@ public class AttributeTests
         [Fact]
         public void RequiredRuntimeAttribute()
         {
-
             RequiredRuntimeAttribute attribute =
                 typeof(X).GetTypeInfo().GetCustomAttribute<RequiredRuntimeAttribute>();
 
diff --git a/src/Framework/IProjectElement.cs b/src/Framework/IProjectElement.cs
index a5eea6df205..9c2dff5336f 100644
--- a/src/Framework/IProjectElement.cs
+++ b/src/Framework/IProjectElement.cs
@@ -8,7 +8,6 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public interface IProjectElement
     {
-
         /// <summary>
         /// Gets the name of the associated element. 
         /// Useful for display in some circumstances.
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 0ba3d618b7a..ee9e9cba954 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -6,7 +6,6 @@
 
 namespace Microsoft.Build.Eventing
 {
-
     /// <summary>
     /// This captures information of how various key methods of building with MSBuild ran.
     /// </summary>
@@ -281,7 +280,6 @@ public void RarLogResultsStop()
         [Event(33)]
         public void ParseStart(string projectFileName)
         {
-
             WriteEvent(33, projectFileName);
         }
 
diff --git a/src/Framework/ProjectEvaluationFinishedEventArgs.cs b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
index 7179df89d9a..1d900b49c03 100644
--- a/src/Framework/ProjectEvaluationFinishedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
@@ -17,7 +17,6 @@ public sealed class ProjectEvaluationFinishedEventArgs : BuildStatusEventArgs
         /// </summary>
         public ProjectEvaluationFinishedEventArgs()
         {
-            
         }
 
         /// <summary>
diff --git a/src/Framework/ProjectEvaluationStartedEventArgs.cs b/src/Framework/ProjectEvaluationStartedEventArgs.cs
index f391d8825d6..80332d2c4f4 100644
--- a/src/Framework/ProjectEvaluationStartedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationStartedEventArgs.cs
@@ -16,7 +16,6 @@ public class ProjectEvaluationStartedEventArgs : BuildStatusEventArgs
         /// </summary>
         public ProjectEvaluationStartedEventArgs()
         {
-
         }
 
         /// <summary>
diff --git a/src/Framework/TaskPropertyInfo.cs b/src/Framework/TaskPropertyInfo.cs
index eb5808ef40b..bbda09f9634 100644
--- a/src/Framework/TaskPropertyInfo.cs
+++ b/src/Framework/TaskPropertyInfo.cs
@@ -17,7 +17,7 @@ public class TaskPropertyInfo
         /// </summary>
         /// <param name="name">Name of the parameter</param>
         /// <param name="typeOfParameter">The actual type of the parameter</param>
-        /// <param name="output">True if the parameter is both an output and and input parameter. False if the parameter is only an input parameter</param>
+        /// <param name="output">True if the parameter is both an output and input parameter. False if the parameter is only an input parameter</param>
         /// <param name="required">True if the parameter must be supplied to each invocation of the task.</param>
         public TaskPropertyInfo(string name, Type typeOfParameter, bool output, bool required)
         {
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 04697b84240..5fee06a9d1e 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1265,7 +1265,6 @@ public void HelpMessagesAreValid()
                         // Ignore empty lines
                         if (!String.IsNullOrWhiteSpace(helpMessageLines[i]))
                         {
-
                             if (item.Key.Contains("Examples"))
                             {
                                 // Examples require a certain number of leading spaces
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 9d27325e7b0..a2cc9a8d075 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -659,7 +659,6 @@ public void ConfigurationInvalid()
             // if there's not, we will catch when we try to read the toolsets. Either is fine; we just want to not crash.
             (output.Contains("MSB1043") || output.Contains("MSB4136")).ShouldBeTrue("Output should contain 'MSB1043' or 'MSB4136'");
 
-
         }
 #endif
 
@@ -1424,14 +1423,12 @@ public void TestProcessProjectSwitch()
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-
             projects = new string[] { "test.sln~", "test.sln" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
         }
 
-
         /// <summary>
         /// Ignore .sln and .vcproj files to replicate Building_DF_LKG functionality
         /// </summary>
@@ -1444,7 +1441,6 @@ public void TestProcessProjectSwitchReplicateBuildingDFLKG()
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj"); // "Expected test.proj to be only project found"
         }
 
-
         /// <summary>
         /// Test the case where we remove all of the project extensions that exist in the directory
         /// </summary>
@@ -1903,7 +1899,7 @@ public void ProcessConsoleLoggerSwitches()
         {
             ArrayList loggers = new ArrayList();
             LoggerVerbosity verbosity = LoggerVerbosity.Normal;
-            List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>(); ;
+            List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>(); 
             string[] consoleLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
 
             MSBuildApp.ProcessConsoleLoggerSwitch
@@ -2208,7 +2204,6 @@ public void TasksGetAssemblyLoadContexts()
 
 #endif
 
-
         private string CopyMSBuild()
         {
             string dest = null;
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index dd02ff90a83..82b3d8dc181 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -46,7 +46,6 @@ string commandLineArg
             this.commandLineArg = commandLineArg;
         }
 
-
         /// <summary>
         /// Serialization constructor
         /// </summary>
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 80ce432a513..a4e3f1f2045 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -197,7 +197,6 @@ bool emptyParametersAllowed
             internal bool emptyParametersAllowed;
         }
 
-
         // map switches that do not take parameters to their identifiers (taken from ParameterlessSwitch enum)
         // WARNING: keep this map in the same order as the ParameterlessSwitch enumeration
         private static readonly ParameterlessSwitchInfo[] s_parameterlessSwitchesMap =
@@ -498,7 +497,6 @@ bool emptyParametersAllowed
                     // check if they were all stored successfully i.e. they were all non-empty (after removing quoting, if requested)
                     parametersStored = (emptyParameters == 0);
                 }
-
             }
             else
             {
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index 6029f16baf0..a03db6f636f 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -27,17 +27,9 @@ internal NodeEndpointOutOfProcTaskHost(string pipeName)
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected override long GetHostHandshake()
+        protected override Handshake GetHandshake()
         {
-            return CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
-        }
-
-        /// <summary>
-        /// Returns the client handshake for this node endpoint
-        /// </summary>
-        protected override long GetClientHandshake()
-        {
-            return CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
         }
     }
 }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index cd8ef08e016..0ad949936e5 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -644,7 +644,6 @@ string [] commandLine
                     // leave priority where it was.
                     catch (Win32Exception) { }
 
-
                     DateTime t1 = DateTime.Now;
 
                     // If the primary file passed to MSBuild is a .binlog file, play it back into passed loggers
@@ -2586,7 +2585,6 @@ internal static ProfilerLogger ProcessProfileEvaluationSwitch(string[] parameter
                     ex.Message);
             }
 
-
             var logger = new ProfilerLogger(profilerFile);
             loggers.Add(logger);
 
@@ -2653,7 +2651,6 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
                         CommandLineSwitchException.Throw("InvalidNodeNumberValue", nodeModeNumber.ToString());
                     }
 
-
                     if (shutdownReason == NodeEngineShutdownReason.Error)
                     {
                         Debug.WriteLine("An error has happened, throwing an exception");
@@ -2784,7 +2781,6 @@ DirectoryGetFiles getFiles
                     }
                 }
 
-
                 if (potentialSolutionFiles != null)
                 {
                     foreach (string s in potentialSolutionFiles)
@@ -2926,7 +2922,7 @@ private static Dictionary<string, object> ValidateExtensions(string[] projectsEx
                     if (extensionToIgnore.IndexOfAny(s_wildcards) > -1)
                     {
                         InitializationException.Throw("InvalidExtensionToIgnore", extensionToIgnore, null, false);
-                    };
+                    }
                     if (!extensionsToIgnoreDictionary.ContainsKey(extensionToIgnore))
                     {
                         extensionsToIgnoreDictionary.Add(extensionToIgnore, null);
@@ -3628,7 +3624,6 @@ out ILogger logger
                     logger.Parameters = loggerDescription.LoggerSwitchParameters;
                 }
             }
-
             catch (LoggerException)
             {
                 // Logger failed politely during parameter/verbosity setting
diff --git a/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs b/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
index e7e6a6221ef..99aadcb9f7e 100644
--- a/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
+++ b/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
@@ -93,7 +93,6 @@ private static bool IsValueWriteAtomic()
         /// </summary>
         public ConcurrentDictionary(IEqualityComparer<TKey> comparer = null)
         {
-
             int concurrencyLevel = Environment.ProcessorCount;
             int capacity = DefaultCapacity;
 
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 0a8fd4dbb3a..a3b95a2eb36 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -18,7 +18,6 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal class TypeLoader
     {
-
         /// <summary>
         /// Cache to keep track of the assemblyLoadInfos based on a given typeFilter.
         /// </summary>
diff --git a/src/Samples/XmlFileLogger/XmlFileLogger.cs b/src/Samples/XmlFileLogger/XmlFileLogger.cs
index 10772659ed8..5663da5cd74 100644
--- a/src/Samples/XmlFileLogger/XmlFileLogger.cs
+++ b/src/Samples/XmlFileLogger/XmlFileLogger.cs
@@ -62,7 +62,6 @@ public override void Initialize(IEventSource eventSource)
             };
             eventSource.WarningRaised += (o, args) =>
             {
-
                 _warings++;
                 _build.AddMessage(args, string.Format("Warning {0}: {1}", args.Code, args.Message));
             };
diff --git a/src/Shared/BufferedReadStream.cs b/src/Shared/BufferedReadStream.cs
index e907d980e4a..f3f9b6906b3 100644
--- a/src/Shared/BufferedReadStream.cs
+++ b/src/Shared/BufferedReadStream.cs
@@ -144,7 +144,6 @@ protected override void Dispose(bool disposing)
 
             base.Dispose(disposing);
         }
-
         
     }
 }
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 7a69513847b..d40444aecfc 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -207,7 +207,6 @@ private static BuildEnvironment TryFromMSBuildAssembly()
             }
 
             return null;
-
         }
 
         private static BuildEnvironment TryFromMSBuildAssemblyUnderVisualStudio(string msbuildAssembly, string msbuildExe, bool allowLegacyToolsVersion = false)
@@ -449,7 +448,6 @@ internal static void ResetInstance_ForUnitTestsOnly(Func<string> getProcessFromR
         private static Func<string, string> s_getEnvironmentVariable = GetEnvironmentVariable;
         private static Func<bool> s_runningTests = CheckIfRunningTests;
 
-
         private static class BuildEnvironmentHelperSingleton
         {
             //Â ExplicitÂ staticÂ constructorÂ toÂ tellÂ C#Â compiler
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 2bb61d35127..cd238bd5540 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -51,7 +51,59 @@ internal enum HandshakeOptions
         /// <summary>
         /// Building with BelowNormal priority
         /// </summary>
-        LowPriority = 16
+        LowPriority = 16,
+
+        /// <summary>
+        /// Building with administrator privileges
+        /// </summary>
+        Administrator = 32
+    }
+
+    internal readonly struct Handshake
+    {
+        readonly int options;
+        readonly int salt;
+        readonly int fileVersionMajor;
+        readonly int fileVersionMinor;
+        readonly int fileVersionBuild;
+        readonly int fileVersionPrivate;
+        readonly int sessionId;
+
+        internal Handshake(HandshakeOptions nodeType)
+        {
+            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
+            // This indicates in the first byte that we are a modern build.
+            options = (int)nodeType | (((int)CommunicationsUtilities.handshakeVersion) << 24);
+            string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+            string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
+            salt = CommunicationsUtilities.GetHandshakeHashCode(handshakeSalt + toolsDirectory);
+            Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
+            fileVersionMajor = fileVersion.Major;
+            fileVersionMinor = fileVersion.Minor;
+            fileVersionBuild = fileVersion.Build;
+            fileVersionPrivate = fileVersion.Revision;
+            sessionId = Process.GetCurrentProcess().SessionId;
+        }
+
+        // This is used as a key, so it does not need to be human readable.
+        public override string ToString()
+        {
+            return String.Format("{0} {1} {2} {3} {4} {5} {6}", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);
+        }
+
+        internal int[] RetrieveHandshakeComponents()
+        {
+            return new int[]
+            {
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)
+            };
+        }
     }
 
     /// <summary>
@@ -60,19 +112,19 @@ internal enum HandshakeOptions
     static internal class CommunicationsUtilities
     {
         /// <summary>
-        /// The timeout to connect to a node.
+        /// Indicates to the NodeEndpoint that all the various parts of the Handshake have been sent.
         /// </summary>
-        private const int DefaultNodeConnectionTimeout = 900 * 1000; // 15 minutes; enough time that a dev will typically do another build in this time
+        private const int EndOfHandshakeSignal = -0x2a2a2a2a;
 
         /// <summary>
-        /// Flag if we have already calculated the FileVersion hashcode
+        /// The version of the handshake. This should be updated each time the handshake structure is altered.
         /// </summary>
-        private static bool s_fileVersionChecked;
+        internal const byte handshakeVersion = 0x01;
 
         /// <summary>
-        /// A hashcode calculated from the fileversion
+        /// The timeout to connect to a node.
         /// </summary>
-        private static int s_fileVersionHash;
+        private const int DefaultNodeConnectionTimeout = 900 * 1000; // 15 minutes; enough time that a dev will typically do another build in this time
 
         /// <summary>
         /// Whether to trace communications
@@ -102,48 +154,6 @@ static internal int NodeConnectionTimeout
             get { return GetIntegerVariableOrDefault("MSBUILDNODECONNECTIONTIMEOUT", DefaultNodeConnectionTimeout); }
         }
 
-        /// <summary>
-        /// Looks up the file version and caches the hashcode
-        /// This file version hashcode is used in calculating the handshake
-        /// </summary>
-        private static int FileVersionHash
-        {
-            get
-            {
-                if (!s_fileVersionChecked)
-                {
-                    // We only hash in any complus_installroot value, not a file version.
-                    // This is because in general msbuildtaskhost.exe does not load any assembly that
-                    // the parent process loads, so they can't compare the version of a particular assembly.
-                    // They can't compare their own versions, because if one of them is serviced, they
-                    // won't match any more. The only known incompatibility is between a razzle and non-razzle
-                    // parent and child. COMPLUS_Version can (and typically will) differ legitimately between
-                    // them, so just check COMPLUS_InstallRoot.
-                    string complusInstallRoot = Environment.GetEnvironmentVariable("COMPLUS_INSTALLROOT");
-
-                    // This is easier in .NET 4+:
-                    //  var fileIdentity = typeof(CommunicationsUtilities).GetTypeInfo().Assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>().InformationalVersion;
-                    // but we need to be 3.5 compatible here to work in MSBuildTaskHost
-                    string fileIdentity = null;
-                    foreach (var attribute in typeof(CommunicationsUtilities).GetTypeInfo().Assembly.GetCustomAttributes(false))
-                    {
-                        if (attribute is AssemblyInformationalVersionAttribute informationalVersionAttribute)
-                        {
-                            fileIdentity = informationalVersionAttribute.InformationalVersion;
-                            break;
-                        }
-                    }
-
-                    ErrorUtilities.VerifyThrow(fileIdentity != null, "Did not successfully retrieve InformationalVersion.");
-
-                    s_fileVersionHash = GetHandshakeHashCode(complusInstallRoot ?? fileIdentity);
-                    s_fileVersionChecked = true;
-                }
-
-                return s_fileVersionHash;
-            }
-        }
-
         /// <summary>
         /// Get environment block
         /// </summary>
@@ -291,70 +301,19 @@ internal static void SetEnvironment(IDictionary<string, string> newEnvironment)
             }
         }
 
+#nullable enable
         /// <summary>
-        /// Given a base handshake, generates the real handshake based on e.g. elevation level.  
+        /// Indicate to the client that all elements of the Handshake have been sent.
         /// </summary>
-        private static long GenerateHostHandshakeFromBase(long baseHandshake)
+        internal static void WriteEndOfHandshakeSignal(this PipeStream stream)
         {
-#if FEATURE_SECURITY_PRINCIPAL_WINDOWS
-            // If we are running in elevated privs, we will only accept a handshake from an elevated process as well.
-            WindowsPrincipal principal = new WindowsPrincipal(WindowsIdentity.GetCurrent());
-
-            // Both the client and the host will calculate this separately, and the idea is that if they come out the same
-            // then we can be sufficiently confident that the other side has the same elevation level as us.  This is complementary
-            // to the username check which is also done on connection.
-            if (principal.IsInRole(WindowsBuiltInRole.Administrator))
-            {
-                unchecked
-                {
-                    baseHandshake = baseHandshake ^ 0x5c5c5c5c5c5c5c5c + Process.GetCurrentProcess().SessionId;
-                }
-            }
-#endif
-
-            // Mask out the first byte. Modern builds expect the first byte to be zero to indicate that they are modern
-            // and should be treated as such. Older builds used a non-zero initial byte. See here:
-            // https://github.com/microsoft/msbuild/blob/584ca5f11b28971f5651b4b8de5f173ad1cb2786/src/Shared/NodeEndpointOutOfProcBase.cs#L403.
-            return baseHandshake & 0x00FFFFFFFFFFFFFF;
-        }
-
-        /// <summary>
-        /// Magic number sent by the host to the client during the handshake.
-        /// Derived from the binary timestamp to avoid mixing binary versions.
-        /// </summary>
-        internal static long GetHostHandshake(HandshakeOptions nodeType)
-        {
-            string salt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
-            string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
-            int nodeHandshakeSalt = GetHandshakeHashCode(salt + toolsDirectory);
-
-            Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", nodeType={2}, FileVersionHash={3}", salt, toolsDirectory, nodeType, FileVersionHash);
-
-            // FileVersionHash (32 bits) is shifted 8 bits to avoid session ID collision
-            // HandshakeOptions (5 bits) is shifted just after the FileVersionHash
-            // remaining bits of nodeHandshakeSalt (32 bits truncated to 11) are shifted next
-            //      nodeHandshakeSalt    | HandshakeOptions |             fileVersionHash           | SessionID
-            //  0000 0000 0000 0000 000        0 0000        0000 0000 0000 0000 0000 0000 0000 0000  0000 0000
-            unchecked
-            {
-                ulong baseHandshake = ((ulong)(uint)nodeHandshakeSalt << 45) | ((ulong)(uint)nodeType << 40) | ((ulong)(uint)FileVersionHash << 8);
-                return GenerateHostHandshakeFromBase((long)baseHandshake);
-            }
-        }
-
-        /// <summary>
-        /// Magic number sent by the client to the host during the handshake.
-        /// Munged version of the host handshake.
-        /// </summary>
-        internal static long GetClientHandshake(HandshakeOptions hostContext)
-        {
-            return ~GetHostHandshake(hostContext);
+            stream.WriteIntForHandshake(EndOfHandshakeSignal);
         }
 
         /// <summary>
         /// Extension method to write a series of bytes to a stream
         /// </summary>
-        internal static void WriteLongForHandshake(this PipeStream stream, long value)
+        internal static void WriteIntForHandshake(this PipeStream stream, int value)
         {
             byte[] bytes = BitConverter.GetBytes(value);
 
@@ -365,39 +324,49 @@ internal static void WriteLongForHandshake(this PipeStream stream, long value)
                 Array.Reverse(bytes);
             }
 
-            ErrorUtilities.VerifyThrow(bytes.Length == 8, "Long should be 8 bytes");
+            ErrorUtilities.VerifyThrow(bytes.Length == 4, "Int should be 4 bytes");
 
             stream.Write(bytes, 0, bytes.Length);
         }
 
-        /// <summary>
-        /// Extension method to read a series of bytes from a stream
-        /// </summary>
-        internal static long ReadLongForHandshake(this PipeStream stream
+        internal static void ReadEndOfHandshakeSignal(this PipeStream stream, bool isProvider
 #if NETCOREAPP2_1 || MONO
-            , int handshakeReadTimeout
+            , int timeout
 #endif
             )
         {
-            return stream.ReadLongForHandshake((byte[])null, 0
+            // Accept only the first byte of the EndOfHandshakeSignal
+            int valueRead = stream.ReadIntForHandshake(null
 #if NETCOREAPP2_1 || MONO
-                , handshakeReadTimeout
+            , timeout
 #endif
                 );
+
+            if (valueRead != EndOfHandshakeSignal)
+            {
+                if (isProvider)
+                {
+                    CommunicationsUtilities.Trace("Handshake failed on part {0}. Probably the client is a different MSBuild build.", valueRead);
+                }
+                else
+                {
+                    CommunicationsUtilities.Trace("Expected end of handshake signal but received {0}. Probably the host is a different MSBuild build.", valueRead);
+                }
+                throw new InvalidOperationException();
+            }
         }
 
         /// <summary>
         /// Extension method to read a series of bytes from a stream.
         /// If specified, leading byte matches one in the supplied array if any, returns rejection byte and throws IOException.
         /// </summary>
-        internal static long ReadLongForHandshake(this PipeStream stream, byte[] leadingBytesToReject,
-            byte rejectionByteToReturn
+        internal static int ReadIntForHandshake(this PipeStream stream, byte? byteToAccept
 #if NETCOREAPP2_1 || MONO
             , int timeout
 #endif
             )
         {
-            byte[] bytes = new byte[8];
+            byte[] bytes = new byte[4];
 
 #if NETCOREAPP2_1 || MONO
             if (!NativeMethodsShared.IsWindows)
@@ -437,24 +406,18 @@ byte rejectionByteToReturn
                         throw new IOException(String.Format(CultureInfo.InvariantCulture, "Unexpected end of stream while reading for handshake"));
                     }
 
-                    if (i == 0 && leadingBytesToReject != null)
-                    {
-                        foreach (byte reject in leadingBytesToReject)
-                        {
-                            if (read == reject)
-                            {
-                                stream.WriteByte(rejectionByteToReturn); // disconnect the host
+                    bytes[i] = Convert.ToByte(read);
 
-                                throw new IOException(String.Format(CultureInfo.InvariantCulture, "Client: rejected old host. Received byte {0} but this matched a byte to reject.", bytes[i]));  // disconnect and quit
-                            }
-                        }
+                    if (i == 0 && byteToAccept != null && byteToAccept != bytes[0])
+                    {
+                        stream.WriteIntForHandshake(0x0F0F0F0F);
+                        stream.WriteIntForHandshake(0x0F0F0F0F);
+                        throw new InvalidOperationException(String.Format(CultureInfo.InvariantCulture, "Client: rejected old host. Received byte {0} instead of {1}.", bytes[0], byteToAccept));
                     }
-
-                    bytes[i] = Convert.ToByte(read);
                 }
             }
 
-            long result;
+            int result;
 
             try
             {
@@ -465,7 +428,7 @@ byte rejectionByteToReturn
                     Array.Reverse(bytes);
                 }
 
-                result = BitConverter.ToInt64(bytes, 0 /* start index */);
+                result = BitConverter.ToInt32(bytes, 0 /* start index */);
             }
             catch (ArgumentException ex)
             {
@@ -474,6 +437,7 @@ byte rejectionByteToReturn
 
             return result;
         }
+#nullable disable
 
 #if !FEATURE_APM
         internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int bytesToRead)
@@ -495,12 +459,14 @@ internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int byte
         /// <summary>
         /// Given the appropriate information, return the equivalent HandshakeOptions.
         /// </summary>
-        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit = false, int clrVersion = 0, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
+        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit = false, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
         {
             HandshakeOptions context = taskHost ? HandshakeOptions.TaskHost : HandshakeOptions.None;
 
+            int clrVersion = 0;
+
             // We don't know about the TaskHost. Figure it out.
-            if (taskHost && clrVersion == 0)
+            if (taskHost)
             {
                 // Take the current TaskHost context
                 if (taskHostParameters == null)
@@ -517,6 +483,7 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                     is64Bit = taskHostParameters[XMakeAttributes.architecture].Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
                 }
             }
+
             if (is64Bit)
             {
                 context |= HandshakeOptions.X64;
@@ -533,6 +500,16 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
             {
                 context |= HandshakeOptions.LowPriority;
             }
+#if FEATURE_SECURITY_PRINCIPAL_WINDOWS
+            // If we are running in elevated privs, we will only accept a handshake from an elevated process as well.
+            // Both the client and the host will calculate this separately, and the idea is that if they come out the same
+            // then we can be sufficiently confident that the other side has the same elevation level as us.  This is complementary
+            // to the username check which is also done on connection.
+            if (new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator))
+            {
+                context |= HandshakeOptions.Administrator;
+            }
+#endif
             return context;
         }
 
@@ -646,5 +623,10 @@ internal static int GetHandshakeHashCode(string fileVersion)
                 }
             }
         }
+
+        internal static int AvoidEndOfHandshakeSignal(int x)
+        {
+            return x == EndOfHandshakeSignal ? ~x : x;
+        }
     }
 }
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 03db70e079d..1a5c9dde2b4 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -348,7 +348,6 @@ string logOutputProperties
             return formattedMessage.ToString();
         }
 
-
         /// <summary>
         /// Splits strings on 'newLines' with tolerance for Everett and Dogfood builds.
         /// </summary>
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 2cef4f9586c..9e6839a1b13 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -685,7 +685,6 @@ IEnumerable<string> paths
             }
         }
 
-
         /// <summary>
         /// Checks if the char is a DirectorySeparatorChar or a AltDirectorySeparatorChar
         /// </summary>
@@ -1144,7 +1143,6 @@ out bool isLegalFileSpec
             }
         }
 
-
         /// <summary>
         /// Determine if the filespec is legal according to the following conditions:
         /// 
@@ -1189,7 +1187,6 @@ private static bool HasMisplacedRecursiveOperator(string str)
             return false;
         }
 
-
         /// <summary>
         /// Append the regex equivalents for character sequences in the fixed directory part of a filespec:
         ///
@@ -1867,7 +1864,6 @@ internal string[] GetFiles
             List<string> excludeSpecsUnescaped = null
             )
         {
-
             // For performance. Short-circuit iff there is no wildcard.
             if (!HasWildcards(filespecUnescaped))
             {
@@ -2189,7 +2185,6 @@ static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped,
             {
                 foreach (string excludeSpec in excludeSpecsUnescaped)
                 {
-
                     // Try a path equality check first to:
                     // - avoid the expensive regex
                     // - maintain legacy behaviour where an illegal filespec is treated as a normal string
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index a02cf5c4582..ae7ca71d82b 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -31,7 +31,6 @@ internal static partial class FileUtilities
         // A list of possible test runners. If the program running has one of these substrings in the name, we assume
         // this is a test harness.
 
-
         // This flag, when set, indicates that we are running tests. Initially assume it's true. It also implies that
         // the currentExecutableOverride is set to a path (that is non-null). Assume this is not initialized when we
         // have the impossible combination of runningTests = false and currentExecutableOverride = null.
@@ -83,7 +82,6 @@ public static bool GetIsFileSystemCaseSensitive()
         /// Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/Microsoft/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-
         internal static readonly char[] InvalidPathChars = new char[]
         {
             '|', '\0',
@@ -350,7 +348,6 @@ private static bool IsValidRelativePathBound(char? c)
         /// </summary>
         internal static string NormalizePath(string path)
         {
-
             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
             string fullPath = GetFullPath(path);
             return FixFilePath(fullPath);
@@ -665,7 +662,6 @@ internal static bool HasExtension(string fileName, string[] allowedExtensions)
         /// </summary>
         internal static string ExecutingAssemblyPath => Path.GetFullPath(AssemblyUtilities.GetAssemblyLocation(typeof(FileUtilities).GetTypeInfo().Assembly));
 
-
         /// <summary>
         /// Determines the full path for the given file-spec.
         /// ASSUMES INPUT IS STILL ESCAPED
@@ -769,7 +765,6 @@ internal static bool PathIsInvalid(string path)
             return path.IndexOfAny(InvalidFileNameChars, lastDirectorySeparator >= 0 ? lastDirectorySeparator + 1 : 0) >= 0;
         }
 
-
         /// <summary>
         /// A variation on File.Delete that will throw ExceptionHandling.NotExpectedException exceptions
         /// </summary>
@@ -919,7 +914,6 @@ internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSys
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryExists)
                     : fileSystem.DirectoryExists(fullPath);
-
             }
             catch
             {
@@ -944,7 +938,6 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileExists)
                     : fileSystem.FileExists(fullPath);
-
             }
             catch
             {
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index c8be4058ee7..8c1855e413d 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -165,6 +165,5 @@ internal static bool MeetsUncPatternMinimumRequirements(string pattern)
                 (pattern[1] == _backSlash ||
                 pattern[1] == _forwardSlash);
        }
-
     }
 }
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 8723e085dfd..efe72958d2c 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -916,7 +916,7 @@ internal static string GeneratePathToBuildToolsForToolsVersion(string toolsVersi
         }
 
         /// <summary>
-        /// Take the parts of the Target framework moniker and formulate the reference assembly path based on the the following pattern:
+        /// Take the parts of the Target framework moniker and formulate the reference assembly path based on the following pattern:
         /// For a framework and version:
         ///     $(TargetFrameworkRootPath)\$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)
         /// For a subtype:
diff --git a/src/Shared/LanguageParser/tokenCharReader.cs b/src/Shared/LanguageParser/tokenCharReader.cs
index 6d0975b391e..aa8aa07d3d4 100644
--- a/src/Shared/LanguageParser/tokenCharReader.cs
+++ b/src/Shared/LanguageParser/tokenCharReader.cs
@@ -122,7 +122,6 @@ internal bool EndOfLines
             get { return _sources.IsPastEnd(_position); }
         }
 
-
         /*
          * Method:  GetCurrentMatchedString
          * 
@@ -158,7 +157,6 @@ private bool Sink(string match, bool ignoreCase)
                 return false;
             }
 
-
             string compare = _sources.Substring(_position, match.Length);
 
             if
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 49385b177ad..43d914ac1f0 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -19,7 +19,6 @@
 using FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
 using Microsoft.Build.Utilities;
 
-
 namespace Microsoft.Build.Shared
 {
     /// <summary>
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 05b8ae7a4a5..19973530259 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -239,12 +239,7 @@ internal void InternalConstruct(string pipeName)
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected abstract long GetHostHandshake();
-
-        /// <summary>
-        /// Returns the client handshake for this node endpoint
-        /// </summary>
-        protected abstract long GetClientHandshake();
+        protected abstract Handshake GetHandshake();
 
         /// <summary>
         /// Updates the current link status if it has changed and notifies any registered delegates.
@@ -329,8 +324,6 @@ private void InitializeAsyncPacketThread()
         private void PacketPumpProc()
         {
             NamedPipeServerStream localPipeServer = _pipeServer;
-            PipeStream localWritePipe = _pipeServer;
-            PipeStream localReadPipe = _pipeServer;
 
             AutoResetEvent localPacketAvailable = _packetAvailable;
             AutoResetEvent localTerminatePacketPump = _terminatePacketPump;
@@ -340,6 +333,7 @@ private void PacketPumpProc()
             bool gotValidConnection = false;
             while (!gotValidConnection)
             {
+                gotValidConnection = true;
                 DateTime restartWaitTime = DateTime.UtcNow;
 
                 // We only wait to wait the difference between now and the last original start time, in case we have multiple hosts attempting
@@ -352,14 +346,11 @@ private void PacketPumpProc()
                     // Wait for a connection
 #if FEATURE_APM
                     IAsyncResult resultForConnection = localPipeServer.BeginWaitForConnection(null, null);
-#else
-                    Task connectionTask = localPipeServer.WaitForConnectionAsync();
-#endif
                     CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
-
-#if FEATURE_APM
                     bool connected = resultForConnection.AsyncWaitHandle.WaitOne(waitTimeRemaining, false);
 #else
+                    Task connectionTask = localPipeServer.WaitForConnectionAsync();
+                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
                     bool connected = connectionTask.Wait(waitTimeRemaining);
 #endif
                     if (!connected)
@@ -374,57 +365,57 @@ private void PacketPumpProc()
                     localPipeServer.EndWaitForConnection(resultForConnection);
 #endif
 
-                    // The handshake protocol is a simple long exchange.  The host sends us a long, and we
-                    // respond with another long.  Once the handshake is complete, both sides can be assured the
-                    // other is ready to accept data.
-                    // To avoid mixing client and server builds, the long is the MSBuild binary timestamp.
-
-                    // Compatibility issue here.
-                    // Previous builds of MSBuild 4.0 would exchange just a byte.
-                    // Host would send either 0x5F or 0x60 depending on whether it was the toolset or not respectively.
-                    // Client would return either 0xF5 or 0x06 respectively.
-                    // Therefore an old host on a machine with new clients running will hang, 
-                    // sending a byte and waiting for a byte until it eventually times out;
-                    // because the new client will want 7 more bytes before it returns anything.
-                    // The other way around is not a problem, because the old client would immediately return the (wrong)
-                    // byte on receiving the first byte of the long sent by the new host, and the new host would disconnect.
-                    // To avoid the hang, special case here:
-                    // Make sure our handshakes always start with 00.
-                    // If we received ONLY one byte AND it's 0x5F or 0x60, return 0xFF (it doesn't matter what as long as
-                    // it will cause the host to reject us; new hosts expect 00 and old hosts expect F5 or 06).
+                    // The handshake protocol is a series of int exchanges.  The host sends us a each component, and we
+                    // verify it. Afterwards, the host sends an "End of Handshake" signal, to which we respond in kind.
+                    // Once the handshake is complete, both sides can be assured the other is ready to accept data.
+                    Handshake handshake = GetHandshake();
                     try
                     {
-                        long handshake = localReadPipe.ReadLongForHandshake(/* reject these leads */ new byte[] { 0x5F, 0x60 }, 0xFF /* this will disconnect the host; it expects leading 00 or F5 or 06 */
+                        int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
+                        for (int i = 0; i < handshakeComponents.Length; i++)
+                        {
+                            int handshakePart = _pipeServer.ReadIntForHandshake(i == 0 ? (byte?)CommunicationsUtilities.handshakeVersion : null /* this will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard */
 #if NETCOREAPP2_1 || MONO
                             , ClientConnectTimeout /* wait a long time for the handshake from this side */
 #endif
                             );
 
-#if FEATURE_SECURITY_PERMISSIONS
-                        WindowsIdentity currentIdentity = WindowsIdentity.GetCurrent();
-#endif
+                            if (handshakePart != handshakeComponents[i])
+                            {
+                                CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshakePart, handshakeComponents[i]);
+                                _pipeServer.WriteIntForHandshake(i + 1);
+                                gotValidConnection = false;
+                                break;
+                            }
+                        }
 
-                        if (handshake != GetHostHandshake())
+                        if (gotValidConnection)
                         {
-                            CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshake, GetHostHandshake());
-                            localPipeServer.Disconnect();
-                            continue;
-                        }
+                            // To ensure that our handshake and theirs have the same number of bytes, receive and send a magic number indicating EOS.
+#if NETCOREAPP2_1 || MONO
+                            _pipeServer.ReadEndOfHandshakeSignal(false, ClientConnectTimeout); /* wait a long time for the handshake from this side */
+#else
+                            _pipeServer.ReadEndOfHandshakeSignal(false);
+#endif
+                            CommunicationsUtilities.Trace("Successfully connected to parent.");
+                            _pipeServer.WriteEndOfHandshakeSignal();
 
 #if FEATURE_SECURITY_PERMISSIONS
-                        // We will only talk to a host that was started by the same user as us.  Even though the pipe access is set to only allow this user, we want to ensure they
-                        // haven't attempted to change those permissions out from under us.  This ensures that the only way they can truly gain access is to be impersonating the
-                        // user we were started by.
-                        WindowsIdentity clientIdentity = null;
-                        localPipeServer.RunAsClient(delegate () { clientIdentity = WindowsIdentity.GetCurrent(true); });
-
-                        if (clientIdentity == null || !String.Equals(clientIdentity.Name, currentIdentity.Name, StringComparison.OrdinalIgnoreCase))
-                        {
-                            CommunicationsUtilities.Trace("Handshake failed. Host user is {0} but we were created by {1}.", (clientIdentity == null) ? "<unknown>" : clientIdentity.Name, currentIdentity.Name);
-                            localPipeServer.Disconnect();
-                            continue;
-                        }
+                            // We will only talk to a host that was started by the same user as us.  Even though the pipe access is set to only allow this user, we want to ensure they
+                            // haven't attempted to change those permissions out from under us.  This ensures that the only way they can truly gain access is to be impersonating the
+                            // user we were started by.
+                            WindowsIdentity currentIdentity = WindowsIdentity.GetCurrent();
+                            WindowsIdentity clientIdentity = null;
+                            localPipeServer.RunAsClient(delegate () { clientIdentity = WindowsIdentity.GetCurrent(true); });
+
+                            if (clientIdentity == null || !String.Equals(clientIdentity.Name, currentIdentity.Name, StringComparison.OrdinalIgnoreCase))
+                            {
+                                CommunicationsUtilities.Trace("Handshake failed. Host user is {0} but we were created by {1}.", (clientIdentity == null) ? "<unknown>" : clientIdentity.Name, currentIdentity.Name);
+                                gotValidConnection = false;
+                                continue;
+                            }
 #endif
+                        }
                     }
                     catch (IOException e)
                     {
@@ -432,19 +423,25 @@ private void PacketPumpProc()
                         // 1. The host (OOP main node) connects to us, it immediately checks for user privileges
                         //    and if they don't match it disconnects immediately leaving us still trying to read the blank handshake
                         // 2. The host is too old sending us bits we automatically reject in the handshake
+                        // 3. We expected to read the EndOfHandshake signal, but we received something else
                         CommunicationsUtilities.Trace("Client connection failed but we will wait for another connection. Exception: {0}", e.Message);
+                        
+                        gotValidConnection = false;
+                    }
+                    catch (InvalidOperationException)
+                    {
+                        gotValidConnection = false;
+                    }
+
+                    if (!gotValidConnection)
+                    {
                         if (localPipeServer.IsConnected)
                         {
                             localPipeServer.Disconnect();
                         }
-
                         continue;
                     }
 
-                    gotValidConnection = true;
-
-                    CommunicationsUtilities.Trace("Writing handshake to parent");
-                    localWritePipe.WriteLongForHandshake(GetClientHandshake());
                     ChangeLinkStatus(LinkStatus.Active);
                 }
                 catch (Exception e)
@@ -467,8 +464,8 @@ private void PacketPumpProc()
             }
 
             RunReadLoop(
-                new BufferedReadStream(localReadPipe),
-                localWritePipe,
+                new BufferedReadStream(_pipeServer),
+                _pipeServer,
                 localPacketQueue, localPacketAvailable, localTerminatePacketPump);
 
             CommunicationsUtilities.Trace("Ending read loop");
diff --git a/src/Shared/ReuseableStringBuilder.cs b/src/Shared/ReuseableStringBuilder.cs
index 8f295e0b263..bcd727bc402 100644
--- a/src/Shared/ReuseableStringBuilder.cs
+++ b/src/Shared/ReuseableStringBuilder.cs
@@ -80,7 +80,6 @@ string IInternable.ExpensiveConvertToString()
                 _cachedString = ((ReuseableStringBuilder)this).ToString();
             }
             return _cachedString;
-
         }
 
         /// <summary>
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 95b5e812934..6a5b35b2c24 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -555,7 +555,6 @@ public void LogCommandLine(MessageImportance importance, string commandLine)
                 ErrorUtilities.ThrowInvalidOperation("LoggingBeforeTaskInitialization", e.Message);
             }
 
-
             BuildEngine.LogMessageEvent(e);
         }
 
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index 8948d8dde99..8764ad77c12 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -147,6 +147,5 @@ public void Dispose()
                 Directory.Delete(Path, true);
             }
         }
-
     }
 }
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index d2b59ce5c80..3fa68f16c03 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -201,7 +201,7 @@ public bool LogTaskInputs
         public readonly bool IgnoreEmptyImports = Environment.GetEnvironmentVariable("MSBUILDIGNOREEMPTYIMPORTS") == "1";
 
         /// <summary>
-        /// Whether to to respect the TreatAsLocalProperty parameter on the Project tag. 
+        /// Whether to respect the TreatAsLocalProperty parameter on the Project tag. 
         /// </summary>
         public readonly bool IgnoreTreatAsLocalProperty = Environment.GetEnvironmentVariable("MSBUILDIGNORETREATASLOCALPROPERTY") != null;
 
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index fd1a73d7d7e..3dfd5b8447b 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -1,7 +1,6 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index a78ff71ecbd..9680172543b 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -712,7 +712,6 @@ public void VerifyAssemblyNameExSerialization(string assemblyName)
         [Fact]
         public void VerifyAssemblyNameExSerializationWithRemappedFrom()
         {
-            
             AssemblyNameExtension assemblyNameOriginal = new AssemblyNameExtension("System.Xml, Version=10.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension assemblyRemappedFrom = new AssemblyNameExtension("System.Xml, Version=9.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
             assemblyRemappedFrom.MarkImmutable();
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index ef549c92323..293b4dbcec3 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -128,7 +128,6 @@ void Verify(string include, string[] excludes, bool shouldHaveNoMatches = false,
             //    of Directory.GetFiles, which is case-sensitive on Unix.
         }
 
-
         /// <summary>
         /// A test data class for providing data to the <see cref="FileMatcherTest.GetFilesComplexGlobbingMatching"/> test.
         /// </summary>
@@ -724,7 +723,6 @@ public void Regress162390()
             );
         }
 
-
         /*
         * Method:  GetLongFileNameForShortLocalPath
         *
@@ -982,7 +980,6 @@ public void ReduceDoubleSlashesBaseline()
             ValidateFileMatch(Path.Combine("**", "*.cs"), "file.cs", true);
         }
 
-
         [Fact]
         public void ReduceDoubleSlashes()
         {
@@ -1091,7 +1088,6 @@ public void Unc()
                 true
                 );
 
-
             ValidateFileMatch
                 (
                 "**",
@@ -1204,7 +1200,6 @@ public void SplitFileSpec()
             ValidateSplitFileSpec("bin\\**\\", "bin\\", "**\\", "");
             ValidateSplitFileSpec("bin\\**\\*", "bin\\", "**\\", "*");
             ValidateSplitFileSpec("**", "", "**\\", "*.*");
-
         }
 
         [Fact]
@@ -1455,7 +1450,6 @@ public void ExcludePatternAndSpecificFiles()
                     @"bin\**",
                     @"Program_old.cs",
                     @"Properties\AssemblyInfo_old.cs"
-
                 },
                 new[]    //  Matching files
                 {
@@ -1857,8 +1851,6 @@ out bool isLegalFileSpec
             isLegalFileSpec.ShouldBe(expectedIsLegalFileSpec);
         }
 
-
-
         #region Support functions.
 
         /// <summary>
@@ -2138,7 +2130,6 @@ internal static string Normalize(string path)
                 // Preserve parent-directory markers.
                 normalized = normalized.Replace(@".." + Path.DirectorySeparatorChar, "<:PARENT:>");
 
-
                 // Just get rid of doubles enough to satisfy our test cases.
                 string doubleSeparator = Path.DirectorySeparatorChar.ToString() + Path.DirectorySeparatorChar.ToString();
                 normalized = normalized.Replace(doubleSeparator, Path.DirectorySeparatorChar.ToString());
@@ -2190,7 +2181,6 @@ private bool IsMatchingDirectory(string path, string candidate)
                 return false;
             }
 
-
             /// <summary>
             /// Searches the candidates array for one that matches path
             /// </summary>
@@ -2358,8 +2348,6 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
             Assert.Equal(0, mockFileSystem.FileHits3); // "At least one file that was marked untouchable was referenced."
         }
 
-
-
         /// <summary>
         /// Simulate GetFileSystemEntries
         /// </summary>
@@ -2377,7 +2365,6 @@ private static ImmutableArray<string> GetFileSystemEntriesLoopBack(FileMatcher.F
 
         private static FileMatcher loopBackFileMatcher = new FileMatcher(FileSystems.Default, GetFileSystemEntriesLoopBack);
 
-
         private static void ValidateSplitFileSpec
             (
             string filespec,
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index b9b730401aa..43e2aa4c725 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -273,7 +273,6 @@ public void HasExtension_WhenInvalidFileName_ThrowsArgumentException()
             Assert.Throws<ArgumentException>(() =>
             {
                 FileUtilities.HasExtension("|/", new[] { ".exe" });
-
             });
         }
 
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index b7b47a4e20e..a82b7650ee2 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -70,7 +70,6 @@ internal static string MSBuildAssemblyVersion
             }
         }
 
-
         /// <summary>
         /// Helper method to tell us whether a particular metadata name is an MSBuild well-known metadata
         /// (e.g., "RelativeDir", "FullPath", etc.)
@@ -431,7 +430,6 @@ internal static void AssertItemHasMetadata(Dictionary<string, string> expected,
             foreach (var key in expected.Keys)
             {
                 item.GetMetadataValue(key).ShouldBe(expected[key]);
-
             }
         }
 
@@ -778,7 +776,6 @@ string newExpectedProjectContents
             Assert.Equal(newExpectedProjectContents, newActualProjectContents); // "Project XML does not match expected XML.  See 'Standard Out' tab for details."
         }
 
-
         private static string s_tempProjectDir;
 
         /// <summary>
@@ -1842,8 +1839,6 @@ internal static string GetSleepCommandTemplate()
                     : "sleep {0}";
         }
 
-
-
         /// <summary>
         /// Break the provided string into an array, on newlines
         /// </summary>
@@ -1898,7 +1893,6 @@ internal class BuildManagerSession : IDisposable
 
             public MockLogger Logger { get; set; }
 
-
             public BuildManagerSession(
                 TestEnvironment env,
                 BuildParameters buildParametersPrototype = null,
diff --git a/src/Shared/UnitTests/TestData/GlobbingTestData.cs b/src/Shared/UnitTests/TestData/GlobbingTestData.cs
index 4d7418086c6..a0fe1f04247 100644
--- a/src/Shared/UnitTests/TestData/GlobbingTestData.cs
+++ b/src/Shared/UnitTests/TestData/GlobbingTestData.cs
@@ -5,7 +5,6 @@
 
 namespace Microsoft.Build.Engine.UnitTests.Globbing
 {
-    
     public static class GlobbingTestData
     {
         public static IEnumerable<object[]> IncludesAndExcludesWithWildcardsTestData
diff --git a/src/Shared/VisualStudioLocationHelper.cs b/src/Shared/VisualStudioLocationHelper.cs
index 35792d610fa..b3f5bcb2487 100644
--- a/src/Shared/VisualStudioLocationHelper.cs
+++ b/src/Shared/VisualStudioLocationHelper.cs
@@ -85,7 +85,6 @@ private static ISetupConfiguration GetQuery()
                 // Try to CoCreate the class object.
                 return new SetupConfiguration();
             }
-
             catch (COMException ex) when (ex.ErrorCode == REGDB_E_CLASSNOTREG)
             {
                 // Try to get the class object using app-local call.
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index 103570c4d6e..eb1fd4e4eb1 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -58,7 +58,6 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
             return newElement;
         }
 
-
         /// <summary>
         /// Verifies that a name is valid for the name of an item, property, or piece of metadata.
         /// If it isn't, throws an ArgumentException indicating the invalid character.
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index f0f166d5d60..9b5b2745243 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -92,8 +92,6 @@ public Miscellaneous(ITestOutputHelper output) : base(output)
         {
         }
 
-
-
         /// <summary>
         /// Let us have the following dependency structure
         ///
@@ -142,8 +140,6 @@ public void CopyLocalDependenciesWhenParentReferenceInGacFalseAllParentsInGac()
             t.ResolvedFiles[0].GetMetadata("CopyLocal").ShouldBe("false", StringCompareShould.IgnoreCase);
         }
 
-
-
         [Fact]
         public void ValidateFrameworkNameError()
         {
@@ -445,7 +441,6 @@ public void Basic()
             assemblyNames[0].SetMetadata(ItemMetadataNames.winMDFile, "NOPE");
             assemblyNames[0].SetMetadata(ItemMetadataNames.winmdImplmentationFile, "IMPL");
 
-
             assemblyNames[1].SetMetadata("Private", "true");
             assemblyNames[2].SetMetadata("Private", "false");
             assemblyNames[4].SetMetadata("Private", "false");
@@ -729,7 +724,6 @@ public void EmbedInteropTypes()
                 { "false", "false", "false", "false" }     // MyDontCopyLocalAssembly
             };
 
-
             int assembliesCount = (int)EmbedInteropTypes_Indices.EndMarker;
 
             // now let's verify our data structures are all set up correctly
@@ -807,7 +801,6 @@ public void NOPForEmptyItemLists()
             Assert.True(succeeded); // "Expected success."
         }
 
-
         /// <summary>
         /// If no related file extensions are input to RAR, .pdb and .xml should be used
         /// by default.
@@ -1021,7 +1014,6 @@ public void SimulateCreateProjectAgainstWhidbeyWithTrailingSlash()
             SimulateCreateProjectAgainstWhidbeyInternal(ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version45) + @"\");
         }
 
-
         /// <summary>
         /// Invalid candidate assembly files should not crash
         /// </summary>
@@ -1168,7 +1160,6 @@ public void NonExistentReference()
             Assert.Equal(0, String.Compare(ToolLocationHelper.GetPathToDotNetFrameworkFile("System.Xml.dll", TargetDotNetFrameworkVersion.Version45), t.ResolvedFiles[0].ItemSpec, StringComparison.OrdinalIgnoreCase));
         }
 
-
         /// <summary>
         /// Consider this situation.
         ///
@@ -2206,7 +2197,6 @@ public void GatherVersions410DotNet()
             Assert.Equal("v00001.0", ((string)returnedVersions[14].RegistryKey));
         }
 
-
         [Fact]
         public void GatherVersions40255DotNet()
         {
@@ -2371,7 +2361,6 @@ private void RemoveAssemblyFoldersExTestConditionRegistryKey()
             }
         }
 
-
         /// <summary>
         /// CandidateAssemblyFiles are extra files passed in through the CandidateAssemblyFiles
         /// that should be considered for matching when search paths contains {CandidateAssemblyFiles}
@@ -2393,7 +2382,6 @@ public void CandidateAssemblyFiles()
             Assert.Equal(Path.Combine(s_myVersion20Path, "System.Xml.dll"), t.ResolvedFiles[0].ItemSpec);
         }
 
-
         /// <summary>
         /// Make sure three part version numbers put on the required target framework do not cause a problem.
         /// </summary>
@@ -2861,7 +2849,6 @@ public void DuplicateEntries()
                 Assert.Empty(errorFileNames); // "Expected no Error file names"
                 Assert.Single(remap);
 
-
                 AssemblyRemapping pair = remap.First<AssemblyRemapping>();
                 Assert.Equal("Remapped", pair.To.Name);
                 Assert.False(pair.To.Retargetable);
@@ -2974,7 +2961,6 @@ public void ToElementButNoFrom()
             }
         }
 
-
         /// <summary>
         /// If a relative file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}
         /// then try to resolve directly to that file name and make it a full path.
@@ -3012,7 +2998,6 @@ public void RawFileNameRelative()
             }
         }
 
-
         /// <summary>
         /// If a relative searchPath is passed in through the search path parameter
         /// then try to resolve the file but make sure it is a full name
@@ -3198,7 +3183,6 @@ public void Regress444793()
             );
         }
 
-
         /// <summary>
         /// If a file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}
         /// then try to resolve directly to that file name.
@@ -3698,7 +3682,6 @@ public void ConflictGeneratesMessageReferencingAssemblyName()
             e.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "ResolveAssemblyReference.FoundConflicts", "D");
         }
 
-
         /// <summary>
         /// Consider this dependency chain:
         ///
@@ -3787,7 +3770,6 @@ public void ConflictWithForeVersionPrimary()
             Assert.True(ContainsItem(t.ResolvedDependencyFiles, s_myLibraries_V2_GDllPath));
         }
 
-
         /// <summary>
         /// Consider this dependency chain:
         ///
@@ -4002,7 +3984,6 @@ public void SpecificVersionAbsent()
             Assert.Empty(t.ResolvedFiles);
         }
 
-
         /// <summary>
         /// Unresolved primary references should result in warnings.
         /// </summary>
@@ -4029,7 +4010,6 @@ public void Regress199998()
             Assert.Equal(1, m.Warnings);
         }
 
-
         /// <summary>
         /// In this case,
         /// - A single primary file reference to simple name "A".
@@ -4267,7 +4247,6 @@ public void SimpleNameWithSpecificVersionFalse()
             Assert.True(ContainsItem(t.ResolvedFiles, @"c:\MyStronglyNamed\A.dll")); // "Expected to find assembly, but didn't."
         }
 
-
         /// <summary>
         /// Consider this situation:
         ///
@@ -4303,7 +4282,6 @@ public void IrrelevantAssemblyNameElement()
             Assert.True(ContainsItem(t.ResolvedFiles, s_myLibraries_V1_DDllPath)); // "Expected to find assembly, but didn't."
         }
 
-
         /// <summary>
         /// Regress EVERETT QFE 626
         /// Consider this dependency chain:
@@ -4520,13 +4498,10 @@ public void Regress275161_ScatterAssemblies()
 
             Assert.True(ContainsItem(t.ScatterFiles, @"C:\Regress275161\m1.netmodule")); //                 "Expected to find scatter file m1."
 
-
             Assert.True(ContainsItem(t.ScatterFiles, @"C:\Regress275161\m2.netmodule")); //                 "Expected to find scatter file m2."
 
-
             Assert.True(ContainsItem(t.CopyLocalFiles, @"C:\Regress275161\m1.netmodule")); //                 "Expected to find scatter file m1 in CopyLocalFiles."
 
-
             Assert.True(ContainsItem(t.CopyLocalFiles, @"C:\Regress275161\m2.netmodule")); //                 "Expected to find scatter file m2 in CopyLocalFiles."
         }
 
@@ -4669,7 +4644,6 @@ public void Regress313086_Part2_MscorlibAsRawFilename()
             Assert.Single(t.ResolvedFiles);
         }
 
-
         /// <summary>
         /// If a directory path is passed into AssemblyFiles, then we should warn and continue on.
         /// </summary>
@@ -4748,7 +4722,6 @@ public void RelativeAssemblyFiles()
             }
         }
 
-
         /// <summary>
         /// Behave gracefully if a referenced assembly is inaccessible to the user.
         /// </summary>
@@ -4803,7 +4776,6 @@ public void Regress316906_UnauthorizedAccessViolation_PrimaryFileIsInaccessible(
             Assert.Single(t.ResolvedFiles);
         }
 
-
         /// <summary>
         /// Behave gracefully if a referenced assembly is inaccessible to the user.
         /// </summary>
@@ -4821,7 +4793,6 @@ public void Regress316906_UnauthorizedAccessViolation_PrimaryAsRawFileIsInaccess
             };
             t.SearchPaths = new string[] { "{RawFileName}" };
 
-
             Execute(t);
 
             Assert.Equal(1, e.Warnings); // "One warning expected in this scenario."
@@ -4829,8 +4800,6 @@ public void Regress316906_UnauthorizedAccessViolation_PrimaryAsRawFileIsInaccess
             Assert.Empty(t.ResolvedFiles);
         }
 
-
-
         /// <summary>
         /// If there's a SearhPath like {Registry:,,} then still behave nicely.
         /// </summary>
@@ -4903,7 +4872,6 @@ public void Regress276548_AssemblyNameDifferentThanFusionName()
 
             Execute(t);
 
-
             Assert.Equal(0, e.Warnings); // "One warning expected in this scenario."
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Single(t.ResolvedFiles);
@@ -4945,13 +4913,11 @@ public void Regress314573_VeryLongPaths()
 
             Execute(t);
 
-
             Assert.Equal(1, e.Warnings); // "One warning expected in this scenario." // Couldn't find dependencies for {HintPathFromItem}-resolved item.
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Empty(t.ResolvedFiles);  // This test used to have 1 here. But that was because the mock GetAssemblyName was not accurately throwing an exception for non-existent files.
         }
 
-
         /// <summary>
         /// Need to be robust in the face of assembly names with special characters.
         /// </summary>
@@ -4974,7 +4940,6 @@ public void Regress265003_EscapedCharactersInFusionName()
             t.Assemblies[1].SetMetadata("HintPath", @"c:\MyEscapedName\__'ASP'dw0024ry.dll");
             t.TargetFrameworkDirectories = new string[] { Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName) };
 
-
             t.SearchPaths = new string[]
             {
                 @"{TargetFrameworkDirectory}",
@@ -4984,7 +4949,6 @@ public void Regress265003_EscapedCharactersInFusionName()
 
             Execute(t);
 
-
             Assert.Equal(0, e.Warnings); // "One warning expected in this scenario."
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Equal(2, t.ResolvedFiles.Length);
@@ -5023,7 +4987,6 @@ public void Regress284081_UnescapedCharactersInFusionNameWithHintPath()
 
             Execute(t);
 
-
             Assert.Equal(0, e.Warnings); // "No warning expected in this scenario."
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Single(t.ResolvedFiles);
@@ -5147,7 +5110,6 @@ public void Regress354669_HintPathWithTrailingSlash()
 
             t.Assemblies[0].SetMetadata("HintPath", @"C:\Regress354669\");
 
-
             t.SearchPaths = new string[]
             {
                 "{RawFileName}",
@@ -5240,7 +5202,6 @@ public void Regress_DogfoodCLRThrowsFileLoadException()
             Execute(t);
         }
 
-
         /// <summary>
         /// There was a bug in which any file mentioned in the InstalledAssemblyTables was automatically
         /// considered to be a file present in the framework directory. This assumption was originally true,
@@ -5312,7 +5273,6 @@ public void InvalidCharsInInstalledAssemblyTable()
                 new TaskItem("SomeAssembly")
             };
 
-
             t.TargetFrameworkDirectories = new string[] { @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx" };
             t.InstalledAssemblyTables = new TaskItem[] { new TaskItem("asdfasdfasjr390rjfiogatg~~!@@##$%$%%^&**()") };
 
@@ -5349,7 +5309,6 @@ public void Regress435487_FxFileResolvedByHintPathShouldByCopyLocal()
 
             t.Assemblies[0].SetMetadata("HintPath", @"C:\Regress435487\microsoft.build.engine.dll");
 
-
             t.SearchPaths = new string[]
             {
                 @"{HintPathFromItem}",
@@ -5415,7 +5374,6 @@ public void PartialNameMatchingFromRedist()
                 AssemblyNameExtension Av2 = new AssemblyNameExtension(v2);
                 AssemblyNameExtension Av3 = new AssemblyNameExtension(v3);
 
-
                 AssemblyTableInfo assemblyTableInfo = new AssemblyTableInfo(redistFile, "MyFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { assemblyTableInfo });
                 InstalledAssemblies installedAssemblies = new InstalledAssemblies(redistList);
@@ -5611,7 +5569,6 @@ private static string CreateGenericRedistList()
             return tempFile;
         }
 
-
         [Fact]
         public void GetRedistListPathsFromDisk_ThrowsArgumentNullException()
         {
@@ -5661,7 +5618,6 @@ public void RedistListGenerateBlackListEmptyAssemblyInfoWithRedistAssemblies()
                 List<string> whiteListErrorFileNames = new List<string>();
                 Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[0], whiteListErrors, whiteListErrorFileNames);
 
-
                 // Since there were no white list expect the black list to return null
                 Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
             }
@@ -5768,8 +5724,6 @@ public void RedistListNoSubsetListName()
                    "</FileList >";
                 File.WriteAllText(subsetFile, subsetListContents);
 
-
-
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
@@ -5868,8 +5822,6 @@ public void RedistListDifferentNameToSubSet()
                    "</FileList >";
                 File.WriteAllText(subsetFile, subsetListContents);
 
-
-
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
@@ -5987,7 +5939,7 @@ public void RedistListNoAssembliesinRedistList()
         [Fact]
         public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
         {
-            string redistFile = CreateGenericRedistList(); ;
+            string redistFile = CreateGenericRedistList(); 
             string goodSubsetFile = FileUtilities.GetTemporaryFile();
             try
             {
@@ -6240,7 +6192,6 @@ public void SubsetListFinderEmptySubsetToSearchFor()
             Assert.Empty(returnArray); // "Expected the array returned to be 0 length"
         }
 
-
         /// <summary>
         /// Verify that the method will not crash if there are empty string array elements
         /// </summary>
@@ -6554,7 +6505,6 @@ public void TestGenerateFrameworkName()
             installedSubSetTable = null;
             Assert.True(String.IsNullOrEmpty(ResolveAssemblyReference.GenerateSubSetName(null, installedSubSetTable)));
 
-
             targetFrameworks = new string[] { "Client", "Framework" };
             installedSubSetTable = new ITaskItem[] { new TaskItem("c:\\foo\\Mouse.xml"), new TaskItem("D:\\foo\\bar\\Man.xml") };
             Assert.Equal("Client, Framework, Mouse, Man", ResolveAssemblyReference.GenerateSubSetName(targetFrameworks, installedSubSetTable));
@@ -6638,7 +6588,6 @@ public void ReferenceTableDependentItemsInBlackList()
             VerifyReferenceTable(referenceTable, mockEngine, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, new string[] { warningMessage });
         }
 
-
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
         /// and enginePrimary->sqlDependencyReference: sqlDependencyReference is in black list
@@ -6709,7 +6658,6 @@ public void ReferenceTablePrimaryToPrimaryDependencyWithOneInBlackList()
             xmlPrimaryReference.AddSourceItems(enginePrimaryReference.GetSourceItems());
             xmlPrimaryReference.AddDependee(enginePrimaryReference);
 
-
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, null, null, xmlAssemblyName, enginePrimaryReference, null, null, xmlPrimaryReference);
 
@@ -6753,7 +6701,6 @@ public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
             xmlPrimaryReference.AddSourceItems(enginePrimaryReference.GetSourceItems());
             xmlPrimaryReference.AddDependee(enginePrimaryReference);
 
-
             dataDependencyReference.FullPath = "FullPath";
             dataDependencyReference.MakeDependentAssemblyReference(xmlPrimaryReference);
 
@@ -6762,7 +6709,6 @@ public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
 
             InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { dataAssemblyName }, out blackList);
 
-
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, dataAssemblyName.FullName, subsetName);
             string warningMessage2 = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem2.ItemSpec, dataAssemblyName.FullName, subsetName);
@@ -6821,7 +6767,6 @@ public void ReferenceTableDependentItemsInBlackList3()
             VerifyReferenceTable(referenceTable, mockEngine, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, new string[] { warningMessage, warningMessage2 });
         }
 
-
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
         /// and xmlPrimary->dataDependencyReference: sqlDependencyReference is in black list
@@ -6914,7 +6859,6 @@ public void ReferenceTableDependentItemsInBlackList5()
 
             InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out blackList);
 
-
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
             string warningMessage2 = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, dataAssemblyName.FullName, subsetName);
@@ -6936,7 +6880,6 @@ public void ReferenceTableDependentItemsInBlackList5()
             table.Clear();
         }
 
-
         /// <summary>
         /// Testing case
         /// enginePrimary -> dataDependencyReference   also enginePrimary->sqlDependencyReference   specific version = true on the primary
@@ -7191,7 +7134,6 @@ private void InitializeMockEngine(out ReferenceTable referenceTable, out MockEng
             referenceTable = MakeEmptyReferenceTable(rar.Log);
         }
 
-
         /// <summary>
         ///Initialize the black list and use it to remove references from the reference table
         /// </summary>
@@ -7477,7 +7419,6 @@ public void ResolveAssemblyReferenceVerifyFullClientName()
             }
         }
 
-
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
         /// black list is not used.
@@ -7513,7 +7454,6 @@ public void ResolveAssemblyReferenceVerifyFullClientNameWithSubsetTables()
             }
         }
 
-
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
         /// black list is not used.
@@ -7753,7 +7693,6 @@ public void Regress397129_HandleInvalidDirectoriesAndFiles_Case2()
 
             t.Assemblies[0].SetMetadata("HintPath", @"||invalidpath||");
 
-
             t.SearchPaths = new string[]
             {
                 @"{HintPathFromItem}"
@@ -7815,7 +7754,6 @@ public void Regress393931_AllowAlternateAssemblyExtensions_Case1()
                 new TaskItem("A")
             };
 
-
             t.SearchPaths = new string[]
             {
                 @"C:\Regress393931"
@@ -7848,7 +7786,6 @@ public void Regress393931_AllowAlternateAssemblyExtensions()
                 new TaskItem("A")
             };
 
-
             t.SearchPaths = new string[]
             {
                 @"C:\Regress393931"
@@ -7899,7 +7836,6 @@ public void SGenDependeicies()
             Assert.True(ContainsItem(t.SerializationAssemblyFiles, @"c:\SGenDependeicies\mycomponent2.XmlSerializers.dll")); // "Expected to find serialization assembly, but didn't."
         }
 
-
         /// <summary>
         /// Consider this dependency chain:
         ///
@@ -8283,7 +8219,6 @@ public void VerifyAssemblyInRedistListDiffVersion()
             }
         }
 
-
         /// <summary>
         /// Verify when we ask if an assembly is in the redist list we get the right answer.
         /// The public key is significant and should make the match not work
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
index 91fec5aa1a1..1f35cf0117a 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
@@ -76,7 +76,7 @@ public void DependeeDirectoryIsProbedForDependency()
                 bool succeeded = Execute(t);
 
                 Assert.True(succeeded);
-                ;
+                
                 uniqueFileExists[s_dependsOnNuGet_NWinMdPath].ShouldBe(1);
                 uniqueFileExists[s_dependsOnNuGet_NDllPath].ShouldBe(1);
                 uniqueFileExists[s_dependsOnNuGet_NExePath].ShouldBe(1);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 2ca9c3dfd74..a616a901069 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -322,7 +322,6 @@ internal void StopIOMonitoringAndAssert_Minimal_IOUse(int ioThreshold = 1)
                 }
             }
 
-
             uniqueFileExists = null;
             uniqueGetAssemblyName = null;
         }
@@ -344,7 +343,6 @@ internal void StopIOMonitoringAndAssert_Zero_IOUse()
                 }
             }
 
-
             // Check for zero IO in GetAssemblyName.
             foreach (var entry in uniqueGetAssemblyName)
             {
@@ -842,7 +840,6 @@ internal static bool FileExists(string path)
                 uniqueFileExists[lowerPath] = uniqueFileExists[lowerPath] + 1;
             }
 
-
             // First, MyMissingAssembly doesn't exist anywhere.
             if (path.IndexOf("MyMissingAssembly") != -1)
             {
@@ -854,7 +851,6 @@ internal static bool FileExists(string path)
                 path = Path.GetFullPath(path);
             }
 
-
             foreach (string file in s_existentFiles)
             {
                 if (String.Equals(path, file, StringComparison.OrdinalIgnoreCase))
@@ -863,7 +859,6 @@ internal static bool FileExists(string path)
                 }
             }
 
-
             // Everything else doesn't exist.
             return false;
         }
@@ -980,7 +975,6 @@ internal static string GetRuntimeVersion(string path)
             {
                 return "WindowsRuntime 1.0, Other V2.0.50727";
             }
-
             else if (String.Equals(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return "V2.0.50727";
@@ -1281,8 +1275,6 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
             {
                 return new AssemblyNameExtension("E, Version=0.0.0.0, Culture=neutral, PUBlicKeyToken=null");
             }
-
-
             if (String.Equals(path, s_unifyMeDll_V05Path, StringComparison.OrdinalIgnoreCase))
             {
                 throw new FileNotFoundException();
@@ -1302,8 +1294,6 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
             {
                 return new AssemblyNameExtension("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=" + AssemblyRef.EcmaPublicKey);
             }
-
-
             if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnEverettSystem, VersION=1.0.5000.0, Culture=neutral, PublicKeyToken=feedbeadbadcadbe");
@@ -1783,7 +1773,6 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
             return new AssemblyNameExtension(defaultName);
         }
 
-
         /// <summary>
         /// Cached implementation. Given an assembly name, crack it open and retrieve the list of dependent
         /// assemblies and  the list of scatter files.
@@ -2174,8 +2163,6 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                     new AssemblyNameExtension("mscorlib, VeRsIon=2.0.0.0, Culture=neuTRal, PublicKeyToken=b77a5c561934e089")
                 };
             }
-
-
             if (String.Equals(path, s_myLibraries_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
index f21876d03c3..d9daab826d4 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
@@ -114,7 +114,7 @@ public void HighVersionDoesntExist()
 
             t.BuildEngine = engine;
             t.Assemblies = assemblyNames;
-                t.SearchPaths = new string[] { s_myApp_V10Path, @"C:\Framework\Everett" }; ;
+                t.SearchPaths = new string[] { s_myApp_V10Path, @"C:\Framework\Everett" }; 
 
             bool succeeded = Execute(t);
 
diff --git a/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs b/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
index 349ae0014ca..c1de8787f55 100644
--- a/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
+++ b/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
@@ -49,7 +49,7 @@ private void TestResolveHelper(string itemSpec, string projectGuid, string packa
                 (resolvedProjectWithConfiguration == null) ? string.Empty : resolvedProjectWithConfiguration.GetMetadata("FullConfiguration"));
 
             Assert.Equal(expectedResult, result);
-            if (result == true)
+            if (result)
             {
                 Assert.Equal(expectedFullConfiguration, resolvedProjectWithConfiguration.GetMetadata("FullConfiguration"));
                 Assert.Equal(expectedConfiguration, resolvedProjectWithConfiguration.GetMetadata("Configuration"));
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index 72e60aa3539..8fe91a6d738 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -223,7 +223,6 @@ public void EmptyLanguage()
             mockLogger.AssertLogContains(String.Format(unformattedMessage, "Language"));
         }
 
-
         /// <summary>
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
@@ -539,7 +538,6 @@ public void BuildTaskDateCodeFactory()
                         </Target>
                     </Project>";
 
-
             MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
             mockLogger.AssertLogContains("Current Date and Time:");
             mockLogger.AssertLogDoesntContain("[[]]");
@@ -876,7 +874,6 @@ public bool Execute()
             mockLogger.AssertLogContains(unformattedMessage);
         }
 
-
         /// <summary>
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index 33e4a815a2f..9a77edb3002 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -16,7 +16,6 @@ namespace Microsoft.Build.UnitTests
 {
     sealed public class CreateCSharpManifestResourceName_Tests
     {
-
         private readonly ITestOutputHelper _testOutput;
 
         public CreateCSharpManifestResourceName_Tests(ITestOutputHelper output)
@@ -82,7 +81,6 @@ public void Regress172107()
                     null
                 );
 
-
             MemoryStream m = new MemoryStream();
             m.Write(new byte[] { 0x64, 0xc3, 0x61, 0x2e, 0x43, 0x6c, 0x61, 0x73, 0x73 }, 0, 9); // dÃa.Class in ANSI
             m.Flush();
@@ -97,8 +95,6 @@ public void Regress172107()
             Assert.Equal(className, result);
         }
 
-
-
         /// <summary>
         /// Test for a namespace that has UTF8 characters but there's no BOM at the start.
         ///
@@ -456,7 +452,6 @@ public void DependentUponConvention_DoesNotApplyToNonResx(bool explicitlySpecify
             }
         }
 
-
         /// <summary>
         /// Opt into DependentUpon convention and load the expected file properly when the file is in a subfolder.
         /// </summary>
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index d3146f9d584..ce70c6c1a2f 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -16,7 +16,6 @@ namespace Microsoft.Build.UnitTests
 {
     sealed public class CreateVisualBasicManifestResourceName_Tests
     {
-
         private readonly ITestOutputHelper _testOutput;
 
         public CreateVisualBasicManifestResourceName_Tests(ITestOutputHelper output)
diff --git a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
index f8375e81d89..03a50d12ec5 100644
--- a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
+++ b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
@@ -328,7 +328,6 @@ public void TestGeneralFrameworkMonikerGoodWithFrameworkInFallbackPaths()
                 Assert.Equal(".NET Framework 4.1", displayName);
             }
         }
-
     }
 }
 #endif
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index 52973541190..7c29e78e789 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -404,7 +404,6 @@ static void Main(string[] args)
                 }
                 ");
 
-
             // -------------------------------------------------------
             // TeamBuild.proj
             // -------------------------------------------------------
@@ -550,7 +549,6 @@ public void DifferentGlobalPropertiesWithoutDefault()
             }
         }
 
-
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
@@ -606,7 +604,6 @@ public void DifferentGlobalPropertiesWithBlanks()
             }
         }
 
-
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
@@ -711,7 +708,6 @@ public void DifferentAdditionalPropertiesWithDefault()
             }
         }
 
-
         /// <summary>
         /// Check if passing additional global properties via metadata works
         /// </summary>
@@ -770,7 +766,6 @@ public void DifferentAdditionalPropertiesWithGlobalProperties()
             }
         }
 
-
         /// <summary>
         /// Check if passing additional global properties via metadata works
         /// </summary>
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 41bedd6cf66..613c44e048d 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -297,7 +297,7 @@ public void CheckIsExistingProjectReference()
 
             // find the Ax ref, matching with aximp types - should find it
             retValue = rcr.IsExistingProjectReference(axAttr, ComReferenceTypes.aximp, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == axRefInfo); // "ActiveX ref should be found for aximp ref types"
+            Assert.True(retValue && referenceInfo == axRefInfo); // "ActiveX ref should be found for aximp ref types"
 
             // find the Ax ref, matching with tlbimp types - should NOT find it
             retValue = rcr.IsExistingProjectReference(axAttr, ComReferenceTypes.tlbimp, out referenceInfo);
@@ -306,11 +306,11 @@ public void CheckIsExistingProjectReference()
 
             // find the Tlb ref, matching with any type of reference - should find it
             retValue = rcr.IsExistingProjectReference(tlbAttr, null, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == tlbRefInfo); // "Tlb ref should be found for any type of ref"
+            Assert.True(retValue && referenceInfo == tlbRefInfo); // "Tlb ref should be found for any type of ref"
 
             // find the Tlb ref, matching with tlbimp types - should find it
             retValue = rcr.IsExistingProjectReference(tlbAttr, ComReferenceTypes.tlbimp, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == tlbRefInfo); // "Tlb ref should be found for tlbimp ref types"
+            Assert.True(retValue && referenceInfo == tlbRefInfo); // "Tlb ref should be found for tlbimp ref types"
 
             // find the Tlb ref, matching with pia types - should NOT find it
             retValue = rcr.IsExistingProjectReference(tlbAttr, ComReferenceTypes.primary, out referenceInfo);
@@ -319,11 +319,11 @@ public void CheckIsExistingProjectReference()
 
             // find the Pia ref, matching with any type of reference - should find it
             retValue = rcr.IsExistingProjectReference(piaAttr, null, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == piaRefInfo); // "Pia ref should be found for any type of ref"
+            Assert.True(retValue && referenceInfo == piaRefInfo); // "Pia ref should be found for any type of ref"
 
             // find the Pia ref, matching with pia types - should find it
             retValue = rcr.IsExistingProjectReference(piaAttr, ComReferenceTypes.primary, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == piaRefInfo); // "Pia ref should be found for pia ref types"
+            Assert.True(retValue && referenceInfo == piaRefInfo); // "Pia ref should be found for pia ref types"
 
             // find the Pia ref, matching with pia types - should NOT find it
             retValue = rcr.IsExistingProjectReference(piaAttr, ComReferenceTypes.aximp, out referenceInfo);
@@ -356,15 +356,15 @@ public void CheckIsExistingDependencyReference()
 
             // find the Ax ref - should find it
             bool retValue = rcr.IsExistingDependencyReference(axAttr, out ComReferenceInfo referenceInfo);
-            Assert.True(retValue == true && referenceInfo == axRefInfo); // "ActiveX ref should be found"
+            Assert.True(retValue && referenceInfo == axRefInfo); // "ActiveX ref should be found"
 
             // find the Tlb ref - should find it
             retValue = rcr.IsExistingDependencyReference(tlbAttr, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == tlbRefInfo); // "Tlb ref should be found"
+            Assert.True(retValue && referenceInfo == tlbRefInfo); // "Tlb ref should be found"
 
             // find the Pia ref - should find it
             retValue = rcr.IsExistingDependencyReference(piaAttr, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == piaRefInfo); // "Pia ref should be found"
+            Assert.True(retValue && referenceInfo == piaRefInfo); // "Pia ref should be found"
 
             // try to find a non existing reference - should not find it
             retValue = rcr.IsExistingDependencyReference(notInProjectAttr, out referenceInfo);
diff --git a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
index 5e3385a4c34..b21f5de108b 100644
--- a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
@@ -107,7 +107,7 @@ private void TestResolveHelper(string itemSpec, string projectGuid, string packa
                 itemSpec, projectGuid, package, name, xmlString, expectedResult, result, expectedPath, resolvedPath);
 
             Assert.Equal(result, expectedResult);
-            if (result == true)
+            if (result)
             {
                 Assert.Equal(resolvedPath.ItemSpec, expectedPath);
             }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index b3c46b3889b..f1aee6a9f23 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -364,7 +364,6 @@ public void ForceOutOfDateByDeletion()
             Utilities.AssertLogContainsResource(t2, "GenerateResource.ResourceNotFound", t2.Sources[0].ItemSpec);
         }
 
-
         /// <summary>
         ///  Force out-of-date with ShouldRebuildResgenOutputFile on the linked file
         /// </summary>
@@ -803,7 +802,6 @@ public void NothingOutOfDateExceptReference()
 
                 File.GetLastWriteTime(incrementalUpToDate.OutputResources[0].ItemSpec).ShouldBe(firstWriteTime);
 
-
                 _output.WriteLine("** Touch the reference, and repeat, it should now rebuild");
                 DateTime newTime = DateTime.Now + new TimeSpan(0, 1, 0);
                 File.SetLastWriteTime(localSystemDll, newTime);
@@ -1455,7 +1453,6 @@ public void StronglyTypedResourcesEmitTypeIntoClass()
                 generatedSource.ShouldNotContain("object MyString", "Strongly-typed resource accessor is returning type `object` instead of `string`");
                 generatedSource.ShouldContain("static string MyString");
                 generatedSource.ShouldMatch("//.*Looks up a localized string similar to MyValue", "Couldn't find a comment in the usual format for a string resource.");
-
             }
             finally
             {
@@ -1471,7 +1468,6 @@ public void StronglyTypedResourcesEmitTypeIntoClass()
             }
         }
 
-
         /// <summary>
         ///  STR with resource namespace yields proper output, message (CS)
         /// </summary>
@@ -3315,7 +3311,6 @@ public void ResxValueNewlines(string newline)
             }
             finally
             {
-
                 File.Delete(t.Sources[0].ItemSpec);
                 foreach (ITaskItem item in t.FilesWritten)
                 {
@@ -3373,7 +3368,6 @@ GenerateResource ExecuteTask()
                 Utilities.FileUpdated(resourcesFile, initialWriteTime).ShouldBeFalse();
             }
         }
-
     }
 }
 
@@ -3890,7 +3884,6 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
                     Assert.Contains("namespace " + classNamespace.ToLower(), Utilities.ReadFileContent(STRFile).ToLower());
                 }
 
-
                 // Verify log is as expected
                 Utilities.AssertLogContainsResource(t, "GenerateResource.ProcessingFile", textFile, resourcesFile);
                 Utilities.AssertLogContainsResource(t, "GenerateResource.ReadResourceMessage", 4, textFile);
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs b/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
index 3bf41699346..62414fb64cf 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
@@ -139,6 +139,5 @@ read any of the formats listed below.
 
         private const string FinalBoilerplate = @"</root>
 ";
-
     }
 }
diff --git a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
index d2756b09680..96ccee06a50 100644
--- a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
+++ b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
@@ -155,6 +155,5 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
                 base.AddResponseFileCommands(commandLine);
             }
         }
-
     }
 }
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index 7e96b14814a..ab6b6c95d2b 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -12,7 +12,6 @@
 
 namespace Microsoft.Build.Tasks.UnitTests
 {
-
     public sealed class WriteLinesToFile_Tests
     {
         private readonly ITestOutputHelper _output;
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index ffc77ba7845..88473de9a22 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -36,7 +36,7 @@ internal enum CopyLocalState
         NoBecausePrerequisite,
 
         /// <summary>
-        /// The Reference should be CopyLocal='false' because the the Private attribute is set to 'false' in the project. 
+        /// The Reference should be CopyLocal='false' because the Private attribute is set to 'false' in the project. 
         /// </summary>
         NoBecauseReferenceItemHadMetadata,
 
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index b3d531e909d..49c33f3f5ac 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -113,7 +113,6 @@ public override bool Execute()
                     {
                         writeOutput = false;
                     }
-
                 }
                 catch(System.Xml.XmlException)
                 {
@@ -121,7 +120,6 @@ public override bool Execute()
                 }
             }
 
-
             if (AppConfigFile != null)
             {
                 AppConfigFile.CopyMetadataTo(OutputAppConfigFile);
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index 69e0aeeea4f..e435966cd5e 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -240,7 +240,6 @@ internal void RemoveDependency(Reference dependencyToRemove)
             _dependencies.Remove(dependencyToRemove);
         }
 
-
         /// <summary>
         /// Get the dependee references for this reference.
         ///  This is collection of References.
@@ -565,7 +564,6 @@ internal string FullPathWithoutExtension
             }
         }
 
-
         /// <summary>
         /// This is the HintPath from the source item. This is used to resolve the assembly.
         /// </summary>
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 344c40c092d..dbe99f99bc2 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -378,7 +378,6 @@ internal void AddReference(AssemblyNameExtension assemblyName, Reference referen
             References[assemblyName] = reference;
         }
 
-
         /// <summary>
         /// Find the reference that corresponds to the given path.
         /// </summary>
@@ -588,7 +587,6 @@ ITaskItem referenceAssemblyName
                 }
             }
 
-
             // Embed Interop Types aka "NOPIAs" support is not available for Fx < 4.0
             // So, we just ignore this setting on down-level platforms
             if (_projectTargetFramework != null && _projectTargetFramework >= s_targetFrameworkVersion_40)
@@ -1634,7 +1632,6 @@ private void ComputeClosure()
                     ErrorUtilities.VerifyThrow(dependencyIterations < maxIterations, "Maximum iterations exceeded while looking for dependencies.");
                 } while (moreDependencies);
 
-
                 // If everything is either resolved or unresolvable, then we can quit.
                 // Otherwise, loop again.
                 moreResolvable = false;
@@ -1924,7 +1921,7 @@ out List<AssemblyNameReference> conflictingReferences
 
         /// <summary>
         /// If a reference is a higher version than what exists in the redist list of the target framework then 
-        /// this reference needs to be marked as excluded so that it is not not allowed to be referenced. 
+        /// this reference needs to be marked as excluded so that it is not allowed to be referenced. 
         /// 
         /// If the user needs this reference then they need to set specific version to true.
         /// </summary>
@@ -2196,7 +2193,6 @@ Dictionary<string, List<AssemblyNameReference>> baseNameToReferences
                 if (baseNameToReferences[baseName].Count == 1)
                 {
                     baseNameToReferences.Remove(baseName);
-
                 }
             }
         }
@@ -2414,7 +2410,6 @@ out redistName
                 }
             }
 
-
             return false;
         }
 
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 61e2a6a93e5..246ac9e5525 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -246,7 +246,7 @@ public string[] TargetFrameworkSubsets
         ///         when false, any assembly with the same simple name will be a match.
         ///         when absent, then look at the value in Include. 
         ///           If its a simple name then behave as if specific version=false.
-        ///           If its a strong name name then behave as if specific version=true.
+        ///           If its a strong name then behave as if specific version=true.
         ///     string ExecutableExtension [default=absent] -- 
         ///         when present, the resolved assembly must have this extension.
         ///         when absent, .dll is considered and then .exe for each directory looked at.
@@ -496,7 +496,6 @@ public string[] AllowedAssemblyExtensions
             set { _allowedAssemblyExtensions = value; }
         }
 
-
         /// <summary>
         /// [default=.pdb;.xml]
         /// These are the extensions that will be considered when looking for related files.
@@ -507,7 +506,6 @@ public string[] AllowedRelatedFileExtensions
             set { _relatedFileExtensions = value; }
         }
 
-
         /// <summary>
         /// If this file name is passed in, then we parse it as an app.config file and extract bindingRedirect mappings. These mappings are used in the dependency
         /// calculation process to remap versions of assemblies.
@@ -563,7 +561,6 @@ public bool AutoUnify
             set { _autoUnify = value; }
         }
 
-
         /// <summary>
         ///  When determining if a dependency should be copied locally one of the checks done is to see if the 
         ///  parent reference in the project file has the Private metadata set or not. If that metadata is set then 
@@ -905,7 +902,6 @@ public String DependsOnNETStandard
             private set;
         }
 
-
         #endregion
         #region Logging
 
@@ -1408,7 +1404,6 @@ private void LogInputs()
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", latestFolder);
                 }
 
-
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "ProfileTablesLocation");
                 foreach (ITaskItem profileTable in FullFrameworkAssemblyTables)
                 {
@@ -1602,7 +1597,6 @@ private void LogAssembliesConsideredAndRejected(Reference reference, string fusi
                         }
                     }
 
-
                     // If this is a new search location, then show the message.
                     if (lastSearchPath != location.SearchPath)
                     {
@@ -1770,7 +1764,6 @@ private void LogCopyLocalState(Reference reference, MessageImportance importance
             }
         }
 
-
         /// <summary>
         /// Log a message about the imageruntime information.
         /// </summary>
@@ -1964,7 +1957,6 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         }
                     }
 
-
                     // Validate the contents of the InstalledAssemblyTables parameter.
                     AssemblyTableInfo[] installedAssemblyTableInfo = GetInstalledAssemblyTableInfo(_ignoreDefaultInstalledAssemblyTables, _installedAssemblyTables, new GetListPath(RedistList.GetRedistListPathsFromDisk), TargetFrameworkDirectories);
                     AssemblyTableInfo[] whiteListSubsetTableInfo = null;
@@ -2197,7 +2189,6 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             dependencyTable.RemoveReferencesMarkedForExclusion(true /* Remove the reference and do not warn*/, subsetOrProfileName);
                         }
 
-
                         // Based on the closure, get a table of ideal remappings needed to 
                         // produce zero conflicts.
                         dependencyTable.ResolveConflicts
@@ -2469,7 +2460,6 @@ private static IReadOnlyCollection<DependentAssembly> CombineRemappedAssemblies(
             return combined;
         }
 
-
         /// <summary>
         /// If a targeted runtime is passed in use that, if none is passed in then we need to use v2.0.50727
         /// since the common way this would be empty is if we were using RAR as an override task.
@@ -2672,7 +2662,6 @@ private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableIn
             }
         }
 
-
         /// <summary>
         /// Determine if a black list should be used or not
         /// 
@@ -2725,7 +2714,7 @@ private bool ShouldUseSubsetBlackList()
         /// Populates the suggested redirects output parameter.
         /// </summary>
         /// <param name="idealAssemblyRemappings">The list of ideal remappings.</param>
-        /// <param name="idealAssemblyRemappedReferences">The list of of references to ideal assembly remappings.</param>
+        /// <param name="idealAssemblyRemappedReferences">The list of references to ideal assembly remappings.</param>
         private void PopulateSuggestedRedirects(List<DependentAssembly> idealAssemblyRemappings, List<AssemblyNameReference> idealAssemblyRemappedReferences)
         {
             var holdSuggestedRedirects = new List<ITaskItem>();
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 089a8c03a31..658f9f4693d 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -2092,7 +2092,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     }
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
-                    if (publicKey == null || !publicKey.ToLowerInvariant().Equals(publicKeyAttribute.Value.ToLowerInvariant()))
+                    if (publicKey == null || !publicKey.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase))
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
                     }
@@ -2105,7 +2105,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     ReplaceAttribute(packageFileNode, HASH_ATTRIBUTE, fileHash);
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
-                    if (!fileHash.ToLowerInvariant().Equals(hashAttribute.Value.ToLowerInvariant()))
+                    if (!fileHash.Equals(hashAttribute.Value, StringComparison.OrdinalIgnoreCase))
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", "Hash", builder.Name, fileSource));
                     }
diff --git a/src/Tasks/CreateManifestResourceName.cs b/src/Tasks/CreateManifestResourceName.cs
index 89f9d51c851..f53eee09666 100644
--- a/src/Tasks/CreateManifestResourceName.cs
+++ b/src/Tasks/CreateManifestResourceName.cs
@@ -64,7 +64,6 @@ public ITaskItem[] ResourceFiles
         /// The resulting manifest names.
         /// </summary>
         /// <value></value>
-
         [Output]
         public ITaskItem[] ManifestResourceNames { get; private set; }
 
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index 35db2490c74..df817422bfd 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -617,7 +617,6 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
 
                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);
             }
-            
         }
 
         #endregion
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index f6e8010e4e9..c979b21be5b 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -148,7 +148,6 @@ public FileDirInfo(string filename)
                             IsReadOnly = fileInfo.IsReadOnly;
                             LastWriteTimeUtc = fileInfo.LastWriteTimeUtc;
                             Length = fileInfo.Length;
-
                         }
                         else
                         {
@@ -162,7 +161,6 @@ public FileDirInfo(string filename)
                                 IsReadOnly = false;
                                 LastWriteTimeUtc = directoryInfo.LastWriteTimeUtc;
                             }
-
                         }
                     }
                 }
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index b75684fbd98..7b9c1287d0a 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -28,7 +28,6 @@ private enum DependencyType { Install, Prerequisite };
         protected abstract bool OnManifestResolved(Manifest manifest);
         protected abstract Type GetObjectType();
 
-
         protected GenerateManifestBase() : base(AssemblyResources.PrimaryResources, "MSBuild.")
         {
         }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 651174fa26f..c5e9da0abaa 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -50,7 +50,6 @@ namespace Microsoft.Build.Tasks
     public sealed partial class GenerateResource : TaskExtension
     {
 
-
 #region Fields
 
         // This cache helps us track the linked resource files listed inside of a resx resource file
@@ -692,7 +691,6 @@ public override bool Execute()
                     Sources = newSources.ToArray();
                 }
 
-
                 // If there are no sources to process, just return (with success) and report the condition.
                 if ((Sources == null) || (Sources.Length == 0))
                 {
@@ -1136,7 +1134,6 @@ private bool GenerateResourcesUsingResGen(List<ITaskItem> inputsToProcess, List<
 #endif
         }
 
-
 #if FEATURE_RESGEN
         /// <summary>
         /// Given an instance of the ResGen task with everything but the strongly typed
@@ -3321,7 +3318,6 @@ private void WriteResources(ReaderInfo reader, String filename)
 #endif
                     break;
 
-
                 case Format.Assembly:
                     _logger.LogErrorFromResources("GenerateResource.CannotWriteAssembly", filename);
                     break;
@@ -3718,7 +3714,6 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
             }
         }
 
-
         /// <summary>
         /// Write resources to an XML or binary format resources file.
         /// </summary>
@@ -3820,7 +3815,6 @@ private void AddResource(ReaderInfo reader, IResource entry, String inputFileNam
             reader.resourcesHashTable.Add(entry.Name, entry);
         }
 
-
         /// <summary>
         /// Add a resource from an XML or binary format file to the internal data structures
         /// </summary>
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 4393c520267..a4ae9a93ca9 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -606,7 +606,7 @@ private void GatherReferenceAssemblies(HashSet<ResolvedReferenceAssembly> resolv
         }
 
         /// <summary>
-        /// Gather the redist files from from the redist directory.
+        /// Gather the redist files from the redist directory.
         /// </summary>
         private void GatherRedistFiles(HashSet<ResolvedRedistFile> resolvedRedistFiles, ITaskItem sdkReference, string redistFilePath, SDKInfo info)
         {
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 655ac5b8e9b..e6b3d7a91ce 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -194,7 +194,6 @@ public bool IsClickOnceManifest
             set => _isClickOnceManifest = value;
         }
 
-
         /// <summary>
         /// Specifies the maximum allowable length of a file path in a ClickOnce application deployment.
         /// If this value is specified, then the length of each file path in the application is checked against this limit.
@@ -414,7 +413,7 @@ private void ValidateCom()
             {
                 if (assembly.ReferenceType == AssemblyReferenceType.NativeAssembly && !assembly.IsPrerequisite && !String.IsNullOrEmpty(assembly.ResolvedPath))
                 {
-                    ComInfo[] comInfoArray = ManifestReader.GetComInfo(assembly.ResolvedPath); ;
+                    ComInfo[] comInfoArray = ManifestReader.GetComInfo(assembly.ResolvedPath); 
                     if (comInfoArray != null)
                     {
                         foreach (ComInfo comInfo in comInfoArray)
diff --git a/src/Tasks/ManifestUtil/AssemblyReference.cs b/src/Tasks/ManifestUtil/AssemblyReference.cs
index 7864b0cbc33..81c741db55d 100644
--- a/src/Tasks/ManifestUtil/AssemblyReference.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReference.cs
@@ -102,7 +102,6 @@ public AssemblyReferenceType ReferenceType
             set { _referenceType = value; }
         }
 
-
         /// <summary>
         /// True if the reference is specified in the project file, false if it is added to the manifest as a result
         /// of computing the closure of all project references.
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index da358580c54..f5f16fe3354 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -232,7 +232,6 @@ private static string GetInstallableFramework(string redistListFilePath)
             return installableFramework;
         }
 
-
         private static CompatibleFramework GetSubsetCompatFramework(FrameworkNameVersioning frameworkName)
         {
             CompatibleFramework compat = GetFullCompatFramework(frameworkName);
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index e6cd1009e34..bbba6bb4f2c 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -200,7 +200,6 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
             //      <requestedExecutionLevel level="asInvoker" />
             //  </requestedPrivileges>
 
-
             // we always create a requestedPrivilege node to put into the generated TrustInfo document
             //
             XmlElement requestedPrivilegeElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.requestedPrivilegeElement), XmlNamespaces.asmv3);
@@ -232,7 +231,7 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
                 //  here so we can allow the passed-in node to override it if there is a comment present
                 //
                 System.Resources.ResourceManager resources = new System.Resources.ResourceManager("Microsoft.Build.Tasks.Core.Strings.ManifestUtilities", typeof(SecurityUtilities).Module.Assembly);
-                commentString = resources.GetString("TrustInfo.RequestedExecutionLevelComment"); ;
+                commentString = resources.GetString("TrustInfo.RequestedExecutionLevelComment"); 
             }
             else
             {
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index ccd5e63d346..6e081717785 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -510,7 +510,6 @@ int IComparer.Compare(object obj1, object obj2)
         }
         #endregion
 
-
         public static Version ConvertFrameworkVersionToString(string version)
         {
             if (version.StartsWith("v", StringComparison.OrdinalIgnoreCase))
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index d7a6ae38e71..d7fb13512ae 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -66,7 +66,6 @@ internal static class Win32
         internal const int TRUST_E_EXPLICIT_DISTRUST = unchecked((int)0x800B0111);
         internal const int CERT_E_CHAINING = unchecked((int)0x800B010A);
 
-
         // Values for dwFlags of CertVerifyAuthenticodeLicense.
         internal const int AXL_REVOCATION_NO_CHECK = unchecked((int)0x00000001);
         internal const int AXL_REVOCATION_CHECK_END_CERT_ONLY = unchecked((int)0x00000002);
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 9bc15d0aed2..a3e41bc1005 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -169,7 +169,7 @@ public bool IsPrerequisiteAssembly(string assemblyName)
         }
 
         /// <summary>
-        /// If there was a remapping entry in the redist list list then remap the passed in assemblynameextension 
+        /// If there was a remapping entry in the redist list then remap the passed in assemblynameextension 
         /// if not just return the original one. 
         /// </summary>
         public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRemap)
@@ -959,7 +959,7 @@ internal class SubsetListFinder
         /// files exist.
         /// </summary>
         /// <param name="subsetToSearchFor">String array of subset names, ie  Client, Net, MySubset. This may be null or empty if no subsets were requested to be 
-        /// found in the target framework directories. This can happen if the the subsets are instead passed in as InstalledDefaultSubsetTables</param>
+        /// found in the target framework directories. This can happen if the subsets are instead passed in as InstalledDefaultSubsetTables</param>
         internal SubsetListFinder(string[] subsetToSearchFor)
         {
             ErrorUtilities.VerifyThrowArgumentNull(subsetToSearchFor, nameof(subsetToSearchFor));
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index c3e29dd3c96..f6741aa36d2 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -84,7 +84,6 @@ private static UInt64 HashFromBlob(byte[] data)
             return result;
         }
 
-
         private bool ResolveAssemblyKey()
         {
             bool pfxSuccess = true;
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index d2d62c26564..1ba945d1c76 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -347,6 +347,5 @@ internal static string[] ParseResxFileRefString(string stringValue)
             }
             return result;
         }
-
     }
 }
diff --git a/src/Tasks/System.Design.cs b/src/Tasks/System.Design.cs
index ff9adc9c4b8..8f032bbf49b 100644
--- a/src/Tasks/System.Design.cs
+++ b/src/Tasks/System.Design.cs
@@ -9,7 +9,6 @@
 using System.Threading;
 using System.Security.Permissions;
 
-
 using System.ComponentModel;
 
 namespace Microsoft.Build.Tasks
@@ -62,13 +61,11 @@ protected override string GetLocalizedString(string value)
         }
     }
 
-
     /// <summary>
     ///    AutoGenerated resource class. Usage:
     ///
     ///        string s = SR.GetString(SR.MyIdenfitier);
     /// </summary>
-
     internal sealed class SR
     {
         internal const string ClassDocComment = "ClassDocComment";
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 10fe9859407..08f4516bc67 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -33,7 +33,6 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// </summary>
         private Hashtable instanceLocalFileStateCache = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
-
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
         /// cache this for long periods of time since there's no way (without actually 
@@ -48,7 +47,6 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// </summary>
         private Dictionary<string, bool> instanceLocalDirectoryExists = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
 
-
         /// <summary>
         /// GetDirectories information is also purely instance-local. This information
         /// is only considered good for the lifetime of the task (or whatever) that owns 
@@ -371,7 +369,6 @@ private FileState GetFileState(string path)
             upToDateLocalFileStateCache.TryGetValue(path, out FileState state);
             if (state == null)
             {   // We haven't seen this file this ResolveAssemblyReference session
-
                 state = ComputeFileStateFromCachesAndDisk(path);
                 upToDateLocalFileStateCache[path] = state;
             }
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index 50f1c3872cd..f6a3506e981 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -474,7 +474,6 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
                             }
                         }
                     }
-
                     else if (String.Equals(child.Name, includedPlatformType, StringComparison.OrdinalIgnoreCase))
                     {
                         foreach (XmlAttribute attrib in child.Attributes)
diff --git a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
index 80543f08545..562468ff8ec 100644
--- a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
+++ b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
@@ -467,7 +467,6 @@ public void TestVerifyThrowElse()
             }
            );
         }
-
         
     }
 
diff --git a/src/Utilities.UnitTests/MuxLogger_Tests.cs b/src/Utilities.UnitTests/MuxLogger_Tests.cs
index f4bdda15924..21fcfb9f78c 100644
--- a/src/Utilities.UnitTests/MuxLogger_Tests.cs
+++ b/src/Utilities.UnitTests/MuxLogger_Tests.cs
@@ -313,14 +313,12 @@ public void RegisteringLoggerDuringBuildThrowsException()
 
                     // This call should throw an InvalidOperationException
                     muxLogger.RegisterLogger(submission.SubmissionId, mockLogger);
-
                 }
                 finally
                 {
                     buildManager.EndBuild();
                 }
             });
-
         }
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index 124ef58cb6b..26cb7e3fdf1 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -180,7 +180,6 @@ public void CheckMetadataCount()
             t.MetadataCount.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length + 1);
         }
 
-
         [Fact]
         public void NonexistentRequestFullPath()
         {
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index d00a76bda0d..2344361b235 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -18,8 +18,6 @@
 using Microsoft.Win32;
 #endif
 
-
-
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using UtilitiesDotNetFrameworkArchitecture = Microsoft.Build.Utilities.DotNetFrameworkArchitecture;
 using SharedDotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
@@ -754,7 +752,6 @@ public void TestGetPathToBuildToolsFile_32Bit()
             ToolLocationHelper.GetPathToDotNetFrameworkFile("msbuild.exe", TargetDotNetFrameworkVersion.Version40, UtilitiesDotNetFrameworkArchitecture.Bitness32).ShouldBe(
                     ToolLocationHelper.GetPathToBuildToolsFile("msbuild.exe", "4.0", UtilitiesDotNetFrameworkArchitecture.Bitness32));
 
-
             var toolsPath32 = ProjectCollection.GlobalProjectCollection.GetToolset(ObjectModelHelpers.MSBuildDefaultToolsVersion).Properties["MSBuildToolsPath32"];
             string tv12path = Path.Combine(Path.GetFullPath(toolsPath32.EvaluatedValue), "msbuild.exe");
 
@@ -834,7 +831,6 @@ public void TestGetDotNetFrameworkSdkRootRegistryKey()
             Should.Throw<ArgumentException>( () => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version46, VisualStudioVersion.Version120) );
             ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version46, VisualStudioVersion.Version140).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK46);
 
-
             // v4.6.1
             Should.Throw<ArgumentException>( () => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version461, VisualStudioVersion.Version100) );
             Should.Throw<ArgumentException>( () => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version461, VisualStudioVersion.Version110) );
@@ -1728,7 +1724,6 @@ public void GetPathToReferenceAssembliesWithRootGoodWithChain()
             string framework39redistDirectory = Path.Combine(framework39Directory, "RedistList");
             string framework39RedistList = Path.Combine(framework39redistDirectory, "FrameworkList.xml");
 
-
             try
             {
                 Directory.CreateDirectory(framework41redistDirectory);
@@ -1739,7 +1734,6 @@ public void GetPathToReferenceAssembliesWithRootGoodWithChain()
                 File.WriteAllText(framework40RedistList, redistString40);
                 File.WriteAllText(framework41RedistList, redistString41);
 
-
                 FrameworkNameVersioning frameworkName = new FrameworkNameVersioning("MyFramework", new Version("4.1"));
                 IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(tempDirectory, frameworkName);
 
@@ -1823,7 +1817,6 @@ public void DisplayNameGeneration()
             }
         }
 
-
         /// <summary>
         /// Make sure we do not crash if there is a circular reference in the redist lists, we should only have a path in our reference assembly list once.
         ///
@@ -1859,7 +1852,6 @@ public void GetPathToReferenceAssembliesWithRootCircularReference()
                 File.WriteAllText(framework40RedistList, redistString40);
                 File.WriteAllText(framework41RedistList, redistString41);
 
-
                 FrameworkNameVersioning frameworkName = new FrameworkNameVersioning("MyFramework", new Version("4.1"));
                 IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(tempDirectory, frameworkName);
 
@@ -2132,7 +2124,6 @@ public void LegacyFramework30WithNo20Installed()
             list[1].ShouldBe(LegacyFrameworkTestHelper.DotNet30FrameworkPath, StringCompareShould.IgnoreCase);
         }
 
-
         /// <summary>
         /// Verify when 35 is simulated to be installed that the method returns the 3.5 directory
         /// </summary>
@@ -2170,7 +2161,6 @@ public void LegacyFramework35NotInstalled()
             list.Count.ShouldBe(0);
         }
 
-
         /// <summary>
         /// Verify when 35 reference assembly are simulated to not be installed that the method returns an empty list
         /// </summary>
@@ -3382,7 +3372,6 @@ public void VerifySDKManifest()
 
                 string manifestFile = Path.Combine(manifestPath, "SDKManifest.xml");
 
-
                 string manifestPlatformSDK = @"
                 <FileList
                     DisplayName = ""Windows""
@@ -3450,7 +3439,6 @@ public void VerifySDKManifest()
                     </File>
                 </FileList>";
 
-
                 File.WriteAllText(manifestFile, manifestExtensionSDK);
                 sdkManifest = new SDKManifest(manifestPath);
 
@@ -3830,7 +3818,6 @@ public void VerifyGetInstalledSDKLocations3()
                     folderKey.SetValue("", Path.Combine(testDirectoryRoot, platformDirectory));
                 }
 
-
                 if (Directory.Exists(testDirectoryRoot))
                 {
                     FileUtilities.DeleteDirectoryNoThrow(testDirectoryRoot, true);
@@ -4237,7 +4224,6 @@ public void VerifyFindRootFolderWhereAllFilesExist()
             ToolLocationHelper.FindRootFolderWhereAllFilesExist(@"c:<>;" + roots, "file1.txt").ShouldBe(rootDirectories[0]); // should ignore invalid dir
         }
 
-
 #if FEATURE_REGISTRY_SDKS
         /// <summary>
         /// Verify that the GetPlatformSDKPropsFileLocation method can be correctly called for pre-OneCore SDKs during evaluation time as a msbuild function.
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 78c523c03ed..d8c69b18f9e 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -856,6 +856,5 @@ protected override string GenerateCommandLineCommands()
                 return $"echo ÅoÅ > {OutputPath}";
             }
         }
-
     }
 }
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index a1654a3ea8e..1ab61732c78 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -2226,7 +2226,6 @@ public void LaunchMultipleOfSameTool_DifferentContexts()
             {
                 FileUtilities.DeleteDirectoryNoThrow(testDir, true);
             }
-
         }
 
         [Fact(Skip = "Needs investigation")]
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index e5dd41f43bb..cb671c25576 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -12,8 +12,6 @@
 using Microsoft.Build.Utilities;
 using Xunit;
 
-
-
 #pragma warning disable 0219
 
 #if FEATURE_FILE_TRACKER
@@ -1235,7 +1233,6 @@ public void MultipleCanonicalCLMissingOutputDependencyRemoved()
             Assert.Empty(outofDate);
         }
 
-
         [Fact]
         public void MultipleCanonicalCLMissingInputDependencyRemoved()
         {
@@ -1302,7 +1299,6 @@ public void MultipleCanonicalCLMissingInputDependencyRemoved()
             Assert.Empty(outofdate);
         }
 
-
         [Fact]
         public void MultiplePrimaryCanonicalCL()
         {
@@ -1959,7 +1955,6 @@ public void MultipleRootedCLAcrossTlogs2()
             Assert.True(outofdate[0].ItemSpec == Path.Combine("TestFiles", "one.cpp"));
         }
 
-
         [Fact]
         public void OutputSingleCanonicalCL()
         {
@@ -2412,7 +2407,6 @@ public void OutputCLMinimalRebuildOptimization()
                 Path.GetFullPath(Path.Combine("TestFiles", "three.obj")),
             });
 
-
             // Represent our tracked and computed outputs
             CanonicalTrackedOutputFiles outputs = new CanonicalTrackedOutputFiles(DependencyTestHelper.MockTask, DependencyTestHelper.ItemArray(new TaskItem(Path.Combine("TestFiles", "one.write.tlog"))));
 
@@ -2507,7 +2501,6 @@ public void OutputCLMinimalRebuildOptimizationComputed()
                 Path.GetFullPath(Path.Combine("TestFiles", "three.obj")),
             });
 
-
             // Represent our tracked and computed outputs
             CanonicalTrackedOutputFiles outputs = new CanonicalTrackedOutputFiles(DependencyTestHelper.MockTask, DependencyTestHelper.ItemArray(new TaskItem(Path.Combine("TestFiles", "one.write.tlog"))));
 
@@ -3529,7 +3522,6 @@ public void FlatTrackingDataInputOrOutputNewerThanTracking()
             // We should be out of date inputs & outputs vs tracking (since we wrote the files after the tracking logs)
             Assert.False(FlatTrackingData.IsUpToDate(DependencyTestHelper.MockTask.Log, UpToDateCheckType.InputOrOutputNewerThanTracking, inputs, outputs));
 
-
             // Touch the tracking logs so that are more recent that any of the inputs
             Thread.Sleep(_sleepTimeMilliseconds);
             File.SetLastWriteTime(Path.Combine("TestFiles", "one.read.tlog"), DateTime.Now);
diff --git a/src/Utilities/CommandLineBuilder.cs b/src/Utilities/CommandLineBuilder.cs
index 64c4bf0430a..26621001e06 100644
--- a/src/Utilities/CommandLineBuilder.cs
+++ b/src/Utilities/CommandLineBuilder.cs
@@ -109,7 +109,6 @@ public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparat
         /// <returns></returns>
         public override string ToString() => CommandLine.ToString();
 
-
         // Use if escaping of hyphens is supposed to take place
         private static readonly string s_allowedUnquotedRegexNoHyphen =
                          "^"                             // Beginning of line
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 08b17e71e28..d50a869c93f 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -314,7 +314,6 @@ public static IList<AssemblyFoldersExInfo> GetAssemblyFoldersExInfo(string regis
 
             AssemblyFoldersEx assemblyFoldersEx = new AssemblyFoldersEx(registryRoot, targetFrameworkVersion, registryKeySuffix, osVersion, platform, new GetRegistrySubKeyNames(RegistryHelper.GetSubKeyNames), new GetRegistrySubKeyDefaultValue(RegistryHelper.GetDefaultValue), targetProcessorArchitecture, new OpenBaseKey(RegistryHelper.OpenBaseKey));
 
-
             var assemblyFolders = new List<AssemblyFoldersExInfo>();
             assemblyFolders.AddRange(assemblyFoldersEx);
             return assemblyFolders;
@@ -939,7 +938,6 @@ public static string[] GetPlatformOrFrameworkExtensionSdkReferences
                 string targetPlatformVersion
             )
         {
-
             lock (s_locker)
             {
                 if (s_cachedExtensionSdkReferences == null)
@@ -1803,7 +1801,7 @@ public static string GetPathToStandardLibraries(string targetFrameworkIdentifier
         /// <param name="targetFrameworkProfile">Profile being targeted</param>
         /// <param name="platformTarget">What is the targeted platform, this is used to determine where we should look for the standard libraries. Note, this parameter is only used for .net frameworks less than 4.0</param>
         /// <param name="targetFrameworkRootPath">Root directory where the target framework will be looked for. Uses default path if this is null</param>
-        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
+        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the framework cannot be found in @targetFrameworkRootPath</param>
         /// <exception cref="ArgumentNullException">When the frameworkName is null</exception>
         /// <returns>Collection of reference assembly locations.</returns>
         public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths)
@@ -1903,7 +1901,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkI
         /// <param name="targetFrameworkVersion">Version being targeted</param>
         /// <param name="targetFrameworkProfile">Profile being targeted</param>
         /// <param name="targetFrameworkRootPath">Root directory which will be used to calculate the reference assembly path. The references assemblies will be
-        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
+        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the framework cannot be found in @targetFrameworkRootPath</param>
         /// generated in the following way TargetFrameworkRootPath\TargetFrameworkIdentifier\TargetFrameworkVersion\SubType\TargetFrameworkSubType.
         /// Uses the default path if this is null.
         /// </param>
@@ -1921,7 +1919,6 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkI
             return GetPathToReferenceAssemblies(targetFrameworkRootPath, targetFrameworkFallbackSearchPaths, targetFrameworkName);
         }
 
-
         /// <summary>
         /// Returns the paths to the reference assemblies location for the given target framework.
         /// This method will assume the requested ReferenceAssemblyRoot path will be the ProgramFiles directory specified by Environment.SpecialFolder.ProgramFiles
@@ -2164,7 +2161,6 @@ private static IList<string> HandleLegacy20(VersionToPath PathToDotNetFramework)
             return referencePaths;
         }
 
-
         /// <summary>
         /// Returns the paths to the reference assemblies location for the given framework version relative to a given targetFrameworkRoot.
         /// The method will not check to see if the path exists or not.
@@ -2172,7 +2168,7 @@ private static IList<string> HandleLegacy20(VersionToPath PathToDotNetFramework)
         /// <param name="targetFrameworkRootPath">Root directory which will be used to calculate the reference assembly path. The references assemblies will be
         /// generated in the following way TargetFrameworkRootPath\TargetFrameworkIdentifier\TargetFrameworkVersion\SubType\TargetFrameworkSubType.
         /// </param>
-        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
+        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the framework cannot be found in @targetFrameworkRootPath</param>
         /// <param name="frameworkName">A frameworkName class which represents a TargetFrameworkMoniker. This cannot be null.</param>
         /// <returns>Collection of reference assembly locations.</returns>
         public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, FrameworkNameVersioning frameworkName)
@@ -3020,7 +3016,6 @@ private static string GetTargetPlatformMonikerRegistryRoots(string registryRootL
                 ErrorUtilities.DebugTraceMessage("GetTargetPlatformMonikerRegistryRoots", "MSBUILDDISABLEREGISTRYFORSDKLOOKUP is set registry sdk lookup is disabled");
             }
 
-
             return registryRoot;
         }
 
@@ -3690,7 +3685,6 @@ public static IList<string> GetSupportedTargetFrameworks()
             return s_targetFrameworkMonikers;
         }
 
-
         /// <summary>
         /// This method will return the highest version of a target framework moniker based on the identifier. This method will only 
         /// find full frameworks, this means no profiles will be returned.
@@ -3830,7 +3824,6 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                 }
             }
 
-
             if (programFilesReferenceAssemblyLocationFound && bFoundDotNetFrameworkIdentifier == false)
             {
                 if (bAddDotNetFrameworkIdentifier == false)
@@ -3853,11 +3846,9 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                 }
             }
 
-
             return frameworkIdentifiers;
         }
 
-
         /// <summary>
         /// Gets the installed versions for a given framework
         /// </summary>
@@ -3965,7 +3956,6 @@ private static IList<string> GetFrameworkProfiles(string frameworkReferenceRoot,
             return frameworkProfiles;
         }
 
-
         /// <summary>
         /// returns the .NETFramework versions lessthanOrEqualTo 3.5 installed in the machine
         /// Only returns Fx versions lessthanOrEqualTo 3.5 if DNFx3.5 is installed
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 365066c0e9d..12e5e1d8e77 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -1367,7 +1367,6 @@ public override bool Execute()
                     }
                     else
                     {
-
                         Encoding encoding;
 
                         if (Traits.Instance.EscapeHatches.AvoidUnicodeWhenWritingToolTaskBatch)
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index be7d6f571f5..6548dc6ab48 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -797,7 +797,6 @@ private void ConstructDependencyTable()
                                                 break;
                                             }
 
-
                                             tlogEntry = tlog.ReadLine();
                                         }
                                     }
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index 88b60b0dfc8..7a178045c99 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -223,8 +223,6 @@ public FlatTrackingData(ITaskItem[] tlogFiles, ITaskItem[] tlogFilesToIgnore, Da
             InternalConstruct(null, tlogFiles, tlogFilesToIgnore, false, missingFileTimeUtc, excludedInputPaths);
         }
 
-
-
         /// <summary>
         /// Constructor
         /// </summary>
@@ -678,7 +676,6 @@ public DateTime GetLastWriteTimeUtc(string file)
             return fileModifiedTimeUtc;
         }
 
-
         #endregion
 
         #region Static Methods
@@ -848,7 +845,6 @@ public static void FinalizeTLogs(bool trackedOperationsSucceeded, ITaskItem[] re
             // Read the output table, skipping missing files
             FlatTrackingData outputs = new FlatTrackingData(writeTLogNames, true);
 
-
             // If we failed we need to clean the Tlogs
             if (!trackedOperationsSucceeded)
             {
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs
index 30635a19eaa..a8b28069581 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs
@@ -21,5 +21,4 @@ public enum Scope
             Method
         }
     }
-
 }
