diff --git a/.editorconfig b/.editorconfig
index 044208a0a78..c619a8f04ec 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -15,6 +15,9 @@ trim_trailing_whitespace = true
 [project.json]
 indent_size = 2
 
+[*.txt]
+insert_final_newline = false
+
 # C# files
 [*.cs]
 # New line preferences
@@ -210,7 +213,7 @@ dotnet_analyzer_diagnostic.category-Style.severity = warning
 dotnet_diagnostic.IDE0004.severity = suggestion
 
 # IDE0005: Remove unnecessary usings/imports
-dotnet_diagnostic.IDE0005.severity = warning
+dotnet_diagnostic.IDE0005.severity = none
 
 # Use explicit type instead of 'var'
 dotnet_diagnostic.IDE0008.severity = suggestion
@@ -397,4 +400,11 @@ dotnet_diagnostic.IDE0251.severity = suggestion
 dotnet_diagnostic.IDE0270.severity = suggestion
 
 # naming rule violation
-dotnet_diagnostic.IDE1006.severity = suggestion
\ No newline at end of file
+dotnet_diagnostic.IDE1006.severity = suggestion
+
+# Use primary constructor
+dotnet_diagnostic.IDE0290.severity = suggestion
+
+# Collection initialization can be simplified
+dotnet_diagnostic.IDE0300.severity = suggestion
+dotnet_diagnostic.IDE0301.severity = suggestion
diff --git a/.github/ISSUE_TEMPLATE/06_feature_request.yml b/.github/ISSUE_TEMPLATE/06_feature_request.yml
index 9cf2f69540d..c2108af202e 100644
--- a/.github/ISSUE_TEMPLATE/06_feature_request.yml
+++ b/.github/ISSUE_TEMPLATE/06_feature_request.yml
@@ -1,7 +1,7 @@
 name: üí° Feature  Request
 description: Suggest an idea for this project.
 title: "[Feature Request]: "
-labels: ["Feature Request"]
+labels: ["Feature Request", "needs-triage"]
 body:
   - type: textarea
     attributes:
@@ -24,4 +24,4 @@ body:
   - type: textarea
     attributes:
       label: Alternative Designs
-      description: If you have an idea how to achieve this new feature, let us know that here. Please include any pointers to code, relevant changes, or related issues you know of.
\ No newline at end of file
+      description: If you have an idea how to achieve this new feature, let us know that here. Please include any pointers to code, relevant changes, or related issues you know of.
diff --git a/.gitignore b/.gitignore
index 854f738d435..4b481121c52 100644
--- a/.gitignore
+++ b/.gitignore
@@ -21,6 +21,9 @@ artifacts/
 # Visual Studio 2015 cache/options directory
 .vs/
 
+# Verify result files
+*.received.*
+
 *_i.c
 *_p.c
 *_i.h
@@ -218,3 +221,6 @@ stage1/
 
 # .DS_Store for macOS
 **/.DS_Store
+
+# We keep launchSettings.json local
+**/launchSettings.json
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 8ff78b900be..d538f655a85 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -100,7 +100,12 @@ jobs:
 - job: FullReleaseOnWindows
   displayName: "Windows Full Release (no bootstrap)"
   pool:
-    vmImage: 'windows-2022'
+    ${{ if eq(variables['System.TeamProject'], 'public') }}:
+      name: NetCore-Public
+      demands: ImageOverride -equals windows.vs2022preview.amd64.open
+    ${{ if ne(variables['System.TeamProject'], 'public') }}:
+      name: VSEngSS-MicroBuild2022-1ES
+      demands: agent.os -equals Windows_NT
   steps:
   - task: BatchScript@1
     displayName: cibuild.cmd
@@ -229,8 +234,4 @@ jobs:
     continueOnError: true
     condition: always()
 
-- template: /eng/common/templates/job/source-build.yml
-  parameters:
-    platform:
-      name: 'Managed'
-      container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7'
+- template: /eng/common/templates/jobs/source-build.yml
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index f232c2ca67c..c13bede0870 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -23,12 +23,9 @@ variables:
   - name: SourceBranch
     value: $(IbcSourceBranchName)
   # If we're not on a vs* branch, use main as our optprof collection branch
-  # NOTE: the code is temporarily fixed. For the branches that should use opt-prof from the main branch we should use the latest working Opt-Prof collected from main 20230217.4.
   - ${{ if not(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs')) }}:
-    - name: OptProfDrop
-      value: 'OptimizationData/DotNet-msbuild-Trusted/main/20230217.4/7352286/1'   
     - name: SourceBranch
-      value: ''
+      value: main
   # if OptProfDropName is set as a parameter, set OptProfDrop to the parameter and unset SourceBranch
   - ${{ if ne(parameters.OptProfDropName, 'default') }}:
     - name: OptProfDrop
diff --git a/Directory.Build.props b/Directory.Build.props
index 43bebf10428..6db67e877f6 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -25,7 +25,7 @@
           src/Framework/README.md
           src/Utilities/README.md
      -->
-    <LatestDotNetCoreForMSBuild>net7.0</LatestDotNetCoreForMSBuild>
+    <LatestDotNetCoreForMSBuild>$(NetCurrent)</LatestDotNetCoreForMSBuild>
   </PropertyGroup>
 
   <PropertyGroup>
@@ -77,10 +77,6 @@
     <MachineIndependentBuild>true</MachineIndependentBuild>
   </PropertyGroup>
 
-  <PropertyGroup>
-    <AssemblyInformationCachePaths Condition="Exists('$(NetCoreRoot)sdk\$(NetCoreSdkVersion)\SdkPrecomputedAssemblyReferences.cache')">$(AssemblyInformationCachePaths);$(NetCoreRoot)sdk\$(NetCoreSdkVersion)\SDKPrecomputedAssemblyReferences.cache</AssemblyInformationCachePaths>
-  </PropertyGroup>
-
   <PropertyGroup>
     <DefaultItemExcludes>$(DefaultItemExcludes);*.log</DefaultItemExcludes>
     <DefaultItemExcludes>$(DefaultItemExcludes);*.binlog</DefaultItemExcludes>
diff --git a/MSBuild.Dev.slnf b/MSBuild.Dev.slnf
index 1157c36a866..4ae636a74a6 100644
--- a/MSBuild.Dev.slnf
+++ b/MSBuild.Dev.slnf
@@ -13,7 +13,8 @@
       "src\\Tasks\\Microsoft.Build.Tasks.csproj",
       "src\\Utilities.UnitTests\\Microsoft.Build.Utilities.UnitTests.csproj",
       "src\\Utilities\\Microsoft.Build.Utilities.csproj",
-      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj"
+      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj",
+      "src\\StringTools\\StringTools.csproj"
     ]
   }
 }
\ No newline at end of file
diff --git a/NuGet.config b/NuGet.config
index 9b4c6f6759c..d7187b4d64a 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -6,6 +6,9 @@
     <add key="dotnet-public" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public/nuget/v3/index.json" />
     <add key="dotnet-tools" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json" />
     <add key="dotnet6" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json" />
+    <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
+    <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
+    <add key="BuildXL" value="https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources />
 </configuration>
diff --git a/PublishToBlob.proj b/PublishToBlob.proj
deleted file mode 100644
index 3f37b55ba64..00000000000
--- a/PublishToBlob.proj
+++ /dev/null
@@ -1,34 +0,0 @@
-<Project>
-
-  <!--
-
-  This is for the internal orchestrated build scenarios and will likely never be run on a
-  developer's machine.  The official build definition builds this file directly.
-
-  -->
-
-  <PropertyGroup>
-    <FeedTasksPackage>Microsoft.DotNet.Build.Tasks.Feed</FeedTasksPackage>
-    <!-- This version should be kept in sync with `project.json` -->
-    <FeedTasksPackageVersion>2.1.0-prerelease-02419-02</FeedTasksPackageVersion>
-  </PropertyGroup>
-
-  <Import Project="$(MSBuildThisFileDirectory)packages\$(FeedTasksPackage)\$(FeedTasksPackageVersion)\build\$(FeedTasksPackage).targets" />
-
-  <ItemGroup>
-    <ItemsToPush Include="$(MSBuildThisFileDirectory)bin\Packages\*.nupkg" />
-  </ItemGroup>
-
-  <Target Name="Build">
-    <PushToBlobFeed ExpectedFeedUrl="$(ExpectedFeedUrl)"
-                    AccountKey="$(AccountKey)"
-                    ItemsToPush="@(ItemsToPush)"
-                    Overwrite="$(PublishOverwrite)"
-                    ManifestBranch="$(ManifestBranch)"
-                    ManifestBuildId="$(ManifestBuildId)"
-                    ManifestCommit="$(ManifestCommit)"
-                    ManifestName="msbuild"
-                    SkipCreateManifest="false" />
-  </Target>
-
-</Project>
diff --git a/build.sh b/build.sh
index 2d2a01b1ee0..f9a7889f52c 100755
--- a/build.sh
+++ b/build.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 SOURCE="${BASH_SOURCE[0]}"
 while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index f2e6b6e4753..2497ff6eb37 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -47,7 +47,7 @@ When `Clean`ing the output of a project, `CleanReferencedProjects` ensures that
 
 ## Targets required to be referenceable
 
-These targets should exist in a project to be compatible with the common targets' `ProjectReference`. Some are called only conditionally.
+These targets should exist in a project to be compatible with the common targets' `ProjectReference` (unless [marked with the `SkipNonexistentTargets='true'` metadatum](#targets-marked-with-skipnonexistenttargetstrue-metadatum)). Some are called only conditionally.
 
 These targets are all defined in `Microsoft.Common.targets` and are defined in Microsoft SDKs. You should only have to implement them yourself if you require custom behavior or are authoring a project that doesn't import the common targets.
 
@@ -85,6 +85,10 @@ If implementing a project with an ‚Äúouter‚Äù (determine what properties to pass
   * As of 15.7, this is _optional_. If a project does not contain a `GetCopyToOutputDirectoryItems` target, projects that reference it will not copy any of its outputs to their own output folders, but the build can succeed.
 * `Clean` should delete all outputs of the project.
   * It is not called during a normal build, only during "Clean" and "Rebuild".
+
+### Targets Marked With `SkipNonexistentTargets='true'` Metadatum
+`GetTargetFrameworks` and `GetTargetFrameworksWithPlatformForSingleTargetFramework` are skippable if nonexistent since some project types (for example, `wixproj` projects) may not define them. See [this comment](https://github.com/dotnet/msbuild/blob/cc55017f88688cbe3f9aa810cdf44273adea76ea/src/Tasks/Microsoft.Managed.After.targets#L74-L77) for more details.
+
 ## Other protocol requirements
 
 As with all MSBuild logic, targets can be added to do other work with `ProjectReference`s.
diff --git a/documentation/README.md b/documentation/README.md
index 082fab41bb3..199be8361fb 100644
--- a/documentation/README.md
+++ b/documentation/README.md
@@ -39,6 +39,7 @@ The folder contains collection of docs and references for MSBuild, detailed info
 ### Problems?
 
 * [Rebuilding when nothing changed](wiki/Rebuilding-when-nothing-changed.md)
+* [Controling References Behavior](wiki/Controlling-Dependencies-Behavior.md)
 * [Something's wrong in my build](wiki/Something's-wrong-in-my-build.md)
 * [Some gotchas around the Microsoft.Build.Framework project/assembly](wiki/Microsoft.Build.Framework.md)
 * [GAC and MSBuild](wiki/UnGAC.md)
@@ -50,16 +51,17 @@ The folder contains collection of docs and references for MSBuild, detailed info
 * [`ProjectReference`](ProjectReference-Protocol.md)
 * [MSBuild Server](MSBuild-Server.md)
 * [Low priority nodes](specs/low-priority-switch.md)
+* [Threading in MSBuild worker nodes](specs/threading.md)
+* [Nodes orchestration](wiki/Nodes-Orchestration.md)
 * [Project cache plugin](specs/project-cache.md)
 * [Support for remote host objects](specs/remote-host-object.md)
 * [Static graph](specs/static-graph.md)
 * [Single project isolated builds: implementation details](specs/single-project-isolated-builds.md)
 * [Task isolation](specs/task-isolation-and-dependencies.md)
-* [Threading in MSBuild worker nodes](specs/threading.md)
 * [Target maps](wiki/Target-Maps.md)
 * [Managing parallelism in MSBuild](specs/resource-management.md)
 * [SDK resolution](specs/sdk-resolvers-algorithm.md)
-* [Nodes orchestration](wiki/Nodes-Orchestration.md)
+* [RAR core scenarios](specs/rar-core-scenarios.md)
 
 ### Tasks
 
@@ -72,13 +74,16 @@ The folder contains collection of docs and references for MSBuild, detailed info
 ### Logging
 
 * [Binary log](wiki/Binary-Log.md)
-* [Live logger: how to opt in](livelogger/Opt-In-Mechanism.md)
-
-## Designs
+* [Terminal logger: how to opt in](terminallogger/Opt-In-Mechanism.md)
 
-* [Resolve Assembly Reference as a service](design/rar-as-service.md)
+## Archived Designs
+* [Resolve Assembly Reference as a service](specs/rar-as-service.md)
    * Prototype: https://github.com/dotnet/msbuild/issues/6193
 
+## Proposed Designs
+* [Packages Sourcing](specs/proposed/interactive-package-references.md)
+* [Secrets Metadata](specs/proposed/security-metadata.md)
+
 ## Community contributions
 
 * [MSBuild overview](Contributions/MSBuild-overview.md)
diff --git a/documentation/livelogger/Opt-In-Mechanism.md b/documentation/livelogger/Opt-In-Mechanism.md
deleted file mode 100644
index ca9c558fde8..00000000000
--- a/documentation/livelogger/Opt-In-Mechanism.md
+++ /dev/null
@@ -1,19 +0,0 @@
-# When should we use LiveLogger
-
-The LiveLogger presents the user with the build's most relevant information at the time, automatically hiding all the information that is no longer relevant (as to prevent huge log outputs). However, many users might find this not very useful (or even counterproductive) such as those using a terminal without proper ANSI support or when redirecting the output to a file. For that reason, the users must be able to turn this feature on/off at will.
-
-# Proposal
-Using the `/livelogger` or `/ll` command line switches, users are able to opt-in and use the LiveLogger, EXCEPT when:
-- The terminal does not support ANSI codes or color
- - Output is redirected to a file or pipe
-
-For early development stages, an environment variable `$MSBUILDLIVELOGGER` should be enabled to prevent accidental access to an unfinished feature. 
-
-In cases where the LiveLogger should not be enabled, the default ConsoleLogger should be used instead.
-
-# Considerations
-## Should LiveLogger be used with other loggers (eg, BinaryLogger, FileLogger, custom loggers)?
-LiveLogger should only replace the current ConsoleLogger for the aforementioned cases. Additionally, other loggers can be used in conjunction. 
-
-## Should output be ignored with the `/noconsolelogger` flag enabled?
-LiveLogger serves as a replacement for ConsoleLogger, so it should behave similarly. When attaching the `/noconsolelogger` flag, it should not output anything.
diff --git a/documentation/design/rar-as-service.md b/documentation/specs/archive/rar-as-service.md
similarity index 100%
rename from documentation/design/rar-as-service.md
rename to documentation/specs/archive/rar-as-service.md
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index f646f120114..4eef03f279b 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -29,7 +29,7 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | RarComputeClosure | Resolves references from, for example, properties to explicit values. Used in resolving assembly references (RAR). |
 | RarLogResults | Logs the results from having resolved assembly references (RAR). |
 | RarOverall | Initiates the process of resolving assembly references (RAR). |
-| RarRemoveReferencesMarkedForExclusion | Removes blacklisted references from the reference table, putting primary and dependency references in invalid file lists. |
+| RarRemoveReferencesMarkedForExclusion | Removes denylisted references from the reference table, putting primary and dependency references in invalid file lists. |
 | RequestThreadProc | A function to requesting a new builder thread. |
 | ReusableStringBuilderFactory | Uses and resizes (if necessary) of ReusableStringBuilders. |
 | ReusableStringBuilderFactoryUnbalanced | Identifies improper usage from multiple threads or buggy code: multiple Gets were called without a Relase. |
diff --git a/documentation/specs/proposed/security-metadata.md b/documentation/specs/proposed/security-metadata.md
new file mode 100644
index 00000000000..e2ed58050b6
--- /dev/null
+++ b/documentation/specs/proposed/security-metadata.md
@@ -0,0 +1,253 @@
+
+# Security Metadata
+
+The feature is meant to improve the security of builds executed via MSBuild, by reducing the chances of spilling secrets (and possibly other sensitive data) from otherwise secured or/and inaccessible build environments.
+
+It builds upon the other efforts reducing the cases accidentaly logging secrets - ['not logging unused environemnt variables'](https://github.com/dotnet/msbuild/pull/7484), 'redacting known secret patterns' (internal, by @michaelcfanning). Distinction here is that we want to give users option how to configure their build scripts and build data so that they can indicate what contains secret/sensitive data and shouldn't get output into logs.
+
+The feature is envisioned to be delivered in multiple interations, while first itearation will be facilitated via global items and/or properties that will be indicating masking logging of specific types of data in log entries (hence no syntactic changes will be imposed for now).
+
+# North Star / Longer-term vision
+
+We envision MSBuild to have a first-class-citisen type system for it's data and tasks. 'Secret' would be one of the data types - allowable to be passed only to other variables or task inputs denoted as 'secret' (so e.g. it would not be possible to pass secrets to [`WriteLinesToFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/writelinestofile-task)) and vice versa 'secret' task input or data type could be initialized/evaluated only from other 'secrets' or predefined external sources of data - environment variables, commandline arguments, files, apropriately denoted task output parameters.
+
+Such a strong typing would allow to hold to stronger guarantees of not spilling properly denoted sensitive data and redact them with minimal impact on build performance (as opposed to intermediate attempts that will need to perform string inspections).
+
+**Ilustrative sample:**
+
+```xml
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Secrets>
+    <!-- initialize from command line -->
+    <GH_token />
+    <!-- initialize from env -->
+    <ACR_login>$(ACR_login)</ACR_login>
+    <!-- initialize by task -->
+    <ACR_password />
+	</Secrets>
+
+  <UsingTask TaskName="ReadCreadentialFromValut" AssemblyFile="$(MSBuildProjectDirectory)/Tasks/ACR-Tasks.dll" />
+  <UsingTask TaskName="PushImageToACR" AssemblyFile="$(MSBuildProjectDirectory)/Tasks/ACR-Tasks.dll" />
+	
+  <Target Name='PushImage'> 
+    <Message Text="Pushin image to ACR" />
+    <ReadCreadentialFromValut 
+      Key="$(ACR_password_key)"
+    >
+      <Output TaskParameter="Value" PropertyName="ACR_password"/>
+    </ReadCreadentialFromValut>
+    <PushImageToACR 
+      Login="$(ACR_login)"
+      Password="$(ACR_password)"
+    />
+  </Target>
+</Project>
+```
+
+```cs
+ReadCreadentialFromValut : Task
+{
+  /// <summary>
+  /// Key to be fetched
+  /// </summary>
+  public string Key { get; set; }
+
+  /// <summary>
+  /// Fetched value
+  /// </summary>
+  [Output]
+  [Secret]
+  public string Value { get; set; }
+
+  // ... Execute() ...
+}
+```
+
+```cs
+PushImageToACR : Task
+{
+  /// <summary>
+  /// Azure Container Registry Login
+  /// </summary>
+  public Secret Login { get; set; }
+
+  /// <summary>
+  /// Azure Container Registry Password
+  /// </summary>
+  public Secret Password { get; set; }
+
+  // ... Execute() ...
+}
+```
+
+An opt-out mechanism would allow usage of properly denoted tasks with plain string input data (and vice versa) - to allow smoother gradual onboarding to the new type system, without the need to rework the entire build script suite at one shot.
+
+
+# Scope of initial iteration
+
+## In scope
+ * Following data can be opted-in for redacting:
+    * property values
+    * item values
+    * item metadata values
+    * all item metadata
+    * any combination of above
+    * task input parameters (to denote that task is requiring sensitive data and only such can be passed in)
+    * task OutputItems (This can be handy in cases similar to [`ReadLinesFromFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/readlinesfromfile-task))
+ * Redacting the above will happen in all log events before they are being sent to subscribed loggers. 
+ * Redacting will apply to data initializations and passing:
+    * task input parameters
+    * task OutputItems
+    * transfering value to other properties/items via evaluation, transforms, flattening, [Property functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/property-functions), [Item functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/item-functions)
+    * initialization from environemnt variables or command line
+ * Redacting **will NOT** occure on:
+    * log events emited from tasks (this might be added as extra opt-in option - but would lead to significant build performance degradation).
+    * any other alternative output of tasks (direct writes to file system, network connections etc.)
+
+## Out of scope
+  * Redacting **will NOT** occure on:
+    * Log events emited from tasks (this might be added as extra opt-in option - but would lead to significant build performance degradation).
+    * Any other alternative output of tasks (direct writes to file system, network connections etc.)
+    * MSBuild xml nodes (elements/attributes) names. (Sensitive data within MSBuild script itself is strongly discouraged)
+    * Passing values to task and there embedding into additional text and passing out as output parameter - unless such is explicitly marked as containing sensitive data.
+    * Encrypting/securing data in memory during therun of the build.
+ 
+
+# User interaction
+
+There needs to be a way how user specifies which data should be redacted from logs. We have several options:
+
+ * New data type - this is part of the [North Star vision](#north-star--longer-term-vision), but is out of scope for the initial iteration.
+ * [Not recomended] Denoting those via some metadata on a definition of the data to be redacted - this has two main drawbacks - a) For some data types (properties, metadata) we'd need new constructs how to attach additional info (property metadata; item meta-metadata). b) some data can be defined implicitly or dynamicaly
+ * Property with global scope - e.g. 
+   ```xml
+   <DataToRedactFromLogs>Foo;Bar;Baz->SomeMetadata;MyItem->*</DataToRedactFromLogs>
+   ```
+   single property might look bit cryptic for denoting different data types. On the other hand it might be more efficient in simple redacting scenarios (pointing to a set of regexes; single sustom redactor etc.) and would allow limiting the log events pre-buffering needs.
+
+ * Item with global scope - e.g. 
+   ```xml
+   <ItemGroup>
+     <!-- Redacting property content based on the name of the property (or environment variable) -->
+     <DataToRedactFromLogs Include="Foo" Type="Property">
+     </DataToRedactFromLogs>
+     <!-- Redacting item content based on the name of the item. Metadat are not redacted -->
+     <DataToRedactFromLogs Include="Bar" Type="Item" RedactValue=True>
+     </DataToRedactFromLogs>
+     <!-- Redacting item metadata content based on the name. -->
+     <DataToRedactFromLogs Include="Baz" Type="Item" RedactValue=False Metadata="SomeMetadata">
+     </DataToRedactFromLogs>
+     <!-- Redacting all metadata content of specific item based on the name of the item. -->
+     <DataToRedactFromLogs Include="MyItem" Type="Item" RedactValue=False Metadata="*" />
+     <!-- Redacting property content passed from the task. At the same time requiring that the data receiving the output of the task are denoted as secret as well. -->
+     <DataToRedactFromLogs Include="OutputA" Type="TaskOutput" TaskName="TaskX" />
+     <!-- Redacting task parameter value. At the same time requiring that the data passed to the parameter of the task are denoted as secret as well. -->
+     <DataToRedactFromLogs Include="ParamA" Type="TaskParameter" TaskName="TaskX" />
+     </DataToRedactFromLogs>
+   </ItemGroup>
+   ```
+   This can offer a more chatty, but better understandable (and possibly beter script generatable) way of denoting the redacting intent.
+ * A regex on *value* to redact above discused data types based on their content - e.g.:
+    ```xml
+   <ItemGroup>
+     <!-- Redact GH tokens based on https://github.blog/changelog/2021-03-31-authentication-token-format-updates-are-generally-available -->
+     <DataToRedactFromLogs Include="ghp_[A-Za-z0-9_]" Type="ValueRegex">
+     </DataToRedactFromLogs>
+   </ItemGroup>
+   ```
+   This way we can give build architects a tool to define common `.props` files opting-in for redacting specific types strings known to be tokens/secrets/sensitive data, without the need to guess under which properties or items they would show within the build
+* A custom plugin flagging values for redaction. e.g.:
+    ```xml
+   <ItemGroup>
+     <DataToRedactFromLogs Include="MySecretsClassifier.dll,Contoso.Secrets.Classifier.ClassifySecrets" Type="ValueClassifierPlugin">
+     </DataToRedactFromLogs>
+   </ItemGroup>
+   ```
+
+   where:
+
+   ```csharp
+   Contoso.Secrets;
+
+   public class Classifier: IValueClassifier
+   {
+      public ISet<string>? GetPartsToRedact(string value) {/* Logic goes here */}
+   }
+   ```
+   This option has additional security considerations, but allows most versatile secrets redaction.
+
+   The last option can possibly be allowed to be injected via other means, that MSBuild currently uses for injecting pluggable fnctionality (command line argument; environment variable; binary placed in a specific search location)
+* A built in redacting plugin - to be opted-in via env var or command line. Plugin will use same extension point as custom plugins - with extended interface allowing to provide redaction values as well:
+   ```csharp
+
+   public interface IValueRedactor
+   {
+      public ISet<Tuple<string, string>>? GetPartsToRedact(string value);
+   }
+   ```
+   This plugin will allow for no-touch redacting of most comon secret patterns by various providers. The default plugin is going to be provided as contribution by 1ES (by @michaelcfanning) and is currently out of scope of this document.
+
+
+First presented option is not to be used. All the other options will likely be supported.
+
+# Special considerations
+
+* There should be no (or very minimal) performance impact to cases where redacting is not opted-in and/or to cases where there is lower/minimal level of logging. In another words - we should not spend cycles detecting and redacting secrets on log events that are not going to be loged (todo: second case might be more problematic - as loggers can decide their level of logging).
+* Order of processing and imports is important here - if we indicate secret metadata in items, the properties are processed first and hence we can miss preanalyzing (or even redacting) some data. Same applies for order of processing of the properties.
+* Considering above two facts - we need a opt-in commandline switch or environemnt variable (or combination) to indicate that secrets metadata might be used - in which case we'll need to buffer build/log events before we have processed all the metadata indicating what needs to be redacted. Extra care will need to be given to sending command line args via EventSource ([source](https://github.com/dotnet/msbuild/blob/main/src/MSBuild/XMake.cs#L655))
+* There are no global items today - this can be simulated by putting those to directory.props
+* Even seemingly innocent tasks with seemingly innocent logging can spill possibly sensitive data (e.g. think the RAR task, logging all the inputs, while those are just reference related info - those can contain paths that might already by itself be sensitive info). Related: [#8493](https://github.com/dotnet/msbuild/issues/8493) 
+* `MSBuild` task can pose a boundary for some context passing (e.g. properties/items).
+* Properties/items can occure dynamically after the initial processing of the script - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task). That should not be a problem, but we should keep it in mind (as additional entrypoint of external data into internal data holders).
+* Task authors and consumers are posibly different personas with disconected codebases. For this reason we want to support ability to indicate that task input/output is meant to be a secret. A user of the task should follow the contract and denote the data to be mounted to the task appropriately (otherwise a build warning/error will be issued).
+
+# Suggested Implementation
+
+* Need for explicit opt-in - command line switch or environment variable.
+* On detection of opt in, all build events for loggers need to be buffered for a deffered dispatch to loggers (similarly as we have ['DeferredBuildMessage'](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L400) and [`LogDeferredMessages`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L2890)), until the full pass through the build script (including all imports and `.props` and `.targets` files) so that properties initialization and items initialization is fully performed - as only then we know the full extent of requested redacting.
+  * In the future version - with first-class citizen type for secrets, we can possibly frontload single pass through the script just for detection of the secret redaction declarations and avoid the buffering and post-process need.
+* Buffered events need to be post-processed in respect with the redaction requests, only then dispatched.
+* We'll maintain lookup of elements requested for redaction - those explicitly requested by the name of property/item and those identified as sensitive by value or by transfer of value from other sensitive element.
+* We'll intercept assigments of value to property ([`TrackPropertyWrite`](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs#L223)), item and task parameter
+  * If value is assigned to a task parameter and such is indicated by user as sensitive, the holder of the value (the R-value - parameter/item being assigned to the task input) needs to be as well tracked as sensitive, otherwise build waring/error will be issued.
+  * If value is assigned to a task parameter and such is not indicated by user as sensitive, but the holder of the value (the R-value - parameter/item being assigned to the task input) is tracked as sensitive (either because it was explicitly denoted by name, or it was later marked by MSBuild due to holding value matching a sensitivity value regex or callback) - a build warning/error will be issued.
+  * If value is assigned to property/item from a task output and such is indicated by user as sensitive, the L-value holder of the value (the property/item being assigned to) need to be as well tracked as sensitive, otherwise build waring/error will be issued.
+  * If value is being assigned to property or item
+    * and such is indicated by user as sensitive, the generated build event needs to be redacted.
+    * and such is not indicated by user as sensitive, but the R-value is indicated as sensitive - the data holder (property/item) is marked as holding sensitive data and treated accordingly.
+    * and such is not indicated by user as sensitive, the value is passed to sensitivity indicating regex or callback (in case any of those are configured by user) and if matched - the data holder (property/item) is marked as holding sensitive data and treated accordingly.
+* No other redacting of log events will be performed. This is not a strong requirement - we can introduce another opt-in level of strict inspection of all log events. The gain is very questionable though, while the performance impact is severe (internal experiments by @michaelcfanning measured by @rokonec indicate 4-times slow-down on mid-size build). Additionally to being perf-expensive, it can possibly get easily confused - e.g.:
+
+```xml
+<ItemGroup>
+  <DataToRedactFromLogs>MySecret</DataToRedactFromLogs>
+  <MySecret>a</MySecret>
+  <MyInnocentData>hahaha</MyInnocentData>
+  <SomeProp></SomeProp>
+</ItemGroup>
+
+<Target Name="Test">
+  <MyTask FirstInput="MySecret" SecondInput="MyInnocentData">
+    <Output PropertyName="SomeProp" TaskParameter="Result">
+  </MyTask>
+  <!-- Might log: 
+       Result from task: h<redacted>h<redacted>h<redacted>
+  -->
+  <Message Text="Result from task: $(SomeProp)">
+</Target>
+```
+
+In case we'd want to redact all occurences of value of `MySecret` from the task result - we might get a lot of false positives and very confusing results.
+
+# Open questions
+ * What to use as a replacement of the data to be redacted? (Randomized hash, fixed token, etc.) - *very likely just a static pattern ('******'). The built-in redactor plugin will be allowed to provide custom replacements*
+ * Do we want to allow to supply custom replacement value for injectable redaction functionality? There would need to be very strong compeling reason, as this is easily suspectible to [log forging attack](https://owasp.org/www-community/attacks/Log_Injection) - *most likely no.*
+ * Balancing performance and accuracy - can we afford to not support arbitrary output of tasks? Otherwise we'd need to process all log events (similar experiments indicate 4 times slowdown of the build of mid-size project (Orchard)). On the other with explicit 'secret metadata' feature users might expect 100% correctness. Should we make this configurable as well (input data only vs all log entries)? Plus this might be suspectible to false positives (see above).
+
+
+# Links
+ * Nightfall data redaction syntax: https://docs.nightfall.ai/docs/redacting-sensitive-data-in-4-lines-of-code
+ * `spark.redaction.regex`: https://people.apache.org/~pwendell/spark-releases/latest/configuration.html
+ * Redacting secrets in k8s logs in ops tool `Komodor`: https://docs.komodor.com/Learn/Sensitive-Information-Redaction.html
+ * MSBuild opt-in functionality for properties/items/metadata logging disabling: https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs#L1199
+
diff --git a/documentation/specs/rar-core-scenarios.md b/documentation/specs/rar-core-scenarios.md
new file mode 100644
index 00000000000..3fb19ad7846
--- /dev/null
+++ b/documentation/specs/rar-core-scenarios.md
@@ -0,0 +1,200 @@
+# Resolve Assembly Reference core scenarios
+
+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.
+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously
+slow build tasks.
+
+## Overview
+
+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different
+locations where it searches for assemblies. Please see the [official documentation](https://learn.microsoft.com/visualstudio/msbuild/resolveassemblyreference-task) and
+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description
+of its features.
+
+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,
+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of
+the "resolvers", internal classes implementing various resolution strategies, are not used in modern scenarios.
+
+## Requirements
+
+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the
+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because
+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,
+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.
+
+### Inputs
+
+In a typical build targeting modern .NET (*not* .NET Framework), RAR inputs come from three sources.
+
+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the
+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are
+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are
+guaranteed to be passed in.
+
+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,
+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.
+
+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly
+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly
+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are
+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is
+established.
+
+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the
+combined SDK, NuGet, and project references in one input array.
+
+## Design
+
+To meet the requirements, RAR must internally be able to do the following.
+
+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores
+the reference.
+
+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as
+`C:\_nugetpackages\microsoft.netcore.app.ref\7.0.2\ref\net7.0\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be
+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees
+such an AssemblyRef in another assembly.
+
+- For project references (reference given as a path to an assembly file that is not guaranteed to have its dependencies resolved), RAR must be able to look
+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.
+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,
+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is
+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,
+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.
+
+## Scale
+
+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything
+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.
+In the OrchardCore solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.
+
+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR
+has to touch the disk.
+
+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually
+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.
+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the
+file with a .NET metadata reader.
+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening
+the file with a .NET metadata reader.
+
+## Optimizations
+
+RAR optimizations tend to revolve around caching of information that is expensive to calculate.
+
+### Existing caching
+
+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.
+
+#### **Per invocation in-memory cache**
+
+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot
+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.
+One issue with this cache is that the key is not normalized so a file specified as `C:\dir\file` will use a different cache entry than the same file specified as
+`C:/dir/file`.
+
+#### **Per process in-memory cache**
+
+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last
+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer
+considered valid.
+
+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`
+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that
+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is
+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like
+`C:\_nugetpackages\microsoft.aspnetcore.app.ref\7.0.2\ref\net7.0`, for example.
+
+#### **Per project disk cache**
+
+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the
+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified
+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written
+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.
+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.
+
+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents
+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom
+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.
+
+#### **SDK disk pre-cache**
+
+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global
+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the
+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.
+
+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`
+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.
+
+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.
+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the
+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also
+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.
+
+## Proposed design
+
+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly
+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional
+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help
+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.
+
+For regular project references the system works as about as efficient as possible.
+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.
+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the
+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.
+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.
+
+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.
+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race
+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.
+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.
+
+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project
+references, so optimizing them has the best bang for the buck.
+
+### Obtain assembly names from the SDK
+
+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its
+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies
+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)
+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense
+to save it to disk.
+
+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,
+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.
+
+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not
+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only
+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.
+
+### Treat NuGet references as immutable [shelved]
+
+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as
+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller
+because the number of NuGet references is typically lower. The proposal is to shelve this opportunity for now due to the unfavorable risk-benefit ratio.
+
+### Don't load the per project disk cache when not needed
+
+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to
+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is
+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.
+
+### Save only relevant data to the per project disk cache
+
+As for saving the per-project cache, we would guarantee that after RAR is done, the cache contains exactly the data needed for this specific project. This would
+be done by keeping track of the items used during RAR execution, and writing those and only those to the cache. Having a cache that's guaranteed to have certain
+well-defined content after each build is a very good property to have. For instance, in dev box scenarios it would otherwise be hard to reliably "prime" a repo
+enlistment - the system may prime by building the full solution and then the developer uses the box to build a specific project that happens to have an incomplete
+cache and get sub-optimal first-time build performance.
+
+Saving of the per-project disk cache may be further optimized by
+- Keeping the timestamp of the cache file in memory and skipping the save if the relevant cache items haven't become dirty (i.e. the dependencies have not changed)
+*and* the timestamp of the cache file hasn't changed since the last save. In hot inner loop scenarios this would reduce the save to a timestamp check.
+- Saving the file asynchronously, i.e. not blocking the build on completing the save operation.
+
+### Don't use the SDK disk pre-cache
+
+The idea of pre-generated on-disk cache is sound. For the `ExternallyResolved` SDK assemblies specifically, though, it effectively duplicates the information already
+present in `FrameworkList.xml`. That is, it maps assembly paths to assembly names. If the need arises we may want to re-design the pre-cache to remove the major
+drawback that it duplicates itself into all per-project caches. Cold RAR would load both caches and combine their contents (currently it's either or). Until then,
+it should be OK to leave it unchanged and unused.
diff --git a/documentation/specs/single-project-isolated-builds.md b/documentation/specs/single-project-isolated-builds.md
index e3f8b94670d..75b15fc5b82 100644
--- a/documentation/specs/single-project-isolated-builds.md
+++ b/documentation/specs/single-project-isolated-builds.md
@@ -1,54 +1,43 @@
-# Single project isolated builds: implementation details
+# Single Project Isolated Builds: Implementation Details
 
 <!-- workflow -->
 Single project isolated builds can be achieved by providing MSBuild with input and output cache files.
 
-The input cache files contain the cached results of all the targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the BuildManager APIs) should build targets. Any referenced projects by the top level project should be provided from the input caches.
+The input cache files contain the cached `TargetResult`s of all targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the `BuildManager` APIs) should build targets; Any referenced projects by the top level project should be provided from the input caches.
 
-The output cache file tells MSBuild where to serialize the results of building the current project. This output cache becomes an input cache for all other projects that depend on the current project.
-The output cache file can be omitted in which case the build reuses prior results but does not write out any new results. This is useful when one wants to re-execute the build for a project without building its references.
+The output cache file tells MSBuild where to serialize the `TargetResult`s for a project's built targets and becomes an input cache for dependent projects.
 
 The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).
 
-## Input / Output cache implementation
+## Input / Output Cache Implementation
 <!-- cache structure -->
-The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22).
-
-One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.
+The cache files contain the serialized state of MSBuild's [`ConfigCache`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [`ResultsCache`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCache.cs), which have been traditionally used by the engine to cache build results. They ensure that a target is only built once per build submission. `ConfigCache` entries are instances of [`BuildRequestConfiguration`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25)s (a `(project path, global properties)` tuple), and `ResultsCache` entries are instances of [`BuildResult`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34)s, which contain [`TargetResult`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22)s. The `ConfigCache` entries and `ResultsCache` entries form a [bijection](https://en.wikipedia.org/wiki/Bijection).
 
 <!-- cache lifetime -->
-The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
+In a build, the input and output cache files have the same lifetime as the `ConfigCache` and  `ResultsCache`. The `ConfigCache` and  `ResultsCache` are owned by the [`BuildManager`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On command-line builds, the cache lifetime is the same as the entire process lifetime since `MSBuild.exe` uses one `BuildManager` with one `BeginBuild` / `EndBuild` session. When other processes (e.g. Visual Studio's `devenv.exe`) perform MSBuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
 
 <!-- constraints -->
 
-When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.
-The following constraints are enforced during cache aggregation:
-- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
-- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)
-- Colliding configurations (defined as tuples of `(project path, global properties)`) get their corresponding BuildResult entries merged at the level of TargetResult entries. TargetResult conflicts are handled via the "first one wins" strategy. This is in line with vanilla msbuild's behaviour where a target tuple of `(project path, global properties, target)` gets executed only once.
+When loading input cache files, MSBuild merges incoming instances of `ConfigCache`s and `ResultsCache`s into one instance of each with the help of the [`CacheAggregator`](https://github.com/dotnet/msbuild/blob/51df47643a8ee2715ac67fab8d652b25be070cd2/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L15), which enforces the following constraints:
+- No duplicate cache entries
+- Bijection:
+   - `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
+   - `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`
 
-The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.
+Note that the output cache file contains a single `BuildResult` with the `TargetResult`s from the project specified to be built in the `BeginBuild` / `EndBuild` session, as any `BuildResult`s obtained through isolation exemption are excluded to prevent potential duplicate input cache entries; Entries from input caches are not transferred to the output cache.
 
 <!-- How input / output cache entries are separated with the override caches -->
-Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
+Input cache entries are separated from output cache entries with the composite caches [`ConfigCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [`ResultsCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). Each composite cache contains two underlying caches: a cache where input caches files are loaded into (the override cache), and a cache where new results are written into (the current cache).* In the `ConfigCacheWithOverride`, these caches are instances of `ConfigCache`s and, in the `ResultsCacheWithOverride`, these caches are instances of `ResultsCache`s. A query for a cache entry is first attempted from the override cache and, if unsatisfied, a second attempt is made from the current cache. Writes are only written to the current cache, never into the override cache.* It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache query.
 
-## Isolation implementation
+## Isolation Implementation
 
-[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
+[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the `Scheduler` and  `TaskBuilder`. [`TaskBuilder.ExecuteInstantiatedTask`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in a `ProjectReference` item. [`Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
 
-### How isolation exemption complicates everything
-<!-- Potential cache scenarios caused by exemption -->
-Project references [can be exempt](static-graph.md#exempting-references-from-isolation-constraints) from isolation constraints via the `GraphIsolationExemptReference` item.
+### Isolation Exemption
+The `Scheduler` [skips isolation constraints](static-graph.md#exempting-references-from-isolation-constraints) on project references via the:
 
-The `Scheduler` knows to skip isolation constraints on an exempt `BuildRequest` because the [ProjectBuilder compares](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L349) each new `BuildRequest` against the `GraphIsolationExemptReference` items defined in the calling project, and if exempt, sets `BuildRequest.SkipStaticGraphIsolationConstraints`. When a `BuildRequest` is marked as exempt, the `Scheduler` also marks its corresponding `BuildRequestConfiguration` as exempt as well, which aids in further identification of exempt projects outside the `Scheduler`.
+* `GraphIsolationExemptReference` item. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of a `BuildRequest` to `true` if the `RequestBuilder` matches it against a `GraphIsolationExemptReference` item defined in the calling project. Additionally, the `RequestBuilder` marks the `BuildRequest`'s corresponding `BuildRequestConfiguration` as exempt to allow the `TaskBuilder` to verify exemption from isolation constraints.
 
-The build results for the exempt project are also included in the current cache (according to the above mentioned rule that newly built results are serialized in the output cache file). This complicates the way caches interact in several scenarios:
-1. the same project can be exempt via multiple references, thus potentially colliding when multiple output cache files containing the same exempt project get aggregated. For example, given the graph `{A->B, A->C}`, where both `B` and `C` build the exempt project `D`, `D` will appear in the output caches of both `B` and `C`. When `A` aggregates these two caches, it will encounter duplicate entries for `D`, and will need to merge the results.
-2. a project can be both exempt and present in the graph at the same time. For example, given the graph `{A->B}`, both `A` and `B` are in the graph, but `A` can also mark `B` as exempt (meaning that `A` contains both a `ProjectReference` item to `B`, and a `GraphIsolationExemptReference` item to `B`). The fact that `B` is in the graph means that `A` will receive an input cache containing B's build results. There are two subcases here:
-   1.  `A` builds targets from `B` that already exist in the input cache file from `B`. In this case, all the builds of `B` will be cache hits, and no target results from `B` will make it into `A`'s output cache, since nothing new was built.
-   2.  `A` builds targets from `B` that do not exist in the input cache file from `B`. If `B` weren't exempt from isolation constraints, this scenario would lead to a build break, as cache misses are illegal under isolation. With `B` being exempt, the new builds of `B` will get included in `A`'s output cache. The results from `B`'s cache file won't get included in `A`'s output cache file, as they weren't built by `A`.
-3. A project, which is not in the graph, can be exempt by two parent/child projects from the graph. For example, given the graph `{A->B}`, both `A` and `B` can exempt project `D` (meaning that neither `A` nor `B` have a `ProjectReference` to `D`, but both `A` and `B` have a `GraphIsolationExemptReference` to `D`). The fact that `B` is in the graph means that `A` will receive an input cache containing `B`'s build results. Since `B` builds targets from `D`, it means that `B`'s output cache file also contains target results from `D`. There are two subcases here:
-   1. `A` builds targets from `D` that already exist in the input cache file from `B`. This is handled in the same way as the above case `2.1.`
-   2. `A` builds targets from `D` that do not exist in the input cache file from `B`, meaning that `A` builds additional targets from `D` which `B` didn't build. This is handled in the same way as teh above case `2.2.`
+* `isolate:MessageUponIsolationViolation` switch. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of _every_ `BuildRequest` to `true`. The `TaskBuilder` verifies exemption from isolation constraints just by the switch value.
 
-**Current issue:** if multiple nodes in the graph exempt the same project file, the build results of the exempt project will trickle up and conflict in the first parent that tries to merge them. Documented in issue [#4386](https://github.com/dotnet/msbuild/issues/4386).
+\* Except in the following scenario when a `ProjectReference` is exempted from isolation constraints: a dependency project A outputs a cache file F containing a `BuildResult` with `TargetResult`s T<sub>cached</sub> for targets t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>m</sub> and a dependent project B uses F as an input cache file but builds and obtains the `TargetResult`s T<sub>new</sub> for targets t<sub>m + 1</sub>, t<sub>m + 2</sub>, ..., t<sub>n</sub> such that 0 < m < n. In this case, T<sub>new</sub> will be placed into the `ResultsCache` containing T<sub>cached</sub> to enforce no overlap between the override and current caches in the `ConfigCacheWithOverride`.
\ No newline at end of file
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 99bceac17ab..49acebe57fe 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -223,15 +223,17 @@ A project reference protocol may contain multiple targets, for example `A -> B,
 
 The common project reference protocols (Build, Rebuild, Restore, Clean) will be specified by the common props and targets file in the msbuild repository. Other SDKs can implement their own protocols (e.g. ASPNET implementing Publish).
 
+For this section and the remainder of this spec, a project's default target(s) (what it would execute if no other targets are specified, so often Build but configurable via DefaultTargets) will be referred to as `.default`. That is also how it is used in MSBuild code.
+
 Here are the rules for the common protocols:
 
-`Build -> GetTargetFrameworks, <default>, GetNativeManifest, GetCopyToOutputDirectoryItems`
+`Build -> GetTargetFrameworks, .default, GetNativeManifest, GetCopyToOutputDirectoryItems`
 
-The default target (represented in this spec's pseudo protocol representation as `<default>`) is resolved for each project.
+`.default` is resolved for each project.
 
 `Clean -> GetTargetFrameworks, Clean`
 
-`Rebuild -> GetTargetFrameworks, Clean, <default>, GetNativeManifest, GetCopyToOutputDirectoryItems`
+`Rebuild -> GetTargetFrameworks, Clean, .default, GetNativeManifest, GetCopyToOutputDirectoryItems`
 
 `Rebuild` actually calls `Clean` and `Build`, which in turn uses the concatenation of the `Clean` and `Build` mappings. `GetTargetFrameworks` is repeated so only the first call to it remains in the final target list.
 
@@ -358,7 +360,7 @@ namespace Microsoft.Build.Experimental.Graph
 ```
 
 ## Isolated builds
-Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any BuildResult objects for project references must be pre-computed and somehow provided as inputs to the referencing project.
+Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any `BuildResult` objects for project references must be precomputed and somehow provided as inputs to the referencing project.
 
 If a project uses the MSBuild task, the build result must be in MSBuild's build result cache instead of just-in-time executing targets on that referenced project. If it is not in the build result cache, an error will be logged and the build will fail. If the project is calling into itself either via `CallTarget` or the MSBuild task with a different set of global properties, this will be allowed to support multitargeting and other build dimensions implemented in a similar way.
 
@@ -367,7 +369,7 @@ Because referenced projects and their entry targets are guaranteed to be in the
 ### Isolated graph builds
 When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.
 
-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
+Furthermore, running in this mode enforces that each `(project, global properties)` pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
 
 This discrete start and end time also allows for easy integration with [I/O Tracking](#io-tracking) to observe all inputs and outputs for a project. Note however that I/O during target execution, particular target execution which may not normally happen as part of a project's individual build execution, would be attributed to the project reference project rather the project with the project reference. This differs from today's behavior, but seems like a desirable difference anyway.
 
@@ -387,9 +389,9 @@ These incremental builds could be extended to the entire graph by keeping a proj
 Details on how isolation and cache files are implemented in MSBuild can be found [here](./static-graph-implementation-details.md).
 
 #### APIs
-Cache file information is provided via [BuildParameters](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one BuildManager BeginBuild/EndBuild session.
+Cache file information is provided via [`BuildParameters`](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one `BuildManager` `BeginBuild`/`EndBuild` session.
 
-Isolation constraints are turned on via [BuildParameters.IsolateProjects](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used.
+Isolation constraints are turned on via [`BuildParameters.IsolateProjects`](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used, except when the `isolate:MessageUponIsolationViolation` switch is used.
 
 #### Command line
 Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
@@ -401,14 +403,21 @@ In certain situations one may want to exempt a reference from isolation constrai
 - exempting references whose project files are generated at build times with random names (for example, each WPF project, before the Build target, generates and builds a helper .csproj with a random file name)
 - relaxing constraints for MSBuild task calling patterns that static graph cannot express (for exemple, if a project is calculating references, or the targets to call on references, at runtime via an arbitrary algorithm)
 
-A project is exempt from isolation constraints by adding its full path to the `GraphIsolationExemptReference` item. For example, if project A.csproj references project B.csproj, the following snippet exempts B.csproj from isolation constraints while A.csproj is built:
-```xml
-<ItemGroup>
-  <GraphIsolationExemptReference Include="/Full/Path/To/B.csproj" />
-</ItemGroup>
-```
-
-A reference is exempt only in projects that add the reference in `GraphIsolationExemptReference`. If multiple projects need to exempt the same reference, all of them need to add the reference to `GraphIsolationExemptReference`.
+A project may be exempt from isolation constraints in two ways:
+
+<!-- List is encoded in HTML since XML code block
+and its following text won't be indented properly. -->
+<ul>
+<li>its full path is added to the <code>GraphIsolationExemptReference</code> item. For example, if project <code>A.csproj</code> references project <code>B.csproj</code>, the following snippet exempts <code>B.csproj</code> from isolation constraints while <code>A.csproj</code> is built:
+<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
+  <span class="hljs-tag">&lt;<span class="hljs-name">GraphIsolationExemptReference</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"/Full/Path/To/B.csproj"</span> /&gt;</span>
+<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
+</code></pre>
+If multiple projects need to exempt the same reference, all of them need to add the reference to <code>GraphIsolationExemptReference</code>.
+</li>
+<li> via the <code>isolate:MessageUponIsolationViolation</code> switch
+</li>
+</ul>
 
 For now, self-builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.
 
diff --git a/documentation/terminallogger/Opt-In-Mechanism.md b/documentation/terminallogger/Opt-In-Mechanism.md
new file mode 100644
index 00000000000..f6d63e7f4ac
--- /dev/null
+++ b/documentation/terminallogger/Opt-In-Mechanism.md
@@ -0,0 +1,38 @@
+# TerminalLogger Opt-in
+
+## When should we use TerminalLogger
+
+The TerminalLogger presents the user with the build's most relevant information at the time, automatically hiding all the information that is no longer relevant (as to prevent huge log outputs). However, many users might find this not very useful (or even counterproductive) such as those using a terminal without proper ANSI support or when redirecting the output to a file. For that reason, the users must be able to turn this feature on/off at will.
+
+## Proposal
+
+### Enabling for a single build
+
+Using the `/terminallogger` or `/tl` command line switches, users are able to opt-in and use the TerminalLogger, EXCEPT when:
+
+- The terminal does not support ANSI codes or color
+- Output is redirected to a file or pipe
+
+### Enabling for all builds
+
+Users can set the `MSBUILDTERMINALLOGGER` environment variable to enable TerminalLogger without adding a swtich to all build invocations.
+
+### TerminalLogger parameters
+
+Both methods accept parameters:
+
+- `true` forces TerminalLogger to be used even wwhen it would be disabled
+- `false` forces TerminalLogger to not be used even when it would be enabled
+- `auto` enables TerminalLogger when the terminal supports it and the session doesn't have redirected stdout/stderr
+
+In cases where the TerminalLogger should not be enabled, the default ConsoleLogger should be used instead.
+
+## Considerations
+
+### Should TerminalLogger be used with other loggers (eg, BinaryLogger, FileLogger, custom loggers)?
+
+TerminalLogger should only replace the current ConsoleLogger for the aforementioned cases. Additionally, other loggers can be used in conjunction.
+
+### Should output be ignored with the `/noconsolelogger` flag enabled?
+
+TerminalLogger serves as a replacement for ConsoleLogger, so it should behave similarly. When attaching the `/noconsolelogger` flag, it should not output anything.
diff --git a/documentation/wiki/ChangeWaves-Dev.md b/documentation/wiki/ChangeWaves-Dev.md
index de8d8e11725..7c0c0e86cf4 100644
--- a/documentation/wiki/ChangeWaves-Dev.md
+++ b/documentation/wiki/ChangeWaves-Dev.md
@@ -1,4 +1,4 @@
-‚ö† This doc is intended for internal teams.
+‚ö† This doc is intended for internal teams. For information about how to deal with MSBuild Change Waves as an MSBuild _user_, see [ChangeWaves.md](ChangeWaves.md).
 
 # What are Change Waves?
 A Change Wave is a set of risky features developed under the same opt-out flag. The purpose of this is to warn developers of risky changes that will become standard functionality down the line. If there's something we think is worth the risk, we found that Change Waves were a good middle ground between making necessary changes and warning customers of what will soon be permanent.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 25f81f0eebe..9fb1d1cc7fc 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -23,12 +23,20 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 
 ## Current Rotation of Change Waves
 
+### 17.8
+- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
+- [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
+- [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
+- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
+
+
 ### 17.6
 - [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
 - [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
 - [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
 - [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
 - [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
+- [Log item self-expansion](https://github.com/dotnet/msbuild/pull/8581)
 
 ### 17.4
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
@@ -61,4 +69,4 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
 - [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
 - [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
-- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
\ No newline at end of file
+- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
diff --git a/documentation/wiki/Controlling-Dependencies-Behavior.md b/documentation/wiki/Controlling-Dependencies-Behavior.md
new file mode 100644
index 00000000000..ceafb75a2d1
--- /dev/null
+++ b/documentation/wiki/Controlling-Dependencies-Behavior.md
@@ -0,0 +1,264 @@
+# Controlling references behavior
+
+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.
+
+## .NET SDK projects and access to transitive references
+
+[.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) by default make all transitive references accessible as if they were direct references.
+
+This is provided for the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.
+
+It is facilitated via `project.assets.json` file created by NuGet client during the restore operation. This file captures the whole transitive closure of the project dependency tree.
+
+SDK build tasks require existence of this file (hence the infamous `Assets file <path>\project.assets.json not found` if the MSBuild.exe is run without prior restore operation). It is used to reconstruct the `ProjectReference`s and create `Reference` items for the content of `PackageReference`s for the project and make them available to the rest of the build. For this reason MSBuild and compiler by default sees those transitive references as if they were direct references.
+
+## Access to transitive project references
+
+Above described behavior can lead to easy unintentional breaking out of layering architecture separation. 
+
+This behavior can be opted-out for `ProjectReference`s via `DisableTransitiveProjectReferences` property on the referencing project.
+
+<a name="OnionArchSample"></a>*Example*:
+
+Let's imagine an `Onion Architecture` design:
+
+```mermaid
+flowchart LR
+    Service[Service Layer] --> Repository
+    Repository[Repository Layer] --> Domain[Domain Layer]
+```
+
+Service Layer definition:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj" />
+  </ItemGroup>
+
+  <PropertyGroup>
+    <TargetFramework>net48</TargetFramework>
+    <LangVersion>10</LangVersion>
+    <!-- This prevents referencing types from transitive project references. -->
+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>
+  </PropertyGroup>
+</Project>
+```
+
+```csharp
+namespace Service;
+	
+public class PersonsAccessor
+{
+    private Repository.Persona _persona;
+    // This is allowed unless DisableTransitiveProjectReferences=true is passed into build.
+    // private Domain.PersonTable _tbl;
+}
+```
+
+## Access to transitive package references
+
+The transitive access to references works by default for package references as well. This can be opted out for referencing projects via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)).
+
+When using this metadatum - the access to the package, its dirrect and transitive dependencies is **not** restricted for the project declaring the refenerence on the package in its `Project` element. It is restricted for the projects referencing the project (or package) that specified the `PackageRegerence` with the `PrivateAssets` metadatum.
+
+*Example*:
+
+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:
+
+```mermaid
+flowchart LR
+    Service[Service Layer] --> Repository
+    Repository[Repository Layer] --> newtonsoft.json[newtonsoft.json]
+```
+
+We are not able to influence access to `newtonsoft.json` and its dependencies (would there be any) in the `Repository Layer`, but we can prevent it from propagating to `Service Layer`.
+
+`Repository Layer`:
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- This prevents the reference to be available to referencing types. -->
+    <PrivateAssets>compile</PrivateAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+Unless opted out via `PrivateAssets=compile`, our `Service Layer` would have access to `newtonsoft.json`:
+
+```csharp
+namespace Service;
+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.
+//using Newtonsoft.Json;
+	
+public class PersonsAccessor
+{
+    private Repository.Persona _persona;
+}
+```
+
+**Notes:**
+   `PrivateAssets` metadatum (and it's counterparts `IncludeAssets` and `ExcludeAssets`) is applicable to `PackageReference` and controls exposure of dependencies to the consuming projects, not the current project. It is currently not possible to prevent access to package references from within directly referencing project - this is purely decision of the package itself (as it can define it's dependencies as `PrivateAssets`).
+
+## Not copying dependencies to output
+
+By default the above mentioned dependency types are copied to the build output directory during the build. There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).
+
+Overriding this logic depends on the type of the dependency.
+
+### Not copying Assembly Reference
+
+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):
+
+```xml
+<ItemGroup>
+  <Reference Include="mydll">
+    <HintPath>..\somepath\mydll.dll</HintPath>
+    <!-- This indicates that the reference should not be copied to output folder. -->
+    <Private>false</Private>
+  </Reference>
+</ItemGroup>
+```
+
+### Not copying PackageReference
+
+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:
+
+**Not copying package dependency to the immediate output folder:**
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->
+    <IncludeAssets>compile</IncludeAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+**Not copying package dependency to the downstream dependants output folder:**
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- The dependency is copied to output folder in current referencing project, 
+           but it's not copied to output folder of projects referencing current project. -->
+    <PrivateAssets>all</PrivateAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+**Not copying package dependency from the upstream dependencies:**
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->
+    <ExcludeAssets>all</ExcludeAssets>
+  </ProjectReference>
+</ItemGroup>
+```
+
+### Not copying ProjectReference
+
+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This indicates that the referenced project output should not be copied to output folder. -->
+    <Private>false</Private>
+  </ProjectReference>
+</ItemGroup>
+```
+
+Same metadata and logic applies here as it is being inherited from the `Reference` Item definition and the logic treats it identicaly. 
+
+## ProjectReference without accessibility and copying to output
+
+In a specific scenarios we might want to indicate that specific project should be built prior our project but said project should not be reference accessible nor its output copied to current project output. This can be helpful for build time only dependencies - projects defining behavior that is going to be used as build step of a current project.
+
+Such a behavior can be achived with [`ReferenceOutputAssembly` metadata](https://learn.microsoft.com/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference):
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This indicates that the referenced project should not be referenced in code and output should not be copied to output folder. 
+         This way we basically only indicate the build order.
+    -->
+    <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+  </ProjectReference>
+</ItemGroup>
+```
+
+**Note:** This technique has possibly unexpected behavior when referencing project with executable output type (`<OutputType>Exe</OutputType>`) - in such case the output assembly (`.dll`) is still not copied and referenced (as the metadatum name implies) and hence the types defined within the project cannot be referenced, however other supplementary output (added as `content` or `none`) is copied to the current project output folder (for .NET Core this includes `deps.json`, `runtimeconfig.json` and mainly `<app>.exe`). In that case we can combine (or replace) the `ReferenceOutputAssembly` metadata with `Private` metadata - [as described above](#not-copying-projectreference). More details on this case [here](https://github.com/dotnet/msbuild/issues/4795#issuecomment-1442390297)
+
+## Forcing TargetFramework of a referenced multitargeted project
+
+Consider agaoin our previous [Onion architecture example](#OnionArchSample), but now the individual projects will be [multitargeted](https://learn.microsoft.com/nuget/create-packages/multiple-target-frameworks-project-file). 
+
+Repository Layer:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFrameworks>netstandard2.0;net48</TargetFrameworks>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' == 'net48'">
+    <ProjectReference Include="..\Domain-net48\Domain-net48.csproj" />
+    <PackageReference Include="System.Text.Json" Version="7.0.2" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
+    <ProjectReference Include="..\Domain-netstd20\Domain-netstd20.csproj" />
+    <PackageReference Include="newtonsoft.json" Version="13.0.1">
+  </ItemGroup>
+</Project>
+```
+
+And it's going to be referenced by Service Layer:
+
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <OutputType>Exe</OutputType>
+    <TargetFrameworks>net48;netstandard2.0</TargetFrameworks>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj"  />
+  </ItemGroup>
+</Project>
+```
+
+Building the Service Layer will create output folders for `net7` and `net48`:
+
+```
+net48
+ |---- Repository.dll (targeted for net48)
+ |---- Domain-net48.dll
+ |---- System.Text.Json.dll
+
+net7
+ |---- Repository.dll (targeted for netstandard2.0)
+ |---- Domain-netstd20.dll
+ |---- Newtonsoft.Json.dll 
+```
+
+Should we want to reference the netstandard version of the Repository Layer in our Service Layer - we can force the reference chain via `SetTargetFramework` metadata on `ProjectReference` item:
+
+```xml
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj" SetTargetFramework="TargetFramework=netstandard2.0" />
+  </ItemGroup>
+```
+
+**Notes:** 
+
+`SetTargetFramework` is currently not honored by the NuGet client([nuget issue #12436](https://github.com/NuGet/Home/issues/12436)), so the output folder will contain binaries from nuget packages as if this metadata was not used. To workaround this the apropriate nuget needs to be directly referenced from the project enforcing reference framework via `SetTargetFramework`, or copied to output/publish folder via different means.
+
+
+`SetTargetFramework` will properly enforce the framework for the `ProjectReference` chain. Once the `TargetFramework` overriding is encountered it is passed down the reference chain and the `ProjectReference`s respect it during the `TargetFramework` resolution. Due to the nature of handling of [transitive references in .NET-SDK style projects](#net-sdk-projects-and-access-to-transitive-references) and the fact that NuGet client doesn't honor `SetTargetFramework`, the transitive references can get resolved and built for multiple `TargetFramework`s. This means the output folder will contain proper version of the direct dependency - Repository Layer. The transitive references might overbuild, and output folder of current project (Service Layer) might contain both versions of the transitive project dependency (Domain-net48.dll and Domain-netstd20.dll). This limitation can be workarounded by switching of the transitive project references via `DisableTransitiveProjectReferences` (same as shown in [Access to transitive project references](#access-to-transitive-project-references))
+
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
index b9be0b3f59b..3fa12a84f6a 100644
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ b/documentation/wiki/Providing-Binary-Logs.md
@@ -6,25 +6,39 @@ However, you should be aware what type of information is captured in the binary
 
 ‚ö† NOTE: some build environments make secrets available using environment variables. Before sharing a binary log, make sure it does not expose API tokens or other important secrets.
 
+## Capturing Binary Logs for command-line builds
+
 You can create a binary log by passing the `-bl` parameter to MSBuild (`MSBuild.exe` or `dotnet build`). You can explore the contents of the generated .binlog file using [MSBuild Structured Log Viewer](http://msbuildlog.com/) or in your browser using [Live Structured Log Viewer](https://live.msbuildlog.com). Note: We don't capture any data from binary logs viewed on your browser.
 
+Examples:
+
+```sh
+dotnet build -bl
+dotnet build -bl:SpecificStep.binlog
+MSBuild.exe -bl:ServiceRelease.binlog -p:Configuration=Release
+```
+
 [More details about binary logs](Binary-Log.md)
 
 ## Capturing Binary Logs Through Visual Studio
-### (Preferred way) Capturing logs for all MSBuild invocations
+
+### Capturing logs for all MSBuild invocations
+
 Set `MSBUILDDEBUGENGINE` environment variable to `'1'` and (optionally) set `MSBUILDDEBUGPATH` to an existing destination folder to store the captured logs. Then start Visual Studio from the same shell to inherit the environment:
 
 `cmd:`
-```
+
+```batch
 > SET MSBUILDDEBUGENGINE=1
 > SET MSBUILDDEBUGPATH=C:\MSBuildReproLogs
 > devenv.exe MySolution.sln
 ```
 
 `PowerShell:`
-```
+
+```powershell
 > $env:MSBUILDDEBUGENGINE = 1
-> $env:MSBUILDDEBUGPATH= C:\MSBuildReproLogs
+> $env:MSBUILDDEBUGPATH="C:\MSBuildReproLogs"
 > & "devenv.exe" MySolution.sln
 ```
 
@@ -33,8 +47,10 @@ MSBuild binary logs are then captured to a location specified via `MSBUILDDEBUGP
 ‚ö† NOTE: logs are being recorded for each MSBuild invocation (including design time builds) and kept in the folder without removing older ones - so the number of log files can grow quickly. It is recommended to set the opt-in environment variable only for the short duration of reproducing the issue to be investigated (though it is understandable that some nondeterministic issues might need multiple reproduction attempts)
 
 Further reading:
+
 * [More technical info](Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#logs)
 * [Design time builds logs](https://github.com/dotnet/project-system/blob/main/docs/repo/debugging/design-time-builds.md#gathering-full-fidelity-binlogs)
 
 ### Capturing specific logs for chosen build invocations
+
 See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index 5a6b132e78e..02e1e308112 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -33,13 +33,16 @@
   <Target Name="GatherNuGetDependencies" AfterTargets="ResolvePackageAssets">
     <ItemGroup>
         <!-- Collect known NuGet dependencies after resolving packages -->
-        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGet.'))' == 'True'" />
-        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Newtonsoft.Json'))' == 'True'" />
-        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGetSdkResolver'))' == 'True'" />
-        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Microsoft.Extensions.'))' == 'True'" />
+        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGet.'))' == 'true'" />
+        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Newtonsoft.Json'))' == 'true'" />
+        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGetSdkResolver'))' == 'true'" />
+        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Microsoft.Extensions.'))' == 'true'" />
 
-        <!-- NuGet.targets will be in the ResolvedRuntimeTargets ItemGroup -->
-        <_NuGetRuntimeDependencies Include="%(RuntimeTargetsCopyLocalItems.Identity)" Condition="'@(RuntimeTargetsCopyLocalItems->Contains('NuGet.'))' == 'True'" />
+        <!-- NuGet.targets and NuGet.RestoreEx.targets will be in the RuntimeTargetsCopyLocalItems ItemGroup -->
+        <_NuGetRuntimeDependencies Include="%(RuntimeTargetsCopyLocalItems.Identity)" Condition="'@(RuntimeTargetsCopyLocalItems->Contains('NuGet.'))' == 'true'" />
+
+        <!-- NuGet.Build.Tasks.Console.exe will be in the None ItemGroup -->
+        <_NuGetRuntimeDependencies Include="%(None.Identity)" Condition="'@(None->Contains('NuGet.'))' == 'true'" />
 
         <_NuGetRuntimeDependencies Include="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\RuntimeIdentifierGraph.json" />
     </ItemGroup>
@@ -53,11 +56,11 @@
          need to be in a specific location that does not mesh with NuGet. To resolve this, we include the default
          PackageReference assets but will remove them from the Reference ItemGroup before RAR runs and avoid the warnings -->
     <ItemGroup>
-        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Build'))' == 'True'" />
-        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGet.'))' == 'True'" />
-        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Newtonsoft.Json'))' == 'True'" />
-        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGetSdkResolver'))' == 'True'" />
-        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Extensions.'))' == 'True'" />
+        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Build'))' == 'true'" />
+        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGet.'))' == 'true'" />
+        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Newtonsoft.Json'))' == 'true'" />
+        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGetSdkResolver'))' == 'true'" />
+        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Extensions.'))' == 'true'" />
     </ItemGroup>
   </Target>
 
@@ -65,6 +68,9 @@
     <ItemGroup>
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\*.targets" />
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\*.props" />
+      <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\Tracker*.dll" />
+      <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\Tracker*.exe" />
+      <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\FileTracker*.dll" />
       <SdkResolverFiles Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\**\*.*" />
       <NuGetSdkResolverManifest Include= "$(RepoRoot)src\MSBuild\SdkResolvers\VS\Microsoft.Build.NuGetSdkResolver.xml" Condition="'$(MonoBuild)' != 'true'" />
       <NuGetSdkResolverManifest Include= "$(RepoRoot)src\MSBuild\SdkResolvers\Standalone\Microsoft.Build.NuGetSdkResolver.xml" Condition="'$(MonoBuild)' == 'true'" />
@@ -122,35 +128,45 @@
 
     <!-- Copy in props and targets from the machine-installed MSBuildExtensionsPath -->
     <Copy SourceFiles="@(InstalledVersionedExtensions)"
-          DestinationFiles="@(InstalledVersionedExtensions->'$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(InstalledVersionedExtensions->'$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
     <Copy SourceFiles="@(SdkResolverFiles)"
-          DestinationFiles="@(SdkResolverFiles->'$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(SdkResolverFiles->'$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <Copy SourceFiles="@(InstalledMicrosoftExtensions)"
-          DestinationFiles="@(InstalledMicrosoftExtensions->'$(BootstrapDestination)Microsoft\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(InstalledMicrosoftExtensions->'$(BootstrapDestination)Microsoft\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <Copy SourceFiles="@(InstalledSdks)"
           DestinationFiles="@(InstalledSdks -> '$(BootstrapDestination)Sdks\%(RecursiveDir)%(Filename)%(Extension)')"
-          Condition="'$(MonoBuild)' != 'true'" />
+          Condition="'$(MonoBuild)' != 'true'"
+          SkipUnchangedFiles="true" />
     <Copy SourceFiles="@(InstalledSdks)"
           DestinationFiles="@(InstalledSdks -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\Sdks\%(RecursiveDir)%(Filename)%(Extension)')"
-          Condition="'$(MonoBuild)' == 'true'" />
+          Condition="'$(MonoBuild)' == 'true'"
+          SkipUnchangedFiles="true" />
 
     <Copy SourceFiles="@(InstalledStaticAnalysisTools)"
-          DestinationFiles="@(InstalledStaticAnalysisTools -> '$(BootstrapDestination)..\Team Tools\Static Analysis Tools\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(InstalledStaticAnalysisTools -> '$(BootstrapDestination)..\Team Tools\Static Analysis Tools\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <Copy SourceFiles="@(InstalledNuGetFiles)"
-          DestinationFiles="@(InstalledNuGetFiles->'$(BootstrapDestination)Microsoft\NuGet\%(Filename)%(Extension)')" />
+          DestinationFiles="@(InstalledNuGetFiles->'$(BootstrapDestination)Microsoft\NuGet\%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <Copy Condition="'$(MonoBuild)' != 'true'"
           SourceFiles="@(_NuGetRuntimeDependencies)"
-          DestinationFolder="$(BootstrapDestination)..\Common7\IDE\CommonExtensions\Microsoft\NuGet\" />
+          DestinationFolder="$(BootstrapDestination)..\Common7\IDE\CommonExtensions\Microsoft\NuGet\"
+          SkipUnchangedFiles="true" />
     <Copy Condition="'$(MonoBuild)' == 'true'"
           SourceFiles="@(_NuGetRuntimeDependencies)"
-          DestinationFolder="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin" />
+          DestinationFolder="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin"
+          SkipUnchangedFiles="true" />
 
     <Copy SourceFiles="@(NuGetSdkResolverManifest)"
-          DestinationFolder="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.Build.NuGetSdkResolver" />
+          DestinationFolder="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.Build.NuGetSdkResolver"
+          SkipUnchangedFiles="true" />
 
     <!-- Delete shim projects, because they point where we can't follow. -->
     <!-- It would be better to just not copy these. -->
@@ -158,27 +174,36 @@
 
     <!-- Copy our binaries -->
     <Copy SourceFiles="@(FreshlyBuiltBinaries)"
-          DestinationFiles="@(FreshlyBuiltBinaries -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(FreshlyBuiltBinaries -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
+
     <Copy SourceFiles="@(RoslynBinaries)"
-          DestinationFiles="@(RoslynBinaries -> '$(BootstrapDestination)15.0\Bin\Roslyn\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(RoslynBinaries -> '$(BootstrapDestination)15.0\Bin\Roslyn\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <!-- Copy our binaries to the x64 location. -->
-     <Copy SourceFiles="@(FreshlyBuiltBinariesx64)"
-          DestinationFiles="@(FreshlyBuiltBinariesx64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
+    <Copy SourceFiles="@(FreshlyBuiltBinariesx64)"
+          DestinationFiles="@(FreshlyBuiltBinariesx64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <!-- Copy our binaries to the arm64 location. -->
-     <Copy SourceFiles="@(FreshlyBuiltBinariesArm64)"
-          DestinationFiles="@(FreshlyBuiltBinariesArm64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')" />
+    <Copy SourceFiles="@(FreshlyBuiltBinariesArm64)"
+          DestinationFiles="@(FreshlyBuiltBinariesArm64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <!-- Copy our freshly-built props and targets, overwriting anything we copied from the machine -->
     <Copy SourceFiles="@(FreshlyBuiltRootProjects)"
-          DestinationFiles="@(FreshlyBuiltRootProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(Filename)%(Extension)')" />
+          DestinationFiles="@(FreshlyBuiltRootProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
     <Copy SourceFiles="@(FreshlyBuiltProjects)"
-          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
     <Copy SourceFiles="@(FreshlyBuiltProjects)"
-          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
     <Copy SourceFiles="@(FreshlyBuiltProjects)"
-          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
   </Target>
 
@@ -221,6 +246,12 @@
     <Copy SourceFiles="@(_NuGetRuntimeDependencies)"
           DestinationFolder="$(BootstrapDestination)" />
 
+    <Copy SourceFiles="$(RepoRoot)src\MSBuild.Bootstrap\RedirectNuGetConsoleProcess.After.Microsoft.Common.targets"
+          DestinationFolder="$(BootstrapDestination)\Current\Microsoft.Common.targets\ImportAfter" />
+
+    <Copy SourceFiles="$(RepoRoot)src\MSBuild.Bootstrap\RedirectNuGetConsoleProcess.After.Microsoft.Common.targets"
+          DestinationFolder="$(BootstrapDestination)\Current\SolutionFile\ImportAfter" />
+
     <!-- Disable workload resolver until we can figure out whether it can work in the bootstrap
          https://github.com/dotnet/msbuild/issues/6566 -->
     <Touch Files="$(BootstrapDestination)\DisableWorkloadResolver.sentinel" AlwaysCreate="true" />
diff --git a/eng/Build.props b/eng/Build.props
index 92315cd00ab..f2afe806410 100644
--- a/eng/Build.props
+++ b/eng/Build.props
@@ -2,13 +2,9 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
 
-<!-- Commented out as a temporary fix for the msbuild CI.
-Waiting for https://github.com/NuGet/NuGet.Client/pull/5010 fix to flow to CI machines. -->
-<!--
   <PropertyGroup>
     <RestoreUseStaticGraphEvaluation Condition="'$(DotNetBuildFromSource)' != 'true'">true</RestoreUseStaticGraphEvaluation>
   </PropertyGroup>
--->
 
   <ItemGroup>
 	<!-- Remove all sln files globbed by arcade so far and add only MSBuild.sln to the build.
diff --git a/eng/Packages.props b/eng/Packages.props
index 08b6d66cf10..ac8df77f629 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -13,8 +13,9 @@
     <PackageVersion Include="Microsoft.CodeAnalysis.Collections" Version="$(MicrosoftCodeAnalysisCollectionsVersion)" />
     <PackageVersion Include="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
     <PackageVersion Include="Microsoft.IO.Redist" Version="$(MicrosoftIORedistVersion)" />
-	<PackageVersion Include="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" Condition="'$(UsingToolMicrosoftNetCompilers)' != 'true'" />
+    <PackageVersion Include="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" Condition="'$(UsingToolMicrosoftNetCompilers)' != 'true'" />
     <PackageVersion Include="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
+    <PackageVersion Include="NuGet.Build.Tasks.Console" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
     <PackageVersion Include="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
@@ -24,13 +25,10 @@
     <PackageVersion Include="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
     <PackageVersion Include="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
     <PackageVersion Include="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
-    <PackageVersion Include="System.Security.Permissions" Version="$(SystemSecurityPermissionsVersion)" />
     <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
     <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
-    <PackageVersion Include="xunit.assert" Version="$(XUnitVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
-    <PackageVersion Include="xunit.core" Version="$(XUnitVersion)" />
   </ItemGroup>
 </Project>
diff --git a/eng/Signing.props b/eng/Signing.props
index 66347f3d9d1..3e8e6dbf5cc 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -1,9 +1,11 @@
 <Project>
   <ItemGroup>
     <ItemsToSign Include="$(VisualStudioSetupInsertionPath)Microsoft.Build.UnGAC.exe" />
+
+    <FileSignInfo Include="RuntimeContracts.dll" CertificateName="3PartySHA2" />
   </ItemGroup>
-    
+
   <PropertyGroup>
     <UseDotNetCertificate>true</UseDotNetCertificate>
   </PropertyGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/eng/SourceBuild.props b/eng/SourceBuild.props
index 2bd3712f6ee..a7925ca3dc3 100644
--- a/eng/SourceBuild.props
+++ b/eng/SourceBuild.props
@@ -1,9 +1,10 @@
+<!-- Whenever altering this or other Source Build files, please include @dotnet/source-build-internal as a reviewer. -->
+
 <Project>
 
   <PropertyGroup>
     <GitHubRepositoryName>msbuild</GitHubRepositoryName>
     <SourceBuildManagedOnly>true</SourceBuildManagedOnly>
-    <SourceBuildTrimNetFrameworkTargets>true</SourceBuildTrimNetFrameworkTargets>
   </PropertyGroup>
 
   <Target Name="ConfigureInnerBuildArgs" BeforeTargets="GetSourceBuildCommandConfiguration">
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index c1b6dfbf053..15a527720b7 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -1,5 +1,18 @@
+<!-- Whenever altering this or other Source Build files, please include @dotnet/source-build-internal as a reviewer. -->
+<!-- See aka.ms/dotnet/prebuilts for guidance on what pre-builts are and how to eliminate them. -->
+
 <UsageData>
   <IgnorePatterns>
-    <UsagePattern IdentityGlob="*/*" />
+    <UsagePattern IdentityGlob="Microsoft.SourceBuild.Intermediate.*/*" />
+
+    <!-- Baseline 7.0 dependencies until msbuild targets net8 and uses a net8 arcade, SBRP, etc.
+         These cannot be added to 7.0 SBRP, because they would are produced in the 7.0 build. -->
+    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*7.0.3*" />
   </IgnorePatterns>
+  <Usages>
+  </Usages>
 </UsageData>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index abd0c3e78a1..8bc30740f26 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,23 +1,85 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
+  <ProductDependencies>
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.23428.2">
+      <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
+      <Sha>26ce96327dd346534926c4551f8b8d62a6fc724f</Sha>
+      <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.CodeDom" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <!-- Necessary for source-build due to being a transitive dependency of System.Reflection.MetadataLoadContext.
+      This allows the package to be retrieved from previously-source-built artifacts and flow in as dependencies
+      of the packages produced by msbuild. -->
+    <Dependency Name="System.Collections.Immutable" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
+      and flow in as dependencies of the packages produced by msbuild. -->
+    <Dependency Name="System.Configuration.ConfigurationManager" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
+      and flow in as dependencies of the packages produced by msbuild. -->
+    <Dependency Name="System.Reflection.Metadata" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
+      and flow in as dependencies of the packages produced by msbuild. -->
+    <Dependency Name="System.Reflection.MetadataLoadContext" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Resources.Extensions" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
+      and flow in as dependencies of the packages produced by msbuild. -->
+    <Dependency Name="System.Security.Cryptography.Pkcs" Version="7.0.2">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Cryptography.Xml" Version="7.0.1">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <Dependency Name="System.Text.Json" Version="7.0.3">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>5b20af47d99620150c53eaf5db8636fdf730b126</Sha>
+    </Dependency>
+  </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.24218.1">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23425.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>6a6f2717562e54654ddd34f71e3838048aaf8a39</Sha>
+      <Sha>90c167d5c57de4a8bced566379dbd893556c94e8</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.7.0-preview.2.51">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23423.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+      <Uri>https://github.com/dotnet/xliff-tasks</Uri>
+      <Sha>ed9a83526483c094fb51e7000b6f816ce6cb0325</Sha>
+      <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
+    </Dependency>
+    <Dependency Name="NuGet.Build.Tasks" Version="6.8.0-rc.112">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>f3bb337e310ce44abda4ad73cdb0755ed940809d</Sha>
+      <Sha>f47eb5771ee3f9a100d0b31d82ccb5ee600a56ed</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.7.0-3.23315.4">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.8.0-3.23465.5">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>fcfb85983ac231b870ed737d4be669b50d627b64</Sha>
+      <Sha>dc3d0694a4b31b8e27038431888cd4e8dd5b6cb6</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.24218.1">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23425.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>6a6f2717562e54654ddd34f71e3838048aaf8a39</Sha>
+      <Sha>90c167d5c57de4a8bced566379dbd893556c94e8</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 5de99680a81..3adb0f6b89a 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,9 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.6.11</VersionPrefix>
-    <DotNetFinalVersionKind>release</DotNetFinalVersionKind>
-    <PackageValidationBaselineVersion>17.5.0</PackageValidationBaselineVersion>
+    <VersionPrefix>17.8.7</VersionPrefix><DotNetFinalVersionKind>release</DotNetFinalVersionKind>
+    <PackageValidationBaselineVersion>17.7.0</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -39,7 +38,6 @@
     <SystemReflectionMetadataLoadContextVersion>7.0.0</SystemReflectionMetadataLoadContextVersion>
     <SystemReflectionMetadataVersion>7.0.0</SystemReflectionMetadataVersion>
     <SystemResourcesExtensionsPackageVersion>7.0.0</SystemResourcesExtensionsPackageVersion>
-    <SystemSecurityPermissionsVersion>7.0.0</SystemSecurityPermissionsVersion>
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
   </PropertyGroup>
@@ -49,13 +47,13 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.24218.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23425.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.7.0-3.23315.4</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.7.0-preview.2.51</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.8.0-3.23465.5</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.8.0-rc.112</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
-    <SystemTextJsonVersion>7.0.0</SystemTextJsonVersion>
+    <SystemTextJsonVersion>7.0.3</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index 906a33dc12f..46d471d042b 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -91,8 +91,8 @@ try {
   else
   {
     $buildToolPath = $dotnetExePath
-    $buildToolCommand = Join-Path $bootstrapRoot "net7.0\MSBuild\MSBuild.dll"
-    $buildToolFramework = "netcoreapp3.1"
+    $buildToolCommand = Join-Path $bootstrapRoot "net8.0\MSBuild\MSBuild.dll"
+    $buildToolFramework = "net8.0"
   }
 
   # Use separate artifacts folder for stage 2
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index b4404b7e4ad..ceb2b343329 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -63,8 +63,8 @@ bootstrapRoot="$Stage1Dir/bin/bootstrap"
 if [ $host_type = "core" ]
 then
   _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
-  _InitializeBuildToolCommand="$bootstrapRoot/net7.0/MSBuild/MSBuild.dll"
-  _InitializeBuildToolFramework="netcoreapp3.1"
+  _InitializeBuildToolCommand="$bootstrapRoot/net8.0/MSBuild/MSBuild.dll"
+  _InitializeBuildToolFramework="net8.0"
 elif [ $host_type = "mono" ]
 then
   export _InitializeBuildTool="mono"
diff --git a/eng/common/BuildConfiguration/build-configuration.json b/eng/common/BuildConfiguration/build-configuration.json
new file mode 100644
index 00000000000..3d1cc89894c
--- /dev/null
+++ b/eng/common/BuildConfiguration/build-configuration.json
@@ -0,0 +1,4 @@
+{
+  "RetryCountLimit": 1,
+  "RetryByAnyError": false
+}
diff --git a/eng/common/SetupNugetSources.ps1 b/eng/common/SetupNugetSources.ps1
index 4ed5c54e733..69d1523a006 100644
--- a/eng/common/SetupNugetSources.ps1
+++ b/eng/common/SetupNugetSources.ps1
@@ -146,6 +146,7 @@ $userName = "dn-bot"
 # Insert credential nodes for Maestro's private feeds
 InsertMaestroPrivateFeedCredentials -Sources $sources -Creds $creds -Username $userName -pwd $Password
 
+# 3.1 uses a different feed url format so it's handled differently here
 $dotnet31Source = $sources.SelectSingleNode("add[@key='dotnet3.1']")
 if ($dotnet31Source -ne $null) {
     AddPackageSource -Sources $sources -SourceName "dotnet3.1-internal" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v2" -Creds $creds -Username $userName -pwd $Password
diff --git a/eng/common/SetupNugetSources.sh b/eng/common/SetupNugetSources.sh
index ad3fb74fd2c..d387c7eac95 100644
--- a/eng/common/SetupNugetSources.sh
+++ b/eng/common/SetupNugetSources.sh
@@ -105,53 +105,33 @@ if [ "$?" == "0" ]; then
     PackageSources+=('dotnet3.1-internal-transport')
 fi
 
-# Ensure dotnet5-internal and dotnet5-internal-transport are in the packageSources if the public dotnet5 feeds are present
-grep -i "<add key=\"dotnet5\"" $ConfigFile
-if [ "$?" == "0" ]; then
-    grep -i "<add key=\"dotnet5-internal\"" $ConfigFile
-    if [ "$?" != "0" ]; then
-        echo "Adding dotnet5-internal to the packageSources."
-        PackageSourcesNodeFooter="</packageSources>"
-        PackageSourceTemplate="${TB}<add key=\"dotnet5-internal\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal/nuget/v2\" />"
-
-        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
-    fi
-    PackageSources+=('dotnet5-internal')
-
-    grep -i "<add key=\"dotnet5-internal-transport\">" $ConfigFile
-    if [ "$?" != "0" ]; then
-        echo "Adding dotnet5-internal-transport to the packageSources."
-        PackageSourcesNodeFooter="</packageSources>"
-        PackageSourceTemplate="${TB}<add key=\"dotnet5-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal-transport/nuget/v2\" />"
-
-        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
-    fi
-    PackageSources+=('dotnet5-internal-transport')
-fi
-
-# Ensure dotnet6-internal and dotnet6-internal-transport are in the packageSources if the public dotnet6 feeds are present
-grep -i "<add key=\"dotnet6\"" $ConfigFile
-if [ "$?" == "0" ]; then
-    grep -i "<add key=\"dotnet6-internal\"" $ConfigFile
-    if [ "$?" != "0" ]; then
-        echo "Adding dotnet6-internal to the packageSources."
-        PackageSourcesNodeFooter="</packageSources>"
-        PackageSourceTemplate="${TB}<add key=\"dotnet6-internal\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet6-internal/nuget/v2\" />"
+DotNetVersions=('5' '6' '7' '8')
+
+for DotNetVersion in ${DotNetVersions[@]} ; do
+    FeedPrefix="dotnet${DotNetVersion}";
+    grep -i "<add key=\"$FeedPrefix\"" $ConfigFile
+    if [ "$?" == "0" ]; then
+        grep -i "<add key=\"$FeedPrefix-internal\"" $ConfigFile
+        if [ "$?" != "0" ]; then
+            echo "Adding $FeedPrefix-internal to the packageSources."
+            PackageSourcesNodeFooter="</packageSources>"
+            PackageSourceTemplate="${TB}<add key=\"$FeedPrefix-internal\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/$FeedPrefix-internal/nuget/v2\" />"
+
+            sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+        fi
+        PackageSources+=("$FeedPrefix-internal")
 
-        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
-    fi
-    PackageSources+=('dotnet6-internal')
+        grep -i "<add key=\"$FeedPrefix-internal-transport\">" $ConfigFile
+        if [ "$?" != "0" ]; then
+            echo "Adding $FeedPrefix-internal-transport to the packageSources."
+            PackageSourcesNodeFooter="</packageSources>"
+            PackageSourceTemplate="${TB}<add key=\"$FeedPrefix-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/$FeedPrefix-internal-transport/nuget/v2\" />"
 
-    grep -i "<add key=\"dotnet6-internal-transport\">" $ConfigFile
-    if [ "$?" != "0" ]; then
-        echo "Adding dotnet6-internal-transport to the packageSources."
-        PackageSourcesNodeFooter="</packageSources>"
-        PackageSourceTemplate="${TB}<add key=\"dotnet6-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet6-internal-transport/nuget/v2\" />"
-
-        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+            sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+        fi
+        PackageSources+=("$FeedPrefix-internal-transport")
     fi
-    PackageSources+=('dotnet6-internal-transport')
-fi
+done
 
 # I want things split line by line
 PrevIFS=$IFS
diff --git a/eng/common/build.sh b/eng/common/build.sh
index a16e18b174a..50af40cdd2c 100755
--- a/eng/common/build.sh
+++ b/eng/common/build.sh
@@ -19,6 +19,9 @@ usage()
   echo "Actions:"
   echo "  --restore                  Restore dependencies (short: -r)"
   echo "  --build                    Build solution (short: -b)"
+  echo "  --sourceBuild              Source-build the solution (short: -sb)"
+  echo "                             Will additionally trigger the following actions: --restore, --build, --pack"
+  echo "                             If --configuration is not set explicitly, will also set it to 'Release'"
   echo "  --rebuild                  Rebuild solution"
   echo "  --test                     Run all unit tests in the solution (short: -t)"
   echo "  --integrationTest          Run all integration tests in the solution"
@@ -55,6 +58,7 @@ scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
 
 restore=false
 build=false
+source_build=false
 rebuild=false
 test=false
 integration_test=false
@@ -73,7 +77,7 @@ exclude_ci_binary_log=false
 pipelines_log=false
 
 projects=''
-configuration='Debug'
+configuration=''
 prepare_machine=false
 verbosity='minimal'
 runtime_source_feed=''
@@ -119,6 +123,12 @@ while [[ $# > 0 ]]; do
     -pack)
       pack=true
       ;;
+    -sourcebuild|-sb)
+      build=true
+      source_build=true
+      restore=true
+      pack=true
+      ;;
     -test|-t)
       test=true
       ;;
@@ -168,6 +178,10 @@ while [[ $# > 0 ]]; do
   shift
 done
 
+if [[ -z "$configuration" ]]; then
+  if [[ "$source_build" = true ]]; then configuration="Release"; else configuration="Debug"; fi
+fi
+
 if [[ "$ci" == true ]]; then
   pipelines_log=true
   node_reuse=false
@@ -187,7 +201,6 @@ function InitializeCustomToolset {
 }
 
 function Build {
-
   InitializeToolset
   InitializeCustomToolset
 
@@ -206,6 +219,7 @@ function Build {
     /p:RepoRoot="$repo_root" \
     /p:Restore=$restore \
     /p:Build=$build \
+    /p:ArcadeBuildFromSource=$source_build \
     /p:Rebuild=$rebuild \
     /p:Test=$test \
     /p:Pack=$pack \
diff --git a/eng/common/cross/arm/sources.list.focal b/eng/common/cross/arm/sources.list.focal
new file mode 100644
index 00000000000..4de2600c174
--- /dev/null
+++ b/eng/common/cross/arm/sources.list.focal
@@ -0,0 +1,11 @@
+deb http://ports.ubuntu.com/ubuntu-ports/ focal main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ focal main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ focal-updates main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ focal-updates main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ focal-backports main restricted
+deb-src http://ports.ubuntu.com/ubuntu-ports/ focal-backports main restricted
+
+deb http://ports.ubuntu.com/ubuntu-ports/ focal-security main restricted universe multiverse
+deb-src http://ports.ubuntu.com/ubuntu-ports/ focal-security main restricted universe multiverse
diff --git a/eng/common/cross/arm/sources.list.jammy b/eng/common/cross/arm/sources.list.jammy
new file mode 100644
index 00000000000..6bb0453029c
--- /dev/null
+++ b/eng/common/cross/arm/sources.list.jammy
@@ -0,0 +1,11 @@
+deb http://ports.ubuntu.com/ubuntu-ports/ jammy main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ jammy main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ jammy-updates main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ jammy-updates main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ jammy-backports main restricted
+deb-src http://ports.ubuntu.com/ubuntu-ports/ jammy-backports main restricted
+
+deb http://ports.ubuntu.com/ubuntu-ports/ jammy-security main restricted universe multiverse
+deb-src http://ports.ubuntu.com/ubuntu-ports/ jammy-security main restricted universe multiverse
diff --git a/eng/common/cross/arm/sources.list.xenial b/eng/common/cross/arm/sources.list.xenial
index eacd86b7df3..56fbb36a59f 100644
--- a/eng/common/cross/arm/sources.list.xenial
+++ b/eng/common/cross/arm/sources.list.xenial
@@ -8,4 +8,4 @@ deb http://ports.ubuntu.com/ubuntu-ports/ xenial-backports main restricted
 deb-src http://ports.ubuntu.com/ubuntu-ports/ xenial-backports main restricted
 
 deb http://ports.ubuntu.com/ubuntu-ports/ xenial-security main restricted universe multiverse
-deb-src http://ports.ubuntu.com/ubuntu-ports/ xenial-security main restricted universe multiverse
\ No newline at end of file
+deb-src http://ports.ubuntu.com/ubuntu-ports/ xenial-security main restricted universe multiverse
diff --git a/eng/common/cross/arm/tizen/tizen.patch b/eng/common/cross/arm/tizen/tizen.patch
new file mode 100644
index 00000000000..fb12ade7250
--- /dev/null
+++ b/eng/common/cross/arm/tizen/tizen.patch
@@ -0,0 +1,9 @@
+diff -u -r a/usr/lib/libc.so b/usr/lib/libc.so
+--- a/usr/lib/libc.so	2016-12-30 23:00:08.284951863 +0900
++++ b/usr/lib/libc.so	2016-12-30 23:00:32.140951815 +0900
+@@ -2,4 +2,4 @@
+    Use the shared library, but some functions are only in
+    the static library, so try that secondarily.  */
+ OUTPUT_FORMAT(elf32-littlearm)
+-GROUP ( /lib/libc.so.6 /usr/lib/libc_nonshared.a  AS_NEEDED ( /lib/ld-linux-armhf.so.3 ) )
++GROUP ( libc.so.6 libc_nonshared.a  AS_NEEDED ( ld-linux-armhf.so.3 ) )
diff --git a/eng/common/cross/arm64/sources.list.focal b/eng/common/cross/arm64/sources.list.focal
new file mode 100644
index 00000000000..4de2600c174
--- /dev/null
+++ b/eng/common/cross/arm64/sources.list.focal
@@ -0,0 +1,11 @@
+deb http://ports.ubuntu.com/ubuntu-ports/ focal main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ focal main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ focal-updates main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ focal-updates main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ focal-backports main restricted
+deb-src http://ports.ubuntu.com/ubuntu-ports/ focal-backports main restricted
+
+deb http://ports.ubuntu.com/ubuntu-ports/ focal-security main restricted universe multiverse
+deb-src http://ports.ubuntu.com/ubuntu-ports/ focal-security main restricted universe multiverse
diff --git a/eng/common/cross/arm64/sources.list.jammy b/eng/common/cross/arm64/sources.list.jammy
new file mode 100644
index 00000000000..6bb0453029c
--- /dev/null
+++ b/eng/common/cross/arm64/sources.list.jammy
@@ -0,0 +1,11 @@
+deb http://ports.ubuntu.com/ubuntu-ports/ jammy main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ jammy main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ jammy-updates main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ jammy-updates main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ jammy-backports main restricted
+deb-src http://ports.ubuntu.com/ubuntu-ports/ jammy-backports main restricted
+
+deb http://ports.ubuntu.com/ubuntu-ports/ jammy-security main restricted universe multiverse
+deb-src http://ports.ubuntu.com/ubuntu-ports/ jammy-security main restricted universe multiverse
diff --git a/eng/common/cross/arm64/sources.list.xenial b/eng/common/cross/arm64/sources.list.xenial
index eacd86b7df3..56fbb36a59f 100644
--- a/eng/common/cross/arm64/sources.list.xenial
+++ b/eng/common/cross/arm64/sources.list.xenial
@@ -8,4 +8,4 @@ deb http://ports.ubuntu.com/ubuntu-ports/ xenial-backports main restricted
 deb-src http://ports.ubuntu.com/ubuntu-ports/ xenial-backports main restricted
 
 deb http://ports.ubuntu.com/ubuntu-ports/ xenial-security main restricted universe multiverse
-deb-src http://ports.ubuntu.com/ubuntu-ports/ xenial-security main restricted universe multiverse
\ No newline at end of file
+deb-src http://ports.ubuntu.com/ubuntu-ports/ xenial-security main restricted universe multiverse
diff --git a/eng/common/cross/arm64/tizen-fetch.sh b/eng/common/cross/arm64/tizen-fetch.sh
deleted file mode 100644
index 16d1301f21e..00000000000
--- a/eng/common/cross/arm64/tizen-fetch.sh
+++ /dev/null
@@ -1,170 +0,0 @@
-#!/usr/bin/env bash
-set -e
-
-if [[ -z "${VERBOSE// }" ]] || [ "$VERBOSE" -ne "$VERBOSE" ] 2>/dev/null; then
-	VERBOSE=0
-fi
-
-Log()
-{
-	if [ $VERBOSE -ge $1 ]; then
-		echo ${@:2}
-	fi
-}
-
-Inform()
-{
-	Log 1 -e "\x1B[0;34m$@\x1B[m"
-}
-
-Debug()
-{
-	Log 2 -e "\x1B[0;32m$@\x1B[m"
-}
-
-Error()
-{
-	>&2 Log 0 -e "\x1B[0;31m$@\x1B[m"
-}
-
-Fetch()
-{
-	URL=$1
-	FILE=$2
-	PROGRESS=$3
-	if [ $VERBOSE -ge 1 ] && [ $PROGRESS ]; then
-		CURL_OPT="--progress-bar"
-	else
-		CURL_OPT="--silent"
-	fi
-	curl $CURL_OPT $URL > $FILE
-}
-
-hash curl 2> /dev/null || { Error "Require 'curl' Aborting."; exit 1; }
-hash xmllint 2> /dev/null || { Error "Require 'xmllint' Aborting."; exit 1; }
-hash sha256sum 2> /dev/null || { Error "Require 'sha256sum' Aborting."; exit 1; }
-
-TMPDIR=$1
-if [ ! -d $TMPDIR ]; then
-	TMPDIR=./tizen_tmp
-	Debug "Create temporary directory : $TMPDIR"
-	mkdir -p $TMPDIR
-fi
-
-TIZEN_URL=http://download.tizen.org/snapshots/tizen/
-BUILD_XML=build.xml
-REPOMD_XML=repomd.xml
-PRIMARY_XML=primary.xml
-TARGET_URL="http://__not_initialized"
-
-Xpath_get()
-{
-	XPATH_RESULT=''
-	XPATH=$1
-	XML_FILE=$2
-	RESULT=$(xmllint --xpath $XPATH $XML_FILE)
-	if [[ -z ${RESULT// } ]]; then
-		Error "Can not find target from $XML_FILE"
-		Debug "Xpath = $XPATH"
-		exit 1
-	fi
-	XPATH_RESULT=$RESULT
-}
-
-fetch_tizen_pkgs_init()
-{
-	TARGET=$1
-	PROFILE=$2
-	Debug "Initialize TARGET=$TARGET, PROFILE=$PROFILE"
-
-	TMP_PKG_DIR=$TMPDIR/tizen_${PROFILE}_pkgs
-	if [ -d $TMP_PKG_DIR ]; then rm -rf $TMP_PKG_DIR; fi
-	mkdir -p $TMP_PKG_DIR
-
-	PKG_URL=$TIZEN_URL/$PROFILE/latest
-
-	BUILD_XML_URL=$PKG_URL/$BUILD_XML
-	TMP_BUILD=$TMP_PKG_DIR/$BUILD_XML
-	TMP_REPOMD=$TMP_PKG_DIR/$REPOMD_XML
-	TMP_PRIMARY=$TMP_PKG_DIR/$PRIMARY_XML
-	TMP_PRIMARYGZ=${TMP_PRIMARY}.gz
-
-	Fetch $BUILD_XML_URL $TMP_BUILD
-
-	Debug "fetch $BUILD_XML_URL to $TMP_BUILD"
-
-	TARGET_XPATH="//build/buildtargets/buildtarget[@name=\"$TARGET\"]/repo[@type=\"binary\"]/text()"
-	Xpath_get $TARGET_XPATH $TMP_BUILD
-	TARGET_PATH=$XPATH_RESULT
-	TARGET_URL=$PKG_URL/$TARGET_PATH
-
-	REPOMD_URL=$TARGET_URL/repodata/repomd.xml
-	PRIMARY_XPATH='string(//*[local-name()="data"][@type="primary"]/*[local-name()="location"]/@href)'
-
-	Fetch $REPOMD_URL $TMP_REPOMD
-
-	Debug "fetch $REPOMD_URL to $TMP_REPOMD"
-
-	Xpath_get $PRIMARY_XPATH $TMP_REPOMD
-	PRIMARY_XML_PATH=$XPATH_RESULT
-	PRIMARY_URL=$TARGET_URL/$PRIMARY_XML_PATH
-
-	Fetch $PRIMARY_URL $TMP_PRIMARYGZ
-
-	Debug "fetch $PRIMARY_URL to $TMP_PRIMARYGZ"
-
-	gunzip $TMP_PRIMARYGZ
-
-	Debug "unzip $TMP_PRIMARYGZ to $TMP_PRIMARY"
-}
-
-fetch_tizen_pkgs()
-{
-	ARCH=$1
-	PACKAGE_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="location"]/@href)'
-
-	PACKAGE_CHECKSUM_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="checksum"]/text())'
-
-	for pkg in ${@:2}
-	do
-		Inform "Fetching... $pkg"
-		XPATH=${PACKAGE_XPATH_TPL/_PKG_/$pkg}
-		XPATH=${XPATH/_ARCH_/$ARCH}
-		Xpath_get $XPATH $TMP_PRIMARY
-		PKG_PATH=$XPATH_RESULT
-
-		XPATH=${PACKAGE_CHECKSUM_XPATH_TPL/_PKG_/$pkg}
-		XPATH=${XPATH/_ARCH_/$ARCH}
-		Xpath_get $XPATH $TMP_PRIMARY
-		CHECKSUM=$XPATH_RESULT
-
-		PKG_URL=$TARGET_URL/$PKG_PATH
-		PKG_FILE=$(basename $PKG_PATH)
-		PKG_PATH=$TMPDIR/$PKG_FILE
-
-		Debug "Download $PKG_URL to $PKG_PATH"
-		Fetch $PKG_URL $PKG_PATH true
-
-		echo "$CHECKSUM $PKG_PATH" | sha256sum -c - > /dev/null
-		if [ $? -ne 0 ]; then
-			Error "Fail to fetch $PKG_URL to $PKG_PATH"
-			Debug "Checksum = $CHECKSUM"
-			exit 1
-		fi
-	done
-}
-
-Inform "Initialize arm base"
-fetch_tizen_pkgs_init standard base
-Inform "fetch common packages"
-fetch_tizen_pkgs aarch64 gcc glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
-Inform "fetch coreclr packages"
-fetch_tizen_pkgs aarch64 lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
-Inform "fetch corefx packages"
-fetch_tizen_pkgs aarch64 libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
-
-Inform "Initialize standard unified"
-fetch_tizen_pkgs_init standard unified
-Inform "fetch corefx packages"
-fetch_tizen_pkgs aarch64 gssdp gssdp-devel tizen-release
-
diff --git a/eng/common/cross/armel/tizen-build-rootfs.sh b/eng/common/cross/armel/tizen-build-rootfs.sh
deleted file mode 100755
index 9a4438af61c..00000000000
--- a/eng/common/cross/armel/tizen-build-rootfs.sh
+++ /dev/null
@@ -1,35 +0,0 @@
-#!/usr/bin/env bash
-set -e
-
-__ARM_SOFTFP_CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
-__TIZEN_CROSSDIR="$__ARM_SOFTFP_CrossDir/tizen"
-
-if [[ -z "$ROOTFS_DIR" ]]; then
-    echo "ROOTFS_DIR is not defined."
-    exit 1;
-fi
-
-TIZEN_TMP_DIR=$ROOTFS_DIR/tizen_tmp
-mkdir -p $TIZEN_TMP_DIR
-
-# Download files
-echo ">>Start downloading files"
-VERBOSE=1 $__ARM_SOFTFP_CrossDir/tizen-fetch.sh $TIZEN_TMP_DIR
-echo "<<Finish downloading files"
-
-echo ">>Start constructing Tizen rootfs"
-TIZEN_RPM_FILES=`ls $TIZEN_TMP_DIR/*.rpm`
-cd $ROOTFS_DIR
-for f in $TIZEN_RPM_FILES; do
-    rpm2cpio $f  | cpio -idm --quiet
-done
-echo "<<Finish constructing Tizen rootfs"
-
-# Cleanup tmp
-rm -rf $TIZEN_TMP_DIR
-
-# Configure Tizen rootfs
-echo ">>Start configuring Tizen rootfs"
-ln -sfn asm-arm ./usr/include/asm
-patch -p1 < $__TIZEN_CROSSDIR/tizen.patch
-echo "<<Finish configuring Tizen rootfs"
diff --git a/eng/common/cross/armel/tizen-fetch.sh b/eng/common/cross/armel/tizen-fetch.sh
deleted file mode 100755
index 64f0187e5aa..00000000000
--- a/eng/common/cross/armel/tizen-fetch.sh
+++ /dev/null
@@ -1,170 +0,0 @@
-#!/usr/bin/env bash
-set -e
-
-if [[ -z "${VERBOSE// }" ]] || [ "$VERBOSE" -ne "$VERBOSE" ] 2>/dev/null; then
-	VERBOSE=0
-fi
-
-Log()
-{
-	if [ $VERBOSE -ge $1 ]; then
-		echo ${@:2}
-	fi
-}
-
-Inform()
-{
-	Log 1 -e "\x1B[0;34m$@\x1B[m"
-}
-
-Debug()
-{
-	Log 2 -e "\x1B[0;32m$@\x1B[m"
-}
-
-Error()
-{
-	>&2 Log 0 -e "\x1B[0;31m$@\x1B[m"
-}
-
-Fetch()
-{
-	URL=$1
-	FILE=$2
-	PROGRESS=$3
-	if [ $VERBOSE -ge 1 ] && [ $PROGRESS ]; then
-		CURL_OPT="--progress-bar"
-	else
-		CURL_OPT="--silent"
-	fi
-	curl $CURL_OPT $URL > $FILE
-}
-
-hash curl 2> /dev/null || { Error "Require 'curl' Aborting."; exit 1; }
-hash xmllint 2> /dev/null || { Error "Require 'xmllint' Aborting."; exit 1; }
-hash sha256sum 2> /dev/null || { Error "Require 'sha256sum' Aborting."; exit 1; }
-
-TMPDIR=$1
-if [ ! -d $TMPDIR ]; then
-	TMPDIR=./tizen_tmp
-	Debug "Create temporary directory : $TMPDIR"
-	mkdir -p $TMPDIR 
-fi
-
-TIZEN_URL=http://download.tizen.org/snapshots/tizen
-BUILD_XML=build.xml
-REPOMD_XML=repomd.xml
-PRIMARY_XML=primary.xml
-TARGET_URL="http://__not_initialized"
-
-Xpath_get()
-{
-	XPATH_RESULT=''
-	XPATH=$1
-	XML_FILE=$2
-	RESULT=$(xmllint --xpath $XPATH $XML_FILE)
-	if [[ -z ${RESULT// } ]]; then
-		Error "Can not find target from $XML_FILE"
-		Debug "Xpath = $XPATH"
-		exit 1
-	fi
-	XPATH_RESULT=$RESULT
-}
-
-fetch_tizen_pkgs_init()
-{
-	TARGET=$1
-	PROFILE=$2
-	Debug "Initialize TARGET=$TARGET, PROFILE=$PROFILE"
-
-	TMP_PKG_DIR=$TMPDIR/tizen_${PROFILE}_pkgs
-	if [ -d $TMP_PKG_DIR ]; then rm -rf $TMP_PKG_DIR; fi
-	mkdir -p $TMP_PKG_DIR
-
-	PKG_URL=$TIZEN_URL/$PROFILE/latest
-
-	BUILD_XML_URL=$PKG_URL/$BUILD_XML
-	TMP_BUILD=$TMP_PKG_DIR/$BUILD_XML
-	TMP_REPOMD=$TMP_PKG_DIR/$REPOMD_XML
-	TMP_PRIMARY=$TMP_PKG_DIR/$PRIMARY_XML
-	TMP_PRIMARYGZ=${TMP_PRIMARY}.gz
-
-	Fetch $BUILD_XML_URL $TMP_BUILD
-
-	Debug "fetch $BUILD_XML_URL to $TMP_BUILD"
-
-	TARGET_XPATH="//build/buildtargets/buildtarget[@name=\"$TARGET\"]/repo[@type=\"binary\"]/text()"
-	Xpath_get $TARGET_XPATH $TMP_BUILD
-	TARGET_PATH=$XPATH_RESULT
-	TARGET_URL=$PKG_URL/$TARGET_PATH
-
-	REPOMD_URL=$TARGET_URL/repodata/repomd.xml
-	PRIMARY_XPATH='string(//*[local-name()="data"][@type="primary"]/*[local-name()="location"]/@href)'
-
-	Fetch $REPOMD_URL $TMP_REPOMD
-
-	Debug "fetch $REPOMD_URL to $TMP_REPOMD"
-
-	Xpath_get $PRIMARY_XPATH $TMP_REPOMD
-	PRIMARY_XML_PATH=$XPATH_RESULT
-	PRIMARY_URL=$TARGET_URL/$PRIMARY_XML_PATH
-
-	Fetch $PRIMARY_URL $TMP_PRIMARYGZ
-
-	Debug "fetch $PRIMARY_URL to $TMP_PRIMARYGZ"
-
-	gunzip $TMP_PRIMARYGZ 
-
-	Debug "unzip $TMP_PRIMARYGZ to $TMP_PRIMARY" 
-}
-
-fetch_tizen_pkgs()
-{
-	ARCH=$1
-	PACKAGE_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="location"]/@href)'
-
-	PACKAGE_CHECKSUM_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="checksum"]/text())'
-
-	for pkg in ${@:2}
-	do
-		Inform "Fetching... $pkg"
-		XPATH=${PACKAGE_XPATH_TPL/_PKG_/$pkg}
-		XPATH=${XPATH/_ARCH_/$ARCH}
-		Xpath_get $XPATH $TMP_PRIMARY
-		PKG_PATH=$XPATH_RESULT
-
-		XPATH=${PACKAGE_CHECKSUM_XPATH_TPL/_PKG_/$pkg}
-		XPATH=${XPATH/_ARCH_/$ARCH}
-		Xpath_get $XPATH $TMP_PRIMARY
-		CHECKSUM=$XPATH_RESULT
-
-		PKG_URL=$TARGET_URL/$PKG_PATH
-		PKG_FILE=$(basename $PKG_PATH)
-		PKG_PATH=$TMPDIR/$PKG_FILE
-
-		Debug "Download $PKG_URL to $PKG_PATH"
-		Fetch $PKG_URL $PKG_PATH true
-
-		echo "$CHECKSUM $PKG_PATH" | sha256sum -c - > /dev/null
-		if [ $? -ne 0 ]; then
-			Error "Fail to fetch $PKG_URL to $PKG_PATH"
-			Debug "Checksum = $CHECKSUM"
-			exit 1
-		fi
-	done
-}
-
-Inform "Initialize arm base"
-fetch_tizen_pkgs_init standard base
-Inform "fetch common packages"
-fetch_tizen_pkgs armv7l gcc gcc-devel-static glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
-Inform "fetch coreclr packages"
-fetch_tizen_pkgs armv7l lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
-Inform "fetch corefx packages"
-fetch_tizen_pkgs armv7l libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
-
-Inform "Initialize standard unified"
-fetch_tizen_pkgs_init standard unified
-Inform "fetch corefx packages"
-fetch_tizen_pkgs armv7l gssdp gssdp-devel tizen-release
-
diff --git a/eng/common/cross/armel/tizen/tizen-dotnet.ks b/eng/common/cross/armel/tizen/tizen-dotnet.ks
deleted file mode 100644
index 506d455bd4f..00000000000
--- a/eng/common/cross/armel/tizen/tizen-dotnet.ks
+++ /dev/null
@@ -1,50 +0,0 @@
-lang en_US.UTF-8
-keyboard us
-timezone --utc Asia/Seoul
-
-part / --fstype="ext4" --size=3500 --ondisk=mmcblk0 --label rootfs --fsoptions=defaults,noatime
-
-rootpw tizen
-desktop --autologinuser=root
-user --name root  --groups audio,video --password 'tizen'
-
-repo --name=standard  --baseurl=http://download.tizen.org/releases/milestone/tizen/unified/latest/repos/standard/packages/ --ssl_verify=no
-repo --name=base      --baseurl=http://download.tizen.org/releases/milestone/tizen/base/latest/repos/standard/packages/ --ssl_verify=no
-
-%packages
-tar
-gzip
-
-sed
-grep
-gawk
-perl
-
-binutils
-findutils
-util-linux
-lttng-ust
-userspace-rcu
-procps-ng
-tzdata
-ca-certificates
-
-
-### Core FX
-libicu
-libunwind
-iputils
-zlib
-krb5
-libcurl
-libopenssl
-
-%end
-
-%post
-
-### Update /tmp privilege
-chmod 777 /tmp
-####################################
-
-%end
diff --git a/eng/common/cross/armv6/sources.list.buster b/eng/common/cross/armv6/sources.list.buster
new file mode 100644
index 00000000000..f27fc4fb346
--- /dev/null
+++ b/eng/common/cross/armv6/sources.list.buster
@@ -0,0 +1,2 @@
+deb http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi
+deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi
diff --git a/eng/common/cross/build-android-rootfs.sh b/eng/common/cross/build-android-rootfs.sh
index 42516bbeebc..f163fb9dae9 100755
--- a/eng/common/cross/build-android-rootfs.sh
+++ b/eng/common/cross/build-android-rootfs.sh
@@ -107,12 +107,12 @@ __AndroidPackages+=" liblzma"
 __AndroidPackages+=" krb5"
 __AndroidPackages+=" openssl"
 
-for path in $(wget -qO- http://termux.net/dists/stable/main/binary-$__AndroidArch/Packages |\
+for path in $(wget -qO- https://packages.termux.dev/termux-main-21/dists/stable/main/binary-$__AndroidArch/Packages |\
     grep -A15 "Package: \(${__AndroidPackages// /\\|}\)" | grep -v "static\|tool" | grep Filename); do
 
     if [[ "$path" != "Filename:" ]]; then
         echo "Working on: $path"
-        wget -qO- http://termux.net/$path | dpkg -x - "$__TmpDir"
+        wget -qO- https://packages.termux.dev/termux-main-21/$path | dpkg -x - "$__TmpDir"
     fi
 done
 
diff --git a/eng/common/cross/build-rootfs.sh b/eng/common/cross/build-rootfs.sh
index 5c05b39f101..9caf9b021db 100755
--- a/eng/common/cross/build-rootfs.sh
+++ b/eng/common/cross/build-rootfs.sh
@@ -4,22 +4,30 @@ set -e
 
 usage()
 {
-    echo "Usage: $0 [BuildArch] [CodeName] [lldbx.y] [--skipunmount] --rootfsdir <directory>]"
-    echo "BuildArch can be: arm(default), armel, arm64, x86"
-    echo "CodeName - optional, Code name for Linux, can be: xenial(default), zesty, bionic, alpine, alpine3.9 or alpine3.13. If BuildArch is armel, LinuxCodeName is jessie(default) or tizen."
-    echo "                              for FreeBSD can be: freebsd11, freebsd12, freebsd13"
-    echo "                              for illumos can be: illumos."
+    echo "Usage: $0 [BuildArch] [CodeName] [lldbx.y] [llvmx[.y]] [--skipunmount] --rootfsdir <directory>]"
+    echo "BuildArch can be: arm(default), arm64, armel, armv6, ppc64le, riscv64, s390x, x64, x86"
+    echo "CodeName - optional, Code name for Linux, can be: xenial(default), zesty, bionic, alpine"
+    echo "                               for alpine can be specified with version: alpineX.YY or alpineedge"
+    echo "                               for FreeBSD can be: freebsd12, freebsd13"
+    echo "                               for illumos can be: illumos"
+    echo "                               for Haiku can be: haiku."
     echo "lldbx.y - optional, LLDB version, can be: lldb3.9(default), lldb4.0, lldb5.0, lldb6.0 no-lldb. Ignored for alpine and FreeBSD"
+    echo "llvmx[.y] - optional, LLVM version for LLVM related packages."
     echo "--skipunmount - optional, will skip the unmount of rootfs folder."
+    echo "--skipsigcheck - optional, will skip package signature checks (allowing untrusted packages)."
     echo "--use-mirror - optional, use mirror URL to fetch resources, when available."
+    echo "--jobs N - optional, restrict to N jobs."
     exit 1
 }
 
 __CodeName=xenial
 __CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
-__InitialDir=$PWD
 __BuildArch=arm
 __AlpineArch=armv7
+__FreeBSDArch=arm
+__FreeBSDMachineArch=armv7
+__IllumosArch=arm7
+__HaikuArch=arm
 __QEMUArch=arm
 __UbuntuArch=armhf
 __UbuntuRepo="http://ports.ubuntu.com/"
@@ -32,24 +40,27 @@ __UbuntuPackages="build-essential"
 __AlpinePackages="alpine-base"
 __AlpinePackages+=" build-base"
 __AlpinePackages+=" linux-headers"
-__AlpinePackagesEdgeCommunity=" lldb-dev"
-__AlpinePackagesEdgeMain+=" python3"
-__AlpinePackagesEdgeMain+=" libedit"
+__AlpinePackages+=" lldb-dev"
+__AlpinePackages+=" python3"
+__AlpinePackages+=" libedit"
 
 # symlinks fixer
 __UbuntuPackages+=" symlinks"
 
-# CoreCLR and CoreFX dependencies
+# runtime dependencies
 __UbuntuPackages+=" libicu-dev"
 __UbuntuPackages+=" liblttng-ust-dev"
 __UbuntuPackages+=" libunwind8-dev"
+__UbuntuPackages+=" libnuma-dev"
 
 __AlpinePackages+=" gettext-dev"
 __AlpinePackages+=" icu-dev"
 __AlpinePackages+=" libunwind-dev"
 __AlpinePackages+=" lttng-ust-dev"
+__AlpinePackages+=" compiler-rt"
+__AlpinePackages+=" numactl-dev"
 
-# CoreFX dependencies
+# runtime libraries' dependencies
 __UbuntuPackages+=" libcurl4-openssl-dev"
 __UbuntuPackages+=" libkrb5-dev"
 __UbuntuPackages+=" libssl-dev"
@@ -60,36 +71,76 @@ __AlpinePackages+=" krb5-dev"
 __AlpinePackages+=" openssl-dev"
 __AlpinePackages+=" zlib-dev"
 
-__FreeBSDBase="12.2-RELEASE"
-__FreeBSDPkg="1.12.0"
+__FreeBSDBase="12.4-RELEASE"
+__FreeBSDPkg="1.17.0"
 __FreeBSDABI="12"
 __FreeBSDPackages="libunwind"
 __FreeBSDPackages+=" icu"
 __FreeBSDPackages+=" libinotify"
-__FreeBSDPackages+=" lttng-ust"
+__FreeBSDPackages+=" openssl"
 __FreeBSDPackages+=" krb5"
 __FreeBSDPackages+=" terminfo-db"
 
-__IllumosPackages="icu-64.2nb2"
-__IllumosPackages+=" mit-krb5-1.16.2nb4"
-__IllumosPackages+=" openssl-1.1.1e"
-__IllumosPackages+=" zlib-1.2.11"
+__IllumosPackages="icu"
+__IllumosPackages+=" mit-krb5"
+__IllumosPackages+=" openssl"
+__IllumosPackages+=" zlib"
+
+__HaikuPackages="gcc_syslibs"
+__HaikuPackages+=" gcc_syslibs_devel"
+__HaikuPackages+=" gmp"
+__HaikuPackages+=" gmp_devel"
+__HaikuPackages+=" icu66"
+__HaikuPackages+=" icu66_devel"
+__HaikuPackages+=" krb5"
+__HaikuPackages+=" krb5_devel"
+__HaikuPackages+=" libiconv"
+__HaikuPackages+=" libiconv_devel"
+__HaikuPackages+=" llvm12_libunwind"
+__HaikuPackages+=" llvm12_libunwind_devel"
+__HaikuPackages+=" mpfr"
+__HaikuPackages+=" mpfr_devel"
+__HaikuPackages+=" openssl"
+__HaikuPackages+=" openssl_devel"
+__HaikuPackages+=" zlib"
+__HaikuPackages+=" zlib_devel"
 
 # ML.NET dependencies
 __UbuntuPackages+=" libomp5"
 __UbuntuPackages+=" libomp-dev"
 
+# Taken from https://github.com/alpinelinux/alpine-chroot-install/blob/6d08f12a8a70dd9b9dc7d997c88aa7789cc03c42/alpine-chroot-install#L85-L133
+__AlpineKeys='
+4a6a0840:MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1yHJxQgsHQREclQu4Ohe\nqxTxd1tHcNnvnQTu/UrTky8wWvgXT+jpveroeWWnzmsYlDI93eLI2ORakxb3gA2O\nQ0Ry4ws8vhaxLQGC74uQR5+/yYrLuTKydFzuPaS1dK19qJPXB8GMdmFOijnXX4SA\njixuHLe1WW7kZVtjL7nufvpXkWBGjsfrvskdNA/5MfxAeBbqPgaq0QMEfxMAn6/R\nL5kNepi/Vr4S39Xvf2DzWkTLEK8pcnjNkt9/aafhWqFVW7m3HCAII6h/qlQNQKSo\nGuH34Q8GsFG30izUENV9avY7hSLq7nggsvknlNBZtFUcmGoQrtx3FmyYsIC8/R+B\nywIDAQAB
+5243ef4b:MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvNijDxJ8kloskKQpJdx+\nmTMVFFUGDoDCbulnhZMJoKNkSuZOzBoFC94omYPtxnIcBdWBGnrm6ncbKRlR+6oy\nDO0W7c44uHKCFGFqBhDasdI4RCYP+fcIX/lyMh6MLbOxqS22TwSLhCVjTyJeeH7K\naA7vqk+QSsF4TGbYzQDDpg7+6aAcNzg6InNePaywA6hbT0JXbxnDWsB+2/LLSF2G\nmnhJlJrWB1WGjkz23ONIWk85W4S0XB/ewDefd4Ly/zyIciastA7Zqnh7p3Ody6Q0\nsS2MJzo7p3os1smGjUF158s6m/JbVh4DN6YIsxwl2OjDOz9R0OycfJSDaBVIGZzg\ncQIDAQAB
+524d27bb:MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr8s1q88XpuJWLCZALdKj\nlN8wg2ePB2T9aIcaxryYE/Jkmtu+ZQ5zKq6BT3y/udt5jAsMrhHTwroOjIsF9DeG\ne8Y3vjz+Hh4L8a7hZDaw8jy3CPag47L7nsZFwQOIo2Cl1SnzUc6/owoyjRU7ab0p\niWG5HK8IfiybRbZxnEbNAfT4R53hyI6z5FhyXGS2Ld8zCoU/R4E1P0CUuXKEN4p0\n64dyeUoOLXEWHjgKiU1mElIQj3k/IF02W89gDj285YgwqA49deLUM7QOd53QLnx+\nxrIrPv3A+eyXMFgexNwCKQU9ZdmWa00MjjHlegSGK8Y2NPnRoXhzqSP9T9i2HiXL\nVQIDAQAB
+5261cecb:MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwlzMkl7b5PBdfMzGdCT0\ncGloRr5xGgVmsdq5EtJvFkFAiN8Ac9MCFy/vAFmS8/7ZaGOXoCDWbYVLTLOO2qtX\nyHRl+7fJVh2N6qrDDFPmdgCi8NaE+3rITWXGrrQ1spJ0B6HIzTDNEjRKnD4xyg4j\ng01FMcJTU6E+V2JBY45CKN9dWr1JDM/nei/Pf0byBJlMp/mSSfjodykmz4Oe13xB\nCa1WTwgFykKYthoLGYrmo+LKIGpMoeEbY1kuUe04UiDe47l6Oggwnl+8XD1MeRWY\nsWgj8sF4dTcSfCMavK4zHRFFQbGp/YFJ/Ww6U9lA3Vq0wyEI6MCMQnoSMFwrbgZw\nwwIDAQAB
+58199dcc:MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3v8/ye/V/t5xf4JiXLXa\nhWFRozsnmn3hobON20GdmkrzKzO/eUqPOKTpg2GtvBhK30fu5oY5uN2ORiv2Y2ht\neLiZ9HVz3XP8Fm9frha60B7KNu66FO5P2o3i+E+DWTPqqPcCG6t4Znk2BypILcit\nwiPKTsgbBQR2qo/cO01eLLdt6oOzAaF94NH0656kvRewdo6HG4urbO46tCAizvCR\nCA7KGFMyad8WdKkTjxh8YLDLoOCtoZmXmQAiwfRe9pKXRH/XXGop8SYptLqyVVQ+\ntegOD9wRs2tOlgcLx4F/uMzHN7uoho6okBPiifRX+Pf38Vx+ozXh056tjmdZkCaV\naQIDAQAB
+58cbb476:MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoSPnuAGKtRIS5fEgYPXD\n8pSGvKAmIv3A08LBViDUe+YwhilSHbYXUEAcSH1KZvOo1WT1x2FNEPBEFEFU1Eyc\n+qGzbA03UFgBNvArurHQ5Z/GngGqE7IarSQFSoqewYRtFSfp+TL9CUNBvM0rT7vz\n2eMu3/wWG+CBmb92lkmyWwC1WSWFKO3x8w+Br2IFWvAZqHRt8oiG5QtYvcZL6jym\nY8T6sgdDlj+Y+wWaLHs9Fc+7vBuyK9C4O1ORdMPW15qVSl4Lc2Wu1QVwRiKnmA+c\nDsH/m7kDNRHM7TjWnuj+nrBOKAHzYquiu5iB3Qmx+0gwnrSVf27Arc3ozUmmJbLj\nzQIDAQAB
+58e4f17d:MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvBxJN9ErBgdRcPr5g4hV\nqyUSGZEKuvQliq2Z9SRHLh2J43+EdB6A+yzVvLnzcHVpBJ+BZ9RV30EM9guck9sh\nr+bryZcRHyjG2wiIEoduxF2a8KeWeQH7QlpwGhuobo1+gA8L0AGImiA6UP3LOirl\nI0G2+iaKZowME8/tydww4jx5vG132JCOScMjTalRsYZYJcjFbebQQolpqRaGB4iG\nWqhytWQGWuKiB1A22wjmIYf3t96l1Mp+FmM2URPxD1gk/BIBnX7ew+2gWppXOK9j\n1BJpo0/HaX5XoZ/uMqISAAtgHZAqq+g3IUPouxTphgYQRTRYpz2COw3NF43VYQrR\nbQIDAQAB
+60ac2099:MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwR4uJVtJOnOFGchnMW5Y\nj5/waBdG1u5BTMlH+iQMcV5+VgWhmpZHJCBz3ocD+0IGk2I68S5TDOHec/GSC0lv\n6R9o6F7h429GmgPgVKQsc8mPTPtbjJMuLLs4xKc+viCplXc0Nc0ZoHmCH4da6fCV\ntdpHQjVe6F9zjdquZ4RjV6R6JTiN9v924dGMAkbW/xXmamtz51FzondKC52Gh8Mo\n/oA0/T0KsCMCi7tb4QNQUYrf+Xcha9uus4ww1kWNZyfXJB87a2kORLiWMfs2IBBJ\nTmZ2Fnk0JnHDb8Oknxd9PvJPT0mvyT8DA+KIAPqNvOjUXP4bnjEHJcoCP9S5HkGC\nIQIDAQAB
+6165ee59:MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAutQkua2CAig4VFSJ7v54\nALyu/J1WB3oni7qwCZD3veURw7HxpNAj9hR+S5N/pNeZgubQvJWyaPuQDm7PTs1+\ntFGiYNfAsiibX6Rv0wci3M+z2XEVAeR9Vzg6v4qoofDyoTbovn2LztaNEjTkB+oK\ntlvpNhg1zhou0jDVYFniEXvzjckxswHVb8cT0OMTKHALyLPrPOJzVtM9C1ew2Nnc\n3848xLiApMu3NBk0JqfcS3Bo5Y2b1FRVBvdt+2gFoKZix1MnZdAEZ8xQzL/a0YS5\nHd0wj5+EEKHfOd3A75uPa/WQmA+o0cBFfrzm69QDcSJSwGpzWrD1ScH3AK8nWvoj\nv7e9gukK/9yl1b4fQQ00vttwJPSgm9EnfPHLAtgXkRloI27H6/PuLoNvSAMQwuCD\nhQRlyGLPBETKkHeodfLoULjhDi1K2gKJTMhtbnUcAA7nEphkMhPWkBpgFdrH+5z4\nLxy+3ek0cqcI7K68EtrffU8jtUj9LFTUC8dERaIBs7NgQ/LfDbDfGh9g6qVj1hZl\nk9aaIPTm/xsi8v3u+0qaq7KzIBc9s59JOoA8TlpOaYdVgSQhHHLBaahOuAigH+VI\nisbC9vmqsThF2QdDtQt37keuqoda2E6sL7PUvIyVXDRfwX7uMDjlzTxHTymvq2Ck\nhtBqojBnThmjJQFgZXocHG8CAwEAAQ==
+61666e3f:MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlEyxkHggKCXC2Wf5Mzx4\nnZLFZvU2bgcA3exfNPO/g1YunKfQY+Jg4fr6tJUUTZ3XZUrhmLNWvpvSwDS19ZmC\nIXOu0+V94aNgnhMsk9rr59I8qcbsQGIBoHzuAl8NzZCgdbEXkiY90w1skUw8J57z\nqCsMBydAueMXuWqF5nGtYbi5vHwK42PffpiZ7G5Kjwn8nYMW5IZdL6ZnMEVJUWC9\nI4waeKg0yskczYDmZUEAtrn3laX9677ToCpiKrvmZYjlGl0BaGp3cxggP2xaDbUq\nqfFxWNgvUAb3pXD09JM6Mt6HSIJaFc9vQbrKB9KT515y763j5CC2KUsilszKi3mB\nHYe5PoebdjS7D1Oh+tRqfegU2IImzSwW3iwA7PJvefFuc/kNIijfS/gH/cAqAK6z\nbhdOtE/zc7TtqW2Wn5Y03jIZdtm12CxSxwgtCF1NPyEWyIxAQUX9ACb3M0FAZ61n\nfpPrvwTaIIxxZ01L3IzPLpbc44x/DhJIEU+iDt6IMTrHOphD9MCG4631eIdB0H1b\n6zbNX1CXTsafqHRFV9XmYYIeOMggmd90s3xIbEujA6HKNP/gwzO6CDJ+nHFDEqoF\nSkxRdTkEqjTjVKieURW7Swv7zpfu5PrsrrkyGnsRrBJJzXlm2FOOxnbI2iSL1B5F\nrO5kbUxFeZUIDq+7Yv4kLWcCAwEAAQ==
+616a9724:MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAnC+bR4bHf/L6QdU4puhQ\ngl1MHePszRC38bzvVFDUJsmCaMCL2suCs2A2yxAgGb9pu9AJYLAmxQC4mM3jNqhg\n/E7yuaBbek3O02zN/ctvflJ250wZCy+z0ZGIp1ak6pu1j14IwHokl9j36zNfGtfv\nADVOcdpWITFFlPqwq1qt/H3UsKVmtiF3BNWWTeUEQwKvlU8ymxgS99yn0+4OPyNT\nL3EUeS+NQJtDS01unau0t7LnjUXn+XIneWny8bIYOQCuVR6s/gpIGuhBaUqwaJOw\n7jkJZYF2Ij7uPb4b5/R3vX2FfxxqEHqssFSg8FFUNTZz3qNZs0CRVyfA972g9WkJ\nhPfn31pQYil4QGRibCMIeU27YAEjXoqfJKEPh4UWMQsQLrEfdGfb8VgwrPbniGfU\nL3jKJR3VAafL9330iawzVQDlIlwGl6u77gEXMl9K0pfazunYhAp+BMP+9ot5ckK+\nosmrqj11qMESsAj083GeFdfV3pXEIwUytaB0AKEht9DbqUfiE/oeZ/LAXgySMtVC\nsbC4ESmgVeY2xSBIJdDyUap7FR49GGrw0W49NUv9gRgQtGGaNVQQO9oGL2PBC41P\niWF9GLoX30HIz1P8PF/cZvicSSPkQf2Z6TV+t0ebdGNS5DjapdnCrq8m9Z0pyKsQ\nuxAL2a7zX8l5i1CZh1ycUGsCAwEAAQ==
+616abc23:MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA0MfCDrhODRCIxR9Dep1s\neXafh5CE5BrF4WbCgCsevyPIdvTeyIaW4vmO3bbG4VzhogDZju+R3IQYFuhoXP5v\nY+zYJGnwrgz3r5wYAvPnLEs1+dtDKYOgJXQj+wLJBW1mzRDL8FoRXOe5iRmn1EFS\nwZ1DoUvyu7/J5r0itKicZp3QKED6YoilXed+1vnS4Sk0mzN4smuMR9eO1mMCqNp9\n9KTfRDHTbakIHwasECCXCp50uXdoW6ig/xUAFanpm9LtK6jctNDbXDhQmgvAaLXZ\nLvFqoaYJ/CvWkyYCgL6qxvMvVmPoRv7OPcyni4xR/WgWa0MSaEWjgPx3+yj9fiMA\n1S02pFWFDOr5OUF/O4YhFJvUCOtVsUPPfA/Lj6faL0h5QI9mQhy5Zb9TTaS9jB6p\nLw7u0dJlrjFedk8KTJdFCcaGYHP6kNPnOxMylcB/5WcztXZVQD5WpCicGNBxCGMm\nW64SgrV7M07gQfL/32QLsdqPUf0i8hoVD8wfQ3EpbQzv6Fk1Cn90bZqZafg8XWGY\nwddhkXk7egrr23Djv37V2okjzdqoyLBYBxMz63qQzFoAVv5VoY2NDTbXYUYytOvG\nGJ1afYDRVWrExCech1mX5ZVUB1br6WM+psFLJFoBFl6mDmiYt0vMYBddKISsvwLl\nIJQkzDwtXzT2cSjoj3T5QekCAwEAAQ==
+616ac3bc:MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAvaaoSLab+IluixwKV5Od\n0gib2YurjPatGIbn5Ov2DLUFYiebj2oJINXJSwUOO+4WcuHFEqiL/1rya+k5hLZt\nhnPL1tn6QD4rESznvGSasRCQNT2vS/oyZbTYJRyAtFkEYLlq0t3S3xBxxHWuvIf0\nqVxVNYpQWyM3N9RIeYBR/euXKJXileSHk/uq1I5wTC0XBIHWcthczGN0m9wBEiWS\n0m3cnPk4q0Ea8mUJ91Rqob19qETz6VbSPYYpZk3qOycjKosuwcuzoMpwU8KRiMFd\n5LHtX0Hx85ghGsWDVtS0c0+aJa4lOMGvJCAOvDfqvODv7gKlCXUpgumGpLdTmaZ8\n1RwqspAe3IqBcdKTqRD4m2mSg23nVx2FAY3cjFvZQtfooT7q1ItRV5RgH6FhQSl7\n+6YIMJ1Bf8AAlLdRLpg+doOUGcEn+pkDiHFgI8ylH1LKyFKw+eXaAml/7DaWZk1d\ndqggwhXOhc/UUZFQuQQ8A8zpA13PcbC05XxN2hyP93tCEtyynMLVPtrRwDnHxFKa\nqKzs3rMDXPSXRn3ZZTdKH3069ApkEjQdpcwUh+EmJ1Ve/5cdtzT6kKWCjKBFZP/s\n91MlRrX2BTRdHaU5QJkUheUtakwxuHrdah2F94lRmsnQlpPr2YseJu6sIE+Dnx4M\nCfhdVbQL2w54R645nlnohu8CAwEAAQ==
+616adfeb:MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAq0BFD1D4lIxQcsqEpQzU\npNCYM3aP1V/fxxVdT4DWvSI53JHTwHQamKdMWtEXetWVbP5zSROniYKFXd/xrD9X\n0jiGHey3lEtylXRIPxe5s+wXoCmNLcJVnvTcDtwx/ne2NLHxp76lyc25At+6RgE6\nADjLVuoD7M4IFDkAsd8UQ8zM0Dww9SylIk/wgV3ZkifecvgUQRagrNUdUjR56EBZ\nraQrev4hhzOgwelT0kXCu3snbUuNY/lU53CoTzfBJ5UfEJ5pMw1ij6X0r5S9IVsy\nKLWH1hiO0NzU2c8ViUYCly4Fe9xMTFc6u2dy/dxf6FwERfGzETQxqZvSfrRX+GLj\n/QZAXiPg5178hT/m0Y3z5IGenIC/80Z9NCi+byF1WuJlzKjDcF/TU72zk0+PNM/H\nKuppf3JT4DyjiVzNC5YoWJT2QRMS9KLP5iKCSThwVceEEg5HfhQBRT9M6KIcFLSs\nmFjx9kNEEmc1E8hl5IR3+3Ry8G5/bTIIruz14jgeY9u5jhL8Vyyvo41jgt9sLHR1\n/J1TxKfkgksYev7PoX6/ZzJ1ksWKZY5NFoDXTNYUgzFUTOoEaOg3BAQKadb3Qbbq\nXIrxmPBdgrn9QI7NCgfnAY3Tb4EEjs3ON/BNyEhUENcXOH6I1NbcuBQ7g9P73kE4\nVORdoc8MdJ5eoKBpO8Ww8HECAwEAAQ==
+616ae350:MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAyduVzi1mWm+lYo2Tqt/0\nXkCIWrDNP1QBMVPrE0/ZlU2bCGSoo2Z9FHQKz/mTyMRlhNqTfhJ5qU3U9XlyGOPJ\npiM+b91g26pnpXJ2Q2kOypSgOMOPA4cQ42PkHBEqhuzssfj9t7x47ppS94bboh46\nxLSDRff/NAbtwTpvhStV3URYkxFG++cKGGa5MPXBrxIp+iZf9GnuxVdST5PGiVGP\nODL/b69sPJQNbJHVquqUTOh5Ry8uuD2WZuXfKf7/C0jC/ie9m2+0CttNu9tMciGM\nEyKG1/Xhk5iIWO43m4SrrT2WkFlcZ1z2JSf9Pjm4C2+HovYpihwwdM/OdP8Xmsnr\nDzVB4YvQiW+IHBjStHVuyiZWc+JsgEPJzisNY0Wyc/kNyNtqVKpX6dRhMLanLmy+\nf53cCSI05KPQAcGj6tdL+D60uKDkt+FsDa0BTAobZ31OsFVid0vCXtsbplNhW1IF\nHwsGXBTVcfXg44RLyL8Lk/2dQxDHNHzAUslJXzPxaHBLmt++2COa2EI1iWlvtznk\nOk9WP8SOAIj+xdqoiHcC4j72BOVVgiITIJNHrbppZCq6qPR+fgXmXa+sDcGh30m6\n9Wpbr28kLMSHiENCWTdsFij+NQTd5S47H7XTROHnalYDuF1RpS+DpQidT5tUimaT\nJZDr++FjKrnnijbyNF8b98UCAwEAAQ==
+616db30d:MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAnpUpyWDWjlUk3smlWeA0\nlIMW+oJ38t92CRLHH3IqRhyECBRW0d0aRGtq7TY8PmxjjvBZrxTNDpJT6KUk4LRm\na6A6IuAI7QnNK8SJqM0DLzlpygd7GJf8ZL9SoHSH+gFsYF67Cpooz/YDqWrlN7Vw\ntO00s0B+eXy+PCXYU7VSfuWFGK8TGEv6HfGMALLjhqMManyvfp8hz3ubN1rK3c8C\nUS/ilRh1qckdbtPvoDPhSbTDmfU1g/EfRSIEXBrIMLg9ka/XB9PvWRrekrppnQzP\nhP9YE3x/wbFc5QqQWiRCYyQl/rgIMOXvIxhkfe8H5n1Et4VAorkpEAXdsfN8KSVv\nLSMazVlLp9GYq5SUpqYX3KnxdWBgN7BJoZ4sltsTpHQ/34SXWfu3UmyUveWj7wp0\nx9hwsPirVI00EEea9AbP7NM2rAyu6ukcm4m6ATd2DZJIViq2es6m60AE6SMCmrQF\nwmk4H/kdQgeAELVfGOm2VyJ3z69fQuywz7xu27S6zTKi05Qlnohxol4wVb6OB7qG\nLPRtK9ObgzRo/OPumyXqlzAi/Yvyd1ZQk8labZps3e16bQp8+pVPiumWioMFJDWV\nGZjCmyMSU8V6MB6njbgLHoyg2LCukCAeSjbPGGGYhnKLm1AKSoJh3IpZuqcKCk5C\n8CM1S15HxV78s9dFntEqIokCAwEAAQ==
+'
+__Keyring=
+__SkipSigCheck=0
 __UseMirror=0
 
 __UnprocessedBuildArgs=
 while :; do
-    if [ $# -le 0 ]; then
+    if [[ "$#" -le 0 ]]; then
         break
     fi
 
-    lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
+    lowerI="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
     case $lowerI in
-        -?|-h|--help)
+        -\?|-h|--help)
             usage
             exit 1
             ;;
@@ -104,6 +155,8 @@ while :; do
             __UbuntuArch=arm64
             __AlpineArch=aarch64
             __QEMUArch=aarch64
+            __FreeBSDArch=arm64
+            __FreeBSDMachineArch=aarch64
             ;;
         armel)
             __BuildArch=armel
@@ -111,129 +164,211 @@ while :; do
             __UbuntuRepo="http://ftp.debian.org/debian/"
             __CodeName=jessie
             ;;
+        armv6)
+            __BuildArch=armv6
+            __UbuntuArch=armhf
+            __QEMUArch=arm
+            __UbuntuRepo="http://raspbian.raspberrypi.org/raspbian/"
+            __CodeName=buster
+            __LLDB_Package="liblldb-6.0-dev"
+
+            if [[ -e "/usr/share/keyrings/raspbian-archive-keyring.gpg" ]]; then
+                __Keyring="--keyring /usr/share/keyrings/raspbian-archive-keyring.gpg"
+            fi
+            ;;
+        riscv64)
+            __BuildArch=riscv64
+            __AlpineArch=riscv64
+            __AlpinePackages="${__AlpinePackages// lldb-dev/}"
+            __QEMUArch=riscv64
+            __UbuntuArch=riscv64
+            __UbuntuRepo="http://deb.debian.org/debian-ports"
+            __UbuntuPackages="${__UbuntuPackages// libunwind8-dev/}"
+            unset __LLDB_Package
+
+            if [[ -e "/usr/share/keyrings/debian-ports-archive-keyring.gpg" ]]; then
+                __Keyring="--keyring /usr/share/keyrings/debian-ports-archive-keyring.gpg --include=debian-ports-archive-keyring"
+            fi
+            ;;
+        ppc64le)
+            __BuildArch=ppc64le
+            __AlpineArch=ppc64le
+            __QEMUArch=ppc64le
+            __UbuntuArch=ppc64el
+            __UbuntuRepo="http://ports.ubuntu.com/ubuntu-ports/"
+            __UbuntuPackages="${__UbuntuPackages// libunwind8-dev/}"
+            __UbuntuPackages="${__UbuntuPackages// libomp-dev/}"
+            __UbuntuPackages="${__UbuntuPackages// libomp5/}"
+            unset __LLDB_Package
+            ;;
         s390x)
             __BuildArch=s390x
+            __AlpineArch=s390x
+            __QEMUArch=s390x
             __UbuntuArch=s390x
             __UbuntuRepo="http://ports.ubuntu.com/ubuntu-ports/"
-            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libunwind8-dev//')
-            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp-dev//')
-            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp5//')
+            __UbuntuPackages="${__UbuntuPackages// libunwind8-dev/}"
+            __UbuntuPackages="${__UbuntuPackages// libomp-dev/}"
+            __UbuntuPackages="${__UbuntuPackages// libomp5/}"
             unset __LLDB_Package
             ;;
+        x64)
+            __BuildArch=x64
+            __AlpineArch=x86_64
+            __UbuntuArch=amd64
+            __FreeBSDArch=amd64
+            __FreeBSDMachineArch=amd64
+            __illumosArch=x86_64
+            __HaikuArch=x86_64
+            __UbuntuRepo="http://archive.ubuntu.com/ubuntu/"
+            ;;
         x86)
             __BuildArch=x86
             __UbuntuArch=i386
+            __AlpineArch=x86
             __UbuntuRepo="http://archive.ubuntu.com/ubuntu/"
             ;;
-        lldb3.6)
-            __LLDB_Package="lldb-3.6-dev"
-            ;;
-        lldb3.8)
-            __LLDB_Package="lldb-3.8-dev"
-            ;;
-        lldb3.9)
-            __LLDB_Package="liblldb-3.9-dev"
-            ;;
-        lldb4.0)
-            __LLDB_Package="liblldb-4.0-dev"
-            ;;
-        lldb5.0)
-            __LLDB_Package="liblldb-5.0-dev"
-            ;;
-        lldb6.0)
-            __LLDB_Package="liblldb-6.0-dev"
+        lldb*)
+            version="${lowerI/lldb/}"
+            parts=(${version//./ })
+
+            # for versions > 6.0, lldb has dropped the minor version
+            if [[ "${parts[0]}" -gt 6 ]]; then
+                version="${parts[0]}"
+            fi
+
+            __LLDB_Package="liblldb-${version}-dev"
             ;;
         no-lldb)
             unset __LLDB_Package
             ;;
+        llvm*)
+            version="${lowerI/llvm/}"
+            parts=(${version//./ })
+            __LLVM_MajorVersion="${parts[0]}"
+            __LLVM_MinorVersion="${parts[1]}"
+
+            # for versions > 6.0, llvm has dropped the minor version
+            if [[ -z "$__LLVM_MinorVersion" && "$__LLVM_MajorVersion" -le 6 ]]; then
+                __LLVM_MinorVersion=0;
+            fi
+            ;;
         xenial) # Ubuntu 16.04
-            if [ "$__CodeName" != "jessie" ]; then
+            if [[ "$__CodeName" != "jessie" ]]; then
                 __CodeName=xenial
             fi
             ;;
         zesty) # Ubuntu 17.04
-            if [ "$__CodeName" != "jessie" ]; then
+            if [[ "$__CodeName" != "jessie" ]]; then
                 __CodeName=zesty
             fi
             ;;
         bionic) # Ubuntu 18.04
-            if [ "$__CodeName" != "jessie" ]; then
+            if [[ "$__CodeName" != "jessie" ]]; then
                 __CodeName=bionic
             fi
             ;;
+        focal) # Ubuntu 20.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=focal
+            fi
+            ;;
+        jammy) # Ubuntu 22.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=jammy
+            fi
+            ;;
         jessie) # Debian 8
             __CodeName=jessie
-            __UbuntuRepo="http://ftp.debian.org/debian/"
+
+            if [[ -z "$__UbuntuRepo" ]]; then
+                __UbuntuRepo="http://ftp.debian.org/debian/"
+            fi
             ;;
         stretch) # Debian 9
             __CodeName=stretch
-            __UbuntuRepo="http://ftp.debian.org/debian/"
             __LLDB_Package="liblldb-6.0-dev"
+
+            if [[ -z "$__UbuntuRepo" ]]; then
+                __UbuntuRepo="http://ftp.debian.org/debian/"
+            fi
             ;;
         buster) # Debian 10
             __CodeName=buster
-            __UbuntuRepo="http://ftp.debian.org/debian/"
             __LLDB_Package="liblldb-6.0-dev"
+
+            if [[ -z "$__UbuntuRepo" ]]; then
+                __UbuntuRepo="http://ftp.debian.org/debian/"
+            fi
             ;;
-        tizen)
-            if [ "$__BuildArch" != "armel" ] && [ "$__BuildArch" != "arm64" ]; then
-                echo "Tizen is available only for armel and arm64."
-                usage;
-                exit 1;
+        bullseye) # Debian 11
+            __CodeName=bullseye
+
+            if [[ -z "$__UbuntuRepo" ]]; then
+                __UbuntuRepo="http://ftp.debian.org/debian/"
             fi
+            ;;
+        sid) # Debian sid
+            __CodeName=sid
+
+            if [[ -z "$__UbuntuRepo" ]]; then
+                __UbuntuRepo="http://ftp.debian.org/debian/"
+            fi
+            ;;
+        tizen)
             __CodeName=
             __UbuntuRepo=
             __Tizen=tizen
             ;;
-        alpine|alpine3.9)
-            __CodeName=alpine
-            __UbuntuRepo=
-            __AlpineVersion=3.9
-            __AlpinePackagesEdgeMain+=" llvm11-libs"
-            __AlpinePackagesEdgeMain+=" clang-libs"
-            ;;
-        alpine3.13)
+        alpine*)
             __CodeName=alpine
             __UbuntuRepo=
-            __AlpineVersion=3.13
-            # Alpine 3.13 has all the packages we need in the 3.13 repository
-            __AlpinePackages+=$__AlpinePackagesEdgeCommunity
-            __AlpinePackagesEdgeCommunity=
-            __AlpinePackages+=$__AlpinePackagesEdgeMain
-            __AlpinePackagesEdgeMain=
-            __AlpinePackages+=" llvm10-libs"
+            version="${lowerI/alpine/}"
+
+            if [[ "$version" == "edge" ]]; then
+                __AlpineVersion=edge
+            else
+                parts=(${version//./ })
+                __AlpineMajorVersion="${parts[0]}"
+                __AlpineMinoVersion="${parts[1]}"
+                __AlpineVersion="$__AlpineMajorVersion.$__AlpineMinoVersion"
+            fi
             ;;
-        freebsd11)
-            __FreeBSDBase="11.3-RELEASE"
-            __FreeBSDABI="11"
-            ;&
         freebsd12)
             __CodeName=freebsd
-            __BuildArch=x64
             __SkipUnmount=1
             ;;
         freebsd13)
             __CodeName=freebsd
-            __FreeBSDBase="13.0-RELEASE"
+            __FreeBSDBase="13.2-RELEASE"
             __FreeBSDABI="13"
-            __BuildArch=x64
             __SkipUnmount=1
             ;;
         illumos)
             __CodeName=illumos
-            __BuildArch=x64
+            __SkipUnmount=1
+            ;;
+        haiku)
+            __CodeName=haiku
             __SkipUnmount=1
             ;;
         --skipunmount)
             __SkipUnmount=1
             ;;
+        --skipsigcheck)
+            __SkipSigCheck=1
+            ;;
         --rootfsdir|-rootfsdir)
             shift
-            __RootfsDir=$1
+            __RootfsDir="$1"
             ;;
         --use-mirror)
             __UseMirror=1
             ;;
+        --use-jobs)
+            shift
+            MAXJOBS=$1
+            ;;
         *)
             __UnprocessedBuildArgs="$__UnprocessedBuildArgs $1"
             ;;
@@ -242,85 +377,154 @@ while :; do
     shift
 done
 
-if [ "$__BuildArch" == "armel" ]; then
+case "$__AlpineVersion" in
+    3.14) __AlpinePackages+=" llvm11-libs" ;;
+    3.15) __AlpinePackages+=" llvm12-libs" ;;
+    3.16) __AlpinePackages+=" llvm13-libs" ;;
+    3.17) __AlpinePackages+=" llvm15-libs" ;;
+    edge) __AlpineLlvmLibsLookup=1 ;;
+    *)
+        if [[ "$__AlpineArch" =~ s390x|ppc64le ]]; then
+            __AlpineVersion=3.15 # minimum version that supports lldb-dev
+            __AlpinePackages+=" llvm12-libs"
+        elif [[ "$__AlpineArch" == "x86" ]]; then
+            __AlpineVersion=3.17 # minimum version that supports lldb-dev
+            __AlpinePackages+=" llvm15-libs"
+        elif [[ "$__AlpineArch" == "riscv64" ]]; then
+            __AlpineLlvmLibsLookup=1
+            __AlpineVersion=edge # minimum version with APKINDEX.tar.gz (packages archive)
+        else
+            __AlpineVersion=3.13 # 3.13 to maximize compatibility
+            __AlpinePackages+=" llvm10-libs"
+
+            if [[ "$__AlpineArch" == "armv7" ]]; then
+                __AlpinePackages="${__AlpinePackages//numactl-dev/}"
+            fi
+        fi
+esac
+
+if [[ "$__AlpineVersion" =~ 3\.1[345] ]]; then
+    # compiler-rt--static was merged in compiler-rt package in alpine 3.16
+    # for older versions, we need compiler-rt--static, so replace the name
+    __AlpinePackages="${__AlpinePackages/compiler-rt/compiler-rt-static}"
+fi
+
+if [[ "$__BuildArch" == "armel" ]]; then
     __LLDB_Package="lldb-3.5-dev"
 fi
+
+if [[ "$__CodeName" == "xenial" && "$__UbuntuArch" == "armhf" ]]; then
+    # libnuma-dev is not available on armhf for xenial
+    __UbuntuPackages="${__UbuntuPackages//libnuma-dev/}"
+fi
+
 __UbuntuPackages+=" ${__LLDB_Package:-}"
 
-if [ -z "$__RootfsDir" ] && [ ! -z "$ROOTFS_DIR" ]; then
-    __RootfsDir=$ROOTFS_DIR
+if [[ -n "$__LLVM_MajorVersion" ]]; then
+    __UbuntuPackages+=" libclang-common-${__LLVM_MajorVersion}${__LLVM_MinorVersion:+.$__LLVM_MinorVersion}-dev"
+fi
+
+if [[ -z "$__RootfsDir" && -n "$ROOTFS_DIR" ]]; then
+    __RootfsDir="$ROOTFS_DIR"
 fi
 
-if [ -z "$__RootfsDir" ]; then
+if [[ -z "$__RootfsDir" ]]; then
     __RootfsDir="$__CrossDir/../../../.tools/rootfs/$__BuildArch"
 fi
 
-if [ -d "$__RootfsDir" ]; then
-    if [ $__SkipUnmount == 0 ]; then
-        umount $__RootfsDir/* || true
+if [[ -d "$__RootfsDir" ]]; then
+    if [[ "$__SkipUnmount" == "0" ]]; then
+        umount "$__RootfsDir"/* || true
     fi
-    rm -rf $__RootfsDir
+    rm -rf "$__RootfsDir"
 fi
 
-mkdir -p $__RootfsDir
+mkdir -p "$__RootfsDir"
 __RootfsDir="$( cd "$__RootfsDir" && pwd )"
 
 if [[ "$__CodeName" == "alpine" ]]; then
-    __ApkToolsVersion=2.9.1
-    __ApkToolsDir=$(mktemp -d)
-    wget https://github.com/alpinelinux/apk-tools/releases/download/v$__ApkToolsVersion/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz -P $__ApkToolsDir
-    tar -xf $__ApkToolsDir/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz -C $__ApkToolsDir
-    mkdir -p $__RootfsDir/usr/bin
-    cp -v /usr/bin/qemu-$__QEMUArch-static $__RootfsDir/usr/bin
-
-    $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
-      -X http://dl-cdn.alpinelinux.org/alpine/v$__AlpineVersion/main \
-      -X http://dl-cdn.alpinelinux.org/alpine/v$__AlpineVersion/community \
-      -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
-      add $__AlpinePackages
-
-    if [[ -n "$__AlpinePackagesEdgeMain" ]]; then
-      $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
-        -X http://dl-cdn.alpinelinux.org/alpine/edge/main \
-        -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
-        add $__AlpinePackagesEdgeMain
+    __ApkToolsVersion=2.12.11
+    __ApkToolsSHA512SUM=53e57b49230da07ef44ee0765b9592580308c407a8d4da7125550957bb72cb59638e04f8892a18b584451c8d841d1c7cb0f0ab680cc323a3015776affaa3be33
+    __ApkToolsDir="$(mktemp -d)"
+    __ApkKeysDir="$(mktemp -d)"
+
+    wget "https://gitlab.alpinelinux.org/api/v4/projects/5/packages/generic//v$__ApkToolsVersion/x86_64/apk.static" -P "$__ApkToolsDir"
+    echo "$__ApkToolsSHA512SUM $__ApkToolsDir/apk.static" | sha512sum -c
+    chmod +x "$__ApkToolsDir/apk.static"
+
+    if [[ -f "/usr/bin/qemu-$__QEMUArch-static" ]]; then
+        mkdir -p "$__RootfsDir"/usr/bin
+        cp -v "/usr/bin/qemu-$__QEMUArch-static" "$__RootfsDir/usr/bin"
+    fi
+
+    if [[ "$__AlpineVersion" == "edge" ]]; then
+        version=edge
+    else
+        version="v$__AlpineVersion"
     fi
 
-    if [[ -n "$__AlpinePackagesEdgeCommunity" ]]; then
-      $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
-        -X http://dl-cdn.alpinelinux.org/alpine/edge/community \
-        -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
-        add $__AlpinePackagesEdgeCommunity
+    for line in $__AlpineKeys; do
+        id="${line%%:*}"
+        content="${line#*:}"
+
+        echo -e "-----BEGIN PUBLIC KEY-----\n$content\n-----END PUBLIC KEY-----" > "$__ApkKeysDir/alpine-devel@lists.alpinelinux.org-$id.rsa.pub"
+    done
+
+    if [[ "$__SkipSigCheck" == "1" ]]; then
+        __ApkSignatureArg="--allow-untrusted"
+    else
+        __ApkSignatureArg="--keys-dir $__ApkKeysDir"
+    fi
+
+    # initialize DB
+    "$__ApkToolsDir/apk.static" \
+        -X "http://dl-cdn.alpinelinux.org/alpine/$version/main" \
+        -X "http://dl-cdn.alpinelinux.org/alpine/$version/community" \
+        -U $__ApkSignatureArg --root "$__RootfsDir" --arch "$__AlpineArch" --initdb add
+
+    if [[ "$__AlpineLlvmLibsLookup" == 1 ]]; then
+        __AlpinePackages+=" $("$__ApkToolsDir/apk.static" \
+            -X "http://dl-cdn.alpinelinux.org/alpine/$version/main" \
+            -X "http://dl-cdn.alpinelinux.org/alpine/$version/community" \
+            -U $__ApkSignatureArg --root "$__RootfsDir" --arch "$__AlpineArch" \
+            search 'llvm*-libs' | sort | tail -1 | sed 's/-[^-]*//2g')"
     fi
 
-    rm -r $__ApkToolsDir
+    # install all packages in one go
+    "$__ApkToolsDir/apk.static" \
+        -X "http://dl-cdn.alpinelinux.org/alpine/$version/main" \
+        -X "http://dl-cdn.alpinelinux.org/alpine/$version/community" \
+        -U $__ApkSignatureArg --root "$__RootfsDir" --arch "$__AlpineArch" \
+        add $__AlpinePackages
+
+    rm -r "$__ApkToolsDir"
 elif [[ "$__CodeName" == "freebsd" ]]; then
-    mkdir -p $__RootfsDir/usr/local/etc
-    JOBS="$(getconf _NPROCESSORS_ONLN)"
-    wget -O - https://download.freebsd.org/ftp/releases/amd64/${__FreeBSDBase}/base.txz | tar -C $__RootfsDir -Jxf - ./lib ./usr/lib ./usr/libdata ./usr/include ./usr/share/keys ./etc ./bin/freebsd-version
-    echo "ABI = \"FreeBSD:${__FreeBSDABI}:amd64\"; FINGERPRINTS = \"${__RootfsDir}/usr/share/keys\"; REPOS_DIR = [\"${__RootfsDir}/etc/pkg\"]; REPO_AUTOUPDATE = NO; RUN_SCRIPTS = NO;" > ${__RootfsDir}/usr/local/etc/pkg.conf
-    echo "FreeBSD: { url: "pkg+http://pkg.FreeBSD.org/\${ABI}/quarterly", mirror_type: \"srv\", signature_type: \"fingerprints\", fingerprints: \"${__RootfsDir}/usr/share/keys/pkg\", enabled: yes }" > ${__RootfsDir}/etc/pkg/FreeBSD.conf
-    mkdir -p $__RootfsDir/tmp
+    mkdir -p "$__RootfsDir"/usr/local/etc
+    JOBS=${MAXJOBS:="$(getconf _NPROCESSORS_ONLN)"}
+    wget -O - "https://download.freebsd.org/ftp/releases/${__FreeBSDArch}/${__FreeBSDMachineArch}/${__FreeBSDBase}/base.txz" | tar -C "$__RootfsDir" -Jxf - ./lib ./usr/lib ./usr/libdata ./usr/include ./usr/share/keys ./etc ./bin/freebsd-version
+    echo "ABI = \"FreeBSD:${__FreeBSDABI}:${__FreeBSDMachineArch}\"; FINGERPRINTS = \"${__RootfsDir}/usr/share/keys\"; REPOS_DIR = [\"${__RootfsDir}/etc/pkg\"]; REPO_AUTOUPDATE = NO; RUN_SCRIPTS = NO;" > "${__RootfsDir}"/usr/local/etc/pkg.conf
+    echo "FreeBSD: { url: \"pkg+http://pkg.FreeBSD.org/\${ABI}/quarterly\", mirror_type: \"srv\", signature_type: \"fingerprints\", fingerprints: \"${__RootfsDir}/usr/share/keys/pkg\", enabled: yes }" > "${__RootfsDir}"/etc/pkg/FreeBSD.conf
+    mkdir -p "$__RootfsDir"/tmp
     # get and build package manager
-    wget -O -  https://github.com/freebsd/pkg/archive/${__FreeBSDPkg}.tar.gz  |  tar -C $__RootfsDir/tmp -zxf -
-    cd $__RootfsDir/tmp/pkg-${__FreeBSDPkg}
+    wget -O - "https://github.com/freebsd/pkg/archive/${__FreeBSDPkg}.tar.gz" | tar -C "$__RootfsDir"/tmp -zxf -
+    cd "$__RootfsDir/tmp/pkg-${__FreeBSDPkg}"
     # needed for install to succeed
-    mkdir -p $__RootfsDir/host/etc
-    ./autogen.sh && ./configure --prefix=$__RootfsDir/host && make -j "$JOBS" && make install
-    rm -rf $__RootfsDir/tmp/pkg-${__FreeBSDPkg}
+    mkdir -p "$__RootfsDir"/host/etc
+    ./autogen.sh && ./configure --prefix="$__RootfsDir"/host && make -j "$JOBS" && make install
+    rm -rf "$__RootfsDir/tmp/pkg-${__FreeBSDPkg}"
     # install packages we need.
-    INSTALL_AS_USER=$(whoami) $__RootfsDir/host/sbin/pkg -r $__RootfsDir -C $__RootfsDir/usr/local/etc/pkg.conf update
-    INSTALL_AS_USER=$(whoami) $__RootfsDir/host/sbin/pkg -r $__RootfsDir -C $__RootfsDir/usr/local/etc/pkg.conf install --yes $__FreeBSDPackages
+    INSTALL_AS_USER=$(whoami) "$__RootfsDir"/host/sbin/pkg -r "$__RootfsDir" -C "$__RootfsDir"/usr/local/etc/pkg.conf update
+    INSTALL_AS_USER=$(whoami) "$__RootfsDir"/host/sbin/pkg -r "$__RootfsDir" -C "$__RootfsDir"/usr/local/etc/pkg.conf install --yes $__FreeBSDPackages
 elif [[ "$__CodeName" == "illumos" ]]; then
     mkdir "$__RootfsDir/tmp"
     pushd "$__RootfsDir/tmp"
-    JOBS="$(getconf _NPROCESSORS_ONLN)"
+    JOBS=${MAXJOBS:="$(getconf _NPROCESSORS_ONLN)"}
     echo "Downloading sysroot."
     wget -O - https://github.com/illumos/sysroot/releases/download/20181213-de6af22ae73b-v1/illumos-sysroot-i386-20181213-de6af22ae73b-v1.tar.gz | tar -C "$__RootfsDir" -xzf -
     echo "Building binutils. Please wait.."
     wget -O - https://ftp.gnu.org/gnu/binutils/binutils-2.33.1.tar.bz2 | tar -xjf -
     mkdir build-binutils && cd build-binutils
-    ../binutils-2.33.1/configure --prefix="$__RootfsDir" --target="x86_64-sun-solaris2.10" --program-prefix="x86_64-illumos-" --with-sysroot="$__RootfsDir"
+    ../binutils-2.33.1/configure --prefix="$__RootfsDir" --target="${__illumosArch}-sun-solaris2.10" --program-prefix="${__illumosArch}-illumos-" --with-sysroot="$__RootfsDir"
     make -j "$JOBS" && make install && cd ..
     echo "Building gcc. Please wait.."
     wget -O - https://ftp.gnu.org/gnu/gcc/gcc-8.4.0/gcc-8.4.0.tar.xz | tar -xJf -
@@ -330,22 +534,27 @@ elif [[ "$__CodeName" == "illumos" ]]; then
     CFLAGS_FOR_TARGET="-fPIC"
     export CFLAGS CXXFLAGS CXXFLAGS_FOR_TARGET CFLAGS_FOR_TARGET
     mkdir build-gcc && cd build-gcc
-    ../gcc-8.4.0/configure --prefix="$__RootfsDir" --target="x86_64-sun-solaris2.10" --program-prefix="x86_64-illumos-" --with-sysroot="$__RootfsDir" --with-gnu-as       \
+    ../gcc-8.4.0/configure --prefix="$__RootfsDir" --target="${__illumosArch}-sun-solaris2.10" --program-prefix="${__illumosArch}-illumos-" --with-sysroot="$__RootfsDir" --with-gnu-as       \
         --with-gnu-ld --disable-nls --disable-libgomp --disable-libquadmath --disable-libssp --disable-libvtv --disable-libcilkrts --disable-libada --disable-libsanitizer \
         --disable-libquadmath-support --disable-shared --enable-tls
     make -j "$JOBS" && make install && cd ..
-    BaseUrl=https://pkgsrc.joyent.com
+    BaseUrl=https://pkgsrc.smartos.org
     if [[ "$__UseMirror" == 1 ]]; then
-        BaseUrl=http://pkgsrc.smartos.skylime.net
+        BaseUrl=https://pkgsrc.smartos.skylime.net
     fi
-    BaseUrl="$BaseUrl"/packages/SmartOS/2020Q1/x86_64/All
+    BaseUrl="$BaseUrl/packages/SmartOS/trunk/${__illumosArch}/All"
+    echo "Downloading manifest"
+    wget "$BaseUrl"
     echo "Downloading dependencies."
     read -ra array <<<"$__IllumosPackages"
     for package in "${array[@]}"; do
-       echo "Installing $package..."
+        echo "Installing '$package'"
+        # find last occurrence of package in listing and extract its name
+        package="$(sed -En '/.*href="('"$package"'-[0-9].*).tgz".*/h;$!d;g;s//\1/p' All)"
+        echo "Resolved name '$package'"
         wget "$BaseUrl"/"$package".tgz
         ar -x "$package".tgz
-        tar --skip-old-files -xzf "$package".tmp.tgz -C "$__RootfsDir" 2>/dev/null
+        tar --skip-old-files -xzf "$package".tmp.tg* -C "$__RootfsDir" 2>/dev/null
     done
     echo "Cleaning up temporary files."
     popd
@@ -356,26 +565,82 @@ elif [[ "$__CodeName" == "illumos" ]]; then
     wget -P "$__RootfsDir"/usr/include/net https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/io/bpf/net/dlt.h
     wget -P "$__RootfsDir"/usr/include/netpacket https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/inet/sockmods/netpacket/packet.h
     wget -P "$__RootfsDir"/usr/include/sys https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/sys/sdt.h
-elif [[ -n $__CodeName ]]; then
-    qemu-debootstrap --arch $__UbuntuArch $__CodeName $__RootfsDir $__UbuntuRepo
-    cp $__CrossDir/$__BuildArch/sources.list.$__CodeName $__RootfsDir/etc/apt/sources.list
-    chroot $__RootfsDir apt-get update
-    chroot $__RootfsDir apt-get -f -y install
-    chroot $__RootfsDir apt-get -y install $__UbuntuPackages
-    chroot $__RootfsDir symlinks -cr /usr
-    chroot $__RootfsDir apt-get clean
-
-    if [ $__SkipUnmount == 0 ]; then
-        umount $__RootfsDir/* || true
+elif [[ "$__CodeName" == "haiku" ]]; then
+    JOBS=${MAXJOBS:="$(getconf _NPROCESSORS_ONLN)"}
+
+    echo "Building Haiku sysroot for $__HaikuArch"
+    mkdir -p "$__RootfsDir/tmp"
+    pushd "$__RootfsDir/tmp"
+
+    mkdir "$__RootfsDir/tmp/download"
+
+    echo "Downloading Haiku package tool"
+    git clone https://github.com/haiku/haiku-toolchains-ubuntu --depth 1 $__RootfsDir/tmp/script
+    wget -O "$__RootfsDir/tmp/download/hosttools.zip" $($__RootfsDir/tmp/script/fetch.sh --hosttools)
+    unzip -o "$__RootfsDir/tmp/download/hosttools.zip" -d "$__RootfsDir/tmp/bin"
+
+    DepotBaseUrl="https://depot.haiku-os.org/__api/v2/pkg/get-pkg"
+    HpkgBaseUrl="https://eu.hpkg.haiku-os.org/haiku/master/$__HaikuArch/current"
+
+    # Download Haiku packages
+    echo "Downloading Haiku packages"
+    read -ra array <<<"$__HaikuPackages"
+    for package in "${array[@]}"; do
+        echo "Downloading $package..."
+        # API documented here: https://github.com/haiku/haikudepotserver/blob/master/haikudepotserver-api2/src/main/resources/api2/pkg.yaml#L60
+        # The schema here: https://github.com/haiku/haikudepotserver/blob/master/haikudepotserver-api2/src/main/resources/api2/pkg.yaml#L598
+        hpkgDownloadUrl="$(wget -qO- --post-data='{"name":"'"$package"'","repositorySourceCode":"haikuports_'$__HaikuArch'","versionType":"LATEST","naturalLanguageCode":"en"}' \
+            --header='Content-Type:application/json' "$DepotBaseUrl" | jq -r '.result.versions[].hpkgDownloadURL')"
+        wget -P "$__RootfsDir/tmp/download" "$hpkgDownloadUrl"
+    done
+    for package in haiku haiku_devel; do
+        echo "Downloading $package..."
+        hpkgVersion="$(wget -qO- $HpkgBaseUrl | sed -n 's/^.*version: "\([^"]*\)".*$/\1/p')"
+        wget -P "$__RootfsDir/tmp/download" "$HpkgBaseUrl/packages/$package-$hpkgVersion-1-$__HaikuArch.hpkg"
+    done
+
+    # Set up the sysroot
+    echo "Setting up sysroot and extracting required packages"
+    mkdir -p "$__RootfsDir/boot/system"
+    for file in "$__RootfsDir/tmp/download/"*.hpkg; do
+        echo "Extracting $file..."
+        LD_LIBRARY_PATH="$__RootfsDir/tmp/bin" "$__RootfsDir/tmp/bin/package" extract -C "$__RootfsDir/boot/system" "$file"
+    done
+
+    # Download buildtools
+    echo "Downloading Haiku buildtools"
+    wget -O "$__RootfsDir/tmp/download/buildtools.zip" $($__RootfsDir/tmp/script/fetch.sh --buildtools --arch=$__HaikuArch)
+    unzip -o "$__RootfsDir/tmp/download/buildtools.zip" -d "$__RootfsDir"
+
+    # Cleaning up temporary files
+    echo "Cleaning up temporary files"
+    popd
+    rm -rf "$__RootfsDir/tmp"
+elif [[ -n "$__CodeName" ]]; then
+
+    if [[ "$__SkipSigCheck" == "0" ]]; then
+        __Keyring="$__Keyring --force-check-gpg"
+    fi
+
+    debootstrap "--variant=minbase" $__Keyring --arch "$__UbuntuArch" "$__CodeName" "$__RootfsDir" "$__UbuntuRepo"
+    cp "$__CrossDir/$__BuildArch/sources.list.$__CodeName" "$__RootfsDir/etc/apt/sources.list"
+    chroot "$__RootfsDir" apt-get update
+    chroot "$__RootfsDir" apt-get -f -y install
+    chroot "$__RootfsDir" apt-get -y install $__UbuntuPackages
+    chroot "$__RootfsDir" symlinks -cr /usr
+    chroot "$__RootfsDir" apt-get clean
+
+    if [[ "$__SkipUnmount" == "0" ]]; then
+        umount "$__RootfsDir"/* || true
     fi
 
     if [[ "$__BuildArch" == "armel" && "$__CodeName" == "jessie" ]]; then
-        pushd $__RootfsDir
-        patch -p1 < $__CrossDir/$__BuildArch/armel.jessie.patch
+        pushd "$__RootfsDir"
+        patch -p1 < "$__CrossDir/$__BuildArch/armel.jessie.patch"
         popd
     fi
 elif [[ "$__Tizen" == "tizen" ]]; then
-    ROOTFS_DIR=$__RootfsDir $__CrossDir/$__BuildArch/tizen-build-rootfs.sh
+    ROOTFS_DIR="$__RootfsDir" "$__CrossDir/tizen-build-rootfs.sh" "$__BuildArch"
 else
     echo "Unsupported target platform."
     usage;
diff --git a/eng/common/cross/ppc64le/sources.list.bionic b/eng/common/cross/ppc64le/sources.list.bionic
new file mode 100644
index 00000000000..21095574095
--- /dev/null
+++ b/eng/common/cross/ppc64le/sources.list.bionic
@@ -0,0 +1,11 @@
+deb http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted
+deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted
+
+deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted universe multiverse
+deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted universe multiverse
diff --git a/eng/common/cross/riscv64/sources.list.sid b/eng/common/cross/riscv64/sources.list.sid
new file mode 100644
index 00000000000..65f730d224c
--- /dev/null
+++ b/eng/common/cross/riscv64/sources.list.sid
@@ -0,0 +1 @@
+deb http://deb.debian.org/debian-ports sid main
diff --git a/eng/common/cross/arm64/tizen-build-rootfs.sh b/eng/common/cross/tizen-build-rootfs.sh
similarity index 55%
rename from eng/common/cross/arm64/tizen-build-rootfs.sh
rename to eng/common/cross/tizen-build-rootfs.sh
index 13bfddb5e2a..ac84173d44f 100644
--- a/eng/common/cross/arm64/tizen-build-rootfs.sh
+++ b/eng/common/cross/tizen-build-rootfs.sh
@@ -1,8 +1,34 @@
 #!/usr/bin/env bash
 set -e
 
+ARCH=$1
+LINK_ARCH=$ARCH
+
+case "$ARCH" in
+    arm)
+        TIZEN_ARCH="armv7hl"
+        ;;
+    armel)
+        TIZEN_ARCH="armv7l"
+        LINK_ARCH="arm"
+        ;;
+    arm64)
+        TIZEN_ARCH="aarch64"
+        ;;
+    x86)
+        TIZEN_ARCH="i686"
+        ;;
+    x64)
+        TIZEN_ARCH="x86_64"
+        LINK_ARCH="x86"
+        ;;
+    *)
+        echo "Unsupported architecture for tizen: $ARCH"
+        exit 1
+esac
+
 __CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
-__TIZEN_CROSSDIR="$__CrossDir/tizen"
+__TIZEN_CROSSDIR="$__CrossDir/${ARCH}/tizen"
 
 if [[ -z "$ROOTFS_DIR" ]]; then
     echo "ROOTFS_DIR is not defined."
@@ -14,7 +40,7 @@ mkdir -p $TIZEN_TMP_DIR
 
 # Download files
 echo ">>Start downloading files"
-VERBOSE=1 $__CrossDir/tizen-fetch.sh $TIZEN_TMP_DIR
+VERBOSE=1 $__CrossDir/tizen-fetch.sh $TIZEN_TMP_DIR $TIZEN_ARCH
 echo "<<Finish downloading files"
 
 echo ">>Start constructing Tizen rootfs"
@@ -30,6 +56,6 @@ rm -rf $TIZEN_TMP_DIR
 
 # Configure Tizen rootfs
 echo ">>Start configuring Tizen rootfs"
-ln -sfn asm-arm64 ./usr/include/asm
+ln -sfn asm-${LINK_ARCH} ./usr/include/asm
 patch -p1 < $__TIZEN_CROSSDIR/tizen.patch
 echo "<<Finish configuring Tizen rootfs"
diff --git a/eng/common/cross/tizen-fetch.sh b/eng/common/cross/tizen-fetch.sh
new file mode 100644
index 00000000000..c18de68d3ed
--- /dev/null
+++ b/eng/common/cross/tizen-fetch.sh
@@ -0,0 +1,172 @@
+#!/usr/bin/env bash
+set -e
+
+if [[ -z "${VERBOSE// }" ]] || [ "$VERBOSE" -ne "$VERBOSE" ] 2>/dev/null; then
+    VERBOSE=0
+fi
+
+Log()
+{
+    if [ $VERBOSE -ge $1 ]; then
+        echo ${@:2}
+    fi
+}
+
+Inform()
+{
+    Log 1 -e "\x1B[0;34m$@\x1B[m"
+}
+
+Debug()
+{
+    Log 2 -e "\x1B[0;32m$@\x1B[m"
+}
+
+Error()
+{
+    >&2 Log 0 -e "\x1B[0;31m$@\x1B[m"
+}
+
+Fetch()
+{
+    URL=$1
+    FILE=$2
+    PROGRESS=$3
+    if [ $VERBOSE -ge 1 ] && [ $PROGRESS ]; then
+        CURL_OPT="--progress-bar"
+    else
+        CURL_OPT="--silent"
+    fi
+    curl $CURL_OPT $URL > $FILE
+}
+
+hash curl 2> /dev/null || { Error "Require 'curl' Aborting."; exit 1; }
+hash xmllint 2> /dev/null || { Error "Require 'xmllint' Aborting."; exit 1; }
+hash sha256sum 2> /dev/null || { Error "Require 'sha256sum' Aborting."; exit 1; }
+
+TMPDIR=$1
+if [ ! -d $TMPDIR ]; then
+    TMPDIR=./tizen_tmp
+    Debug "Create temporary directory : $TMPDIR"
+    mkdir -p $TMPDIR
+fi
+
+TIZEN_ARCH=$2
+
+TIZEN_URL=http://download.tizen.org/snapshots/TIZEN/Tizen
+BUILD_XML=build.xml
+REPOMD_XML=repomd.xml
+PRIMARY_XML=primary.xml
+TARGET_URL="http://__not_initialized"
+
+Xpath_get()
+{
+    XPATH_RESULT=''
+    XPATH=$1
+    XML_FILE=$2
+    RESULT=$(xmllint --xpath $XPATH $XML_FILE)
+    if [[ -z ${RESULT// } ]]; then
+        Error "Can not find target from $XML_FILE"
+        Debug "Xpath = $XPATH"
+        exit 1
+    fi
+    XPATH_RESULT=$RESULT
+}
+
+fetch_tizen_pkgs_init()
+{
+    TARGET=$1
+    PROFILE=$2
+    Debug "Initialize TARGET=$TARGET, PROFILE=$PROFILE"
+
+    TMP_PKG_DIR=$TMPDIR/tizen_${PROFILE}_pkgs
+    if [ -d $TMP_PKG_DIR ]; then rm -rf $TMP_PKG_DIR; fi
+    mkdir -p $TMP_PKG_DIR
+
+    PKG_URL=$TIZEN_URL/$PROFILE/latest
+
+    BUILD_XML_URL=$PKG_URL/$BUILD_XML
+    TMP_BUILD=$TMP_PKG_DIR/$BUILD_XML
+    TMP_REPOMD=$TMP_PKG_DIR/$REPOMD_XML
+    TMP_PRIMARY=$TMP_PKG_DIR/$PRIMARY_XML
+    TMP_PRIMARYGZ=${TMP_PRIMARY}.gz
+
+    Fetch $BUILD_XML_URL $TMP_BUILD
+
+    Debug "fetch $BUILD_XML_URL to $TMP_BUILD"
+
+    TARGET_XPATH="//build/buildtargets/buildtarget[@name=\"$TARGET\"]/repo[@type=\"binary\"]/text()"
+    Xpath_get $TARGET_XPATH $TMP_BUILD
+    TARGET_PATH=$XPATH_RESULT
+    TARGET_URL=$PKG_URL/$TARGET_PATH
+
+    REPOMD_URL=$TARGET_URL/repodata/repomd.xml
+    PRIMARY_XPATH='string(//*[local-name()="data"][@type="primary"]/*[local-name()="location"]/@href)'
+
+    Fetch $REPOMD_URL $TMP_REPOMD
+
+    Debug "fetch $REPOMD_URL to $TMP_REPOMD"
+
+    Xpath_get $PRIMARY_XPATH $TMP_REPOMD
+    PRIMARY_XML_PATH=$XPATH_RESULT
+    PRIMARY_URL=$TARGET_URL/$PRIMARY_XML_PATH
+
+    Fetch $PRIMARY_URL $TMP_PRIMARYGZ
+
+    Debug "fetch $PRIMARY_URL to $TMP_PRIMARYGZ"
+
+    gunzip $TMP_PRIMARYGZ
+
+    Debug "unzip $TMP_PRIMARYGZ to $TMP_PRIMARY"
+}
+
+fetch_tizen_pkgs()
+{
+    ARCH=$1
+    PACKAGE_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="location"]/@href)'
+
+    PACKAGE_CHECKSUM_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="checksum"]/text())'
+
+    for pkg in ${@:2}
+    do
+        Inform "Fetching... $pkg"
+        XPATH=${PACKAGE_XPATH_TPL/_PKG_/$pkg}
+        XPATH=${XPATH/_ARCH_/$ARCH}
+        Xpath_get $XPATH $TMP_PRIMARY
+        PKG_PATH=$XPATH_RESULT
+
+        XPATH=${PACKAGE_CHECKSUM_XPATH_TPL/_PKG_/$pkg}
+        XPATH=${XPATH/_ARCH_/$ARCH}
+        Xpath_get $XPATH $TMP_PRIMARY
+        CHECKSUM=$XPATH_RESULT
+
+        PKG_URL=$TARGET_URL/$PKG_PATH
+        PKG_FILE=$(basename $PKG_PATH)
+        PKG_PATH=$TMPDIR/$PKG_FILE
+
+        Debug "Download $PKG_URL to $PKG_PATH"
+        Fetch $PKG_URL $PKG_PATH true
+
+        echo "$CHECKSUM $PKG_PATH" | sha256sum -c - > /dev/null
+        if [ $? -ne 0 ]; then
+            Error "Fail to fetch $PKG_URL to $PKG_PATH"
+            Debug "Checksum = $CHECKSUM"
+            exit 1
+        fi
+    done
+}
+
+Inform "Initialize ${TIZEN_ARCH} base"
+fetch_tizen_pkgs_init standard Tizen-Base
+Inform "fetch common packages"
+fetch_tizen_pkgs ${TIZEN_ARCH} gcc gcc-devel-static glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
+Inform "fetch coreclr packages"
+fetch_tizen_pkgs ${TIZEN_ARCH} lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
+Inform "fetch corefx packages"
+fetch_tizen_pkgs ${TIZEN_ARCH} libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
+
+Inform "Initialize standard unified"
+fetch_tizen_pkgs_init standard Tizen-Unified
+Inform "fetch corefx packages"
+fetch_tizen_pkgs ${TIZEN_ARCH} gssdp gssdp-devel tizen-release
+
diff --git a/eng/common/cross/toolchain.cmake b/eng/common/cross/toolchain.cmake
index 51f30e53dd4..a88d643c8a7 100644
--- a/eng/common/cross/toolchain.cmake
+++ b/eng/common/cross/toolchain.cmake
@@ -6,25 +6,31 @@ unset(FREEBSD)
 unset(ILLUMOS)
 unset(ANDROID)
 unset(TIZEN)
+unset(HAIKU)
 
 set(TARGET_ARCH_NAME $ENV{TARGET_BUILD_ARCH})
 if(EXISTS ${CROSS_ROOTFS}/bin/freebsd-version)
   set(CMAKE_SYSTEM_NAME FreeBSD)
+  set(FREEBSD 1)
 elseif(EXISTS ${CROSS_ROOTFS}/usr/platform/i86pc)
   set(CMAKE_SYSTEM_NAME SunOS)
   set(ILLUMOS 1)
+elseif(EXISTS ${CROSS_ROOTFS}/boot/system/develop/headers/config/HaikuConfig.h)
+  set(CMAKE_SYSTEM_NAME Haiku)
+  set(HAIKU 1)
 else()
   set(CMAKE_SYSTEM_NAME Linux)
+  set(LINUX 1)
 endif()
 set(CMAKE_SYSTEM_VERSION 1)
 
-if(TARGET_ARCH_NAME STREQUAL "armel")
-  set(CMAKE_SYSTEM_PROCESSOR armv7l)
-  set(TOOLCHAIN "arm-linux-gnueabi")
-  if("$ENV{__DistroRid}" MATCHES "tizen.*")
-    set(TIZEN_TOOLCHAIN "armv7l-tizen-linux-gnueabi/9.2.0")
-  endif()
-elseif(TARGET_ARCH_NAME STREQUAL "arm")
+if(EXISTS ${CROSS_ROOTFS}/etc/tizen-release)
+  set(TIZEN 1)
+elseif(EXISTS ${CROSS_ROOTFS}/android_platform)
+  set(ANDROID 1)
+endif()
+
+if(TARGET_ARCH_NAME STREQUAL "arm")
   set(CMAKE_SYSTEM_PROCESSOR armv7l)
   if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/armv7-alpine-linux-musleabihf)
     set(TOOLCHAIN "armv7-alpine-linux-musleabihf")
@@ -33,30 +39,83 @@ elseif(TARGET_ARCH_NAME STREQUAL "arm")
   else()
     set(TOOLCHAIN "arm-linux-gnueabihf")
   endif()
+  if(TIZEN)
+    set(TIZEN_TOOLCHAIN "armv7hl-tizen-linux-gnueabihf/9.2.0")
+  endif()
 elseif(TARGET_ARCH_NAME STREQUAL "arm64")
   set(CMAKE_SYSTEM_PROCESSOR aarch64)
   if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/aarch64-alpine-linux-musl)
     set(TOOLCHAIN "aarch64-alpine-linux-musl")
-  else()
+  elseif(LINUX)
     set(TOOLCHAIN "aarch64-linux-gnu")
+    if(TIZEN)
+      set(TIZEN_TOOLCHAIN "aarch64-tizen-linux-gnu/9.2.0")
+    endif()
+  elseif(FREEBSD)
+    set(triple "aarch64-unknown-freebsd12")
   endif()
-  if("$ENV{__DistroRid}" MATCHES "tizen.*")
-    set(TIZEN_TOOLCHAIN "aarch64-tizen-linux-gnu/9.2.0")
+elseif(TARGET_ARCH_NAME STREQUAL "armel")
+  set(CMAKE_SYSTEM_PROCESSOR armv7l)
+  set(TOOLCHAIN "arm-linux-gnueabi")
+  if(TIZEN)
+    set(TIZEN_TOOLCHAIN "armv7l-tizen-linux-gnueabi/9.2.0")
+  endif()
+elseif(TARGET_ARCH_NAME STREQUAL "armv6")
+  set(CMAKE_SYSTEM_PROCESSOR armv6l)
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/armv6-alpine-linux-musleabihf)
+    set(TOOLCHAIN "armv6-alpine-linux-musleabihf")
+  else()
+    set(TOOLCHAIN "arm-linux-gnueabihf")
+  endif()
+elseif(TARGET_ARCH_NAME STREQUAL "ppc64le")
+  set(CMAKE_SYSTEM_PROCESSOR ppc64le)
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/powerpc64le-alpine-linux-musl)
+    set(TOOLCHAIN "powerpc64le-alpine-linux-musl")
+  else()
+    set(TOOLCHAIN "powerpc64le-linux-gnu")
+  endif()
+elseif(TARGET_ARCH_NAME STREQUAL "riscv64")
+  set(CMAKE_SYSTEM_PROCESSOR riscv64)
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/riscv64-alpine-linux-musl)
+    set(TOOLCHAIN "riscv64-alpine-linux-musl")
+  else()
+    set(TOOLCHAIN "riscv64-linux-gnu")
   endif()
 elseif(TARGET_ARCH_NAME STREQUAL "s390x")
   set(CMAKE_SYSTEM_PROCESSOR s390x)
-  set(TOOLCHAIN "s390x-linux-gnu")
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/s390x-alpine-linux-musl)
+    set(TOOLCHAIN "s390x-alpine-linux-musl")
+  else()
+    set(TOOLCHAIN "s390x-linux-gnu")
+  endif()
+elseif(TARGET_ARCH_NAME STREQUAL "x64")
+  set(CMAKE_SYSTEM_PROCESSOR x86_64)
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/x86_64-alpine-linux-musl)
+    set(TOOLCHAIN "x86_64-alpine-linux-musl")
+  elseif(LINUX)
+    set(TOOLCHAIN "x86_64-linux-gnu")
+    if(TIZEN)
+      set(TIZEN_TOOLCHAIN "x86_64-tizen-linux-gnu/9.2.0")
+    endif()
+  elseif(FREEBSD)
+    set(triple "x86_64-unknown-freebsd12")
+  elseif(ILLUMOS)
+    set(TOOLCHAIN "x86_64-illumos")
+  elseif(HAIKU)
+    set(TOOLCHAIN "x86_64-unknown-haiku")
+  endif()
 elseif(TARGET_ARCH_NAME STREQUAL "x86")
   set(CMAKE_SYSTEM_PROCESSOR i686)
-  set(TOOLCHAIN "i686-linux-gnu")
-elseif (CMAKE_SYSTEM_NAME STREQUAL "FreeBSD")
-  set(CMAKE_SYSTEM_PROCESSOR "x86_64")
-  set(triple "x86_64-unknown-freebsd11")
-elseif (ILLUMOS)
-  set(CMAKE_SYSTEM_PROCESSOR "x86_64")
-  set(TOOLCHAIN "x86_64-illumos")
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/i586-alpine-linux-musl)
+    set(TOOLCHAIN "i586-alpine-linux-musl")
+  else()
+    set(TOOLCHAIN "i686-linux-gnu")
+  endif()
+  if(TIZEN)
+    set(TIZEN_TOOLCHAIN "i586-tizen-linux-gnu/9.2.0")
+  endif()
 else()
-  message(FATAL_ERROR "Arch is ${TARGET_ARCH_NAME}. Only armel, arm, arm64, s390x and x86 are supported!")
+  message(FATAL_ERROR "Arch is ${TARGET_ARCH_NAME}. Only arm, arm64, armel, armv6, ppc64le, riscv64, s390x, x64 and x86 are supported!")
 endif()
 
 if(DEFINED ENV{TOOLCHAIN})
@@ -64,7 +123,11 @@ if(DEFINED ENV{TOOLCHAIN})
 endif()
 
 # Specify include paths
-if(DEFINED TIZEN_TOOLCHAIN)
+if(TIZEN)
+  if(TARGET_ARCH_NAME STREQUAL "arm")
+    include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}/include/c++/)
+    include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}/include/c++/armv7hl-tizen-linux-gnueabihf)
+  endif()
   if(TARGET_ARCH_NAME STREQUAL "armel")
     include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}/include/c++/)
     include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}/include/c++/armv7l-tizen-linux-gnueabi)
@@ -73,9 +136,17 @@ if(DEFINED TIZEN_TOOLCHAIN)
     include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}/include/c++/)
     include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}/include/c++/aarch64-tizen-linux-gnu)
   endif()
+  if(TARGET_ARCH_NAME STREQUAL "x86")
+    include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}/include/c++/)
+    include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}/include/c++/i586-tizen-linux-gnu)
+  endif()
+  if(TARGET_ARCH_NAME STREQUAL "x64")
+    include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}/include/c++/)
+    include_directories(SYSTEM ${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}/include/c++/x86_64-tizen-linux-gnu)
+  endif()
 endif()
 
-if("$ENV{__DistroRid}" MATCHES "android.*")
+if(ANDROID)
     if(TARGET_ARCH_NAME STREQUAL "arm")
         set(ANDROID_ABI armeabi-v7a)
     elseif(TARGET_ARCH_NAME STREQUAL "arm64")
@@ -83,7 +154,9 @@ if("$ENV{__DistroRid}" MATCHES "android.*")
     endif()
 
     # extract platform number required by the NDK's toolchain
-    string(REGEX REPLACE ".*\\.([0-9]+)-.*" "\\1" ANDROID_PLATFORM "$ENV{__DistroRid}")
+    file(READ "${CROSS_ROOTFS}/android_platform" RID_FILE_CONTENTS)
+    string(REPLACE "RID=" "" ANDROID_RID "${RID_FILE_CONTENTS}")
+    string(REGEX REPLACE ".*\\.([0-9]+)-.*" "\\1" ANDROID_PLATFORM "${ANDROID_RID}")
 
     set(ANDROID_TOOLCHAIN clang)
     set(FEATURE_EVENT_TRACE 0) # disable event trace as there is no lttng-ust package in termux repository
@@ -92,12 +165,15 @@ if("$ENV{__DistroRid}" MATCHES "android.*")
 
     # include official NDK toolchain script
     include(${CROSS_ROOTFS}/../build/cmake/android.toolchain.cmake)
-elseif(CMAKE_SYSTEM_NAME STREQUAL "FreeBSD")
+elseif(FREEBSD)
     # we cross-compile by instructing clang
     set(CMAKE_C_COMPILER_TARGET ${triple})
     set(CMAKE_CXX_COMPILER_TARGET ${triple})
     set(CMAKE_ASM_COMPILER_TARGET ${triple})
     set(CMAKE_SYSROOT "${CROSS_ROOTFS}")
+    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fuse-ld=lld")
+    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -fuse-ld=lld")
+    set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -fuse-ld=lld")
 elseif(ILLUMOS)
     set(CMAKE_SYSROOT "${CROSS_ROOTFS}")
 
@@ -129,6 +205,39 @@ elseif(ILLUMOS)
 
     set(CMAKE_C_STANDARD_LIBRARIES "${CMAKE_C_STANDARD_LIBRARIES} -lssp")
     set(CMAKE_CXX_STANDARD_LIBRARIES "${CMAKE_CXX_STANDARD_LIBRARIES} -lssp")
+elseif(HAIKU)
+    set(CMAKE_SYSROOT "${CROSS_ROOTFS}")
+
+    set(TOOLSET_PREFIX ${TOOLCHAIN}-)
+    function(locate_toolchain_exec exec var)
+        string(TOUPPER ${exec} EXEC_UPPERCASE)
+        if(NOT "$ENV{CLR_${EXEC_UPPERCASE}}" STREQUAL "")
+            set(${var} "$ENV{CLR_${EXEC_UPPERCASE}}" PARENT_SCOPE)
+            return()
+        endif()
+
+        find_program(EXEC_LOCATION_${exec}
+            PATHS "${CROSS_ROOTFS}/cross-tools-x86_64/bin"
+            NAMES
+            "${TOOLSET_PREFIX}${exec}${CLR_CMAKE_COMPILER_FILE_NAME_VERSION}"
+            "${TOOLSET_PREFIX}${exec}")
+
+        if (EXEC_LOCATION_${exec} STREQUAL "EXEC_LOCATION_${exec}-NOTFOUND")
+            message(FATAL_ERROR "Unable to find toolchain executable. Name: ${exec}, Prefix: ${TOOLSET_PREFIX}.")
+        endif()
+        set(${var} ${EXEC_LOCATION_${exec}} PARENT_SCOPE)
+    endfunction()
+
+    set(CMAKE_SYSTEM_PREFIX_PATH "${CROSS_ROOTFS}")
+
+    locate_toolchain_exec(gcc CMAKE_C_COMPILER)
+    locate_toolchain_exec(g++ CMAKE_CXX_COMPILER)
+
+    set(CMAKE_C_STANDARD_LIBRARIES "${CMAKE_C_STANDARD_LIBRARIES} -lssp")
+    set(CMAKE_CXX_STANDARD_LIBRARIES "${CMAKE_CXX_STANDARD_LIBRARIES} -lssp")
+
+    # let CMake set up the correct search paths
+    include(Platform/Haiku)
 else()
     set(CMAKE_SYSROOT "${CROSS_ROOTFS}")
 
@@ -149,20 +258,20 @@ function(add_toolchain_linker_flag Flag)
   set("CMAKE_SHARED_LINKER_FLAGS${CONFIG_SUFFIX}_INIT" "${CMAKE_SHARED_LINKER_FLAGS${CONFIG_SUFFIX}_INIT} ${Flag}" PARENT_SCOPE)
 endfunction()
 
-if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
+if(LINUX)
   add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/lib/${TOOLCHAIN}")
   add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/usr/lib/${TOOLCHAIN}")
 endif()
 
-if(TARGET_ARCH_NAME STREQUAL "armel")
-  if(DEFINED TIZEN_TOOLCHAIN) # For Tizen only
+if(TARGET_ARCH_NAME MATCHES "^(arm|armel)$")
+  if(TIZEN)
     add_toolchain_linker_flag("-B${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}")
     add_toolchain_linker_flag("-L${CROSS_ROOTFS}/lib")
     add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/lib")
     add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}")
   endif()
-elseif(TARGET_ARCH_NAME STREQUAL "arm64")
-  if(DEFINED TIZEN_TOOLCHAIN) # For Tizen only
+elseif(TARGET_ARCH_NAME MATCHES "^(arm64|x64)$")
+  if(TIZEN)
     add_toolchain_linker_flag("-B${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}")
     add_toolchain_linker_flag("-L${CROSS_ROOTFS}/lib64")
     add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/lib64")
@@ -173,15 +282,28 @@ elseif(TARGET_ARCH_NAME STREQUAL "arm64")
     add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}")
   endif()
 elseif(TARGET_ARCH_NAME STREQUAL "x86")
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/i586-alpine-linux-musl)
+    add_toolchain_linker_flag("--target=${TOOLCHAIN}")
+    add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/usr/lib/gcc/${TOOLCHAIN}")
+  endif()
   add_toolchain_linker_flag(-m32)
+  if(TIZEN)
+    add_toolchain_linker_flag("-B${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}")
+    add_toolchain_linker_flag("-L${CROSS_ROOTFS}/lib")
+    add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/lib")
+    add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}")
+  endif()
 elseif(ILLUMOS)
   add_toolchain_linker_flag("-L${CROSS_ROOTFS}/lib/amd64")
   add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/amd64/lib")
+elseif(HAIKU)
+  add_toolchain_linker_flag("-lnetwork")
+  add_toolchain_linker_flag("-lroot")
 endif()
 
 # Specify compile options
 
-if((TARGET_ARCH_NAME MATCHES "^(arm|armel|arm64|s390x)$" AND NOT "$ENV{__DistroRid}" MATCHES "android.*") OR ILLUMOS)
+if((TARGET_ARCH_NAME MATCHES "^(arm|arm64|armel|armv6|ppc64le|riscv64|s390x|x64|x86)$" AND NOT ANDROID AND NOT FREEBSD) OR ILLUMOS OR HAIKU)
   set(CMAKE_C_COMPILER_TARGET ${TOOLCHAIN})
   set(CMAKE_CXX_COMPILER_TARGET ${TOOLCHAIN})
   set(CMAKE_ASM_COMPILER_TARGET ${TOOLCHAIN})
@@ -200,16 +322,22 @@ if(TARGET_ARCH_NAME MATCHES "^(arm|armel)$")
 
   add_definitions (-DCLR_ARM_FPU_CAPABILITY=${CLR_ARM_FPU_CAPABILITY})
 
+  # persist variables across multiple try_compile passes
+  list(APPEND CMAKE_TRY_COMPILE_PLATFORM_VARIABLES CLR_ARM_FPU_TYPE CLR_ARM_FPU_CAPABILITY)
+
   if(TARGET_ARCH_NAME STREQUAL "armel")
     add_compile_options(-mfloat-abi=softfp)
   endif()
 elseif(TARGET_ARCH_NAME STREQUAL "x86")
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/i586-alpine-linux-musl)
+    add_compile_options(--target=${TOOLCHAIN})
+  endif()
   add_compile_options(-m32)
   add_compile_options(-Wno-error=unused-command-line-argument)
 endif()
 
-if(DEFINED TIZEN_TOOLCHAIN)
-  if(TARGET_ARCH_NAME MATCHES "^(armel|arm64)$")
+if(TIZEN)
+  if(TARGET_ARCH_NAME MATCHES "^(arm|armel|arm64|x86)$")
     add_compile_options(-Wno-deprecated-declarations) # compile-time option
     add_compile_options(-D__extern_always_inline=inline) # compile-time option
   endif()
diff --git a/eng/common/cross/x64/sources.list.bionic b/eng/common/cross/x64/sources.list.bionic
new file mode 100644
index 00000000000..a71ccadcffa
--- /dev/null
+++ b/eng/common/cross/x64/sources.list.bionic
@@ -0,0 +1,11 @@
+deb http://archive.ubuntu.com/ubuntu/ bionic main restricted universe
+deb-src http://archive.ubuntu.com/ubuntu/ bionic main restricted universe
+
+deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted universe
+deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted universe
+
+deb http://archive.ubuntu.com/ubuntu/ bionic-backports main restricted
+deb-src http://archive.ubuntu.com/ubuntu/ bionic-backports main restricted
+
+deb http://archive.ubuntu.com/ubuntu/ bionic-security main restricted universe multiverse
+deb-src http://archive.ubuntu.com/ubuntu/ bionic-security main restricted universe multiverse
diff --git a/eng/common/cross/x64/sources.list.xenial b/eng/common/cross/x64/sources.list.xenial
new file mode 100644
index 00000000000..ad9c5a0144e
--- /dev/null
+++ b/eng/common/cross/x64/sources.list.xenial
@@ -0,0 +1,11 @@
+deb http://archive.ubuntu.com/ubuntu/ xenial main restricted universe
+deb-src http://archive.ubuntu.com/ubuntu/ xenial main restricted universe
+
+deb http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted universe
+deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted universe
+
+deb http://archive.ubuntu.com/ubuntu/ xenial-backports main restricted
+deb-src http://archive.ubuntu.com/ubuntu/ xenial-backports main restricted
+
+deb http://archive.ubuntu.com/ubuntu/ xenial-security main restricted universe multiverse
+deb-src http://archive.ubuntu.com/ubuntu/ xenial-security main restricted universe multiverse
diff --git a/eng/common/cross/x64/tizen/tizen.patch b/eng/common/cross/x64/tizen/tizen.patch
new file mode 100644
index 00000000000..56fbc881095
--- /dev/null
+++ b/eng/common/cross/x64/tizen/tizen.patch
@@ -0,0 +1,9 @@
+diff -u -r a/usr/lib64/libc.so b/usr/lib64/libc.so
+--- a/usr/lib64/libc.so	2016-12-30 23:00:08.284951863 +0900
++++ b/usr/lib64/libc.so	2016-12-30 23:00:32.140951815 +0900
+@@ -2,4 +2,4 @@
+    Use the shared library, but some functions are only in
+    the static library, so try that secondarily.  */
+ OUTPUT_FORMAT(elf64-x86-64)
+-GROUP ( /lib64/libc.so.6 /usr/lib64/libc_nonshared.a  AS_NEEDED ( /lib64/ld-linux-x86-64.so.2 ) )
++GROUP ( libc.so.6 libc_nonshared.a  AS_NEEDED ( ld-linux-x86-64.so.2 ) )
diff --git a/eng/common/cross/x86/sources.list.focal b/eng/common/cross/x86/sources.list.focal
new file mode 100644
index 00000000000..99d5731330e
--- /dev/null
+++ b/eng/common/cross/x86/sources.list.focal
@@ -0,0 +1,11 @@
+deb http://archive.ubuntu.com/ubuntu/ focal main restricted universe
+deb-src http://archive.ubuntu.com/ubuntu/ focal main restricted universe
+
+deb http://archive.ubuntu.com/ubuntu/ focal-updates main restricted universe
+deb-src http://archive.ubuntu.com/ubuntu/ focal-updates main restricted universe
+
+deb http://archive.ubuntu.com/ubuntu/ focal-backports main restricted
+deb-src http://archive.ubuntu.com/ubuntu/ focal-backports main restricted
+
+deb http://archive.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse
+deb-src http://archive.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse
diff --git a/eng/common/cross/x86/sources.list.jammy b/eng/common/cross/x86/sources.list.jammy
new file mode 100644
index 00000000000..af1c1feaeac
--- /dev/null
+++ b/eng/common/cross/x86/sources.list.jammy
@@ -0,0 +1,11 @@
+deb http://archive.ubuntu.com/ubuntu/ jammy main restricted universe
+deb-src http://archive.ubuntu.com/ubuntu/ jammy main restricted universe
+
+deb http://archive.ubuntu.com/ubuntu/ jammy-updates main restricted universe
+deb-src http://archive.ubuntu.com/ubuntu/ jammy-updates main restricted universe
+
+deb http://archive.ubuntu.com/ubuntu/ jammy-backports main restricted
+deb-src http://archive.ubuntu.com/ubuntu/ jammy-backports main restricted
+
+deb http://archive.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse
+deb-src http://archive.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse
diff --git a/eng/common/cross/x86/tizen/tizen.patch b/eng/common/cross/x86/tizen/tizen.patch
new file mode 100644
index 00000000000..f4fe8838ad6
--- /dev/null
+++ b/eng/common/cross/x86/tizen/tizen.patch
@@ -0,0 +1,9 @@
+diff -u -r a/usr/lib/libc.so b/usr/lib/libc.so
+--- a/usr/lib/libc.so	2016-12-30 23:00:08.284951863 +0900
++++ b/usr/lib/libc.so	2016-12-30 23:00:32.140951815 +0900
+@@ -2,4 +2,4 @@
+    Use the shared library, but some functions are only in
+    the static library, so try that secondarily.  */
+ OUTPUT_FORMAT(elf32-i386)
+-GROUP ( /lib/libc.so.6 /usr/lib/libc_nonshared.a  AS_NEEDED ( /lib/ld-linux.so.2 ) )
++GROUP ( libc.so.6 libc_nonshared.a  AS_NEEDED ( ld-linux.so.2 ) )
diff --git a/eng/common/darc-init.sh b/eng/common/darc-init.sh
index 4e4116f1d0b..c305ae6bd77 100755
--- a/eng/common/darc-init.sh
+++ b/eng/common/darc-init.sh
@@ -53,7 +53,7 @@ fi
 function InstallDarcCli {
   local darc_cli_package_name="microsoft.dotnet.darc"
 
-  InitializeDotNetCli
+  InitializeDotNetCli true
   local dotnet_root=$_InitializeDotNetCli
 
   if [ -z "$toolpath" ]; then
diff --git a/eng/common/dotnet-install.sh b/eng/common/dotnet-install.sh
index b09ea669f9c..7e69e3a9e24 100755
--- a/eng/common/dotnet-install.sh
+++ b/eng/common/dotnet-install.sh
@@ -54,6 +54,13 @@ cpuname=$(uname -m)
 case $cpuname in
   arm64|aarch64)
     buildarch=arm64
+    if [ "$(getconf LONG_BIT)" -lt 64 ]; then
+        # This is 32-bit OS running on 64-bit CPU (for example Raspberry Pi OS)
+        buildarch=arm
+    fi
+    ;;
+  loongarch64)
+    buildarch=loongarch64
     ;;
   amd64|x86_64)
     buildarch=x64
diff --git a/eng/common/generate-locproject.ps1 b/eng/common/generate-locproject.ps1
index 25e97ac0077..524aaa57f2b 100644
--- a/eng/common/generate-locproject.ps1
+++ b/eng/common/generate-locproject.ps1
@@ -10,9 +10,7 @@ Param(
 
 Set-StrictMode -Version 2.0
 $ErrorActionPreference = "Stop"
-. $PSScriptRoot\tools.ps1
-
-Import-Module -Name (Join-Path $PSScriptRoot 'native\CommonLibrary.psm1')
+. $PSScriptRoot\pipeline-logging-functions.ps1
 
 $exclusionsFilePath = "$SourcesDirectory\eng\Localize\LocExclusions.json"
 $exclusions = @{ Exclusions = @() }
@@ -28,13 +26,34 @@ $jsonFiles = @()
 $jsonTemplateFiles = Get-ChildItem -Recurse -Path "$SourcesDirectory" | Where-Object { $_.FullName -Match "\.template\.config\\localize\\.+\.en\.json" } # .NET templating pattern
 $jsonTemplateFiles | ForEach-Object {
     $null = $_.Name -Match "(.+)\.[\w-]+\.json" # matches '[filename].[langcode].json
-    
+
     $destinationFile = "$($_.Directory.FullName)\$($Matches.1).json"
     $jsonFiles += Copy-Item "$($_.FullName)" -Destination $destinationFile -PassThru
 }
 
 $jsonWinformsTemplateFiles = Get-ChildItem -Recurse -Path "$SourcesDirectory" | Where-Object { $_.FullName -Match "en\\strings\.json" } # current winforms pattern
 
+$wxlFiles = Get-ChildItem -Recurse -Path "$SourcesDirectory" | Where-Object { $_.FullName -Match "\\.+\.wxl" -And -Not( $_.Directory.Name -Match "\d{4}" ) } # localized files live in four digit lang ID directories; this excludes them
+if (-not $wxlFiles) {
+    $wxlEnFiles = Get-ChildItem -Recurse -Path "$SourcesDirectory" | Where-Object { $_.FullName -Match "\\1033\\.+\.wxl" } #  pick up en files (1033 = en) specifically so we can copy them to use as the neutral xlf files
+    if ($wxlEnFiles) {
+      $wxlFiles = @()
+      $wxlEnFiles | ForEach-Object {
+        $destinationFile = "$($_.Directory.Parent.FullName)\$($_.Name)"
+        $wxlFiles += Copy-Item "$($_.FullName)" -Destination $destinationFile -PassThru
+      }
+    }
+}
+
+$macosHtmlEnFiles = Get-ChildItem -Recurse -Path "$SourcesDirectory" | Where-Object { $_.FullName -Match "en\.lproj\\.+\.html$" } # add installer HTML files
+$macosHtmlFiles = @()
+if ($macosHtmlEnFiles) {
+    $macosHtmlEnFiles | ForEach-Object {
+        $destinationFile = "$($_.Directory.Parent.FullName)\$($_.Name)"
+        $macosHtmlFiles += Copy-Item "$($_.FullName)" -Destination $destinationFile -PassThru
+    }
+}
+
 $xlfFiles = @()
 
 $allXlfFiles = Get-ChildItem -Recurse -Path "$SourcesDirectory\*\*.xlf"
@@ -46,7 +65,7 @@ if ($allXlfFiles) {
 }
 $langXlfFiles | ForEach-Object {
     $null = $_.Name -Match "(.+)\.[\w-]+\.xlf" # matches '[filename].[langcode].xlf
-    
+
     $destinationFile = "$($_.Directory.FullName)\$($Matches.1).xlf"
     $xlfFiles += Copy-Item "$($_.FullName)" -Destination $destinationFile -PassThru
 }
@@ -59,10 +78,10 @@ $locJson = @{
             LanguageSet = $LanguageSet
             LocItems = @(
                 $locFiles | ForEach-Object {
-                    $outputPath = "$(($_.DirectoryName | Resolve-Path -Relative) + "\")" 
+                    $outputPath = "$(($_.DirectoryName | Resolve-Path -Relative) + "\")"
                     $continue = $true
                     foreach ($exclusion in $exclusions.Exclusions) {
-                        if ($outputPath.Contains($exclusion))
+                        if ($_.FullName.Contains($exclusion))
                         {
                             $continue = $false
                         }
@@ -79,8 +98,7 @@ $locJson = @{
                                 CopyOption = "LangIDOnPath"
                                 OutputPath = "$($_.Directory.Parent.FullName | Resolve-Path -Relative)\"
                             }
-                        }
-                        else {
+                        } else {
                             return @{
                                 SourceFile = $sourceFile
                                 CopyOption = "LangIDOnName"
@@ -90,6 +108,60 @@ $locJson = @{
                     }
                 }
             )
+        },
+        @{
+            LanguageSet = $LanguageSet
+            CloneLanguageSet = "WiX_CloneLanguages"
+            LssFiles = @( "wxl_loc.lss" )
+            LocItems = @(
+                $wxlFiles | ForEach-Object {
+                    $outputPath = "$($_.Directory.FullName | Resolve-Path -Relative)\"
+                    $continue = $true
+                    foreach ($exclusion in $exclusions.Exclusions) {
+                        if ($_.FullName.Contains($exclusion)) {
+                            $continue = $false
+                        }
+                    }
+                    $sourceFile = ($_.FullName | Resolve-Path -Relative)
+                    if ($continue)
+                    {
+                        return @{
+                            SourceFile = $sourceFile
+                            CopyOption = "LangIDOnPath"
+                            OutputPath = $outputPath
+                        }
+                    }
+                }
+            )
+        },
+        @{
+            LanguageSet = $LanguageSet
+            CloneLanguageSet = "VS_macOS_CloneLanguages"
+            LssFiles = @( ".\eng\common\loc\P22DotNetHtmlLocalization.lss" )
+            LocItems = @(
+                $macosHtmlFiles | ForEach-Object {
+                    $outputPath = "$($_.Directory.FullName | Resolve-Path -Relative)\"
+                    $continue = $true
+                    foreach ($exclusion in $exclusions.Exclusions) {
+                        if ($_.FullName.Contains($exclusion)) {
+                            $continue = $false
+                        }
+                    }
+                    $sourceFile = ($_.FullName | Resolve-Path -Relative)
+                    $lciFile = $sourceFile + ".lci"
+                    if ($continue) {
+                        $result = @{
+                            SourceFile = $sourceFile
+                            CopyOption = "LangIDOnPath"
+                            OutputPath = $outputPath
+                        }
+                        if (Test-Path $lciFile -PathType Leaf) {
+                            $result["LciFile"] = $lciFile
+                        }
+                        return $result
+                    }
+                }
+            )
         }
     )
 }
@@ -108,10 +180,10 @@ else {
 
     if ((Get-FileHash "$SourcesDirectory\eng\Localize\LocProject-generated.json").Hash -ne (Get-FileHash "$SourcesDirectory\eng\Localize\LocProject.json").Hash) {
         Write-PipelineTelemetryError -Category "OneLocBuild" -Message "Existing LocProject.json differs from generated LocProject.json. Download LocProject-generated.json and compare them."
-        
+
         exit 1
     }
     else {
         Write-Host "Generated LocProject.json and current LocProject.json are identical."
     }
-}
\ No newline at end of file
+}
diff --git a/eng/common/init-tools-native.ps1 b/eng/common/init-tools-native.ps1
index 6c7a851a808..27ccdb9ecc9 100644
--- a/eng/common/init-tools-native.ps1
+++ b/eng/common/init-tools-native.ps1
@@ -83,7 +83,8 @@ try {
                     Select-Object -Expand 'native-tools' -ErrorAction SilentlyContinue
   if ($NativeTools) {
     if ($PathPromotion -eq $True) {
-      if ($env:SYSTEM_TEAMPROJECT) { # check to see if we're in an Azure pipelines build
+      $ArcadeToolsDirectory = "$env:SYSTEMDRIVE\arcade-tools"
+      if (Test-Path $ArcadeToolsDirectory) { # if this directory exists, we should use native tools on machine
         $NativeTools.PSObject.Properties | ForEach-Object {
           $ToolName = $_.Name
           $ToolVersion = $_.Value
@@ -93,16 +94,12 @@ try {
             if ($ToolVersion -eq "latest") {
               $ToolVersion = ""
             }
-            $ArcadeToolsDirectory = "C:\arcade-tools"
-            if (-not (Test-Path $ArcadeToolsDirectory)) {
-              Write-Error "Arcade tools directory '$ArcadeToolsDirectory' was not found; artifacts were not properly installed."
-              exit 1
-            }
-            $ToolDirectory = (Get-ChildItem -Path "$ArcadeToolsDirectory" -Filter "$ToolName-$ToolVersion*" | Sort-Object -Descending)[0]
-            if ([string]::IsNullOrWhiteSpace($ToolDirectory)) {
+            $ToolDirectories = (Get-ChildItem -Path "$ArcadeToolsDirectory" -Filter "$ToolName-$ToolVersion*" | Sort-Object -Descending)
+            if ($ToolDirectories -eq $null) {
               Write-Error "Unable to find directory for $ToolName $ToolVersion; please make sure the tool is installed on this image."
               exit 1
             }
+            $ToolDirectory = $ToolDirectories[0]
             $BinPathFile = "$($ToolDirectory.FullName)\binpath.txt"
             if (-not (Test-Path -Path "$BinPathFile")) {
               Write-Error "Unable to find binpath.txt in '$($ToolDirectory.FullName)' ($ToolName $ToolVersion); artifact is either installed incorrectly or is not a bootstrappable tool."
@@ -124,6 +121,7 @@ try {
 
           if ((Get-Command "$ToolName" -ErrorAction SilentlyContinue) -eq $null) {
             Write-PipelineTelemetryError -Category 'NativeToolsBootstrap' -Message "$ToolName not found on path. Please install $ToolName $ToolVersion before proceeding."
+            Write-PipelineTelemetryError -Category 'NativeToolsBootstrap' -Message "If this is running on a build machine, the arcade-tools directory was not found, which means there's an error with the image."
           }
         }
         exit 0
@@ -202,4 +200,4 @@ catch {
   Write-Host $_.ScriptStackTrace
   Write-PipelineTelemetryError -Category 'NativeToolsBootstrap' -Message $_
   ExitWithExitCode 1
-}
\ No newline at end of file
+}
diff --git a/eng/common/loc/P22DotNetHtmlLocalization.lss b/eng/common/loc/P22DotNetHtmlLocalization.lss
new file mode 100644
index 00000000000..5d892d61939
--- /dev/null
+++ b/eng/common/loc/P22DotNetHtmlLocalization.lss
@@ -0,0 +1,29 @@
+<?xml version="1.0"?>
+<LS_SETTINGS_FILE>
+  <LS_SETTINGS_DESCRIPTION>
+    <![CDATA[]]>
+  </LS_SETTINGS_DESCRIPTION>
+  <optionSet id="LSOptions">
+    <optionSet id="Defaults" displayName="Options Defaults">
+      <optionSet id="Espresso" displayName="Espresso"/>
+      <optionSet id="Parsers" displayName="Parsers"/>
+    </optionSet>
+    <optionSet id="User" displayName="User Overrides">
+      <optionSet id="Espresso" displayName="Espresso"/>
+      <optionSet id="Parsers" displayName="Parsers"/>
+    </optionSet>
+    <optionSet id="Project" displayName="Project Overrides">
+      <optionSet id="Espresso" displayName="Espresso"/>
+      <optionSet id="Parsers" displayName="Parsers">
+        <optionSet id="Parser 22" displayName="POMHTML Parser options" helpText="POMHTML Parser options for Localization Studio.">
+          <option id="SetCharsetInfo" displayName="Set or add Charset information when Generating" helpText="Add Charset information to the Generated file. This is in the format &lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=windows-1252&quot;&gt;. This is based on the Project Target Langauge. If the dir attribute value in the HTML tag i.e. &lt;HTML dir=&quot;ltr&quot;&gt; is not localizable or is missing, its value will be set automatically on Generate if the reading order of the target language is different from the source language.">
+            <boolean defaultValue="1" currentValue="0"/>
+          </option>
+          <option id="IncTermNoResId" displayName="Include Terms which have no Resource Identifier" helpText="Include Terms which have no Resource Identifier. Terms without Resource Identifiers cannot be Updated or Uploaded if they change.">
+            <boolean defaultValue="0" currentValue="1"/>
+          </option>
+        </optionSet>
+      </optionSet>
+    </optionSet>
+  </optionSet>
+</LS_SETTINGS_FILE>
\ No newline at end of file
diff --git a/eng/common/msbuild.ps1 b/eng/common/msbuild.ps1
index eea19cd8452..f041e5ddd95 100644
--- a/eng/common/msbuild.ps1
+++ b/eng/common/msbuild.ps1
@@ -6,6 +6,7 @@ Param(
   [switch] $ci,
   [switch] $prepareMachine,
   [switch] $excludePrereleaseVS,
+  [string] $msbuildEngine = $null,
   [Parameter(ValueFromRemainingArguments=$true)][String[]]$extraArgs
 )
 
diff --git a/eng/common/native/CommonLibrary.psm1 b/eng/common/native/CommonLibrary.psm1
index adf707c8fe7..ca38268c44d 100644
--- a/eng/common/native/CommonLibrary.psm1
+++ b/eng/common/native/CommonLibrary.psm1
@@ -276,7 +276,8 @@ function Get-MachineArchitecture {
   }
   if (($ProcessorArchitecture -Eq "AMD64") -Or
       ($ProcessorArchitecture -Eq "IA64") -Or
-      ($ProcessorArchitecture -Eq "ARM64")) {
+      ($ProcessorArchitecture -Eq "ARM64") -Or
+      ($ProcessorArchitecture -Eq "LOONGARCH64")) {
     return "x64"
   }
   return "x86"
diff --git a/eng/common/native/find-native-compiler.sh b/eng/common/native/find-native-compiler.sh
deleted file mode 100644
index aed19d07d50..00000000000
--- a/eng/common/native/find-native-compiler.sh
+++ /dev/null
@@ -1,121 +0,0 @@
-#!/usr/bin/env bash
-#
-# This file locates the native compiler with the given name and version and sets the environment variables to locate it.
-#
-
-source="${BASH_SOURCE[0]}"
-
-# resolve $SOURCE until the file is no longer a symlink
-while [[ -h $source ]]; do
-  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
-  source="$(readlink "$source")"
-
-  # if $source was a relative symlink, we need to resolve it relative to the path where the
-  # symlink file was located
-  [[ $source != /* ]] && source="$scriptroot/$source"
-done
-scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
-
-if [ $# -lt 0 ]
-then
-  echo "Usage..."
-  echo "find-native-compiler.sh <compiler> <compiler major version> <compiler minor version>"
-  echo "Specify the name of compiler (clang or gcc)."
-  echo "Specify the major version of compiler."
-  echo "Specify the minor version of compiler."
-  exit 1
-fi
-
-. $scriptroot/../pipeline-logging-functions.sh
-
-compiler="$1"
-cxxCompiler="$compiler++"
-majorVersion="$2"
-minorVersion="$3"
-
-if [ "$compiler" = "gcc" ]; then cxxCompiler="g++"; fi
-
-check_version_exists() {
-    desired_version=-1
-
-    # Set up the environment to be used for building with the desired compiler.
-    if command -v "$compiler-$1.$2" > /dev/null; then
-        desired_version="-$1.$2"
-    elif command -v "$compiler$1$2" > /dev/null; then
-        desired_version="$1$2"
-    elif command -v "$compiler-$1$2" > /dev/null; then
-        desired_version="-$1$2"
-    fi
-
-    echo "$desired_version"
-}
-
-if [ -z "$CLR_CC" ]; then
-
-    # Set default versions
-    if [ -z "$majorVersion" ]; then
-        # note: gcc (all versions) and clang versions higher than 6 do not have minor version in file name, if it is zero.
-        if [ "$compiler" = "clang" ]; then versions=( 9 8 7 6.0 5.0 4.0 3.9 3.8 3.7 3.6 3.5 )
-        elif [ "$compiler" = "gcc" ]; then versions=( 9 8 7 6 5 4.9 ); fi
-
-        for version in "${versions[@]}"; do
-            parts=(${version//./ })
-            desired_version="$(check_version_exists "${parts[0]}" "${parts[1]}")"
-            if [ "$desired_version" != "-1" ]; then majorVersion="${parts[0]}"; break; fi
-        done
-
-        if [ -z "$majorVersion" ]; then
-            if command -v "$compiler" > /dev/null; then
-                if [ "$(uname)" != "Darwin" ]; then
-                    Write-PipelineTelemetryError -category "Build" -type "warning" "Specific version of $compiler not found, falling back to use the one in PATH."
-                fi
-                export CC="$(command -v "$compiler")"
-                export CXX="$(command -v "$cxxCompiler")"
-            else
-                Write-PipelineTelemetryError -category "Build" "No usable version of $compiler found."
-                exit 1
-            fi
-        else
-            if [ "$compiler" = "clang" ] && [ "$majorVersion" -lt 5 ]; then
-                if [ "$build_arch" = "arm" ] || [ "$build_arch" = "armel" ]; then
-                    if command -v "$compiler" > /dev/null; then
-                        Write-PipelineTelemetryError -category "Build" -type "warning" "Found clang version $majorVersion which is not supported on arm/armel architectures, falling back to use clang from PATH."
-                        export CC="$(command -v "$compiler")"
-                        export CXX="$(command -v "$cxxCompiler")"
-                    else
-                        Write-PipelineTelemetryError -category "Build" "Found clang version $majorVersion which is not supported on arm/armel architectures, and there is no clang in PATH."
-                        exit 1
-                    fi
-                fi
-            fi
-        fi
-    else
-        desired_version="$(check_version_exists "$majorVersion" "$minorVersion")"
-        if [ "$desired_version" = "-1" ]; then
-            Write-PipelineTelemetryError -category "Build" "Could not find specific version of $compiler: $majorVersion $minorVersion."
-            exit 1
-        fi
-    fi
-
-    if [ -z "$CC" ]; then
-        export CC="$(command -v "$compiler$desired_version")"
-        export CXX="$(command -v "$cxxCompiler$desired_version")"
-        if [ -z "$CXX" ]; then export CXX="$(command -v "$cxxCompiler")"; fi
-    fi
-else
-    if [ ! -f "$CLR_CC" ]; then
-        Write-PipelineTelemetryError -category "Build" "CLR_CC is set but path '$CLR_CC' does not exist"
-        exit 1
-    fi
-    export CC="$CLR_CC"
-    export CXX="$CLR_CXX"
-fi
-
-if [ -z "$CC" ]; then
-   Write-PipelineTelemetryError -category "Build" "Unable to find $compiler."
-    exit 1
-fi
-
-export CCC_CC="$CC"
-export CCC_CXX="$CXX"
-export SCAN_BUILD_COMMAND="$(command -v "scan-build$desired_version")"
diff --git a/eng/common/native/init-compiler.sh b/eng/common/native/init-compiler.sh
new file mode 100644
index 00000000000..f5c1ec7eafe
--- /dev/null
+++ b/eng/common/native/init-compiler.sh
@@ -0,0 +1,137 @@
+#!/bin/sh
+#
+# This file detects the C/C++ compiler and exports it to the CC/CXX environment variables
+#
+# NOTE: some scripts source this file and rely on stdout being empty, make sure to not output anything here!
+
+if [ -z "$build_arch" ] || [ -z "$compiler" ]; then
+  echo "Usage..."
+  echo "build_arch=<ARCH> compiler=<NAME> init-compiler.sh"
+  echo "Specify the target architecture."
+  echo "Specify the name of compiler (clang or gcc)."
+  exit 1
+fi
+
+case "$compiler" in
+    clang*|-clang*|--clang*)
+        # clangx.y or clang-x.y
+        version="$(echo "$compiler" | tr -d '[:alpha:]-=')"
+        majorVersion="${version%%.*}"
+        [ -z "${version##*.*}" ] && minorVersion="${version#*.}"
+
+        if [ -z "$minorVersion" ] && [ -n "$majorVersion" ] && [ "$majorVersion" -le 6 ]; then
+            minorVersion=0;
+        fi
+        compiler=clang
+        ;;
+
+    gcc*|-gcc*|--gcc*)
+        # gccx.y or gcc-x.y
+        version="$(echo "$compiler" | tr -d '[:alpha:]-=')"
+        majorVersion="${version%%.*}"
+        [ -z "${version##*.*}" ] && minorVersion="${version#*.}"
+        compiler=gcc
+        ;;
+esac
+
+cxxCompiler="$compiler++"
+
+# clear the existing CC and CXX from environment
+CC=
+CXX=
+LDFLAGS=
+
+if [ "$compiler" = "gcc" ]; then cxxCompiler="g++"; fi
+
+check_version_exists() {
+    desired_version=-1
+
+    # Set up the environment to be used for building with the desired compiler.
+    if command -v "$compiler-$1.$2" > /dev/null; then
+        desired_version="-$1.$2"
+    elif command -v "$compiler$1$2" > /dev/null; then
+        desired_version="$1$2"
+    elif command -v "$compiler-$1$2" > /dev/null; then
+        desired_version="-$1$2"
+    fi
+
+    echo "$desired_version"
+}
+
+if [ -z "$CLR_CC" ]; then
+
+    # Set default versions
+    if [ -z "$majorVersion" ]; then
+        # note: gcc (all versions) and clang versions higher than 6 do not have minor version in file name, if it is zero.
+        if [ "$compiler" = "clang" ]; then versions="17 16 15 14 13 12 11 10 9 8 7 6.0 5.0 4.0 3.9 3.8 3.7 3.6 3.5"
+        elif [ "$compiler" = "gcc" ]; then versions="13 12 11 10 9 8 7 6 5 4.9"; fi
+
+        for version in $versions; do
+            _major="${version%%.*}"
+            [ -z "${version##*.*}" ] && _minor="${version#*.}"
+            desired_version="$(check_version_exists "$_major" "$_minor")"
+            if [ "$desired_version" != "-1" ]; then majorVersion="$_major"; break; fi
+        done
+
+        if [ -z "$majorVersion" ]; then
+            if command -v "$compiler" > /dev/null; then
+                if [ "$(uname)" != "Darwin" ]; then
+                    echo "Warning: Specific version of $compiler not found, falling back to use the one in PATH."
+                fi
+                CC="$(command -v "$compiler")"
+                CXX="$(command -v "$cxxCompiler")"
+            else
+                echo "No usable version of $compiler found."
+                exit 1
+            fi
+        else
+            if [ "$compiler" = "clang" ] && [ "$majorVersion" -lt 5 ]; then
+                if [ "$build_arch" = "arm" ] || [ "$build_arch" = "armel" ]; then
+                    if command -v "$compiler" > /dev/null; then
+                        echo "Warning: Found clang version $majorVersion which is not supported on arm/armel architectures, falling back to use clang from PATH."
+                        CC="$(command -v "$compiler")"
+                        CXX="$(command -v "$cxxCompiler")"
+                    else
+                        echo "Found clang version $majorVersion which is not supported on arm/armel architectures, and there is no clang in PATH."
+                        exit 1
+                    fi
+                fi
+            fi
+        fi
+    else
+        desired_version="$(check_version_exists "$majorVersion" "$minorVersion")"
+        if [ "$desired_version" = "-1" ]; then
+            echo "Could not find specific version of $compiler: $majorVersion $minorVersion."
+            exit 1
+        fi
+    fi
+
+    if [ -z "$CC" ]; then
+        CC="$(command -v "$compiler$desired_version")"
+        CXX="$(command -v "$cxxCompiler$desired_version")"
+        if [ -z "$CXX" ]; then CXX="$(command -v "$cxxCompiler")"; fi
+    fi
+else
+    if [ ! -f "$CLR_CC" ]; then
+        echo "CLR_CC is set but path '$CLR_CC' does not exist"
+        exit 1
+    fi
+    CC="$CLR_CC"
+    CXX="$CLR_CXX"
+fi
+
+if [ -z "$CC" ]; then
+    echo "Unable to find $compiler."
+    exit 1
+fi
+
+# Only lld version >= 9 can be considered stable. lld doesn't support s390x.
+if [ "$compiler" = "clang" ] && [ -n "$majorVersion" ] && [ "$majorVersion" -ge 9 ] && [ "$build_arch" != "s390x" ]; then
+    if "$CC" -fuse-ld=lld -Wl,--version >/dev/null 2>&1; then
+        LDFLAGS="-fuse-ld=lld"
+    fi
+fi
+
+SCAN_BUILD_COMMAND="$(command -v "scan-build$desired_version")"
+
+export CC CXX LDFLAGS SCAN_BUILD_COMMAND
diff --git a/eng/common/native/init-distro-rid.sh b/eng/common/native/init-distro-rid.sh
new file mode 100644
index 00000000000..de1687b2ccb
--- /dev/null
+++ b/eng/common/native/init-distro-rid.sh
@@ -0,0 +1,130 @@
+#!/usr/bin/env bash
+
+# getNonPortableDistroRid
+#
+# Input:
+#   targetOs: (str)
+#   targetArch: (str)
+#   rootfsDir: (str)
+#
+# Return:
+#   non-portable rid
+getNonPortableDistroRid()
+{
+    local targetOs="$1"
+    local targetArch="$2"
+    local rootfsDir="$3"
+    local nonPortableRid=""
+
+    if [ "$targetOs" = "linux" ]; then
+        if [ -e "${rootfsDir}/etc/os-release" ]; then
+            source "${rootfsDir}/etc/os-release"
+
+            if [[ "${ID}" == "rhel" || "${ID}" == "rocky" || "${ID}" == "alpine" ]]; then
+                # remove the last version digit
+                VERSION_ID="${VERSION_ID%.*}"
+            fi
+
+            if [[ "${VERSION_ID:-}" =~ ^([[:digit:]]|\.)+$ ]]; then
+                nonPortableRid="${ID}.${VERSION_ID}-${targetArch}"
+            else
+                # Rolling release distros either do not set VERSION_ID, set it as blank or
+                # set it to non-version looking string (such as TEMPLATE_VERSION_ID on ArchLinux);
+                # so omit it here to be consistent with everything else.
+                nonPortableRid="${ID}-${targetArch}"
+            fi
+
+        elif [ -e "${rootfsDir}/android_platform" ]; then
+            source "$rootfsDir"/android_platform
+            nonPortableRid="$RID"
+        fi
+    fi
+
+    if [ "$targetOs" = "freebsd" ]; then
+        # $rootfsDir can be empty. freebsd-version is shell script and it should always work.
+        __freebsd_major_version=$($rootfsDir/bin/freebsd-version | { read v; echo "${v%%.*}"; })
+        nonPortableRid="freebsd.$__freebsd_major_version-${targetArch}"
+    elif command -v getprop && getprop ro.product.system.model 2>&1 | grep -qi android; then
+        __android_sdk_version=$(getprop ro.build.version.sdk)
+        nonPortableRid="android.$__android_sdk_version-${targetArch}"
+    elif [ "$targetOs" = "illumos" ]; then
+        __uname_version=$(uname -v)
+        case "$__uname_version" in
+            omnios-*)
+                __omnios_major_version=$(echo "${__uname_version:8:2}")
+                nonPortableRid=omnios."$__omnios_major_version"-"$targetArch"
+            ;;
+            joyent_*)
+                __smartos_major_version=$(echo "${__uname_version:7:4}")
+                nonPortableRid=smartos."$__smartos_major_version"-"$targetArch"
+            ;;
+            illumos_*)
+                nonPortableRid=openindiana-"$targetArch"
+            ;;
+        esac
+    elif [ "$targetOs" = "solaris" ]; then
+        __uname_version=$(uname -v)
+        __solaris_major_version=$(echo "${__uname_version%.*}")
+        nonPortableRid=solaris."$__solaris_major_version"-"$targetArch"
+    elif [ "$targetOs" = "haiku" ]; then
+        __uname_release=$(uname -r)
+        nonPortableRid=haiku.r"$__uname_release"-"$targetArch"
+    fi
+
+    echo "$(echo $nonPortableRid | tr '[:upper:]' '[:lower:]')"
+}
+
+# initDistroRidGlobal
+#
+# Input:
+#   os: (str)
+#   arch: (str)
+#   rootfsDir?: (nullable:string)
+#
+# Return:
+#   None
+#
+# Notes:
+#
+# It is important to note that the function does not return anything, but it
+# exports the following variables on success:
+#
+#   __DistroRid   : Non-portable rid of the target platform.
+#   __PortableTargetOS  : OS-part of the portable rid that corresponds to the target platform.
+#
+initDistroRidGlobal()
+{
+    local targetOs="$1"
+    local targetArch="$2"
+    local rootfsDir=""
+    if [ "$#" -ge 3 ]; then
+        rootfsDir="$3"
+    fi
+
+    if [ -n "${rootfsDir}" ]; then
+        # We may have a cross build. Check for the existence of the rootfsDir
+        if [ ! -e "${rootfsDir}" ]; then
+            echo "Error rootfsDir has been passed, but the location is not valid."
+            exit 1
+        fi
+    fi
+
+    __DistroRid=$(getNonPortableDistroRid "${targetOs}" "${targetArch}" "${rootfsDir}")
+
+    if [ -z "${__PortableTargetOS:-}" ]; then
+        __PortableTargetOS="$targetOs"
+
+        STRINGS="$(command -v strings || true)"
+        if [ -z "$STRINGS" ]; then
+            STRINGS="$(command -v llvm-strings || true)"
+        fi
+
+        # Check for musl-based distros (e.g Alpine Linux, Void Linux).
+        if "${rootfsDir}/usr/bin/ldd" --version 2>&1 | grep -q musl ||
+                ( [ -n "$STRINGS" ] && "$STRINGS" "${rootfsDir}/usr/bin/ldd" 2>&1 | grep -q musl ); then
+            __PortableTargetOS="linux-musl"
+        fi
+    fi
+
+    export __DistroRid __PortableTargetOS
+}
diff --git a/eng/common/native/init-os-and-arch.sh b/eng/common/native/init-os-and-arch.sh
new file mode 100644
index 00000000000..e693617a6c2
--- /dev/null
+++ b/eng/common/native/init-os-and-arch.sh
@@ -0,0 +1,80 @@
+#!/usr/bin/env bash
+
+# Use uname to determine what the OS is.
+OSName=$(uname -s | tr '[:upper:]' '[:lower:]')
+
+if command -v getprop && getprop ro.product.system.model 2>&1 | grep -qi android; then
+    OSName="android"
+fi
+
+case "$OSName" in
+freebsd|linux|netbsd|openbsd|sunos|android|haiku)
+    os="$OSName" ;;
+darwin)
+    os=osx ;;
+*)
+    echo "Unsupported OS $OSName detected!"
+    exit 1 ;;
+esac
+
+# On Solaris, `uname -m` is discouraged, see https://docs.oracle.com/cd/E36784_01/html/E36870/uname-1.html
+# and `uname -p` returns processor type (e.g. i386 on amd64).
+# The appropriate tool to determine CPU is isainfo(1) https://docs.oracle.com/cd/E36784_01/html/E36870/isainfo-1.html.
+if [ "$os" = "sunos" ]; then
+    if uname -o 2>&1 | grep -q illumos; then
+        os="illumos"
+    else
+        os="solaris"
+    fi
+    CPUName=$(isainfo -n)
+else
+    # For the rest of the operating systems, use uname(1) to determine what the CPU is.
+    CPUName=$(uname -m)
+fi
+
+case "$CPUName" in
+    arm64|aarch64)
+        arch=arm64
+        ;;
+
+    loongarch64)
+        arch=loongarch64
+        ;;
+
+    riscv64)
+        arch=riscv64
+        ;;
+
+    amd64|x86_64)
+        arch=x64
+        ;;
+
+    armv7l|armv8l)
+        if (NAME=""; . /etc/os-release; test "$NAME" = "Tizen"); then
+            arch=armel
+        else
+            arch=arm
+        fi
+        ;;
+
+    armv6l)
+        arch=armv6
+        ;;
+
+    i[3-6]86)
+        echo "Unsupported CPU $CPUName detected, build might not succeed!"
+        arch=x86
+        ;;
+
+    s390x)
+        arch=s390x
+        ;;
+
+    ppc64le)
+        arch=ppc64le
+        ;;
+    *)
+        echo "Unknown CPU $CPUName detected!"
+        exit 1
+        ;;
+esac
diff --git a/eng/common/post-build/sourcelink-validation.ps1 b/eng/common/post-build/sourcelink-validation.ps1
index e8ab29afeb3..4011d324e73 100644
--- a/eng/common/post-build/sourcelink-validation.ps1
+++ b/eng/common/post-build/sourcelink-validation.ps1
@@ -22,6 +22,11 @@ $RetryWaitTimeInSeconds = 30
 # Wait time between check for system load
 $SecondsBetweenLoadChecks = 10
 
+if (!$InputPath -or !(Test-Path $InputPath)){
+  Write-Host "No files to validate."
+  ExitWithExitCode 0
+}
+
 $ValidatePackage = {
   param( 
     [string] $PackagePath                                 # Full path to a Symbols.NuGet package
diff --git a/eng/common/post-build/symbols-validation.ps1 b/eng/common/post-build/symbols-validation.ps1
index a5af041ba77..cd2181bafa0 100644
--- a/eng/common/post-build/symbols-validation.ps1
+++ b/eng/common/post-build/symbols-validation.ps1
@@ -4,9 +4,11 @@ param(
   [Parameter(Mandatory = $true)][string] $DotnetSymbolVersion, # Version of dotnet symbol to use
   [Parameter(Mandatory = $false)][switch] $CheckForWindowsPdbs, # If we should check for the existence of windows pdbs in addition to portable PDBs
   [Parameter(Mandatory = $false)][switch] $ContinueOnError, # If we should keep checking symbols after an error
-  [Parameter(Mandatory = $false)][switch] $Clean                  # Clean extracted symbols directory after checking symbols
+  [Parameter(Mandatory = $false)][switch] $Clean,           # Clean extracted symbols directory after checking symbols
+  [Parameter(Mandatory = $false)][string] $SymbolExclusionFile  # Exclude the symbols in the file from publishing to symbol server
 )
 
+. $PSScriptRoot\..\tools.ps1
 # Maximum number of jobs to run in parallel
 $MaxParallelJobs = 16
 
@@ -25,14 +27,28 @@ if ($CheckForWindowsPdbs) {
   $WindowsPdbVerificationParam = "--windows-pdbs"
 }
 
+$ExclusionSet = New-Object System.Collections.Generic.HashSet[string];
+
+if (!$InputPath -or !(Test-Path $InputPath)){
+  Write-Host "No symbols to validate."
+  ExitWithExitCode 0
+}
+
+#Check if the path exists
+if ($SymbolExclusionFile -and (Test-Path $SymbolExclusionFile)){
+  [string[]]$Exclusions = Get-Content "$SymbolExclusionFile"
+  $Exclusions | foreach { if($_ -and $_.Trim()){$ExclusionSet.Add($_)} }
+}
+else{
+  Write-Host "Symbol Exclusion file does not exists. No symbols to exclude."
+}
+
 $CountMissingSymbols = {
   param( 
     [string] $PackagePath, # Path to a NuGet package
     [string] $WindowsPdbVerificationParam # If we should check for the existence of windows pdbs in addition to portable PDBs
   )
 
-  . $using:PSScriptRoot\..\tools.ps1
-
   Add-Type -AssemblyName System.IO.Compression.FileSystem
 
   Write-Host "Validating $PackagePath "
@@ -118,17 +134,17 @@ $CountMissingSymbols = {
         # Save the output and get diagnostic output
         $output = & $dotnetSymbolExe --symbols --modules $WindowsPdbVerificationParam $TargetServerParam $FullPath -o $SymbolsPath --diagnostics | Out-String
 
-        if (Test-Path $PdbPath) {
-          return 'PDB'
+        if ((Test-Path $PdbPath) -and (Test-path $SymbolPath)) {
+          return 'Module and PDB for Module'
         }
-        elseif (Test-Path $NGenPdb) {
-          return 'NGen PDB'
+        elseif ((Test-Path $NGenPdb) -and (Test-Path $PdbPath) -and (Test-Path $SymbolPath)) {
+          return 'Dll, PDB and NGen PDB'
         }
-        elseif (Test-Path $SODbg) {
-          return 'DBG for SO'
+        elseif ((Test-Path $SODbg) -and (Test-Path $SymbolPath)) {
+          return 'So and DBG for SO'
         }  
-        elseif (Test-Path $DylibDwarf) {
-          return 'Dwarf for Dylib'
+        elseif ((Test-Path $DylibDwarf) -and (Test-Path $SymbolPath)) {
+          return 'Dylib and Dwarf for Dylib'
         }  
         elseif (Test-Path $SymbolPath) {
           return 'Module'
@@ -142,37 +158,44 @@ $CountMissingSymbols = {
       return $null
     }
 
-    $FileGuid = New-Guid
-    $ExpandedSymbolsPath = Join-Path -Path $SymbolsPath -ChildPath $FileGuid
-
-    $SymbolsOnMSDL = & $FirstMatchingSymbolDescriptionOrDefault `
-        -FullPath $FileName `
-        -TargetServerParam '--microsoft-symbol-server' `
-        -SymbolsPath "$ExpandedSymbolsPath-msdl" `
-        -WindowsPdbVerificationParam $WindowsPdbVerificationParam
-    $SymbolsOnSymWeb = & $FirstMatchingSymbolDescriptionOrDefault `
-        -FullPath $FileName `
-        -TargetServerParam '--internal-server' `
-        -SymbolsPath "$ExpandedSymbolsPath-symweb" `
-        -WindowsPdbVerificationParam $WindowsPdbVerificationParam
-
-    Write-Host -NoNewLine "`t Checking file " $FileName "... "
-  
-    if ($SymbolsOnMSDL -ne $null -and $SymbolsOnSymWeb -ne $null) {
-      Write-Host "Symbols found on MSDL ($SymbolsOnMSDL) and SymWeb ($SymbolsOnSymWeb)"
+    $FileRelativePath = $FileName.Replace("$ExtractPath\", "")
+    if (($($using:ExclusionSet) -ne $null) -and ($($using:ExclusionSet).Contains($FileRelativePath) -or ($($using:ExclusionSet).Contains($FileRelativePath.Replace("\", "/"))))){
+      Write-Host "Skipping $FileName from symbol validation"
     }
-    else {
-      $MissingSymbols++
 
-      if ($SymbolsOnMSDL -eq $null -and $SymbolsOnSymWeb -eq $null) {
-        Write-Host 'No symbols found on MSDL or SymWeb!'
+    else {
+      $FileGuid = New-Guid
+      $ExpandedSymbolsPath = Join-Path -Path $SymbolsPath -ChildPath $FileGuid
+
+      $SymbolsOnMSDL = & $FirstMatchingSymbolDescriptionOrDefault `
+          -FullPath $FileName `
+          -TargetServerParam '--microsoft-symbol-server' `
+          -SymbolsPath "$ExpandedSymbolsPath-msdl" `
+          -WindowsPdbVerificationParam $WindowsPdbVerificationParam
+      $SymbolsOnSymWeb = & $FirstMatchingSymbolDescriptionOrDefault `
+          -FullPath $FileName `
+          -TargetServerParam '--internal-server' `
+          -SymbolsPath "$ExpandedSymbolsPath-symweb" `
+          -WindowsPdbVerificationParam $WindowsPdbVerificationParam
+
+      Write-Host -NoNewLine "`t Checking file " $FileName "... "
+  
+      if ($SymbolsOnMSDL -ne $null -and $SymbolsOnSymWeb -ne $null) {
+        Write-Host "Symbols found on MSDL ($SymbolsOnMSDL) and SymWeb ($SymbolsOnSymWeb)"
       }
       else {
-        if ($SymbolsOnMSDL -eq $null) {
-          Write-Host 'No symbols found on MSDL!'
+        $MissingSymbols++
+
+        if ($SymbolsOnMSDL -eq $null -and $SymbolsOnSymWeb -eq $null) {
+          Write-Host 'No symbols found on MSDL or SymWeb!'
         }
         else {
-          Write-Host 'No symbols found on SymWeb!'
+          if ($SymbolsOnMSDL -eq $null) {
+            Write-Host 'No symbols found on MSDL!'
+          }
+          else {
+            Write-Host 'No symbols found on SymWeb!'
+          }
         }
       }
     }
diff --git a/eng/common/sdk-task.ps1 b/eng/common/sdk-task.ps1
index b1bca63ab1d..6c4ac6fec1a 100644
--- a/eng/common/sdk-task.ps1
+++ b/eng/common/sdk-task.ps1
@@ -64,7 +64,7 @@ try {
       $GlobalJson.tools | Add-Member -Name "vs" -Value (ConvertFrom-Json "{ `"version`": `"16.5`" }") -MemberType NoteProperty
     }
     if( -not ($GlobalJson.tools.PSObject.Properties.Name -match "xcopy-msbuild" )) {
-      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "16.10.0-preview2" -MemberType NoteProperty
+      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "17.6.0-2" -MemberType NoteProperty
     }
     if ($GlobalJson.tools."xcopy-msbuild".Trim() -ine "none") {
         $xcopyMSBuildToolsFolder = InitializeXCopyMSBuild $GlobalJson.tools."xcopy-msbuild" -install $true
diff --git a/eng/common/sdl/NuGet.config b/eng/common/sdl/NuGet.config
index 0c5451c1141..3849bdb3cf5 100644
--- a/eng/common/sdl/NuGet.config
+++ b/eng/common/sdl/NuGet.config
@@ -7,6 +7,11 @@
     <clear />
     <add key="guardian" value="https://securitytools.pkgs.visualstudio.com/_packaging/Guardian/nuget/v3/index.json" />
   </packageSources>
+  <packageSourceMapping>
+    <packageSource key="guardian">
+      <package pattern="microsoft.guardian.cli" />
+    </packageSource>
+  </packageSourceMapping>
   <disabledPackageSources>
     <clear />
   </disabledPackageSources>
diff --git a/eng/common/sdl/configure-sdl-tool.ps1 b/eng/common/sdl/configure-sdl-tool.ps1
index adea8e8da2a..27f5a4115fc 100644
--- a/eng/common/sdl/configure-sdl-tool.ps1
+++ b/eng/common/sdl/configure-sdl-tool.ps1
@@ -17,7 +17,9 @@ Param(
   # Optional: Additional params to add to any tool using PoliCheck.
   [string[]] $PoliCheckAdditionalRunConfigParams,
   # Optional: Additional params to add to any tool using CodeQL/Semmle.
-  [string[]] $CodeQLAdditionalRunConfigParams
+  [string[]] $CodeQLAdditionalRunConfigParams,
+  # Optional: Additional params to add to any tool using Binskim.
+  [string[]] $BinskimAdditionalRunConfigParams
 )
 
 $ErrorActionPreference = 'Stop'
@@ -69,22 +71,34 @@ try {
     $gdnConfigFile = Join-Path $gdnConfigPath "$toolConfigName-configure.gdnconfig"
 
     # For some tools, add default and automatic args.
-    if ($tool.Name -eq 'credscan') {
-      if ($targetDirectory) {
-        $tool.Args += "TargetDirectory < $TargetDirectory"
+    switch -Exact ($tool.Name) {
+      'credscan' {
+        if ($targetDirectory) {
+          $tool.Args += "`"TargetDirectory < $TargetDirectory`""
+        }
+        $tool.Args += "`"OutputType < pre`""
+        $tool.Args += $CrScanAdditionalRunConfigParams
       }
-      $tool.Args += "OutputType < pre"
-      $tool.Args += $CrScanAdditionalRunConfigParams
-    } elseif ($tool.Name -eq 'policheck') {
-      if ($targetDirectory) {
-        $tool.Args += "Target < $TargetDirectory"
+      'policheck' {
+        if ($targetDirectory) {
+          $tool.Args += "`"Target < $TargetDirectory`""
+        }
+        $tool.Args += $PoliCheckAdditionalRunConfigParams
       }
-      $tool.Args += $PoliCheckAdditionalRunConfigParams
-    } elseif ($tool.Name -eq 'semmle' -or $tool.Name -eq 'codeql') {
-      if ($targetDirectory) {
-        $tool.Args += "`"SourceCodeDirectory < $TargetDirectory`""
+      {$_ -in 'semmle', 'codeql'} {
+        if ($targetDirectory) {
+          $tool.Args += "`"SourceCodeDirectory < $TargetDirectory`""
+        }
+        $tool.Args += $CodeQLAdditionalRunConfigParams
+      }
+      'binskim' {
+        if ($targetDirectory) {
+          # Binskim crashes due to specific PDBs. GitHub issue: https://github.com/microsoft/binskim/issues/924.
+          # We are excluding all `_.pdb` files from the scan.
+          $tool.Args += "`"Target < $TargetDirectory\**;-:file|$TargetDirectory\**\_.pdb`""
+        }
+        $tool.Args += $BinskimAdditionalRunConfigParams
       }
-      $tool.Args += $CodeQLAdditionalRunConfigParams
     }
 
     # Create variable pointing to the args array directly so we can use splat syntax later.
diff --git a/eng/common/sdl/execute-all-sdl-tools.ps1 b/eng/common/sdl/execute-all-sdl-tools.ps1
index b9fe7317964..4715d75e974 100644
--- a/eng/common/sdl/execute-all-sdl-tools.ps1
+++ b/eng/common/sdl/execute-all-sdl-tools.ps1
@@ -35,6 +35,7 @@ Param(
   [string[]] $CrScanAdditionalRunConfigParams,                                                   # Optional: Additional Params to custom build a CredScan run config in the format @("xyz:abc","sdf:1")
   [string[]] $PoliCheckAdditionalRunConfigParams,                                                # Optional: Additional Params to custom build a Policheck run config in the format @("xyz:abc","sdf:1")
   [string[]] $CodeQLAdditionalRunConfigParams,                                                   # Optional: Additional Params to custom build a Semmle/CodeQL run config in the format @("xyz < abc","sdf < 1")
+  [string[]] $BinskimAdditionalRunConfigParams,                                                  # Optional: Additional Params to custom build a Binskim run config in the format @("xyz < abc","sdf < 1")
   [bool] $BreakOnFailure=$False                                                                  # Optional: Fail the build if there were errors during the run
 )
 
@@ -107,7 +108,8 @@ try {
           -GuardianLoggerLevel $GuardianLoggerLevel `
           -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams `
           -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams `
-          -CodeQLAdditionalRunConfigParams $CodeQLAdditionalRunConfigParams
+          -CodeQLAdditionalRunConfigParams $CodeQLAdditionalRunConfigParams `
+          -BinskimAdditionalRunConfigParams $BinskimAdditionalRunConfigParams
         if ($BreakOnFailure) {
           Exit-IfNZEC "Sdl"
         }
@@ -126,7 +128,7 @@ try {
   Exec-BlockVerbosely {
     & $(Join-Path $PSScriptRoot 'run-sdl.ps1') `
       -GuardianCliLocation $guardianCliLocation `
-      -WorkingDirectory $workingDirectory `
+      -WorkingDirectory $SourceDirectory `
       -UpdateBaseline $UpdateBaseline `
       -GdnFolder $gdnFolder
   }
diff --git a/eng/common/sdl/extract-artifact-packages.ps1 b/eng/common/sdl/extract-artifact-packages.ps1
index 7f28d9c59ec..f031ed5b25e 100644
--- a/eng/common/sdl/extract-artifact-packages.ps1
+++ b/eng/common/sdl/extract-artifact-packages.ps1
@@ -35,31 +35,33 @@ try {
     param( 
       [string] $PackagePath                                 # Full path to a NuGet package
     )
-    
+
     if (!(Test-Path $PackagePath)) {
       Write-PipelineTelemetryError -Category 'Build' -Message "Input file does not exist: $PackagePath"
       ExitWithExitCode 1
     }
-    
+
     $RelevantExtensions = @('.dll', '.exe', '.pdb')
     Write-Host -NoNewLine 'Extracting ' ([System.IO.Path]::GetFileName($PackagePath)) '...'
-  
+
     $PackageId = [System.IO.Path]::GetFileNameWithoutExtension($PackagePath)
     $ExtractPath = Join-Path -Path $using:ExtractPath -ChildPath $PackageId
-  
+
     Add-Type -AssemblyName System.IO.Compression.FileSystem
-  
+
     [System.IO.Directory]::CreateDirectory($ExtractPath);
-  
+
     try {
       $zip = [System.IO.Compression.ZipFile]::OpenRead($PackagePath)
   
       $zip.Entries | 
       Where-Object {$RelevantExtensions -contains [System.IO.Path]::GetExtension($_.Name)} |
         ForEach-Object {
-            $TargetFile = Join-Path -Path $ExtractPath -ChildPath $_.Name
-  
-            [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, $TargetFile, $true)
+            $TargetPath = Join-Path -Path $ExtractPath -ChildPath (Split-Path -Path $_.FullName)
+            [System.IO.Directory]::CreateDirectory($TargetPath);
+
+            $TargetFile = Join-Path -Path $ExtractPath -ChildPath $_.FullName
+            [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, $TargetFile)
           }
     }
     catch {
diff --git a/eng/common/sdl/packages.config b/eng/common/sdl/packages.config
index b7bcfe38caf..4585cfd6bba 100644
--- a/eng/common/sdl/packages.config
+++ b/eng/common/sdl/packages.config
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
 <packages>
-  <package id="Microsoft.Guardian.Cli" version="0.110.1"/>
+  <package id="Microsoft.Guardian.Cli" version="0.109.0"/>
 </packages>
diff --git a/eng/common/sdl/trim-assets-version.ps1 b/eng/common/sdl/trim-assets-version.ps1
new file mode 100644
index 00000000000..a2e00487704
--- /dev/null
+++ b/eng/common/sdl/trim-assets-version.ps1
@@ -0,0 +1,75 @@
+<#
+.SYNOPSIS
+Install and run the 'Microsoft.DotNet.VersionTools.Cli' tool with the 'trim-artifacts-version' command to trim the version from the NuGet assets file name.
+
+.PARAMETER InputPath
+Full path to directory where artifact packages are stored
+
+.PARAMETER Recursive
+Search for NuGet packages recursively
+
+#>
+
+Param(
+  [string] $InputPath,
+  [bool] $Recursive = $true
+)
+
+$CliToolName = "Microsoft.DotNet.VersionTools.Cli"
+
+function Install-VersionTools-Cli {
+  param(
+      [Parameter(Mandatory=$true)][string]$Version
+  )
+
+  Write-Host "Installing the package '$CliToolName' with a version of '$version' ..."
+  $feed = "https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json"
+
+  $argumentList = @("tool", "install", "--local", "$CliToolName", "--add-source $feed", "--no-cache", "--version $Version", "--create-manifest-if-needed")
+  Start-Process "$dotnet" -Verbose -ArgumentList $argumentList -NoNewWindow -Wait
+}
+
+# -------------------------------------------------------------------
+
+if (!(Test-Path $InputPath)) {
+  Write-Host "Input Path '$InputPath' does not exist"
+  ExitWithExitCode 1
+}
+
+$ErrorActionPreference = 'Stop'
+Set-StrictMode -Version 2.0
+
+$disableConfigureToolsetImport = $true
+$global:LASTEXITCODE = 0
+
+# `tools.ps1` checks $ci to perform some actions. Since the SDL
+# scripts don't necessarily execute in the same agent that run the
+# build.ps1/sh script this variable isn't automatically set.
+$ci = $true
+. $PSScriptRoot\..\tools.ps1
+
+try {
+  $dotnetRoot = InitializeDotNetCli -install:$true
+  $dotnet = "$dotnetRoot\dotnet.exe"
+
+  $toolsetVersion = Read-ArcadeSdkVersion
+  Install-VersionTools-Cli -Version $toolsetVersion
+
+  $cliToolFound = (& "$dotnet" tool list --local | Where-Object {$_.Split(' ')[0] -eq $CliToolName})
+  if ($null -eq $cliToolFound) {
+    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "The '$CliToolName' tool is not installed."
+    ExitWithExitCode 1
+  }
+
+  Exec-BlockVerbosely {
+    & "$dotnet" $CliToolName trim-assets-version `
+      --assets-path $InputPath `
+      --recursive $Recursive
+    Exit-IfNZEC "Sdl"
+  }
+}
+catch {
+  Write-Host $_
+  Write-PipelineTelemetryError -Force -Category 'Sdl' -Message $_
+  ExitWithExitCode 1
+}
\ No newline at end of file
diff --git a/eng/common/templates/job/execute-sdl.yml b/eng/common/templates/job/execute-sdl.yml
index aaeb83b4dcb..7870f93bc17 100644
--- a/eng/common/templates/job/execute-sdl.yml
+++ b/eng/common/templates/job/execute-sdl.yml
@@ -34,7 +34,7 @@ jobs:
 - job: Run_SDL
   dependsOn: ${{ parameters.dependsOn }}
   displayName: Run SDL tool
-  condition: eq( ${{ parameters.enable }}, 'true')
+  condition: and(succeededOrFailed(), eq( ${{ parameters.enable }}, 'true'))
   variables:
     - group: DotNet-VSTS-Bot
     - name: AzDOProjectName
@@ -46,6 +46,7 @@ jobs:
     - template: /eng/common/templates/variables/sdl-variables.yml
     - name: GuardianVersion
       value: ${{ coalesce(parameters.overrideGuardianVersion, '$(DefaultGuardianVersion)') }}
+    - template: /eng/common/templates/variables/pool-providers.yml
   pool:
     # We don't use the collection uri here because it might vary (.visualstudio.com vs. dev.azure.com)
     ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
@@ -53,13 +54,15 @@ jobs:
       demands: Cmd
     # If it's not devdiv, it's dnceng
     ${{ if ne(variables['System.TeamProject'], 'DevDiv') }}:
-      name: NetCore1ESPool-Svc-Internal
+      name: $(DncEngInternalBuildPool)
       demands: ImageOverride -equals windows.vs2019.amd64
   steps:
   - checkout: self
     clean: true
 
-  - template: /eng/common/templates/post-build/setup-maestro-vars.yml
+  # If the template caller didn't provide an AzDO parameter, set them all up as Maestro vars.
+  - ${{ if not(and(parameters.AzDOProjectName, parameters.AzDOPipelineId, parameters.AzDOBuildId)) }}:
+    - template: /eng/common/templates/post-build/setup-maestro-vars.yml
 
   - ${{ if ne(parameters.downloadArtifacts, 'false')}}:
     - ${{ if ne(parameters.artifactNames, '') }}:
@@ -102,6 +105,11 @@ jobs:
         downloadPath: $(Build.ArtifactStagingDirectory)\artifacts
         checkDownloadedFiles: true
 
+  - powershell: eng/common/sdl/trim-assets-version.ps1
+      -InputPath $(Build.ArtifactStagingDirectory)\artifacts
+    displayName: Trim the version from the NuGet packages
+    continueOnError: ${{ parameters.sdlContinueOnError }}
+
   - powershell: eng/common/sdl/extract-artifact-packages.ps1
       -InputPath $(Build.ArtifactStagingDirectory)\artifacts\BlobArtifacts
       -ExtractPath $(Build.ArtifactStagingDirectory)\artifacts\BlobArtifacts
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index 01da2420df6..037688b0d30 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -24,7 +24,9 @@ parameters:
   enablePublishBuildAssets: false
   enablePublishTestResults: false
   enablePublishUsingPipelines: false
+  enableBuildRetry: false
   disableComponentGovernance: ''
+  componentGovernanceIgnoreDirectories: ''
   mergeTestResults: false
   testRunTitle: ''
   testResultsFormat: ''
@@ -33,7 +35,7 @@ parameters:
   runAsPublic: false
 # Sbom related params
   enableSbom: true
-  PackageVersion: 6.0.0
+  PackageVersion: 7.0.0
   BuildDropPath: '$(Build.SourcesDirectory)/artifacts'
 
 jobs:
@@ -90,10 +92,20 @@ jobs:
     - ${{ if ne(variable.group, '') }}:
       - group: ${{ variable.group }}
 
+    # handle template variable syntax
+    # example:
+    # - template: path/to/template.yml
+    #   parameters:
+    #     [key]: [value]
+    - ${{ if ne(variable.template, '') }}:
+      - template: ${{ variable.template }}
+        ${{ if ne(variable.parameters, '') }}:
+          parameters: ${{ variable.parameters }}
+
     # handle key-value variable syntax.
     # example:
     # - [key]: [value]
-    - ${{ if and(eq(variable.name, ''), eq(variable.group, '')) }}:
+    - ${{ if and(eq(variable.name, ''), eq(variable.group, ''), eq(variable.template, '')) }}:
       - ${{ each pair in variable }}:
         - name: ${{ pair.key }}
           value: ${{ pair.value }}
@@ -125,7 +137,7 @@ jobs:
 
     - task: NuGetAuthenticate@1
 
-  - ${{ if or(eq(parameters.artifacts.download, 'true'), ne(parameters.artifacts.download, '')) }}:
+  - ${{ if and(ne(parameters.artifacts.download, 'false'), ne(parameters.artifacts.download, '')) }}:
     - task: DownloadPipelineArtifact@2
       inputs:
         buildType: current
@@ -143,6 +155,7 @@ jobs:
         languages: ${{ coalesce(parameters.richCodeNavigationLanguage, 'csharp') }}
         environment: ${{ coalesce(parameters.richCodeNavigationEnvironment, 'production') }}
         richNavLogOutputDirectory: $(Build.SourcesDirectory)/artifacts/bin
+        uploadRichNavArtifacts: ${{ coalesce(parameters.richCodeNavigationUploadArtifacts, false) }}
       continueOnError: true
 
   - template: /eng/common/templates/steps/component-governance.yml
@@ -154,6 +167,7 @@ jobs:
           disableComponentGovernance: true
       ${{ else }}:
         disableComponentGovernance: ${{ parameters.disableComponentGovernance }}
+      componentGovernanceIgnoreDirectories: ${{ parameters.componentGovernanceIgnoreDirectories }}
 
   - ${{ if eq(parameters.enableMicrobuild, 'true') }}:
     - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
@@ -165,7 +179,7 @@ jobs:
           TeamName: $(_TeamName)
 
   - ${{ if ne(parameters.artifacts.publish, '') }}:
-    - ${{ if or(eq(parameters.artifacts.publish.artifacts, 'true'), ne(parameters.artifacts.publish.artifacts, '')) }}:
+    - ${{ if and(ne(parameters.artifacts.publish.artifacts, 'false'), ne(parameters.artifacts.publish.artifacts, '')) }}:
       - task: CopyFiles@2
         displayName: Gather binaries for publish to artifacts
         inputs:
@@ -186,30 +200,12 @@ jobs:
           ArtifactName: ${{ coalesce(parameters.artifacts.publish.artifacts.name , 'Artifacts_$(Agent.Os)_$(_BuildConfig)') }}
         continueOnError: true
         condition: always()
-    - ${{ if or(eq(parameters.artifacts.publish.logs, 'true'), ne(parameters.artifacts.publish.logs, '')) }}:
+    - ${{ if and(ne(parameters.artifacts.publish.logs, 'false'), ne(parameters.artifacts.publish.logs, '')) }}:
       - publish: artifacts/log
         artifact: ${{ coalesce(parameters.artifacts.publish.logs.name, 'Logs_Build_$(Agent.Os)_$(_BuildConfig)') }}
         displayName: Publish logs
         continueOnError: true
         condition: always()
-    - ${{ if or(eq(parameters.artifacts.publish.manifests, 'true'), ne(parameters.artifacts.publish.manifests, '')) }}:
-      - ${{ if and(ne(parameters.enablePublishUsingPipelines, 'true'), eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:    
-        - task: CopyFiles@2
-          displayName: Gather Asset Manifests
-          inputs:
-            SourceFolder: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)/AssetManifest'
-            TargetFolder: '$(Build.ArtifactStagingDirectory)/AssetManifests'
-          continueOnError: ${{ parameters.continueOnError }}
-          condition: and(succeeded(), eq(variables['_DotNetPublishToBlobFeed'], 'true'))
-
-        - task: PublishBuildArtifacts@1
-          displayName: Push Asset Manifests
-          inputs:
-            PathtoPublish: '$(Build.ArtifactStagingDirectory)/AssetManifests'
-            PublishLocation: Container
-            ArtifactName: AssetManifests
-          continueOnError: ${{ parameters.continueOnError }}
-          condition: and(succeeded(), eq(variables['_DotNetPublishToBlobFeed'], 'true'))
 
   - ${{ if ne(parameters.enablePublishBuildArtifacts, 'false') }}:
     - task: PublishBuildArtifacts@1
@@ -243,27 +239,16 @@ jobs:
         mergeTestResults: ${{ parameters.mergeTestResults }}
       continueOnError: true
       condition: always()
-    
-  - ${{ if and(eq(parameters.enablePublishBuildAssets, true), ne(parameters.enablePublishUsingPipelines, 'true'), eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-    - task: CopyFiles@2
-      displayName: Gather Asset Manifests
-      inputs:
-        SourceFolder: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)/AssetManifest'
-        TargetFolder: '$(Build.StagingDirectory)/AssetManifests'
-      continueOnError: ${{ parameters.continueOnError }}
-      condition: and(succeeded(), eq(variables['_DotNetPublishToBlobFeed'], 'true'))
-
-    - task: PublishBuildArtifacts@1
-      displayName: Push Asset Manifests
-      inputs:
-        PathtoPublish: '$(Build.StagingDirectory)/AssetManifests'
-        PublishLocation: Container
-        ArtifactName: AssetManifests
-      continueOnError: ${{ parameters.continueOnError }}
-      condition: and(succeeded(), eq(variables['_DotNetPublishToBlobFeed'], 'true'))
 
   - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), eq(parameters.enableSbom, 'true')) }}:
     - template: /eng/common/templates/steps/generate-sbom.yml
       parameters:
         PackageVersion: ${{ parameters.packageVersion}}
         BuildDropPath: ${{ parameters.buildDropPath }}
+        IgnoreDirectories: ${{ parameters.componentGovernanceIgnoreDirectories }}
+
+  - ${{ if eq(parameters.enableBuildRetry, 'true') }}:
+    - publish: $(Build.SourcesDirectory)\eng\common\BuildConfiguration
+      artifact: BuildConfiguration
+      displayName: Publish build retry configuration
+      continueOnError: true
diff --git a/eng/common/templates/job/onelocbuild.yml b/eng/common/templates/job/onelocbuild.yml
index 5b1b77d1c74..60ab00c4de3 100644
--- a/eng/common/templates/job/onelocbuild.yml
+++ b/eng/common/templates/job/onelocbuild.yml
@@ -14,6 +14,7 @@ parameters:
   ReusePr: true
   UseLfLineEndings: true
   UseCheckedInLocProjectJson: false
+  SkipLocProjectJsonGeneration: false
   LanguageSet: VS_Main_Languages
   LclSource: lclFilesInRepo
   LclPackageId: ''
@@ -22,13 +23,25 @@ parameters:
   MirrorRepo: ''
   MirrorBranch: main
   condition: ''
+  JobNameSuffix: ''
 
 jobs:
-- job: OneLocBuild
+- job: OneLocBuild${{ parameters.JobNameSuffix }}
   
   dependsOn: ${{ parameters.dependsOn }}
 
-  displayName: OneLocBuild
+  displayName: OneLocBuild${{ parameters.JobNameSuffix }}
+
+  variables:
+    - group: OneLocBuildVariables # Contains the CeapexPat and GithubPat
+    - name: _GenerateLocProjectArguments
+      value: -SourcesDirectory ${{ parameters.SourcesDirectory }}
+        -LanguageSet "${{ parameters.LanguageSet }}"
+        -CreateNeutralXlfs
+    - ${{ if eq(parameters.UseCheckedInLocProjectJson, 'true') }}:
+      - name: _GenerateLocProjectArguments
+        value: ${{ variables._GenerateLocProjectArguments }} -UseCheckedInLocProjectJson
+    - template: /eng/common/templates/variables/pool-providers.yml
 
   ${{ if ne(parameters.pool, '') }}:
     pool: ${{ parameters.pool }}
@@ -40,27 +53,17 @@ jobs:
         demands: Cmd
       # If it's not devdiv, it's dnceng
       ${{ if ne(variables['System.TeamProject'], 'DevDiv') }}:
-        name: NetCore1ESPool-Svc-Internal
+        name: $(DncEngInternalBuildPool)
         demands: ImageOverride -equals windows.vs2019.amd64
 
-  variables:
-    - group: OneLocBuildVariables # Contains the CeapexPat and GithubPat
-    - name: _GenerateLocProjectArguments
-      value: -SourcesDirectory ${{ parameters.SourcesDirectory }}
-        -LanguageSet "${{ parameters.LanguageSet }}"
-        -CreateNeutralXlfs
-    - ${{ if eq(parameters.UseCheckedInLocProjectJson, 'true') }}:
-      - name: _GenerateLocProjectArguments
-        value: ${{ variables._GenerateLocProjectArguments }} -UseCheckedInLocProjectJson
-      
-
   steps:
-    - task: Powershell@2
-      inputs:
-        filePath: $(Build.SourcesDirectory)/eng/common/generate-locproject.ps1
-        arguments: $(_GenerateLocProjectArguments)
-      displayName: Generate LocProject.json
-      condition: ${{ parameters.condition }}
+    - ${{ if ne(parameters.SkipLocProjectJsonGeneration, 'true') }}:
+      - task: Powershell@2
+        inputs:
+          filePath: $(Build.SourcesDirectory)/eng/common/generate-locproject.ps1
+          arguments: $(_GenerateLocProjectArguments)
+        displayName: Generate LocProject.json
+        condition: ${{ parameters.condition }}
 
     - task: OneLocBuild@2
       displayName: OneLocBuild
@@ -72,8 +75,8 @@ jobs:
         lclSource: ${{ parameters.LclSource }}
         lclPackageId: ${{ parameters.LclPackageId }}
         isCreatePrSelected: ${{ parameters.CreatePr }}
+        isAutoCompletePrSelected: ${{ parameters.AutoCompletePr }}
         ${{ if eq(parameters.CreatePr, true) }}:
-          isAutoCompletePrSelected: ${{ parameters.AutoCompletePr }}
           isUseLfLineEndingsSelected: ${{ parameters.UseLfLineEndings }}
           ${{ if eq(parameters.RepoType, 'gitHub') }}:
             isShouldReusePrSelected: ${{ parameters.ReusePr }}
diff --git a/eng/common/templates/job/publish-build-assets.yml b/eng/common/templates/job/publish-build-assets.yml
index bd3d54b760c..cafa678affd 100644
--- a/eng/common/templates/job/publish-build-assets.yml
+++ b/eng/common/templates/job/publish-build-assets.yml
@@ -23,23 +23,43 @@ parameters:
   # Optional: whether the build's artifacts will be published using release pipelines or direct feed publishing
   publishUsingPipelines: false
 
+  # Optional: whether the build's artifacts will be published using release pipelines or direct feed publishing
+  publishAssetsImmediately: false
+
+  artifactsPublishingAdditionalParameters: ''
+
+  signingValidationAdditionalParameters: ''
+
 jobs:
 - job: Asset_Registry_Publish
 
   dependsOn: ${{ parameters.dependsOn }}
+  timeoutInMinutes: 150
 
-  displayName: Publish to Build Asset Registry
-
-  pool: ${{ parameters.pool }}
+  ${{ if eq(parameters.publishAssetsImmediately, 'true') }}:
+    displayName: Publish Assets
+  ${{ else }}:
+    displayName: Publish to Build Asset Registry
 
   variables:
+  - template: /eng/common/templates/variables/pool-providers.yml
   - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-    - name: _BuildConfig
-      value: ${{ parameters.configuration }}
     - group: Publish-Build-Assets
     - group: AzureDevOps-Artifact-Feeds-Pats
     - name: runCodesignValidationInjection
       value: false
+    - ${{ if eq(parameters.publishAssetsImmediately, 'true') }}:
+      - template: /eng/common/templates/post-build/common-variables.yml
+
+  pool:
+    # We don't use the collection uri here because it might vary (.visualstudio.com vs. dev.azure.com)
+    ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
+      name: VSEngSS-MicroBuild2022-1ES
+      demands: Cmd
+    # If it's not devdiv, it's dnceng
+    ${{ if ne(variables['System.TeamProject'], 'DevDiv') }}:
+      name: $(DncEngInternalBuildPool)
+      demands: ImageOverride -equals windows.vs2019.amd64
 
   steps:
   - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
@@ -70,7 +90,6 @@ jobs:
           /p:BuildAssetRegistryToken=$(MaestroAccessToken)
           /p:MaestroApiEndpoint=https://maestro.dot.net
           /p:PublishUsingPipelines=${{ parameters.publishUsingPipelines }}
-          /p:Configuration=$(_BuildConfig)
           /p:OfficialBuildId=$(Build.BuildNumber)
       condition: ${{ parameters.condition }}
       continueOnError: ${{ parameters.continueOnError }}
@@ -114,7 +133,25 @@ jobs:
         PathtoPublish: '$(Build.SourcesDirectory)/eng/SymbolPublishingExclusionsFile.txt'
         PublishLocation: Container
         ArtifactName: ReleaseConfigs
-        
+
+    - ${{ if eq(parameters.publishAssetsImmediately, 'true') }}:
+      - template: /eng/common/templates/post-build/setup-maestro-vars.yml
+        parameters:
+          BARBuildId: ${{ parameters.BARBuildId }}
+          PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
+
+      - task: PowerShell@2
+        displayName: Publish Using Darc
+        inputs:
+          filePath: $(Build.SourcesDirectory)/eng/common/post-build/publish-using-darc.ps1
+          arguments: -BuildId $(BARBuildId) 
+            -PublishingInfraVersion 3
+            -AzdoToken '$(publishing-dnceng-devdiv-code-r-build-re)'
+            -MaestroToken '$(MaestroApiAccessToken)'
+            -WaitPublishingFinish true
+            -ArtifactsPublishingAdditionalParameters '${{ parameters.artifactsPublishingAdditionalParameters }}'
+            -SymbolPublishingAdditionalParameters '${{ parameters.symbolPublishingAdditionalParameters }}'
+
     - ${{ if eq(parameters.enablePublishBuildArtifacts, 'true') }}:
       - template: /eng/common/templates/steps/publish-logs.yml
         parameters:
diff --git a/eng/common/templates/job/source-build.yml b/eng/common/templates/job/source-build.yml
index b6137f44ada..8a3deef2b72 100644
--- a/eng/common/templates/job/source-build.yml
+++ b/eng/common/templates/job/source-build.yml
@@ -44,13 +44,16 @@ jobs:
   ${{ if eq(parameters.platform.pool, '') }}:
     # The default VM host AzDO pool. This should be capable of running Docker containers: almost all
     # source-build builds run in Docker, including the default managed platform.
+    # /eng/common/templates/variables/pool-providers.yml can't be used here (some customers declare variables already), so duplicate its logic
     pool:
       ${{ if eq(variables['System.TeamProject'], 'public') }}:
-        name: NetCore-Svc-Public
+        name: $[replace(replace(eq(contains(coalesce(variables['System.PullRequest.TargetBranch'], variables['Build.SourceBranch'], 'refs/heads/main'), 'release'), 'true'), True, 'NetCore-Svc-Public' ), False, 'NetCore-Public')]
         demands: ImageOverride -equals Build.Ubuntu.1804.Amd64.Open
+
       ${{ if eq(variables['System.TeamProject'], 'internal') }}:
-        name: NetCore1ESPool-Svc-Internal
+        name: $[replace(replace(eq(contains(coalesce(variables['System.PullRequest.TargetBranch'], variables['Build.SourceBranch'], 'refs/heads/main'), 'release'), 'true'), True, 'NetCore1ESPool-Svc-Internal'), False, 'NetCore1ESPool-Internal')]
         demands: ImageOverride -equals Build.Ubuntu.1804.Amd64
+
   ${{ if ne(parameters.platform.pool, '') }}:
     pool: ${{ parameters.platform.pool }}
 
diff --git a/eng/common/templates/job/source-index-stage1.yml b/eng/common/templates/job/source-index-stage1.yml
index b710698eb4d..7c068fea19f 100644
--- a/eng/common/templates/job/source-index-stage1.yml
+++ b/eng/common/templates/job/source-index-stage1.yml
@@ -5,10 +5,9 @@ parameters:
   sourceIndexBuildCommand: powershell -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "eng/common/build.ps1 -restore -build -binarylog -ci"
   preSteps: []
   binlogPath: artifacts/log/Debug/Build.binlog
-  pool:
-    vmImage: windows-2019
   condition: ''
   dependsOn: ''
+  pool: ''
 
 jobs:
 - job: SourceIndexStage1
@@ -23,8 +22,19 @@ jobs:
     value: ${{ parameters.binlogPath }}
   - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
     - group: source-dot-net stage1 variables
+  - template: /eng/common/templates/variables/pool-providers.yml
+
+  ${{ if ne(parameters.pool, '') }}:
+    pool: ${{ parameters.pool }}
+  ${{ if eq(parameters.pool, '') }}:
+    pool:
+      ${{ if eq(variables['System.TeamProject'], 'public') }}:
+        name: $(DncEngPublicBuildPool)
+        demands: ImageOverride -equals windows.vs2019.amd64.open
+      ${{ if eq(variables['System.TeamProject'], 'internal') }}:
+        name: $(DncEngInternalBuildPool)
+        demands: ImageOverride -equals windows.vs2019.amd64
 
-  pool: ${{ parameters.pool }}
   steps:
   - ${{ each preStep in parameters.preSteps }}:
     - ${{ preStep }}
diff --git a/eng/common/templates/jobs/codeql-build.yml b/eng/common/templates/jobs/codeql-build.yml
index 54c393af440..f7dc5ea4aaa 100644
--- a/eng/common/templates/jobs/codeql-build.yml
+++ b/eng/common/templates/jobs/codeql-build.yml
@@ -21,7 +21,7 @@ jobs:
       # The Guardian version specified in 'eng/common/sdl/packages.config'. This value must be kept in
       # sync with the packages.config file.
       - name: DefaultGuardianVersion
-        value: 0.110.1
+        value: 0.109.0
       - name: GuardianPackagesConfigFile
         value: $(Build.SourcesDirectory)\eng\common\sdl\packages.config
       - name: GuardianVersion
diff --git a/eng/common/templates/jobs/jobs.yml b/eng/common/templates/jobs/jobs.yml
index f70826518cc..6673dd68a46 100644
--- a/eng/common/templates/jobs/jobs.yml
+++ b/eng/common/templates/jobs/jobs.yml
@@ -27,6 +27,13 @@ parameters:
   # Optional: Override automatically derived dependsOn value for "publish build assets" job
   publishBuildAssetsDependsOn: ''
 
+  # Optional: Publish the assets as soon as the publish to BAR stage is complete, rather doing so in a separate stage.
+  publishAssetsImmediately: false
+
+  # Optional: If using publishAssetsImmediately and additional parameters are needed, can be used to send along additional parameters (normally sent to post-build.yml)
+  artifactsPublishingAdditionalParameters: ''
+  signingValidationAdditionalParameters: ''
+
   # Optional: should run as a public build even in the internal project
   #           if 'true', the build won't run any of the internal only steps, even if it is running in non-public projects.
   runAsPublic: false
@@ -94,4 +101,7 @@ jobs:
 
         runAsPublic: ${{ parameters.runAsPublic }}
         publishUsingPipelines: ${{ parameters.enablePublishUsingPipelines }}
+        publishAssetsImmediately: ${{ parameters.publishAssetsImmediately }}
         enablePublishBuildArtifacts: ${{ parameters.enablePublishBuildArtifacts }}
+        artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+        signingValidationAdditionalParameters: ${{ parameters.signingValidationAdditionalParameters }}
diff --git a/eng/common/templates/jobs/source-build.yml b/eng/common/templates/jobs/source-build.yml
index 7c240e65447..a15b07eb51d 100644
--- a/eng/common/templates/jobs/source-build.yml
+++ b/eng/common/templates/jobs/source-build.yml
@@ -14,7 +14,7 @@ parameters:
   # This is the default platform provided by Arcade, intended for use by a managed-only repo.
   defaultManagedPlatform:
     name: 'Managed'
-    container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7'
+    container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-stream8'
 
   # Defines the platforms on which to run build jobs. One job is created for each platform, and the
   # object in this array is sent to the job template as 'platform'. If no platforms are specified,
diff --git a/eng/common/templates/post-build/common-variables.yml b/eng/common/templates/post-build/common-variables.yml
index fae340f4d20..173914f2364 100644
--- a/eng/common/templates/post-build/common-variables.yml
+++ b/eng/common/templates/post-build/common-variables.yml
@@ -1,8 +1,4 @@
 variables:
-  - group: AzureDevOps-Artifact-Feeds-Pats
-  - group: DotNet-Blob-Feed
-  - group: DotNet-DotNetCli-Storage
-  - group: DotNet-MSRC-Storage
   - group: Publish-Build-Assets
 
   # Whether the build is internal or not
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index 5a0bb8d96d2..d40c00f545a 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -49,6 +49,7 @@ parameters:
     type: object
     default:
       enable: false
+      publishGdn: false
       continueOnError: false
       params: ''
       artifactNames: ''
@@ -82,6 +83,11 @@ parameters:
     default:
     - Validate
 
+  # Optional: Call asset publishing rather than running in a separate stage
+  - name: publishAssetsImmediately
+    type: boolean
+    default: false
+
 stages:
 - ${{ if or(eq( parameters.enableNugetValidation, 'true'), eq(parameters.enableSigningValidation, 'true'), eq(parameters.enableSourceLinkValidation, 'true'), eq(parameters.SDLValidationParameters.enable, 'true')) }}:
   - stage: Validate
@@ -89,18 +95,19 @@ stages:
     displayName: Validate Build Assets
     variables:
       - template: common-variables.yml
+      - template: /eng/common/templates/variables/pool-providers.yml
     jobs:
     - job:
       displayName: NuGet Validation
-      condition: eq( ${{ parameters.enableNugetValidation }}, 'true')
+      condition: and(succeededOrFailed(), eq( ${{ parameters.enableNugetValidation }}, 'true'))
       pool:
         # We don't use the collection uri here because it might vary (.visualstudio.com vs. dev.azure.com)
         ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
           name: VSEngSS-MicroBuild2022-1ES
           demands: Cmd
         # If it's not devdiv, it's dnceng
-        ${{ if ne(variables['System.TeamProject'], 'DevDiv') }}:
-          name: NetCore1ESPool-Svc-Internal
+        ${{ else }}:
+          name: $(DncEngInternalBuildPool)
           demands: ImageOverride -equals windows.vs2019.amd64
 
       steps:
@@ -136,8 +143,8 @@ stages:
           name: VSEngSS-MicroBuild2022-1ES
           demands: Cmd
         # If it's not devdiv, it's dnceng
-        ${{ if ne(variables['System.TeamProject'], 'DevDiv') }}:
-          name: NetCore1ESPool-Svc-Internal
+        ${{ else }}:
+          name: $(DncEngInternalBuildPool)
           demands: ImageOverride -equals windows.vs2019.amd64
       steps:
         - template: setup-maestro-vars.yml
@@ -165,12 +172,6 @@ stages:
         - task: NuGetAuthenticate@1
           displayName: 'Authenticate to AzDO Feeds'
 
-        - task: PowerShell@2
-          displayName: Enable cross-org publishing
-          inputs:
-            filePath: eng\common\enable-cross-org-publishing.ps1
-            arguments: -token $(dn-bot-dnceng-artifact-feeds-rw)
-
         # Signing validation will optionally work with the buildmanifest file which is downloaded from
         # Azure DevOps above.
         - task: PowerShell@2
@@ -196,8 +197,8 @@ stages:
           name: VSEngSS-MicroBuild2022-1ES
           demands: Cmd
         # If it's not devdiv, it's dnceng
-        ${{ if ne(variables['System.TeamProject'], 'DevDiv') }}:
-          name: NetCore1ESPool-Svc-Internal
+        ${{ else }}:
+          name: $(DncEngInternalBuildPool)
           demands: ImageOverride -equals windows.vs2019.amd64
       steps:
         - template: setup-maestro-vars.yml
@@ -230,25 +231,28 @@ stages:
     - template: /eng/common/templates/job/execute-sdl.yml
       parameters:
         enable: ${{ parameters.SDLValidationParameters.enable }}
+        publishGuardianDirectoryToPipeline: ${{ parameters.SDLValidationParameters.publishGdn }}
         additionalParameters: ${{ parameters.SDLValidationParameters.params }}
         continueOnError: ${{ parameters.SDLValidationParameters.continueOnError }}
         artifactNames: ${{ parameters.SDLValidationParameters.artifactNames }}
         downloadArtifacts: ${{ parameters.SDLValidationParameters.downloadArtifacts }}
 
-- stage: publish_using_darc
-  ${{ if or(eq(parameters.enableNugetValidation, 'true'), eq(parameters.enableSigningValidation, 'true'), eq(parameters.enableSourceLinkValidation, 'true'), eq(parameters.SDLValidationParameters.enable, 'true')) }}:
-    dependsOn: ${{ parameters.publishDependsOn }}
-  ${{ if and(ne(parameters.enableNugetValidation, 'true'), ne(parameters.enableSigningValidation, 'true'), ne(parameters.enableSourceLinkValidation, 'true'), ne(parameters.SDLValidationParameters.enable, 'true')) }}:
-    dependsOn: ${{ parameters.validateDependsOn }}
-  displayName: Publish using Darc
-  variables:
-    - template: common-variables.yml
-  jobs:
-  - job:
-    displayName: Publish Using Darc
-    timeoutInMinutes: 120
-    pool:
-      # We don't use the collection uri here because it might vary (.visualstudio.com vs. dev.azure.com)
+- ${{ if ne(parameters.publishAssetsImmediately, 'true') }}:
+  - stage: publish_using_darc
+    ${{ if or(eq(parameters.enableNugetValidation, 'true'), eq(parameters.enableSigningValidation, 'true'), eq(parameters.enableSourceLinkValidation, 'true'), eq(parameters.SDLValidationParameters.enable, 'true')) }}:
+      dependsOn: ${{ parameters.publishDependsOn }}
+    ${{ else }}:
+      dependsOn: ${{ parameters.validateDependsOn }}
+    displayName: Publish using Darc
+    variables:
+      - template: common-variables.yml
+      - template: /eng/common/templates/variables/pool-providers.yml
+    jobs:
+    - job:
+      displayName: Publish Using Darc
+      timeoutInMinutes: 120
+      pool:
+        # We don't use the collection uri here because it might vary (.visualstudio.com vs. dev.azure.com)
         ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
           name: VSEngSS-MicroBuild2022-1ES
           demands: Cmd
@@ -256,11 +260,13 @@ stages:
         ${{ else }}:
           name: NetCore1ESPool-Publishing-Internal
           demands: ImageOverride -equals windows.vs2019.amd64
-    steps:
-      - template: setup-maestro-vars.yml
-        parameters:
-          BARBuildId: ${{ parameters.BARBuildId }}
-          PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
+      steps:
+        - template: setup-maestro-vars.yml
+          parameters:
+            BARBuildId: ${{ parameters.BARBuildId }}
+            PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
+
+        - task: NuGetAuthenticate@0
 
       - task: PowerShell@2
         displayName: Publish Using Darc
diff --git a/eng/common/templates/steps/component-governance.yml b/eng/common/templates/steps/component-governance.yml
index 12527b80ea9..cbba0596709 100644
--- a/eng/common/templates/steps/component-governance.yml
+++ b/eng/common/templates/steps/component-governance.yml
@@ -1,5 +1,6 @@
 parameters:
   disableComponentGovernance: false
+  componentGovernanceIgnoreDirectories: ''
 
 steps:
 - ${{ if eq(parameters.disableComponentGovernance, 'true') }}:
@@ -7,4 +8,6 @@ steps:
     displayName: Set skipComponentGovernanceDetection variable
 - ${{ if ne(parameters.disableComponentGovernance, 'true') }}:
   - task: ComponentGovernanceComponentDetection@0
-    continueOnError: true
\ No newline at end of file
+    continueOnError: true
+    inputs:
+      ignoreDirectories: ${{ parameters.componentGovernanceIgnoreDirectories }}
\ No newline at end of file
diff --git a/eng/common/templates/steps/execute-sdl.yml b/eng/common/templates/steps/execute-sdl.yml
index 9dd5709f66d..07426fde05d 100644
--- a/eng/common/templates/steps/execute-sdl.yml
+++ b/eng/common/templates/steps/execute-sdl.yml
@@ -33,7 +33,7 @@ steps:
 
 - ${{ if ne(parameters.overrideParameters, '') }}:
   - powershell: ${{ parameters.executeAllSdlToolsScript }} ${{ parameters.overrideParameters }}
-    displayName: Execute SDL
+    displayName: Execute SDL (Overridden)
     continueOnError: ${{ parameters.sdlContinueOnError }}
     condition: ${{ parameters.condition }}
 
diff --git a/eng/common/templates/steps/generate-sbom.yml b/eng/common/templates/steps/generate-sbom.yml
index f4d7937f379..a06373f38fa 100644
--- a/eng/common/templates/steps/generate-sbom.yml
+++ b/eng/common/templates/steps/generate-sbom.yml
@@ -2,12 +2,14 @@
 # PackageName - The name of the package this SBOM represents.
 # PackageVersion - The version of the package this SBOM represents. 
 # ManifestDirPath - The path of the directory where the generated manifest files will be placed
+# IgnoreDirectories - Directories to ignore for SBOM generation. This will be passed through to the CG component detector.
 
 parameters:
-  PackageVersion: 6.0.0
+  PackageVersion: 7.0.0
   BuildDropPath: '$(Build.SourcesDirectory)/artifacts'
   PackageName: '.NET'
   ManifestDirPath: $(Build.ArtifactStagingDirectory)/sbom
+  IgnoreDirectories: ''
   sbomContinueOnError: true
 
 steps:
@@ -34,6 +36,8 @@ steps:
       BuildDropPath: ${{ parameters.buildDropPath }}
       PackageVersion: ${{ parameters.packageVersion }}
       ManifestDirPath: ${{ parameters.manifestDirPath }}
+      ${{ if ne(parameters.IgnoreDirectories, '') }}:
+        AdditionalComponentDetectorArgs: '--IgnoreDirectories ${{ parameters.IgnoreDirectories }}'
 
 - task: PublishPipelineArtifact@1
   displayName: Publish SBOM manifest
diff --git a/eng/common/templates/steps/send-to-helix.yml b/eng/common/templates/steps/send-to-helix.yml
index cd02ae1607f..3eb7e2d5f84 100644
--- a/eng/common/templates/steps/send-to-helix.yml
+++ b/eng/common/templates/steps/send-to-helix.yml
@@ -3,7 +3,7 @@ parameters:
   HelixSource: 'pr/default'              # required -- sources must start with pr/, official/, prodcon/, or agent/
   HelixType: 'tests/default/'            # required -- Helix telemetry which identifies what type of data this is; should include "test" for clarity and must end in '/'
   HelixBuild: $(Build.BuildNumber)       # required -- the build number Helix will use to identify this -- automatically set to the AzDO build number
-  HelixTargetQueues: ''                  # required -- semicolon delimited list of Helix queues to test on; see https://helix.dot.net/ for a list of queues
+  HelixTargetQueues: ''                  # required -- semicolon-delimited list of Helix queues to test on; see https://helix.dot.net/ for a list of queues
   HelixAccessToken: ''                   # required -- access token to make Helix API requests; should be provided by the appropriate variable group
   HelixConfiguration: ''                 # optional -- additional property attached to a job
   HelixPreCommands: ''                   # optional -- commands to run before Helix work item execution
@@ -12,7 +12,7 @@ parameters:
   WorkItemCommand: ''                    # optional -- a command to execute on the payload; requires WorkItemDirectory; incompatible with XUnitProjects
   WorkItemTimeout: ''                    # optional -- a timeout in TimeSpan.Parse-ready value (e.g. 00:02:00) for the work item command; requires WorkItemDirectory; incompatible with XUnitProjects
   CorrelationPayloadDirectory: ''        # optional -- a directory to zip up and send to Helix as a correlation payload
-  XUnitProjects: ''                      # optional -- semicolon delimited list of XUnitProjects to parse and send to Helix; requires XUnitRuntimeTargetFramework, XUnitPublishTargetFramework, XUnitRunnerVersion, and IncludeDotNetCli=true
+  XUnitProjects: ''                      # optional -- semicolon-delimited list of XUnitProjects to parse and send to Helix; requires XUnitRuntimeTargetFramework, XUnitPublishTargetFramework, XUnitRunnerVersion, and IncludeDotNetCli=true
   XUnitWorkItemTimeout: ''               # optional -- the workitem timeout in seconds for all workitems created from the xUnit projects specified by XUnitProjects
   XUnitPublishTargetFramework: ''        # optional -- framework to use to publish your xUnit projects
   XUnitRuntimeTargetFramework: ''        # optional -- framework to use for the xUnit console runner
@@ -20,17 +20,16 @@ parameters:
   IncludeDotNetCli: false                # optional -- true will download a version of the .NET CLI onto the Helix machine as a correlation payload; requires DotNetCliPackageType and DotNetCliVersion
   DotNetCliPackageType: ''               # optional -- either 'sdk', 'runtime' or 'aspnetcore-runtime'; determines whether the sdk or runtime will be sent to Helix; see https://raw.githubusercontent.com/dotnet/core/main/release-notes/releases-index.json
   DotNetCliVersion: ''                   # optional -- version of the CLI to send to Helix; based on this: https://raw.githubusercontent.com/dotnet/core/main/release-notes/releases-index.json
-  EnableXUnitReporter: false             # optional -- true enables XUnit result reporting to Mission Control
   WaitForWorkItemCompletion: true        # optional -- true will make the task wait until work items have been completed and fail the build if work items fail. False is "fire and forget."
   IsExternal: false                      # [DEPRECATED] -- doesn't do anything, jobs are external if HelixAccessToken is empty and Creator is set
-  HelixBaseUri: 'https://helix.dot.net/' # optional -- sets the Helix API base URI (allows targeting int)
+  HelixBaseUri: 'https://helix.dot.net/' # optional -- sets the Helix API base URI (allows targeting https://helix.int-dot.net )
   Creator: ''                            # optional -- if the build is external, use this to specify who is sending the job
   DisplayNamePrefix: 'Run Tests'         # optional -- rename the beginning of the displayName of the steps in AzDO 
   condition: succeeded()                 # optional -- condition for step to execute; defaults to succeeded()
   continueOnError: false                 # optional -- determines whether to continue the build if the step errors; defaults to false
 
 steps:
-  - powershell: 'powershell "$env:BUILD_SOURCESDIRECTORY\eng\common\msbuild.ps1 $env:BUILD_SOURCESDIRECTORY\eng\common\helixpublish.proj /restore /t:Test /bl:$env:BUILD_SOURCESDIRECTORY\artifacts\log\$env:BuildConfig\SendToHelix.binlog"'
+  - powershell: 'powershell "$env:BUILD_SOURCESDIRECTORY\eng\common\msbuild.ps1 $env:BUILD_SOURCESDIRECTORY\eng\common\helixpublish.proj /restore /p:TreatWarningsAsErrors=false /t:Test /bl:$env:BUILD_SOURCESDIRECTORY\artifacts\log\$env:BuildConfig\SendToHelix.binlog"'
     displayName: ${{ parameters.DisplayNamePrefix }} (Windows)
     env:
       BuildConfig: $(_BuildConfig)
@@ -54,14 +53,13 @@ steps:
       IncludeDotNetCli: ${{ parameters.IncludeDotNetCli }}
       DotNetCliPackageType: ${{ parameters.DotNetCliPackageType }}
       DotNetCliVersion: ${{ parameters.DotNetCliVersion }}
-      EnableXUnitReporter: ${{ parameters.EnableXUnitReporter }}
       WaitForWorkItemCompletion: ${{ parameters.WaitForWorkItemCompletion }}
       HelixBaseUri: ${{ parameters.HelixBaseUri }}
       Creator: ${{ parameters.Creator }}
       SYSTEM_ACCESSTOKEN: $(System.AccessToken)
     condition: and(${{ parameters.condition }}, eq(variables['Agent.Os'], 'Windows_NT'))
     continueOnError: ${{ parameters.continueOnError }}
-  - script: $BUILD_SOURCESDIRECTORY/eng/common/msbuild.sh $BUILD_SOURCESDIRECTORY/eng/common/helixpublish.proj /restore /t:Test /bl:$BUILD_SOURCESDIRECTORY/artifacts/log/$BuildConfig/SendToHelix.binlog
+  - script: $BUILD_SOURCESDIRECTORY/eng/common/msbuild.sh $BUILD_SOURCESDIRECTORY/eng/common/helixpublish.proj /restore /p:TreatWarningsAsErrors=false /t:Test /bl:$BUILD_SOURCESDIRECTORY/artifacts/log/$BuildConfig/SendToHelix.binlog
     displayName: ${{ parameters.DisplayNamePrefix }} (Unix)
     env:
       BuildConfig: $(_BuildConfig)
@@ -85,7 +83,6 @@ steps:
       IncludeDotNetCli: ${{ parameters.IncludeDotNetCli }}
       DotNetCliPackageType: ${{ parameters.DotNetCliPackageType }}
       DotNetCliVersion: ${{ parameters.DotNetCliVersion }}
-      EnableXUnitReporter: ${{ parameters.EnableXUnitReporter }}
       WaitForWorkItemCompletion: ${{ parameters.WaitForWorkItemCompletion }}
       HelixBaseUri: ${{ parameters.HelixBaseUri }}
       Creator: ${{ parameters.Creator }}
diff --git a/eng/common/templates/steps/source-build.yml b/eng/common/templates/steps/source-build.yml
index b5b3e5aeb3b..41bbb915736 100644
--- a/eng/common/templates/steps/source-build.yml
+++ b/eng/common/templates/steps/source-build.yml
@@ -23,7 +23,7 @@ steps:
     # In addition, add an msbuild argument to copy the WIP from the repo to the target build location.
     # This is because SetupNuGetSources.sh will alter the current NuGet.config file, and we need to preserve those
     # changes.
-    $internalRestoreArgs=
+    internalRestoreArgs=
     if [ '$(dn-bot-dnceng-artifact-feeds-rw)' != '$''(dn-bot-dnceng-artifact-feeds-rw)' ]; then
       # Temporarily work around https://github.com/dotnet/arcade/issues/7709
       chmod +x $(Build.SourcesDirectory)/eng/common/SetupNugetSources.sh
@@ -68,11 +68,21 @@ steps:
       runtimeOsArgs='/p:RuntimeOS=${{ parameters.platform.runtimeOS }}'
     fi
 
+    baseOsArgs=
+    if [ '${{ parameters.platform.baseOS }}' != '' ]; then
+      baseOsArgs='/p:BaseOS=${{ parameters.platform.baseOS }}'
+    fi
+
     publishArgs=
     if [ '${{ parameters.platform.skipPublishValidation }}' != 'true' ]; then
       publishArgs='--publish'
     fi
 
+    assetManifestFileName=SourceBuild_RidSpecific.xml
+    if [ '${{ parameters.platform.name }}' != '' ]; then
+      assetManifestFileName=SourceBuild_${{ parameters.platform.name }}.xml
+    fi
+
     ${{ coalesce(parameters.platform.buildScript, './build.sh') }} --ci \
       --configuration $buildConfig \
       --restore --build --pack $publishArgs -bl \
@@ -81,8 +91,10 @@ steps:
       $internalRestoreArgs \
       $targetRidArgs \
       $runtimeOsArgs \
+      $baseOsArgs \
       /p:SourceBuildNonPortable=${{ parameters.platform.nonPortable }} \
-      /p:ArcadeBuildFromSource=true
+      /p:ArcadeBuildFromSource=true \
+      /p:AssetManifestFileName=$assetManifestFileName
   displayName: Build
 
 # Upload build logs for diagnosis.
@@ -106,3 +118,12 @@ steps:
     artifactName: BuildLogs_SourceBuild_${{ parameters.platform.name }}_Attempt$(System.JobAttempt)
   continueOnError: true
   condition: succeededOrFailed()
+
+# Manually inject component detection so that we can ignore the source build upstream cache, which contains
+# a nupkg cache of input packages (a local feed).
+# This path must match the upstream cache path in property 'CurrentRepoSourceBuiltNupkgCacheDir'
+# in src\Microsoft.DotNet.Arcade.Sdk\tools\SourceBuild\SourceBuildArcade.targets
+- task: ComponentGovernanceComponentDetection@0
+  displayName: Component Detection (Exclude upstream cache)
+  inputs:
+    ignoreDirectories: '$(Build.SourcesDirectory)/artifacts/source-build/self/src/artifacts/obj/source-built-upstream-cache'
diff --git a/eng/common/templates/variables/pool-providers.yml b/eng/common/templates/variables/pool-providers.yml
new file mode 100644
index 00000000000..9cc5c550d3b
--- /dev/null
+++ b/eng/common/templates/variables/pool-providers.yml
@@ -0,0 +1,57 @@
+# Select a pool provider based off branch name. Anything with branch name containing 'release' must go into an -Svc pool, 
+# otherwise it should go into the "normal" pools. This separates out the queueing and billing of released branches.
+
+# Motivation: 
+#   Once a given branch of a repository's output has been officially "shipped" once, it is then considered to be COGS
+#   (Cost of goods sold) and should be moved to a servicing pool provider. This allows both separation of queueing
+#   (allowing release builds and main PR builds to not intefere with each other) and billing (required for COGS.
+#   Additionally, the pool provider name itself may be subject to change when the .NET Core Engineering Services 
+#   team needs to move resources around and create new and potentially differently-named pools. Using this template 
+#   file from an Arcade-ified repo helps guard against both having to update one's release/* branches and renaming.
+
+# How to use: 
+#  This yaml assumes your shipped product branches use the naming convention "release/..." (which many do).
+#  If we find alternate naming conventions in broad usage it can be added to the condition below.
+#
+#  First, import the template in an arcade-ified repo to pick up the variables, e.g.:
+#
+#  variables:
+#  - template: /eng/common/templates/variables/pool-providers.yml
+#
+#  ... then anywhere specifying the pool provider use the runtime variables,
+#      $(DncEngInternalBuildPool) and $  (DncEngPublicBuildPool), e.g.:
+#
+#        pool:
+#           name: $(DncEngInternalBuildPool)
+#           demands: ImageOverride -equals windows.vs2019.amd64
+
+variables:
+  # Coalesce the target and source branches so we know when a PR targets a release branch
+  # If these variables are somehow missing, fall back to main (tends to have more capacity)
+
+  # Any new -Svc alternative pools should have variables added here to allow for splitting work
+  - name: DncEngPublicBuildPool
+    value: $[
+        replace(
+          replace(
+            eq(contains(coalesce(variables['System.PullRequest.TargetBranch'], variables['Build.SourceBranch'], 'refs/heads/main'), 'release'), 'true'),
+            True,
+            'NetCore-Svc-Public'
+          ),
+          False,
+          'NetCore-Public'
+        )
+      ]
+
+  - name: DncEngInternalBuildPool
+    value: $[
+        replace(
+          replace(
+            eq(contains(coalesce(variables['System.PullRequest.TargetBranch'], variables['Build.SourceBranch'], 'refs/heads/main'), 'release'), 'true'),
+            True,
+            'NetCore1ESPool-Svc-Internal'
+          ),
+          False,
+          'NetCore1ESPool-Internal'
+        )
+      ]
\ No newline at end of file
diff --git a/eng/common/templates/variables/sdl-variables.yml b/eng/common/templates/variables/sdl-variables.yml
index 1a860bd0406..dbdd66d4a4b 100644
--- a/eng/common/templates/variables/sdl-variables.yml
+++ b/eng/common/templates/variables/sdl-variables.yml
@@ -2,6 +2,6 @@ variables:
 # The Guardian version specified in 'eng/common/sdl/packages.config'. This value must be kept in
 # sync with the packages.config file.
 - name: DefaultGuardianVersion
-  value: 0.110.1
+  value: 0.109.0
 - name: GuardianPackagesConfigFile
   value: $(Build.SourcesDirectory)\eng\common\sdl\packages.config
\ No newline at end of file
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 81d7b0355e3..aa74ab4a81e 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -287,6 +287,25 @@ function InstallDotNet([string] $dotnetRoot,
   [string] $runtimeSourceFeedKey = '',
   [switch] $noPath) {
 
+  $dotnetVersionLabel = "'sdk v$version'"
+
+  if ($runtime -ne '' -and $runtime -ne 'sdk') {
+    $runtimePath = $dotnetRoot
+    $runtimePath = $runtimePath + "\shared"
+    if ($runtime -eq "dotnet") { $runtimePath = $runtimePath + "\Microsoft.NETCore.App" }
+    if ($runtime -eq "aspnetcore") { $runtimePath = $runtimePath + "\Microsoft.AspNetCore.App" }
+    if ($runtime -eq "windowsdesktop") { $runtimePath = $runtimePath + "\Microsoft.WindowsDesktop.App" }
+    $runtimePath = $runtimePath + "\" + $version
+  
+    $dotnetVersionLabel = "runtime toolset '$runtime/$architecture v$version'"
+
+    if (Test-Path $runtimePath) {
+      Write-Host "  Runtime toolset '$runtime/$architecture v$version' already installed."
+      $installSuccess = $true
+      Exit
+    }
+  }
+
   $installScript = GetDotNetInstallScript $dotnetRoot
   $installParameters = @{
     Version = $version
@@ -323,18 +342,18 @@ function InstallDotNet([string] $dotnetRoot,
     } else {
       $location = "public location";
     }
-    Write-Host "Attempting to install dotnet from $location."
+    Write-Host "  Attempting to install $dotnetVersionLabel from $location."
     try {
       & $installScript @variation
       $installSuccess = $true
       break
     }
     catch {
-      Write-Host "Failed to install dotnet from $location."
+      Write-Host "  Failed to install $dotnetVersionLabel from $location."
     }
   }
   if (-not $installSuccess) {
-    Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Failed to install dotnet from any of the specified locations."
+    Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Failed to install $dotnetVersionLabel from any of the specified locations."
     ExitWithExitCode 1
   }
 }
@@ -360,15 +379,22 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
   }
 
   # Minimum VS version to require.
-  $vsMinVersionReqdStr = '16.8'
+  $vsMinVersionReqdStr = '17.6'
   $vsMinVersionReqd = [Version]::new($vsMinVersionReqdStr)
 
   # If the version of msbuild is going to be xcopied,
   # use this version. Version matches a package here:
-  # https://dev.azure.com/dnceng/public/_packaging?_a=package&feed=dotnet-eng&package=RoslynTools.MSBuild&protocolType=NuGet&version=16.10.0-preview2&view=overview
-  $defaultXCopyMSBuildVersion = '16.10.0-preview2'
+  # https://dev.azure.com/dnceng/public/_artifacts/feed/dotnet-eng/NuGet/RoslynTools.MSBuild/versions/17.6.0-2
+  $defaultXCopyMSBuildVersion = '17.6.0-2'
 
-  if (!$vsRequirements) { $vsRequirements = $GlobalJson.tools.vs }
+  if (!$vsRequirements) {
+    if (Get-Member -InputObject $GlobalJson.tools -Name 'vs') {
+      $vsRequirements = $GlobalJson.tools.vs
+    }
+    else {
+      $vsRequirements = New-Object PSObject -Property @{ version = $vsMinVersionReqdStr }
+    }
+  }
   $vsMinVersionStr = if ($vsRequirements.version) { $vsRequirements.version } else { $vsMinVersionReqdStr }
   $vsMinVersion = [Version]::new($vsMinVersionStr)
 
@@ -392,7 +418,8 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
   # Locate Visual Studio installation or download x-copy msbuild.
   $vsInfo = LocateVisualStudio $vsRequirements
   if ($vsInfo -ne $null) {
-    $vsInstallDir = $vsInfo.installationPath
+    # Ensure vsInstallDir has a trailing slash
+    $vsInstallDir = Join-Path $vsInfo.installationPath "\"
     $vsMajorVersion = $vsInfo.installationVersion.Split('.')[0]
 
     InitializeVisualStudioEnvironmentVariables $vsInstallDir $vsMajorVersion
@@ -406,6 +433,7 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
       if($vsMinVersion -lt $vsMinVersionReqd){
         Write-Host "Using xcopy-msbuild version of $defaultXCopyMSBuildVersion since VS version $vsMinVersionStr provided in global.json is not compatible"
         $xcopyMSBuildVersion = $defaultXCopyMSBuildVersion
+        $vsMajorVersion = $xcopyMSBuildVersion.Split('.')[0]
       }
       else{
         # If the VS version IS compatible, look for an xcopy msbuild package
@@ -573,7 +601,7 @@ function InitializeBuildTool() {
       ExitWithExitCode 1
     }
     $dotnetPath = Join-Path $dotnetRoot (GetExecutableFileName 'dotnet')
-    $buildTool = @{ Path = $dotnetPath; Command = 'msbuild'; Tool = 'dotnet'; Framework = 'netcoreapp3.1' }
+    $buildTool = @{ Path = $dotnetPath; Command = 'msbuild'; Tool = 'dotnet'; Framework = 'net8.0' }
   } elseif ($msbuildEngine -eq "vs") {
     try {
       $msbuildPath = InitializeVisualStudioMSBuild -install:$restore
@@ -643,6 +671,10 @@ function InitializeNativeTools() {
   }
 }
 
+function Read-ArcadeSdkVersion() {
+  return $GlobalJson.'msbuild-sdks'.'Microsoft.DotNet.Arcade.Sdk'
+}
+
 function InitializeToolset() {
   if (Test-Path variable:global:_ToolsetBuildProj) {
     return $global:_ToolsetBuildProj
@@ -650,7 +682,7 @@ function InitializeToolset() {
 
   $nugetCache = GetNuGetPackageCachePath
 
-  $toolsetVersion = $GlobalJson.'msbuild-sdks'.'Microsoft.DotNet.Arcade.Sdk'
+  $toolsetVersion = Read-ArcadeSdkVersion
   $toolsetLocationFile = Join-Path $ToolsetDir "$toolsetVersion.txt"
 
   if (Test-Path $toolsetLocationFile) {
@@ -735,6 +767,8 @@ function MSBuild() {
       (Join-Path $basePath (Join-Path netcoreapp2.1 'Microsoft.DotNet.Arcade.Sdk.dll'))
       (Join-Path $basePath (Join-Path netcoreapp3.1 'Microsoft.DotNet.ArcadeLogging.dll')),
       (Join-Path $basePath (Join-Path netcoreapp3.1 'Microsoft.DotNet.Arcade.Sdk.dll'))
+      (Join-Path $basePath (Join-Path net7.0 'Microsoft.DotNet.ArcadeLogging.dll')),
+      (Join-Path $basePath (Join-Path net7.0 'Microsoft.DotNet.Arcade.Sdk.dll'))
     )
     $selectedPath = $null
     foreach ($path in $possiblePaths) {
@@ -807,7 +841,8 @@ function MSBuild-Core() {
       Write-Host "See log: $buildLog" -ForegroundColor DarkGray
     }
 
-    if ($ci) {
+    # When running on Azure Pipelines, override the returned exit code to avoid double logging.
+    if ($ci -and $env:SYSTEM_TEAMPROJECT -ne $null) {
       Write-PipelineSetResult -Result "Failed" -Message "msbuild execution failed."
       # Exiting with an exit code causes the azure pipelines task to log yet another "noise" error
       # The above Write-PipelineSetResult will cause the task to be marked as failure without adding yet another error
@@ -902,11 +937,13 @@ if (!$disableConfigureToolsetImport) {
 function Enable-Nuget-EnhancedRetry() {
     if ($ci) {
       Write-Host "Setting NUGET enhanced retry environment variables"
-      $env:NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY = 'true'
-      $env:NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT = 6
-      $env:NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS = 1000
-      Write-PipelineSetVariable -Name 'NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY' -Value 'true'
-      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT' -Value '6'
-      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS' -Value '1000'
+      $env:NUGET_ENABLE_ENHANCED_HTTP_RETRY = 'true'
+      $env:NUGET_ENHANCED_MAX_NETWORK_TRY_COUNT = 6
+      $env:NUGET_ENHANCED_NETWORK_RETRY_DELAY_MILLISECONDS = 1000
+      $env:NUGET_RETRY_HTTP_429 = 'true'
+      Write-PipelineSetVariable -Name 'NUGET_ENABLE_ENHANCED_HTTP_RETRY' -Value 'true'
+      Write-PipelineSetVariable -Name 'NUGET_ENHANCED_MAX_NETWORK_TRY_COUNT' -Value '6'
+      Write-PipelineSetVariable -Name 'NUGET_ENHANCED_NETWORK_RETRY_DELAY_MILLISECONDS' -Value '1000'
+      Write-PipelineSetVariable -Name 'NUGET_RETRY_HTTP_429' -Value 'true'
     }
 }
diff --git a/eng/common/tools.sh b/eng/common/tools.sh
index e555c34269f..e8d47894334 100755
--- a/eng/common/tools.sh
+++ b/eng/common/tools.sh
@@ -178,12 +178,41 @@ function InstallDotNetSdk {
   if [[ $# -ge 3 ]]; then
     architecture=$3
   fi
-  InstallDotNet "$root" "$version" $architecture 'sdk' 'false' $runtime_source_feed $runtime_source_feed_key
+  InstallDotNet "$root" "$version" $architecture 'sdk' 'true' $runtime_source_feed $runtime_source_feed_key
 }
 
 function InstallDotNet {
   local root=$1
   local version=$2
+  local runtime=$4
+
+  local dotnetVersionLabel="'$runtime v$version'"
+  if [[ -n "${4:-}" ]] && [ "$4" != 'sdk' ]; then
+    runtimePath="$root"
+    runtimePath="$runtimePath/shared"
+    case "$runtime" in
+      dotnet)
+        runtimePath="$runtimePath/Microsoft.NETCore.App"
+        ;;
+      aspnetcore)
+        runtimePath="$runtimePath/Microsoft.AspNetCore.App"
+        ;;
+      windowsdesktop)
+        runtimePath="$runtimePath/Microsoft.WindowsDesktop.App"
+        ;;
+      *)
+        ;;
+    esac
+    runtimePath="$runtimePath/$version"
+
+    dotnetVersionLabel="runtime toolset '$runtime/$architecture v$version'"
+
+    if [ -d "$runtimePath" ]; then
+      echo "  Runtime toolset '$runtime/$architecture v$version' already installed."
+      local installSuccess=1
+      return
+    fi
+  fi
 
   GetDotNetInstallScript "$root"
   local install_script=$_GetDotNetInstallScript
@@ -228,17 +257,17 @@ function InstallDotNet {
   for variationName in "${variations[@]}"; do
     local name="$variationName[@]"
     local variation=("${!name}")
-    echo "Attempting to install dotnet from $variationName."
+    echo "  Attempting to install $dotnetVersionLabel from $variationName."
     bash "$install_script" "${variation[@]}" && installSuccess=1
     if [[ "$installSuccess" -eq 1 ]]; then
       break
     fi
 
-    echo "Failed to install dotnet from $variationName."
+    echo "  Failed to install $dotnetVersionLabel from $variationName."
   done
 
   if [[ "$installSuccess" -eq 0 ]]; then
-    Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from any of the specified locations."
+    Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install $dotnetVersionLabel from any of the specified locations."
     ExitWithExitCode 1
   fi
 }
@@ -312,7 +341,7 @@ function InitializeBuildTool {
   # return values
   _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
   _InitializeBuildToolCommand="msbuild"
-  _InitializeBuildToolFramework="netcoreapp3.1"
+  _InitializeBuildToolFramework="net8.0"
 }
 
 # Set RestoreNoCache as a workaround for https://github.com/NuGet/Home/issues/3116
@@ -416,13 +445,6 @@ function MSBuild {
       export NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS=20
       Write-PipelineSetVariable -name "NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS" -value "20"
       Write-PipelineSetVariable -name "NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS" -value "20"
-
-      export NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY=true
-      export NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT=6
-      export NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS=1000
-      Write-PipelineSetVariable -name "NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY" -value "true"
-      Write-PipelineSetVariable -name "NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT" -value "6"
-      Write-PipelineSetVariable -name "NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS" -value "1000"
     fi
 
     local toolset_dir="${_InitializeToolset%/*}"
@@ -435,6 +457,8 @@ function MSBuild {
     possiblePaths+=( "$toolset_dir/netcoreapp2.1/Microsoft.DotNet.Arcade.Sdk.dll" )
     possiblePaths+=( "$toolset_dir/netcoreapp3.1/Microsoft.DotNet.ArcadeLogging.dll" )
     possiblePaths+=( "$toolset_dir/netcoreapp3.1/Microsoft.DotNet.Arcade.Sdk.dll" )
+    possiblePaths+=( "$toolset_dir/net7.0/Microsoft.DotNet.ArcadeLogging.dll" )
+    possiblePaths+=( "$toolset_dir/net7.0/Microsoft.DotNet.Arcade.Sdk.dll" )
     for path in "${possiblePaths[@]}"; do
       if [[ -f $path ]]; then
         selectedPath=$path
@@ -479,7 +503,9 @@ function MSBuild-Core {
       # We should not Write-PipelineTaskError here because that message shows up in the build summary
       # The build already logged an error, that's the reason it failed. Producing an error here only adds noise.
       echo "Build failed with exit code $exit_code. Check errors above."
-      if [[ "$ci" == "true" ]]; then
+
+      # When running on Azure Pipelines, override the returned exit code to avoid double logging.
+      if [[ "$ci" == "true" && -n ${SYSTEM_TEAMPROJECT:-} ]]; then
         Write-PipelineSetResult -result "Failed" -message "msbuild execution failed."
         # Exiting with an exit code causes the azure pipelines task to log yet another "noise" error
         # The above Write-PipelineSetResult will cause the task to be marked as failure without adding yet another error
@@ -493,6 +519,17 @@ function MSBuild-Core {
   RunBuildTool "$_InitializeBuildToolCommand" /m /nologo /clp:Summary /v:$verbosity /nr:$node_reuse $warnaserror_switch /p:TreatWarningsAsErrors=$warn_as_error /p:ContinuousIntegrationBuild=$ci "$@"
 }
 
+function GetDarc {
+    darc_path="$temp_dir/darc"
+    version="$1"
+
+    if [[ -n "$version" ]]; then
+      version="--darcversion $version"
+    fi
+
+    "$eng_root/common/darc-init.sh" --toolpath "$darc_path" $version
+}
+
 ResolvePath "${BASH_SOURCE[0]}"
 _script_dir=`dirname "$_ResolvePath"`
 
@@ -511,7 +548,7 @@ global_json_file="${repo_root}global.json"
 # determine if global.json contains a "runtimes" entry
 global_json_has_runtimes=false
 if command -v jq &> /dev/null; then
-  if jq -er '. | select(has("runtimes"))' "$global_json_file" &> /dev/null; then
+  if jq -e '.tools | has("runtimes")' "$global_json_file" &> /dev/null; then
     global_json_has_runtimes=true
   fi
 elif [[ "$(cat "$global_json_file")" =~ \"runtimes\"[[:space:]\:]*\{ ]]; then
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 6334d5f0b15..3f87fa86718 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -13,16 +13,22 @@
     <PackageVersion Include="BenchmarkDotNet" Version="0.13.1" />
     <PackageVersion Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
 
+    <PackageVersion Include="FluentAssertions" Version="6.11.0" />
+    <PackageVersion Update="FluentAssertions" Condition="'$(FluentAssertionsVersion)' != ''" Version="$(FluentAssertionsVersion)" />
+
     <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
     <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
+    <PackageVersion Include="Microsoft.BuildXL.Processes" Version="0.1.0-20230929.2" />
+    <PackageVersion Update="Microsoft.BuildXL.Processes" Condition="'$(BuildXLProcessesVersion)' != ''" Version="$(BuildXLProcessesVersion)" />
+
     <PackageVersion Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
     <PackageVersion Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(MicrosoftVisualStudioSetupConfigurationInteropVersion)' != ''" Version="$(MicrosoftVisualStudioSetupConfigurationInteropVersion)" PrivateAssets="All" />
 
     <PackageVersion Include="Microsoft.Win32.Registry" Version="5.0.0" />
     <PackageVersion Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
 
-    <PackageVersion Include="Newtonsoft.Json" Version="13.0.2" />
+    <PackageVersion Include="Newtonsoft.Json" Version="13.0.3" />
     <PackageVersion Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
 
     <PackageVersion Include="PdbGit" Version="3.0.41" />
@@ -48,11 +54,14 @@
 
     <PackageVersion Include="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
     <PackageVersion Update="System.Security.Cryptography.X509Certificates" Condition="'$(SystemSecurityCryptographyX509CertificatesVersion)' != ''" Version="$(SystemSecurityCryptographyX509CertificatesVersion)" />
+
+    <PackageVersion Include="Verify.Xunit" Version="19.14.1" />
+    <PackageVersion Update="Verify.XUnit" Condition="'$(VerifyXUnitVersion)' != ''" Version="$(VerifyXUnitVersion)" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
     <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.4" />
-    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.435" PrivateAssets="all"/>
+    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.507" PrivateAssets="all"/>
     <GlobalPackageReference Include="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" PrivateAssets="All" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
diff --git a/eng/sdl-tsa-vars.config b/eng/sdl-tsa-vars.config
new file mode 100644
index 00000000000..26d67a9a8b7
--- /dev/null
+++ b/eng/sdl-tsa-vars.config
@@ -0,0 +1,12 @@
+-SourceToolsList @("policheck","credscan")
+-ArtifactToolsList @("binskim")
+-TsaInstanceURL https://devdiv.visualstudio.com/
+-TsaProjectName DEVDIV
+-TsaNotificationEmail msbtm@microsoft.com
+-TsaCodebaseAdmin EUROPE\joaguila
+-TsaBugAreaPath "DevDiv\NET Tools\MSBuild"
+-TsaIterationPath DevDiv
+-TsaRepositoryName DotNet-msbuild-Trusted
+-TsaCodebaseName DotNet-msbuild-Trusted
+-TsaOnboard $True
+-TsaPublish $True
diff --git a/global.json b/global.json
index 088aacc941d..d9967b3a53d 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "7.0.304",
+    "dotnet": "8.0.100-preview.7.23376.3",
     "vs": {
-      "version": "17.4.1"
+      "version": "17.6.0"
     },
-    "xcopy-msbuild": "17.4.1"
+    "xcopy-msbuild": "17.6.0-2"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.24218.1"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23425.2"
   }
 }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index d7a084641b2..37b65ce9199 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -69,7 +69,7 @@ else {
 if ($runtime -eq "Desktop") {
     $targetFramework = "net472"
 } else {
-    $targetFramework = "net7.0"
+    $targetFramework = "net8.0"
 }
 
 $bootstrapBinDirectory = "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework"
diff --git a/src/BannedSymbols.txt b/src/BannedSymbols.txt
index 80f588d4b83..c369fe9d42b 100644
--- a/src/BannedSymbols.txt
+++ b/src/BannedSymbols.txt
@@ -1 +1,7 @@
 M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char);CompareInfo.IndexOf can unexpectedly allocate strings--use string.IndexOf
+P:Microsoft.Build.Construction.ProjectElementContainer.Children;Use ChildrenEnumerable instead to avoid boxing
+M:System.Xml.XmlReader.Create(System.String);Do not pass paths to XmlReader.Create--use the Stream overload
+M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings);Do not pass paths to XmlReader.Create--use the Stream overload
+M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext);Do not pass paths to XmlReader.Create--use the Stream overload
+M:System.Xml.XPath.XPathDocument.#ctor(System.String);Do not pass string paths to XPathDocument ctor--use the Stream overload
+M:System.Xml.XPath.XPathDocument.#ctor(System.String,System.Xml.XmlSpace);Do not pass string paths to XPathDocument ctor--use the Stream overload
diff --git a/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
index 5950b6a4ec2..2b59cd43574 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
@@ -28,7 +28,7 @@ public void ReadNone()
         {
             ProjectRootElement project = ProjectRootElement.Create();
 
-            Assert.Null(project.Imports.GetEnumerator().Current);
+            Assert.Empty(project.Imports);
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/ProjectImportGroupElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectImportGroupElement_Tests.cs
index 289fe98f4cc..f32676c98f3 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectImportGroupElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectImportGroupElement_Tests.cs
@@ -143,7 +143,7 @@ public void ReadNone()
         {
             ProjectRootElement project = ProjectRootElement.Create();
 
-            Assert.Null(project.Imports.GetEnumerator().Current);
+            Assert.Empty(project.Imports);
         }
 
         /// <summary>
@@ -162,7 +162,7 @@ public void ReadNoChild()
 
             ProjectImportGroupElement importGroup = (ProjectImportGroupElement)Helpers.GetFirst(project.ImportGroups);
 
-            Assert.Null(project.Imports.GetEnumerator().Current);
+            Assert.Empty(project.Imports);
             Assert.Equal(0, Helpers.Count(importGroup.Imports));
         }
 
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionGroupElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionGroupElement_Tests.cs
index 0ffa9b60cc2..7191ec67da7 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionGroupElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionGroupElement_Tests.cs
@@ -24,7 +24,7 @@ public void ReadNone()
         {
             ProjectRootElement project = ProjectRootElement.Create();
             Assert.Equal(0, Helpers.Count(project.Children));
-            Assert.Null(project.ItemDefinitionGroups.GetEnumerator().Current);
+            Assert.Empty(project.ItemDefinitionGroups);
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
index ac62b8e21d7..721a4521fdc 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
@@ -82,6 +82,30 @@ public void ReadNoChildren(string project)
             Assert.Equal(0, Helpers.Count(item.Metadata));
         }
 
+        [Fact]
+        public void ReadMetadataLocationPreserved()
+        {
+            string project = """
+                <Project>
+                    <Target Name='t'>
+                        <ItemGroup>
+                            <i Include='i' MetadataA='123' MetadataB='xyz' />
+                        </ItemGroup>
+                    </Target>
+                </Project>
+                """;
+
+            ProjectItemElement item = GetItemFromContent(project);
+            Assert.Equal(2, item.Metadata.Count);
+            ProjectMetadataElement metadatum1 = item.Metadata.First();
+            ProjectMetadataElement metadatum2 = item.Metadata.Skip(1).First();
+
+            Assert.Equal(4, metadatum1.Location.Line);
+            Assert.Equal(4, metadatum2.Location.Line);
+            Assert.Equal(27, metadatum1.Location.Column);
+            Assert.Equal(43, metadatum2.Location.Column);
+        }
+
         /// <summary>
         /// Read item with no include
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
index 8c71efffce3..61660b61ef0 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
@@ -24,7 +24,7 @@ public void ReadNoItemGroup()
         {
             ProjectRootElement project = ProjectRootElement.Create();
             Assert.Equal(0, Helpers.Count(project.Children));
-            Assert.Null(project.ItemGroups.GetEnumerator().Current);
+            Assert.Empty(project.ItemGroups);
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/ProjectPropertyGroupElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectPropertyGroupElement_Tests.cs
index 38f84d1b655..d70ad718687 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectPropertyGroupElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectPropertyGroupElement_Tests.cs
@@ -23,7 +23,7 @@ public void ReadNoPropertyGroup()
         {
             ProjectRootElement project = ProjectRootElement.Create();
             Assert.Equal(0, Helpers.Count(project.Children));
-            Assert.Null(project.PropertyGroups.GetEnumerator().Current);
+            Assert.Empty(project.PropertyGroups);
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
index 891e1bd625d..aa46fef257e 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
@@ -41,7 +41,7 @@ public void AddTargetInvalidName()
         public void ReadNoTarget()
         {
             ProjectRootElement project = ProjectRootElement.Create();
-            Assert.Null(project.Targets.GetEnumerator().Current);
+            Assert.Empty(project.Targets);
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs
index cbb90d0ff94..fe49f9cb243 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs
@@ -25,7 +25,7 @@ public void ReadNone()
         {
             ProjectRootElement project = ProjectRootElement.Create();
 
-            Assert.Null(project.UsingTasks.GetEnumerator().Current);
+            Assert.Empty(project.UsingTasks);
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs b/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs
index 9a4b587a16a..dcdf5f8ac7f 100644
--- a/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs
@@ -65,7 +65,7 @@ public void ReadEmptyParameterGroup()
             UsingTaskParameterGroupElement parameterGroup = GetParameterGroupXml(s_contentEmptyParameterGroup);
             Assert.NotNull(parameterGroup);
             Assert.Equal(0, parameterGroup.Count);
-            Assert.Null(parameterGroup.Parameters.GetEnumerator().Current);
+            Assert.Empty(parameterGroup.Parameters);
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index c4c4e0b9c59..fbdf4b3742f 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -95,6 +95,49 @@ public void AccessorsWithMetadata()
             Assert.Equal("v2", item.GetMetadataValue("m2"));
         }
 
+        /// <summary>
+        /// Basic ProjectItemInstance with metadata added using ImportMetadata
+        /// </summary>
+        [Fact]
+        public void AccessorsWithImportedMetadata()
+        {
+            ProjectItemInstance item = GetItemInstance();
+
+            ((IMetadataContainer)item).ImportMetadata(new Dictionary<string, string>
+            {
+                { "m1", "v1" },
+                { "m2", "v2" },
+            });
+
+            Assert.Equal("m1", item.GetMetadata("m1").Name);
+            Assert.Equal("m2", item.GetMetadata("m2").Name);
+            Assert.Equal("v1", item.GetMetadataValue("m1"));
+            Assert.Equal("v2", item.GetMetadataValue("m2"));
+        }
+
+        /// <summary>
+        /// ImportMetadata adds and overwrites metadata, does not delete existing metadata
+        /// </summary>
+        [Fact]
+        public void ImportMetadataAddsAndOverwrites()
+        {
+            ProjectItemInstance item = GetItemInstance();
+
+            item.SetMetadata("m1", "v1");
+            item.SetMetadata("m2", "v0");
+
+            ((IMetadataContainer) item).ImportMetadata(new Dictionary<string, string>
+            {
+                { "m2", "v2" },
+                { "m3", "v3" },
+            });
+
+            // m1 was not deleted, m2 was overwritten, m3 was added
+            Assert.Equal("v1", item.GetMetadataValue("m1"));
+            Assert.Equal("v2", item.GetMetadataValue("m2"));
+            Assert.Equal("v3", item.GetMetadataValue("m3"));
+        }
+
         /// <summary>
         /// Get metadata not present
         /// </summary>
@@ -106,6 +149,56 @@ public void GetMissingMetadata()
             Assert.Equal(String.Empty, item.GetMetadataValue("X"));
         }
 
+        [Fact]
+        public void CopyMetadataToTaskItem()
+        {
+            ProjectItemInstance fromItem = GetItemInstance();
+
+            fromItem.SetMetadata("m1", "v1");
+            fromItem.SetMetadata("m2", "v2");
+
+            ITaskItem toItem = new Utilities.TaskItem();
+
+            ((ITaskItem)fromItem).CopyMetadataTo(toItem);
+
+            Assert.Equal("v1", toItem.GetMetadata("m1"));
+            Assert.Equal("v2", toItem.GetMetadata("m2"));
+        }
+
+#if FEATURE_APPDOMAIN
+        private sealed class RemoteTaskItemFactory : MarshalByRefObject
+        {
+            public ITaskItem CreateTaskItem() => new Utilities.TaskItem();
+        }
+
+        [Fact]
+        public void CopyMetadataToRemoteTaskItem()
+        {
+            ProjectItemInstance fromItem = GetItemInstance();
+
+            fromItem.SetMetadata("m1", "v1");
+            fromItem.SetMetadata("m2", "v2");
+
+            AppDomain appDomain = null;
+            try
+            {
+                appDomain = AppDomain.CreateDomain("CopyMetadataToRemoteTaskItem", null, AppDomain.CurrentDomain.SetupInformation);
+                RemoteTaskItemFactory itemFactory = (RemoteTaskItemFactory)appDomain.CreateInstanceFromAndUnwrap(typeof(RemoteTaskItemFactory).Module.FullyQualifiedName, typeof(RemoteTaskItemFactory).FullName);
+
+                ITaskItem toItem = itemFactory.CreateTaskItem();
+
+                ((ITaskItem)fromItem).CopyMetadataTo(toItem);
+
+                Assert.Equal("v1", toItem.GetMetadata("m1"));
+                Assert.Equal("v2", toItem.GetMetadata("m2"));
+            }
+            finally
+            {
+                AppDomain.Unload(appDomain);
+            }
+        }
+#endif
+
         /// <summary>
         /// Set include
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 14c83442af4..57cba86c10c 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -15,8 +15,9 @@
   </PropertyGroup>
 
   <PropertyGroup>
-    <NuGetCommandLinePackageVersion>4.1.0</NuGetCommandLinePackageVersion>
-</PropertyGroup>
+    <!-- Managed manually since PackageDownload is not supported by dependabot https://github.com/dependabot/dependabot-core/issues/2920 -->
+    <NuGetCommandLinePackageVersion>4.9.6</NuGetCommandLinePackageVersion>
+  </PropertyGroup>
 
   <ItemGroup>
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
@@ -28,16 +29,13 @@
 
   <ItemGroup>
     <!-- GeneratePathProperty currently isn't enabled for PackageDownload. -->
-    <Content Condition="'$(MSBuildRuntimeType)' != 'Core' and '$(Configuration)' == 'Release'" Include="$(NuGetPackageRoot)\nuget.commandline\$(NuGetCommandLinePackageVersion)\tools\NuGet.exe" CopyToOutputDirectory="PreserveNewest" Link="nuget\NuGet.exe" />
+    <Content Include="$(NuGetPackageRoot)\nuget.commandline\$(NuGetCommandLinePackageVersion)\tools\NuGet.exe" CopyToOutputDirectory="PreserveNewest" Link="nuget\NuGet.exe" />
   </ItemGroup>
 
   <ItemGroup>
     <Compile Include="..\Shared\EncodingStringWriter.cs">
       <Link>EncodingStringWriter.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <Link>EncodingUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index c0a00cf572e..ee35a83c93a 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -1,13 +1,11 @@
 Ôªø// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if !DEBUG
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using System.IO;
 using Xunit;
-#endif
 using Xunit.Abstractions;
 using Xunit.NetCore.Extensions;
 
@@ -21,9 +19,7 @@ public NugetRestoreTests(ITestOutputHelper output)
             _output = output;
         }
 
-        // This NuGet version cannot locate other assemblies when parsing solutions at restore time. This includes localized strings required in debug mode.
-        // NuGet version 4.1.0 was somewhat arbitrarily chosen. 3.5 breaks with an unrelated error, and 4.8.2 does not fail when a new dependency is introduced. This is a safe middle point.
-#if !DEBUG
+        // Tests proper loading of msbuild assemblies by nuget.exe
         [WindowsFullFrameworkOnlyFact]
         public void TestOldNuget()
         {
@@ -54,6 +50,5 @@ public void TestOldNuget()
             RunnerUtilities.RunProcessAndGetOutput(Path.Combine(msbuildExePath, "nuget", "NuGet.exe"), "restore " + sln.Path + " -MSBuildPath \"" + msbuildExePath + "\"", out bool success, outputHelper: _output);
             success.ShouldBeTrue();
         }
-#endif
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
index f07ab76dd54..e3531211645 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
@@ -34,14 +34,14 @@ public LinkPair(T view, T real)
 
         public void VerifyNotSame(LinkPair<T> other)
         {
-            Assert.NotSame((object)this.View, (object)other.View);
-            Assert.NotSame((object)this.Real, (object)other.Real);
+            Assert.NotEqual((object)this.View, (object)other.View);
+            Assert.NotEqual((object)this.Real, (object)other.Real);
         }
 
         public void VerifySame(LinkPair<T> other)
         {
-            Assert.Same((object)this.View, (object)other.View);
-            Assert.Same((object)this.Real, (object)other.Real);
+            Assert.Equal((object)this.View, (object)other.View);
+            Assert.Equal((object)this.Real, (object)other.Real);
         }
 
         public void VerifySetter(bool finalValue, Func<T, bool> getter, Action<T, bool> setter)
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index b1288952956..d850b213576 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -6,8 +6,13 @@
 using System.Configuration.Assemblies;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Reflection;
+using System.Runtime.CompilerServices;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
 using Shouldly;
 using Xunit;
 
@@ -20,6 +25,11 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class BinaryTranslator_Tests
     {
+        static BinaryTranslator_Tests()
+        {
+            SerializationContractInitializer.Initialize();
+        }
+
         /// <summary>
         /// Tests the SerializationMode property
         /// </summary>
@@ -27,7 +37,7 @@ public class BinaryTranslator_Tests
         public void TestSerializationMode()
         {
             MemoryStream stream = new MemoryStream();
-            using ITranslator readTranslator = BinaryTranslator.GetReadTranslator(stream, null);
+            using ITranslator readTranslator = BinaryTranslator.GetReadTranslator(stream, InterningBinaryReader.PoolingBuffer);
             Assert.Equal(TranslationDirection.ReadFromStream, readTranslator.Mode);
 
             using ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(stream);
@@ -171,34 +181,122 @@ public void TestSerializeEnum()
             Assert.Equal(value, deserializedValue);
         }
 
-        /// <summary>
-        /// Tests serializing using the DotNet serializer.
-        /// </summary>
         [Fact]
-        public void TestSerializeDotNet()
+        public void TestSerializeException()
         {
-            ArgumentNullException value = new ArgumentNullException("The argument was null", new InsufficientMemoryException());
-            TranslationHelpers.GetWriteTranslator().TranslateDotNet(ref value);
+            Exception value = new ArgumentNullException("The argument was null");
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
 
-            ArgumentNullException deserializedValue = null;
-            TranslationHelpers.GetReadTranslator().TranslateDotNet(ref deserializedValue);
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
 
-            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        [Fact]
+        public void TestSerializeException_NestedWithStack()
+        {
+            Exception value = null;
+            try
+            {
+                // Intentionally throw a nested exception with a stack trace.
+                value = value.InnerException;
+            }
+            catch (Exception e)
+            {
+                value = new ArgumentNullException("The argument was null", e);
+            }
+
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        [Fact]
+        public void TestSerializeBuildException_NestedWithStack()
+        {
+            Exception value = null;
+            try
+            {
+                throw new InvalidProjectFileException("sample message");
+            }
+            catch (Exception e)
+            {
+                try
+                {
+                    throw new ArgumentNullException("The argument was null", e);
+                }
+                catch (Exception exception)
+                {
+                    value = new InternalErrorException("Another message", exception);
+                }
+            }
+
+            Assert.NotNull(value);
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        public static IEnumerable<object[]> GetBuildExceptionsAsTestData()
+            => AppDomain
+                .CurrentDomain
+                .GetAssemblies()
+                // TaskHost is copying code files - so has a copy of types with identical names.
+                .Where(a => !a.FullName!.StartsWith("MSBuildTaskHost", StringComparison.CurrentCultureIgnoreCase))
+                .SelectMany(s => s.GetTypes())
+                .Where(BuildExceptionSerializationHelper.IsSupportedExceptionType)
+                .Select(t => new object[] { t });
+
+        [Theory]
+        [MemberData(nameof(GetBuildExceptionsAsTestData))]
+        public void TestSerializationOfBuildExceptions(Type exceptionType)
+        {
+            Exception e = (Exception)Activator.CreateInstance(exceptionType, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.CreateInstance | BindingFlags.Instance, null, new object[]{"msg", new GenericBuildTransferredException() }, System.Globalization.CultureInfo.CurrentCulture);
+            Exception remote;
+            try
+            {
+                throw e;
+            }
+            catch (Exception exception)
+            {
+                remote = exception;
+            }
+
+            Assert.NotNull(remote);
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref remote);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(remote, deserializedValue, out string diffReason, true), $"Exception type {exceptionType.FullName} not properly de/serialized: {diffReason}");
         }
 
-        /// <summary>
-        /// Tests serializing using the DotNet serializer passing in null.
-        /// </summary>
         [Fact]
-        public void TestSerializeDotNetNull()
+        public void TestInvalidProjectFileException_NestedWithStack()
         {
-            ArgumentNullException value = null;
-            TranslationHelpers.GetWriteTranslator().TranslateDotNet(ref value);
+            Exception value = null;
+            try
+            {
+                throw new InvalidProjectFileException("sample message", new InternalErrorException("Another message"));
+            }
+            catch (Exception e)
+            {
+                value = e;
+            }
+
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
 
-            ArgumentNullException deserializedValue = null;
-            TranslationHelpers.GetReadTranslator().TranslateDotNet(ref deserializedValue);
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
 
-            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason, true), diffReason);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
new file mode 100644
index 00000000000..14e2a4cfd41
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
@@ -0,0 +1,169 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
+using static Microsoft.Build.UnitTests.ObjectModelHelpers;
+
+#nullable disable
+
+namespace Microsoft.Build.Engine.UnitTests.BackEnd
+{
+    public class BuildManager_Logging_Tests : IDisposable
+    {
+        private string _mainProject = @"
+<Project>
+
+  <Target Name=`MainTarget`>
+    <MSBuild Projects=`{0}` Targets=`ChildTarget` />
+  </Target>
+
+</Project>";
+
+        private string _childProjectWithCustomBuildEvent = $@"
+<Project>
+
+    <UsingTask TaskName=""CustomBuildEventTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
+    <Target Name=`ChildTarget`>
+        <CustomBuildEventTask />
+    </Target>
+
+</Project>";
+
+
+        /// <summary>
+        /// The mock logger for testing.
+        /// </summary>
+        private readonly MockLogger _logger;
+
+        /// <summary>
+        /// The standard build manager for each test.
+        /// </summary>
+        private readonly BuildManager _buildManager;
+
+        /// <summary>
+        /// The project collection used.
+        /// </summary>
+        private readonly ProjectCollection _projectCollection;
+
+        private readonly TestEnvironment _env;
+        private readonly ITestOutputHelper _output;
+
+        /// <summary>
+        /// SetUp
+        /// </summary>
+        public BuildManager_Logging_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+            // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.
+            BuildManager.DefaultBuildManager.Dispose();
+
+            _logger = new MockLogger(output);
+            _buildManager = new BuildManager();
+            _projectCollection = new ProjectCollection();
+
+            _env = TestEnvironment.Create(output);
+        }
+
+        [DotNetOnlyTheory]
+        [InlineData("1", true)]
+        // [InlineData("0", true)] <-- explicitly opting out on core will lead to node crash (as documented)
+        [InlineData(null, true)]
+        public void Build_WithCustomBuildArgs_NetCore(string envVariableValue, bool isWarningExpected)
+            => TestCustomEventWarning<BuildErrorEventArgs>(envVariableValue, isWarningExpected);
+
+        [WindowsFullFrameworkOnlyTheory]
+        [InlineData("1", true)]
+        [InlineData("0", false)]
+        [InlineData(null, false)]
+        public void Build_WithCustomBuildArgs_Framework(string envVariableValue, bool isWarningExpected) =>
+            TestCustomEventWarning<BuildWarningEventArgs>(envVariableValue, isWarningExpected);
+
+        private void TestCustomEventWarning<T>(string envVariableValue, bool isWarningExpected) where T : LazyFormattedBuildEventArgs
+        {
+            var testFiles = _env.CreateTestProjectWithFiles(string.Empty, new[] { "main", "child1" }, string.Empty);
+
+            ILoggingService service = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+            service.RegisterLogger(_logger);
+
+            _env.SetEnvironmentVariable("MSBUILDCUSTOMBUILDEVENTWARNING", envVariableValue);
+            _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+
+            _buildManager.BeginBuild(BuildParameters);
+
+            try
+            {
+                var child1ProjectPath = testFiles.CreatedFiles[1];
+                var cleanedUpChildContents = CleanupFileContents(_childProjectWithCustomBuildEvent);
+                File.WriteAllText(child1ProjectPath, cleanedUpChildContents);
+
+                var mainProjectPath = testFiles.CreatedFiles[0];
+                var cleanedUpMainContents = CleanupFileContents(string.Format(_mainProject, child1ProjectPath));
+                File.WriteAllText(mainProjectPath, cleanedUpMainContents);
+
+                var buildRequestData = new BuildRequestData(
+                   mainProjectPath,
+                   new Dictionary<string, string>(),
+                   MSBuildConstants.CurrentToolsVersion,
+                   new[] { "MainTarget" },
+                   null);
+
+                var submission = _buildManager.PendBuildRequest(buildRequestData);
+                var result = submission.Execute();
+                var allEvents = _logger.AllBuildEvents;
+
+                if (isWarningExpected)
+                {
+                    allEvents.OfType<T>().ShouldHaveSingleItem();
+                    allEvents.First(x => x is T).Message.ShouldContain(
+                        string.Format(ResourceUtilities.GetResourceString("DeprecatedEventSerialization"),
+                        "MyCustomBuildEventArgs"));
+                }
+                else
+                {
+                    allEvents.OfType<T>().ShouldBeEmpty();
+                }
+            }
+            finally
+            {
+                _buildManager.EndBuild();
+            }
+        }
+
+        private BuildParameters BuildParameters => new BuildParameters(_projectCollection)
+        {
+            DisableInProcNode = true,
+            EnableNodeReuse = false,
+            Loggers = new ILogger[] { _logger }
+        };
+
+        /// <summary>
+        /// TearDown
+        /// </summary>
+        public void Dispose()
+        {
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index e340aaacdc6..0f01ede7b2b 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -93,9 +93,15 @@ public BuildManager_Tests(ITestOutputHelper output)
         /// </summary>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
 
         /// <summary>
@@ -4040,7 +4046,7 @@ public void MultiProcReentrantProjectWithCallTargetDoesNotFail()
             }
         }
 
-        [Fact]
+        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/9245")]
         public void IdenticalSubmissionsShouldCompleteAndNotHangTheBuildOnMissingTargetExceptions()
         {
             var projectContents =
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index 13269b5221a..02c1179e863 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -326,16 +326,16 @@ public void TestTranslation()
 
             Assert.Equal(result.ConfigurationId, deserializedResult.ConfigurationId);
             Assert.True(TranslationHelpers.CompareCollections(result.DefaultTargets, deserializedResult.DefaultTargets, StringComparer.Ordinal));
-            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception, out string diffReason), diffReason);
             Assert.Equal(result.Exception.Message, deserializedResult.Exception.Message);
             Assert.Equal(result.GlobalRequestId, deserializedResult.GlobalRequestId);
             Assert.True(TranslationHelpers.CompareCollections(result.InitialTargets, deserializedResult.InitialTargets, StringComparer.Ordinal));
             Assert.Equal(result.NodeRequestId, deserializedResult.NodeRequestId);
             Assert.Equal(result["alpha"].ResultCode, deserializedResult["alpha"].ResultCode);
-            Assert.True(TranslationHelpers.CompareExceptions(result["alpha"].Exception, deserializedResult["alpha"].Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result["alpha"].Exception, deserializedResult["alpha"].Exception, out diffReason), diffReason);
             Assert.True(TranslationHelpers.CompareCollections(result["alpha"].Items, deserializedResult["alpha"].Items, TaskItemComparer.Instance));
             Assert.Equal(result["omega"].ResultCode, deserializedResult["omega"].ResultCode);
-            Assert.True(TranslationHelpers.CompareExceptions(result["omega"].Exception, deserializedResult["omega"].Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result["omega"].Exception, deserializedResult["omega"].Exception, out diffReason), diffReason);
             Assert.True(TranslationHelpers.CompareCollections(result["omega"].Items, deserializedResult["omega"].Items, TaskItemComparer.Instance));
         }
 
diff --git a/src/Build.UnitTests/BackEnd/CustomBuildEventTask.cs b/src/Build.UnitTests/BackEnd/CustomBuildEventTask.cs
new file mode 100644
index 00000000000..4309ea61ea6
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/CustomBuildEventTask.cs
@@ -0,0 +1,25 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+#nullable disable
+
+namespace Microsoft.Build.UnitTests
+{
+    public class CustomBuildEventTask : Task
+    {
+        public override bool Execute()
+        {
+            MyCustomBuildEventArgs customBuildEvent = new() { RawMessage = "A message from MyCustomBuildEventArgs" };
+            BuildEngine.LogCustomEvent(customBuildEvent);
+
+            return true;
+        }
+
+        [Serializable]
+        public sealed class MyCustomBuildEventArgs : CustomBuildEventArgs { }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
new file mode 100644
index 00000000000..27b30d71997
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
@@ -0,0 +1,85 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+using System;
+using System.Globalization;
+using System.Linq;
+using Microsoft.Build.Framework.Telemetry;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests.Telemetry;
+
+public class LoggingConfigurationTelemetry_Tests
+{
+    [Fact]
+    public void LoggingConfigurationTelemetryIsThere()
+    {
+        KnownTelemetry.LoggingConfigurationTelemetry.ShouldNotBeNull();
+    }
+
+    [Fact]
+    public void BuildTelemetryConstructedHasNoProperties()
+    {
+        LoggingConfigurationTelemetry telemetry = new();
+
+        telemetry.EventName.ShouldBe("loggingConfiguration");
+        telemetry.TerminalLogger.ShouldBe(false);
+        telemetry.TerminalLoggerUserIntent.ShouldBeNull();
+        telemetry.TerminalLoggerUserIntentSource.ShouldBeNull();
+        telemetry.TerminalLoggerDefault.ShouldBeNull();
+        telemetry.TerminalLoggerDefaultSource.ShouldBeNull();
+        telemetry.ConsoleLogger.ShouldBe(false);
+        telemetry.ConsoleLoggerType.ShouldBeNull();
+        telemetry.ConsoleLoggerVerbosity.ShouldBeNull();
+        telemetry.FileLogger.ShouldBe(false);
+        telemetry.FileLoggerVerbosity.ShouldBeNull();
+        telemetry.FileLoggersCount.ShouldBe(0);
+        telemetry.FileLoggerVerbosity.ShouldBeNull();
+        telemetry.BinaryLogger.ShouldBe(false);
+        telemetry.BinaryLoggerUsedDefaultName.ShouldBe(false);
+
+        telemetry.UpdateEventProperties();
+        telemetry.Properties.Where(kv => kv.Value != bool.FalseString).ShouldBeEmpty();
+    }
+
+    [Fact]
+    public void BuildTelemetryCreateProperProperties()
+    {
+        LoggingConfigurationTelemetry telemetry = new()
+        {
+            TerminalLogger = true,
+            TerminalLoggerUserIntent = "on",
+            TerminalLoggerUserIntentSource = "arg",
+            TerminalLoggerDefault = "auto",
+            TerminalLoggerDefaultSource = "sdk",
+            ConsoleLogger = true,
+            ConsoleLoggerType = "serial",
+            ConsoleLoggerVerbosity = "minimal",
+            FileLogger = true,
+            FileLoggerType = "serial",
+            FileLoggersCount = 2,
+            FileLoggerVerbosity = "normal",
+            BinaryLogger = true,
+            BinaryLoggerUsedDefaultName = true
+        };
+
+        telemetry.UpdateEventProperties();
+
+        telemetry.Properties["TerminalLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["TerminalLoggerUserIntent"].ShouldBe("on");
+        telemetry.Properties["TerminalLoggerUserIntentSource"].ShouldBe("arg");
+        telemetry.Properties["TerminalLoggerDefault"].ShouldBe("auto");
+        telemetry.Properties["TerminalLoggerDefaultSource"].ShouldBe("sdk");
+        telemetry.Properties["ConsoleLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["ConsoleLoggerType"].ShouldBe("serial");
+        telemetry.Properties["ConsoleLoggerVerbosity"].ShouldBe("minimal");
+        telemetry.Properties["FileLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["FileLoggerType"].ShouldBe("serial");
+        telemetry.Properties["FileLoggersCount"].ShouldBe("2");
+        telemetry.Properties["FileLoggerVerbosity"].ShouldBe("normal");
+        telemetry.Properties["BinaryLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["BinaryLoggerUsedDefaultName"].ShouldBe(bool.TrueString);
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index 078aae2bb15..1bae3f8adde 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -1068,7 +1068,7 @@ public void ImportanceReflectsCentralForwardingLoggerVerbosity()
         public void ImportanceReflectsUnknownLoggerVerbosity()
         {
             // Minimum message importance is Low (i.e. we're logging everything) even when all registered loggers have
-            // Normal verbosity if at least of one them is not on our whitelist.
+            // Normal verbosity if at least of one them is not on our allowlist.
             _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Normal));
             _initializedService.RegisterLogger(new MockLogger() { Verbosity = LoggerVerbosity.Normal });
             _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Normal));
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index 4eb2b6a1307..9b0a1eae9bb 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -772,6 +771,121 @@ public void ItemsIncludeExcludePathsCombinations()
             }
         }
 
+        /// <summary>
+        /// Referring to an item outside of target leads to 'naturally expected' reference to the item being processed.
+        ///  No expansion occurs.
+        /// </summary>
+        [Fact]
+        public void ItemsRecursionOutsideTarget()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectContent = """
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                     <ItemGroup>
+                        <iout1 Include='a/b.foo' TargetPath='%(Filename)%(Extension)' />
+                        <iout1 Include='c/d.foo' TargetPath='%(Filename)%(Extension)' />
+                        <iout1 Include='g/h.foo' TargetPath='%(Filename)%(Extension)' />
+                      </ItemGroup>
+                      <Target Name='a'>
+                        <Message Text="iout1=[@(iout1)]" Importance='High' />
+                        <Message Text="iout1-target-paths=[@(iout1->'%(TargetPath)')]" Importance='High' />
+                      </Target>
+                    </Project>
+                """;
+            var projectFile = env.CreateFile("test.proj", ObjectModelHelpers.CleanupFileContents(projectContent));
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile.Path, logger);
+
+            _testOutput.WriteLine(logger.FullLog);
+
+            logger.AssertLogContains("iout1=[a/b.foo;c/d.foo;g/h.foo]");
+            logger.AssertLogContains("iout1-target-paths=[b.foo;d.foo;h.foo]");
+        }
+
+        /// <summary>
+        /// Referring to an item within target leads to item expansion which might be unintended behavior - hence warning.
+        /// </summary>
+        [Fact]
+        public void ItemsRecursionWithinTarget()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectContent = """
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                      <Target Name='a'>
+                        <ItemGroup>
+                          <iin1 Include='a/b.foo' TargetPath='%(Filename)%(Extension)' />
+                          <iin1 Include='c/d.foo' TargetPath='%(Filename)%(Extension)' />
+                          <iin1 Include='g/h.foo' TargetPath='%(Filename)%(Extension)' />
+                        </ItemGroup>
+                        <Message Text="iin1=[@(iin1)]" Importance='High' />
+                        <Message Text="iin1-target-paths=[@(iin1->'%(TargetPath)')]" Importance='High' />
+                      </Target>
+                    </Project>
+                """;
+            string projFileName = "test.proj";
+            var projectFile = env.CreateFile(projFileName, ObjectModelHelpers.CleanupFileContents(projectContent));
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile.Path, logger);
+
+            _testOutput.WriteLine(logger.FullLog);
+
+            logger.AssertLogDoesntContain("iin1=[a/b.foo;c/d.foo;g/h.foo]");
+            logger.AssertLogDoesntContain("iin1-target-paths=[b.foo;d.foo;h.foo]");
+            logger.AssertLogContains("iin1=[a/b.foo;c/d.foo;g/h.foo;g/h.foo]");
+            logger.AssertLogContains("iin1-target-paths=[;b.foo;b.foo;d.foo]");
+
+            logger.AssertLogContains(string.Format(ResourceUtilities.GetResourceString("ItemReferencingSelfInTarget"), "iin1", "Filename"));
+            logger.AssertLogContains(string.Format(ResourceUtilities.GetResourceString("ItemReferencingSelfInTarget"), "iin1", "Extension"));
+            logger.AssertMessageCount("MSB4120", 6);
+            // The location of the offending attribute (TargetPath) is transferred - for both metadatums (%(Filename) and %(Extension)) on correct locations in xml
+            logger.AssertMessageCount($"{projFileName}(4,34):", 2, false);
+            logger.AssertMessageCount($"{projFileName}(5,34):", 2, false);
+            logger.AssertMessageCount($"{projFileName}(6,34):", 2, false);
+            Assert.Equal(0, logger.WarningCount);
+            Assert.Equal(0, logger.ErrorCount);
+        }
+
+        /// <summary>
+        /// Referring to an unrelated item within target leads to expected expansion.
+        /// </summary>
+        [Fact]
+        public void UnrelatedItemsRecursionWithinTarget()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectContent = """
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                      <ItemGroup>
+                        <iout1 Include='a/b.foo'/>
+                        <iout1 Include='c/d.foo'/>
+                        <iout1 Include='g/h.foo'/>
+                      </ItemGroup>
+
+                      <Target Name='a'>
+                        <ItemGroup>
+                          <iin1 Include='@(iout1)' TargetPath='%(Filename)%(Extension)' />
+                        </ItemGroup>
+                        <Message Text="iin1=[@(iin1)]" Importance='High' />
+                        <Message Text="iin1-target-paths=[@(iin1->'%(TargetPath)')]" Importance='High' />
+                      </Target>
+                    </Project>
+                """;
+            var projectFile = env.CreateFile("test.proj", ObjectModelHelpers.CleanupFileContents(projectContent));
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile.Path, logger);
+
+            _testOutput.WriteLine(logger.FullLog);
+
+            logger.AssertLogContains("iin1=[a/b.foo;c/d.foo;g/h.foo]");
+            logger.AssertLogContains("iin1-target-paths=[b.foo;d.foo;h.foo]");
+
+            logger.AssertLogDoesntContain("MSB4120");
+            Assert.Equal(0, logger.WarningCount);
+            Assert.Equal(0, logger.ErrorCount);
+        }
+
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 13de6f28e6f..2d9699376c1 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using FluentAssertions;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -57,8 +58,21 @@ public void VerifyEventType()
             ProjectStartedEventArgs projectStarted = new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null);
             ProjectFinishedEventArgs projectFinished = new ProjectFinishedEventArgs("message", "help", "ProjectFile", true);
             ExternalProjectStartedEventArgs externalStartedEvent = new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames");
+            ExternalProjectFinishedEventArgs externalFinishedEvent = new("message", "help", "senderName", "projectFile", true);
             ProjectEvaluationStartedEventArgs evaluationStarted = new ProjectEvaluationStartedEventArgs();
             ProjectEvaluationFinishedEventArgs evaluationFinished = new ProjectEvaluationFinishedEventArgs();
+            AssemblyLoadBuildEventArgs assemblyLoad = new(AssemblyLoadingContext.Evaluation, null, null, "path", Guid.NewGuid(), null);
+            ExtendedBuildErrorEventArgs extError = new("extError", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
+            ExtendedBuildWarningEventArgs extWarning = new("extWarn", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
+            ExtendedBuildMessageEventArgs extMessage = new("extMsg", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", MessageImportance.Normal);
+            ExtendedCustomBuildEventArgs extCustom = new("extCustom", "message", "help", "sender");
+            CriticalBuildMessageEventArgs criticalMessage = new("Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "Sender", DateTime.Now, "arg1");
+            PropertyInitialValueSetEventArgs propInit = new("prop", "val", "propsource", "message", "help", "sender", MessageImportance.Normal);
+            MetaprojectGeneratedEventArgs metaProjectGenerated = new("metaName", "path", "message");
+            PropertyReassignmentEventArgs propReassign = new("prop", "prevValue", "newValue", "loc", "message", "help", "sender", MessageImportance.Normal);
+            ResponseFileUsedEventArgs responseFileUsed = new("path");
+            UninitializedPropertyReadEventArgs uninitializedPropertyRead = new("prop", "message", "help", "sender", MessageImportance.Normal);
+            EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "help", "sender", MessageImportance.Normal);
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -76,7 +90,20 @@ public void VerifyEventType()
             VerifyLoggingPacket(projectFinished, LoggingEventType.ProjectFinishedEvent);
             VerifyLoggingPacket(evaluationStarted, LoggingEventType.ProjectEvaluationStartedEvent);
             VerifyLoggingPacket(evaluationFinished, LoggingEventType.ProjectEvaluationFinishedEvent);
-            VerifyLoggingPacket(externalStartedEvent, LoggingEventType.CustomEvent);
+            VerifyLoggingPacket(externalStartedEvent, LoggingEventType.ExternalProjectStartedEvent);
+            VerifyLoggingPacket(externalFinishedEvent, LoggingEventType.ExternalProjectFinishedEvent);
+            VerifyLoggingPacket(assemblyLoad, LoggingEventType.AssemblyLoadEvent);
+            VerifyLoggingPacket(extError, LoggingEventType.ExtendedBuildErrorEvent);
+            VerifyLoggingPacket(extWarning, LoggingEventType.ExtendedBuildWarningEvent);
+            VerifyLoggingPacket(extMessage, LoggingEventType.ExtendedBuildMessageEvent);
+            VerifyLoggingPacket(extCustom, LoggingEventType.ExtendedCustomEvent);
+            VerifyLoggingPacket(criticalMessage, LoggingEventType.CriticalBuildMessage);
+            VerifyLoggingPacket(propInit, LoggingEventType.PropertyInitialValueSet);
+            VerifyLoggingPacket(metaProjectGenerated, LoggingEventType.MetaprojectGenerated);
+            VerifyLoggingPacket(propReassign, LoggingEventType.PropertyReassignment);
+            VerifyLoggingPacket(responseFileUsed, LoggingEventType.ResponseFileUsedEvent);
+            VerifyLoggingPacket(uninitializedPropertyRead, LoggingEventType.UninitializedPropertyRead);
+            VerifyLoggingPacket(environmentVariableRead, LoggingEventType.EnvironmentVariableReadEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
@@ -218,6 +245,13 @@ public void TestTranslation()
             {
                 BuildEventArgs[] testArgs = new BuildEventArgs[]
                 {
+                    new ResponseFileUsedEventArgs("path"),
+                    new UninitializedPropertyReadEventArgs("prop", "message", "help", "sender", MessageImportance.Normal),
+                    new EnvironmentVariableReadEventArgs("env", "message", "help", "sender", MessageImportance.Normal) { BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6) },
+                    new PropertyReassignmentEventArgs("prop", "prevValue", "newValue", "loc", "message", "help", "sender", MessageImportance.Normal),
+                    new PropertyInitialValueSetEventArgs("prop", "val", "propsource", "message", "help", "sender", MessageImportance.Normal),
+                    new MetaprojectGeneratedEventArgs("metaName", "path", "message"),
+                    new CriticalBuildMessageEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "Sender", DateTime.Now, "arg1"),
                     new BuildFinishedEventArgs("Message", "Keyword", true),
                     new BuildStartedEventArgs("Message", "Help"),
                     new BuildMessageEventArgs("Message", "help", "sender", MessageImportance.Low),
@@ -236,11 +270,36 @@ public void TestTranslation()
                     new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null),
                     new ProjectFinishedEventArgs("message", "help", "ProjectFile", true),
                     new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames"),
+                    new ExternalProjectFinishedEventArgs("message", "help", "senderName", "projectFile", true),
                     CreateProjectEvaluationStarted(),
                     CreateProjectEvaluationFinished(),
-                    CreateTargetSkipped()
+                    new AssemblyLoadBuildEventArgs(AssemblyLoadingContext.Evaluation, "init", "aname", "path", Guid.NewGuid(), "domain", MessageImportance.Normal),
+                    CreateTargetSkipped(),
+                    new ExtendedBuildErrorEventArgs("extError", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
+                    new ExtendedBuildWarningEventArgs("extWarn", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
+                    new ExtendedBuildMessageEventArgs("extWarn", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", MessageImportance.Normal, DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
+                    new ExtendedCustomBuildEventArgs("extCustom", "message", "help", "sender", DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
                 };
-
                 foreach (BuildEventArgs arg in testArgs)
                 {
                     LogMessagePacket packet = new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(0, arg));
@@ -250,7 +309,17 @@ public void TestTranslation()
 
                     LogMessagePacket deserializedPacket = tempPacket as LogMessagePacket;
 
-                    CompareLogMessagePackets(packet, deserializedPacket);
+                    packet.Should().BeEquivalentTo(deserializedPacket, options => options
+                        .RespectingRuntimeTypes());
+
+                    BuildEventArgs args = packet.NodeBuildEvent?.Value;
+                    BuildEventArgs desArgs = deserializedPacket?.NodeBuildEvent?.Value;
+                    desArgs.Should().BeEquivalentTo(args, options => options
+                        .RespectingRuntimeTypes()
+                        // Since we use struct DictionaryEntry of class TaskItemData, generated DictionaryEntry.Equals compare TaskItemData by references.
+                        // Bellow will instruct equivalency test to not use DictionaryEntry.Equals but its public members for equivalency tests.
+                        .ComparingByMembers<DictionaryEntry>() 
+                        .WithTracing(), "Roundtrip deserialization of message type {0} should be equivalent", args.GetType().Name);
                 }
             }
             finally
@@ -273,249 +342,6 @@ private static void VerifyLoggingPacket(BuildEventArgs buildEvent, LoggingEventT
             Assert.True(Object.ReferenceEquals(buildEvent, packet.NodeBuildEvent.Value.Value)); // "Expected buildEvent to have the same object reference as packet.BuildEvent"
         }
 
-        /// <summary>
-        /// Compares two BuildEventArgs objects for equivalence.
-        /// </summary>
-        private void CompareNodeBuildEventArgs(KeyValuePair<int, BuildEventArgs> leftTuple, KeyValuePair<int, BuildEventArgs> rightTuple, bool expectInvalidBuildEventContext)
-        {
-            BuildEventArgs left = leftTuple.Value;
-            BuildEventArgs right = rightTuple.Value;
-
-            if (expectInvalidBuildEventContext)
-            {
-                Assert.Equal(BuildEventContext.Invalid, right.BuildEventContext);
-            }
-            else
-            {
-                Assert.Equal(left.BuildEventContext, right.BuildEventContext);
-            }
-
-            Assert.Equal(leftTuple.Key, rightTuple.Key);
-            Assert.Equal(left.HelpKeyword, right.HelpKeyword);
-            Assert.Equal(left.Message, right.Message);
-            Assert.Equal(left.SenderName, right.SenderName);
-            Assert.Equal(left.ThreadId, right.ThreadId);
-            Assert.Equal(left.Timestamp, right.Timestamp);
-        }
-
-        /// <summary>
-        /// Compares two LogMessagePacket objects for equivalence.
-        /// </summary>
-        private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket right)
-        {
-            Assert.Equal(left.EventType, right.EventType);
-            Assert.Equal(left.NodeBuildEvent.Value.Value.GetType(), right.NodeBuildEvent.Value.Value.GetType());
-
-            CompareNodeBuildEventArgs(left.NodeBuildEvent.Value, right.NodeBuildEvent.Value, left.EventType == LoggingEventType.CustomEvent /* expectInvalidBuildEventContext */);
-
-            switch (left.EventType)
-            {
-                case LoggingEventType.BuildErrorEvent:
-                    BuildErrorEventArgs leftError = left.NodeBuildEvent.Value.Value as BuildErrorEventArgs;
-                    BuildErrorEventArgs rightError = right.NodeBuildEvent.Value.Value as BuildErrorEventArgs;
-                    Assert.NotNull(leftError);
-                    Assert.NotNull(rightError);
-                    Assert.Equal(leftError.Code, rightError.Code);
-                    Assert.Equal(leftError.ColumnNumber, rightError.ColumnNumber);
-                    Assert.Equal(leftError.EndColumnNumber, rightError.EndColumnNumber);
-                    Assert.Equal(leftError.EndLineNumber, rightError.EndLineNumber);
-                    Assert.Equal(leftError.File, rightError.File);
-                    Assert.Equal(leftError.LineNumber, rightError.LineNumber);
-                    Assert.Equal(leftError.Message, rightError.Message);
-                    Assert.Equal(leftError.Subcategory, rightError.Subcategory);
-                    break;
-
-                case LoggingEventType.BuildFinishedEvent:
-                    BuildFinishedEventArgs leftFinished = left.NodeBuildEvent.Value.Value as BuildFinishedEventArgs;
-                    BuildFinishedEventArgs rightFinished = right.NodeBuildEvent.Value.Value as BuildFinishedEventArgs;
-                    Assert.NotNull(leftFinished);
-                    Assert.NotNull(rightFinished);
-                    Assert.Equal(leftFinished.Succeeded, rightFinished.Succeeded);
-                    break;
-
-                case LoggingEventType.BuildMessageEvent:
-                    BuildMessageEventArgs leftMessage = left.NodeBuildEvent.Value.Value as BuildMessageEventArgs;
-                    BuildMessageEventArgs rightMessage = right.NodeBuildEvent.Value.Value as BuildMessageEventArgs;
-                    Assert.NotNull(leftMessage);
-                    Assert.NotNull(rightMessage);
-                    Assert.Equal(leftMessage.Importance, rightMessage.Importance);
-                    break;
-
-                case LoggingEventType.BuildStartedEvent:
-                    BuildStartedEventArgs leftBuildStart = left.NodeBuildEvent.Value.Value as BuildStartedEventArgs;
-                    BuildStartedEventArgs rightBuildStart = right.NodeBuildEvent.Value.Value as BuildStartedEventArgs;
-                    Assert.NotNull(leftBuildStart);
-                    Assert.NotNull(rightBuildStart);
-                    break;
-
-                case LoggingEventType.BuildWarningEvent:
-                    BuildWarningEventArgs leftBuildWarn = left.NodeBuildEvent.Value.Value as BuildWarningEventArgs;
-                    BuildWarningEventArgs rightBuildWarn = right.NodeBuildEvent.Value.Value as BuildWarningEventArgs;
-                    Assert.NotNull(leftBuildWarn);
-                    Assert.NotNull(rightBuildWarn);
-                    Assert.Equal(leftBuildWarn.Code, rightBuildWarn.Code);
-                    Assert.Equal(leftBuildWarn.ColumnNumber, rightBuildWarn.ColumnNumber);
-                    Assert.Equal(leftBuildWarn.EndColumnNumber, rightBuildWarn.EndColumnNumber);
-                    Assert.Equal(leftBuildWarn.EndLineNumber, rightBuildWarn.EndLineNumber);
-                    Assert.Equal(leftBuildWarn.File, rightBuildWarn.File);
-                    Assert.Equal(leftBuildWarn.LineNumber, rightBuildWarn.LineNumber);
-                    Assert.Equal(leftBuildWarn.Subcategory, rightBuildWarn.Subcategory);
-                    break;
-
-                case LoggingEventType.CustomEvent:
-                    ExternalProjectStartedEventArgs leftCustom = left.NodeBuildEvent.Value.Value as ExternalProjectStartedEventArgs;
-                    ExternalProjectStartedEventArgs rightCustom = right.NodeBuildEvent.Value.Value as ExternalProjectStartedEventArgs;
-                    Assert.NotNull(leftCustom);
-                    Assert.NotNull(rightCustom);
-                    Assert.Equal(leftCustom.ProjectFile, rightCustom.ProjectFile);
-                    Assert.Equal(leftCustom.TargetNames, rightCustom.TargetNames);
-                    break;
-
-                case LoggingEventType.ProjectFinishedEvent:
-                    ProjectFinishedEventArgs leftProjectFinished = left.NodeBuildEvent.Value.Value as ProjectFinishedEventArgs;
-                    ProjectFinishedEventArgs rightProjectFinished = right.NodeBuildEvent.Value.Value as ProjectFinishedEventArgs;
-                    Assert.NotNull(leftProjectFinished);
-                    Assert.NotNull(rightProjectFinished);
-                    Assert.Equal(leftProjectFinished.ProjectFile, rightProjectFinished.ProjectFile);
-                    Assert.Equal(leftProjectFinished.Succeeded, rightProjectFinished.Succeeded);
-                    break;
-
-                case LoggingEventType.ProjectStartedEvent:
-                    ProjectStartedEventArgs leftProjectStarted = left.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
-                    ProjectStartedEventArgs rightProjectStarted = right.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
-                    Assert.NotNull(leftProjectStarted);
-                    Assert.NotNull(rightProjectStarted);
-                    Assert.Equal(leftProjectStarted.ParentProjectBuildEventContext, rightProjectStarted.ParentProjectBuildEventContext);
-                    Assert.Equal(leftProjectStarted.ProjectFile, rightProjectStarted.ProjectFile);
-                    Assert.Equal(leftProjectStarted.ProjectId, rightProjectStarted.ProjectId);
-                    Assert.Equal(leftProjectStarted.TargetNames, rightProjectStarted.TargetNames);
-
-                    // UNDONE: (Serialization.) We don't actually serialize the items at this time.
-                    // Assert.AreEqual(leftProjectStarted.Items, rightProjectStarted.Items);
-                    // UNDONE: (Serialization.) We don't actually serialize properties at this time.
-                    // Assert.AreEqual(leftProjectStarted.Properties, rightProjectStarted.Properties);
-                    break;
-
-                case LoggingEventType.ProjectEvaluationStartedEvent:
-                    ProjectEvaluationStartedEventArgs leftEvaluationStarted = left.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
-                    ProjectEvaluationStartedEventArgs rightEvaluationStarted = right.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
-                    Assert.NotNull(leftEvaluationStarted);
-                    Assert.NotNull(rightEvaluationStarted);
-                    Assert.Equal(leftEvaluationStarted.ProjectFile, rightEvaluationStarted.ProjectFile);
-                    break;
-
-                case LoggingEventType.ProjectEvaluationFinishedEvent:
-                    ProjectEvaluationFinishedEventArgs leftEvaluationFinished = left.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
-                    ProjectEvaluationFinishedEventArgs rightEvaluationFinished = right.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
-                    Assert.NotNull(leftEvaluationFinished);
-                    Assert.NotNull(rightEvaluationFinished);
-                    Assert.Equal(leftEvaluationFinished.ProjectFile, rightEvaluationFinished.ProjectFile);
-                    Assert.Equal(leftEvaluationFinished.ProfilerResult, rightEvaluationFinished.ProfilerResult);
-                    Assert.Equal(
-                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.GlobalProperties),
-                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.GlobalProperties));
-                    Assert.Equal(
-                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.Properties),
-                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.Properties));
-                    Assert.Equal(
-                        TranslationHelpers.GetMultiItemsString(leftEvaluationFinished.Items),
-                        TranslationHelpers.GetMultiItemsString(rightEvaluationFinished.Items));
-                    break;
-
-                case LoggingEventType.TargetFinishedEvent:
-                    TargetFinishedEventArgs leftTargetFinished = left.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
-                    TargetFinishedEventArgs rightTargetFinished = right.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
-                    Assert.NotNull(leftTargetFinished);
-                    Assert.NotNull(rightTargetFinished);
-                    Assert.Equal(leftTargetFinished.ProjectFile, rightTargetFinished.ProjectFile);
-                    Assert.Equal(leftTargetFinished.Succeeded, rightTargetFinished.Succeeded);
-                    Assert.Equal(leftTargetFinished.TargetFile, rightTargetFinished.TargetFile);
-                    Assert.Equal(leftTargetFinished.TargetName, rightTargetFinished.TargetName);
-                    // TODO: target output translation is a special case and is done in TranslateTargetFinishedEvent
-                    // Assert.Equal(leftTargetFinished.TargetOutputs, rightTargetFinished.TargetOutputs);
-                    break;
-
-                case LoggingEventType.TargetStartedEvent:
-                    TargetStartedEventArgs leftTargetStarted = left.NodeBuildEvent.Value.Value as TargetStartedEventArgs;
-                    TargetStartedEventArgs rightTargetStarted = right.NodeBuildEvent.Value.Value as TargetStartedEventArgs;
-                    Assert.NotNull(leftTargetStarted);
-                    Assert.NotNull(rightTargetStarted);
-                    Assert.Equal(leftTargetStarted.ProjectFile, rightTargetStarted.ProjectFile);
-                    Assert.Equal(leftTargetStarted.TargetFile, rightTargetStarted.TargetFile);
-                    Assert.Equal(leftTargetStarted.TargetName, rightTargetStarted.TargetName);
-                    break;
-
-                case LoggingEventType.TargetSkipped:
-                    TargetSkippedEventArgs leftTargetSkipped = left.NodeBuildEvent.Value.Value as TargetSkippedEventArgs;
-                    TargetSkippedEventArgs rightTargetSkipped = right.NodeBuildEvent.Value.Value as TargetSkippedEventArgs;
-                    Assert.Equal(leftTargetSkipped.BuildReason, rightTargetSkipped.BuildReason);
-                    Assert.Equal(leftTargetSkipped.SkipReason, rightTargetSkipped.SkipReason);
-                    Assert.Equal(leftTargetSkipped.BuildEventContext, rightTargetSkipped.BuildEventContext);
-                    Assert.Equal(leftTargetSkipped.OriginalBuildEventContext, rightTargetSkipped.OriginalBuildEventContext);
-                    Assert.Equal(leftTargetSkipped.Condition, rightTargetSkipped.Condition);
-                    Assert.Equal(leftTargetSkipped.EvaluatedCondition, rightTargetSkipped.EvaluatedCondition);
-                    Assert.Equal(leftTargetSkipped.Importance, rightTargetSkipped.Importance);
-                    Assert.Equal(leftTargetSkipped.OriginallySucceeded, rightTargetSkipped.OriginallySucceeded);
-                    Assert.Equal(leftTargetSkipped.ProjectFile, rightTargetSkipped.ProjectFile);
-                    Assert.Equal(leftTargetSkipped.TargetFile, rightTargetSkipped.TargetFile);
-                    Assert.Equal(leftTargetSkipped.TargetName, rightTargetSkipped.TargetName);
-                    Assert.Equal(leftTargetSkipped.ParentTarget, rightTargetSkipped.ParentTarget);
-                    break;
-
-                case LoggingEventType.TaskCommandLineEvent:
-                    TaskCommandLineEventArgs leftCommand = left.NodeBuildEvent.Value.Value as TaskCommandLineEventArgs;
-                    TaskCommandLineEventArgs rightCommand = right.NodeBuildEvent.Value.Value as TaskCommandLineEventArgs;
-                    Assert.NotNull(leftCommand);
-                    Assert.NotNull(rightCommand);
-                    Assert.Equal(leftCommand.CommandLine, rightCommand.CommandLine);
-                    Assert.Equal(leftCommand.Importance, rightCommand.Importance);
-                    Assert.Equal(leftCommand.TaskName, rightCommand.TaskName);
-                    break;
-
-                case LoggingEventType.TaskParameterEvent:
-                    var leftTaskParameter = left.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
-                    var rightTaskParameter = right.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
-                    Assert.NotNull(leftTaskParameter);
-                    Assert.NotNull(rightTaskParameter);
-                    Assert.Equal(leftTaskParameter.Kind, rightTaskParameter.Kind);
-                    Assert.Equal(leftTaskParameter.ItemType, rightTaskParameter.ItemType);
-                    Assert.Equal(leftTaskParameter.Items.Count, rightTaskParameter.Items.Count);
-                    Assert.Equal(leftTaskParameter.Message, rightTaskParameter.Message);
-                    Assert.Equal(leftTaskParameter.BuildEventContext, rightTaskParameter.BuildEventContext);
-                    Assert.Equal(leftTaskParameter.Timestamp, rightTaskParameter.Timestamp);
-                    Assert.Equal(leftTaskParameter.LineNumber, rightTaskParameter.LineNumber);
-                    Assert.Equal(leftTaskParameter.ColumnNumber, rightTaskParameter.ColumnNumber);
-                    break;
-
-                case LoggingEventType.TaskFinishedEvent:
-                    TaskFinishedEventArgs leftTaskFinished = left.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
-                    TaskFinishedEventArgs rightTaskFinished = right.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
-                    Assert.NotNull(leftTaskFinished);
-                    Assert.NotNull(rightTaskFinished);
-                    Assert.Equal(leftTaskFinished.ProjectFile, rightTaskFinished.ProjectFile);
-                    Assert.Equal(leftTaskFinished.Succeeded, rightTaskFinished.Succeeded);
-                    Assert.Equal(leftTaskFinished.TaskFile, rightTaskFinished.TaskFile);
-                    Assert.Equal(leftTaskFinished.TaskName, rightTaskFinished.TaskName);
-                    break;
-
-                case LoggingEventType.TaskStartedEvent:
-                    TaskStartedEventArgs leftTaskStarted = left.NodeBuildEvent.Value.Value as TaskStartedEventArgs;
-                    TaskStartedEventArgs rightTaskStarted = right.NodeBuildEvent.Value.Value as TaskStartedEventArgs;
-                    Assert.NotNull(leftTaskStarted);
-                    Assert.NotNull(rightTaskStarted);
-                    Assert.Equal(leftTaskStarted.ProjectFile, rightTaskStarted.ProjectFile);
-                    Assert.Equal(leftTaskStarted.TaskFile, rightTaskStarted.TaskFile);
-                    Assert.Equal(leftTaskStarted.TaskName, rightTaskStarted.TaskName);
-                    Assert.Equal(leftTaskStarted.LineNumber, rightTaskStarted.LineNumber);
-                    Assert.Equal(leftTaskStarted.ColumnNumber, rightTaskStarted.ColumnNumber);
-                    break;
-
-                default:
-                    Assert.True(false, string.Format("Unexpected logging event type {0}", left.EventType));
-                    break;
-            }
-        }
-
         #endregion
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
index 322c61aa579..83d4ae0cf0a 100644
--- a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -77,9 +77,15 @@ public SdkResultOutOfProc_Tests(ITestOutputHelper output)
 
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
             EvaluationContext.TestOnlyHookOnCreate = null;
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 30eafec7e91..5644861dbc9 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -236,6 +236,41 @@ Skipping target ""Build"" because all output files are up-to-date with respect t
             }
         }
 
+        [Fact]
+        public void TestErrorForSkippedTargetInputsAndOutputs()
+        {
+            string projectContents = @"
+<Project>
+  <Target Name=""Build"" Inputs=""a.txt;b.txt"" Outputs=""c.txt"">
+    <Message Text=""test"" Importance=""High"" />
+  </Target>
+</Project>";
+
+            using (var env = TestEnvironment.Create())
+            {
+                var buildParameters = new BuildParameters()
+                {
+                    Question = true,
+                };
+
+                using (var buildSession = new Helpers.BuildManagerSession(env, buildParameters))
+                {
+                    var files = env.CreateTestProjectWithFiles(projectContents, new[] { "a.txt", "b.txt", "c.txt" });
+                    var fileA = new FileInfo(files.CreatedFiles[0]);
+                    var fileB = new FileInfo(files.CreatedFiles[1]);
+                    var fileC = new FileInfo(files.CreatedFiles[2]);
+
+                    var now = DateTime.UtcNow;
+                    fileA.LastWriteTimeUtc = now - TimeSpan.FromSeconds(10);
+                    fileB.LastWriteTimeUtc = now + TimeSpan.FromSeconds(10);
+                    fileC.LastWriteTimeUtc = now;
+
+                    var result = buildSession.BuildProjectFile(files.ProjectFile);
+                    result.OverallResult.ShouldBe(BuildResultCode.Failure);
+                }
+            }
+        }
+
         /// <summary>
         /// Ensure that skipped targets only infer outputs once
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
index 5c653497011..d9fb204fb78 100644
--- a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
@@ -102,7 +102,7 @@ public void TestTranslationNoException()
 
             Assert.Equal(result.ResultCode, deserializedResult.ResultCode);
             Assert.True(TranslationHelpers.CompareCollections(result.Items, deserializedResult.Items, TaskItemComparer.Instance));
-            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception, out string diffReason), diffReason);
             Assert.Equal(result.OriginalBuildEventContext, deserializedResult.OriginalBuildEventContext);
         }
 
@@ -122,7 +122,7 @@ public void TestTranslationWithException()
 
             Assert.Equal(result.ResultCode, deserializedResult.ResultCode);
             Assert.True(TranslationHelpers.CompareCollections(result.Items, deserializedResult.Items, TaskItemComparer.Instance));
-            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception, out string diffReason), diffReason);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 42a4d6545d3..065958278e0 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -572,7 +572,7 @@ private DependencyAnalysisResult PerformDependencyAnalysisTestHelper(
                 ItemBucket itemBucket = new ItemBucket(null, null, new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
                 TargetUpToDateChecker analyzer = new TargetUpToDateChecker(p, p.Targets["Build"], _mockHost, BuildEventContext.Invalid);
 
-                return analyzer.PerformDependencyAnalysis(itemBucket, out changedTargetInputs, out upToDateTargetInputs);
+                return analyzer.PerformDependencyAnalysis(itemBucket, false, out changedTargetInputs, out upToDateTargetInputs);
             }
             finally
             {
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
index 8d7f7f5936d..64ffc8fba5c 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
@@ -17,228 +17,973 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class TaskBuilderTestTask : IGeneratedTask
     {
+        /// <summary>
+        /// A custom <see cref="IConvertible"/> value type.
+        /// </summary>
+        /// <remarks>
+        /// Types like this one can be used only as Output parameter types because they can be converted to string
+        /// but not from string.
+        /// </remarks>
+        [Serializable]
+        public struct CustomStruct : IConvertible
+        {
+            private readonly object _value;
+
+            /// <summary>
+            /// Using <see cref="IConvertible"/> as the type of the <see cref="_value"/> field triggers a BinaryFormatter bug.
+            /// </summary>
+            private IConvertible Value => (IConvertible)_value;
+
+            public CustomStruct(IConvertible value)
+            {
+                _value = value;
+            }
+
+            public TypeCode GetTypeCode() => Value.GetTypeCode();
+            public bool ToBoolean(IFormatProvider provider) => Value.ToBoolean(provider);
+            public byte ToByte(IFormatProvider provider) => Value.ToByte(provider);
+            public char ToChar(IFormatProvider provider) => Value.ToChar(provider);
+            public DateTime ToDateTime(IFormatProvider provider) => Value.ToDateTime(provider);
+            public decimal ToDecimal(IFormatProvider provider) => Value.ToDecimal(provider);
+            public double ToDouble(IFormatProvider provider) => Value.ToDouble(provider);
+            public short ToInt16(IFormatProvider provider) => Value.ToInt16(provider);
+            public int ToInt32(IFormatProvider provider) => Value.ToInt32(provider);
+            public long ToInt64(IFormatProvider provider) => Value.ToInt64(provider);
+            public sbyte ToSByte(IFormatProvider provider) => Value.ToSByte(provider);
+            public float ToSingle(IFormatProvider provider) => Value.ToSingle(provider);
+            public string ToString(IFormatProvider provider) => Value.ToString(provider);
+            public object ToType(Type conversionType, IFormatProvider provider) => Value.ToType(conversionType, provider);
+            public ushort ToUInt16(IFormatProvider provider) => Value.ToUInt16(provider);
+            public uint ToUInt32(IFormatProvider provider) => Value.ToUInt32(provider);
+            public ulong ToUInt64(IFormatProvider provider) => Value.ToUInt64(provider);
+        }
+
+        /// <summary>
+        /// The <see cref="CustomStruct"/> value returned from <see cref="CustomStructOutput"/>.
+        /// </summary>
+        internal static readonly CustomStruct s_customStruct = new CustomStruct(42);
+
+        /// <summary>
+        /// The <see cref="CustomStruct[]"/> value returned from <see cref="CustomStructArrayOutput"/>.
+        /// </summary>
+        internal static readonly CustomStruct[] s_customStructArray = new CustomStruct[] { new CustomStruct(43), new CustomStruct(44) };
+
         /// <summary>
         /// The task host.
         /// </summary>
-        private ITestTaskHost _testTaskHost;
+        private ITestTaskHost _testTaskHost;
+
+        /// <summary>
+        /// The value to return from Execute.
+        /// </summary>
+        private bool _executeReturnValue;
+
+        /// <summary>
+        /// The value for the BoolOutput.
+        /// </summary>
+        private bool _boolOutput;
+
+        /// <summary>
+        /// The value for the BoolArrayOutput.
+        /// </summary>
+        private bool[] _boolArrayOutput;
+
+        /// <summary>
+        /// The value for the ByteOutput.
+        /// </summary>
+        private byte _byteOutput;
+
+        /// <summary>
+        /// The value for the ByteArrayOutput.
+        /// </summary>
+        private byte[] _byteArrayOutput;
+
+        /// <summary>
+        /// The value for the SByteOutput.
+        /// </summary>
+        private sbyte _sbyteOutput;
+
+        /// <summary>
+        /// The value for the SByteArrayOutput.
+        /// </summary>
+        private sbyte[] _sbyteArrayOutput;
+
+        /// <summary>
+        /// The value for the DoubleOutput.
+        /// </summary>
+        private double _doubleOutput;
+
+        /// <summary>
+        /// The value for the DoubleArrayOutput.
+        /// </summary>
+        private double[] _doubleArrayOutput;
+
+        /// <summary>
+        /// The value for the FloatOutput.
+        /// </summary>
+        private float _floatOutput;
+
+        /// <summary>
+        /// The value for the FloatArrayOutput.
+        /// </summary>
+        private float[] _floatArrayOutput;
+
+        /// <summary>
+        /// The value for the ShortOutput.
+        /// </summary>
+        private short _shortOutput;
+
+        /// <summary>
+        /// The value for the ShortArrayOutput.
+        /// </summary>
+        private short[] _shortArrayOutput;
+
+        /// <summary>
+        /// The value for the UShortOutput.
+        /// </summary>
+        private ushort _ushortOutput;
+
+        /// <summary>
+        /// The value for the UShortArrayOutput.
+        /// </summary>
+        private ushort[] _ushortArrayOutput;
+
+        /// <summary>
+        /// The value for the IntOutput.
+        /// </summary>
+        private int _intOutput;
+
+        /// <summary>
+        /// The value for the IntArrayOutput.
+        /// </summary>
+        private int[] _intArrayOutput;
+
+        /// <summary>
+        /// The value for the UIntOutput.
+        /// </summary>
+        private uint _uintOutput;
+
+        /// <summary>
+        /// The value for the UIntArrayOutput.
+        /// </summary>
+        private uint[] _uintArrayOutput;
+
+        /// <summary>
+        /// The value for the LongOutput.
+        /// </summary>
+        private long _longOutput;
+
+        /// <summary>
+        /// The value for the LongArrayOutput.
+        /// </summary>
+        private long[] _longArrayOutput;
+
+        /// <summary>
+        /// The value for the ULongOutput.
+        /// </summary>
+        private ulong _ulongOutput;
+
+        /// <summary>
+        /// The value for the ULongArrayOutput.
+        /// </summary>
+        private ulong[] _ulongArrayOutput;
+
+        /// <summary>
+        /// The value for the DecimalOutput.
+        /// </summary>
+        private decimal _decimalOutput;
+
+        /// <summary>
+        /// The value for the DecimalArrayOutput.
+        /// </summary>
+        private decimal[] _decimalArrayOutput;
+
+        /// <summary>
+        /// The value for the CharOutput.
+        /// </summary>
+        private char _charOutput;
+
+        /// <summary>
+        /// The value for the CharArrayOutput.
+        /// </summary>
+        private char[] _charArrayOutput;
+
+        /// <summary>
+        /// The value for the StringOutput.
+        /// </summary>
+        private string _stringOutput;
+
+        /// <summary>
+        /// The value for the StringArrayOutput.
+        /// </summary>
+        private string[] _stringArrayOutput;
+
+        /// <summary>
+        /// The value for the DateTimeOutput.
+        /// </summary>
+        private DateTime _dateTimeOutput;
+
+        /// <summary>
+        /// The value for the DateTimeArrayOutput.
+        /// </summary>
+        private DateTime[] _dateTimeArrayOutput;
+
+        /// <summary>
+        /// The value for the ItemOutput.
+        /// </summary>
+        private ITaskItem _itemOutput;
+
+        /// <summary>
+        /// The value for the ItemArrayOutput.
+        /// </summary>
+        private ITaskItem[] _itemArrayOutput;
+
+        /// <summary>
+        /// Property determining if Execute() should throw or not.
+        /// </summary>
+        public bool ThrowOnExecute
+        {
+            internal get;
+            set;
+        }
+
+        /// <summary>
+        /// A boolean parameter.
+        /// </summary>
+        public bool BoolParam
+        {
+            set
+            {
+                _boolOutput = value;
+                _testTaskHost?.ParameterSet("BoolParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A boolean array parameter.
+        /// </summary>
+        public bool[] BoolArrayParam
+        {
+            set
+            {
+                _boolArrayOutput = value;
+                _testTaskHost?.ParameterSet("BoolArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A byte parameter.
+        /// </summary>
+        public byte ByteParam
+        {
+            set
+            {
+                _byteOutput = value;
+                _testTaskHost?.ParameterSet("ByteParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A byte array parameter.
+        /// </summary>
+        public byte[] ByteArrayParam
+        {
+            set
+            {
+                _byteArrayOutput = value;
+                _testTaskHost?.ParameterSet("ByteArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An sbyte parameter.
+        /// </summary>
+        public sbyte SByteParam
+        {
+            set
+            {
+                _sbyteOutput = value;
+                _testTaskHost?.ParameterSet("SByteParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An sbyte array parameter.
+        /// </summary>
+        public sbyte[] SByteArrayParam
+        {
+            set
+            {
+                _sbyteArrayOutput = value;
+                _testTaskHost?.ParameterSet("SByteArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A double parameter.
+        /// </summary>
+        public double DoubleParam
+        {
+            set
+            {
+                _doubleOutput = value;
+                _testTaskHost?.ParameterSet("DoubleParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A double array parameter.
+        /// </summary>
+        public double[] DoubleArrayParam
+        {
+            set
+            {
+                _doubleArrayOutput = value;
+                _testTaskHost?.ParameterSet("DoubleArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A float parameter.
+        /// </summary>
+        public float FloatParam
+        {
+            set
+            {
+                _floatOutput = value;
+                _testTaskHost?.ParameterSet("FloatParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A float array parameter.
+        /// </summary>
+        public float[] FloatArrayParam
+        {
+            set
+            {
+                _floatArrayOutput = value;
+                _testTaskHost?.ParameterSet("FloatArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A short parameter.
+        /// </summary>
+        public short ShortParam
+        {
+            set
+            {
+                _shortOutput = value;
+                _testTaskHost?.ParameterSet("ShortParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A short array parameter.
+        /// </summary>
+        public short[] ShortArrayParam
+        {
+            set
+            {
+                _shortArrayOutput = value;
+                _testTaskHost?.ParameterSet("ShortArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ushort parameter.
+        /// </summary>
+        public ushort UShortParam
+        {
+            set
+            {
+                _ushortOutput = value;
+                _testTaskHost?.ParameterSet("UShortParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ushort array parameter.
+        /// </summary>
+        public ushort[] UShortArrayParam
+        {
+            set
+            {
+                _ushortArrayOutput = value;
+                _testTaskHost?.ParameterSet("UShortArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An integer parameter.
+        /// </summary>
+        public int IntParam
+        {
+            set
+            {
+                _intOutput = value;
+                _testTaskHost?.ParameterSet("IntParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An integer array parameter.
+        /// </summary>
+        public int[] IntArrayParam
+        {
+            set
+            {
+                _intArrayOutput = value;
+                _testTaskHost?.ParameterSet("IntArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A uint parameter.
+        /// </summary>
+        public uint UIntParam
+        {
+            set
+            {
+                _uintOutput = value;
+                _testTaskHost?.ParameterSet("UIntParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A uint array parameter.
+        /// </summary>
+        public uint[] UIntArrayParam
+        {
+            set
+            {
+                _uintArrayOutput = value;
+                _testTaskHost?.ParameterSet("UIntArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A long parameter.
+        /// </summary>
+        public long LongParam
+        {
+            set
+            {
+                _longOutput = value;
+                _testTaskHost?.ParameterSet("LongParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A long array parameter.
+        /// </summary>
+        public long[] LongArrayParam
+        {
+            set
+            {
+                _longArrayOutput = value;
+                _testTaskHost?.ParameterSet("LongArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ulong parameter.
+        /// </summary>
+        public ulong ULongParam
+        {
+            set
+            {
+                _ulongOutput = value;
+                _testTaskHost?.ParameterSet("ULongParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ulong array parameter.
+        /// </summary>
+        public ulong[] ULongArrayParam
+        {
+            set
+            {
+                _ulongArrayOutput = value;
+                _testTaskHost?.ParameterSet("ULongArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A decimal parameter.
+        /// </summary>
+        public decimal DecimalParam
+        {
+            set
+            {
+                _decimalOutput = value;
+                _testTaskHost?.ParameterSet("DecimalParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A decimal array parameter.
+        /// </summary>
+        public decimal[] DecimalArrayParam
+        {
+            set
+            {
+                _decimalArrayOutput = value;
+                _testTaskHost?.ParameterSet("DecimalArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A char parameter.
+        /// </summary>
+        public char CharParam
+        {
+            set
+            {
+                _charOutput = value;
+                _testTaskHost?.ParameterSet("CharParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A char array parameter.
+        /// </summary>
+        public char[] CharArrayParam
+        {
+            set
+            {
+                _charArrayOutput = value;
+                _testTaskHost?.ParameterSet("CharArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A string parameter.
+        /// </summary>
+        public string StringParam
+        {
+            set
+            {
+                _stringOutput = value;
+                _testTaskHost?.ParameterSet("StringParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A string array parameter.
+        /// </summary>
+        public string[] StringArrayParam
+        {
+            set
+            {
+                _stringArrayOutput = value;
+                _testTaskHost?.ParameterSet("StringArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A DateTime parameter.
+        /// </summary>
+        public DateTime DateTimeParam
+        {
+            set
+            {
+                _dateTimeOutput = value;
+                _testTaskHost?.ParameterSet("DateTimeParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A DateTime array parameter.
+        /// </summary>
+        public DateTime[] DateTimeArrayParam
+        {
+            set
+            {
+                _dateTimeArrayOutput = value;
+                _testTaskHost?.ParameterSet("DateTimeArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An item parameter.
+        /// </summary>
+        public ITaskItem ItemParam
+        {
+            set
+            {
+                _itemOutput = value;
+                _testTaskHost?.ParameterSet("ItemParam", value);
+            }
+        }
 
         /// <summary>
-        /// The value to return from Execute
+        /// An item array parameter.
         /// </summary>
-        private bool _executeReturnValue;
+        public ITaskItem[] ItemArrayParam
+        {
+            set
+            {
+                _itemArrayOutput = value;
+                _testTaskHost?.ParameterSet("ItemArrayParam", value);
+            }
+        }
 
         /// <summary>
-        /// The value for the BoolOutput
+        /// The Execute return value parameter.
         /// </summary>
-        private bool _boolOutput;
+        [Required]
+        public bool ExecuteReturnParam
+        {
+            set
+            {
+                _executeReturnValue = value;
+                _testTaskHost?.ParameterSet("ExecuteReturnParam", value);
+            }
+        }
 
         /// <summary>
-        /// The value for the BoolArrayOutput
+        /// A boolean output.
         /// </summary>
-        private bool[] _boolArrayOutput;
+        [Output]
+        public bool BoolOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("BoolOutput", _boolOutput);
+                return _boolOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the IntOutput
+        /// A boolean array output.
         /// </summary>
-        private int _intOutput;
+        [Output]
+        public bool[] BoolArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("BoolArrayOutput", _boolArrayOutput);
+                return _boolArrayOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the IntArrayOutput
+        /// A byte output.
         /// </summary>
-        private int[] _intArrayOutput;
+        [Output]
+        public byte ByteOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("ByteOutput", _byteOutput);
+                return _byteOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the StringOutput
+        /// A byte array output.
         /// </summary>
-        private string _stringOutput;
+        [Output]
+        public byte[] ByteArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("ByteArrayOutput", _byteArrayOutput);
+                return _byteArrayOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the StringArrayOutput
+        /// An sbyte output.
         /// </summary>
-        private string[] _stringArrayOutput;
+        [Output]
+        public sbyte SByteOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("SByteOutput", _sbyteOutput);
+                return _sbyteOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the ItemOutput
+        /// An sbyte array output.
         /// </summary>
-        private ITaskItem _itemOutput;
+        [Output]
+        public sbyte[] SByteArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("SByteArrayOutput", _sbyteArrayOutput);
+                return _sbyteArrayOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the ItemArrayOutput
+        /// A double output.
         /// </summary>
-        private ITaskItem[] _itemArrayOutput;
+        [Output]
+        public double DoubleOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DoubleOutput", _doubleOutput);
+                return _doubleOutput;
+            }
+        }
 
         /// <summary>
-        /// Property determining if Execute() should throw or not.
+        /// A double array output.
         /// </summary>
-        public bool ThrowOnExecute
+        [Output]
+        public double[] DoubleArrayOutput
         {
-            internal get;
-            set;
+            get
+            {
+                _testTaskHost?.OutputRead("DoubleArrayOutput", _doubleArrayOutput);
+                return _doubleArrayOutput;
+            }
         }
 
         /// <summary>
-        /// A boolean parameter
+        /// A float output.
         /// </summary>
-        public bool BoolParam
+        [Output]
+        public float FloatOutput
         {
-            set
+            get
             {
-                _boolOutput = value;
-                _testTaskHost?.ParameterSet("BoolParam", value);
+                _testTaskHost?.OutputRead("FloatOutput", _floatOutput);
+                return _floatOutput;
             }
         }
 
         /// <summary>
-        /// A boolean array parameter
+        /// A float array output.
         /// </summary>
-        public bool[] BoolArrayParam
+        [Output]
+        public float[] FloatArrayOutput
         {
-            set
+            get
             {
-                _boolArrayOutput = value;
-                _testTaskHost?.ParameterSet("BoolArrayParam", value);
+                _testTaskHost?.OutputRead("FloatArrayOutput", _floatArrayOutput);
+                return _floatArrayOutput;
             }
         }
 
         /// <summary>
-        /// An integer parameter
+        /// A short output.
         /// </summary>
-        public int IntParam
+        [Output]
+        public short ShortOutput
         {
-            set
+            get
             {
-                _intOutput = value;
-                _testTaskHost?.ParameterSet("IntParam", value);
+                _testTaskHost?.OutputRead("ShortOutput", _shortOutput);
+                return _shortOutput;
             }
         }
 
         /// <summary>
-        /// An integer array parameter.
+        /// A short array output.
         /// </summary>
-        public int[] IntArrayParam
+        [Output]
+        public short[] ShortArrayOutput
         {
-            set
+            get
             {
-                _intArrayOutput = value;
-                _testTaskHost?.ParameterSet("IntArrayParam", value);
+                _testTaskHost?.OutputRead("ShortArrayOutput", _shortArrayOutput);
+                return _shortArrayOutput;
             }
         }
 
         /// <summary>
-        /// A string parameter.
+        /// A ushort output.
         /// </summary>
-        public string StringParam
+        [Output]
+        public ushort UShortOutput
         {
-            set
+            get
             {
-                _stringOutput = value;
-                _testTaskHost?.ParameterSet("StringParam", value);
+                _testTaskHost?.OutputRead("UShortOutput", _ushortOutput);
+                return _ushortOutput;
             }
         }
 
         /// <summary>
-        /// A string array parameter.
+        /// A ushort array output.
         /// </summary>
-        public string[] StringArrayParam
+        [Output]
+        public ushort[] UShortArrayOutput
         {
-            set
+            get
             {
-                _stringArrayOutput = value;
-                _testTaskHost?.ParameterSet("StringArrayParam", value);
+                _testTaskHost?.OutputRead("UShortArrayOutput", _ushortArrayOutput);
+                return _ushortArrayOutput;
             }
         }
 
         /// <summary>
-        /// An item parameter.
+        /// An integer output.
         /// </summary>
-        public ITaskItem ItemParam
+        [Output]
+        public int IntOutput
         {
-            set
+            get
             {
-                _itemOutput = value;
-                _testTaskHost?.ParameterSet("ItemParam", value);
+                _testTaskHost?.OutputRead("IntOutput", _intOutput);
+                return _intOutput;
             }
         }
 
         /// <summary>
-        /// An item array parameter.
+        /// An integer array output.
         /// </summary>
-        public ITaskItem[] ItemArrayParam
+        [Output]
+        public int[] IntArrayOutput
         {
-            set
+            get
             {
-                _itemArrayOutput = value;
-                _testTaskHost?.ParameterSet("ItemArrayParam", value);
+                _testTaskHost?.OutputRead("IntArrayOutput", _intArrayOutput);
+                return _intArrayOutput;
             }
         }
 
         /// <summary>
-        /// The Execute return value parameter.
+        /// A uint output.
         /// </summary>
-        [Required]
-        public bool ExecuteReturnParam
+        [Output]
+        public uint UIntOutput
         {
-            set
+            get
             {
-                _executeReturnValue = value;
-                _testTaskHost?.ParameterSet("ExecuteReturnParam", value);
+                _testTaskHost?.OutputRead("UIntOutput", _uintOutput);
+                return _uintOutput;
             }
         }
 
         /// <summary>
-        /// A boolean output.
+        /// A uint array output.
         /// </summary>
         [Output]
-        public bool BoolOutput
+        public uint[] UIntArrayOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("BoolOutput", _boolOutput);
-                return _boolOutput;
+                _testTaskHost?.OutputRead("UIntArrayOutput", _uintArrayOutput);
+                return _uintArrayOutput;
             }
         }
 
         /// <summary>
-        /// A boolean array output
+        /// A long output.
         /// </summary>
         [Output]
-        public bool[] BoolArrayOutput
+        public long LongOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("BoolArrayOutput", _boolArrayOutput);
-                return _boolArrayOutput;
+                _testTaskHost?.OutputRead("LongOutput", _longOutput);
+                return _longOutput;
             }
         }
 
         /// <summary>
-        /// An integer output
+        /// A long array output.
         /// </summary>
         [Output]
-        public int IntOutput
+        public long[] LongArrayOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("IntOutput", _intOutput);
-                return _intOutput;
+                _testTaskHost?.OutputRead("LongArrayOutput", _longArrayOutput);
+                return _longArrayOutput;
             }
         }
 
         /// <summary>
-        /// An integer array output
+        /// A ulong output.
         /// </summary>
         [Output]
-        public int[] IntArrayOutput
+        public ulong ULongOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("IntArrayOutput", _intArrayOutput);
-                return _intArrayOutput;
+                _testTaskHost?.OutputRead("ULongOutput", _ulongOutput);
+                return _ulongOutput;
+            }
+        }
+
+        /// <summary>
+        /// A ulong array output.
+        /// </summary>
+        [Output]
+        public ulong[] ULongArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("ULongArrayOutput", _ulongArrayOutput);
+                return _ulongArrayOutput;
+            }
+        }
+
+        /// <summary>
+        /// A decimal output.
+        /// </summary>
+        [Output]
+        public decimal DecimalOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DecimalOutput", _decimalOutput);
+                return _decimalOutput;
+            }
+        }
+
+        /// <summary>
+        /// A decimal array output.
+        /// </summary>
+        [Output]
+        public decimal[] DecimalArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DecimalArrayOutput", _decimalArrayOutput);
+                return _decimalArrayOutput;
+            }
+        }
+
+        /// <summary>
+        /// A char output.
+        /// </summary>
+        [Output]
+        public char CharOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CharOutput", _charOutput);
+                return _charOutput;
+            }
+        }
+
+        /// <summary>
+        /// A char array output.
+        /// </summary>
+        [Output]
+        public char[] CharArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CharArrayOutput", _charArrayOutput);
+                return _charArrayOutput;
             }
         }
 
         /// <summary>
-        /// A string output
+        /// A string output.
         /// </summary>
         [Output]
         public string StringOutput
@@ -290,7 +1035,59 @@ public string NullStringOutput
         }
 
         /// <summary>
-        /// A null ITaskItem output
+        /// A DateTime output
+        /// </summary>
+        [Output]
+        public DateTime DateTimeOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DateTimeOutput", _dateTimeOutput);
+                return _dateTimeOutput;
+            }
+        }
+
+        /// <summary>
+        /// A DateTime array output.
+        /// </summary>
+        [Output]
+        public DateTime[] DateTimeArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DateTimeArrayOutput", _dateTimeArrayOutput);
+                return _dateTimeArrayOutput;
+            }
+        }
+
+        /// <summary>
+        /// A CustomStruct output.
+        /// </summary>
+        [Output]
+        public CustomStruct CustomStructOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CustomStructOutput", s_customStruct);
+                return s_customStruct;
+            }
+        }
+
+        /// <summary>
+        /// A CustomStruct array output.
+        /// </summary>
+        [Output]
+        public CustomStruct[] CustomStructArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CustomStructArrayOutput", s_customStructArray);
+                return s_customStructArray;
+            }
+        }
+
+        /// <summary>
+        /// A null ITaskItem output.
         /// </summary>
         [Output]
         public ITaskItem NullITaskItemOutput
@@ -303,7 +1100,7 @@ public ITaskItem NullITaskItemOutput
         }
 
         /// <summary>
-        /// A null string array output
+        /// A null string array output.
         /// </summary>
         [Output]
         public string[] NullStringArrayOutput
@@ -316,7 +1113,7 @@ public string[] NullStringArrayOutput
         }
 
         /// <summary>
-        /// A null ITaskItem array output
+        /// A null ITaskItem array output.
         /// </summary>
         [Output]
         public ITaskItem[] NullITaskItemArrayOutput
@@ -329,7 +1126,7 @@ public ITaskItem[] NullITaskItemArrayOutput
         }
 
         /// <summary>
-        /// A string array output
+        /// A string array output.
         /// </summary>
         [Output]
         public string[] StringArrayOutput
@@ -342,7 +1139,7 @@ public string[] StringArrayOutput
         }
 
         /// <summary>
-        /// A task item output
+        /// A task item output.
         /// </summary>
         [Output]
         public ITaskItem ItemOutput
@@ -355,7 +1152,7 @@ public ITaskItem ItemOutput
         }
 
         /// <summary>
-        /// A task item array output
+        /// A task item array output.
         /// </summary>
         [Output]
         public ITaskItem[] ItemArrayOutput
@@ -368,7 +1165,7 @@ public ITaskItem[] ItemArrayOutput
         }
 
         /// <summary>
-        /// A task item array output that is null
+        /// A task item array output that is null.
         /// </summary>
         [Output]
         public ITaskItem[] ItemArrayNullOutput
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index c91df2ca317..1e6b56edd0e 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -164,7 +164,6 @@ public void CanceledTasksDoNotLogMSB4181()
                     Loggers = new ILogger[] { logger },
                     EnableNodeReuse = false
                 };
-                ;
 
                 BuildRequestData data = new BuildRequestData(project.CreateProjectInstance(), new string[] { "test" }, collection.HostServices);
                 manager.BeginBuild(_parameters);
@@ -597,6 +596,31 @@ public void NullMetadataOnLegacyOutputItems()
             logger.AssertLogContains("[foo: ]");
         }
 
+        /// <summary>
+        /// If an item returned from a task has bare-minimum metadata implementation, we shouldn't crash.
+        /// </summary>
+        [Fact]
+        public void MinimalLegacyOutputItems()
+        {
+            string customTaskPath = Assembly.GetExecutingAssembly().Location;
+
+            string projectContents = $"""
+                                     <Project>
+                                       <UsingTask TaskName="TaskThatReturnsMinimalItem" AssemblyFile="{customTaskPath}" />
+
+                                       <Target Name="Build">
+                                         <TaskThatReturnsMinimalItem>
+                                           <Output TaskParameter="MinimalTaskItemOutput" ItemName="Outputs"/>
+                                         </TaskThatReturnsMinimalItem>
+
+                                         <Message Text="[%(Outputs.Identity): %(Outputs.a)]" Importance="High" />
+                                       </Target>
+                                     </Project>
+                                     """;
+
+            MockLogger logger = ObjectModelHelpers.BuildProjectExpectSuccess(projectContents, _testOutput, LoggerVerbosity.Diagnostic);
+        }
+
         /// <summary>
         /// Regression test for https://github.com/dotnet/msbuild/issues/5080
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index 7ca94153d09..f4644d4e358 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1029,6 +1029,25 @@ public void TestTaskResolutionFailureWithNoUsingTask()
             _logger.AssertLogContains("MSB4036");
         }
 
+        /// <summary>
+        /// https://github.com/dotnet/msbuild/issues/8864
+        /// </summary>
+        [Fact]
+        public void TestTaskDictionaryOutputItems()
+        {
+            string customTaskPath = Assembly.GetExecutingAssembly().Location;
+            MockLogger ml = ObjectModelHelpers.BuildProjectExpectSuccess($"""
+                    <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                        <UsingTask TaskName=`TaskThatReturnsDictionaryTaskItem` AssemblyFile=`{customTaskPath}`/>
+                        <Target Name=`Build`>
+                           <TaskThatReturnsDictionaryTaskItem Key="a" Value="b">
+                                <Output TaskParameter="DictionaryTaskItemOutput" ItemName="Outputs"/>
+                            </TaskThatReturnsDictionaryTaskItem>
+                        </Target>
+                    </Project>
+                """);
+            ml.AssertLogContains("a=b");
+        }
         #endregion
 
         #region ITestTaskHost Members
@@ -1423,11 +1442,11 @@ private ProjectInstance CreateTestProject()
                     <Target Name='Skip' Inputs='testProject.proj' Outputs='testProject.proj' />
 
                     <Target Name='Error' >
-                        <ErrorTask1 ContinueOnError='True'/>                    
-                        <ErrorTask2 ContinueOnError='False'/>  
-                        <ErrorTask3 /> 
-                        <OnError ExecuteTargets='Foo'/>                  
-                        <OnError ExecuteTargets='Bar'/>                  
+                        <ErrorTask1 ContinueOnError='True'/>
+                        <ErrorTask2 ContinueOnError='False'/>
+                        <ErrorTask3 />
+                        <OnError ExecuteTargets='Foo'/>
+                        <OnError ExecuteTargets='Bar'/>
                     </Target>
 
                     <Target Name='Foo' Inputs='foo.cpp' Outputs='foo.o'>
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index a3226a7df75..5c82a444f39 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -3,7 +3,10 @@
 
 using System;
 using System.Diagnostics;
+using System.Globalization;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.BackEnd;
 
@@ -58,37 +61,170 @@ public void TaskNodesDieAfterBuild()
             }
         }
 
-        [Fact]
-        public void VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost()
+        [DotNetOnlyTheory]
+        [InlineData(false)]
+        // [InlineData(true)] <-- explicitly opting out on core will lead to node crash
+        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost_NetCore(
+            bool testLegacyImplementation)
+            => VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(testLegacyImplementation);
+
+        [WindowsFullFrameworkOnlyTheory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost_Framework(
+            bool testLegacyImplementation)
+            => VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(testLegacyImplementation);
+
+        private void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(bool testLegacyImplementation)
         {
             using TestEnvironment env = TestEnvironment.Create(_output);
 
+            ChangeWaves.ResetStateForTests();
+            if (testLegacyImplementation)
+            {
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+
+            string boolParam = "True";
+            string boolArrayParam = "False;True;False";
+            string byteParam = "42";
+            string byteArrayParam = "11;22;33";
+            string sbyteParam = "-42";
+            string sbyteArrayParam = "-11;-22;-33";
+            string doubleParam = "3.14";
+            string doubleArrayParam = "3.14;2.72";
+            string floatParam = "0.5";
+            string floatArrayParam = "0.6;0.7;0.8";
+            string shortParam = "-100";
+            string shortArrayParam = "-200;-300;999";
+            string ushortParam = "100";
+            string ushortArrayParam = "200;300;999";
+            string intParam = "-314";
+            string intArrayParam = "42;-67;98";
+            string uintParam = "314";
+            string uintArrayParam = "4200000;67;98";
+            string longParam = "-120000000000";
+            string longArrayParam = "-120000000000;0;1";
+            string ulongParam = "120000000000";
+            string ulongArrayParam = "120000000000;0;1";
+            string decimalParam = "0.999999999999";
+            string decimalArrayParam = "-0.999999999999";
+            string charParam = "A";
+            string charArrayParam = "A;b;2";
+            string stringParam = "stringParamInput";
+            string stringArrayParam = "stringArrayParamInput1;stringArrayParamInput2;stringArrayParamInput3";
+            string dateTimeParam = "01/01/2001 10:15:00";
+            string dateTimeArrayParam = "01/01/2001 10:15:00;02/02/2002 11:30:00;03/03/2003 12:45:00";
+
             string projectContents = $@"
 <Project>
     <UsingTask TaskName=""{nameof(TaskBuilderTestTask)}"" AssemblyFile=""{typeof(TaskBuilderTestTask).Assembly.Location}"" TaskFactory=""TaskHostFactory"" />
-    <Target Name='{nameof(VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost)}'>
+    <Target Name='{nameof(VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost)}'>
         <{nameof(TaskBuilderTestTask)}
             ExecuteReturnParam=""true""
-            BoolParam=""true""
-            BoolArrayParam=""false;true;false""
-            IntParam=""314""
-            IntArrayParam=""42;67;98""
-            StringParam=""stringParamInput""
-            StringArrayParam=""stringArrayParamInput1;stringArrayParamInput2;stringArrayParamInput3"">
+            BoolParam=""{boolParam}""
+            BoolArrayParam=""{boolArrayParam}""
+            ByteParam=""{byteParam}""
+            ByteArrayParam=""{byteArrayParam}""
+            SByteParam=""{sbyteParam}""
+            SByteArrayParam=""{sbyteArrayParam}""
+            DoubleParam=""{doubleParam}""
+            DoubleArrayParam=""{doubleArrayParam}""
+            FloatParam=""{floatParam}""
+            FloatArrayParam=""{floatArrayParam}""
+            ShortParam=""{shortParam}""
+            ShortArrayParam=""{shortArrayParam}""
+            UShortParam=""{ushortParam}""
+            UShortArrayParam=""{ushortArrayParam}""
+            IntParam=""{intParam}""
+            IntArrayParam=""{intArrayParam}""
+            UIntParam=""{uintParam}""
+            UIntArrayParam=""{uintArrayParam}""
+            LongParam=""{longParam}""
+            LongArrayParam=""{longArrayParam}""
+            ULongParam=""{ulongParam}""
+            ULongArrayParam=""{ulongArrayParam}""
+            DecimalParam=""{decimalParam}""
+            DecimalArrayParam=""{decimalArrayParam}""
+            CharParam=""{charParam}""
+            CharArrayParam=""{charArrayParam}""
+            StringParam=""{stringParam}""
+            StringArrayParam=""{stringArrayParam}""
+            DateTimeParam=""{dateTimeParam}""
+            DateTimeArrayParam=""{dateTimeArrayParam}"">
 
             <Output PropertyName=""BoolOutput"" TaskParameter=""BoolOutput"" />
             <Output PropertyName=""BoolArrayOutput"" TaskParameter=""BoolArrayOutput"" />
+            <Output PropertyName=""ByteOutput"" TaskParameter=""ByteOutput"" />
+            <Output PropertyName=""ByteArrayOutput"" TaskParameter=""ByteArrayOutput"" />
+            <Output PropertyName=""SByteOutput"" TaskParameter=""SByteOutput"" />
+            <Output PropertyName=""SByteArrayOutput"" TaskParameter=""SByteArrayOutput"" />
+            <Output PropertyName=""DoubleOutput"" TaskParameter=""DoubleOutput"" />
+            <Output PropertyName=""DoubleArrayOutput"" TaskParameter=""DoubleArrayOutput"" />
+            <Output PropertyName=""FloatOutput"" TaskParameter=""FloatOutput"" />
+            <Output PropertyName=""FloatArrayOutput"" TaskParameter=""FloatArrayOutput"" />
+            <Output PropertyName=""ShortOutput"" TaskParameter=""ShortOutput"" />
+            <Output PropertyName=""ShortArrayOutput"" TaskParameter=""ShortArrayOutput"" />
+            <Output PropertyName=""UShortOutput"" TaskParameter=""UShortOutput"" />
+            <Output PropertyName=""UShortArrayOutput"" TaskParameter=""UShortArrayOutput"" />
             <Output PropertyName=""IntOutput"" TaskParameter=""IntOutput"" />
             <Output PropertyName=""IntArrayOutput"" TaskParameter=""IntArrayOutput"" />
-            <Output PropertyName=""EnumOutput"" TaskParameter=""EnumOutput"" />
+            <Output PropertyName=""UIntOutput"" TaskParameter=""UIntOutput"" />
+            <Output PropertyName=""UIntArrayOutput"" TaskParameter=""UIntArrayOutput"" />
+            <Output PropertyName=""LongOutput"" TaskParameter=""LongOutput"" />
+            <Output PropertyName=""LongArrayOutput"" TaskParameter=""LongArrayOutput"" />
+            <Output PropertyName=""ULongOutput"" TaskParameter=""ULongOutput"" />
+            <Output PropertyName=""ULongArrayOutput"" TaskParameter=""ULongArrayOutput"" />
+            <Output PropertyName=""DecimalOutput"" TaskParameter=""DecimalOutput"" />
+            <Output PropertyName=""DecimalArrayOutput"" TaskParameter=""DecimalArrayOutput"" />
+            <Output PropertyName=""CharOutput"" TaskParameter=""CharOutput"" />
+            <Output PropertyName=""CharArrayOutput"" TaskParameter=""CharArrayOutput"" />
             <Output PropertyName=""StringOutput"" TaskParameter=""StringOutput"" />
             <Output PropertyName=""StringArrayOutput"" TaskParameter=""StringArrayOutput"" />
+            <Output PropertyName=""DateTimeOutput"" TaskParameter=""DateTimeOutput"" />
+            <Output PropertyName=""DateTimeArrayOutput"" TaskParameter=""DateTimeArrayOutput"" />
+            <Output PropertyName=""CustomStructOutput"" TaskParameter=""CustomStructOutput"" />
+            <Output PropertyName=""EnumOutput"" TaskParameter=""EnumOutput"" />
         </{nameof(TaskBuilderTestTask)}>
     </Target>
 </Project>";
             TransientTestProjectWithFiles project = env.CreateTestProjectWithFiles(projectContents);
             ProjectInstance projectInstance = new(project.ProjectFile);
             projectInstance.Build(new[] { new MockLogger(env.Output) }).ShouldBeTrue();
+
+            projectInstance.GetPropertyValue("BoolOutput").ShouldBe(boolParam);
+            projectInstance.GetPropertyValue("BoolArrayOutput").ShouldBe(boolArrayParam);
+            projectInstance.GetPropertyValue("ByteOutput").ShouldBe(byteParam);
+            projectInstance.GetPropertyValue("ByteArrayOutput").ShouldBe(byteArrayParam);
+            projectInstance.GetPropertyValue("SByteOutput").ShouldBe(sbyteParam);
+            projectInstance.GetPropertyValue("SByteArrayOutput").ShouldBe(sbyteArrayParam);
+            projectInstance.GetPropertyValue("DoubleOutput").ShouldBe(doubleParam);
+            projectInstance.GetPropertyValue("DoubleArrayOutput").ShouldBe(doubleArrayParam);
+            projectInstance.GetPropertyValue("FloatOutput").ShouldBe(floatParam);
+            projectInstance.GetPropertyValue("FloatArrayOutput").ShouldBe(floatArrayParam);
+            projectInstance.GetPropertyValue("ShortOutput").ShouldBe(shortParam);
+            projectInstance.GetPropertyValue("ShortArrayOutput").ShouldBe(shortArrayParam);
+            projectInstance.GetPropertyValue("UShortOutput").ShouldBe(ushortParam);
+            projectInstance.GetPropertyValue("UShortArrayOutput").ShouldBe(ushortArrayParam);
+            projectInstance.GetPropertyValue("IntOutput").ShouldBe(intParam);
+            projectInstance.GetPropertyValue("IntArrayOutput").ShouldBe(intArrayParam);
+            projectInstance.GetPropertyValue("UIntOutput").ShouldBe(uintParam);
+            projectInstance.GetPropertyValue("UIntArrayOutput").ShouldBe(uintArrayParam);
+            projectInstance.GetPropertyValue("LongOutput").ShouldBe(longParam);
+            projectInstance.GetPropertyValue("LongArrayOutput").ShouldBe(longArrayParam);
+            projectInstance.GetPropertyValue("ULongOutput").ShouldBe(ulongParam);
+            projectInstance.GetPropertyValue("ULongArrayOutput").ShouldBe(ulongArrayParam);
+            projectInstance.GetPropertyValue("DecimalOutput").ShouldBe(decimalParam);
+            projectInstance.GetPropertyValue("DecimalArrayOutput").ShouldBe(decimalArrayParam);
+            projectInstance.GetPropertyValue("CharOutput").ShouldBe(charParam);
+            projectInstance.GetPropertyValue("CharArrayOutput").ShouldBe(charArrayParam);
+            projectInstance.GetPropertyValue("StringOutput").ShouldBe(stringParam);
+            projectInstance.GetPropertyValue("StringArrayOutput").ShouldBe(stringArrayParam);
+            projectInstance.GetPropertyValue("DateTimeOutput").ShouldBe(dateTimeParam);
+            projectInstance.GetPropertyValue("DateTimeArrayOutput").ShouldBe(dateTimeArrayParam);
+            projectInstance.GetPropertyValue("CustomStructOutput").ShouldBe(TaskBuilderTestTask.s_customStruct.ToString(CultureInfo.InvariantCulture));
+            projectInstance.GetPropertyValue("EnumOutput").ShouldBe(TargetBuiltReason.BeforeTargets.ToString());
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
index 5c6bf006b2c..7504cd8bb3d 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Xunit;
@@ -25,21 +26,67 @@ public class TaskHostTaskComplete_Tests
         [Fact]
         public void TestConstructors()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success), null);
-            TaskHostTaskComplete complete2 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure), null);
-            TaskHostTaskComplete complete3 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringInitialization, new ArgumentOutOfRangeException()), null);
-            TaskHostTaskComplete complete4 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringExecution, new ArgumentNullException()), null);
+#if FEATURE_REPORTFILEACCESSES
+            var fileAccessData = new List<FileAccessData>()
+            {
+                new FileAccessData(
+                    ReportedFileOperation.CreateFile,
+                    RequestedAccess.Read,
+                    0,
+                    0,
+                    DesiredAccess.GENERIC_READ,
+                    FlagsAndAttributes.FILE_ATTRIBUTE_NORMAL,
+                    "foo",
+                    null,
+                    true),
+            };
+#endif
+
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringInitialization,
+                new ArgumentOutOfRangeException()),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringExecution, new ArgumentNullException()),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
 
             IDictionary<string, object> parameters = new Dictionary<string, object>();
-            TaskHostTaskComplete complete5 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             IDictionary<string, object> parameters2 = new Dictionary<string, object>();
             parameters2.Add("Text", "Hello!");
             parameters2.Add("MyBoolValue", true);
             parameters2.Add("MyITaskItem", new TaskItem("ABC"));
             parameters2.Add("ItemArray", new ITaskItem[] { new TaskItem("DEF"), new TaskItem("GHI"), new TaskItem("JKL") });
-
-            TaskHostTaskComplete complete6 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters2), null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters2),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
         }
 
         /// <summary>
@@ -60,7 +107,12 @@ public void TestInvalidConstructors()
         [Fact]
         public void TestTranslationWithNullDictionary()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -78,7 +130,12 @@ public void TestTranslationWithNullDictionary()
         [Fact]
         public void TestTranslationWithEmptyDictionary()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, new Dictionary<string, object>()), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, new Dictionary<string, object>()),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -99,7 +156,12 @@ public void TestTranslationWithValueTypesInDictionary()
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("Text", "Foo");
             parameters.Add("BoolValue", false);
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -121,7 +183,12 @@ public void TestTranslationWithITaskItemInDictionary()
         {
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemValue", new TaskItem("Foo"));
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -142,7 +209,12 @@ public void TestTranslationWithITaskItemArrayInDictionary()
         {
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemArrayValue", new ITaskItem[] { new TaskItem("Foo"), new TaskItem("Baz") });
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -168,7 +240,12 @@ private void AssertInvalidConstructorThrows(Type expectedExceptionType, TaskComp
 
             try
             {
-                TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(taskResult, taskOutputParameters, taskException, taskExceptionMessage, taskExceptionMessageArgs), buildProcessEnvironment);
+                TaskHostTaskComplete complete = new(
+                    new OutOfProcTaskHostTaskResult(taskResult, taskOutputParameters, taskException, taskExceptionMessage, taskExceptionMessageArgs),
+#if FEATURE_REPORTFILEACCESSES
+                    null,
+#endif
+                    buildProcessEnvironment);
             }
             catch (Exception e)
             {
diff --git a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
index 8f4a5d6c1aa..3fe12dd13fe 100644
--- a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
@@ -385,6 +385,61 @@ public void TestLogCustomEventNotSerializableSP()
             Assert.Equal("testCustomBuildEvent", _customLogger.LastCustom.Message);
         }
 
+        /// <summary>
+        /// Test that extended custom events are logged properly
+        /// </summary>
+        [Fact]
+        public void TestLogExtendedCustomEventNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogCustomEvent(new ExtendedCustomBuildEventArgs("testExtCustomBuildEvent", "ext message", null, null));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastCustom is ExtendedCustomBuildEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext message", _customLogger.LastCustom.Message);
+        }
+
+        [Fact]
+        public void TestLogExtendedCustomErrorNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogErrorEvent(new ExtendedBuildErrorEventArgs("testExtCustomBuildError", null, null, null, 0, 0, 0, 0,"ext err message", null, null));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastError is ExtendedBuildErrorEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext err message", _customLogger.LastError.Message);
+        }
+
+        [Fact]
+        public void TestLogExtendedCustomWarningNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogWarningEvent(new ExtendedBuildWarningEventArgs("testExtCustomBuildWarning", null, null, null, 0, 0, 0, 0, "ext warn message", null, null));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastWarning is ExtendedBuildWarningEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext warn message", _customLogger.LastWarning.Message);
+        }
+
+        [Fact]
+        public void TestLogExtendedCustomMessageNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogMessageEvent(new ExtendedBuildMessageEventArgs("testExtCustomBuildMessage", "ext message", null, null, MessageImportance.Normal));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastMessage is ExtendedBuildMessageEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext message", _customLogger.LastMessage.Message);
+        }
+
         /// <summary>
         /// Test that errors are logged properly
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index 993c4ee1593..1e8bcaf1f14 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -2182,18 +2182,15 @@ internal TaskRegistry CreateTaskRegistryAndRegisterTasks(List<ProjectUsingTaskEl
                 ? new TaskRegistry(toolset, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache)
                 : new TaskRegistry(ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
-            foreach (ProjectUsingTaskElement projectUsingTaskElement in usingTaskElements)
-            {
-                TaskRegistry.RegisterTasksFromUsingTaskElement(
-                        _loggingService,
-                        _loggerContext,
-                        Directory.GetCurrentDirectory(),
-                        projectUsingTaskElement,
-                        registry,
-                        RegistryExpander,
-                        ExpanderOptions.ExpandPropertiesAndItems,
-                        FileSystems.Default);
-            }
+            string currentDir = Directory.GetCurrentDirectory();
+            TaskRegistry.InitializeTaskRegistryFromUsingTaskElements(
+                _loggingService,
+                _loggerContext,
+                usingTaskElements.Select(el => (el, currentDir)),
+                registry,
+                RegistryExpander,
+                ExpanderOptions.ExpandPropertiesAndItems,
+                FileSystems.Default);
 
             return registry;
         }
diff --git a/src/Build.UnitTests/BackEnd/TaskThatReturnsDictionaryTaskItem.cs b/src/Build.UnitTests/BackEnd/TaskThatReturnsDictionaryTaskItem.cs
new file mode 100644
index 00000000000..c258beb89a4
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/TaskThatReturnsDictionaryTaskItem.cs
@@ -0,0 +1,210 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.Framework;
+
+#nullable disable
+
+namespace Microsoft.Build.Engine.UnitTests;
+/// <summary>
+/// Task that returns a custom ITaskItem implementation that has a custom IDictionary type returned from CloneCustomMetadata()
+/// </summary>
+public sealed class TaskThatReturnsDictionaryTaskItem : Utilities.Task
+{
+    public string Key { get; set; }
+    public string Value { get; set; }
+
+    public override bool Execute()
+    {
+        var metaValue = new MinimalDictionary<string, string>
+        {
+            { Key, Value }
+        };
+        DictionaryTaskItemOutput = new MinimalDictionaryTaskItem(metaValue);
+        return true;
+    }
+
+    [Output]
+    public ITaskItem DictionaryTaskItemOutput { get; set; }
+
+    internal sealed class MinimalDictionaryTaskItem : ITaskItem
+    {
+        private MinimalDictionary<string, string> _metaData = new MinimalDictionary<string, string>();
+
+        public MinimalDictionaryTaskItem(MinimalDictionary<string, string> metaValue)
+        {
+            _metaData = metaValue;
+        }
+
+        public string ItemSpec { get => $"{nameof(MinimalDictionaryTaskItem)}spec"; set => throw new NotImplementedException(); }
+
+        public ICollection MetadataNames => throw new NotImplementedException();
+
+        public int MetadataCount => throw new NotImplementedException();
+
+        ICollection ITaskItem.MetadataNames => throw new NotImplementedException();
+
+        public IDictionary CloneCustomMetadata() => _metaData;
+
+        public string GetMetadata(string metadataName)
+        {
+            if (String.IsNullOrEmpty(metadataName))
+            {
+                throw new ArgumentNullException(nameof(metadataName));
+            }
+
+            string value = (string)_metaData[metadataName];
+            return value;
+        }
+
+        public void SetMetadata(string metadataName, string metadataValue) => throw new NotImplementedException();
+        public void RemoveMetadata(string metadataName) => throw new NotImplementedException();
+        public void CopyMetadataTo(ITaskItem destinationItem) => throw new NotImplementedException();
+    }
+}
+
+public sealed class MinimalDictionary<TKey, TValue> : IDictionary
+{
+    private List<TKey> _keys = new List<TKey>();
+    private List<TValue> _values = new List<TValue>();
+
+    public object this[object key]
+    {
+        get
+        {
+            int index = _keys.IndexOf((TKey)key);
+            return index == -1 ? throw new KeyNotFoundException() : (object)_values[index];
+        }
+        set
+        {
+            int index = _keys.IndexOf((TKey)key);
+            if (index == -1)
+            {
+                _keys.Add((TKey)key);
+                _values.Add((TValue)value);
+            }
+            else
+            {
+                _values[index] = (TValue)value;
+            }
+        }
+    }
+
+    public bool IsFixedSize => false;
+
+    public bool IsReadOnly => false;
+
+    public ICollection Keys => _keys;
+
+    public ICollection Values => _values;
+
+    public int Count => _keys.Count;
+
+    public bool IsSynchronized => false;
+
+    public object SyncRoot => throw new NotSupportedException();
+
+    public void Add(object key, object value)
+    {
+        if (_keys.Contains((TKey)key))
+        {
+            throw new ArgumentException("An item with the same key has already been added.");
+        }
+
+        _keys.Add((TKey)key);
+        _values.Add((TValue)value);
+    }
+
+    public void Clear()
+    {
+        _keys.Clear();
+        _values.Clear();
+    }
+
+    public bool Contains(object key)
+    {
+        return _keys.Contains((TKey)key);
+    }
+
+    public void CopyTo(Array array, int index)
+    {
+        if (array == null)
+        {
+            throw new ArgumentNullException(nameof(array));
+        }
+
+        if (array.Rank != 1)
+        {
+            throw new ArgumentException("Array must be one-dimensional.", nameof(array));
+        }
+
+        if (index < 0 || index > array.Length)
+        {
+            throw new ArgumentOutOfRangeException(nameof(index));
+        }
+
+        if (array.Length - index < Count)
+        {
+            throw new ArgumentException("The number of elements in the source is greater than the available space from index to the end of the destination array.");
+        }
+
+        for (int i = 0; i < Count; i++)
+        {
+            array.SetValue(new KeyValuePair<TKey, TValue>(_keys[i], _values[i]), index + i);
+        }
+    }
+
+    public IDictionaryEnumerator GetEnumerator() => new MinimalDictionaryEnumerator(_keys, _values);
+
+    public void Remove(object key)
+    {
+        int index = _keys.IndexOf((TKey)key);
+        if (index != -1)
+        {
+            _keys.RemoveAt(index);
+            _values.RemoveAt(index);
+        }
+    }
+
+    IEnumerator IEnumerable.GetEnumerator()
+    {
+        for (int i = 0; i < Count; i++)
+        {
+            yield return new KeyValuePair<TKey, TValue>(_keys[i], _values[i]);
+        }
+    }
+
+    private sealed class MinimalDictionaryEnumerator : IDictionaryEnumerator
+    {
+        private List<TKey> _keys;
+        private List<TValue> _values;
+        private int _index = -1;
+
+        public MinimalDictionaryEnumerator(List<TKey> keys, List<TValue> values)
+        {
+            _keys = keys;
+            _values = values;
+        }
+
+        public object Current => Entry;
+
+        public object Key => _keys[_index];
+
+        public object Value => _values[_index];
+
+        public DictionaryEntry Entry => new DictionaryEntry(Key, Value);
+
+        public bool MoveNext()
+        {
+            return ++_index < _keys.Count;
+        }
+
+        public void Reset()
+        {
+            _index = -1;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
index 60f073a0cf2..7d4736837ce 100644
--- a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
+++ b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
@@ -9,6 +9,7 @@
 using System.Text;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
+using Xunit;
 
 #nullable disable
 
@@ -40,7 +41,7 @@ internal static ITranslator GetWriteTranslator()
         internal static ITranslator GetReadTranslator()
         {
             s_serializationStream.Seek(0, SeekOrigin.Begin);
-            return BinaryTranslator.GetReadTranslator(s_serializationStream, null);
+            return BinaryTranslator.GetReadTranslator(s_serializationStream, InterningBinaryReader.PoolingBuffer);
         }
 
         /// <summary>
@@ -85,8 +86,9 @@ internal static bool CompareCollections<T>(ICollection<T> left, ICollection<T> r
         /// <summary>
         /// Compares two exceptions.
         /// </summary>
-        internal static bool CompareExceptions(Exception left, Exception right)
+        internal static bool CompareExceptions(Exception left, Exception right, out string diffReason, bool detailed = false)
         {
+            diffReason = null;
             if (ReferenceEquals(left, right))
             {
                 return true;
@@ -94,20 +96,74 @@ internal static bool CompareExceptions(Exception left, Exception right)
 
             if ((left == null) ^ (right == null))
             {
+                diffReason = "One exception is null and the other is not.";
                 return false;
             }
 
             if (left.Message != right.Message)
             {
+                diffReason = $"Exception messages are different ({left.Message} vs {right.Message}).";
                 return false;
             }
 
             if (left.StackTrace != right.StackTrace)
             {
+                diffReason = $"Exception stack traces are different ({left.StackTrace} vs {right.StackTrace}).";
                 return false;
             }
 
-            return CompareExceptions(left.InnerException, right.InnerException);
+            if (!CompareExceptions(left.InnerException, right.InnerException, out diffReason, detailed))
+            {
+                diffReason = "Inner exceptions are different: " + diffReason;
+                return false;
+            }
+
+            if (detailed)
+            {
+                if (left.GetType() != right.GetType())
+                {
+                    diffReason = $"Exception types are different ({left.GetType().FullName} vs {right.GetType().FullName}).";
+                    return false;
+                }
+
+                foreach (var prop in left.GetType().GetProperties())
+                {
+                    if (!IsSimpleType(prop.PropertyType))
+                    {
+                        continue;
+                    }
+
+                    object leftProp = prop.GetValue(left, null);
+                    object rightProp = prop.GetValue(right, null);
+
+                    if (leftProp == null && rightProp != null)
+                    {
+                        diffReason = $"Property {prop.Name} is null on left but not on right.";
+                        return false;
+                    }
+
+                    if (leftProp != null && !prop.GetValue(left, null).Equals(prop.GetValue(right, null)))
+                    {
+                        diffReason = $"Property {prop.Name} is different ({prop.GetValue(left, null)} vs {prop.GetValue(rightProp, null)}).";
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        internal static bool IsSimpleType(Type type)
+        {
+            // Nullables
+            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
+            {
+                return IsSimpleType(type.GetGenericArguments()[0]);
+            }
+            return type.IsPrimitive
+                   || type.IsEnum
+                   || type == typeof(string)
+                   || type == typeof(decimal);
         }
 
         internal static string GetPropertiesString(IEnumerable properties)
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 10e697437e2..57e2bc3fa82 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -228,12 +228,24 @@ public void AssemblyLoadsDuringTaskRunLogged()
                 BinaryLogger logger = new();
                 logger.Parameters = _logFile;
                 env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
-                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{logger.Parameters}", out bool success);
-                success.ShouldBeTrue();
-                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile2.log")};verbosity=normal", out bool success);
                 success.ShouldBeTrue();
+
+                string assemblyLoadedEventText =
+                    "Assembly loaded during TaskRun (InlineCode.HelloWorld): System.Diagnostics.Debug";
                 string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
-                text.ShouldContain("Assembly loaded during TaskRun (InlineCode.HelloWorld): System.Diagnostics.Debug");
+                text.ShouldContain(assemblyLoadedEventText);
+                // events should not be in logger with verbosity normal
+                string text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile2.log"));
+                text2.ShouldNotContain(assemblyLoadedEventText);
+
+                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile3.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile4.log")};verbosity=normal", out success);
+                success.ShouldBeTrue();
+                text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile3.log"));
+                text.ShouldContain(assemblyLoadedEventText);
+                // events should not be in logger with verbosity normal
+                text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile4.log"));
+                text2.ShouldNotContain(assemblyLoadedEventText);
             }
         }
 
@@ -262,7 +274,8 @@ public void BinaryLoggerShouldEmbedFilesViaTaskOutput()
 
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
         }
 
         [RequiresSymbolicLinksFact]
@@ -321,10 +334,14 @@ public void BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput()
 
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkName));
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkLvl2Name));
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(emptyFileName));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkName),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkLvl2Name),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(emptyFileName),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 168cca02bbe..9963b2338b5 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
+using Shouldly;
 using Xunit;
 
 #nullable disable
@@ -27,6 +28,26 @@ public BuildEventArgsSerializationTests()
             _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
+        [Fact]
+        public void WriteBlobFromStream()
+        {
+            byte[] bytes = new byte[] { 1, 2, 3, 4, 5 };
+            MemoryStream inputStream = new MemoryStream(bytes);
+
+            MemoryStream outputStream = new MemoryStream();
+            using BinaryWriter binaryWriter = new BinaryWriter(outputStream);
+            BuildEventArgsWriter writer = new BuildEventArgsWriter(binaryWriter);
+
+            writer.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, inputStream);
+            binaryWriter.Flush();
+
+            outputStream.Position = 0;
+            BinaryReader binaryReader = new BinaryReader(outputStream);
+            Assert.Equal(BinaryLogRecordKind.ProjectImportArchive, (BinaryLogRecordKind)binaryReader.Read7BitEncodedInt());
+            Assert.Equal(bytes.Length, binaryReader.Read7BitEncodedInt());
+            Assert.Equal(bytes, binaryReader.ReadBytes(bytes.Length));
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
@@ -242,6 +263,40 @@ public void RoundtripBuildErrorEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
+        {
+            var args = new ExtendedBuildErrorEventArgs(
+                "extendedDataType",
+                "Subcategory",
+                "Code",
+                "File",
+                1,
+                2,
+                3,
+                4,
+                "Message with arguments: '{0}'",
+                "Help",
+                "SenderName",
+                DateTime.Parse("9/1/2021 12:02:07 PM"),
+                useArguments ? new object[] { "argument0" } : null);
+
+            // For now we don't serialize extended data into binary log
+            Roundtrip<BuildErrorEventArgs>(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
@@ -274,6 +329,40 @@ public void RoundtripBuildWarningEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArguments)
+        {
+            var args = new ExtendedBuildWarningEventArgs(
+                "extendedDataType",
+                "Subcategory",
+                "Code",
+                "File",
+                1,
+                2,
+                3,
+                4,
+                "Message with arguments: '{0}'",
+                "Help",
+                "SenderName",
+                DateTime.Parse("9/1/2021 12:02:07 PM"),
+                useArguments ? new object[] { "argument0" } : null);
+
+            // For now we don't serialize extended data into binary log
+            Roundtrip<BuildWarningEventArgs>(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
@@ -308,6 +397,122 @@ public void RoundtripBuildMessageEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useArguments)
+        {
+            var args = new ExtendedBuildMessageEventArgs(
+                "extendedDataType",
+                "Subcategory",
+                "Code",
+                "File",
+                1, 
+                2,
+                3,
+                4,
+                "Message",
+                "Help",
+                "SenderName",
+                MessageImportance.High,
+                DateTime.Parse("12/12/2015 06:11:56 PM"),
+                useArguments ? new object[] { "argument0" } : null);
+
+            Roundtrip<BuildMessageEventArgs>(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.Importance.ToString(),
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
+        [Fact]
+        public void RoundtripAssemblyLoadBuild()
+        {
+            string assemblyName = Guid.NewGuid().ToString();
+            string assemblyPath = Guid.NewGuid().ToString();
+            Guid mvid = Guid.NewGuid();
+            string loadingInitiator = Guid.NewGuid().ToString();
+            string appDomainName = Guid.NewGuid().ToString();
+            AssemblyLoadingContext context =
+                (AssemblyLoadingContext)(new Random().Next(Enum.GetNames(typeof(AssemblyLoadingContext)).Length));
+
+            AssemblyLoadBuildEventArgs args = new(context, loadingInitiator, assemblyName, assemblyPath, mvid, appDomainName);
+
+            Roundtrip(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.Importance.ToString(),
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => e.LoadingContext.ToString(),
+                e => e.AssemblyName,
+                e => e.AssemblyPath,
+                e => e.MVID.ToString(),
+                e => e.AppDomainDescriptor,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ExtendedCustomBuildEventArgs_SerializedAsMessage(bool withOptionalData)
+        {
+            ExtendedCustomBuildEventArgs args = new(
+                type: "TypeOfExtendedCustom",
+                message: withOptionalData ? "a message with args {0} {1}" : null,
+                helpKeyword: withOptionalData ? "MSBT123" : null,
+                senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+                eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+                messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
+
+
+            var memoryStream = new MemoryStream();
+            var binaryWriter = new BinaryWriter(memoryStream);
+            var buildEventArgsWriter = new BuildEventArgsWriter(binaryWriter);
+            buildEventArgsWriter.Write(args);
+
+            memoryStream.Position = 0;
+            var binaryReader = new BinaryReader(memoryStream);
+
+            using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
+            var deserialized = buildEventArgsReader.Read();
+            BuildMessageEventArgs desArgs = (BuildMessageEventArgs)deserialized;
+
+            desArgs.ShouldBeOfType(typeof(BuildMessageEventArgs));
+
+            desArgs.Message.ShouldBe(args.Message);
+            desArgs.HelpKeyword.ShouldBe(args.HelpKeyword);
+            desArgs.SenderName.ShouldBe(args.SenderName);
+            desArgs.Importance.ShouldBe(MessageImportance.Normal);
+            desArgs.Timestamp.ShouldBe(args.Timestamp);
+
+            if (withOptionalData)
+            {
+                desArgs.BuildEventContext.ShouldBe(args.BuildEventContext);
+            }
+            else
+            {
+                desArgs.BuildEventContext.ShouldBe(BuildEventContext.Invalid);
+            }
+        }
+
         [Fact]
         public void RoundtripResponseFileUsedEventArgs()
         {
@@ -669,7 +874,7 @@ private void Roundtrip<T>(T args, params Func<T, string>[] fieldsToCompare)
             Assert.Equal(length, memoryStream.Position);
 
             Assert.NotNull(deserializedArgs);
-            Assert.Equal(args.GetType(), deserializedArgs.GetType());
+            Assert.Equal(typeof(T), deserializedArgs.GetType());
 
             foreach (var field in fieldsToCompare)
             {
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 70ed081e9fb..10859bb9ce5 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -1234,7 +1234,7 @@ public void MultilineFormatUnixLineEndings()
         [Fact]
         public void MultilineFormatMixedLineEndings()
         {
-            string s = "foo" + "\r\n\r\n" + "bar" + "\n" + "baz" + "\n\r\n\n" +
+            string s = "\n" + "foo" + "\r\n\r\n" + "bar" + "\n" + "baz" + "\n\r\n\n" +
                 "jazz" + "\r\n" + "razz" + "\n\n" + "matazz" + "\n" + "end";
 
             SerialConsoleLogger cl = new SerialConsoleLogger();
@@ -1242,7 +1242,7 @@ public void MultilineFormatMixedLineEndings()
             string ss = cl.IndentString(s, 0);
 
             // should convert lines to system format
-            ss.ShouldBe($"foo{Environment.NewLine}{Environment.NewLine}bar{Environment.NewLine}baz{Environment.NewLine}{Environment.NewLine}{Environment.NewLine}jazz{Environment.NewLine}razz{Environment.NewLine}{Environment.NewLine}matazz{Environment.NewLine}end{Environment.NewLine}");
+            ss.ShouldBe($"{Environment.NewLine}foo{Environment.NewLine}{Environment.NewLine}bar{Environment.NewLine}baz{Environment.NewLine}{Environment.NewLine}{Environment.NewLine}jazz{Environment.NewLine}razz{Environment.NewLine}{Environment.NewLine}matazz{Environment.NewLine}end{Environment.NewLine}");
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/ConsoleOutputAlignerTests.cs b/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
index 87dc12b963d..6b7e72a4679 100644
--- a/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
+++ b/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Text;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
 using Shouldly;
 using Xunit;
 
@@ -18,7 +20,7 @@ public class ConsoleOutputAlignerTests
         public void IndentBiggerThanBuffer_IndentedAndNotAligned(string input, bool aligned)
         {
             string indent = "    ";
-            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: aligned);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: aligned, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: indent.Length);
 
@@ -30,7 +32,7 @@ public void IndentBiggerThanBuffer_IndentedAndNotAligned(string input, bool alig
         [InlineData("12345")]
         public void NoAlignNoIndent_NotAlignedEvenIfBiggerThanBuffer(string input)
         {
-            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: false);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: false, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: 0);
 
@@ -43,7 +45,7 @@ public void NoAlignNoIndent_NotAlignedEvenIfBiggerThanBuffer(string input)
         public void NoBufferWidthNoIndent_NotAligned(int sizeOfMessage)
         {
             string input = new string('.', sizeOfMessage);
-            var aligner = new ConsoleOutputAligner(bufferWidth: -1, alignMessages: false);
+            var aligner = new ConsoleOutputAligner(bufferWidth: -1, alignMessages: false, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: 0);
 
@@ -55,7 +57,7 @@ public void NoBufferWidthNoIndent_NotAligned(int sizeOfMessage)
         [InlineData("12345")]
         public void WithoutBufferWidthWithoutIndentWithAlign_NotIndentedAndNotAligned(string input)
         {
-            var aligner = new ConsoleOutputAligner(bufferWidth: -1, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: -1, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: 0);
 
@@ -67,7 +69,7 @@ public void WithoutBufferWidthWithoutIndentWithAlign_NotIndentedAndNotAligned(st
         [InlineData("12345")]
         public void NoAlignPrefixAlreadyWritten_NotChanged(string input)
         {
-            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 0);
 
@@ -80,7 +82,7 @@ public void NoAlignPrefixAlreadyWritten_NotChanged(string input)
         [InlineData("  ", "1")]
         public void SmallerThanBuffer_NotAligned(string indent, string input)
         {
-            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: indent.Length);
 
@@ -93,7 +95,7 @@ public void SmallerThanBuffer_NotAligned(string indent, string input)
         [InlineData("  ", "12", "  1", "  2")]
         public void BiggerThanBuffer_AlignedWithIndent(string indent, string input, string expected1stLine, string expected2ndLine)
         {
-            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: indent.Length);
 
@@ -114,7 +116,7 @@ public void BiggerThanBuffer_AlignedWithIndent(string indent, string input, stri
                                   "  4\n")]
         public void XTimesBiggerThanBuffer_AlignedToMultipleLines(string indent, string input, string expected)
         {
-            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: indent.Length);
 
@@ -128,7 +130,7 @@ public void XTimesBiggerThanBuffer_AlignedToMultipleLines(string indent, string
         [InlineData("  ", "12", "1", "  2")]
         public void BiggerThanBufferWithPrefixAlreadyWritten_AlignedWithIndentFromSecondLine(string indent, string input, string expected1stLine, string expected2ndLine)
         {
-            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: indent.Length);
 
@@ -142,7 +144,7 @@ public void BiggerThanBufferWithPrefixAlreadyWritten_AlignedWithIndentFromSecond
         public void MultiLineWithoutAlign_NotChanged(string input)
         {
             input = input.Replace("\n", Environment.NewLine);
-            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: false);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: false, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 0);
 
@@ -165,7 +167,7 @@ public void NonStandardNewLines_AlignAsExpected(string input, string expected)
         {
             expected = expected.Replace("\n", Environment.NewLine) + Environment.NewLine;
 
-            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 2);
 
@@ -179,7 +181,7 @@ public void NonStandardNewLines_AlignAsExpected(string input, string expected)
         public void ShortMultiLineWithAlign_NoChange(string input)
         {
             input = input.Replace("\n", Environment.NewLine);
-            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 0);
 
@@ -202,7 +204,7 @@ public void ShortMultiLineWithAlign_NoChange(string input)
         public void ShortMultiLineWithMixedNewLines_NewLinesReplacedByActualEnvironmentNewLines(string input)
         {
             string expected = input.Replace("\r", "").Replace("\n", Environment.NewLine) + Environment.NewLine;
-            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 0);
 
@@ -217,7 +219,7 @@ public void MultiLineWithPrefixAlreadyWritten(string prefix, string input, strin
         {
             input = input.Replace("\n", Environment.NewLine);
             expected = expected.Replace("\n", Environment.NewLine);
-            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: prefix.Length);
 
@@ -231,7 +233,7 @@ public void MultiLineWithoutPrefixAlreadyWritten(string prefix, string input, st
         {
             input = input.Replace("\n", Environment.NewLine);
             expected = expected.Replace("\n", Environment.NewLine);
-            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: prefix.Length);
 
@@ -244,7 +246,7 @@ public void MultiLineWithoutPrefixAlreadyWritten(string prefix, string input, st
         public void ShortTextWithTabs_NoChange(string input)
         {
             input = input.Replace("\n", Environment.NewLine);
-            var aligner = new ConsoleOutputAligner(bufferWidth: 50, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 50, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 0);
 
@@ -259,7 +261,7 @@ public void ShortTextWithTabs_NoChange(string input)
         public void LastTabOverLimit_NoChange(string prefix, string input, int bufferWidthWithoutNewLine, bool prefixAlreadyWritten)
         {
             input = input.Replace("\n", Environment.NewLine);
-            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: prefixAlreadyWritten, prefixWidth: prefix.Length);
 
@@ -274,7 +276,7 @@ public void LastTabOverLimit_NoChange(string prefix, string input, int bufferWid
         public void LastTabAtLimit_NoChange(string prefix, string input, int bufferWidthWithoutNewLine, bool prefixAlreadyWritten)
         {
             input = input.Replace("\n", Environment.NewLine);
-            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: prefixAlreadyWritten, prefixWidth: prefix.Length);
 
@@ -289,7 +291,7 @@ public void LastTabAtLimit_NoChange(string prefix, string input, int bufferWidth
         public void TabsMakesItJustOverLimit_IndentAndAlign(string prefix, string input, int bufferWidthWithoutNewLine, bool prefixAlreadyWritten)
         {
             input = input.Replace("\n", Environment.NewLine);
-            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input + "x", prefixAlreadyWritten: prefixAlreadyWritten, prefixWidth: prefix.Length);
 
@@ -366,11 +368,17 @@ public void MultiLinesOverLimit_IndentAndAlign(string prefix, string input, stri
         {
             input = input.Replace("\n", Environment.NewLine);
             expected = expected.Replace("\n", Environment.NewLine);
-            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true);
+            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true, stringBuilderProvider: new TestStringBuilderProvider());
 
             string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: prefixAlreadyWritten, prefixWidth: prefix.Length);
 
             output.ShouldBe(expected);
         }
+
+        private sealed class TestStringBuilderProvider : IStringBuilderProvider
+        {
+            public StringBuilder Acquire(int capacity) => new StringBuilder(capacity);
+            public string GetStringAndRelease(StringBuilder builder) => builder.ToString();
+        }
     }
 }
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index 84c24cb12b0..278c11f36ed 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -282,7 +282,7 @@ public void CanBeMSBuildFileRejectsMSBuildLikeFiles()
                 string solutionFileContents =
                     @"
                     Microsoft Visual Studio Solution File, Format Version 8.00
-                        Project('{F14B399A-7131-4C87-9E4B-1186C45EF12D}') = 'PrtProj', '" + Path.GetFileName(rptprojPath) + @"', '{CCCCCCCC-9925-4D57-9DAF-E0A9D936ABDB}'
+                        Project('{F14B399A-7131-4C87-9E4B-1186C45EF12D}') = 'RptProj', '" + Path.GetFileName(rptprojPath) + @"', '{CCCCCCCC-9925-4D57-9DAF-E0A9D936ABDB}'
                             ProjectSection(ProjectDependencies) = postProject
                             EndProjectSection
                         EndProject
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index 443871defb6..78cd0f31dc1 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -130,26 +130,44 @@ public void IsolatedContextShouldNotSupportBeingPassedAFileSystem()
             Should.Throw<ArgumentException>(() => EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated, fileSystem));
         }
 
-        [Fact]
-        public void EvaluationShouldUseDirectoryCache()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void EvaluationShouldUseDirectoryCache(bool useProjectInstance)
         {
-            var projectFile = _env.CreateFile("1.proj", @"<Project> <ItemGroup Condition=`Exists('1.file')`> <Compile Include='*.cs'/> </ItemGroup> </Project>".Cleanup()).Path;
+            var projectFile = _env.CreateFile("1.proj", @"<Project> <Import Project='1.file' Condition=`Exists('1.file')`/> <ItemGroup><Compile Include='*.cs'/></ItemGroup> </Project>".Cleanup()).Path;
 
             var projectCollection = _env.CreateProjectCollection().Collection;
             var directoryCacheFactory = new Helpers.LoggingDirectoryCacheFactory();
 
-            var project = Project.FromFile(
-                projectFile,
-                new ProjectOptions
-                {
-                    ProjectCollection = projectCollection,
-                    DirectoryCacheFactory = directoryCacheFactory,
-                });
+            int expectedEvaluationId;
+            if (useProjectInstance)
+            {
+                var projectInstance = ProjectInstance.FromFile(
+                    projectFile,
+                    new ProjectOptions
+                    {
+                        ProjectCollection = projectCollection,
+                        DirectoryCacheFactory = directoryCacheFactory,
+                    });
+                expectedEvaluationId = projectInstance.EvaluationId;
+            }
+            else
+            {
+                var project = Project.FromFile(
+                    projectFile,
+                    new ProjectOptions
+                    {
+                        ProjectCollection = projectCollection,
+                        DirectoryCacheFactory = directoryCacheFactory,
+                    });
+                expectedEvaluationId = project.LastEvaluationId;
+            }
 
             directoryCacheFactory.DirectoryCaches.Count.ShouldBe(1);
             var directoryCache = directoryCacheFactory.DirectoryCaches[0];
 
-            directoryCache.EvaluationId.ShouldBe(project.LastEvaluationId);
+            directoryCache.EvaluationId.ShouldBe(expectedEvaluationId);
 
             directoryCache.ExistenceChecks.OrderBy(kvp => kvp.Key).ShouldBe(
                 new Dictionary<string, int>
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index e897cd174e3..3df737c387a 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -868,15 +868,15 @@ public void CanGetCorrectListOfItemsWithSemicolonsInThem()
                         <MyUserMacro>foo%3bbar</MyUserMacro>
                     </PropertyGroup>
                     <ItemGroup>
-                        <CrazyList Include=""a"" />
-                        <CrazyList Include=""b%3bc"" />
-                        <CrazyList Include=""$(MyUserMacro)"" />
+                        <DifferentList Include=""a"" />
+                        <DifferentList Include=""b%3bc"" />
+                        <DifferentList Include=""$(MyUserMacro)"" />
                     </ItemGroup>
                 </Project>";
 
             System.Xml.XmlReader reader = new System.Xml.XmlTextReader(new StringReader(projectString));
             Project project = new Project(reader);
-            IEnumerable<ProjectItem> items = project.GetItems("CrazyList");
+            IEnumerable<ProjectItem> items = project.GetItems("DifferentList");
 
             Assert.Equal(3, items.Count());
             Assert.Equal("a", items.ElementAt(0).EvaluatedInclude);
@@ -900,15 +900,15 @@ public void CanGetCorrectListOfItemsWithSemicolonsInThem2()
                         <MyUserMacro>foo;bar</MyUserMacro>
                     </PropertyGroup>
                     <ItemGroup>
-                        <CrazyList Include=""a"" />
-                        <CrazyList Include=""b%3bc"" />
-                        <CrazyList Include=""$(MyUserMacro)"" />
+                        <DifferentList Include=""a"" />
+                        <DifferentList Include=""b%3bc"" />
+                        <DifferentList Include=""$(MyUserMacro)"" />
                     </ItemGroup>
                 </Project>";
 
             System.Xml.XmlReader reader = new System.Xml.XmlTextReader(new StringReader(projectString));
             Project project = new Project(reader);
-            IEnumerable<ProjectItem> items = project.GetItems("CrazyList");
+            IEnumerable<ProjectItem> items = project.GetItems("DifferentList");
 
             Assert.Equal(4, items.Count());
             Assert.Equal("a", items.ElementAt(0).EvaluatedInclude);
@@ -1446,11 +1446,11 @@ public class Class1
 
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
-        /// have all sorts of crazy characters in their name. There
+        /// have all sorts of different characters in their name. There
         /// is even a P2P reference between the two projects in the .SLN.
         /// </summary>
         [Fact(Skip = "This is a known issue in Roslyn. This test should be enabled if Roslyn is updated for this scenario.")]
-        public void SolutionWithLotsaCrazyCharacters()
+        public void SolutionWithLotsaDifferentCharacters()
         {
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
@@ -1612,11 +1612,11 @@ public class Class1
 
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
-        /// have all sorts of crazy characters in their name. There
+        /// have all sorts of different characters in their name. There
         /// is even a P2P reference between the two projects in the .SLN.
         /// </summary>
         [Fact(Skip = "This is a known issue in Roslyn. This test should be enabled if Roslyn is updated for this scenario.")]
-        public void SolutionWithLotsaCrazyCharacters_UsingTaskHost()
+        public void SolutionWithLotsaDifferentCharacters_UsingTaskHost()
         {
             string originalOverrideTaskHostVariable = Environment.GetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC");
 
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index f215d86d9ec..221ea0026e2 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4473,6 +4473,38 @@ public void ConditionWithShortCircuitAndErrorDoesNotFailBuild(string projectInne
             }
         }
 
+        [Theory]
+        [InlineData("$(Hello)", 0, 8, "Hello")]
+        [InlineData("$(Hello)|$(World)", 9, 8, "World")]
+        [InlineData("$(He()o)", 0, 8, null)]
+        [InlineData("$)Hello(", 0, 8, null)]
+        [InlineData("$(Helloo", 0, 8, null)]
+        [InlineData("$Heello)", 0, 8, null)]
+        [InlineData("$(He$$o)", 0, 8, null)]
+        [InlineData(" $(Helo)", 0, 8, null)]
+        [InlineData("$(Helo) ", 0, 8, null)]
+        [InlineData("$()", 0, 3, "")]
+        [InlineData("$( Hello )", 0, 10, " Hello ")]
+        [InlineData("$(He-ll-o)", 0, 10, "He-ll-o")]
+        [InlineData("$(He ll o)", 0, 10, "He ll o")]
+        [InlineData("aaa$(Hello)", 3, 8, "Hello")]
+        [InlineData("aaa$(Hello)bbb", 3, 8, "Hello")]
+        public void TryGetSingleProperty(string input, int start, int length, string expected)
+        {
+            bool result = ConditionEvaluator.TryGetSingleProperty(input.AsSpan(), start, length, out ReadOnlySpan<char> actual);
+
+            if (expected is null)
+            {
+                Assert.False(result);
+                Assert.True(actual.IsEmpty);
+            }
+            else
+            {
+                Assert.True(result);
+                Assert.Equal(expected, actual.ToString());
+            }
+        }
+
         [Fact]
         public void VerifyMSBuildLastModifiedProjectForImport()
         {
diff --git a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
new file mode 100644
index 00000000000..43c261e5676
--- /dev/null
+++ b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
@@ -0,0 +1,279 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Globalization;
+using System.Runtime.InteropServices;
+using System.Threading;
+
+using Microsoft.Build.Evaluation;
+
+using Shouldly;
+
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Engine.UnitTests.Evaluation
+{
+    public class ExpanderFunction_Tests
+    {
+        private readonly ITestOutputHelper _output;
+
+        public ExpanderFunction_Tests(ITestOutputHelper output) => _output = output;
+
+        /* Tests for TryConvertToInt */
+
+        [Fact]
+        public void TryConvertToIntGivenNull()
+        {
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(null, out int actual).ShouldBeFalse();
+            actual.ShouldBe(0);
+        }
+
+        [Fact]
+        public void TryConvertToIntGivenDouble()
+        {
+            const double value = 10.0;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            actual.ShouldBe(10);
+        }
+
+        [Fact]
+        public void TryConvertToIntGivenLong()
+        {
+            const long value = 10;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            actual.ShouldBe(10);
+        }
+
+        [Fact]
+        public void TryConvertToIntGivenInt()
+        {
+            const int value = 10;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            actual.ShouldBe(10);
+        }
+
+        [Fact]
+        public void TryConvertToIntGivenString()
+        {
+            const string value = "10";
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            actual.ShouldBe(10);
+        }
+
+        [Fact]
+        public void TryConvertToIntGivenDoubleWithIntMinValue()
+        {
+            const int expected = int.MinValue;
+            const double value = expected;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            actual.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void TryConvertToIntGivenDoubleWithIntMaxValue()
+        {
+            const int expected = int.MaxValue;
+            const double value = expected;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            actual.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void TryConvertToIntGivenDoubleWithLessThanIntMinValue()
+        {
+            const double value = int.MinValue - 1.0;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeFalse();
+            actual.ShouldBe(0);
+        }
+
+        [Fact]
+        public void TryConvertToIntGivenDoubleWithGreaterThanIntMaxValue()
+        {
+            const double value = int.MaxValue + 1.0;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeFalse();
+            actual.ShouldBe(0);
+        }
+
+        [Fact]
+        public void TryConvertToIntGivenLongWithGreaterThanIntMaxValue()
+        {
+            const long value = int.MaxValue + 1L;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeFalse();
+            actual.ShouldBe(0);
+        }
+
+        /* Tests for TryConvertToLong */
+
+        [Fact]
+        public void TryConvertToLongGivenNull()
+        {
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(null, out long actual).ShouldBeFalse();
+            actual.ShouldBe(0);
+        }
+
+        [Fact]
+        public void TryConvertToLongGivenDouble()
+        {
+            const double value = 10.0;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            actual.ShouldBe(10);
+        }
+
+        [Fact]
+        public void TryConvertToLongGivenLong()
+        {
+            const long value = 10;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            actual.ShouldBe(10);
+        }
+
+        [Fact]
+        public void TryConvertToLongGivenInt()
+        {
+            const int value = 10;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            actual.ShouldBe(10);
+        }
+
+        [Fact]
+        public void TryConvertToLongGivenString()
+        {
+            const string value = "10";
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            actual.ShouldBe(10);
+        }
+
+        [Fact]
+        public void TryConvertToLongGivenDoubleWithLongMinValue()
+        {
+            const long expected = long.MinValue;
+            const double value = expected;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            actual.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void TryConvertToLongGivenDoubleWithLongMaxValueShouldNotThrow()
+        {
+            // An OverflowException should not be thrown from TryConvertToLong().
+            // Convert.ToInt64(double) has a defect and will throw an OverflowException
+            // for values >= (long.MaxValue - 511) and <= long.MaxValue.
+            _ = Should.NotThrow(() => Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong((double)long.MaxValue, out _));
+        }
+
+        [Fact]
+        public void TryConvertToLongGivenDoubleWithLongMaxValue()
+        {
+            const long longMaxValue = long.MaxValue;
+            bool result = Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong((double)longMaxValue, out long actual);
+            if (RuntimeInformation.OSArchitecture != Architecture.Arm64)
+            {
+                // Because of loss of precision, long.MaxValue will not 'round trip' from long to double to long.
+                result.ShouldBeFalse();
+                actual.ShouldBe(0);
+            }
+            else
+            {
+                // Testing on macOS 12 on Apple Silicon M1 Pro produces different result.
+                result.ShouldBeTrue();
+                actual.ShouldBe(longMaxValue);
+            }
+        }
+
+        [Fact]
+        public void TryConvertToLongGivenDoubleWithVeryLargeLongValue()
+        {
+            // Because of loss of precision, veryLargeLong will not 'round trip' but within TryConvertToLong
+            // the double to long conversion will pass the tolerance test. Return will be true and veryLargeLong != expected.
+            const long veryLargeLong = long.MaxValue - 512;
+            const double value = veryLargeLong;
+            const long expected = 9223372036854774784L;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            actual.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void TryConvertToLongGivenDoubleWithLessThanLongMinValue()
+        {
+            const double value = -92233720368547758081D;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeFalse();
+            actual.ShouldBe(0);
+        }
+
+        [Fact]
+        public void TryConvertToLongGivenDoubleWithGreaterThanLongMaxValue()
+        {
+            const double value = (double)long.MaxValue + long.MaxValue;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeFalse();
+            actual.ShouldBe(0);
+        }
+
+        /* Tests for TryConvertToDouble */
+
+        [Fact]
+        public void TryConvertToDoubleGivenNull()
+        {
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(null, out double actual).ShouldBeFalse();
+            actual.ShouldBe(0);
+        }
+
+        [Fact]
+        public void TryConvertToDoubleGivenDouble()
+        {
+            const double value = 10.0;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            actual.ShouldBe(10.0);
+        }
+
+        [Fact]
+        public void TryConvertToDoubleGivenLong()
+        {
+            const long value = 10;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            actual.ShouldBe(10.0);
+        }
+
+        [Fact]
+        public void TryConvertToDoubleGivenInt()
+        {
+            const int value = 10;
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            actual.ShouldBe(10.0);
+        }
+
+        [Fact]
+        public void TryConvertToDoubleGivenString()
+        {
+            const string value = "10";
+            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            actual.ShouldBe(10.0);
+        }
+
+        [Fact]
+        public void TryConvertToDoubleGivenStringAndLocale()
+        {
+            const string value = "1,2";
+
+            Thread currentThread = Thread.CurrentThread;
+            CultureInfo originalCulture = currentThread.CurrentCulture;
+
+            try
+            {
+                // English South Africa locale uses ',' as decimal separator.
+                // The invariant culture should be used and "1,2" should be 12.0 not 1.2.
+                var cultureEnglishSouthAfrica = CultureInfo.CreateSpecificCulture("en-ZA");
+                currentThread.CurrentCulture = cultureEnglishSouthAfrica;
+                Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+                actual.ShouldBe(12.0);
+            }
+            finally
+            {
+                // Restore CultureInfo.
+                currentThread.CurrentCulture = originalCulture;
+                CultureInfo.CurrentCulture = originalCulture;
+                CultureInfo.DefaultThreadCurrentCulture = originalCulture;
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 3b04989a30b..030c6db60c3 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -37,6 +37,8 @@ public class Expander_Tests
         private string _dateToParse = new DateTime(2010, 12, 25).ToString(CultureInfo.CurrentCulture);
         private static readonly string s_rootPathPrefix = NativeMethodsShared.IsWindows ? "C:\\" : Path.VolumeSeparatorChar.ToString();
 
+        private static bool IsIntrinsicFunctionOverloadsEnabled => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8);
+
         [Fact]
         public void ExpandAllIntoTaskItems0()
         {
@@ -1118,6 +1120,37 @@ public void HasMetadata()
             logger.AssertLogContains("[One|Three|Four]");
         }
 
+
+        /// <summary>
+        /// Filter items by WithoutMetadataValue function
+        /// </summary>
+        [Fact]
+        public void WithoutMetadataValue()
+        {
+            MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess("""
+                <Project>
+                    <ItemGroup>
+                            <_Item Include="One">
+                                <A>true</A>
+                            </_Item>
+                            <_Item Include="Two">
+                                <A>false</A>
+                            </_Item>
+                            <_Item Include="Three">
+                                <A></A>
+                            </_Item>
+                            <_Item Include="Four">
+                                <B></B>
+                            </_Item>
+                    </ItemGroup>
+                    <Target Name="AfterBuild">
+                        <Message Text="[@(_Item->WithoutMetadataValue('a', 'true'),'|')]"/>
+                    </Target>
+                </Project>
+                """);
+
+            logger.AssertLogContains("[Two|Three|Four]");
+        }
         [Fact]
         public void DirectItemMetadataReferenceShouldBeCaseInsensitive()
         {
@@ -2806,6 +2839,290 @@ public void PropertyFunctionRuntimeInformation(string propertyFunction, string e
             Assert.Equal(expectedExpansion, result);
         }
 
+        [Theory]
+        [InlineData("windows")]
+        [InlineData("linux")]
+        [InlineData("macos")]
+        [InlineData("osx")]
+        public void IsOSPlatform(string platform)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsOSPlatform('{platform}'))";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsOSPlatform(platform);
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsOSPlatform(platform);
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData("windows", 4, 0, 0, 0)]
+        [InlineData("windows", 999, 0, 0, 0)]
+        [InlineData("linux", 0, 0, 0, 0)]
+        [InlineData("macos", 10, 15, 0, 0)]
+        [InlineData("macos", 999, 0, 0, 0)]
+        [InlineData("osx", 0, 0, 0, 0)]
+        public void IsOSPlatformVersionAtLeast(string platform, int major, int minor, int build, int revision)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsOSPlatformVersionAtLeast('{platform}', {major}, {minor}, {build}, {revision}))";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsOSPlatformVersionAtLeast(platform, major, minor, build, revision);
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsOSPlatformVersionAtLeast(platform, major, minor, build, revision);
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsLinux()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsLinux())";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsLinux();
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsLinux();
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsFreeBSD()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsFreeBSD())";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = System.OperatingSystem.IsFreeBSD();
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsFreeBSD();
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0, 0)]
+        [InlineData(999, 0, 0, 0)]
+        public void IsFreeBSDVersionAtLeast(int major, int minor, int build, int revision)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsFreeBSDVersionAtLeast({major}, {minor}, {build}, {revision}))";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsFreeBSDVersionAtLeast(major, minor, build, revision);
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsFreeBSDVersionAtLeast(major, minor, build, revision);
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsMacOS()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsMacOS())";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsMacOS();
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsMacOS();
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0)]
+        [InlineData(10, 15, 0)]
+        [InlineData(999, 0, 0)]
+        public void IsMacOSVersionAtLeast(int major, int minor, int build)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsMacOSVersionAtLeast({major}, {minor}, {build}))";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsMacOSVersionAtLeast(major, minor, build);
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsMacOSVersionAtLeast(major, minor, build);
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsWindows()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsWindows())";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsWindows();
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsWindows();
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0, 0)]
+        [InlineData(4, 0, 0, 0)]
+        [InlineData(999, 0, 0, 0)]
+        public void IsWindowsVersionAtLeast(int major, int minor, int build, int revision)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsWindowsVersionAtLeast({major}, {minor}, {build}, {revision}))";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsWindowsVersionAtLeast(major, minor, build, revision);
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsWindowsVersionAtLeast(major, minor, build, revision);
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+#if NET5_0_OR_GREATER
+
+        [Fact]
+        public void IsAndroid()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsAndroid())";
+
+            string expected = OperatingSystem.IsAndroid() ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0, 0)]
+        [InlineData(999, 0, 0, 0)]
+        public void IsAndroidVersionAtLeast(int major, int minor, int build, int revision)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsAndroidVersionAtLeast({major}, {minor}, {build}, {revision}))";
+            string expected = OperatingSystem.IsAndroidVersionAtLeast(major, minor, build, revision) ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsIOS()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsIOS())";
+
+            string expected = OperatingSystem.IsIOS() ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0)]
+        [InlineData(16, 5, 1)]
+        [InlineData(999, 0, 0)]
+        public void IsIOSVersionAtLeast(int major, int minor, int build)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsIOSVersionAtLeast({major}, {minor}, {build}))";
+            string expected = OperatingSystem.IsIOSVersionAtLeast(major, minor, build) ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsMacCatalyst()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsMacCatalyst())";
+
+            string expected = OperatingSystem.IsMacCatalyst() ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0)]
+        [InlineData(999, 0, 0)]
+        public void IsMacCatalystVersionAtLeast(int major, int minor, int build)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsMacCatalystVersionAtLeast({major}, {minor}, {build}))";
+            string expected = OperatingSystem.IsMacCatalystVersionAtLeast(major, minor, build) ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsTvOS()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsTvOS())";
+
+            string expected = OperatingSystem.IsTvOS() ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0)]
+        [InlineData(16, 5, 0)]
+        [InlineData(999, 0, 0)]
+        public void IsTvOSVersionAtLeast(int major, int minor, int build)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsTvOSVersionAtLeast({major}, {minor}, {build}))";
+            string expected = OperatingSystem.IsTvOSVersionAtLeast(major, minor, build) ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsWatchOS()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsWatchOS())";
+
+            string expected = OperatingSystem.IsWatchOS() ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0)]
+        [InlineData(9, 5, 2)]
+        [InlineData(999, 0, 0)]
+        public void IsWatchOSVersionAtLeast(int major, int minor, int build)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsWatchOSVersionAtLeast({major}, {minor}, {build}))";
+            string expected = OperatingSystem.IsWatchOSVersionAtLeast(major, minor, build) ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+#endif
+
         [Theory]
         [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x', 1))", "3")]
         [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x45', 1))", "3")]
@@ -3180,17 +3497,17 @@ public void PropertyFunctionValueOrDefaultFromEnvironment()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
 
-            pg["BonkersTargetsPath"] = ProjectPropertyInstance.Create("BonkersTargetsPath", "Bonkers");
+            pg["DifferentTargetsPath"] = ProjectPropertyInstance.Create("DifferentTargetsPath", "Different");
 
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
 
-            string result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::ValueOrDefault('$(BonkersTargetsPath)', '42'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+            string result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::ValueOrDefault('$(DifferentTargetsPath)', '42'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
-            Assert.Equal("Bonkers", result);
+            Assert.Equal("Different", result);
 
-            pg["BonkersTargetsPath"] = ProjectPropertyInstance.Create("BonkersTargetsPath", String.Empty);
+            pg["DifferentTargetsPath"] = ProjectPropertyInstance.Create("DifferentTargetsPath", String.Empty);
 
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::ValueOrDefault('$(BonkersTargetsPath)', '43'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::ValueOrDefault('$(DifferentTargetsPath)', '43'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
             Assert.Equal("43", result);
         }
@@ -3394,28 +3711,25 @@ public void PropertyFunctionStaticMethodIntrinsicMaths()
             result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::Modulo(2345.5, 43))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
             Assert.Equal((2345.5 % 43).ToString(), result);
+        }
 
-            // test for overflow wrapping
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::Add(9223372036854775807, 20))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
-
-            double expectedResult = 9223372036854775807D + 20D;
-            Assert.Equal(expectedResult.ToString(), result);
-
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseOr(40, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
-
-            Assert.Equal((40 | 2).ToString(), result);
-
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseAnd(42, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
-
-            Assert.Equal((42 & 2).ToString(), result);
-
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseXor(213, 255))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
-
-            Assert.Equal((213 ^ 255).ToString(), result);
+        /// <summary>
+        /// Expand intrinsic property functions that call a bit operator
+        /// </summary>
+        [Fact]
+        public void PropertyFunctionStaticMethodIntrinsicBitOperations()
+        {
+            PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
 
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseNot(-43))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
 
-            Assert.Equal((~-43).ToString(), result);
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseOr(40, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((40 | 2).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseAnd(42, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((42 & 2).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseXor(213, 255))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((213 ^ 255).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseNot(-43))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((~-43).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::LeftShift(1, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((1 << 2).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::RightShift(-8, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((-8 >> 2).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::RightShiftUnsigned(-8, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((-8 >>> 2).ToString());
         }
 
         /// <summary>
@@ -3690,13 +4004,21 @@ public void Medley()
                 new string[] {"$([MSBuild]::Add(1,2).CompareTo(3))", "0"},
                 new string[] {"$([MSBuild]::Add(1,2).CompareTo(3))", "0"},
                 new string[] {"$([MSBuild]::Add(1,2).CompareTo(3.0))", "0"},
+                new string[] {"$([MSBuild]::Add(1,2.0).CompareTo(3.0))", "0"},
+                new string[] {"$([System.Convert]::ToDouble($([MSBuild]::Add(1,2))).CompareTo(3.0))", "0"},
                 new string[] {"$([MSBuild]::Add(1,2).CompareTo('3'))", "0"},
                 new string[] {"$([MSBuild]::Add(1,2).CompareTo(3.1))", "-1"},
+                new string[] {"$([MSBuild]::Add(1,2.0).CompareTo(3.1))", "-1"},
+                new string[] {"$([System.Convert]::ToDouble($([MSBuild]::Add(1,2))).CompareTo(3.1))", "-1"},
                 new string[] {"$([MSBuild]::Add(1,2).CompareTo(2))", "1"},
                 new string[] {"$([MSBuild]::Add(1,2).Equals(3))", "True"},
                 new string[] {"$([MSBuild]::Add(1,2).Equals(3.0))", "True"},
+                new string[] {"$([MSBuild]::Add(1,2.0).Equals(3.0))", "True"},
+                new string[] {"$([System.Convert]::ToDouble($([MSBuild]::Add(1,2))).Equals(3.0))", "True"},
                 new string[] {"$([MSBuild]::Add(1,2).Equals('3'))", "True"},
                 new string[] {"$([MSBuild]::Add(1,2).Equals(3.1))", "False"},
+                new string[] {"$([MSBuild]::Add(1,2.0).Equals(3.1))", "False"},
+                new string[] {"$([System.Convert]::ToDouble($([MSBuild]::Add(1,2))).Equals(3.1))", "False"},
                 new string[] {"$(a.Insert(0,'%28'))", "%28no"},
                 new string[] {"$(a.Insert(0,'\"'))", "\"no"},
                 new string[] {"$(a.Insert(0,'(('))", "%28%28no"},
@@ -4173,11 +4495,34 @@ public void PropertyFunctionMathMin()
         }
 
         [Fact]
-        public void PropertyFunctionMSBuildAdd()
+        public void PropertyFunctionMSBuildAddIntegerLiteral()
         {
             TestPropertyFunction("$([MSBuild]::Add($(X), 5))", "X", "7", "12");
         }
 
+        [Fact]
+        public void PropertyFunctionMSBuildAddRealLiteral()
+        {
+            TestPropertyFunction("$([MSBuild]::Add($(X), 0.5))", "X", "7", "7.5");
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildAddIntegerOverflow()
+        {
+            // Overflow wrapping - result exceeds size of long
+            string expected = IsIntrinsicFunctionOverloadsEnabled ? "-9223372036854775808" : (long.MaxValue + 1.0).ToString();
+            TestPropertyFunction("$([MSBuild]::Add($(X), 1))", "X", long.MaxValue.ToString(), expected);
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildAddRealArgument()
+        {
+            // string argument is an integer that exceeds the size of long.
+            double value = long.MaxValue + 1.0;
+            double expected = value + 1.0;
+            TestPropertyFunction("$([MSBuild]::Add($(X), 1))", "X", value.ToString(), expected.ToString());
+        }
+
         [Fact]
         public void PropertyFunctionMSBuildAddComplex()
         {
@@ -4185,17 +4530,45 @@ public void PropertyFunctionMSBuildAddComplex()
         }
 
         [Fact]
-        public void PropertyFunctionMSBuildSubtract()
+        public void PropertyFunctionMSBuildSubtractIntegerLiteral()
         {
             TestPropertyFunction("$([MSBuild]::Subtract($(X), 20100000))", "X", "20100042", "42");
         }
 
         [Fact]
-        public void PropertyFunctionMSBuildMultiply()
+        public void PropertyFunctionMSBuildSubtractRealLiteral()
+        {
+            TestPropertyFunction("$([MSBuild]::Subtract($(X), 20100000.0))", "X", "20100042", "42");
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildSubtractIntegerMaxValue()
+        {
+            // If the double overload is used, there will be a rounding error.
+            string expected = IsIntrinsicFunctionOverloadsEnabled ? "1" : "0";
+            TestPropertyFunction("$([MSBuild]::Subtract($(X), 9223372036854775806))", "X", long.MaxValue.ToString(), expected);
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildMultiplyIntegerLiteral()
         {
             TestPropertyFunction("$([MSBuild]::Multiply($(X), 8800))", "X", "2", "17600");
         }
 
+        [Fact]
+        public void PropertyFunctionMSBuildMultiplyRealLiteral()
+        {
+            TestPropertyFunction("$([MSBuild]::Multiply($(X), 1.5))", "X", "2", "3");
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildMultiplyIntegerOverflow()
+        {
+            // Overflow - result exceeds size of long
+            string expected = IsIntrinsicFunctionOverloadsEnabled ? "-2" : (long.MaxValue * 2.0).ToString();
+            TestPropertyFunction("$([MSBuild]::Multiply($(X), 2))", "X", long.MaxValue.ToString(), expected);
+        }
+
         [Fact]
         public void PropertyFunctionMSBuildMultiplyComplex()
         {
@@ -4203,9 +4576,28 @@ public void PropertyFunctionMSBuildMultiplyComplex()
         }
 
         [Fact]
-        public void PropertyFunctionMSBuildDivide()
+        public void PropertyFunctionMSBuildDivideIntegerLiteral()
+        {
+            string expected = IsIntrinsicFunctionOverloadsEnabled ? "6" : "6.5536";
+            TestPropertyFunction("$([MSBuild]::Divide($(X), 10000))", "X", "65536", expected);
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildDivideRealLiteral()
+        {
+            TestPropertyFunction("$([MSBuild]::Divide($(X), 10000.0))", "X", "65536", "6.5536");
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildModuloIntegerLiteral()
+        {
+            TestPropertyFunction("$([MSBuild]::Modulo($(X), 3))", "X", "10", "1");
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildModuloRealLiteral()
         {
-            TestPropertyFunction("$([MSBuild]::Divide($(X), 10000))", "X", "65536", (6.5536).ToString());
+            TestPropertyFunction("$([MSBuild]::Modulo($(X), 3.0))", "X", "10", "1");
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
new file mode 100644
index 00000000000..aa43ed04e22
--- /dev/null
+++ b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
@@ -0,0 +1,478 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.Xml;
+
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+
+using Shouldly;
+
+using Xunit;
+
+namespace Microsoft.Build.Engine.UnitTests.Evaluation
+{
+    public class IntrinsicFunctionOverload_Tests
+    {
+        private Version ChangeWaveForOverloading = ChangeWaves.Wave17_8;
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void MSBuildAddInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Add($([System.Int64]::MaxValue), 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = isIntrinsicFunctionOverloadsEnabled ? unchecked(long.MaxValue + 1).ToString() : (long.MaxValue + 1.0).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+            if (!isIntrinsicFunctionOverloadsEnabled)
+            {
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildAddIntegerGreaterThanMax()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Add(9223372036854775808, 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = ((long.MaxValue +1D) + 1).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildAddIntegerLessThanMin()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Add(-9223372036854775809, 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = ((long.MinValue - 1D) + 1).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildAddReal()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Add(1.0, 2.0))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = 3.0.ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void MSBuildSubtractInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Subtract($([System.Int64]::MaxValue), 9223372036854775806))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = isIntrinsicFunctionOverloadsEnabled ? 1.ToString() : 0.ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+            if (!isIntrinsicFunctionOverloadsEnabled)
+            {
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildSubtractIntegerGreaterThanMax()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Subtract(9223372036854775808, 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = ((long.MaxValue + 1D) - 1).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildSubtractIntegerLessThanMin()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Subtract(-9223372036854775809, 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = ((long.MinValue - 1D) - 1).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildSubtractReal()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Subtract(2.0, 1.0))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = 1.0.ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void MSBuildMultiplyInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Multiply($([System.Int64]::MaxValue), 2))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = isIntrinsicFunctionOverloadsEnabled ? unchecked(long.MaxValue * 2).ToString() : (long.MaxValue * 2.0).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+            if (!isIntrinsicFunctionOverloadsEnabled)
+            {
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildMultiplyIntegerGreaterThanMax()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Multiply(9223372036854775808, 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = ((long.MaxValue + 1D) * 1).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildMultiplyIntegerLessThanMin()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Multiply(-9223372036854775809, 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = ((long.MinValue - 1D) * 1).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildMultiplyReal()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Multiply(2.0, 1.0))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = 2.0.ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void MSBuildDivideInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Divide(10, 3))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = isIntrinsicFunctionOverloadsEnabled ? (10 / 3).ToString() : (10.0 / 3.0).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+            if (!isIntrinsicFunctionOverloadsEnabled)
+            {
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildDivideIntegerGreaterThanMax()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Divide(9223372036854775808, 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = ((long.MaxValue + 1D) / 1).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildDivideIntegerLessThanMin()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Divide(-9223372036854775809, 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = ((long.MinValue - 1D) / 1).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildDivideReal()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Divide(1, 0.5))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = 2.0.ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void MSBuildModuloInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Modulo(10, 3))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = 1.ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+            if (!isIntrinsicFunctionOverloadsEnabled)
+            {
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildModuloIntegerGreaterThanMax()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Modulo(9223372036854775808, 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = ((long.MaxValue + 1D) % 1).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildModuloIntegerLessThanMin()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Modulo(-9223372036854775809, 1))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = ((long.MinValue - 1D) % 1).ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+
+        [Fact]
+        public void MSBuildModuloReal()
+        {
+            const string projectContent = @"
+                    <Project>
+                        <PropertyGroup>
+                            <Actual>$([MSBuild]::Modulo(11.0, 2.5))</Actual>
+                        </PropertyGroup>
+                    </Project>";
+
+            string expected = 1.ToString();
+
+            using TestEnvironment env = TestEnvironment.Create();
+
+            ChangeWaves.ResetStateForTests();
+
+            var project = new Project(XmlReader.Create(new StringReader(projectContent.Cleanup())));
+            ProjectProperty? actualProperty = project.GetProperty("Actual");
+            actualProperty.EvaluatedValue.ShouldBe(expected);
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
new file mode 100644
index 00000000000..8ede8eec729
--- /dev/null
+++ b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
@@ -0,0 +1,42 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+
+using Xunit;
+
+namespace Microsoft.Build.Evaluation;
+
+public sealed class UsedUninitializedProperties_Tests
+{
+    [Fact]
+    public void Basics()
+    {
+        UsedUninitializedProperties props = new();
+
+        Assert.False(props.TryGetPropertyElementLocation("Hello", out IElementLocation? elementLocation));
+        Assert.Null(elementLocation);
+
+        props.RemoveProperty("Hello");
+
+        IElementLocation location1 = new MockElementLocation("File1");
+        IElementLocation location2 = new MockElementLocation("File2");
+
+        props.TryAdd("Hello", location1);
+        props.TryAdd("Hello", location2);
+
+        Assert.True(props.TryGetPropertyElementLocation("Hello", out elementLocation));
+        Assert.Same(location1, elementLocation);
+
+        Assert.True(props.TryGetPropertyElementLocation("Hello", out elementLocation));
+        Assert.Same(location1, elementLocation);
+
+        props.RemoveProperty("Hello");
+
+        Assert.False(props.TryGetPropertyElementLocation("Hello", out elementLocation));
+        Assert.Null(elementLocation);
+
+        props.RemoveProperty("Hello");
+    }
+}
diff --git a/src/Build.UnitTests/EvaluationProfiler_Tests.cs b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
index 27438bec72e..078dc9e3520 100644
--- a/src/Build.UnitTests/EvaluationProfiler_Tests.cs
+++ b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
@@ -67,8 +67,14 @@ public EvaluationProfiler_Tests(ITestOutputHelper output)
         /// <nodoc/>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
index 845b0c556c8..b941649ad74 100644
--- a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -27,7 +27,7 @@ namespace Microsoft.Build.Graph.UnitTests
     /// <summary>
     /// Performs SetPlatform negotiation for all project references when opted
     /// in via the EnableDynamicPlatformResolution property.
-    /// 
+    ///
     /// The static graph mirrors the negotiation during build to determine plartform for each node.
     /// These tests mirror GetCompatiblePlatform_Tests.cs in order to make sure they both are in sync.
     /// </summary>
@@ -351,5 +351,102 @@ public void PlatformIsChosenAsDefault()
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GetPropertyValue("Platform").ShouldBe(GetFirstNodeWithProjectNumber(graph, 1).ProjectInstance.GetPropertyValue("Platform"));
             }
         }
+
+        // Validate configurations are defined in project reference protocol
+        [Fact]
+        public void SolutionWithoutAllConfigurations()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                var firstProjectName = "1";
+                var secondProjectName = "2";
+                var thirdProjectName = "3";
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder project1Folder = testEnvironment.CreateFolder(Path.Combine(folder.Path, firstProjectName), createFolder: true);
+                TransientTestFolder project1SubFolder = testEnvironment.CreateFolder(Path.Combine(project1Folder.Path, firstProjectName), createFolder: true);
+                TransientTestFile project1 = testEnvironment.CreateFile(project1SubFolder, $"{firstProjectName}.csproj",
+                    @"<Project>
+                        <PropertyGroup>
+                             <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                             <Platform>x64</Platform>
+                         </PropertyGroup>
+                         <ItemGroup>
+                             <ProjectReference Include=""$(MSBuildThisFileDirectory)\..\..\2\2\2.proj"" />
+                             <ProjectReference Include=""$(MSBuildThisFileDirectory)\..\..\3\3\3.proj"" />
+                         </ItemGroup>
+                  </Project>
+                    ");
+
+                TransientTestFolder project2Folder = testEnvironment.CreateFolder(Path.Combine(folder.Path, secondProjectName), createFolder: true);
+                TransientTestFolder project2SubFolder = testEnvironment.CreateFolder(Path.Combine(project2Folder.Path, secondProjectName), createFolder: true);
+                TransientTestFile project2 = testEnvironment.CreateFile(project2SubFolder, $"{secondProjectName}.proj",
+                    @"<Project>
+                        <PropertyGroup>
+                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                            <Platforms>AnyCPU;x64</Platforms>
+                        </PropertyGroup>
+                    </Project>
+                    ");
+
+                TransientTestFolder project3Folder = testEnvironment.CreateFolder(Path.Combine(folder.Path, thirdProjectName), createFolder: true);
+                TransientTestFolder project3SubFolder = testEnvironment.CreateFolder(Path.Combine(project3Folder.Path, thirdProjectName), createFolder: true);
+                TransientTestFile project3 = testEnvironment.CreateFile(project3SubFolder, $"{thirdProjectName}.proj",
+                    @"<Project>
+                        <PropertyGroup>
+                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                            <Platforms>AnyCPU;x64</Platforms>
+                        </PropertyGroup>
+                    </Project>
+                    ");
+
+
+                // Slashes here (and in the .slnf) are hardcoded as backslashes intentionally to support the common case.
+                TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "SimpleProject.sln",
+                    @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.0.29326.124
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Project1"", ""1\1\1.csproj"", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""2"", ""2\2\2.proj"", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|x64 = Debug|x64
+                            Release|x64 = Release|x64
+                            EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|x64.ActiveCfg = Debug|x64
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|x64.Build.0 = Debug|x64
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|x64.ActiveCfg = Release|x64
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|x64.Build.0 = Release|x64
+
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|x64.ActiveCfg = Debug|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|x64.Build.0 = Debug|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|x64.ActiveCfg = Release|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|x64.Build.0 = Release|Any CPU
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                        GlobalSection(ExtensibilityGlobals) = postSolution
+                            SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
+                        EndGlobalSection
+                    EndGlobal
+                ");
+
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+                MockLogger logger = new();
+                projectCollection.RegisterLogger(logger);
+                ProjectGraphEntryPoint entryPoint = new(solutionFile.Path, new Dictionary<string, string>());
+
+                // We want to make sure negotiation respects configuration if defined but negotiates if not.
+                ProjectGraph graphFromSolution = new(entryPoint, projectCollection);
+                logger.AssertNoErrors();
+                GetFirstNodeWithProjectNumber(graphFromSolution, 2).ProjectInstance.GetPropertyValue("Platform").ShouldBe("AnyCPU", "Project2 should have followed the sln config to AnyCPU");
+                GetFirstNodeWithProjectNumber(graphFromSolution, 3).ProjectInstance.GetPropertyValue("Platform").ShouldBe("x64", "Project3 isn't in the solution so it should have negotiated to x64 to match Project1");
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 5033b018ce7..431ea412875 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -524,18 +524,37 @@ public void SolutionsCanInjectEdgesIntoTheProjectGraph(Dictionary<int, int[]> ed
 
             var graphFromSolutionEdges = graphFromSolution.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
 
-            // Solutions add the CurrentSolutionConfigurationContents global property for platform resolution
-            foreach ((ConfigurationMetadata, ConfigurationMetadata) graphFromSolutionEdge in graphFromSolutionEdges.Keys)
+            // These are global properties added by GraphBuilder when building a solution
+            HashSet<string> propertiesToIgnore = new(StringComparer.OrdinalIgnoreCase)
             {
-                graphFromSolutionEdge.Item1.GlobalProperties.ShouldContainKey("CurrentSolutionConfigurationContents");
-                graphFromSolutionEdge.Item2.GlobalProperties.ShouldContainKey("CurrentSolutionConfigurationContents");
+                "CurrentSolutionConfigurationContents",
+                "BuildingSolutionFile",
+                "SolutionDir",
+                "SolutionExt",
+                "SolutionFileName",
+                "SolutionName",
+                SolutionProjectGenerator.SolutionPathPropertyName
+            };
+
+            // Solutions add these global properties
+            foreach (string propertyToIgnore in propertiesToIgnore)
+            {
+                foreach ((ConfigurationMetadata, ConfigurationMetadata) graphFromSolutionEdge in graphFromSolutionEdges.Keys)
+                {
+                    graphFromSolutionEdge.Item1.GlobalProperties.ShouldContainKey(propertyToIgnore);
+                    graphFromSolutionEdge.Item2.GlobalProperties.ShouldContainKey(propertyToIgnore);
+                }
             }
 
-            // Remove CurrentSolutionConfigurationContents for comparison purposes. This is done as a separate pass since some edges may be sharing an instance.
-            foreach ((ConfigurationMetadata, ConfigurationMetadata) graphFromSolutionEdge in graphFromSolutionEdges.Keys)
+            // Remove some properties for comparison purposes as we are comparing a graph created from a solution against the graph (without solution properties) used to make the solution.
+            // This is done as a separate pass since some edges may be sharing an instance.
+            foreach (string propertyToIgnore in propertiesToIgnore)
             {
-                graphFromSolutionEdge.Item1.GlobalProperties.Remove("CurrentSolutionConfigurationContents");
-                graphFromSolutionEdge.Item2.GlobalProperties.Remove("CurrentSolutionConfigurationContents");
+                foreach ((ConfigurationMetadata, ConfigurationMetadata) graphFromSolutionEdge in graphFromSolutionEdges.Keys)
+                {
+                    graphFromSolutionEdge.Item1.GlobalProperties.Remove(propertyToIgnore);
+                    graphFromSolutionEdge.Item2.GlobalProperties.Remove(propertyToIgnore);
+                }
             }
 
             // Original edges get preserved.
@@ -676,8 +695,9 @@ private void AssertSolutionBasedGraph(
             var globalProperties = currentSolutionConfiguration != null
                 ? new Dictionary<string, string>
                 {
-                    ["Configuration"] = currentSolutionConfiguration.ConfigurationName,
-                    ["Platform"] = currentSolutionConfiguration.PlatformName
+                    // Intentionally use mismatched casing to ensure it's properly normalized.
+                    ["Configuration"] = currentSolutionConfiguration.ConfigurationName.ToUpperInvariant(),
+                    ["Platform"] = currentSolutionConfiguration.PlatformName.ToUpperInvariant()
                 }
                 : new Dictionary<string, string>();
 
@@ -687,6 +707,9 @@ private void AssertSolutionBasedGraph(
                     globalProperties),
                 _env.CreateProjectCollection().Collection);
 
+            // Exactly 1 node per project
+            graph.ProjectNodes.Count.ShouldBe(graph.ProjectNodes.Select(GetProjectPath).Distinct().Count());
+
             // in the solution, all nodes are entry points
             graphFromSolution.EntryPointNodes.Select(GetProjectPath)
                 .ShouldBeSetEquivalentTo(graph.ProjectNodes.Select(GetProjectPath));
@@ -705,19 +728,9 @@ private void AssertSolutionBasedGraph(
 
             foreach (var node in graphFromSolution.ProjectNodes)
             {
-                // Project references get duplicated, once as entry points from the solution (handled in the if block) and once as nodes
-                // produced by ProjectReference items (handled in the else block).
-                if (node.ReferencingProjects.Count == 0)
-                {
-                    var expectedProjectConfiguration = actualProjectConfigurations[GetProjectNumber(node).ToString()][expectedCurrentConfiguration];
-                    GetConfiguration(node).ShouldBe(expectedProjectConfiguration.ConfigurationName);
-                    GetPlatform(node).ShouldBe(expectedProjectConfiguration.PlatformName);
-                }
-                else
-                {
-                    GetConfiguration(node).ShouldBe(GetConfiguration(node.ReferencingProjects.First()));
-                    GetPlatform(node).ShouldBe(GetPlatform(node.ReferencingProjects.First()));
-                }
+                var expectedProjectConfiguration = actualProjectConfigurations[GetProjectNumber(node).ToString()][expectedCurrentConfiguration];
+                GetConfiguration(node).ShouldBe(expectedProjectConfiguration.ConfigurationName);
+                GetPlatform(node).ShouldBe(expectedProjectConfiguration.PlatformName);
             }
         }
 
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 3c504a35e59..932c3c8e439 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -681,6 +681,8 @@ public void ConstructGraphWithSolution()
             // This test exercises two key features of solution-based builds from AssignProjectConfiguration:
             // 1. Adding synthetic project references
             // 2. Resolving project configuration based on the sln
+            // 3. Handling unresolved project references with ShouldUnsetParentConfigurationAndPlatform=true
+            // 4. Handling unresolved project references with ShouldUnsetParentConfigurationAndPlatform=false
             using (var env = TestEnvironment.Create())
             {
                 const string SolutionFileContents = """
@@ -766,21 +768,37 @@ public void ConstructGraphWithSolution()
                 project1Xml.AddItem("ProjectReference", "Project2.vcxproj");
 
                 ProjectRootElement project2Xml = ProjectRootElement.Create();
+
+                // Project 2 depends on Project 4, which is not in the solution and uses ShouldUnsetParentConfigurationAndPlatform=true (the default)
+                project2Xml.AddItem("ProjectReference", "Project4.vcxproj");
+                project2Xml.AddProperty("ShouldUnsetParentConfigurationAndPlatform", "true");
+
                 ProjectRootElement project3Xml = ProjectRootElement.Create();
 
+                // Project 3 depends on Project 5, which is not in the solution and uses ShouldUnsetParentConfigurationAndPlatform=false
+                project3Xml.AddItem("ProjectReference", "Project5.vcxproj");
+                project3Xml.AddProperty("ShouldUnsetParentConfigurationAndPlatform", "false");
+
+                ProjectRootElement project4Xml = ProjectRootElement.Create();
+                ProjectRootElement project5Xml = ProjectRootElement.Create();
+
                 string project1Path = Path.Combine(env.DefaultTestDirectory.Path, "Project1.csproj");
                 string project2Path = Path.Combine(env.DefaultTestDirectory.Path, "Project2.vcxproj");
                 string project3Path = Path.Combine(env.DefaultTestDirectory.Path, "Project3.vcxproj");
+                string project4Path = Path.Combine(env.DefaultTestDirectory.Path, "Project4.vcxproj");
+                string project5Path = Path.Combine(env.DefaultTestDirectory.Path, "Project5.vcxproj");
 
                 project1Xml.Save(project1Path);
                 project2Xml.Save(project2Path);
                 project3Xml.Save(project3Path);
+                project4Xml.Save(project4Path);
+                project5Xml.Save(project5Path);
 
                 var projectGraph = new ProjectGraph(slnFile.Path);
                 projectGraph.EntryPointNodes.Count.ShouldBe(3);
                 projectGraph.GraphRoots.Count.ShouldBe(1);
                 projectGraph.GraphRoots.First().ProjectInstance.FullPath.ShouldBe(project1Path);
-                projectGraph.ProjectNodes.Count.ShouldBe(3);
+                projectGraph.ProjectNodes.Count.ShouldBe(5);
 
                 ProjectGraphNode project1Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project1Path);
                 project1Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
@@ -790,12 +808,24 @@ public void ConstructGraphWithSolution()
                 ProjectGraphNode project2Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project2Path);
                 project2Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
                 project2Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
-                project2Node.ProjectReferences.Count.ShouldBe(0);
+                project2Node.ProjectReferences.Count.ShouldBe(1);
 
                 ProjectGraphNode project3Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project3Path);
                 project3Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
                 project3Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
-                project3Node.ProjectReferences.Count.ShouldBe(0);
+                project3Node.ProjectReferences.Count.ShouldBe(1);
+
+                // Configuration and Platform get unset
+                ProjectGraphNode project4Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project4Path);
+                project4Node.ProjectInstance.GlobalProperties.ContainsKey("Configuration").ShouldBeFalse();
+                project4Node.ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+                project4Node.ProjectReferences.Count.ShouldBe(0);
+
+                // Configuration and Platform are inherited from the referencing project
+                ProjectGraphNode project5Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project5Path);
+                project5Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project5Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                project5Node.ProjectReferences.Count.ShouldBe(0);
             }
         }
 
@@ -2633,6 +2663,71 @@ public void MultipleProjectReferencesSameFileDifferentTargets()
             targetLists[project2].ShouldBe(new[] { "SomeDefaultTarget2", "SomeOtherTarget" });
         }
 
+        [Fact]
+        public void MultitargettingTargetsWithBuildProjectReferencesFalse()
+        {
+            // This test should emulate Microsoft.Managed.After.targets's handling of multitargetting projects.
+            ProjectGraph graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: new Dictionary<int, int[]>()
+                {
+                    { 1, new[] { 2 } },
+                },
+                globalProperties: new Dictionary<string, string> { { "BuildProjectReferences", "false" } },
+                extraContentForAllNodes: """
+                <PropertyGroup>
+                  <TargetFrameworks>netcoreapp3.1;net6.0;net7.0</TargetFrameworks>
+                </PropertyGroup>
+
+                <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">
+                  <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
+                </PropertyGroup>
+
+                <PropertyGroup>
+                  <InnerBuildProperty>TargetFramework</InnerBuildProperty>
+                  <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
+                </PropertyGroup>
+
+                <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' != 'true'">
+                  <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
+                  <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
+
+                  <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+                </PropertyGroup>
+                <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' == 'true'">
+                  <ProjectReferenceTargetsForBuild>.default;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+                </PropertyGroup>
+
+                <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
+                  <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
+                  <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
+
+                  <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
+                </ItemGroup>
+
+                <Target Name="Build" />
+                <Target Name="GetTargetPath" />
+                <Target Name="GetNativeManifest" />
+                <Target Name="GetTargetFrameworks" />
+                <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework" />
+                """);
+
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(Array.Empty<string>());
+
+            targetLists[GetOuterBuild(graph, 1)].ShouldBe(new[] { "Build" });
+            foreach (ProjectGraphNode inner in GetInnerBuilds(graph, 1))
+            {
+                targetLists[inner].ShouldBe(new[] { "Build" });
+            }
+
+            targetLists[GetOuterBuild(graph, 2)].ShouldBe(new[] { "GetTargetFrameworks" });
+            foreach (ProjectGraphNode inner in GetInnerBuilds(graph, 2))
+            {
+                // GetTargetFrameworks actually shouldn't be here...
+                targetLists[inner].ShouldBe(new[] { "GetTargetFrameworks", "GetTargetPath", "GetNativeManifest", "GetTargetFrameworksWithPlatformForSingleTargetFramework" });
+            }
+        }
+
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/InternalEngineHelpers.cs b/src/Build.UnitTests/InternalEngineHelpers.cs
index 4751aef9ddd..8590a479da9 100644
--- a/src/Build.UnitTests/InternalEngineHelpers.cs
+++ b/src/Build.UnitTests/InternalEngineHelpers.cs
@@ -175,7 +175,7 @@ internal static void AssertBuildResultsEqual(BuildResult actualBuildResult, Buil
 
             internal static void AssertTargetResultsEqual(TargetResult a, TargetResult b)
             {
-                TranslationHelpers.CompareExceptions(a.Exception, b.Exception).ShouldBeTrue();
+                TranslationHelpers.CompareExceptions(a.Exception, b.Exception, out string diffReason).ShouldBeTrue(diffReason);
                 TranslationHelpers.CompareCollections(a.Items, b.Items, TaskItemComparer.Instance).ShouldBeTrue();
 
                 a.ResultCode.ShouldBe(b.ResultCode);
diff --git a/src/Build.UnitTests/InvalidProjectFileException_Tests.cs b/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
index 499927b7c47..8e1d50c18d6 100644
--- a/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
+++ b/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
@@ -22,42 +22,6 @@ public InvalidProjectFileExceptionTests(ITestOutputHelper output)
             _testOutput = output;
         }
 
-        /// <summary>
-        /// Verify I implemented ISerializable correctly
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize()
-        {
-            InvalidProjectFileException e = new InvalidProjectFileException(
-                "projectFile",
-                1, 2, 3, 4,
-                "message",
-                "errorSubcategory",
-                "errorCode",
-                "helpKeyword");
-
-            using (MemoryStream memstr = new MemoryStream())
-            {
-                BinaryFormatter frm = new BinaryFormatter();
-
-                frm.Serialize(memstr, e);
-                memstr.Position = 0;
-
-                InvalidProjectFileException e2 = (InvalidProjectFileException)frm.Deserialize(memstr);
-
-                Assert.Equal(e.ColumnNumber, e2.ColumnNumber);
-                Assert.Equal(e.EndColumnNumber, e2.EndColumnNumber);
-                Assert.Equal(e.EndLineNumber, e2.EndLineNumber);
-                Assert.Equal(e.ErrorCode, e2.ErrorCode);
-                Assert.Equal(e.ErrorSubcategory, e2.ErrorSubcategory);
-                Assert.Equal(e.HasBeenLogged, e2.HasBeenLogged);
-                Assert.Equal(e.HelpKeyword, e2.HelpKeyword);
-                Assert.Equal(e.LineNumber, e2.LineNumber);
-                Assert.Equal(e.Message, e2.Message);
-                Assert.Equal(e.ProjectFile, e2.ProjectFile);
-            }
-        }
-
         /// <summary>
         /// Verify that nesting an IPFE copies the error code
         /// </summary>
diff --git a/src/Build.UnitTests/LoggerException_Tests.cs b/src/Build.UnitTests/LoggerException_Tests.cs
deleted file mode 100644
index 6a052a7ee27..00000000000
--- a/src/Build.UnitTests/LoggerException_Tests.cs
+++ /dev/null
@@ -1,49 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.IO;
-using System.Runtime.Serialization.Formatters.Binary;
-using Microsoft.Build.Exceptions;
-using Microsoft.Build.Framework;
-using Xunit;
-
-#nullable disable
-
-namespace Microsoft.Build.UnitTests
-{
-    public class InternalLoggerExceptionTests
-    {
-        /// <summary>
-        /// Verify I implemented ISerializable correctly
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize()
-        {
-            InternalLoggerException e = new InternalLoggerException(
-                "message",
-                new Exception("innerException"),
-                new BuildStartedEventArgs("evMessage", "evHelpKeyword"),
-                "errorCode",
-                "helpKeyword",
-                false);
-
-            using (MemoryStream memstr = new MemoryStream())
-            {
-                BinaryFormatter frm = new BinaryFormatter();
-
-                frm.Serialize(memstr, e);
-                memstr.Position = 0;
-
-                InternalLoggerException e2 = (InternalLoggerException)frm.Deserialize(memstr);
-
-                Assert.Equal(e.BuildEventArgs.Message, e2.BuildEventArgs.Message);
-                Assert.Equal(e.BuildEventArgs.HelpKeyword, e2.BuildEventArgs.HelpKeyword);
-                Assert.Equal(e.ErrorCode, e2.ErrorCode);
-                Assert.Equal(e.HelpKeyword, e2.HelpKeyword);
-                Assert.Equal(e.Message, e2.Message);
-                Assert.Equal(e.InnerException.Message, e2.InnerException.Message);
-            }
-        }
-    }
-}
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index f7493839380..92fc5c72239 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -15,6 +15,8 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+    <PackageReference Include="FluentAssertions" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
@@ -45,6 +47,9 @@
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' == 'true'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=$(LatestDotNetCoreForMSBuild)</SetTargetFramework>
     </ProjectReference>
+
+    <Reference Include="System.IO.Compression"
+               Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' " />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
deleted file mode 100644
index 66ef134bbe3..00000000000
--- a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
+++ /dev/null
@@ -1,68 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Text;
-using System.Xml;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework.Profiler;
-using Microsoft.Build.UnitTests.BackEnd;
-using Xunit;
-
-#nullable disable
-
-namespace Microsoft.Build.UnitTests
-{
-    // Although this tests the ProfilerResult API from Microsoft.Build.Framework, it uses the
-    //  construction APIs in Microsoft.Build in the test, so this test is in the Microsoft.Build tests
-    public class ProjectEvaluationFinishedEventArgs_Tests
-    {
-        /// <summary>
-        /// Roundtrip serialization tests for <see cref="ProfilerResult"/>
-        /// </summary>
-        [MemberData(nameof(GetProfilerResults))]
-        [Theory]
-        public void ProfilerResultRoundTrip(ProfilerResult profilerResult)
-        {
-            var writeTranslator = TranslationHelpers.GetWriteTranslator();
-            ProfilerResult deserializedResult = default;
-
-            writeTranslator.TranslateDotNet(ref profilerResult);
-
-            var readTranslator = TranslationHelpers.GetReadTranslator();
-
-            readTranslator.TranslateDotNet(ref deserializedResult);
-
-            Assert.Equal(deserializedResult, profilerResult);
-        }
-
-        public static IEnumerable<object[]> GetProfilerResults()
-        {
-            yield return new object[] { new ProfilerResult(new Dictionary<EvaluationLocation, ProfiledLocation>()) };
-
-            yield return new object[] { new ProfilerResult(new Dictionary<EvaluationLocation, ProfiledLocation>
-            {
-                {new EvaluationLocation(0, null, EvaluationPass.TotalEvaluation, "1", "myFile", 42, "elementName", "description", EvaluationLocationKind.Condition), new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2) },
-                {new EvaluationLocation(1, 0, EvaluationPass.Targets, "1", null, null, null, null, EvaluationLocationKind.Glob), new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2) },
-                {new EvaluationLocation(2, 0, EvaluationPass.LazyItems, "2", null, null, null, null, EvaluationLocationKind.Element), new ProfiledLocation(TimeSpan.Zero, TimeSpan.Zero, 0) }
-            }) };
-
-            var element = new ProjectRootElement(
-                XmlReader.Create(new MemoryStream(Encoding.UTF8.GetBytes(
-                    "<Project />"))),
-                new ProjectRootElementCache(false), false, false);
-
-            yield return new object[] { new ProfilerResult(new Dictionary<EvaluationLocation, ProfiledLocation>
-            {
-                {EvaluationLocation.CreateLocationForCondition(null, EvaluationPass.UsingTasks, "1", "myFile", 42, "conditionCase"), new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2) },
-                {EvaluationLocation.CreateLocationForProject(null, EvaluationPass.InitialProperties, "1", "myFile", 42, element),
-                    new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2) },
-                {EvaluationLocation.CreateLocationForGlob(null, EvaluationPass.InitialProperties, "1", "myFile", 42, "glob description"),
-                new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2) }
-            }) };
-        }
-    }
-}
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 364c68081a9..36094ff2bec 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -898,10 +898,10 @@ public void NoLinkMetadataSynthesisWhenDefinedInProject()
         }
 
         /// <summary>
-        /// Synthesizes Link metadata if the items are defined in an import and are on the whitelist
+        /// Synthesizes Link metadata if the items are defined in an import and are on the allowlist
         /// </summary>
         [Fact]
-        public void SynthesizeLinkMetadataForItemsOnWhitelist()
+        public void SynthesizeLinkMetadataForItemsOnAllowlist()
         {
             string outputPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
             string directoryToDelete = null;
diff --git a/src/Build.UnitTests/TaskThatReturnsMinimalItem.cs b/src/Build.UnitTests/TaskThatReturnsMinimalItem.cs
new file mode 100644
index 00000000000..7f8eec32b2a
--- /dev/null
+++ b/src/Build.UnitTests/TaskThatReturnsMinimalItem.cs
@@ -0,0 +1,48 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Engine.UnitTests;
+
+/// <summary>
+/// Task that emulates .NET 3.5 tasks.
+/// </summary>
+public sealed class TaskThatReturnsMinimalItem : ITask
+{
+    public IBuildEngine? BuildEngine { get; set; }
+    public ITaskHost? HostObject { get; set; }
+
+    [Output]
+    public ITaskItem MinimalTaskItemOutput { get => new MinimalTaskItem(); }
+
+    public bool Execute() => true;
+
+    /// <summary>
+    /// Minimal implementation of <see cref="ITaskItem"/> that uses a <see cref="Hashtable"/> for metadata,
+    /// like MSBuild 3 did.
+    /// </summary>
+    internal sealed class MinimalTaskItem : ITaskItem
+    {
+        public string ItemSpec { get => $"{nameof(MinimalTaskItem)}spec"; set => throw new NotImplementedException(); }
+
+        public ICollection MetadataNames => throw new NotImplementedException();
+
+        public int MetadataCount => throw new NotImplementedException();
+
+        public IDictionary CloneCustomMetadata()
+        {
+            Hashtable t = new();
+            t["key"] = "value";
+
+            return t;
+        }
+        public void CopyMetadataTo(ITaskItem destinationItem) => throw new NotImplementedException();
+        public string GetMetadata(string metadataName) => "value";
+        public void RemoveMetadata(string metadataName) => throw new NotImplementedException();
+        public void SetMetadata(string metadataName, string metadataValue) => throw new NotImplementedException();
+    }
+}
diff --git a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
new file mode 100644
index 00000000000..84e458f6a54
--- /dev/null
+++ b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
@@ -0,0 +1,237 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Framework.Telemetry;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.UnitTests;
+
+/// <summary>
+/// End to end tests for the terminal logger configuration.
+/// We need to execute msbuild process as tested code path is also in XMake.cs.
+/// Also verifies that the telemetry is logged correctly.
+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.
+/// </summary>
+public class TerminalLoggerConfiguration_Tests : IDisposable
+{
+    private readonly TestEnvironment _env;
+
+    private readonly string _cmd;
+    private readonly ITestOutputHelper _output;
+
+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)
+    {
+        _env = TestEnvironment.Create(output);
+        _output = output;
+
+        // Ignore environment variables that may have been set by the environment where the tests are running.
+        _env.SetEnvironmentVariable("MSBUILDLIVELOGGER", null);
+        _env.SetEnvironmentVariable("MSBUILDTERMINALLOGGER", null);
+
+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);
+        TransientTestFile projectFile = _env.CreateFile(logFolder, "myProj.proj", $"""
+            <Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Hello">
+                <Target Name="Hello">
+                  <Message Text="Hello, world!" />
+                </Target>
+            </Project>
+            """);
+        _cmd = $"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry";
+    }
+
+    /// <summary>
+    /// TearDown
+    /// </summary>
+    public void Dispose()
+    {
+        _env.Dispose();
+    }
+
+    [Theory]
+    [InlineData("on")]
+    [InlineData("true")]
+    public void TerminalLoggerOn(string tlValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tl:{tlValue}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = bool.FalseString,
+            TerminalLoggerDefaultSource = "msbuild",
+            TerminalLoggerUserIntent = tlValue,
+            TerminalLoggerUserIntentSource = "arg",
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("")]
+    [InlineData("auto")]
+    public void TerminalLoggerWithTlAutoIsOff(string tlValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tl:{tlValue}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = false,
+            TerminalLoggerDefault = bool.FalseString,
+            TerminalLoggerDefaultSource = "msbuild",
+            TerminalLoggerUserIntent = tlValue,
+            TerminalLoggerUserIntentSource = "arg",
+            ConsoleLogger = true,
+            ConsoleLoggerType = "parallel",
+            ConsoleLoggerVerbosity = "normal",
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldNotBeTerminalLog(output);
+    }
+
+
+    [Fact]
+    public void TerminalLoggerDefaultByEnv()
+    {
+        _env.SetEnvironmentVariable("DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER", bool.TrueString);
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tlp:default={bool.TrueString}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = bool.TrueString,
+            TerminalLoggerDefaultSource = "DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER",
+            TerminalLoggerUserIntent = null,
+            TerminalLoggerUserIntentSource = null,
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("MSBUILDLIVELOGGER")]
+    [InlineData("MSBUILDTERMINALLOGGER")]
+    public void TerminalLoggerOnByEnv(string envVarSource)
+    {
+        _env.SetEnvironmentVariable(envVarSource, bool.TrueString);
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = bool.FalseString,
+            TerminalLoggerDefaultSource = "msbuild",
+            TerminalLoggerUserIntent = bool.TrueString,
+            TerminalLoggerUserIntentSource = envVarSource,
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("on")]
+    [InlineData("true")]
+    public void TerminalLoggerDefaultOn(string defaultValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tlp:default={defaultValue}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = defaultValue,
+            TerminalLoggerDefaultSource = "sdk",
+            TerminalLoggerUserIntent = null,
+            TerminalLoggerUserIntentSource = null,
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("off")]
+    [InlineData("false")]
+    public void TerminalLoggerDefaultOff(string defaultValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tlp:default={defaultValue} -v:m", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = false,
+            TerminalLoggerDefault = defaultValue,
+            TerminalLoggerDefaultSource = "sdk",
+            TerminalLoggerUserIntent = null,
+            TerminalLoggerUserIntentSource = null,
+            ConsoleLogger = true,
+            ConsoleLoggerVerbosity = "minimal",
+            ConsoleLoggerType = "parallel", 
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldNotBeTerminalLog(output);
+    }
+
+    private static void ShouldBeTerminalLog(string output) => output.ShouldContain("\x1b[?25l");
+    private static void ShouldNotBeTerminalLog(string output) => output.ShouldNotContain("\x1b[?25l");
+}
diff --git a/src/Build.UnitTests/TestComparers/TaskRegistryComparers.cs b/src/Build.UnitTests/TestComparers/TaskRegistryComparers.cs
index 380d2b73bb6..31360a91580 100644
--- a/src/Build.UnitTests/TestComparers/TaskRegistryComparers.cs
+++ b/src/Build.UnitTests/TestComparers/TaskRegistryComparers.cs
@@ -20,6 +20,7 @@ internal sealed class TaskRegistryComparer : IEqualityComparer<TaskRegistry>
             public bool Equals(TaskRegistry x, TaskRegistry y)
             {
                 Assert.Equal(x.Toolset, y.Toolset, new ToolsetComparer());
+                Assert.Equal(x.NextRegistrationOrderId, y.NextRegistrationOrderId);
 
                 Helpers.AssertDictionariesEqual(
                     x.TaskRegistrations,
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 40a6964c0e5..86a5a8073d2 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -32,3 +32,6 @@
 
 [assembly: ComVisible(false)]
 [assembly: CLSCompliant(true)]
+
+[assembly: Dependency("BuildXL.Utilities.Core", LoadHint.Sometimes)]
+[assembly: Dependency("BuildXL.Processes", LoadHint.Sometimes)]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 9787ffe4a5c..fc71b1c1d1d 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -13,6 +13,7 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Runtime.CompilerServices;
 using System.Runtime.ExceptionServices;
 using System.Threading;
 using System.Threading.Tasks;
@@ -25,6 +26,7 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Graph;
@@ -306,6 +308,7 @@ public BuildManager(string hostName)
             _nextUnnamedProjectId = 1;
             _componentFactories = new BuildComponentFactoryCollection(this);
             _componentFactories.RegisterDefaultFactories();
+            SerializationContractInitializer.Initialize();
             _projectStartedEvents = new Dictionary<int, BuildEventArgs>();
 
             _projectStartedEventHandler = OnProjectStarted;
@@ -334,13 +337,13 @@ private enum BuildManagerState
             Idle,
 
             /// <summary>
-            /// This is the state the BuildManager is in after <see cref="BeginBuild(BuildParameters)"/> has been called but before <see cref="EndBuild"/> has been called.
-            /// <see cref="BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.PendBuildRequest(GraphBuildRequestData)"/>, <see cref="BuildManager.BuildRequest(GraphBuildRequestData)"/>, and <see cref="BuildManager.EndBuild"/> may be called in this state.
+            /// This is the state the BuildManager is in after <see cref="BeginBuild(BuildParameters)"/> has been called but before <see cref="EndBuild()"/> has been called.
+            /// <see cref="BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.PendBuildRequest(GraphBuildRequestData)"/>, <see cref="BuildManager.BuildRequest(GraphBuildRequestData)"/>, and <see cref="BuildManager.EndBuild()"/> may be called in this state.
             /// </summary>
             Building,
 
             /// <summary>
-            /// This is the state the BuildManager is in after <see cref="BuildManager.EndBuild"/> has been called but before all existing submissions have completed.
+            /// This is the state the BuildManager is in after <see cref="BuildManager.EndBuild()"/> has been called but before all existing submissions have completed.
             /// </summary>
             WaitingForBuildToComplete
         }
@@ -557,6 +560,13 @@ public void BeginBuild(BuildParameters parameters)
                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath("msbuild-cache");
                 }
 
+#if FEATURE_REPORTFILEACCESSES
+                if (_buildParameters.ReportFileAccesses)
+                {
+                    EnableDetouredNodeLauncher();
+                }
+#endif
+
                 // Initialize components.
                 _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;
 
@@ -565,11 +575,23 @@ public void BeginBuild(BuildParameters parameters)
                 // Log deferred messages and response files
                 LogDeferredMessages(loggingService, _deferredBuildMessages);
 
+                // Log known deferred telemetry
+                KnownTelemetry.LoggingConfigurationTelemetry.UpdateEventProperties();
+                loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.Properties);
+
                 InitializeCaches();
 
+#if FEATURE_REPORTFILEACCESSES
+                var fileAccessManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager) as IFileAccessManager;
+#endif
+
                 _projectCacheService = new ProjectCacheService(
                     this,
                     loggingService,
+#if FEATURE_REPORTFILEACCESSES
+                    fileAccessManager,
+#endif
+                    _configCache,
                     _buildParameters.ProjectCacheDescriptor);
 
                 _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
@@ -579,7 +601,9 @@ public void BeginBuild(BuildParameters parameters)
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfiguration, BuildRequestConfiguration.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfigurationResponse, BuildRequestConfigurationResponse.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildResult, BuildResult.FactoryForDeserialization, this);
+                _nodeManager.RegisterPacketHandler(NodePacketType.FileAccessReport, FileAccessReport.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.NodeShutdown, NodeShutdown.FactoryForDeserialization, this);
+                _nodeManager.RegisterPacketHandler(NodePacketType.ProcessReport, ProcessReport.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResolveSdkRequest, SdkResolverRequest.FactoryForDeserialization, SdkResolverService as INodePacketHandler);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResourceRequest, ResourceRequest.FactoryForDeserialization, this);
 
@@ -694,6 +718,29 @@ void InitializeCaches()
             }
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Configure the build to use I/O tracking for nodes.
+        /// </summary>
+        /// <remarks>
+        /// Must be a separate non-inlinable method to avoid loading the BuildXL assembly when not opted in.
+        /// </remarks>
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        private void EnableDetouredNodeLauncher()
+        {
+            // Currently BuildXL only supports x64. Once this feature moves out of the experimental phase, this will need to be addressed.
+            ErrorUtilities.VerifyThrowInvalidOperation(NativeMethodsShared.ProcessorArchitecture == NativeMethodsShared.ProcessorArchitectures.X64, "ReportFileAccessesX64Only");
+
+            // To properly report file access, we need to disable the in-proc node which won't be detoured.
+            _buildParameters.DisableInProcNode = true;
+
+            // Node reuse must be disabled as future builds will not be able to listen to events raised by detours.
+            _buildParameters.EnableNodeReuse = false;
+
+            _componentFactories.ReplaceFactory(BuildComponentType.NodeLauncher, DetouredNodeLauncher.CreateComponent);
+        }
+#endif
+
         private static void AttachDebugger()
         {
             if (Debugger.IsAttached)
@@ -1559,6 +1606,16 @@ private void ProcessPacket(int node, INodePacket packet)
                         HandleNodeShutdown(node, shutdownPacket);
                         break;
 
+                    case NodePacketType.FileAccessReport:
+                        FileAccessReport fileAccessReport = ExpectPacketType<FileAccessReport>(packet, NodePacketType.FileAccessReport);
+                        HandleFileAccessReport(node, fileAccessReport);
+                        break;
+
+                    case NodePacketType.ProcessReport:
+                        ProcessReport processReport = ExpectPacketType<ProcessReport>(packet, NodePacketType.ProcessReport);
+                        HandleProcessReport(node, processReport);
+                        break;
+
                     default:
                         ErrorUtilities.ThrowInternalError("Unexpected packet received by BuildManager: {0}", packet.Type);
                         break;
@@ -2366,6 +2423,39 @@ private void HandleResult(int node, BuildResult result)
                 configuration.ProjectTargets ??= result.ProjectTargets;
             }
 
+            // Only report results to the project cache services if it's the result for a build submission.
+            // Note that graph builds create a submission for each node in the graph, so each node in the graph will be
+            // handled here. This intentionally mirrors the behavior for cache requests, as it doesn't make sense to
+            // report for projects which aren't going to be requested. Ideally, *any* request could be handled, but that
+            // would require moving the cache service interactions to the Scheduler.
+            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission buildSubmission))
+            {
+                // The result may be associated with the build submission due to it being the submission which
+                // caused the build, but not the actual request which was originally used with the build submission.
+                // ie. it may be a dependency of the "root-level" project which is associated with this submission, which
+                // isn't what we're looking for. Ensure only the actual submission's request is considered.
+                if (buildSubmission.BuildRequest != null
+                    && buildSubmission.BuildRequest.ConfigurationId == configuration.ConfigurationId
+                    && _projectCacheService.ShouldUseCache(configuration))
+                {
+                    BuildEventContext buildEventContext = _projectStartedEvents.TryGetValue(result.SubmissionId, out BuildEventArgs buildEventArgs)
+                        ? buildEventArgs.BuildEventContext
+                        : new BuildEventContext(result.SubmissionId, node, configuration.Project?.EvaluationId ?? BuildEventContext.InvalidEvaluationId, configuration.ConfigurationId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+                    try
+                    {
+                        _projectCacheService.HandleBuildResultAsync(configuration, result, buildEventContext, _executionCancellationTokenSource.Token).Wait();
+                    }
+                    catch (AggregateException ex) when (ex.InnerExceptions.All(inner => inner is OperationCanceledException))
+                    {
+                        // The build is being cancelled. Swallow any exceptions related specifically to cancellation.
+                    }
+                    catch (OperationCanceledException)
+                    {
+                        // The build is being cancelled. Swallow any exceptions related specifically to cancellation.
+                    }
+                }
+            }
+
             IEnumerable<ScheduleResponse> response = _scheduler.ReportResult(node, result);
             PerformSchedulingActions(response);
         }
@@ -2432,6 +2522,36 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
             CheckForActiveNodesAndCleanUpSubmissions();
         }
 
+        /// <summary>
+        /// Report the received <paramref name="fileAccessReport"/> to the file access manager.
+        /// </summary>
+        /// <param name="nodeId">The id of the node from which the <paramref name="fileAccessReport"/> was received.</param>
+        /// <param name="fileAccessReport">The file access report.</param>
+        private void HandleFileAccessReport(int nodeId, FileAccessReport fileAccessReport)
+        {
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                ((FileAccessManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager)).ReportFileAccess(fileAccessReport.FileAccessData, nodeId);
+            }
+#endif
+        }
+
+        /// <summary>
+        /// Report the received <paramref name="processReport"/> to the file access manager.
+        /// </summary>
+        /// <param name="nodeId">The id of the node from which the <paramref name="processReport"/> was received.</param>
+        /// <param name="processReport">The process data report.</param>
+        private void HandleProcessReport(int nodeId, ProcessReport processReport)
+        {
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                ((FileAccessManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager)).ReportProcess(processReport.ProcessData, nodeId);
+            }
+#endif
+        }
+
         /// <summary>
         /// If there are no more active nodes, cleans up any remaining submissions.
         /// </summary>
@@ -2465,7 +2585,6 @@ private void CheckForActiveNodesAndCleanUpSubmissions()
                     // shut down.
                     submission.CompleteLogging();
 
-                    _overallBuildSuccess = _overallBuildSuccess && (submission.BuildResult.OverallResult == BuildResultCode.Success);
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
 
@@ -2479,7 +2598,6 @@ private void CheckForActiveNodesAndCleanUpSubmissions()
 
                     submission.CompleteResults(new GraphBuildResult(submission.SubmissionId, new BuildAbortedException()));
 
-                    _overallBuildSuccess &= submission.BuildResult.OverallResult == BuildResultCode.Success;
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
 
@@ -2591,8 +2709,6 @@ private void ReportResultsToSubmission(BuildResult result)
 
                     submission.CompleteResults(result);
 
-                    _overallBuildSuccess = _overallBuildSuccess && (_buildSubmissions[result.SubmissionId].BuildResult.OverallResult == BuildResultCode.Success);
-
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
             }
@@ -2610,8 +2726,6 @@ private void ReportResultsToSubmission(GraphBuildResult result)
                 {
                     submission.CompleteResults(result);
 
-                    _overallBuildSuccess &= submission.BuildResult.OverallResult == BuildResultCode.Success;
-
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
             }
@@ -2627,6 +2741,7 @@ private void CheckSubmissionCompletenessAndRemove(BuildSubmission submission)
                 // If the submission has completed or never started, remove it.
                 if (submission.IsCompleted || submission.BuildRequest == null)
                 {
+                    _overallBuildSuccess &= (submission.BuildResult?.OverallResult == BuildResultCode.Success);
                     _buildSubmissions.Remove(submission.SubmissionId);
 
                     // Clear all cached SDKs for the submission
@@ -2647,6 +2762,7 @@ private void CheckSubmissionCompletenessAndRemove(GraphBuildSubmission submissio
                 // If the submission has completed or never started, remove it.
                 if (submission.IsCompleted || !submission.IsStarted)
                 {
+                    _overallBuildSuccess &= submission.BuildResult?.OverallResult == BuildResultCode.Success;
                     _graphBuildSubmissions.Remove(submission.SubmissionId);
 
                     // Clear all cached SDKs for the submission
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index db8405646a1..582532e5795 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -205,6 +205,8 @@ public class BuildParameters : ITranslatable
         /// </summary>
         private bool _logInitialPropertiesAndItems;
 
+        private bool _question;
+
         /// <summary>
         /// The settings used to load the project under build
         /// </summary>
@@ -218,6 +220,8 @@ public class BuildParameters : ITranslatable
 
         private string _outputResultsCacheFile;
 
+        private bool _reportFileAccesses;
+
         /// <summary>
         /// Constructor for those who intend to set all properties themselves.
         /// </summary>
@@ -301,8 +305,10 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _projectIsolationMode = other.ProjectIsolationMode;
             _inputResultsCacheFiles = other._inputResultsCacheFiles;
             _outputResultsCacheFile = other._outputResultsCacheFile;
+            _reportFileAccesses = other._reportFileAccesses;
             DiscardBuildResults = other.DiscardBuildResults;
             LowPriority = other.LowPriority;
+            Question = other.Question;
             ProjectCacheDescriptor = other.ProjectCacheDescriptor;
         }
 
@@ -798,6 +804,17 @@ public string OutputResultsCacheFile
             set => _outputResultsCacheFile = value;
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Gets or sets a value indicating whether file accesses should be reported to any configured project cache plugins.
+        /// </summary>
+        public bool ReportFileAccesses
+        {
+            get => _reportFileAccesses;
+            set => _reportFileAccesses = value;
+        }
+#endif
+
         /// <summary>
         /// Determines whether MSBuild will save the results of builds after EndBuild to speed up future builds.
         /// </summary>
@@ -808,6 +825,15 @@ public string OutputResultsCacheFile
         /// </summary>
         public bool LowPriority { get; set; }
 
+        /// <summary>
+        /// Gets or sets a value that will error when the build process fails an incremental check.
+        /// </summary>
+        public bool Question
+        {
+            get => _question;
+            set => _question = value;
+        }
+
         /// <summary>
         /// Gets or sets the project cache description to use for all <see cref="BuildSubmission"/> or <see cref="GraphBuildSubmission"/>
         /// in addition to any potential project caches described in each project.
@@ -871,7 +897,9 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _logInitialPropertiesAndItems);
             translator.TranslateEnum(ref _projectLoadSettings, (int)_projectLoadSettings);
             translator.Translate(ref _interactive);
+            translator.Translate(ref _question);
             translator.TranslateEnum(ref _projectIsolationMode, (int)_projectIsolationMode);
+            translator.Translate(ref _reportFileAccesses);
 
             // ProjectRootElementCache is not transmitted.
             // ResetCaches is not transmitted.
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index 3fa59bfe28b..7003cce1c32 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -121,7 +121,7 @@ public static (IConfigCache ConfigCache, IResultsCache ResultsCache, Exception e
 
                 using (var fileStream = File.OpenRead(inputCacheFile))
                 {
-                    using var translator = BinaryTranslator.GetReadTranslator(fileStream, null);
+                    using var translator = BinaryTranslator.GetReadTranslator(fileStream, InterningBinaryReader.PoolingBuffer);
 
                     translator.Translate(ref configCache);
                     translator.Translate(ref resultsCache);
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 9f4a4cdb9e2..e0782c3fbf3 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -229,11 +229,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
                 CommunicationsUtilities.Trace("Build finished.");
             }
 
-            if (NativeMethodsShared.IsWindows && _originalConsoleMode is not null)
-            {
-                IntPtr stdOut = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
-                NativeMethodsShared.SetConsoleMode(stdOut, _originalConsoleMode.Value);
-            }
+            NativeMethodsShared.RestoreConsoleMode(_originalConsoleMode);
 
             return _exitResult;
         }
@@ -265,9 +261,10 @@ private bool TryShutdownServer(CancellationToken cancellationToken)
                 return true;
             }
 
-            // Check that server is not busy.
-            bool serverWasBusy = ServerWasBusy();
-            if (serverWasBusy)
+            // Check and wait for server to be not busy for some short time to avoid race condition when server reports build is finished but had not released ServerBusy mutex yet.
+            // If during that short time, a script would try to shutdown server, it would be rejected and server would continue to run.
+            bool serverIsBusy = ServerIsBusyWithWaitAndRetry(250);
+            if (serverIsBusy)
             {
                 CommunicationsUtilities.Trace("Server cannot be shut down for it is not idle.");
                 return false;
@@ -291,6 +288,20 @@ private bool TryShutdownServer(CancellationToken cancellationToken)
             return _exitResult.MSBuildClientExitType == MSBuildClientExitType.Success;
         }
 
+        private bool ServerIsBusyWithWaitAndRetry(int milliseconds)
+        {
+            bool isBusy = ServerWasBusy();
+            Stopwatch sw = Stopwatch.StartNew();
+            while (isBusy && sw.ElapsedMilliseconds < milliseconds)
+            {
+                CommunicationsUtilities.Trace("Wait for server to be not busy - will retry soon...");
+                Thread.Sleep(100);
+                isBusy = ServerWasBusy();
+            }
+
+            return isBusy;
+        }
+
         internal bool ServerIsRunning()
         {
             string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);
@@ -362,63 +373,13 @@ private void ReadPacketsLoop(CancellationToken cancellationToken)
 
         private void ConfigureAndQueryConsoleProperties()
         {
-            var (acceptAnsiColorCodes, outputIsScreen) = QueryIsScreenAndTryEnableAnsiColorCodes();
+            (var acceptAnsiColorCodes, var outputIsScreen, _originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
             int bufferWidth = QueryConsoleBufferWidth();
             ConsoleColor backgroundColor = QueryConsoleBackgroundColor();
 
             _consoleConfiguration = new TargetConsoleConfiguration(bufferWidth, acceptAnsiColorCodes, outputIsScreen, backgroundColor);
         }
 
-        private (bool acceptAnsiColorCodes, bool outputIsScreen) QueryIsScreenAndTryEnableAnsiColorCodes()
-        {
-            bool acceptAnsiColorCodes = false;
-            bool outputIsScreen = false;
-
-            if (NativeMethodsShared.IsWindows)
-            {
-                try
-                {
-                    IntPtr stdOut = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
-                    if (NativeMethodsShared.GetConsoleMode(stdOut, out uint consoleMode))
-                    {
-                        bool success;
-                        if ((consoleMode & NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING) == NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING)
-                        {
-                            // Console is already in required state
-                            success = true;
-                        }
-                        else
-                        {
-                            _originalConsoleMode = consoleMode;
-                            consoleMode |= NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING;
-                            success = NativeMethodsShared.SetConsoleMode(stdOut, consoleMode);
-                        }
-
-                        if (success)
-                        {
-                            acceptAnsiColorCodes = true;
-                        }
-
-                        uint fileType = NativeMethodsShared.GetFileType(stdOut);
-                        // The std out is a char type(LPT or Console)
-                        outputIsScreen = fileType == NativeMethodsShared.FILE_TYPE_CHAR;
-                        acceptAnsiColorCodes &= outputIsScreen;
-                    }
-                }
-                catch (Exception ex)
-                {
-                    CommunicationsUtilities.Trace("MSBuild client warning: problem during enabling support for VT100: {0}.", ex);
-                }
-            }
-            else
-            {
-                // On posix OSes we expect console always supports VT100 coloring unless it is redirected
-                acceptAnsiColorCodes = outputIsScreen = !Console.IsOutputRedirected;
-            }
-
-            return (acceptAnsiColorCodes: acceptAnsiColorCodes, outputIsScreen: outputIsScreen);
-        }
-
         private int QueryConsoleBufferWidth()
         {
             int consoleBufferWidth = -1;
@@ -512,7 +473,7 @@ private bool TryLaunchServer()
                 };
                 NodeLauncher nodeLauncher = new NodeLauncher();
                 CommunicationsUtilities.Trace("Starting Server...");
-                Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions));
+                Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions), nodeId: 0);
                 CommunicationsUtilities.Trace("Server started with PID: {0}", msbuildProcess?.Id);
             }
             catch (Exception ex)
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index 5ea3ee2bde1..c4d543c87da 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -4,6 +4,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -61,6 +62,7 @@ public void RegisterDefaultFactories()
             _componentEntriesByType[BuildComponentType.NodeManager] = new BuildComponentEntry(BuildComponentType.NodeManager, NodeManager.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.TaskHostNodeManager] = new BuildComponentEntry(BuildComponentType.TaskHostNodeManager, TaskHostNodeManager.CreateComponent, CreationPattern.Singleton);
 
+            _componentEntriesByType[BuildComponentType.NodeLauncher] = new BuildComponentEntry(BuildComponentType.NodeLauncher, NodeLauncher.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.InProcNodeProvider] = new BuildComponentEntry(BuildComponentType.InProcNodeProvider, NodeProviderInProc.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.OutOfProcNodeProvider] = new BuildComponentEntry(BuildComponentType.OutOfProcNodeProvider, NodeProviderOutOfProc.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.OutOfProcTaskHostNodeProvider] = new BuildComponentEntry(BuildComponentType.OutOfProcTaskHostNodeProvider, NodeProviderOutOfProcTaskHost.CreateComponent, CreationPattern.Singleton);
@@ -80,6 +82,10 @@ public void RegisterDefaultFactories()
 
             // SDK resolution
             _componentEntriesByType[BuildComponentType.SdkResolverService] = new BuildComponentEntry(BuildComponentType.SdkResolverService, MainNodeSdkResolverService.CreateComponent, CreationPattern.Singleton);
+
+#if FEATURE_REPORTFILEACCESSES
+            _componentEntriesByType[BuildComponentType.FileAccessManager] = new BuildComponentEntry(BuildComponentType.FileAccessManager, FileAccessManager.CreateComponent, CreationPattern.Singleton);
+#endif
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 250d4b4c8bf..ef42f9fe895 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -1322,9 +1322,9 @@ private int GetNextBuildRequestId()
         /// <param name="config">The configuration to be mapped.</param>
         private void IssueConfigurationRequest(BuildRequestConfiguration config)
         {
-            ErrorUtilities.VerifyThrowArgument(config.WasGeneratedByNode, "InvalidConfigurationId");
+            ErrorUtilities.VerifyThrow(config.WasGeneratedByNode, "InvalidConfigurationId");
             ErrorUtilities.VerifyThrowArgumentNull(config, nameof(config));
-            ErrorUtilities.VerifyThrowInvalidOperation(_unresolvedConfigurations.HasConfiguration(config.ConfigurationId), "NoUnresolvedConfiguration");
+            ErrorUtilities.VerifyThrow(_unresolvedConfigurations.HasConfiguration(config.ConfigurationId), "NoUnresolvedConfiguration");
             TraceEngine("Issuing configuration request for node config {0}", config.ConfigurationId);
             RaiseNewConfigurationRequest(config);
         }
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index f02decfdc60..41013a9701e 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -103,7 +103,7 @@ public void ClearResults()
         /// <returns>The build results for the specified request.</returns>
         public BuildResult GetResultForRequest(BuildRequest request)
         {
-            ErrorUtilities.VerifyThrowArgument(request.IsConfigurationResolved, "UnresolvedConfigurationInRequest");
+            ErrorUtilities.VerifyThrow(request.IsConfigurationResolved, "UnresolvedConfigurationInRequest");
 
             lock (_resultsByConfiguration)
             {
@@ -155,7 +155,7 @@ public BuildResult GetResultsForConfiguration(int configurationId)
         /// <returns>A response indicating the results, if any, and the targets needing to be built, if any.</returns>
         public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> configInitialTargets, List<string> configDefaultTargets, bool skippedResultsDoNotCauseCacheMiss)
         {
-            ErrorUtilities.VerifyThrowArgument(request.IsConfigurationResolved, "UnresolvedConfigurationInRequest");
+            ErrorUtilities.VerifyThrow(request.IsConfigurationResolved, "UnresolvedConfigurationInRequest");
             ResultsCacheResponse response = new ResultsCacheResponse(ResultsCacheResponseType.NotSatisfied);
 
             lock (_resultsByConfiguration)
diff --git a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
new file mode 100644
index 00000000000..944334e0c9f
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
@@ -0,0 +1,192 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using BuildXL.Processes;
+using BuildXL.Utilities.Core;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.FileAccesses;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+#nullable disable
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent
+    {
+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();
+
+        private readonly BuildParameters.IBuildParameters _environmentVariables = CreateEnvironmentVariables();
+
+        private IFileAccessManager _fileAccessManager;
+
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));
+            return new DetouredNodeLauncher();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);
+        }
+
+        public void ShutdownComponent()
+        {
+            _fileAccessManager = null;
+
+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)
+            {
+                sandboxedProcess.Dispose();
+            }
+
+            _sandboxedProcesses.Clear();
+        }
+
+        /// <summary>
+        /// Creates a new MSBuild process
+        /// </summary>
+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
+        {
+            // Should always have been set already.
+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
+
+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));
+
+            if (!FileSystems.Default.FileExists(msbuildLocation))
+            {
+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotFindMSBuildExe", msbuildLocation));
+            }
+
+            // Repeat the executable name as the first token of the command line because the command line
+            // parser logic expects it and will otherwise skip the first argument
+            commandLineArgs = $"\"{msbuildLocation}\" {commandLineArgs}";
+
+            CommunicationsUtilities.Trace("Launching node from {0}", msbuildLocation);
+
+            string exeName = msbuildLocation;
+
+#if RUNTIME_TYPE_NETCORE
+            // Run the child process with the same host as the currently-running process.
+            exeName = CurrentHost.GetCurrentHost();
+#endif
+
+            var eventListener = new DetoursEventListener(_fileAccessManager, nodeId);
+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);
+
+            var info = new SandboxedProcessInfo(
+                fileStorage: null, // Don't write stdout/stderr to files
+                fileName: exeName,
+                disableConHostSharing: false,
+                detoursEventListener: eventListener,
+                createJobObjectForCurrentProcess: false)
+            {
+                SandboxKind = SandboxKind.Default,
+                PipDescription = "MSBuild",
+                PipSemiStableHash = 0,
+                Arguments = commandLineArgs,
+                EnvironmentVariables = _environmentVariables,
+                MaxLengthInMemory = 0, // Don't buffer any output
+            };
+
+            // FileAccessManifest.AddScope is used to define the list of files which the running process is allowed to access and what kinds of file accesses are allowed
+            // Tracker internally uses AbsolutePath.Invalid to represent the root, just like Unix '/' root.
+            // this code allows all types of accesses for all files
+            info.FileAccessManifest.AddScope(
+                AbsolutePath.Invalid,
+                FileAccessPolicy.MaskNothing,
+                FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);
+
+            // Support shared compilation
+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = new string[] { NativeMethodsShared.IsWindows ? "VBCSCompiler.exe" : "VBCSCompiler" };
+            info.FileAccessManifest.MonitorChildProcesses = true;
+            info.FileAccessManifest.IgnoreReparsePoints = true;
+            info.FileAccessManifest.UseExtraThreadToDrainNtClose = false;
+            info.FileAccessManifest.UseLargeNtClosePreallocatedList = true;
+            info.FileAccessManifest.LogProcessData = true;
+
+            // needed for logging process arguments when a new process is invoked; see DetoursEventListener.cs
+            info.FileAccessManifest.ReportProcessArgs = true;
+
+            // By default, BuildXL sets the timestamp of all input files to January 1, 1970
+            // This breaks some tools like Robocopy which will not copy a file to the destination if the file exists at the destination and has a timestamp that is more recent than the source file
+            info.FileAccessManifest.NormalizeReadTimestamps = false;
+
+            // If a process exits but its child processes survive, Tracker waits 30 seconds by default to wait for this process to exit.
+            // This slows down C++ builds in which mspdbsrv.exe doesn't exit when it's parent exits. Set this time to 0.
+            info.NestedProcessTerminationTimeout = TimeSpan.Zero;
+
+            ISandboxedProcess sp = SandboxedProcessFactory.StartAsync(info, forceSandboxing: false).GetAwaiter().GetResult();
+            lock (_sandboxedProcesses)
+            {
+                _sandboxedProcesses.Add(sp);
+            }
+
+            CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", sp.ProcessId, exeName);
+            return Process.GetProcessById(sp.ProcessId);
+        }
+
+        private static BuildParameters.IBuildParameters CreateEnvironmentVariables()
+        {
+            var envVars = new Dictionary<string, string>();
+            foreach (DictionaryEntry baseVar in Environment.GetEnvironmentVariables())
+            {
+                envVars.Add((string)baseVar.Key, (string)baseVar.Value);
+            }
+
+            return BuildParameters.GetFactory().PopulateFromDictionary(envVars);
+        }
+
+        private sealed class DetoursEventListener : IDetoursEventListener
+        {
+            private readonly IFileAccessManager _fileAccessManager;
+            private readonly int _nodeId;
+
+            public DetoursEventListener(IFileAccessManager fileAccessManager, int nodeId)
+            {
+                _fileAccessManager = fileAccessManager;
+                _nodeId = nodeId;
+            }
+
+            public override void HandleDebugMessage(DebugData debugData)
+            {
+            }
+
+            public override void HandleFileAccess(FileAccessData fileAccessData) => _fileAccessManager.ReportFileAccess(
+                new Experimental.FileAccess.FileAccessData(
+                    (Experimental.FileAccess.ReportedFileOperation)fileAccessData.Operation,
+                    (Experimental.FileAccess.RequestedAccess)fileAccessData.RequestedAccess,
+                    fileAccessData.ProcessId,
+                    fileAccessData.Error,
+                    (Experimental.FileAccess.DesiredAccess)fileAccessData.DesiredAccess,
+                    (Experimental.FileAccess.FlagsAndAttributes)fileAccessData.FlagsAndAttributes,
+                    fileAccessData.Path,
+                    fileAccessData.ProcessArgs,
+                    fileAccessData.IsAnAugmentedFileAccess),
+                _nodeId);
+
+            public override void HandleProcessData(ProcessData processData) => _fileAccessManager.ReportProcess(
+                new Experimental.FileAccess.ProcessData(
+                    processData.ProcessName,
+                    processData.ProcessId,
+                    processData.ParentProcessId,
+                    processData.CreationDateTime,
+                    processData.ExitDateTime,
+                    processData.ExitCode),
+                _nodeId);
+
+            public override void HandleProcessDetouringStatus(ProcessDetouringStatusData data)
+            {
+            }
+        }
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/Communications/INodeLauncher.cs b/src/Build/BackEnd/Components/Communications/INodeLauncher.cs
new file mode 100644
index 00000000000..c409c856c0b
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/INodeLauncher.cs
@@ -0,0 +1,12 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal interface INodeLauncher
+    {
+        Process Start(string msbuildLocation, string commandLineArgs, int nodeId);
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs b/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
index c3b525eec89..1bcd3206909 100644
--- a/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
+++ b/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
@@ -31,7 +31,7 @@ internal LogMessagePacket(KeyValuePair<int, BuildEventArgs>? nodeBuildEvent)
         /// Constructor for deserialization
         /// </summary>
         private LogMessagePacket(ITranslator translator)
-            : base(translator)
+            : base(translator, new TargetFinishedTranslator(TranslateTargetFinishedEvent))
         {
         }
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
index 657bfc4b4fb..2bc967775f9 100644
--- a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -19,7 +20,7 @@ namespace Microsoft.Build.BackEnd
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    internal class NodeFailedToLaunchException : Exception
+    internal class NodeFailedToLaunchException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard NodeFailedToLaunchException.
@@ -33,6 +34,10 @@ internal NodeFailedToLaunchException(Exception innerException)
             : base(innerException.Message, innerException)
         { }
 
+        public NodeFailedToLaunchException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Constructs a standard NodeFailedToLaunchException.
         /// </summary>
@@ -46,6 +51,9 @@ internal NodeFailedToLaunchException(string errorCode, string message)
         /// <summary>
         /// Constructor for deserialization.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected NodeFailedToLaunchException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -77,6 +85,9 @@ public string ErrorDescription
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
index 611c4ca68c9..ddec6d79279 100644
--- a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -16,12 +16,26 @@
 
 namespace Microsoft.Build.BackEnd
 {
-    internal class NodeLauncher
+    internal sealed class NodeLauncher : INodeLauncher, IBuildComponent
     {
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));
+            return new NodeLauncher();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+        }
+
+        public void ShutdownComponent()
+        {
+        }
+
         /// <summary>
         /// Creates a new MSBuild process
         /// </summary>
-        public Process Start(string msbuildLocation, string commandLineArgs)
+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
         {
             // Disable MSBuild server for a child process.
             // In case of starting msbuild server it prevents an infinite recurson. In case of starting msbuild node we also do not want this variable to be set.
@@ -181,7 +195,7 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)
             }
         }
 
-        private Process DisableMSBuildServer(Func<Process> func)
+        private static Process DisableMSBuildServer(Func<Process> func)
         {
             string useMSBuildServerEnvVarValue = Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName);
             try
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 7346954557d..273e6990f13 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -332,8 +332,8 @@ bool StartNewNode(int nodeId)
                     }
 #endif
                     // Create the node process
-                    NodeLauncher nodeLauncher = new NodeLauncher();
-                    Process msbuildProcess = nodeLauncher.Start(msbuildLocation, commandLineArgs);
+                    INodeLauncher nodeLauncher = (INodeLauncher)_componentHost.GetComponent(BuildComponentType.NodeLauncher);
+                    Process msbuildProcess = nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId);
                     _processesToIgnore.TryAdd(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id), default);
 
                     // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
@@ -598,7 +598,7 @@ private enum ExitPacketState
             /// <summary>
             /// Per node read buffers
             /// </summary>
-            private SharedReadBuffer _sharedReadBuffer;
+            private BinaryReaderFactory _binaryReaderFactory;
 
             /// <summary>
             /// Constructor.
@@ -616,7 +616,7 @@ public NodeContext(int nodeId, Process process,
                 _readBufferMemoryStream = new MemoryStream();
                 _writeBufferMemoryStream = new MemoryStream();
                 _terminateDelegate = terminateDelegate;
-                _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
+                _binaryReaderFactory = InterningBinaryReader.CreateSharedBuffer();
             }
 
             /// <summary>
@@ -982,7 +982,7 @@ private bool ReadAndRoutePacket(NodePacketType packetType, byte[] packetData, in
                     // Since the buffer is publicly visible dispose right away to discourage outsiders from holding a reference to it.
                     using (var packetStream = new MemoryStream(packetData, 0, packetLength, /*writeable*/ false, /*bufferIsPubliclyVisible*/ true))
                     {
-                        ITranslator readTranslator = BinaryTranslator.GetReadTranslator(packetStream, _sharedReadBuffer);
+                        ITranslator readTranslator = BinaryTranslator.GetReadTranslator(packetStream, _binaryReaderFactory);
                         _packetFactory.DeserializeAndRoutePacket(_nodeId, packetType, readTranslator);
                     }
                 }
diff --git a/src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs b/src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs
new file mode 100644
index 00000000000..a0dc533bbd1
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs
@@ -0,0 +1,43 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal static class SerializationContractInitializer
+    {
+        public static void Initialize()
+        {
+            RegisterExceptions();
+            // reserved for future usage - BuildEventArgs, etc.
+        }
+
+        private static void RegisterExceptions()
+        {
+            // Any exception not contained int this list will be transferred as a GenericBuildTransferredException
+            BuildExceptionSerializationHelper.InitializeSerializationContract(
+                new(typeof(GenericBuildTransferredException), (msg, inner) => new GenericBuildTransferredException(msg, inner)),
+                new(typeof(SdkResolverException), (msg, inner) => new SdkResolverException(msg, inner)),
+                new(typeof(BuildAbortedException), BuildAbortedException.CreateFromRemote),
+                new(typeof(CircularDependencyException), (msg, inner) => new CircularDependencyException(msg, inner)),
+                new(typeof(InternalLoggerException), (msg, inner) => new InternalLoggerException(msg, inner)),
+                new(typeof(InvalidProjectFileException), (msg, inner) => new InvalidProjectFileException(msg, inner)),
+                new(typeof(InvalidToolsetDefinitionException), (msg, inner) => new InvalidToolsetDefinitionException(msg, inner)),
+                new(typeof(ProjectCacheException), (msg, inner) => new ProjectCacheException(msg, inner)),
+                new(typeof(InternalErrorException), InternalErrorException.CreateFromRemote),
+                new(typeof(LoggerException), (msg, inner) => new LoggerException(msg, inner)),
+                new(typeof(NodeFailedToLaunchException), (msg, inner) => new NodeFailedToLaunchException(msg, inner)),
+                new(typeof(SchedulerCircularDependencyException), (msg, inner) => new SchedulerCircularDependencyException(msg, inner)),
+                new(typeof(RegistryException), (msg, inner) => new RegistryException(msg, inner)),
+                new(typeof(HostObjectException), (msg, inner) => new HostObjectException(msg, inner)),
+                new(typeof(UnbuildableProjectTypeException), (msg, inner) => new UnbuildableProjectTypeException(msg, inner)));
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index 6aa644f4227..0abf972541a 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -71,11 +71,11 @@ public static T FactoryForDeserializingTypeWithName<T>(this ITranslator translat
             translator.Translate(ref typeName);
 
             var type = Type.GetType(typeName);
-            ErrorUtilities.VerifyThrowInvalidOperation(type != null, "type cannot be null");
-            ErrorUtilities.VerifyThrowInvalidOperation(
+            ErrorUtilities.VerifyThrow(type != null, "type cannot be null");
+            ErrorUtilities.VerifyThrow(
                 typeof(T).IsAssignableFrom(type),
                 $"{typeName} must be a {typeof(T).FullName}");
-            ErrorUtilities.VerifyThrowInvalidOperation(
+            ErrorUtilities.VerifyThrow(
                 typeof(ITranslatable).IsAssignableFrom(type),
                 $"{typeName} must be a {nameof(ITranslatable)}");
 
@@ -85,9 +85,9 @@ public static T FactoryForDeserializingTypeWithName<T>(this ITranslator translat
                 {
                     ConstructorInfo constructor = null;
                     constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, Type.EmptyTypes, null);
-                    ErrorUtilities.VerifyThrowInvalidOperation(
+                    ErrorUtilities.VerifyThrow(
                         constructor != null,
-                        $"{typeName} must have a private parameterless constructor");
+                        "{0} must have a private parameterless constructor", typeName);
                     return constructor;
                 });
 
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
new file mode 100644
index 00000000000..6943ff208e0
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
@@ -0,0 +1,188 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Collections.Concurrent;
+using System.IO;
+using System.Runtime.Versioning;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent
+    {
+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);
+
+        // In order to synchronize between the node communication and the file access reporting, a special file access
+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen
+        // and the build result is reported can plugins be notified about project completion.
+        // NOTE! This is currently Windows-specific and will need to change once this feature is opened up to more scenarios.
+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @":\{MSBuildFileAccessCompletion}\";
+
+        private IScheduler? _scheduler;
+        private IConfigCache? _configCache;
+
+        private object _handlersWriteLock = new object();
+        private Handlers[] _handlers = Array.Empty<Handlers>();
+        private string? _tempDirectory;
+
+        // Keyed on global request id
+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();
+
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));
+            return new FileAccessManager();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;
+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;
+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);
+        }
+
+        public void ShutdownComponent()
+        {
+            _scheduler = null;
+            _configCache = null;
+            _tempDirectory = null;
+            _fileAccessCompletionWaitHandles.Clear();
+        }
+
+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)
+        {
+            string fileAccessPath = fileAccessData.Path;
+
+            // Intercept and avoid forwarding the file access completion
+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))
+            {
+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.
+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));
+
+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());
+                handle.Set();
+            }
+            else if (_tempDirectory != null && fileAccessPath.StartsWith(_tempDirectory))
+            {
+                // Ignore MSBuild's temp directory as these are related to internal MSBuild functionality and not always directly related to the execution of the project itself,
+                // so should not be exposed to handlers. Note that this is not %TEMP% but instead a subdir under %TEMP% which is only expected to be used by MSBuild.
+                return;
+            }
+            else
+            {
+                // Forward the file access to handlers.
+                BuildRequest? buildRequest = GetBuildRequest(nodeId);
+                if (buildRequest != null)
+                {
+                    Handlers[] localHandlers = _handlers;
+                    foreach (Handlers handlers in localHandlers)
+                    {
+                        handlers.FileAccessHander.Invoke(buildRequest, fileAccessData);
+                    }
+                }
+            }
+        }
+
+        public void ReportProcess(ProcessData processData, int nodeId)
+        {
+            BuildRequest? buildRequest = GetBuildRequest(nodeId);
+            if (buildRequest != null)
+            {
+                Handlers[] localHandlers = _handlers;
+                foreach (Handlers handlers in localHandlers)
+                {
+                    handlers.ProcessHandler.Invoke(buildRequest, processData);
+                }
+            }
+        }
+
+        public HandlerRegistration RegisterHandlers(Action<BuildRequest, FileAccessData> fileAccessHandler, Action<BuildRequest, ProcessData> processHandler)
+        {
+            lock (_handlersWriteLock)
+            {
+                Handlers[] newHandlers = new Handlers[_handlers.Length + 1];
+                _handlers.CopyTo(newHandlers, 0);
+
+                Handlers addedHandlers = new(fileAccessHandler, processHandler);
+                newHandlers[_handlers.Length] = addedHandlers;
+
+                _handlers = newHandlers;
+
+                return new HandlerRegistration(() => UnregisterHandlers(addedHandlers));
+            }
+        }
+
+        private void UnregisterHandlers(Handlers handlersToRemove)
+        {
+            lock (_handlersWriteLock)
+            {
+                Handlers[] newHandlers = new Handlers[_handlers.Length - 1];
+                int newHandlersIdx = 0;
+                for (int handlersIdx = 0; handlersIdx < _handlers.Length; handlersIdx++)
+                {
+                    if (_handlers[handlersIdx] != handlersToRemove)
+                    {
+                        newHandlers[newHandlersIdx] = _handlers[handlersIdx];
+                        newHandlersIdx++;
+                    }
+                }
+
+                _handlers = newHandlers;
+            }
+        }
+
+        // The [SupportedOSPlatform] attribute is a safeguard to ensure that the comment on FileAccessCompletionPrefix regarding being Windows-only gets addressed.
+        // [SupportedOSPlatform] doesn't apply to fields, so using it here as a reasonable proxy.
+        [SupportedOSPlatform("windows")]
+        public static void NotifyFileAccessCompletion(int globalRequestId)
+        {
+            // Make a dummy file access to use as a notification that the file accesses should be completed for a project.
+            string filePath = FileAccessCompletionPrefix + globalRequestId.ToString();
+            _ = File.Exists(filePath);
+        }
+
+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken)
+        {
+            ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());
+            if (!handle.IsSet)
+            {
+                handle.Wait(cancellationToken);
+            }
+
+            // Try to keep the collection clean. A request should not need to be completed twice.
+            _fileAccessCompletionWaitHandles.TryRemove(globalRequestId, out _);
+        }
+
+        private BuildRequest? GetBuildRequest(int nodeId)
+        {
+            ErrorUtilities.VerifyThrow(
+                _scheduler != null && _configCache != null,
+                "Component has not been initialized");
+
+            // Note: If the node isn't executing anything it may be accessing binaries required to run, eg. the MSBuild binaries
+            return _scheduler!.GetExecutingRequestByNode(nodeId);
+        }
+
+        internal readonly struct HandlerRegistration : IDisposable
+        {
+            private readonly Action _unregisterAction;
+
+            public HandlerRegistration(Action unregisterAction)
+            {
+                _unregisterAction = unregisterAction;
+            }
+
+            public void Dispose()
+            {
+                _unregisterAction();
+            }
+        }
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs
new file mode 100644
index 00000000000..72ce0107921
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs
@@ -0,0 +1,27 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class FileAccessReport : INodePacket
+    {
+        private FileAccessData _fileAccessData;
+
+        internal FileAccessReport(FileAccessData fileAccessData) => _fileAccessData = fileAccessData;
+
+        private FileAccessReport(ITranslator translator) => Translate(translator);
+
+        /// <inheritdoc/>
+        public NodePacketType Type => NodePacketType.FileAccessReport;
+
+        /// <inheritdoc/>
+        public void Translate(ITranslator translator) => translator.Translate(ref _fileAccessData);
+
+        internal FileAccessData FileAccessData => _fileAccessData;
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator) => new FileAccessReport(translator);
+    }
+}
diff --git a/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
new file mode 100644
index 00000000000..dd3b7685053
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
@@ -0,0 +1,26 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal interface IFileAccessManager
+    {
+        void ReportFileAccess(FileAccessData fileAccessData, int nodeId);
+
+        void ReportProcess(ProcessData processData, int nodeId);
+
+        // Note: The return type of FileAccessManager.HandlerRegistration is exposed directly instead of IDisposable to avoid boxing.
+        FileAccessManager.HandlerRegistration RegisterHandlers(
+            Action<BuildRequest, FileAccessData> fileAccessHandler,
+            Action<BuildRequest, ProcessData> processHandler);
+
+        void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken);
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
new file mode 100644
index 00000000000..e211f674789
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
@@ -0,0 +1,63 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.FileAccesses
+{
+    /// <summary>
+    /// Reports file accesses and process data to the in-proc node.
+    /// </summary>
+    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager, IBuildComponent
+    {
+        /// <summary>
+        /// The <see cref="Action"/> to report file accesses and process
+        /// data to the in-proc node.
+        /// </summary>
+        private readonly Action<INodePacket> _sendPacket;
+
+        private OutOfProcNodeFileAccessManager(Action<INodePacket> sendPacket) => _sendPacket = sendPacket;
+
+        public static IBuildComponent CreateComponent(BuildComponentType type, Action<INodePacket> sendPacket)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));
+            return new OutOfProcNodeFileAccessManager(sendPacket);
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+        }
+
+        public void ShutdownComponent()
+        {
+        }
+
+        /// <summary>
+        /// Reports a file access to the in-proc node.
+        /// </summary>
+        /// <param name="fileAccessData">The file access to report to the in-proc node.</param>
+        /// <param name="nodeId">The id of the reporting out-of-proc node.</param>
+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId) => _sendPacket(new FileAccessReport(fileAccessData));
+
+        /// <summary>
+        /// Reports process data to the in-proc node.
+        /// </summary>
+        /// <param name="processData">The process data to report to the in-proc node.</param>
+        /// <param name="nodeId">The id of the reporting out-of-proc node.</param>
+        public void ReportProcess(ProcessData processData, int nodeId) => _sendPacket(new ProcessReport(processData));
+
+        public FileAccessManager.HandlerRegistration RegisterHandlers(
+            Action<BuildRequest, FileAccessData> fileAccessHandler,
+            Action<BuildRequest, ProcessData> processHandler) =>
+            throw new NotImplementedException("This method should not be called in OOP nodes.");
+
+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken) =>
+            throw new NotImplementedException("This method should not be called in OOP nodes.");
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs b/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs
new file mode 100644
index 00000000000..f8d891fe532
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs
@@ -0,0 +1,27 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class ProcessReport : INodePacket
+    {
+        private ProcessData _processData;
+
+        internal ProcessReport(ProcessData processData) => _processData = processData;
+
+        private ProcessReport(ITranslator translator) => Translate(translator);
+
+        /// <inheritdoc/>
+        public NodePacketType Type => NodePacketType.ProcessReport;
+
+        internal ProcessData ProcessData => _processData;
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator) => new ProcessReport(translator);
+
+        /// <inheritdoc/>
+        public void Translate(ITranslator translator) => translator.Translate(ref _processData);
+    }
+}
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index bcbc7eac430..5ae9d947906 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -130,6 +130,18 @@ internal enum BuildComponentType
         /// The SDK resolution service.
         /// </summary>
         SdkResolverService,
+
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// The component which is the sink for file access reports and forwards reports to other components.
+        /// </summary>
+        FileAccessManager,
+#endif
+
+        /// <summary>
+        /// The component which launches new MSBuild nodes.
+        /// </summary>
+        NodeLauncher,
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 3f7a58fdd83..1efec57dc44 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -128,6 +128,36 @@ internal void LogComment(MessageImportance importance, string messageResourceNam
             _loggingService.LogComment(_eventContext, importance, messageResourceName, messageArgs);
         }
 
+        /// <summary>
+        ///  Helper method to create a message build event from a string resource and some parameters
+        /// </summary>
+        /// <param name="importance">Importance level of the message</param>
+        /// <param name="file">The file in which the event occurred</param>
+        /// <param name="messageResourceName">string within the resource which indicates the format string to use</param>
+        /// <param name="messageArgs">string resource arguments</param>
+        internal void LogComment(MessageImportance importance, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
+        {
+            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+
+            _loggingService.LogBuildEvent(new BuildMessageEventArgs(
+                null,
+                null,
+                file.File,
+                file.Line,
+                file.Column,
+                file.EndLine,
+                file.EndColumn,
+                ResourceUtilities.GetResourceString(messageResourceName),
+                helpKeyword: null,
+                senderName: "MSBuild",
+                importance,
+                DateTime.UtcNow,
+                messageArgs)
+            {
+                BuildEventContext = _eventContext
+            });
+        }
+
         /// <summary>
         /// Helper method to create a message build event from a string
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index a4c66a74ce0..2f95ae3f180 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -218,17 +218,17 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <summary>
         /// A list of warnings to treat as errors for an associated <see cref="BuildEventContext"/>.  If an empty set, all warnings are treated as errors.
         /// </summary>
-        private IDictionary<int, ISet<string>> _warningsAsErrorsByProject;
+        private IDictionary<WarningsConfigKey, ISet<string>> _warningsAsErrorsByProject;
 
         /// <summary>
         /// A list of warnings to not to be promoted to errors for an associated <see cref="BuildEventContext"/>.
         /// </summary>
-        private IDictionary<int, ISet<string>> _warningsNotAsErrorsByProject;
+        private IDictionary<WarningsConfigKey, ISet<string>> _warningsNotAsErrorsByProject;
 
         /// <summary>
         /// A list of warnings to treat as messages for an associated <see cref="BuildEventContext"/>.
         /// </summary>
-        private IDictionary<int, ISet<string>> _warningsAsMessagesByProject;
+        private IDictionary<WarningsConfigKey, ISet<string>> _warningsAsMessagesByProject;
 
         /// <summary>
         /// The minimum message importance that must be logged because there is a possibility that a logger consumes it.
@@ -623,9 +623,9 @@ public ICollection<string> GetWarningsAsMessages(BuildEventContext context)
         /// <param name="warningsByProject">A dictionary of all warnings to be treated special by for which projects.</param>
         /// <param name="warnings">Warning codes we already know should be promoted, demoted, or not promoted as relevant.</param>
         /// <returns></returns>
-        private ICollection<string> GetWarningsForProject(BuildEventContext context, IDictionary<int, ISet<string>> warningsByProject, ISet<string> warnings)
+        private ICollection<string> GetWarningsForProject(BuildEventContext context, IDictionary<WarningsConfigKey, ISet<string>> warningsByProject, ISet<string> warnings)
         {
-            int key = GetWarningsAsErrorOrMessageKey(context);
+            WarningsConfigKey key = GetWarningsConfigKey(context);
 
             if (warningsByProject != null && warningsByProject.TryGetValue(key, out ISet<string> newWarnings))
             {
@@ -678,13 +678,13 @@ public void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet<stri
         /// <param name="warningsByProject">Dictionary with what warnings are currently known (by project) that we will add to.</param>
         /// <param name="buildEventContext">Context for the project to be added</param>
         /// <param name="codes">Codes to add</param>
-        private void AddWarningsAsMessagesOrErrors(ref IDictionary<int, ISet<string>> warningsByProject, BuildEventContext buildEventContext, ISet<string> codes)
+        private void AddWarningsAsMessagesOrErrors(ref IDictionary<WarningsConfigKey, ISet<string>> warningsByProject, BuildEventContext buildEventContext, ISet<string> codes)
         {
             lock (_lockObject)
             {
-                int key = GetWarningsAsErrorOrMessageKey(buildEventContext);
+                WarningsConfigKey key = GetWarningsConfigKey(buildEventContext);
 
-                warningsByProject ??= new ConcurrentDictionary<int, ISet<string>>();
+                warningsByProject ??= new ConcurrentDictionary<WarningsConfigKey, ISet<string>>();
 
                 if (!warningsByProject.ContainsKey(key))
                 {
@@ -901,9 +901,60 @@ public void PacketReceived(int node, INodePacket packet)
 
             LogMessagePacket loggingPacket = (LogMessagePacket)packet;
             InjectNonSerializedData(loggingPacket);
+
+            WarnOnDeprecatedCustomArgsSerialization(loggingPacket);
+
             ProcessLoggingEvent(loggingPacket.NodeBuildEvent);
         }
 
+        /// <summary>
+        /// Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet.
+        /// Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom
+        /// EventArgs derived from existing EventArgs.
+        /// </summary>
+        private void WarnOnDeprecatedCustomArgsSerialization(LogMessagePacket loggingPacket)
+        {
+            if (loggingPacket.EventType == LoggingEventType.CustomEvent
+                && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8)
+                && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
+            {
+                BuildEventArgs buildEvent = loggingPacket.NodeBuildEvent.Value.Value;
+                BuildEventContext buildEventContext = buildEvent?.BuildEventContext ?? BuildEventContext.Invalid;
+
+                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
+                    out string warningCode,
+                    out string helpKeyword,
+                    "DeprecatedEventSerialization",
+                    buildEvent?.GetType().Name ?? string.Empty);
+
+                BuildWarningEventArgs warning = new(
+                    null,
+                    warningCode,
+                    BuildEventFileInfo.Empty.File,
+                    BuildEventFileInfo.Empty.Line,
+                    BuildEventFileInfo.Empty.Column,
+                    BuildEventFileInfo.Empty.EndLine,
+                    BuildEventFileInfo.Empty.EndColumn,
+                    message,
+                    helpKeyword,
+                    "MSBuild");
+
+                warning.BuildEventContext = buildEventContext;
+                if (warning.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+                {
+                    warning.ProjectFile = buildEvent switch
+                    {
+                        BuildMessageEventArgs buildMessageEvent => buildMessageEvent.ProjectFile,
+                        BuildErrorEventArgs buildErrorEvent => buildErrorEvent.ProjectFile,
+                        BuildWarningEventArgs buildWarningEvent => buildWarningEvent.ProjectFile,
+                        _ => null,
+                    };
+                }
+
+                ProcessLoggingEvent(warning);
+            }
+        }
+
         /// <summary>
         /// Register an instantiated logger which implements the ILogger interface. This logger will be registered to a specific event
         /// source (the central logger event source) which will receive all logging messages for a given build.
@@ -1243,19 +1294,18 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
         #endregion
 
         #region Private Methods
-        private static int GetWarningsAsErrorOrMessageKey(BuildEventContext buildEventContext)
+        private static WarningsConfigKey GetWarningsConfigKey(BuildEventContext buildEventContext)
         {
-            var hash = 17;
-            hash = (hash * 31) + buildEventContext.ProjectInstanceId;
-            hash = (hash * 31) + buildEventContext.ProjectContextId;
-            return hash;
+            return new WarningsConfigKey(buildEventContext.ProjectInstanceId, buildEventContext.ProjectContextId);
         }
 
-        private static int GetWarningsAsErrorOrMessageKey(BuildEventArgs buildEventArgs)
+        private static WarningsConfigKey GetWarningsConfigKey(BuildEventArgs buildEventArgs)
         {
-            return GetWarningsAsErrorOrMessageKey(buildEventArgs.BuildEventContext);
+            return GetWarningsConfigKey(buildEventArgs.BuildEventContext);
         }
 
+        private readonly record struct WarningsConfigKey(int InstanceId, int ContextId);
+
         /// <summary>
         /// Create a logging thread to process the logging queue.
         /// </summary>
@@ -1438,65 +1488,122 @@ private void RouteBuildEvent(object loggingEvent)
             {
                 if (ShouldTreatWarningAsMessage(warningEvent))
                 {
-                    loggingEvent = new BuildMessageEventArgs(
-                        warningEvent.Subcategory,
-                        warningEvent.Code,
-                        warningEvent.File,
-                        warningEvent.LineNumber,
-                        warningEvent.ColumnNumber,
-                        warningEvent.EndLineNumber,
-                        warningEvent.EndColumnNumber,
-                        warningEvent.Message,
-                        warningEvent.HelpKeyword,
-                        warningEvent.SenderName,
-                        MessageImportance.Low,
-                        warningEvent.Timestamp)
+                    if (buildEventArgs is ExtendedBuildWarningEventArgs extWarningEvent)
                     {
-                        BuildEventContext = warningEvent.BuildEventContext,
-                        ProjectFile = warningEvent.ProjectFile,
-                    };
+                        buildEventArgs = new ExtendedBuildMessageEventArgs(
+                                extWarningEvent.ExtendedType,
+                                extWarningEvent.Subcategory,
+                                extWarningEvent.Code,
+                                extWarningEvent.File,
+                                extWarningEvent.LineNumber,
+                                extWarningEvent.ColumnNumber,
+                                extWarningEvent.EndLineNumber,
+                                extWarningEvent.EndColumnNumber,
+                                extWarningEvent.Message,
+                                extWarningEvent.HelpKeyword,
+                                extWarningEvent.SenderName,
+                                MessageImportance.Low,
+                                extWarningEvent.Timestamp)
+                        {
+                            BuildEventContext = warningEvent.BuildEventContext,
+                            ProjectFile = warningEvent.ProjectFile,
+                            ExtendedMetadata = extWarningEvent.ExtendedMetadata,
+                            ExtendedData = extWarningEvent.ExtendedData,
+                        };
+                    }
+                    else
+                    {
+                        buildEventArgs = new BuildMessageEventArgs(
+                            warningEvent.Subcategory,
+                            warningEvent.Code,
+                            warningEvent.File,
+                            warningEvent.LineNumber,
+                            warningEvent.ColumnNumber,
+                            warningEvent.EndLineNumber,
+                            warningEvent.EndColumnNumber,
+                            warningEvent.Message,
+                            warningEvent.HelpKeyword,
+                            warningEvent.SenderName,
+                            MessageImportance.Low,
+                            warningEvent.Timestamp)
+                        {
+                            BuildEventContext = warningEvent.BuildEventContext,
+                            ProjectFile = warningEvent.ProjectFile,
+                        };
+                    }
                 }
                 else if (ShouldTreatWarningAsError(warningEvent))
                 {
-                    loggingEvent = new BuildErrorEventArgs(
-                        warningEvent.Subcategory,
-                        warningEvent.Code,
-                        warningEvent.File,
-                        warningEvent.LineNumber,
-                        warningEvent.ColumnNumber,
-                        warningEvent.EndLineNumber,
-                        warningEvent.EndColumnNumber,
-                        warningEvent.Message,
-                        warningEvent.HelpKeyword,
-                        warningEvent.SenderName,
-                        warningEvent.Timestamp)
+                    if (warningEvent is ExtendedBuildWarningEventArgs extWarningEvent)
                     {
-                        BuildEventContext = warningEvent.BuildEventContext,
-                        ProjectFile = warningEvent.ProjectFile,
-                    };
+                        buildEventArgs = new ExtendedBuildErrorEventArgs(
+                            extWarningEvent.ExtendedType,
+                            extWarningEvent.Subcategory,
+                            extWarningEvent.Code,
+                            extWarningEvent.File,
+                            extWarningEvent.LineNumber,
+                            extWarningEvent.ColumnNumber,
+                            extWarningEvent.EndLineNumber,
+                            extWarningEvent.EndColumnNumber,
+                            extWarningEvent.Message,
+                            extWarningEvent.HelpKeyword,
+                            extWarningEvent.SenderName,
+                            extWarningEvent.Timestamp)
+                        {
+                            BuildEventContext = warningEvent.BuildEventContext,
+                            ProjectFile = warningEvent.ProjectFile,
+                            ExtendedMetadata = extWarningEvent.ExtendedMetadata,
+                            ExtendedData = extWarningEvent.ExtendedData,
+                        };
+                    }
+                    else
+                    {
+                        buildEventArgs = new BuildErrorEventArgs(
+                            warningEvent.Subcategory,
+                            warningEvent.Code,
+                            warningEvent.File,
+                            warningEvent.LineNumber,
+                            warningEvent.ColumnNumber,
+                            warningEvent.EndLineNumber,
+                            warningEvent.EndColumnNumber,
+                            warningEvent.Message,
+                            warningEvent.HelpKeyword,
+                            warningEvent.SenderName,
+                            warningEvent.Timestamp)
+                        {
+                            BuildEventContext = warningEvent.BuildEventContext,
+                            ProjectFile = warningEvent.ProjectFile,
+                        };
+                    }
                 }
             }
 
-            if (loggingEvent is BuildErrorEventArgs errorEvent)
+            if (buildEventArgs is BuildErrorEventArgs errorEvent)
             {
                 // Keep track of build submissions that have logged errors.  If there is no build context, add BuildEventContext.InvalidSubmissionId.
                 _buildSubmissionIdsThatHaveLoggedErrors.Add(errorEvent.BuildEventContext?.SubmissionId ?? BuildEventContext.InvalidSubmissionId);
             }
 
-            if (loggingEvent is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
+            if (buildEventArgs is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
             {
-                int key = GetWarningsAsErrorOrMessageKey(projectFinishedEvent);
+                WarningsConfigKey key = GetWarningsConfigKey(projectFinishedEvent);
                 _warningsAsErrorsByProject?.Remove(key);
                 _warningsNotAsErrorsByProject?.Remove(key);
                 _warningsAsMessagesByProject?.Remove(key);
             }
 
-            if (loggingEvent is BuildEventArgs loggingEventBuildArgs)
+            if (loggingEvent is BuildEventArgs)
             {
-                RouteBuildEvent(loggingEventBuildArgs);
+                RouteBuildEvent(buildEventArgs);
             }
             else if (loggingEvent is KeyValuePair<int, BuildEventArgs> loggingEventKeyValuePair)
             {
+                if (loggingEventKeyValuePair.Value != buildEventArgs)
+                {
+                    // buildEventArgs has been altered, lets use that new one
+                    loggingEventKeyValuePair = new KeyValuePair<int, BuildEventArgs>(loggingEventKeyValuePair.Key, buildEventArgs);
+                }
+
                 RouteBuildEvent(loggingEventKeyValuePair);
             }
         }
@@ -1637,7 +1744,7 @@ ILogger UnwrapLoggerType(ILogger log)
         /// </remarks>
         private void UpdateMinimumMessageImportance(ILogger logger)
         {
-            var innerLogger = (logger is Evaluation.ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;
+            var innerLogger = (logger is ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;
 
             MessageImportance? minimumImportance = innerLogger switch
             {
@@ -1651,8 +1758,11 @@ private void UpdateMinimumMessageImportance(ILogger logger)
                 // The null logger has no effect on minimum verbosity.
                 Execution.BuildManager.NullLogger => null,
 
-                // If the logger is not on our whitelist, there are no importance guarantees. Fall back to "any importance".
-                _ => MessageImportance.Low
+                // The terminal logger consumes only high priority messages.
+                _ => innerLogger.GetType().FullName == "Microsoft.Build.Logging.TerminalLogger.TerminalLogger"
+                    ? MessageImportance.High
+                    // If the logger is not on our allow list, there are no importance guarantees. Fall back to "any importance".
+                    : MessageImportance.Low,
             };
 
             if (minimumImportance != null)
@@ -1748,7 +1858,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
             // This only applies if the user specified <MSBuildWarningsAsMessages /> and there is a valid ProjectInstanceId
             if (_warningsAsMessagesByProject != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectInstanceId != BuildEventContext.InvalidProjectInstanceId)
             {
-                if (_warningsAsMessagesByProject.TryGetValue(GetWarningsAsErrorOrMessageKey(warningEvent), out ISet<string> codesByProject))
+                if (_warningsAsMessagesByProject.TryGetValue(GetWarningsConfigKey(warningEvent), out ISet<string> codesByProject))
                 {
                     return codesByProject?.Contains(warningEvent.Code) == true;
                 }
@@ -1759,7 +1869,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
 
         private bool WarningAsErrorNotOverriden(BuildWarningEventArgs warningEvent)
         {
-            int key = GetWarningsAsErrorOrMessageKey(warningEvent);
+            WarningsConfigKey key = GetWarningsConfigKey(warningEvent);
 
             return WarningsNotAsErrors?.Contains(warningEvent.Code) != true && !(_warningsNotAsErrorsByProject?.TryGetValue(key, out ISet<string> notToError) == true && notToError.Contains(warningEvent.Code));
         }
@@ -1786,7 +1896,7 @@ private bool ShouldTreatWarningAsError(BuildWarningEventArgs warningEvent)
             if (_warningsAsErrorsByProject != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectInstanceId != BuildEventContext.InvalidProjectInstanceId)
             {
                 // Attempt to get the list of warnings to treat as errors for the current project
-                int key = GetWarningsAsErrorOrMessageKey(warningEvent);
+                WarningsConfigKey key = GetWarningsConfigKey(warningEvent);
                 if (_warningsAsErrorsByProject.TryGetValue(key, out ISet<string> codesByProject))
                 {
                     // We create an empty set if all warnings should be treated as errors so that should be checked first.
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
index 35ea1c27fca..3a954dec21b 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
@@ -93,7 +93,7 @@ public static CacheResult IndicateCacheHit(IReadOnlyCollection<PluginTargetResul
 
         public static CacheResult IndicateNonCacheHit(CacheResultType resultType)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(resultType != CacheResultType.CacheHit, "CantBeCacheHit");
+            ErrorUtilities.VerifyThrow(resultType != CacheResultType.CacheHit, "CantBeCacheHit");
             return new CacheResult(resultType);
         }
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs b/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs
new file mode 100644
index 00000000000..5ff62cfb514
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs
@@ -0,0 +1,26 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    public readonly struct FileAccessContext
+    {
+        public FileAccessContext(
+            string projectFullPath,
+            IReadOnlyDictionary<string, string> globalProperties,
+            IReadOnlyList<string> targets)
+        {
+            ProjectFullPath = projectFullPath;
+            GlobalProperties = globalProperties;
+            Targets = targets;
+        }
+
+        public string ProjectFullPath { get; }
+
+        public IReadOnlyDictionary<string, string> GlobalProperties { get; }
+
+        public IReadOnlyList<string> Targets { get; }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
index 3b1a9bb3dca..d2f76b4c577 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -12,7 +13,7 @@ namespace Microsoft.Build.Experimental.ProjectCache
     /// This exception is used to wrap an unhandled exception from a project cache plugin. This exception aborts the build, and it can only be
     /// thrown by the MSBuild engine.
     /// </summary>
-    public sealed class ProjectCacheException : Exception
+    public sealed class ProjectCacheException : BuildExceptionBase
     {
         private ProjectCacheException()
         {
@@ -33,6 +34,10 @@ private ProjectCacheException(
             ErrorCode = errorCode;
         }
 
+        internal ProjectCacheException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// The project cache has already logged this as an error.
         /// Should not get logged again.
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
index 2bf479c6055..6c999cfcf53 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
@@ -1,9 +1,11 @@
 Ôªø// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.FileAccess;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
@@ -39,5 +41,32 @@ public abstract Task<CacheResult> GetCacheResultAsync(
         ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
         /// </summary>
         public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);
+
+        /// <summary>
+        ///     Called for each file access from an MSBuild node or one of its children.
+        /// </summary>
+        [CLSCompliant(false)]
+        public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData)
+        {
+        }
+
+        /// <summary>
+        ///     Called for each new child process created by an MSBuild node or one of its children.
+        /// </summary>
+        [CLSCompliant(false)]
+        public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData)
+        {
+        }
+
+        /// <summary>
+        ///     Called when a build request finishes execution. This provides an opportunity for the plugin to take action on the
+        ///     aggregated file access reports from <see cref="HandleFileAccess(FileAccessContext, FileAccessData)"/>.
+        ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
+        /// </summary>
+        public virtual Task HandleProjectFinishedAsync(
+            FileAccessContext fileAccessContext,
+            BuildResult buildResult,
+            PluginLoggerBase logger,
+            CancellationToken cancellationToken) => Task.CompletedTask;
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 9d1cefe040d..d684119e4e8 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -16,6 +16,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
@@ -33,17 +34,31 @@ internal sealed class ProjectCacheService : IAsyncDisposable
         private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { "TargetFramework", "Configuration", "Platform", "TargetPlatform", "OutputType" };
 
         private readonly BuildManager _buildManager;
+        private readonly IBuildComponentHost _componentHost;
         private readonly ILoggingService _loggingService;
+#if FEATURE_REPORTFILEACCESSES
+        private readonly IFileAccessManager _fileAccessManager;
+#endif
+        private readonly IConfigCache _configCache;
 
         private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;
 
         private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);
 
+        // Helps to avoid excessive allocation since BuildRequestConfiguration doesn't expose global properties in a way the plugins can consume (PropertyDictionary<ProjectPropertyInstance> vs IReadOnlyDictionary<string, string>).
+        private readonly ConcurrentDictionary<BuildRequestConfiguration, IReadOnlyDictionary<string, string>> _globalPropertiesPerConfiguration = new();
+
         private bool _isVsScenario;
 
         private bool _isDisposed;
 
-        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);
+        private record struct ProjectCachePlugin(
+            string Name,
+            ProjectCachePluginBase? Instance,
+#if FEATURE_REPORTFILEACCESSES
+            FileAccessManager.HandlerRegistration? HandlerRegistration,
+#endif
+            ExceptionDispatchInfo? InitializationException = null);
 
         /// <summary>
         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,
@@ -61,10 +76,19 @@ private DefaultMSBuildFileSystem()
         public ProjectCacheService(
             BuildManager buildManager,
             ILoggingService loggingService,
+#if FEATURE_REPORTFILEACCESSES
+            IFileAccessManager fileAccessManager,
+#endif
+            IConfigCache configCache,
             ProjectCacheDescriptor? globalProjectCacheDescriptor)
         {
             _buildManager = buildManager;
+            _componentHost = buildManager;
             _loggingService = loggingService;
+#if FEATURE_REPORTFILEACCESSES
+            _fileAccessManager = fileAccessManager;
+#endif
+            _configCache = configCache;
             _globalProjectCacheDescriptor = globalProjectCacheDescriptor;
         }
 
@@ -75,18 +99,24 @@ public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationTok
         {
             EnsureNotDisposed();
 
-            Parallel.ForEach(
-                projectGraph.ProjectNodes,
-                s_parallelOptions,
-                node =>
+            // Performing this in a Task.Run to break away from the main thread and prevent hangs
+            Task.Run(
+                () =>
                 {
-                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
-                    {
-                        // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
-                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
-                    }
-                });
+                    Parallel.ForEach(
+                        projectGraph.ProjectNodes,
+                        s_parallelOptions,
+                        node =>
+                        {
+                            foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
+                            {
+                                // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
+                                    .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                            }
+                        });
+                },
+                cancellationToken);
         }
 
         public void InitializePluginsForVsScenario(
@@ -104,15 +134,21 @@ public void InitializePluginsForVsScenario(
                 return;
             }
 
-            Parallel.ForEach(
-                projectCacheDescriptors,
-                s_parallelOptions,
-                projectCacheDescriptor =>
+            // Performing this in a Task.Run to break away from the main thread and prevent hangs
+            Task.Run(
+                () =>
                 {
-                    // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
-                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
-                });
+                    Parallel.ForEach(
+                        projectCacheDescriptors,
+                        s_parallelOptions,
+                        projectCacheDescriptor =>
+                        {
+                            // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
+                                .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                        });
+                },
+                cancellationToken);
         }
 
         private Task<ProjectCachePlugin> GetProjectCachePluginAsync(
@@ -187,7 +223,13 @@ private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
                 }
                 catch (Exception e)
                 {
-                    return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                    return new ProjectCachePlugin(
+                        pluginTypeName,
+                        Instance: null,
+#if FEATURE_REPORTFILEACCESSES
+                        HandlerRegistration: null,
+#endif
+                        ExceptionDispatchInfo.Capture(e));
                 }
                 finally
                 {
@@ -218,11 +260,43 @@ await pluginInstance.BeginBuildAsync(
                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
                 }
 
-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);
+#if FEATURE_REPORTFILEACCESSES
+            FileAccessManager.HandlerRegistration? handlerRegistration = null;
+            if (_componentHost.BuildParameters.ReportFileAccesses)
+            {
+                handlerRegistration = _fileAccessManager.RegisterHandlers(
+                    (buildRequest, fileAccessData) =>
+                    {
+                        // TODO: Filter out projects which do not configure this plugin
+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);
+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);
+                    },
+                    (buildRequest, processData) =>
+                    {
+                        // TODO: Filter out projects which do not configure this plugin
+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);
+                        pluginInstance.HandleProcess(fileAccessContext, processData);
+                    });
+            }
+#endif
+
+                return new ProjectCachePlugin(
+                    pluginTypeName,
+                    pluginInstance,
+#if FEATURE_REPORTFILEACCESSES
+                    handlerRegistration,
+#endif
+                    InitializationException: null);
             }
             catch (Exception e)
             {
-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                return new ProjectCachePlugin(
+                    pluginTypeName,
+                    Instance: null,
+#if FEATURE_REPORTFILEACCESSES
+                    HandlerRegistration: null,
+#endif
+                    ExceptionDispatchInfo.Capture(e));
             }
             finally
             {
@@ -230,6 +304,27 @@ await pluginInstance.BeginBuildAsync(
             }
         }
 
+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)
+        {
+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];
+            IReadOnlyDictionary<string, string> globalProperties = GetGlobalProperties(configuration);
+            return new FileAccessContext(configuration.ProjectFullPath, globalProperties, buildRequest.Targets);
+        }
+
+        private IReadOnlyDictionary<string, string> GetGlobalProperties(BuildRequestConfiguration configuration)
+            => _globalPropertiesPerConfiguration.GetOrAdd(
+                    configuration,
+                    static configuration =>
+                    {
+                        Dictionary<string, string> globalProperties = new(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);
+                        foreach (ProjectPropertyInstance property in configuration.GlobalProperties)
+                        {
+                            globalProperties.Add(property.Name, property.EvaluatedValue);
+                        }
+
+                        return globalProperties;
+                    });
+
         private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
         {
             try
@@ -306,6 +401,12 @@ public bool ShouldUseCache(BuildRequestConfiguration buildRequestConfiguration)
                 return false;
             }
 
+            // We need to retrieve the configuration if it's already loaded in order to access the Project property below.
+            if (buildRequestConfiguration.IsCached)
+            {
+                buildRequestConfiguration.RetrieveFromCache();
+            }
+
             // Check if there are any project cache items defined in the project
             return GetProjectCacheDescriptors(buildRequestConfiguration.Project).Any();
         }
@@ -315,7 +416,7 @@ private bool IsDesignTimeBuild(BuildRequestConfiguration buildRequestConfigurati
             string? designTimeBuild = buildRequestConfiguration.GlobalProperties[DesignTimeProperties.DesignTimeBuild]?.EvaluatedValue;
             string? buildingProject = buildRequestConfiguration.GlobalProperties[DesignTimeProperties.BuildingProject]?.EvaluatedValue;
             return ConversionUtilities.ConvertStringToBool(designTimeBuild, nullOrWhitespaceIsFalse: true)
-                || (buildingProject != null && !ConversionUtilities.ConvertStringToBool(designTimeBuild, nullOrWhitespaceIsFalse: true));
+                || (buildingProject != null && !ConversionUtilities.ConvertStringToBool(buildingProject, nullOrWhitespaceIsFalse: true));
         }
 
         public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancellationToken)
@@ -587,6 +688,98 @@ static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromS
             }
         }
 
+        public async Task HandleBuildResultAsync(
+            BuildRequestConfiguration requestConfiguration,
+            BuildResult buildResult,
+            BuildEventContext buildEventContext,
+            CancellationToken cancellationToken)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(requestConfiguration.Project, nameof(requestConfiguration.Project));
+
+            if (_projectCachePlugins.IsEmpty)
+            {
+                return;
+            }
+
+            // We need to retrieve the configuration if it's already loaded in order to access the Project property below.
+            if (requestConfiguration.IsCached)
+            {
+                requestConfiguration.RetrieveFromCache();
+            }
+
+            // Filter to plugins which apply to the project, if any
+            List<ProjectCacheDescriptor> projectCacheDescriptors = GetProjectCacheDescriptors(requestConfiguration.Project).ToList();
+            if (projectCacheDescriptors.Count == 0)
+            {
+                return;
+            }
+
+#if FEATURE_REPORTFILEACCESSES
+            if (_componentHost.BuildParameters.ReportFileAccesses)
+            {
+                _fileAccessManager.WaitForFileAccessReportCompletion(buildResult.GlobalRequestId, cancellationToken);
+            }
+#endif
+
+            IReadOnlyDictionary<string, string> globalProperties = GetGlobalProperties(requestConfiguration);
+
+            List<string> targets = buildResult.ResultsByTarget.Keys.ToList();
+            string? targetNames = string.Join(", ", targets);
+
+            FileAccessContext fileAccessContext = new(requestConfiguration.ProjectFullPath, globalProperties, targets);
+
+            var buildEventFileInfo = new BuildEventFileInfo(requestConfiguration.ProjectFullPath);
+            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
+                _loggingService,
+                buildEventContext,
+                buildEventFileInfo);
+
+            Task[] tasks = new Task[projectCacheDescriptors.Count];
+            int idx = 0;
+            foreach (ProjectCacheDescriptor projectCacheDescriptor in projectCacheDescriptors)
+            {
+                tasks[idx++] = Task.Run(
+                    async () =>
+                    {
+                        if (!_projectCachePlugins.TryGetValue(projectCacheDescriptor, out Lazy<Task<ProjectCachePlugin>>? pluginLazyTask))
+                        {
+                            // The plugin might not be in the collection if it was never initialized, which can happen if there are multiple plugins
+                            // and the first one(s) always handles the cache request so the subsequent one(s) never get lazy initialized.
+                            return;
+                        }
+
+                        ProjectCachePlugin plugin = await pluginLazyTask.Value;
+
+                        // Rethrow any initialization exception.
+                        plugin.InitializationException?.Throw();
+
+                        ErrorUtilities.VerifyThrow(plugin.Instance != null, "Plugin '{0}' instance is null", plugin.Name);
+
+                        MSBuildEventSource.Log.ProjectCacheHandleBuildResultStart(plugin.Name, fileAccessContext.ProjectFullPath, targetNames);
+                        try
+                        {
+                            await plugin.Instance!.HandleProjectFinishedAsync(fileAccessContext, buildResult, pluginLogger, cancellationToken);
+                        }
+                        catch (Exception e) when (e is not ProjectCacheException)
+                        {
+                            HandlePluginException(e, nameof(ProjectCachePluginBase.HandleProjectFinishedAsync));
+                        }
+                        finally
+                        {
+                            MSBuildEventSource.Log.ProjectCacheHandleBuildResultStop(plugin.Name, fileAccessContext.ProjectFullPath, targetNames);
+                        }
+                    },
+                    cancellationToken);
+            }
+
+            await Task.WhenAll(tasks).ConfigureAwait(false);
+
+            if (pluginLogger.HasLoggedErrors)
+            {
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheHandleBuildResultFailed", fileAccessContext.ProjectFullPath);
+            }
+        }
+
         public async ValueTask DisposeAsync()
         {
             if (_isDisposed)
@@ -624,6 +817,13 @@ public async ValueTask DisposeAsync()
                         return;
                     }
 
+#if FEATURE_REPORTFILEACCESSES
+                    if (plugin.HandlerRegistration.HasValue)
+                    {
+                        plugin.HandlerRegistration.Value.Dispose();
+                    }
+#endif
+
                     MSBuildEventSource.Log.ProjectCacheEndBuildStart(plugin.Name);
                     try
                     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
index 0f9f1858b52..7e03b6cfd3e 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -157,11 +157,14 @@ private void CurrentDomainOnAssemblyLoad(object? sender, AssemblyLoadEventArgs a
                 : $"{_appDomain.Id}|{_appDomain.FriendlyName}";
 
 
-            AssemblyLoadBuildEventArgs buildArgs = new(_context, _initiator, assemblyName, assemblyPath, mvid, appDomainDescriptor)
+            AssemblyLoadBuildEventArgs buildArgs = new(_context, _initiator, assemblyName, assemblyPath, mvid, appDomainDescriptor);
+
+            // Fix #8816 - when LoggingContext does not have BuildEventContext it is unable to log anything
+            if (_loggingContext?.BuildEventContext != null)
             {
-                BuildEventContext = _loggingContext?.BuildEventContext ?? BuildEventContext.Invalid
-            };
-            _loggingContext?.LogBuildEvent(buildArgs);
+                buildArgs.BuildEventContext = _loggingContext.BuildEventContext;
+                _loggingContext.LogBuildEvent(buildArgs);
+            }
             _loggingService?.LogBuildEvent(buildArgs);
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 8dd00b2148b..72d42315df5 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -184,7 +184,17 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
+                    ExpanderOptions expanderOptions = ExpanderOptions.ExpandAll;
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) &&
+                        // If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
+                        bucket.BucketSequenceNumber == 0 &&
+                        // Referring to unqualified metadata of other item (transform) is fine.
+                        child.Include.IndexOf("@(", StringComparison.Ordinal) == -1)
+                    {
+                        expanderOptions |= ExpanderOptions.LogOnItemMetadataSelfReference;
+                    }
+
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location, loggingContext);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and 
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -403,27 +413,28 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
 
             // Split Include on any semicolons, and take each split in turn
             var includeSplits = ExpressionShredder.SplitSemiColonSeparatedList(evaluatedInclude);
-            ProjectItemInstanceFactory itemFactory = new ProjectItemInstanceFactory(this.Project, originalItem.ItemType);
+            ProjectItemInstanceFactory itemFactory = new ProjectItemInstanceFactory(Project, originalItem.ItemType);
+
+            // EngineFileUtilities.GetFileListEscaped api invocation evaluates excludes by default.
+            // If the code process any expression like "@(x)", we need to handle excludes explicitly using EvaluateExcludePaths().
+            bool anyTransformExprProceeded = false;
 
             foreach (string includeSplit in includeSplits)
             {
                 // If expression is "@(x)" copy specified list with its metadata, otherwise just treat as string
-                bool throwaway;
-
-                IList<ProjectItemInstance> itemsFromSplit = expander.ExpandSingleItemVectorExpressionIntoItems(includeSplit,
+                IList<ProjectItemInstance> itemsFromSplit = expander.ExpandSingleItemVectorExpressionIntoItems(
+                    includeSplit,
                     itemFactory,
                     ExpanderOptions.ExpandItems,
                     false /* do not include null expansion results */,
-                    out throwaway,
+                    out _,
                     originalItem.IncludeLocation);
 
                 if (itemsFromSplit != null)
                 {
                     // Expression is in form "@(X)", so add these items directly.
-                    foreach (ProjectItemInstance item in itemsFromSplit)
-                    {
-                        items.Add(item);
-                    }
+                    items.AddRange(itemsFromSplit);
+                    anyTransformExprProceeded = true;
                 }
                 else
                 {
@@ -453,35 +464,18 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
                 }
             }
 
-            // Evaluate, split, expand and subtract any Exclude
-            HashSet<string> excludesUnescapedForComparison = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
-
-            foreach (string excludeSplit in excludes)
+            // There is a need to Evaluate Exclude part explicitly because of of the expressions had the form "@(X)".
+            if (anyTransformExprProceeded)
             {
-                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(
-                    Project.Directory,
-                    excludeSplit,
-                    loggingMechanism: LoggingContext,
-                    excludeLocation: originalItem.ExcludeLocation);
+                // Calculate all Exclude
+                var excludesUnescapedForComparison = EvaluateExcludePaths(excludes, originalItem.ExcludeLocation);
 
-                foreach (string excludeSplitFile in excludeSplitFiles)
-                {
-                    excludesUnescapedForComparison.Add(excludeSplitFile.NormalizeForPathComparison());
-                }
-            }
-
-            List<ProjectItemInstance> remainingItems = new List<ProjectItemInstance>();
-
-            for (int i = 0; i < items.Count; i++)
-            {
-                if (!excludesUnescapedForComparison.Contains(((IItem)items[i]).EvaluatedInclude.NormalizeForPathComparison()))
-                {
-                    remainingItems.Add(items[i]);
-                }
+                // Subtract any Exclude
+                items = items
+                    .Where(i => !excludesUnescapedForComparison.Contains(((IItem)i).EvaluatedInclude.NormalizeForPathComparison()))
+                    .ToList();
             }
 
-            items = remainingItems;
-
             // Filter the metadata as appropriate
             if (keepMetadata != null)
             {
@@ -509,6 +503,32 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             return items;
         }
 
+        /// <summary>
+        /// Returns a list of all items specified in Exclude parameter.
+        /// If no items match, returns empty list.
+        /// </summary>
+        /// <param name="excludes">The items to match</param>
+        /// <param name="excludeLocation">The specification to match against the items.</param>
+        /// <returns>A list of matching items</returns>
+        private HashSet<string> EvaluateExcludePaths(IReadOnlyList<string> excludes, ElementLocation excludeLocation)
+        {
+            HashSet<string> excludesUnescapedForComparison = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            foreach (string excludeSplit in excludes)
+            {
+                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(
+                    Project.Directory,
+                    excludeSplit,
+                    loggingMechanism: LoggingContext,
+                    excludeLocation: excludeLocation);
+                foreach (string excludeSplitFile in excludeSplitFiles)
+                {
+                    excludesUnescapedForComparison.Add(excludeSplitFile.NormalizeForPathComparison());
+                }
+            }
+
+            return excludesUnescapedForComparison;
+        }
+
         /// <summary>
         /// Returns a list of all items in the provided item group whose itemspecs match the specification, after it is split and any wildcards are expanded.
         /// If no items match, returns null.
@@ -612,7 +632,7 @@ private List<ProjectItemInstance> FindItemsMatchingMetadataSpecification(
         /// 1. The metadata table created for the bucket, may be null.
         /// 2. The metadata table derived from the item definition group, may be null.
         /// </summary>
-        private class NestedMetadataTable : IMetadataTable
+        private class NestedMetadataTable : IMetadataTable, IItemTypeDefinition
         {
             /// <summary>
             /// The table for all metadata added during expansion
@@ -722,6 +742,8 @@ internal void SetValue(string name, string value)
             {
                 _addTable[name] = value;
             }
+
+            string IItemTypeDefinition.ItemType => _itemType;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 79f3c4cd0f7..cef0fb834f9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -462,7 +462,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                         // UNDONE: (Refactor) Refactor TargetUpToDateChecker to take a logging context, not a logging service.
                         MSBuildEventSource.Log.TargetUpToDateStart();
                         TargetUpToDateChecker dependencyAnalyzer = new TargetUpToDateChecker(requestEntry.RequestConfiguration.Project, _target, targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext);
-                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, out changedTargetInputs, out upToDateTargetInputs);
+                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, _host.BuildParameters.Question, out changedTargetInputs, out upToDateTargetInputs);
                         MSBuildEventSource.Log.TargetUpToDateStop((int)dependencyResult);
 
                         switch (dependencyResult)
@@ -471,6 +471,13 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                             case DependencyAnalysisResult.FullBuild:
                             case DependencyAnalysisResult.IncrementalBuild:
                             case DependencyAnalysisResult.SkipUpToDate:
+                                if (dependencyResult != DependencyAnalysisResult.SkipUpToDate && _host.BuildParameters.Question && !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs))
+                                {
+                                    targetSuccess = false;
+                                    aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));
+                                    break;
+                                }
+
                                 // Create the lookups used to hold the current set of properties and items
                                 lookupForInference = bucket.Lookup;
                                 lookupForExecution = bucket.Lookup.Clone();
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index 2f444fce909..dcf16e16545 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -118,6 +118,7 @@ private string TargetOutputSpecification
         /// incremental build is needed.
         /// </remarks>
         /// <param name="bucket"></param>
+        /// <param name="question"></param>
         /// <param name="changedTargetInputs"></param>
         /// <param name="upToDateTargetInputs"></param>
         /// <returns>
@@ -129,6 +130,7 @@ private string TargetOutputSpecification
         /// </returns>
         internal DependencyAnalysisResult PerformDependencyAnalysis(
             ItemBucket bucket,
+            bool question,
             out ItemDictionary<ProjectItemInstance> changedTargetInputs,
             out ItemDictionary<ProjectItemInstance> upToDateTargetInputs)
         {
@@ -252,7 +254,7 @@ internal DependencyAnalysisResult PerformDependencyAnalysis(
                 }
             }
 
-            LogReasonForBuildingTarget(result);
+            LogReasonForBuildingTarget(result, question);
 
             return result;
         }
@@ -261,15 +263,23 @@ internal DependencyAnalysisResult PerformDependencyAnalysis(
         /// Does appropriate logging to indicate why this target is being built fully or partially.
         /// </summary>
         /// <param name="result"></param>
-        private void LogReasonForBuildingTarget(DependencyAnalysisResult result)
+        /// <param name="question"></param>
+        private void LogReasonForBuildingTarget(DependencyAnalysisResult result, bool question)
         {
             // Only if we are not logging just critical events should we be logging the details
             if (!_loggingService.OnlyLogCriticalEvents)
             {
                 if (result == DependencyAnalysisResult.FullBuild && _dependencyAnalysisDetail.Count > 0)
                 {
-                    // For the full build decision the are three possible outcomes
-                    _loggingService.LogComment(_buildEventContext, MessageImportance.Low, "BuildTargetCompletely", _targetToAnalyze.Name);
+                    if (question)
+                    {
+                        _loggingService.LogError(_buildEventContext, new BuildEventFileInfo(String.Empty), "BuildTargetCompletely", _targetToAnalyze.Name);
+                    }
+                    else
+                    {
+                        // For the full build decision, there are three possible outcomes
+                        _loggingService.LogComment(_buildEventContext, MessageImportance.Low, "BuildTargetCompletely", _targetToAnalyze.Name);
+                    }
 
                     foreach (DependencyAnalysisLogDetail logDetail in _dependencyAnalysisDetail)
                     {
@@ -279,8 +289,15 @@ private void LogReasonForBuildingTarget(DependencyAnalysisResult result)
                 }
                 else if (result == DependencyAnalysisResult.IncrementalBuild)
                 {
-                    // For the partial build decision the are three possible outcomes
-                    _loggingService.LogComment(_buildEventContext, MessageImportance.Normal, "BuildTargetPartially", _targetToAnalyze.Name);
+                    if (question)
+                    {
+                        _loggingService.LogError(_buildEventContext, new BuildEventFileInfo(String.Empty), "BuildTargetPartially", _targetToAnalyze.Name);
+                    }
+                    else
+                    {
+                        // For the partial build decision the are three possible outcomes
+                        _loggingService.LogComment(_buildEventContext, MessageImportance.Normal, "BuildTargetPartially", _targetToAnalyze.Name);
+                    }
                     foreach (DependencyAnalysisLogDetail logDetail in _dependencyAnalysisDetail)
                     {
                         string reason = GetIncrementalBuildReason(logDetail);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 3e0ea3b7abf..569a498e1cd 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -6,22 +6,24 @@
 using System.Collections.Generic;
 using System.Globalization;
 #if FEATURE_APPDOMAIN
-using System.Runtime.Remoting.Lifetime;
 using System.Runtime.Remoting;
+using System.Runtime.Remoting.Lifetime;
 #endif
+using System.Diagnostics;
+using System.Reflection;
 using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Components.Caching;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Eventing;
+using Microsoft.Build.Execution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Execution;
-using System.Diagnostics;
-using Microsoft.Build.Collections;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskLoggingContext = Microsoft.Build.BackEnd.Logging.TaskLoggingContext;
-using System.Threading.Tasks;
-using Microsoft.Build.BackEnd.Components.Caching;
-using System.Reflection;
-using Microsoft.Build.Eventing;
 
 #nullable disable
 
@@ -343,6 +345,14 @@ public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames,
         /// </summary>
         public void Yield()
         {
+#if FEATURE_REPORTFILEACCESSES
+            // If file accesses are being reported we should not yield as file access will be attributed to the wrong project.
+            if (_host.BuildParameters.ReportFileAccesses)
+            {
+                return;
+            }
+#endif
+
             lock (_callbackMonitor)
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
@@ -364,6 +374,14 @@ public void Reacquire()
             // to release explicitly granted cores when reacquiring the node may lead to deadlocks.
             ReleaseAllCores();
 
+#if FEATURE_REPORTFILEACCESSES
+            // If file accesses are being reported yielding is a no-op so reacquire should be too.
+            if (_host.BuildParameters.ReportFileAccesses)
+            {
+                return;
+            }
+#endif
+
             lock (_callbackMonitor)
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
@@ -377,7 +395,7 @@ public void Reacquire()
             }
         }
 
-        #endregion
+#endregion
 
         #region IBuildEngine Members
 
@@ -920,11 +938,26 @@ public override bool LogsMessagesOfImportance(MessageImportance importance)
 
             /// <inheritdoc/>
             public override bool IsTaskInputLoggingEnabled => _taskHost._host.BuildParameters.LogTaskInputs;
+
+#if FEATURE_REPORTFILEACCESSES
+            /// <summary>
+            /// Reports a file access from a task.
+            /// </summary>
+            /// <param name="fileAccessData">The file access to report.</param>
+            public void ReportFileAccess(FileAccessData fileAccessData)
+            {
+                IBuildComponentHost buildComponentHost = _taskHost._host;
+                if (buildComponentHost.BuildParameters.ReportFileAccesses)
+                {
+                    ((IFileAccessManager)buildComponentHost.GetComponent(BuildComponentType.FileAccessManager)).ReportFileAccess(fileAccessData, buildComponentHost.BuildParameters.NodeId);
+                }
+            }
+#endif
         }
 
         public EngineServices EngineServices { get; }
 
-        #endregion
+#endregion
 
         /// <summary>
         /// Called by the internal MSBuild task.
@@ -1079,7 +1112,11 @@ internal void MarkAsInactive()
         /// </summary>
         internal bool IsEventSerializable(BuildEventArgs e)
         {
-            if (!e.GetType().GetTypeInfo().IsSerializable)
+#pragma warning disable SYSLIB0050
+            // Types which are not serializable and are not IExtendedBuildEventArgs as
+            // those always implement custom serialization by WriteToStream and CreateFromStream.
+            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)
+#pragma warning restore SYSLIB0050
             {
                 _taskLoggingContext.LogWarning(null, new BuildEventFileInfo(string.Empty), "ExpectedEventToBeSerializable", e.GetType().Name);
                 return false;
diff --git a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
index d66e50d62c1..84e22a9c67c 100644
--- a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
@@ -33,6 +33,11 @@ internal interface IScheduler : IBuildComponent
         /// <returns>A positive configuration id if one exists in the plan, 0 otherwise.</returns>
         int GetConfigurationIdFromPlan(string configurationPath);
 
+        /// <summary>
+        /// Retrieves the request executing on a node.
+        /// </summary>
+        BuildRequest GetExecutingRequestByNode(int nodeId);
+
         /// <summary>
         /// Reports to the scheduler that a request is blocked.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index bedccfe03cd..6208aa883e4 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -283,6 +283,20 @@ public int GetConfigurationIdFromPlan(string configPath)
             return _schedulingPlan.GetConfigIdForPath(configPath);
         }
 
+        /// <summary>
+        /// Retrieves the request executing on a node.
+        /// </summary>
+        public BuildRequest GetExecutingRequestByNode(int nodeId)
+        {
+            if (!_schedulingData.IsNodeWorking(nodeId))
+            {
+                return null;
+            }
+
+            SchedulableRequest request = _schedulingData.GetExecutingRequestByNode(nodeId);
+            return request.BuildRequest;
+        }
+
         /// <summary>
         /// Reports that the specified request has become blocked and cannot proceed.
         /// </summary>
@@ -886,7 +900,7 @@ private bool GetSchedulingPlanAndAlgorithm()
 
                         string multiplier = Environment.GetEnvironmentVariable("MSBUILDCUSTOMSCHEDULERFORSQLCONFIGURATIONLIMITMULTIPLIER");
                         double convertedMultiplier = 0;
-                        if (!Double.TryParse(multiplier, out convertedMultiplier) || convertedMultiplier < 1)
+                        if (!Double.TryParse(multiplier, NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture.NumberFormat, out convertedMultiplier) || convertedMultiplier < 1)
                         {
                             _customSchedulerForSQLConfigurationLimitMultiplier = DefaultCustomSchedulerForSQLConfigurationLimitMultiplier;
                         }
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs b/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
index 405d0290483..61ba3fabbaf 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -14,7 +15,7 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors", Justification = "No point in adding the serialization constructors since BuildRequest is not serializable")]
     [SuppressMessage("Microsoft.Usage", "CA2237:MarkISerializableTypesWithSerializable", Justification = "No point in marking as ISerializable since BuildRequest is not. ")]
-    internal class SchedulerCircularDependencyException : Exception
+    internal class SchedulerCircularDependencyException : BuildExceptionBase
     {
         /// <summary>
         /// The ancestors which led to this circular dependency.
@@ -35,6 +36,11 @@ public SchedulerCircularDependencyException(BuildRequest request, IList<Schedula
             _ancestors = ancestors;
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal SchedulerCircularDependencyException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Gets an enumeration of the ancestors which led to this circular dependency.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
index bd8af074fb0..656cc7f4aab 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -12,7 +13,7 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// <summary>
     /// Represents an exception that occurs when an SdkResolver throws an unhandled exception.
     /// </summary>
-    public class SdkResolverException : Exception
+    public class SdkResolverException : BuildExceptionBase
     {
         public SdkResolver Resolver { get; private set; }
 
@@ -24,5 +25,10 @@ public SdkResolverException(string resourceName, SdkResolver resolver, SdkRefere
             Resolver = resolver;
             Sdk = sdk;
         }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal SdkResolverException(string message, Exception inner)
+            : base(message, inner)
+        { }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
index 68a14ae42a9..85943ff9442 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
@@ -110,7 +110,12 @@ private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, str
                                     string pattern = reader.ReadElementContentAsString();
                                     try
                                     {
-                                        manifest.ResolvableSdkRegex = new Regex(pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));
+                                        RegexOptions regexOptions = RegexOptions.CultureInvariant;
+                                        // For the kind of patterns used here, compiled regexes on .NET Framework tend to run slower than interpreted ones.
+#if RUNTIME_TYPE_NETCORE
+                                        regexOptions |= RegexOptions.Compiled;
+#endif
+                                        manifest.ResolvableSdkRegex = new Regex(pattern, regexOptions, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));
                                     }
                                     catch (ArgumentException ex)
                                     {
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index c0c3531ff34..7757598b2cd 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -144,6 +145,7 @@ public OutOfProcNode()
 
             _componentFactories = new BuildComponentFactoryCollection(this);
             _componentFactories.RegisterDefaultFactories();
+            SerializationContractInitializer.Initialize();
             _packetFactory = new NodePacketFactory();
 
             _buildRequestEngine = (this as IBuildComponentHost).GetComponent(BuildComponentType.RequestEngine) as IBuildRequestEngine;
@@ -152,11 +154,15 @@ public OutOfProcNode()
 
             // Create a factory for the out-of-proc SDK resolver service which can pass our SendPacket delegate to be used for sending packets to the main node
             OutOfProcNodeSdkResolverServiceFactory sdkResolverServiceFactory = new OutOfProcNodeSdkResolverServiceFactory(SendPacket);
-
             ((IBuildComponentHost)this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);
-
             _sdkResolverService = (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
 
+#if FEATURE_REPORTFILEACCESSES
+            ((IBuildComponentHost)this).RegisterFactory(
+                BuildComponentType.FileAccessManager,
+                (componentType) => OutOfProcNodeFileAccessManager.CreateComponent(componentType, SendPacket));
+#endif
+
             if (s_projectRootElementCacheBase == null)
             {
                 s_projectRootElementCacheBase = new ProjectRootElementCache(true /* automatically reload any changes from disk */);
@@ -368,6 +374,13 @@ private void OnRequestComplete(BuildRequest request, BuildResult result)
             {
                 _nodeEndpoint.SendData(result);
             }
+
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                FileAccessManager.NotifyFileAccessCompletion(result.GlobalRequestId);
+            }
+#endif
         }
 
         /// <summary>
@@ -571,7 +584,29 @@ private void SendPacket(INodePacket packet)
         {
             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
             {
+#if RUNTIME_TYPE_NETCORE
+                if (packet is LogMessagePacketBase logMessage
+                    && logMessage.EventType == LoggingEventType.CustomEvent 
+                    &&
+                    (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
+                    && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
+                {
+                    BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;
+
+                    // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>
+                    // Since BinaryFormatter is deprecated in dotnet 8+, log error so users discover root cause easier
+                    // then by reading CommTrace where it would be otherwise logged as critical infra error.
+                    _loggingService.LogError(_loggingContext?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,
+                            "DeprecatedEventSerialization",
+                            buildEvent?.GetType().Name ?? string.Empty);
+                }
+                else
+                {
+                    _nodeEndpoint.SendData(packet);
+                }
+#else
                 _nodeEndpoint.SendData(packet);
+#endif
             }
         }
 
diff --git a/src/Build/BackEnd/Shared/BuildAbortedException.cs b/src/Build/BackEnd/Shared/BuildAbortedException.cs
index ab5d34af0e4..d62a1504c70 100644
--- a/src/Build/BackEnd/Shared/BuildAbortedException.cs
+++ b/src/Build/BackEnd/Shared/BuildAbortedException.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -21,7 +23,7 @@ namespace Microsoft.Build.Exceptions
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    public class BuildAbortedException : Exception
+    public class BuildAbortedException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard BuildAbortedException.
@@ -49,17 +51,49 @@ public BuildAbortedException(string message)
         /// Constructs a BuildAbortedException with an additional message attached and an inner exception.
         /// </summary>
         public BuildAbortedException(string message, Exception innerException)
-            : base(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildAbortedWithMessage", message), innerException)
+            : this(message, innerException, false)
+        { }
+
+        internal static BuildAbortedException CreateFromRemote(string message, Exception innerException)
         {
-            ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "BuildAbortedWithMessage", message);
+            return new BuildAbortedException(message, innerException, true /* calledFromDeserialization */);
+        }
 
-            ErrorCode = errorCode;
+        private BuildAbortedException(string message, Exception innerException, bool calledFromDeserialization)
+            : base(
+                calledFromDeserialization
+                    ? message
+                    : ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildAbortedWithMessage", message),
+                innerException)
+        {
+            if (!calledFromDeserialization)
+            {
+                ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "BuildAbortedWithMessage", message);
+
+                ErrorCode = errorCode;
+            }
+        }
+
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(ErrorCode), ErrorCode }
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            ErrorCode = state[nameof(ErrorCode)];
         }
 
         /// <summary>
         /// Protected constructor used for (de)serialization. 
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected BuildAbortedException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -70,7 +104,7 @@ protected BuildAbortedException(SerializationInfo info, StreamingContext context
         /// Gets the error code (if any) associated with the exception message.
         /// </summary>
         /// <value>Error code string, or null.</value>
-        public string ErrorCode { get; }
+        public string ErrorCode { get; private set; }
 
         /// <summary>
         /// ISerializable method which we must override since Exception implements this interface
@@ -78,6 +112,9 @@ protected BuildAbortedException(SerializationInfo info, StreamingContext context
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 7fb5d26c006..838210573f6 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -1037,7 +1037,7 @@ private ITranslator GetConfigurationTranslator(TranslationDirection direction)
                 else
                 {
                     // Not using sharedReadBuffer because this is not a memory stream and so the buffer won't be used anyway.
-                    return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), null);
+                    return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);
                 }
             }
             catch (Exception e) when (e is DirectoryNotFoundException || e is UnauthorizedAccessException)
diff --git a/src/Build/BackEnd/Shared/CircularDependencyException.cs b/src/Build/BackEnd/Shared/CircularDependencyException.cs
index 08cfb2a4783..fd51ccb5cc1 100644
--- a/src/Build/BackEnd/Shared/CircularDependencyException.cs
+++ b/src/Build/BackEnd/Shared/CircularDependencyException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -16,7 +17,7 @@ namespace Microsoft.Build.Exceptions
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    public class CircularDependencyException : Exception
+    public class CircularDependencyException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard BuildAbortedException.
@@ -30,9 +31,17 @@ internal CircularDependencyException(string message)
         {
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal CircularDependencyException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Constructor for deserialization.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected CircularDependencyException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 3136450178d..2840148876c 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -327,7 +327,7 @@ private void TranslateItems(ITranslator translator)
                 ErrorUtilities.VerifyThrow(buffer != null, "Unexpected null items buffer during translation.");
 
                 using MemoryStream itemsStream = new MemoryStream(buffer, 0, buffer.Length, writable: false, publiclyVisible: true);
-                using var itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, null);
+                using var itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, InterningBinaryReader.PoolingBuffer);
                 _items = new TaskItem[itemsCount];
                 for (int i = 0; i < _items.Length; i++)
                 {
@@ -355,7 +355,7 @@ private static ITranslator GetResultsCacheTranslator(int configId, string target
             }
             else
             {
-                return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), null);
+                return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);
             }
         }
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 0598193fabb..4418a48a63d 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -333,7 +333,7 @@ bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, (string, ElementLo
             // Get the properties that exist on this task.  We need to gather all of the ones that are marked
             // "required" so that we can keep track of whether or not they all get set.
             var setParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            IDictionary<string, string> requiredParameters = GetNamesOfPropertiesWithRequiredAttribute();
+            IReadOnlyDictionary<string, string> requiredParameters = GetNamesOfPropertiesWithRequiredAttribute();
 
             // look through all the attributes of the task element
             foreach (KeyValuePair<string, (string, ElementLocation)> parameter in parameters)
@@ -369,6 +369,11 @@ bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, (string, ElementLo
                 }
             }
 
+            if (this.TaskInstance is IIncrementalTask incrementalTask)
+            {
+                incrementalTask.FailIfNotIncremental = _buildComponentHost.BuildParameters.Question;
+            }
+
             if (taskInitialized)
             {
                 // See if any required properties were not set
@@ -1390,9 +1395,15 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                                     // Setting an item spec expects the escaped value, as does setting metadata.
                                     newItem = new ProjectItemInstance(_projectInstance, outputTargetName, EscapingUtilities.Escape(output.ItemSpec), parameterLocationEscaped);
 
-                                    newItem.SetMetadataOnTaskOutput(output.CloneCustomMetadata()
-                                        .Cast<DictionaryEntry>()
-                                        .Select(x => new KeyValuePair<string, string>((string)x.Key, EscapingUtilities.Escape((string)x.Value))));
+                                    newItem.SetMetadataOnTaskOutput(EnumerateMetadata(output.CloneCustomMetadata()));
+
+                                    static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary customMetadata)
+                                    {
+                                        foreach (DictionaryEntry de in customMetadata)
+                                        {
+                                            yield return new KeyValuePair<string, string>((string)de.Key, EscapingUtilities.Escape((string)de.Value));
+                                        }
+                                    }
                                 }
                             }
 
@@ -1529,10 +1540,10 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
         /// Returns them as keys in a dictionary.
         /// </summary>
         /// <returns>Gets a list of properties which are required.</returns>
-        private IDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute()
+        private IReadOnlyDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute()
         {
             ErrorUtilities.VerifyThrow(_taskFactoryWrapper != null, "Expected taskFactoryWrapper to not be null");
-            IDictionary<string, string> requiredParameters = null;
+            IReadOnlyDictionary<string, string> requiredParameters = null;
 
             try
             {
diff --git a/src/Build/Collections/ConvertingEnumerable.cs b/src/Build/Collections/ConvertingEnumerable.cs
index b4b3e1d7058..e5933cd53dc 100644
--- a/src/Build/Collections/ConvertingEnumerable.cs
+++ b/src/Build/Collections/ConvertingEnumerable.cs
@@ -82,7 +82,7 @@ internal ConvertingEnumerator(IEnumerator<TFrom2> backingEnumerator, Func<TFrom2
             /// <summary>
             /// Get the current element, converted
             /// </summary>
-            public TTo2 Current
+            public readonly TTo2 Current
             {
                 get
                 {
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index eeedd7c4c1b..fb954982e34 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -14,12 +14,10 @@
 
 /*
     ==================================================================================================================
-    MSBUILD COMMENT:
 
-    Ripped off from Hashset.cs with the following changes:
+    This is the standard Hashset with the following changes:
 
     * class renamed
-    * unnecessary methods and attributes if-deffed out (code retained to help windiff, but indented)
     * require T implements IKeyed, and accept IKeyed directly where necessary
     * all constructors require a comparer -- an IEqualityComparer<IKeyed> -- to avoid mistakes
     * change Contains to give you back the found entry, rather than a boolean
@@ -28,16 +26,17 @@
     * constructor that allows the collection to be read-only
     * implement IDictionary<string, T>
     * some convenience methods taking 'string' as overloads of methods taking IKeyed
-    
-    Other than this it is modified absolutely minimally to make it easy to diff with the originals (in the Originals folder) 
-    to verify that no errors were introduced, and make it easier to possibly pick up any future bug fixes to the original. 
-    The care taken to minimally modify this means that it is not necessary to carefully code review this complex class, 
-    nor unit test it directly.
+
     ==================================================================================================================
 */
 
 #nullable disable
 
+// The BuildXL package causes an indirect dependency on the RuntimeContracts package, which adds an analyzer which forbids the use of System.Diagnostics.Contract.
+// So effectively if your dependencies use RuntimeContracts, it attempts to force itself on your as well.
+// See: https://github.com/SergeyTeplyakov/RuntimeContracts/issues/12
+#pragma warning disable RA001 // Do not use System.Diagnostics.Contract class.
+
 namespace Microsoft.Build.Collections
 {
     /// <summary>
@@ -90,10 +89,7 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
     {
         // store lower 31 bits of hash code
         private const int Lower31BitMask = 0x7FFFFFFF;
-#if NEVER
-        // cutoff point, above which we won't do stackallocs. This corresponds to 100 integers.
-        private const int StackAllocThreshold = 100;
-#endif
+
         // when constructing a hashset from an existing collection, it may contain duplicates, 
         // so this is used as the max acceptable excess ratio of capacity to count. Note that
         // this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
@@ -637,360 +633,6 @@ public void UnionWith(IEnumerable<T> other)
             }
         }
 
-#if NEVER
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Takes the intersection of this set with other. Modifies this set.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes: 
-                                                                                                                                                        /// We get better perf if other is a hashset using same equality comparer, because we 
-                                                                                                                                                        /// get constant contains check in other. Resulting cost is O(n1) to iterate over this.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// If we can't go above route, iterate over the other and mark intersection by checking
-                                                                                                                                                        /// contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Attempts to return early based on counts alone, using the property that the 
-                                                                                                                                                        /// intersection of anything with the empty set is the empty set.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other">enumerable with items to add </param>
-                                                                                                                                                        public void IntersectWith(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // intersection of anything with empty set is empty set, so return if count is 0
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // if other is empty, intersection is empty set; remove all elements and we're done
-                                                                                                                                                            // can only figure this out if implements ICollection<T>. (IEnumerable<T> has no count)
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                if (otherAsCollection.Count == 0) {
-                                                                                                                                                                    Clear();
-                                                                                                                                                                    return;
-                                                                                                                                                                }
-
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // faster if other is a hashset using same equality comparer; so check 
-                                                                                                                                                                // that other is a hashset using the same equality comparer.
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    IntersectWithHashSetWithSameEC(otherAsSet);
-                                                                                                                                                                    return;
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            IntersectWithEnumerable(other);
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Remove items in other from this set. Modifies this set.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other">enumerable with items to remove</param>
-                                                                                                                                                        public void ExceptWith(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // this is already the enpty set; return
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // special case if other is this; a set minus itself is the empty set
-                                                                                                                                                            if (other == this) {
-                                                                                                                                                                Clear();
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // remove every element in other from this
-                                                                                                                                                            foreach (T element in other) {
-                                                                                                                                                                Remove(element);
-                                                                                                                                                            }
-                                                                                                                                                        }
-
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Takes symmetric difference (XOR) with other and this set. Modifies this set.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other">enumerable with items to XOR</param>
-                                                                                                                                                        public void SymmetricExceptWith(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // if set is empty, then symmetric difference is other
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                UnionWith(other);
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // special case this; the symmetric difference of a set with itself is the empty set
-                                                                                                                                                            if (other == this) {
-                                                                                                                                                                Clear();
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                            // If other is a HashSet, it has unique elements according to its equality comparer,
-                                                                                                                                                            // but if they're using different equality comparers, then assumption of uniqueness
-                                                                                                                                                            // will fail. So first check if other is a hashset using the same equality comparer;
-                                                                                                                                                            // symmetric except is a lot faster and avoids bit array allocations if we can assume
-                                                                                                                                                            // uniqueness
-                                                                                                                                                            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                SymmetricExceptWithUniqueHashSet(otherAsSet);
-                                                                                                                                                            }
-                                                                                                                                                            else {
-                                                                                                                                                                SymmetricExceptWithEnumerable(other);
-                                                                                                                                                            }
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a subset of other.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If this is the empty set, then it's a subset of anything, including the empty set
-                                                                                                                                                        /// 2. If other has unique elements according to this equality comparer, and this has more
-                                                                                                                                                        /// elements than other, then it can't be a subset.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Furthermore, if other is a hashset using the same equality comparer, we can use a 
-                                                                                                                                                        /// faster element-wise check.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a subset of other; false if not</returns>
-                                                                                                                                                        public bool IsSubsetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // The empty set is a subset of any set
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return true;
-                                                                                                                                                            }
-
-                                                                                                                                                            RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                            // faster if other has unique elements according to this equality comparer; so check 
-                                                                                                                                                            // that other is a hashset using the same equality comparer.
-                                                                                                                                                            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                // if this has more elements then it can't be a subset
-                                                                                                                                                                if (m_count > otherAsSet.Count) {
-                                                                                                                                                                    return false;
-                                                                                                                                                                }
-
-                                                                                                                                                                // already checked that we're using same equality comparer. simply check that 
-                                                                                                                                                                // each element in this is contained in other.
-                                                                                                                                                                return IsSubsetOfHashSetWithSameEC(otherAsSet);
-                                                                                                                                                            }
-                                                                                                                                                            else {
-                                                                                                                                                                ElementCount result = CheckUniqueAndUnfoundElements(other, false);
-                                                                                                                                                                return (result.uniqueCount == m_count && result.unfoundCount >= 0);
-                                                                                                                                                            }
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a proper subset of other (i.e. strictly contained in)
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If this is the empty set, then it's a proper subset of a set that contains at least
-                                                                                                                                                        /// one element, but it's not a proper subset of the empty set.
-                                                                                                                                                        /// 2. If other has unique elements according to this equality comparer, and this has >=
-                                                                                                                                                        /// the number of elements in other, then this can't be a proper subset.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Furthermore, if other is a hashset using the same equality comparer, we can use a 
-                                                                                                                                                        /// faster element-wise check.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a proper subset of other; false if not</returns>
-                                                                                                                                                        public bool IsProperSubsetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                // the empty set is a proper subset of anything but the empty set
-                                                                                                                                                                if (m_count == 0) {
-                                                                                                                                                                    return otherAsCollection.Count > 0;
-                                                                                                                                                                }
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // faster if other is a hashset (and we're using same equality comparer)
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    if (m_count >= otherAsSet.Count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                    // this has strictly less than number of items in other, so the following
-                                                                                                                                                                    // check suffices for proper subset.
-                                                                                                                                                                    return IsSubsetOfHashSetWithSameEC(otherAsSet);
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            ElementCount result = CheckUniqueAndUnfoundElements(other, false);
-                                                                                                                                                            return (result.uniqueCount == m_count && result.unfoundCount > 0);
-
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a superset of other
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If other has no elements (it's the empty set), then this is a superset, even if this
-                                                                                                                                                        /// is also the empty set.
-                                                                                                                                                        /// 2. If other has unique elements according to this equality comparer, and this has less 
-                                                                                                                                                        /// than the number of elements in other, then this can't be a superset
-                                                                                                                                                        /// 
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a superset of other; false if not</returns>
-                                                                                                                                                        public bool IsSupersetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // try to fall out early based on counts
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                // if other is the empty set then this is a superset
-                                                                                                                                                                if (otherAsCollection.Count == 0) {
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // try to compare based on counts alone if other is a hashset with
-                                                                                                                                                                // same equality comparer
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    if (otherAsSet.Count > m_count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            return ContainsAllElements(other);
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a proper superset of other (i.e. other strictly contained in this)
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes: 
-                                                                                                                                                        /// This is slightly more complicated than above because we have to keep track if there
-                                                                                                                                                        /// was at least one element not contained in other.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If this is the empty set, then it can't be a proper superset of any set, even if 
-                                                                                                                                                        /// other is the empty set.
-                                                                                                                                                        /// 2. If other is an empty set and this contains at least 1 element, then this is a proper
-                                                                                                                                                        /// superset.
-                                                                                                                                                        /// 3. If other has unique elements according to this equality comparer, and other's count
-                                                                                                                                                        /// is greater than or equal to this count, then this can't be a proper superset
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Furthermore, if other has unique elements according to this equality comparer, we can
-                                                                                                                                                        /// use a faster element-wise check.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a proper superset of other; false if not</returns>
-                                                                                                                                                        public bool IsProperSupersetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // the empty set isn't a proper superset of any set.
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return false;
-                                                                                                                                                            }
-
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                // if other is the empty set then this is a superset
-                                                                                                                                                                if (otherAsCollection.Count == 0) {
-                                                                                                                                                                    // note that this has at least one element, based on above check
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // faster if other is a hashset with the same equality comparer
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    if (otherAsSet.Count >= m_count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                    // now perform element check
-                                                                                                                                                                    return ContainsAllElements(otherAsSet);
-                                                                                                                                                                }
-                                                                                                                                                            }
-                                                                                                                                                            // couldn't fall out in the above cases; do it the long way
-                                                                                                                                                            ElementCount result = CheckUniqueAndUnfoundElements(other, true);
-                                                                                                                                                            return (result.uniqueCount < m_count && result.unfoundCount == 0);
-
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this set overlaps other (i.e. they share at least one item)
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if these have at least one common element; false if disjoint</returns>
-                                                                                                                                                        public bool Overlaps(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return false;
-                                                                                                                                                            }
-
-                                                                                                                                                            foreach (T element in other) {
-                                                                                                                                                                if (Contains(element)) {
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                            }
-                                                                                                                                                            return false;
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this and other contain the same elements. This is set equality: 
-                                                                                                                                                        /// duplicates and order are ignored
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns></returns>
-                                                                                                                                                        public bool SetEquals(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                            // faster if other is a hashset and we're using same equality comparer
-                                                                                                                                                            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                // attempt to return early: since both contain unique elements, if they have 
-                                                                                                                                                                // different counts, then they can't be equal
-                                                                                                                                                                if (m_count != otherAsSet.Count) {
-                                                                                                                                                                    return false;
-                                                                                                                                                                }
-
-                                                                                                                                                                // already confirmed that the sets have the same number of distinct elements, so if
-                                                                                                                                                                // one is a superset of the other then they must be equal
-                                                                                                                                                                return ContainsAllElements(otherAsSet);
-                                                                                                                                                            }
-                                                                                                                                                            else {
-                                                                                                                                                                ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                                if (otherAsCollection != null) {
-                                                                                                                                                                    // if this count is 0 but other contains at least one element, they can't be equal
-                                                                                                                                                                    if (m_count == 0 && otherAsCollection.Count > 0) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                }
-                                                                                                                                                                ElementCount result = CheckUniqueAndUnfoundElements(other, true);
-                                                                                                                                                                return (result.uniqueCount == m_count && result.unfoundCount == 0);
-                                                                                                                                                            }
-                                                                                                                                                        }
-#endif
-
         // Copy all elements into array starting at zero based index specified
         [SuppressMessage("Microsoft.Usage", "CA2208:InstantiateArgumentExceptionsCorrectly", Justification = "Decently informative for an exception that will probably never actually see the light of day")]
         void ICollection<KeyValuePair<string, T>>.CopyTo(KeyValuePair<string, T>[] array, int index)
@@ -1050,46 +692,6 @@ public void CopyTo(T[] array, int arrayIndex, int count)
             }
         }
 
-#if NEVER
-                                                                                                                                                    /// <summary>
-                                                                                                                                                    /// Remove elements that match specified predicate. Returns the number of elements removed
-                                                                                                                                                    /// </summary>
-                                                                                                                                                    /// <param name="match"></param>
-                                                                                                                                                    /// <returns></returns>
-                                                                                                                                                    public int RemoveWhere(Predicate<T> match) {
-                                                                                                                                                        if (match == null) {
-                                                                                                                                                            throw new ArgumentNullException("match");
-                                                                                                                                                        }
-                                                                                                                                                        Contract.EndContractBlock();
-
-                                                                                                                                                        int numRemoved = 0;
-                                                                                                                                                        for (int i = 0; i < m_lastIndex; i++) {
-                                                                                                                                                            if (m_slots[i].hashCode >= 0) {
-                                                                                                                                                                // cache value in case delegate removes it
-                                                                                                                                                                T value = m_slots[i].value;
-                                                                                                                                                                if (match(value)) {
-                                                                                                                                                                    // check again that remove actually removed it
-                                                                                                                                                                    if (Remove(value)) {
-                                                                                                                                                                        numRemoved++;
-                                                                                                                                                                    }
-                                                                                                                                                                }
-                                                                                                                                                            }
-                                                                                                                                                        }
-                                                                                                                                                        return numRemoved;
-                                                                                                                                                    }
-
-        /// <summary>
-        /// Gets the IEqualityComparer that is used to determine equality of keys for 
-        /// the HashSet.
-        /// </summary>
-        public IEqualityComparer<IKeyed> Comparer
-        {
-            get
-            {
-                return _comparer;
-            }
-        }
-#endif
         /// <summary>
         /// Sets the capacity of this list to the size of the list (rounded up to nearest prime),
         /// unless count is 0, in which case we release references.
@@ -1149,18 +751,6 @@ public void TrimExcess()
             }
         }
 
-#if NEVER
-#if !SILVERLIGHT || FEATURE_NETCORE
-                                                                                                                                                    /// <summary>
-                                                                                                                                                    /// Used for deep equality of HashSet testing
-                                                                                                                                                    /// </summary>
-                                                                                                                                                    /// <returns></returns>
-                                                                                                                                                    public static IEqualityComparer<RetrievableEntryHashSet<T>> CreateSetComparer() {
-                                                                                                                                                        return new HashSetEqualityComparer<T>();
-                                                                                                                                                    }
-#endif
-#endif
-
         #endregion
 
         #region Helper methods
@@ -1301,338 +891,7 @@ internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet<T> other)
             return true;
         }
 
-#if NEVER
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// Checks if this contains of other's elements. Iterates over other's elements and 
-                                                                                                                                                                        /// returns false as soon as it finds an element in other that's not in this.
-                                                                                                                                                                        /// Used by SupersetOf, ProperSupersetOf, and SetEquals.
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        /// <returns></returns>
-                                                                                                                                                                        private bool ContainsAllElements(IEnumerable<T> other) {
-                                                                                                                                                                            foreach (T element in other) {
-                                                                                                                                                                                if (!Contains(element)) {
-                                                                                                                                                                                    return false;
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                            return true;
-                                                                                                                                                                        }
-
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                                        /// If other is a hashset and is using same equality comparer, then checking subset is 
-                                                                                                                                                                        /// faster. Simply check that each element in this is in other.
-                                                                                                                                                                        /// 
-                                                                                                                                                                        /// Note: if other doesn't use same equality comparer, then Contains check is invalid,
-                                                                                                                                                                        /// which is why callers must take are of this.
-                                                                                                                                                                        /// 
-                                                                                                                                                                        /// If callers are concerned about whether this is a proper subset, they take care of that.
-                                                                                                                                                                        ///
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        /// <returns></returns>
-                                                                                                                                                                        private bool IsSubsetOfHashSetWithSameEC(RetrievableEntryHashSet<T> other) {
-
-                                                                                                                                                                            foreach (T item in this) {
-                                                                                                                                                                                if (!other.Contains(item)) {
-                                                                                                                                                                                    return false;
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                            return true;
-                                                                                                                                                                        }
-
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// If other is a hashset that uses same equality comparer, intersect is much faster 
-                                                                                                                                                                        /// because we can use other's Contains
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        private void IntersectWithHashSetWithSameEC(RetrievableEntryHashSet<T> other) {
-                                                                                                                                                                            for (int i = 0; i < m_lastIndex; i++) {
-                                                                                                                                                                                if (m_slots[i].hashCode >= 0) {
-                                                                                                                                                                                    T item = m_slots[i].value;
-                                                                                                                                                                                    if (!other.Contains(item)) {
-                                                                                                                                                                                        Remove(item);
-                                                                                                                                                                                    }
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// Iterate over other. If contained in this, mark an element in bit array corresponding to
-                                                                                                                                                                        /// its position in m_slots. If anything is unmarked (in bit array), remove it.
-                                                                                                                                                                        /// 
-                                                                                                                                                                        /// This attempts to allocate on the stack, if below StackAllocThreshold.
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        [System.Security.SecuritySafeCritical]
-                                                                                                                                                                        private unsafe void IntersectWithEnumerable(IEnumerable<T> other) {
-                                                                                                                                                                            Debug.Assert(m_buckets != null, "m_buckets shouldn't be null; callers should check first");
-
-                                                                                                                                                                            // keep track of current last index; don't want to move past the end of our bit array
-                                                                                                                                                                            // (could happen if another thread is modifying the collection)
-                                                                                                                                                                            int originalLastIndex = m_lastIndex;
-                                                                                                                                                                            int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-                                                                                                                                                                            BitHelper bitHelper;
-                                                                                                                                                                            if (intArrayLength <= StackAllocThreshold) {
-                                                                                                                                                                                int* bitArrayPtr = stackalloc int[intArrayLength];
-                                                                                                                                                                                bitHelper = new BitHelper(bitArrayPtr, intArrayLength);
-                                                                                                                                                                            }
-                                                                                                                                                                            else {
-                                                                                                                                                                                int[] bitArray = new int[intArrayLength];
-                                                                                                                                                                                bitHelper = new BitHelper(bitArray, intArrayLength);
-                                                                                                                                                                            }
-
-                                                                                                                                                                            // mark if contains: find index of in slots array and mark corresponding element in bit array
-                                                                                                                                                                            foreach (T item in other) {
-                                                                                                                                                                                int index = InternalIndexOf(item);
-                                                                                                                                                                                if (index >= 0) {
-                                                                                                                                                                                    bitHelper.MarkBit(index);
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-
-                                                                                                                                                                            // if anything unmarked, remove it. Perf can be optimized here if BitHelper had a 
-                                                                                                                                                                            // FindFirstUnmarked method.
-                                                                                                                                                                            for (int i = 0; i < originalLastIndex; i++) {
-                                                                                                                                                                                if (m_slots[i].hashCode >= 0 && !bitHelper.IsMarked(i)) {
-                                                                                                                                                                                    Remove(m_slots[i].value);
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-
-                                                                                                                                                                    /// <summary>
-                                                                                                                                                                    /// Used internally by set operations which have to rely on bit array marking. This is like
-                                                                                                                                                                    /// Contains but returns index in slots array. 
-                                                                                                                                                                    /// </summary>
-                                                                                                                                                                    /// <param name="item"></param>
-                                                                                                                                                                    /// <returns></returns>
-                                                                                                                                                                    private int InternalIndexOf(T item) {
-                                                                                                                                                                        Debug.Assert(m_buckets != null, "m_buckets was null; callers should check first");
-
-                                                                                                                                                                        int hashCode = InternalGetHashCode(item);
-                                                                                                                                                                        for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                                                                                                                                                                            if ((m_slots[i].hashCode) == hashCode && m_comparer.Equals(m_slots[i].value, item)) {
-                                                                                                                                                                                return i;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                        // wasn't found
-                                                                                                                                                                        return -1;
-                                                                                                                                                                    }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// if other is a set, we can assume it doesn't have duplicate elements, so use this
-                                                                                                                                                                /// technique: if can't remove, then it wasn't present in this set, so add.
-                                                                                                                                                                /// 
-                                                                                                                                                                /// As with other methods, callers take care of ensuring that other is a hashset using the
-                                                                                                                                                                /// same equality comparer.
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="other"></param>
-                                                                                                                                                                private void SymmetricExceptWithUniqueHashSet(RetrievableEntryHashSet<T> other) {
-                                                                                                                                                                    foreach (T item in other) {
-                                                                                                                                                                        if (!Remove(item)) {
-                                                                                                                                                                            AddEvenIfPresent(item);
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// Implementation notes:
-                                                                                                                                                                /// 
-                                                                                                                                                                /// Used for symmetric except when other isn't a HashSet. This is more tedious because 
-                                                                                                                                                                /// other may contain duplicates. HashSet technique could fail in these situations:
-                                                                                                                                                                /// 1. Other has a duplicate that's not in this: HashSet technique would add then 
-                                                                                                                                                                /// remove it.
-                                                                                                                                                                /// 2. Other has a duplicate that's in this: HashSet technique would remove then add it
-                                                                                                                                                                /// back.
-                                                                                                                                                                /// In general, its presence would be toggled each time it appears in other. 
-                                                                                                                                                                /// 
-                                                                                                                                                                /// This technique uses bit marking to indicate whether to add/remove the item. If already
-                                                                                                                                                                /// present in collection, it will get marked for deletion. If added from other, it will
-                                                                                                                                                                /// get marked as something not to remove.
-                                                                                                                                                                ///
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="other"></param>
-                                                                                                                                                                [System.Security.SecuritySafeCritical]
-                                                                                                                                                                private unsafe void SymmetricExceptWithEnumerable(IEnumerable<T> other) {
-                                                                                                                                                                    int originalLastIndex = m_lastIndex;
-                                                                                                                                                                    int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-                                                                                                                                                                    BitHelper itemsToRemove;
-                                                                                                                                                                    BitHelper itemsAddedFromOther;
-                                                                                                                                                                    if (intArrayLength <= StackAllocThreshold / 2) {
-                                                                                                                                                                        int* itemsToRemovePtr = stackalloc int[intArrayLength];
-                                                                                                                                                                        itemsToRemove = new BitHelper(itemsToRemovePtr, intArrayLength);
-
-                                                                                                                                                                        int* itemsAddedFromOtherPtr = stackalloc int[intArrayLength];
-                                                                                                                                                                        itemsAddedFromOther = new BitHelper(itemsAddedFromOtherPtr, intArrayLength);
-                                                                                                                                                                    }
-                                                                                                                                                                    else {
-                                                                                                                                                                        int[] itemsToRemoveArray = new int[intArrayLength];
-                                                                                                                                                                        itemsToRemove = new BitHelper(itemsToRemoveArray, intArrayLength);
-
-                                                                                                                                                                        int[] itemsAddedFromOtherArray = new int[intArrayLength];
-                                                                                                                                                                        itemsAddedFromOther = new BitHelper(itemsAddedFromOtherArray, intArrayLength);
-                                                                                                                                                                    }
-
-                                                                                                                                                                    foreach (T item in other) {
-                                                                                                                                                                        int location = 0;
-                                                                                                                                                                        bool added = AddOrGetLocation(item, out location);
-                                                                                                                                                                        if (added) {
-                                                                                                                                                                            // wasn't already present in collection; flag it as something not to remove
-                                                                                                                                                                            // *NOTE* if location is out of range, we should ignore. BitHelper will
-                                                                                                                                                                            // detect that it's out of bounds and not try to mark it. But it's 
-                                                                                                                                                                            // expected that location could be out of bounds because adding the item
-                                                                                                                                                                            // will increase m_lastIndex as soon as all the free spots are filled.
-                                                                                                                                                                            itemsAddedFromOther.MarkBit(location);
-                                                                                                                                                                        }
-                                                                                                                                                                        else {
-                                                                                                                                                                            // already there...if not added from other, mark for remove. 
-                                                                                                                                                                            // *NOTE* Even though BitHelper will check that location is in range, we want 
-                                                                                                                                                                            // to check here. There's no point in checking items beyond originalLastIndex
-                                                                                                                                                                            // because they could not have been in the original collection
-                                                                                                                                                                            if (location < originalLastIndex && !itemsAddedFromOther.IsMarked(location)) {
-                                                                                                                                                                                itemsToRemove.MarkBit(location);
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-
-                                                                                                                                                                    // if anything marked, remove it
-                                                                                                                                                                    for (int i = 0; i < originalLastIndex; i++) {
-                                                                                                                                                                        if (itemsToRemove.IsMarked(i)) {
-                                                                                                                                                                            Remove(m_slots[i].value);
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// Add if not already in hashset. Returns an out param indicating index where added. This 
-                                                                                                                                                                /// is used by SymmetricExcept because it needs to know the following things:
-                                                                                                                                                                /// - whether the item was already present in the collection or added from other
-                                                                                                                                                                /// - where it's located (if already present, it will get marked for removal, otherwise
-                                                                                                                                                                /// marked for keeping)
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="value"></param>
-                                                                                                                                                                /// <param name="location"></param>
-                                                                                                                                                                /// <returns></returns>
-                                                                                                                                                                private bool AddOrGetLocation(T value, out int location) {
-                                                                                                                                                                    Debug.Assert(m_buckets != null, "m_buckets is null, callers should have checked");
-
-                                                                                                                                                                    int hashCode = InternalGetHashCode(value);
-                                                                                                                                                                    int bucket = hashCode % m_buckets.Length;
-                                                                                                                                                                    for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                                                                                                                                                                        if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, value)) {
-                                                                                                                                                                            location = i;
-                                                                                                                                                                            return false; //already present
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                    int index;
-                                                                                                                                                                    if (m_freeList >= 0) {
-                                                                                                                                                                        index = m_freeList;
-                                                                                                                                                                        m_freeList = m_slots[index].next;
-                                                                                                                                                                    }
-                                                                                                                                                                    else {
-                                                                                                                                                                        if (m_lastIndex == m_slots.Length) {
-                                                                                                                                                                            IncreaseCapacity();
-                                                                                                                                                                            // this will change during resize
-                                                                                                                                                                            bucket = hashCode % m_buckets.Length;
-                                                                                                                                                                        }
-                                                                                                                                                                        index = m_lastIndex;
-                                                                                                                                                                        m_lastIndex++;
-                                                                                                                                                                    }
-                                                                                                                                                                    m_slots[index].hashCode = hashCode;
-                                                                                                                                                                    m_slots[index].value = value;
-                                                                                                                                                                    m_slots[index].next = m_buckets[bucket] - 1;
-                                                                                                                                                                    m_buckets[bucket] = index + 1;
-                                                                                                                                                                    m_count++;
-                                                                                                                                                                    m_version++;
-                                                                                                                                                                    location = index;
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// Determines counts that can be used to determine equality, subset, and superset. This
-                                                                                                                                                                /// is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
-                                                                                                                                                                /// these properties can be checked faster without use of marking because we can assume 
-                                                                                                                                                                /// other has no duplicates.
-                                                                                                                                                                /// 
-                                                                                                                                                                /// The following count checks are performed by callers:
-                                                                                                                                                                /// 1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = m_count; i.e. everything 
-                                                                                                                                                                /// in other is in this and everything in this is in other
-                                                                                                                                                                /// 2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = m_count; i.e. other may
-                                                                                                                                                                /// have elements not in this and everything in this is in other
-                                                                                                                                                                /// 3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = m_count; i.e
-                                                                                                                                                                /// other must have at least one element not in this and everything in this is in other
-                                                                                                                                                                /// 4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
-                                                                                                                                                                /// than m_count; i.e. everything in other was in this and this had at least one element
-                                                                                                                                                                /// not contained in other.
-                                                                                                                                                                /// 
-                                                                                                                                                                /// An earlier implementation used delegates to perform these checks rather than returning
-                                                                                                                                                                /// an ElementCount struct; however this was changed due to the perf overhead of delegates.
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="other"></param>
-                                                                                                                                                                /// <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
-                                                                                                                                                                /// because unfoundCount must be 0.</param>
-                                                                                                                                                                /// <returns></returns>
-                                                                                                                                                                [System.Security.SecuritySafeCritical]
-                                                                                                                                                                private unsafe ElementCount CheckUniqueAndUnfoundElements(IEnumerable<T> other, bool returnIfUnfound) {
-                                                                                                                                                                    ElementCount result;
-
-                                                                                                                                                                    // need special case in case this has no elements. 
-                                                                                                                                                                    if (m_count == 0) {
-                                                                                                                                                                        int numElementsInOther = 0;
-                                                                                                                                                                        foreach (T item in other) {
-                                                                                                                                                                            numElementsInOther++;
-                                                                                                                                                                            // break right away, all we want to know is whether other has 0 or 1 elements
-                                                                                                                                                                            break;
-                                                                                                                                                                        }
-                                                                                                                                                                        result.uniqueCount = 0;
-                                                                                                                                                                        result.unfoundCount = numElementsInOther;
-                                                                                                                                                                        return result;
-                                                                                                                                                                    }
-
-
-                                                                                                                                                                    Debug.Assert((m_buckets != null) && (m_count > 0), "m_buckets was null but count greater than 0");
-
-                                                                                                                                                                    int originalLastIndex = m_lastIndex;
-                                                                                                                                                                    int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-                                                                                                                                                                    BitHelper bitHelper;
-                                                                                                                                                                    if (intArrayLength <= StackAllocThreshold) {
-                                                                                                                                                                        int* bitArrayPtr = stackalloc int[intArrayLength];
-                                                                                                                                                                        bitHelper = new BitHelper(bitArrayPtr, intArrayLength);
-                                                                                                                                                                    }
-                                                                                                                                                                    else {
-                                                                                                                                                                        int[] bitArray = new int[intArrayLength];
-                                                                                                                                                                        bitHelper = new BitHelper(bitArray, intArrayLength);
-                                                                                                                                                                    }
-
-                                                                                                                                                                    // count of items in other not found in this
-                                                                                                                                                                    int unfoundCount = 0;
-                                                                                                                                                                    // count of unique items in other found in this
-                                                                                                                                                                    int uniqueFoundCount = 0;
-
-                                                                                                                                                                    foreach (T item in other) {
-                                                                                                                                                                        int index = InternalIndexOf(item);
-                                                                                                                                                                        if (index >= 0) {
-                                                                                                                                                                            if (!bitHelper.IsMarked(index)) {
-                                                                                                                                                                                // item hasn't been seen yet
-                                                                                                                                                                                bitHelper.MarkBit(index);
-                                                                                                                                                                                uniqueFoundCount++;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                        else {
-                                                                                                                                                                            unfoundCount++;
-                                                                                                                                                                            if (returnIfUnfound) {
-                                                                                                                                                                                break;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-
-                                                                                                                                                                    result.uniqueCount = uniqueFoundCount;
-                                                                                                                                                                    result.unfoundCount = unfoundCount;
-                                                                                                                                                                    return result;
-                                                                                                                                                                }
-#endif
+
         /// <summary>
         /// Copies this to an array. Used for DebugView
         /// </summary>
@@ -1644,71 +903,6 @@ internal T[] ToArray()
             return newArray;
         }
 
-#if NEVER
-                                                                                                                                                            /// <summary>
-                                                                                                                                                            /// Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
-                                                                                                                                                            /// to specified comparer.
-                                                                                                                                                            /// 
-                                                                                                                                                            /// Because items are hashed according to a specific equality comparer, we have to resort
-                                                                                                                                                            /// to n^2 search if they're using different equality comparers.
-                                                                                                                                                            /// </summary>
-                                                                                                                                                            /// <param name="set1"></param>
-                                                                                                                                                            /// <param name="set2"></param>
-                                                                                                                                                            /// <param name="comparer"></param>
-                                                                                                                                                            /// <returns></returns>
-                                                                                                                                                            internal static bool HashSetEquals(RetrievableEntryHashSet<T> set1, RetrievableEntryHashSet<T> set2, IEqualityComparer<T> comparer) {
-                                                                                                                                                                // handle null cases first
-                                                                                                                                                                if (set1 == null) {
-                                                                                                                                                                    return (set2 == null);
-                                                                                                                                                                }
-                                                                                                                                                                else if (set2 == null) {
-                                                                                                                                                                    // set1 != null
-                                                                                                                                                                    return false;
-                                                                                                                                                                }
-
-                                                                                                                                                                // all comparers are the same; this is faster
-                                                                                                                                                                if (AreEqualityComparersEqual(set1, set2)) {
-                                                                                                                                                                    if (set1.Count != set2.Count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                    // suffices to check subset
-                                                                                                                                                                    foreach (T item in set2) {
-                                                                                                                                                                        if (!set1.Contains(item)) {
-                                                                                                                                                                            return false;
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                                else {  // n^2 search because items are hashed according to their respective ECs
-                                                                                                                                                                    foreach (T set2Item in set2) {
-                                                                                                                                                                        bool found = false;
-                                                                                                                                                                        foreach (T set1Item in set1) {
-                                                                                                                                                                            if (comparer.Equals(set2Item, set1Item)) {
-                                                                                                                                                                                found = true;
-                                                                                                                                                                                break;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                        if (!found) {
-                                                                                                                                                                            return false;
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            /// <summary>
-                                                                                                                                                            /// Checks if equality comparers are equal. This is used for algorithms that can
-                                                                                                                                                            /// speed up if it knows the other item has unique elements. I.e. if they're using 
-                                                                                                                                                            /// different equality comparers, then uniqueness assumption between sets break.
-                                                                                                                                                            /// </summary>
-                                                                                                                                                            /// <param name="set1"></param>
-                                                                                                                                                            /// <param name="set2"></param>
-                                                                                                                                                            /// <returns></returns>
-                                                                                                                                                            private static bool AreEqualityComparersEqual(RetrievableEntryHashSet<T> set1, RetrievableEntryHashSet<T> set2) {
-                                                                                                                                                                return set1.Comparer.Equals(set2.Comparer);
-        }
-#endif
-
         private int InternalGetHashCode(string item, int index, int length)
         {
             // No need to check for null 'item' as we own all comparers
diff --git a/src/Build/Collections/RetrievableEntryHashSet/Originals/BitHelper.cs b/src/Build/Collections/RetrievableEntryHashSet/Originals/BitHelper.cs
deleted file mode 100644
index bfd9c45d47c..00000000000
--- a/src/Build/Collections/RetrievableEntryHashSet/Originals/BitHelper.cs
+++ /dev/null
@@ -1,140 +0,0 @@
-Ôªøusing System;
-using System.Collections;
-using System.Text;
-
-#nullable disable
-
-namespace System.Collections.Generic {
-
-    /// <summary>
-    /// ABOUT:
-    /// Helps with operations that rely on bit marking to indicate whether an item in the 
-    /// collection should be added, removed, visited already, etc. 
-    /// 
-    /// BitHelper doesn't allocate the array; you must pass in an array or ints allocated on the 
-    /// stack or heap. ToIntArrayLength() tells you the int array size you must allocate. 
-    /// 
-    /// USAGE:
-    /// Suppose you need to represent a bit array of length (i.e. logical bit array length)
-    /// BIT_ARRAY_LENGTH. Then this is the suggested way to instantiate BitHelper:
-    /// ***************************************************************************
-    /// int intArrayLength = BitHelper.ToIntArrayLength(BIT_ARRAY_LENGTH);
-    /// BitHelper bitHelper;
-    /// if (intArrayLength less than stack alloc threshold)
-    ///     int* m_arrayPtr = stackalloc int[intArrayLength];
-    ///     bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
-    /// else
-    ///     int[] m_arrayPtr = new int[intArrayLength];
-    ///     bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
-    /// ***************************************************************************
-    /// 
-    /// IMPORTANT:
-    /// The second ctor args, length, should be specified as the length of the int array, not
-    /// the logical bit array. Because length is used for bounds checking into the int array,
-    /// it's especially important to get this correct for the stackalloc version. See the code 
-    /// samples above; this is the value gotten from ToIntArrayLength(). 
-    /// 
-    /// The length ctor argument is the only exception; for other methods -- MarkBit and 
-    /// IsMarked -- pass in values as indices into the logical bit array, and it will be mapped
-    /// to the position within the array of ints.
-    /// 
-    /// FUTURE OPTIMIZATIONS:
-    /// A method such as FindFirstMarked/Unmarked Bit would be useful for callers that operate 
-    /// on a bit array and then need to loop over it. In particular, if it avoided visiting 
-    /// every bit, it would allow good perf improvements when the bit array is sparse.
-    /// </summary>
-    unsafe internal class BitHelper {   // should not be serialized
-
-        private const byte MarkedBitFlag = 1;
-        private const byte IntSize = 32;
-
-        // m_length of underlying int array (not logical bit array)
-        private int m_length;
-        
-        // ptr to stack alloc'd array of ints
-        [System.Security.SecurityCritical]
-        private int* m_arrayPtr;
-
-        // array of ints
-        private int[] m_array;
-
-        // whether to operate on stack alloc'd or heap alloc'd array 
-        private bool useStackAlloc;
-
-        /// <summary>
-        /// Instantiates a BitHelper with a heap alloc'd array of ints
-        /// </summary>
-        /// <param name="bitArray">int array to hold bits</param>
-        /// <param name="length">length of int array</param>
-        [System.Security.SecurityCritical]
-        internal BitHelper(int* bitArrayPtr, int length) {
-            this.m_arrayPtr = bitArrayPtr;
-            this.m_length = length;
-            useStackAlloc = true;
-        }
-
-        /// <summary>
-        /// Instantiates a BitHelper with a heap alloc'd array of ints
-        /// </summary>
-        /// <param name="bitArray">int array to hold bits</param>
-        /// <param name="length">length of int array</param>
-        internal BitHelper(int[] bitArray, int length) {
-            this.m_array = bitArray;
-            this.m_length = length;
-        }
-
-        /// <summary>
-        /// Mark bit at specified position
-        /// </summary>
-        /// <param name="bitPosition"></param>
-        [System.Security.SecuritySafeCritical]
-        internal unsafe void MarkBit(int bitPosition) {
-            if (useStackAlloc) {
-                int bitArrayIndex = bitPosition / IntSize;
-                if (bitArrayIndex < m_length && bitArrayIndex >= 0) {
-                    m_arrayPtr[bitArrayIndex] |= (MarkedBitFlag << (bitPosition % IntSize));
-                }
-            }
-            else {
-                int bitArrayIndex = bitPosition / IntSize;
-                if (bitArrayIndex < m_length && bitArrayIndex >= 0) {
-                    m_array[bitArrayIndex] |= (MarkedBitFlag << (bitPosition % IntSize));
-                }
-            }
-        }
-
-        /// <summary>
-        /// Is bit at specified position marked?
-        /// </summary>
-        /// <param name="bitPosition"></param>
-        /// <returns></returns>
-        [System.Security.SecuritySafeCritical]
-        internal unsafe bool IsMarked(int bitPosition) {
-            if (useStackAlloc) {
-                int bitArrayIndex = bitPosition / IntSize;
-                if (bitArrayIndex < m_length && bitArrayIndex >= 0) {
-                    return ((m_arrayPtr[bitArrayIndex] & (MarkedBitFlag << (bitPosition % IntSize))) != 0);
-                }
-                return false;
-            }
-            else {
-                int bitArrayIndex = bitPosition / IntSize;
-                if (bitArrayIndex < m_length && bitArrayIndex >= 0) {
-                    return ((m_array[bitArrayIndex] & (MarkedBitFlag << (bitPosition % IntSize))) != 0);
-                }
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// How many ints must be allocated to represent n bits. Returns (n+31)/32, but 
-        /// avoids overflow
-        /// </summary>
-        /// <param name="n"></param>
-        /// <returns></returns>
-        internal static int ToIntArrayLength(int n) {
-            return n > 0 ? ((n - 1) / IntSize + 1) : 0;
-        }
-
-    }
-}
diff --git a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashHelpers.cs b/src/Build/Collections/RetrievableEntryHashSet/Originals/HashHelpers.cs
deleted file mode 100644
index b637621ae4a..00000000000
--- a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashHelpers.cs
+++ /dev/null
@@ -1,88 +0,0 @@
-Ôªøusing System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-#if !SILVERLIGHT
-using System.Runtime.ConstrainedExecution;
-#endif
-using System.Text;
-
-#nullable disable
-
-namespace System.Collections.Generic {
-
-    /// <summary>
-    /// Duplicated because internal to mscorlib
-    /// </summary>
-    internal static class HashHelpers {
-        // Table of prime numbers to use as hash table sizes. 
-        // The entry used for capacity is the smallest prime number in this array
-        // that is larger than twice the previous capacity. 
-
-        internal static readonly int[] primes = {
-            3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919,
-            1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591,
-            17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363, 156437,
-            187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403, 968897, 1162687, 1395263,
-            1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559, 5999471, 7199369};
-
-#if !SILVERLIGHT
-        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
-#endif
-        internal static bool IsPrime(int candidate) {
-            if ((candidate & 1) != 0) {
-                int limit = (int)Math.Sqrt(candidate);
-                for (int divisor = 3; divisor <= limit; divisor += 2) {
-                    if ((candidate % divisor) == 0) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-            return (candidate == 2);
-        }
-
-#if !SILVERLIGHT
-        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
-#endif
-        internal static int GetPrime(int min) {
-            Debug.Assert(min >= 0, "min less than zero; handle overflow checking before calling HashHelpers");
-
-            for (int i = 0; i < primes.Length; i++) {
-                int prime = primes[i];
-                if (prime >= min) {
-                    return prime;
-                }
-            }
-
-            // Outside of our predefined table. Compute the hard way. 
-            for (int i = (min | 1); i < Int32.MaxValue; i += 2) {
-                if (IsPrime(i)) {
-                    return i;
-                }
-            }
-            return min;
-        }
-
-        internal static int GetMinPrime() {
-            return primes[0];
-        }
-
-        // Returns size of hashtable to grow to.
-        internal static int ExpandPrime(int oldSize)
-        {
-            int newSize = 2 * oldSize;
-
-            // Allow the hashtables to grow to maximum possible size (~2G elements) before encoutering capacity overflow.
-            // Note that this check works even when _items.Length overflowed thanks to the (uint) cast
-            if ((uint)newSize > MaxPrimeArrayLength)
-                return MaxPrimeArrayLength;
-
-            return GetPrime(newSize);
-        }
-
-        // This is the maximum prime smaller than Array.MaxArrayLength
-        internal const int MaxPrimeArrayLength = 0x7FEFFFFD;
-    }
-
-}
diff --git a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSet.cs
deleted file mode 100644
index 41c90e2f090..00000000000
--- a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSet.cs
+++ /dev/null
@@ -1,1453 +0,0 @@
-Ôªøusing System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.Contracts;
-using System.Security.Permissions;
-using System.Text;
-using System.Diagnostics.CodeAnalysis;
-using System.Security;
-
-#nullable disable
-
-namespace System.Collections.Generic {
-
-    /// <summary>
-    /// Implementation notes:
-    /// This uses an array-based implementation similar to Dictionary<T>, using a buckets array
-    /// to map hash values to the Slots array. Items in the Slots array that hash to the same value
-    /// are chained together through the "next" indices. 
-    /// 
-    /// The capacity is always prime; so during resizing, the capacity is chosen as the next prime
-    /// greater than double the last capacity. 
-    /// 
-    /// The underlying data structures are lazily initialized. Because of the observation that, 
-    /// in practice, hashtables tend to contain only a few elements, the initial capacity is
-    /// set very small (3 elements) unless the ctor with a collection is used.
-    /// 
-    /// The +/- 1 modifications in methods that add, check for containment, etc allow us to 
-    /// distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to 
-    /// reset each bucket to -1 when resizing. See Contains, for example.
-    /// 
-    /// Set methods such as UnionWith, IntersectWith, ExceptWith, and SymmetricExceptWith modify
-    /// this set.
-    /// 
-    /// Some operations can perform faster if we can assume "other" contains unique elements
-    /// according to this equality comparer. The only times this is efficient to check is if
-    /// other is a hashset. Note that checking that it's a hashset alone doesn't suffice; we
-    /// also have to check that the hashset is using the same equality comparer. If other 
-    /// has a different equality comparer, it will have unique elements according to its own
-    /// equality comparer, but not necessarily according to ours. Therefore, to go these 
-    /// optimized routes we check that other is a hashset using the same equality comparer.
-    /// 
-    /// A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for 
-    /// special empty set checks.)
-    /// 
-    /// A couple of methods have a special case if other is this (e.g. SymmetricExceptWith). 
-    /// If we didn't have these checks, we could be iterating over the set and modifying at
-    /// the same time. 
-    /// </summary>
-    /// <typeparam name="T"></typeparam>
-    [DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView<>))]
-    [DebuggerDisplay("Count = {Count}")]
-    [SuppressMessage("Microsoft.Naming","CA1710:IdentifiersShouldHaveCorrectSuffix", Justification="By design")]
-    [Serializable()]
-    [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
-    public class HashSet<T> : ICollection<T>, ISerializable, IDeserializationCallback, ISet<T>
-    {
-
-        // store lower 31 bits of hash code
-        private const int Lower31BitMask = 0x7FFFFFFF;
-        // cutoff point, above which we won't do stackallocs. This corresponds to 100 integers.
-        private const int StackAllocThreshold = 100;
-        // when constructing a hashset from an existing collection, it may contain duplicates, 
-        // so this is used as the max acceptable excess ratio of capacity to count. Note that
-        // this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
-        // a lot of adds followed by removes. Users must explicitly shrink by calling TrimExcess.
-        // This is set to 3 because capacity is acceptable as 2x rounded up to nearest prime.
-        private const int ShrinkThreshold = 3;
-
-#if !SILVERLIGHT
-        // constants for serialization
-        private const String CapacityName = "Capacity";
-        private const String ElementsName = "Elements";
-        private const String ComparerName = "Comparer";
-        private const String VersionName = "Version";
-#endif
-
-        private int[] m_buckets;
-        private Slot[] m_slots;
-        private int m_count;
-        private int m_lastIndex;
-        private int m_freeList;
-        private IEqualityComparer<T> m_comparer;
-        private int m_version;
-
-#if !SILVERLIGHT
-        // temporary variable needed during deserialization
-        private SerializationInfo m_siInfo;
-#endif
-
-        #region Constructors
-
-        public HashSet()
-            : this(EqualityComparer<T>.Default) { }
-
-        public HashSet(IEqualityComparer<T> comparer) {
-            if (comparer == null) {
-                comparer = EqualityComparer<T>.Default;
-            }
-
-            this.m_comparer = comparer;
-            m_lastIndex = 0;
-            m_count = 0;
-            m_freeList = -1;
-            m_version = 0;
-        }
-
-        public HashSet(IEnumerable<T> collection)
-            : this(collection, EqualityComparer<T>.Default) { }
-
-        /// <summary>
-        /// Implementation Notes:
-        /// Since resizes are relatively expensive (require rehashing), this attempts to minimize 
-        /// the need to resize by setting the initial capacity based on size of collection. 
-        /// </summary>
-        /// <param name="collection"></param>
-        /// <param name="comparer"></param>
-        public HashSet(IEnumerable<T> collection, IEqualityComparer<T> comparer)
-            : this(comparer) {
-            if (collection == null) {
-                throw new ArgumentNullException("collection");
-            }
-            Contract.EndContractBlock();
-
-            // to avoid excess resizes, first set size based on collection's count. Collection
-            // may contain duplicates, so call TrimExcess if resulting hashset is larger than
-            // threshold
-            int suggestedCapacity = 0;
-            ICollection<T> coll = collection as ICollection<T>;
-            if (coll != null) {
-                suggestedCapacity = coll.Count;
-            }
-            Initialize(suggestedCapacity);
-
-            this.UnionWith(collection);
-            if ((m_count == 0 && m_slots.Length > HashHelpers.GetMinPrime()) ||
-                (m_count > 0 && m_slots.Length / m_count > ShrinkThreshold)) {
-                TrimExcess();
-            }
-        }
-
-#if !SILVERLIGHT
-        protected HashSet(SerializationInfo info, StreamingContext context) {
-            // We can't do anything with the keys and values until the entire graph has been 
-            // deserialized and we have a reasonable estimate that GetHashCode is not going to 
-            // fail.  For the time being, we'll just cache this.  The graph is not valid until 
-            // OnDeserialization has been called.
-            m_siInfo = info;
-        }
-#endif
-
-        #endregion
-
-        #region ICollection<T> methods
-
-        /// <summary>
-        /// Add item to this hashset. This is the explicit implementation of the ICollection<T>
-        /// interface. The other Add method returns bool indicating whether item was added.
-        /// </summary>
-        /// <param name="item">item to add</param>
-        void ICollection<T>.Add(T item) {
-            AddIfNotPresent(item);
-        }
-
-        /// <summary>
-        /// Remove all items from this set. This clears the elements but not the underlying 
-        /// buckets and slots array. Follow this call by TrimExcess to release these.
-        /// </summary>
-        public void Clear() {
-            if (m_lastIndex > 0) {
-                Debug.Assert(m_buckets != null, "m_buckets was null but m_lastIndex > 0");
-
-                // clear the elements so that the gc can reclaim the references.
-                // clear only up to m_lastIndex for m_slots 
-                Array.Clear(m_slots, 0, m_lastIndex);
-                Array.Clear(m_buckets, 0, m_buckets.Length);
-                m_lastIndex = 0;
-                m_count = 0;
-                m_freeList = -1;
-            }
-            m_version++;
-        }
-
-        /// <summary>
-        /// Checks if this hashset contains the item
-        /// </summary>
-        /// <param name="item">item to check for containment</param>
-        /// <returns>true if item contained; false if not</returns>
-        public bool Contains(T item) {
-            if (m_buckets != null) {
-                int hashCode = InternalGetHashCode(item);
-                // see note at "HashSet" level describing why "- 1" appears in for loop
-                for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                    if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, item)) {
-                        return true;
-                    }
-                }
-            }
-            // either m_buckets is null or wasn't found
-            return false;
-        }
-
-        /// <summary>
-        /// Copy items in this hashset to array, starting at arrayIndex
-        /// </summary>
-        /// <param name="array">array to add items to</param>
-        /// <param name="arrayIndex">index to start at</param>
-        public void CopyTo(T[] array, int arrayIndex) {
-            CopyTo(array, arrayIndex, m_count);
-        }
-
-        /// <summary>
-        /// Remove item from this hashset
-        /// </summary>
-        /// <param name="item">item to remove</param>
-        /// <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
-        public bool Remove(T item) {
-            if (m_buckets != null) {
-                int hashCode = InternalGetHashCode(item);
-                int bucket = hashCode % m_buckets.Length;
-                int last = -1;
-                for (int i = m_buckets[bucket] - 1; i >= 0; last = i, i = m_slots[i].next) {
-                    if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, item)) {
-                        if (last < 0) {
-                            // first iteration; update buckets
-                            m_buckets[bucket] = m_slots[i].next + 1;
-                        }
-                        else {
-                            // subsequent iterations; update 'next' pointers
-                            m_slots[last].next = m_slots[i].next;
-                        }
-                        m_slots[i].hashCode = -1;
-                        m_slots[i].value = default(T);
-                        m_slots[i].next = m_freeList;
-
-                        m_count--;
-                        m_version++;
-                        if (m_count == 0) {
-                            m_lastIndex = 0;
-                            m_freeList = -1;
-                        }
-                        else {
-                            m_freeList = i;
-                        }
-                        return true;
-                    }
-                }
-            }
-            // either m_buckets is null or wasn't found
-            return false;
-        }
-
-        /// <summary>
-        /// Number of elements in this hashset
-        /// </summary>
-        public int Count {
-            get { return m_count; }
-        }
-
-        /// <summary>
-        /// Whether this is readonly
-        /// </summary>
-        bool ICollection<T>.IsReadOnly {
-            get { return false; }
-        }
-
-        #endregion
-
-        #region IEnumerable methods
-
-        public Enumerator GetEnumerator() {
-            return new Enumerator(this);
-        }
-
-        IEnumerator<T> IEnumerable<T>.GetEnumerator() {
-            return new Enumerator(this);
-        }
-
-        IEnumerator IEnumerable.GetEnumerator() {
-            return new Enumerator(this);
-        }
-
-        #endregion
-
-        #region ISerializable methods
-
-#if !SILVERLIGHT
-        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
-        [SecurityCritical]
-        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
-            if (info == null) {
-                throw new ArgumentNullException("info");
-            }
-
-            // need to serialize version to avoid problems with serializing while enumerating
-            info.AddValue(VersionName, m_version);
-            info.AddValue(ComparerName, m_comparer, typeof(IEqualityComparer<T>));
-            info.AddValue(CapacityName, m_buckets == null ? 0 : m_buckets.Length);
-            if (m_buckets != null) {
-                T[] array = new T[m_count];
-                CopyTo(array);
-                info.AddValue(ElementsName, array, typeof(T[]));
-            }
-        }
-#endif
-        #endregion
-
-        #region IDeserializationCallback methods
-
-#if !SILVERLIGHT
-        public virtual void OnDeserialization(Object sender) {
-
-            if (m_siInfo == null) {
-                // It might be necessary to call OnDeserialization from a container if the 
-                // container object also implements OnDeserialization. However, remoting will 
-                // call OnDeserialization again. We can return immediately if this function is 
-                // called twice. Note we set m_siInfo to null at the end of this method.
-                return;
-            }
-
-            int capacity = m_siInfo.GetInt32(CapacityName);
-            m_comparer = (IEqualityComparer<T>)m_siInfo.GetValue(ComparerName, typeof(IEqualityComparer<T>));
-            m_freeList = -1;
-
-            if (capacity != 0) {
-                m_buckets = new int[capacity];
-                m_slots = new Slot[capacity];
-
-                T[] array = (T[])m_siInfo.GetValue(ElementsName, typeof(T[]));
-
-                if (array == null) {
-                    throw new SerializationException(SR.GetString(SR.Serialization_MissingKeys));
-                }
-
-                // there are no resizes here because we already set capacity above
-                for (int i = 0; i < array.Length; i++) {
-                    AddIfNotPresent(array[i]);
-                }
-            }
-            else {
-                m_buckets = null;
-            }
-
-            m_version = m_siInfo.GetInt32(VersionName);
-            m_siInfo = null;
-        }
-#endif
-
-        #endregion
-
-        #region HashSet methods
-
-        /// <summary>
-        /// Add item to this HashSet. Returns bool indicating whether item was added (won't be 
-        /// added if already present)
-        /// </summary>
-        /// <param name="item"></param>
-        /// <returns>true if added, false if already present</returns>
-        public bool Add(T item) {
-            return AddIfNotPresent(item);
-        }
-
-        /// <summary>
-        /// Take the union of this HashSet with other. Modifies this set.
-        /// 
-        /// Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
-        /// multiple resizes ended up not being useful in practice; quickly gets to the 
-        /// point where it's a wasteful check.
-        /// </summary>
-        /// <param name="other">enumerable with items to add</param>
-        public void UnionWith(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            foreach (T item in other) {
-                AddIfNotPresent(item);
-            }
-        }
-
-        /// <summary>
-        /// Takes the intersection of this set with other. Modifies this set.
-        /// 
-        /// Implementation Notes: 
-        /// We get better perf if other is a hashset using same equality comparer, because we 
-        /// get constant contains check in other. Resulting cost is O(n1) to iterate over this.
-        /// 
-        /// If we can't go above route, iterate over the other and mark intersection by checking
-        /// contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
-        /// 
-        /// Attempts to return early based on counts alone, using the property that the 
-        /// intersection of anything with the empty set is the empty set.
-        /// </summary>
-        /// <param name="other">enumerable with items to add </param>
-        public void IntersectWith(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // intersection of anything with empty set is empty set, so return if count is 0
-            if (m_count == 0) {
-                return;
-            }
-
-            // if other is empty, intersection is empty set; remove all elements and we're done
-            // can only figure this out if implements ICollection<T>. (IEnumerable<T> has no count)
-            ICollection<T> otherAsCollection = other as ICollection<T>;
-            if (otherAsCollection != null) {
-                if (otherAsCollection.Count == 0) {
-                    Clear();
-                    return;
-                }
-
-                HashSet<T> otherAsSet = other as HashSet<T>;
-                // faster if other is a hashset using same equality comparer; so check 
-                // that other is a hashset using the same equality comparer.
-                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                    IntersectWithHashSetWithSameEC(otherAsSet);
-                    return;
-                }
-            }
-
-            IntersectWithEnumerable(other);
-        }
-
-        /// <summary>
-        /// Remove items in other from this set. Modifies this set.
-        /// </summary>
-        /// <param name="other">enumerable with items to remove</param>
-        public void ExceptWith(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // this is already the enpty set; return
-            if (m_count == 0) {
-                return;
-            }
-
-            // special case if other is this; a set minus itself is the empty set
-            if (other == this) {
-                Clear();
-                return;
-            }
-
-            // remove every element in other from this
-            foreach (T element in other) {
-                Remove(element);
-            }
-        }
-
-        /// <summary>
-        /// Takes symmetric difference (XOR) with other and this set. Modifies this set.
-        /// </summary>
-        /// <param name="other">enumerable with items to XOR</param>
-        public void SymmetricExceptWith(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // if set is empty, then symmetric difference is other
-            if (m_count == 0) {
-                UnionWith(other);
-                return;
-            }
-
-            // special case this; the symmetric difference of a set with itself is the empty set
-            if (other == this) {
-                Clear();
-                return;
-            }
-
-            HashSet<T> otherAsSet = other as HashSet<T>;
-            // If other is a HashSet, it has unique elements according to its equality comparer,
-            // but if they're using different equality comparers, then assumption of uniqueness
-            // will fail. So first check if other is a hashset using the same equality comparer;
-            // symmetric except is a lot faster and avoids bit array allocations if we can assume
-            // uniqueness
-            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                SymmetricExceptWithUniqueHashSet(otherAsSet);
-            }
-            else {
-                SymmetricExceptWithEnumerable(other);
-            }
-        }
-
-        /// <summary>
-        /// Checks if this is a subset of other.
-        /// 
-        /// Implementation Notes:
-        /// The following properties are used up-front to avoid element-wise checks:
-        /// 1. If this is the empty set, then it's a subset of anything, including the empty set
-        /// 2. If other has unique elements according to this equality comparer, and this has more
-        /// elements than other, then it can't be a subset.
-        /// 
-        /// Furthermore, if other is a hashset using the same equality comparer, we can use a 
-        /// faster element-wise check.
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns>true if this is a subset of other; false if not</returns>
-        public bool IsSubsetOf(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // The empty set is a subset of any set
-            if (m_count == 0) {
-                return true;
-            }
-
-            HashSet<T> otherAsSet = other as HashSet<T>;
-            // faster if other has unique elements according to this equality comparer; so check 
-            // that other is a hashset using the same equality comparer.
-            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                // if this has more elements then it can't be a subset
-                if (m_count > otherAsSet.Count) {
-                    return false;
-                }
-
-                // already checked that we're using same equality comparer. simply check that 
-                // each element in this is contained in other.
-                return IsSubsetOfHashSetWithSameEC(otherAsSet);
-            }
-            else {
-                ElementCount result = CheckUniqueAndUnfoundElements(other, false);
-                return (result.uniqueCount == m_count && result.unfoundCount >= 0);
-            }
-        }
-
-        /// <summary>
-        /// Checks if this is a proper subset of other (i.e. strictly contained in)
-        /// 
-        /// Implementation Notes:
-        /// The following properties are used up-front to avoid element-wise checks:
-        /// 1. If this is the empty set, then it's a proper subset of a set that contains at least
-        /// one element, but it's not a proper subset of the empty set.
-        /// 2. If other has unique elements according to this equality comparer, and this has >=
-        /// the number of elements in other, then this can't be a proper subset.
-        /// 
-        /// Furthermore, if other is a hashset using the same equality comparer, we can use a 
-        /// faster element-wise check.
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns>true if this is a proper subset of other; false if not</returns>
-        public bool IsProperSubsetOf(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            ICollection<T> otherAsCollection = other as ICollection<T>;
-            if (otherAsCollection != null) {
-                // the empty set is a proper subset of anything but the empty set
-                if (m_count == 0) {
-                    return otherAsCollection.Count > 0;
-                }
-                HashSet<T> otherAsSet = other as HashSet<T>;
-                // faster if other is a hashset (and we're using same equality comparer)
-                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                    if (m_count >= otherAsSet.Count) {
-                        return false;
-                    }
-                    // this has strictly less than number of items in other, so the following
-                    // check suffices for proper subset.
-                    return IsSubsetOfHashSetWithSameEC(otherAsSet);
-                }
-            }
-
-            ElementCount result = CheckUniqueAndUnfoundElements(other, false);
-            return (result.uniqueCount == m_count && result.unfoundCount > 0);
-
-        }
-
-        /// <summary>
-        /// Checks if this is a superset of other
-        /// 
-        /// Implementation Notes:
-        /// The following properties are used up-front to avoid element-wise checks:
-        /// 1. If other has no elements (it's the empty set), then this is a superset, even if this
-        /// is also the empty set.
-        /// 2. If other has unique elements according to this equality comparer, and this has less 
-        /// than the number of elements in other, then this can't be a superset
-        /// 
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns>true if this is a superset of other; false if not</returns>
-        public bool IsSupersetOf(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // try to fall out early based on counts
-            ICollection<T> otherAsCollection = other as ICollection<T>;
-            if (otherAsCollection != null) {
-                // if other is the empty set then this is a superset
-                if (otherAsCollection.Count == 0) {
-                    return true;
-                }
-                HashSet<T> otherAsSet = other as HashSet<T>;
-                // try to compare based on counts alone if other is a hashset with
-                // same equality comparer
-                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                    if (otherAsSet.Count > m_count) {
-                        return false;
-                    }
-                }
-            }
-
-            return ContainsAllElements(other);
-        }
-
-        /// <summary>
-        /// Checks if this is a proper superset of other (i.e. other strictly contained in this)
-        /// 
-        /// Implementation Notes: 
-        /// This is slightly more complicated than above because we have to keep track if there
-        /// was at least one element not contained in other.
-        /// 
-        /// The following properties are used up-front to avoid element-wise checks:
-        /// 1. If this is the empty set, then it can't be a proper superset of any set, even if 
-        /// other is the empty set.
-        /// 2. If other is an empty set and this contains at least 1 element, then this is a proper
-        /// superset.
-        /// 3. If other has unique elements according to this equality comparer, and other's count
-        /// is greater than or equal to this count, then this can't be a proper superset
-        /// 
-        /// Furthermore, if other has unique elements according to this equality comparer, we can
-        /// use a faster element-wise check.
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns>true if this is a proper superset of other; false if not</returns>
-        public bool IsProperSupersetOf(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // the empty set isn't a proper superset of any set.
-            if (m_count == 0) {
-                return false;
-            }
-
-            ICollection<T> otherAsCollection = other as ICollection<T>;
-            if (otherAsCollection != null) {
-                // if other is the empty set then this is a superset
-                if (otherAsCollection.Count == 0) {
-                    // note that this has at least one element, based on above check
-                    return true;
-                }
-                HashSet<T> otherAsSet = other as HashSet<T>;
-                // faster if other is a hashset with the same equality comparer
-                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                    if (otherAsSet.Count >= m_count) {
-                        return false;
-                    }
-                    // now perform element check
-                    return ContainsAllElements(otherAsSet);
-                }
-            }
-            // couldn't fall out in the above cases; do it the long way
-            ElementCount result = CheckUniqueAndUnfoundElements(other, true);
-            return (result.uniqueCount < m_count && result.unfoundCount == 0);
-
-        }
-
-        /// <summary>
-        /// Checks if this set overlaps other (i.e. they share at least one item)
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns>true if these have at least one common element; false if disjoint</returns>
-        public bool Overlaps(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            if (m_count == 0) {
-                return false;
-            }
-
-            foreach (T element in other) {
-                if (Contains(element)) {
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        /// <summary>
-        /// Checks if this and other contain the same elements. This is set equality: 
-        /// duplicates and order are ignored
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns></returns>
-        public bool SetEquals(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            HashSet<T> otherAsSet = other as HashSet<T>;
-            // faster if other is a hashset and we're using same equality comparer
-            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                // attempt to return early: since both contain unique elements, if they have 
-                // different counts, then they can't be equal
-                if (m_count != otherAsSet.Count) {
-                    return false;
-                }
-
-                // already confirmed that the sets have the same number of distinct elements, so if
-                // one is a superset of the other then they must be equal
-                return ContainsAllElements(otherAsSet);
-            }
-            else {
-                ICollection<T> otherAsCollection = other as ICollection<T>;
-                if (otherAsCollection != null) {
-                    // if this count is 0 but other contains at least one element, they can't be equal
-                    if (m_count == 0 && otherAsCollection.Count > 0) {
-                        return false;
-                    }
-                }
-                ElementCount result = CheckUniqueAndUnfoundElements(other, true);
-                return (result.uniqueCount == m_count && result.unfoundCount == 0);
-            }
-        }
-
-        public void CopyTo(T[] array) { CopyTo(array, 0, m_count); }
-
-        public void CopyTo(T[] array, int arrayIndex, int count) {
-            if (array == null) {
-                throw new ArgumentNullException("array");
-            }
-            Contract.EndContractBlock();
-
-            // check array index valid index into array
-            if (arrayIndex < 0) {
-                throw new ArgumentOutOfRangeException("arrayIndex", SR.GetString(SR.ArgumentOutOfRange_NeedNonNegNum));
-            }
-
-            // also throw if count less than 0
-            if (count < 0) {
-                throw new ArgumentOutOfRangeException("count", SR.GetString(SR.ArgumentOutOfRange_NeedNonNegNum));
-            }
-
-            // will array, starting at arrayIndex, be able to hold elements? Note: not
-            // checking arrayIndex >= array.Length (consistency with list of allowing
-            // count of 0; subsequent check takes care of the rest)
-            if (arrayIndex > array.Length || count > array.Length - arrayIndex) {
-                throw new ArgumentException(SR.GetString(SR.Arg_ArrayPlusOffTooSmall));
-            }
-
-            int numCopied = 0;
-            for (int i = 0; i < m_lastIndex && numCopied < count; i++) {
-                if (m_slots[i].hashCode >= 0) {
-                    array[arrayIndex + numCopied] = m_slots[i].value;
-                    numCopied++;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Remove elements that match specified predicate. Returns the number of elements removed
-        /// </summary>
-        /// <param name="match"></param>
-        /// <returns></returns>
-        public int RemoveWhere(Predicate<T> match) {
-            if (match == null) {
-                throw new ArgumentNullException("match");
-            }
-            Contract.EndContractBlock();
-
-            int numRemoved = 0;
-            for (int i = 0; i < m_lastIndex; i++) {
-                if (m_slots[i].hashCode >= 0) {
-                    // cache value in case delegate removes it
-                    T value = m_slots[i].value;
-                    if (match(value)) {
-                        // check again that remove actually removed it
-                        if (Remove(value)) {
-                            numRemoved++;
-                        }
-                    }
-                }
-            }
-            return numRemoved;
-        }
-
-        /// <summary>
-        /// Gets the IEqualityComparer that is used to determine equality of keys for 
-        /// the HashSet.
-        /// </summary>
-        public IEqualityComparer<T> Comparer {
-            get {
-                return m_comparer;
-            }
-        }
-
-        /// <summary>
-        /// Sets the capacity of this list to the size of the list (rounded up to nearest prime),
-        /// unless count is 0, in which case we release references.
-        /// 
-        /// This method can be used to minimize a list's memory overhead once it is known that no
-        /// new elements will be added to the list. To completely clear a list and release all 
-        /// memory referenced by the list, execute the following statements:
-        /// 
-        /// list.Clear();
-        /// list.TrimExcess(); 
-        /// </summary>
-        public void TrimExcess() {
-            Debug.Assert(m_count >= 0, "m_count is negative");
-
-            if (m_count == 0) {
-                // if count is zero, clear references
-                m_buckets = null;
-                m_slots = null;
-                m_version++;
-            }
-            else {
-                Debug.Assert(m_buckets != null, "m_buckets was null but m_count > 0");
-
-                // similar to IncreaseCapacity but moves down elements in case add/remove/etc
-                // caused fragmentation
-                int newSize = HashHelpers.GetPrime(m_count);
-                Slot[] newSlots = new Slot[newSize];
-                int[] newBuckets = new int[newSize];
-
-                // move down slots and rehash at the same time. newIndex keeps track of current 
-                // position in newSlots array
-                int newIndex = 0;
-                for (int i = 0; i < m_lastIndex; i++) {
-                    if (m_slots[i].hashCode >= 0) {
-                        newSlots[newIndex] = m_slots[i];
-
-                        // rehash
-                        int bucket = newSlots[newIndex].hashCode % newSize;
-                        newSlots[newIndex].next = newBuckets[bucket] - 1;
-                        newBuckets[bucket] = newIndex + 1;
-
-                        newIndex++;
-                    }
-                }
-
-                Debug.Assert(newSlots.Length <= m_slots.Length, "capacity increased after TrimExcess");
-
-                m_lastIndex = newIndex;
-                m_slots = newSlots;
-                m_buckets = newBuckets;
-                m_freeList = -1;
-            }
-        }
-
-#if !SILVERLIGHT || FEATURE_NETCORE
-        /// <summary>
-        /// Used for deep equality of HashSet testing
-        /// </summary>
-        /// <returns></returns>
-        public static IEqualityComparer<HashSet<T>> CreateSetComparer() {
-            return new HashSetEqualityComparer<T>();
-        }
-#endif
-
-        #endregion
-
-        #region Helper methods
-
-        /// <summary>
-        /// Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
-        /// greater than or equal to capacity.
-        /// </summary>
-        /// <param name="capacity"></param>
-        private void Initialize(int capacity) {
-            Debug.Assert(m_buckets == null, "Initialize was called but m_buckets was non-null");
-
-            int size = HashHelpers.GetPrime(capacity);
-
-            m_buckets = new int[size];
-            m_slots = new Slot[size];
-        }
-
-        /// <summary>
-        /// Expand to new capacity. New capacity is next prime greater than or equal to suggested 
-        /// size. This is called when the underlying array is filled. This performs no 
-        /// defragmentation, allowing faster execution; note that this is reasonable since 
-        /// AddIfNotPresent attempts to insert new elements in re-opened spots.
-        /// </summary>
-        /// <param name="sizeSuggestion"></param>
-        private void IncreaseCapacity() {
-            Debug.Assert(m_buckets != null, "IncreaseCapacity called on a set with no elements");
-
-            int newSize = HashHelpers.ExpandPrime(m_count);
-            if (newSize <= m_count) {
-                throw new ArgumentException(SR.GetString(SR.Arg_HSCapacityOverflow));
-            }
-
-            // Able to increase capacity; copy elements to larger array and rehash
-            Slot[] newSlots = new Slot[newSize];
-            if (m_slots != null) {
-                Array.Copy(m_slots, 0, newSlots, 0, m_lastIndex);
-            }
-
-            int[] newBuckets = new int[newSize];
-            for (int i = 0; i < m_lastIndex; i++) {
-                int bucket = newSlots[i].hashCode % newSize;
-                newSlots[i].next = newBuckets[bucket] - 1;
-                newBuckets[bucket] = i + 1;
-            }
-            m_slots = newSlots;
-            m_buckets = newBuckets;
-
-        }
-
-        /// <summary>
-        /// Adds value to HashSet if not contained already
-        /// Returns true if added and false if already present
-        /// </summary>
-        /// <param name="value">value to find</param>
-        /// <returns></returns>
-        private bool AddIfNotPresent(T value) {
-            if (m_buckets == null) {
-                Initialize(0);
-            }
-
-            int hashCode = InternalGetHashCode(value);
-            int bucket = hashCode % m_buckets.Length;
-            for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, value)) {
-                    return false;
-                }
-            }
-            int index;
-            if (m_freeList >= 0) {
-                index = m_freeList;
-                m_freeList = m_slots[index].next;
-            }
-            else {
-                if (m_lastIndex == m_slots.Length) {
-                    IncreaseCapacity();
-                    // this will change during resize
-                    bucket = hashCode % m_buckets.Length;
-                }
-                index = m_lastIndex;
-                m_lastIndex++;
-            }
-            m_slots[index].hashCode = hashCode;
-            m_slots[index].value = value;
-            m_slots[index].next = m_buckets[bucket] - 1;
-            m_buckets[bucket] = index + 1;
-            m_count++;
-            m_version++;
-            return true;
-        }
-
-        /// <summary>
-        /// Checks if this contains of other's elements. Iterates over other's elements and 
-        /// returns false as soon as it finds an element in other that's not in this.
-        /// Used by SupersetOf, ProperSupersetOf, and SetEquals.
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns></returns>
-        private bool ContainsAllElements(IEnumerable<T> other) {
-            foreach (T element in other) {
-                if (!Contains(element)) {
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        /// <summary>
-        /// Implementation Notes:
-        /// If other is a hashset and is using same equality comparer, then checking subset is 
-        /// faster. Simply check that each element in this is in other.
-        /// 
-        /// Note: if other doesn't use same equality comparer, then Contains check is invalid,
-        /// which is why callers must take are of this.
-        /// 
-        /// If callers are concerned about whether this is a proper subset, they take care of that.
-        ///
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns></returns>
-        private bool IsSubsetOfHashSetWithSameEC(HashSet<T> other) {
-
-            foreach (T item in this) {
-                if (!other.Contains(item)) {
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        /// <summary>
-        /// If other is a hashset that uses same equality comparer, intersect is much faster 
-        /// because we can use other's Contains
-        /// </summary>
-        /// <param name="other"></param>
-        private void IntersectWithHashSetWithSameEC(HashSet<T> other) {
-            for (int i = 0; i < m_lastIndex; i++) {
-                if (m_slots[i].hashCode >= 0) {
-                    T item = m_slots[i].value;
-                    if (!other.Contains(item)) {
-                        Remove(item);
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Iterate over other. If contained in this, mark an element in bit array corresponding to
-        /// its position in m_slots. If anything is unmarked (in bit array), remove it.
-        /// 
-        /// This attempts to allocate on the stack, if below StackAllocThreshold.
-        /// </summary>
-        /// <param name="other"></param>
-        [System.Security.SecuritySafeCritical]
-        private unsafe void IntersectWithEnumerable(IEnumerable<T> other) {
-            Debug.Assert(m_buckets != null, "m_buckets shouldn't be null; callers should check first");
-
-            // keep track of current last index; don't want to move past the end of our bit array
-            // (could happen if another thread is modifying the collection)
-            int originalLastIndex = m_lastIndex;
-            int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-            BitHelper bitHelper;
-            if (intArrayLength <= StackAllocThreshold) {
-                int* bitArrayPtr = stackalloc int[intArrayLength];
-                bitHelper = new BitHelper(bitArrayPtr, intArrayLength);
-            }
-            else {
-                int[] bitArray = new int[intArrayLength];
-                bitHelper = new BitHelper(bitArray, intArrayLength);
-            }
-
-            // mark if contains: find index of in slots array and mark corresponding element in bit array
-            foreach (T item in other) {
-                int index = InternalIndexOf(item);
-                if (index >= 0) {
-                    bitHelper.MarkBit(index);
-                }
-            }
-
-            // if anything unmarked, remove it. Perf can be optimized here if BitHelper had a 
-            // FindFirstUnmarked method.
-            for (int i = 0; i < originalLastIndex; i++) {
-                if (m_slots[i].hashCode >= 0 && !bitHelper.IsMarked(i)) {
-                    Remove(m_slots[i].value);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Used internally by set operations which have to rely on bit array marking. This is like
-        /// Contains but returns index in slots array. 
-        /// </summary>
-        /// <param name="item"></param>
-        /// <returns></returns>
-        private int InternalIndexOf(T item) {
-            Debug.Assert(m_buckets != null, "m_buckets was null; callers should check first");
-
-            int hashCode = InternalGetHashCode(item);
-            for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                if ((m_slots[i].hashCode) == hashCode && m_comparer.Equals(m_slots[i].value, item)) {
-                    return i;
-                }
-            }
-            // wasn't found
-            return -1;
-        }
-
-        /// <summary>
-        /// if other is a set, we can assume it doesn't have duplicate elements, so use this
-        /// technique: if can't remove, then it wasn't present in this set, so add.
-        /// 
-        /// As with other methods, callers take care of ensuring that other is a hashset using the
-        /// same equality comparer.
-        /// </summary>
-        /// <param name="other"></param>
-        private void SymmetricExceptWithUniqueHashSet(HashSet<T> other) {
-            foreach (T item in other) {
-                if (!Remove(item)) {
-                    AddIfNotPresent(item);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Implementation notes:
-        /// 
-        /// Used for symmetric except when other isn't a HashSet. This is more tedious because 
-        /// other may contain duplicates. HashSet technique could fail in these situations:
-        /// 1. Other has a duplicate that's not in this: HashSet technique would add then 
-        /// remove it.
-        /// 2. Other has a duplicate that's in this: HashSet technique would remove then add it
-        /// back.
-        /// In general, its presence would be toggled each time it appears in other. 
-        /// 
-        /// This technique uses bit marking to indicate whether to add/remove the item. If already
-        /// present in collection, it will get marked for deletion. If added from other, it will
-        /// get marked as something not to remove.
-        ///
-        /// </summary>
-        /// <param name="other"></param>
-        [System.Security.SecuritySafeCritical]
-        private unsafe void SymmetricExceptWithEnumerable(IEnumerable<T> other) {
-            int originalLastIndex = m_lastIndex;
-            int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-            BitHelper itemsToRemove;
-            BitHelper itemsAddedFromOther;
-            if (intArrayLength <= StackAllocThreshold / 2) {
-                int* itemsToRemovePtr = stackalloc int[intArrayLength];
-                itemsToRemove = new BitHelper(itemsToRemovePtr, intArrayLength);
-
-                int* itemsAddedFromOtherPtr = stackalloc int[intArrayLength];
-                itemsAddedFromOther = new BitHelper(itemsAddedFromOtherPtr, intArrayLength);
-            }
-            else {
-                int[] itemsToRemoveArray = new int[intArrayLength];
-                itemsToRemove = new BitHelper(itemsToRemoveArray, intArrayLength);
-
-                int[] itemsAddedFromOtherArray = new int[intArrayLength];
-                itemsAddedFromOther = new BitHelper(itemsAddedFromOtherArray, intArrayLength);
-            }
-
-            foreach (T item in other) {
-                int location = 0;
-                bool added = AddOrGetLocation(item, out location);
-                if (added) {
-                    // wasn't already present in collection; flag it as something not to remove
-                    // *NOTE* if location is out of range, we should ignore. BitHelper will
-                    // detect that it's out of bounds and not try to mark it. But it's 
-                    // expected that location could be out of bounds because adding the item
-                    // will increase m_lastIndex as soon as all the free spots are filled.
-                    itemsAddedFromOther.MarkBit(location);
-                }
-                else {
-                    // already there...if not added from other, mark for remove. 
-                    // *NOTE* Even though BitHelper will check that location is in range, we want 
-                    // to check here. There's no point in checking items beyond originalLastIndex
-                    // because they could not have been in the original collection
-                    if (location < originalLastIndex && !itemsAddedFromOther.IsMarked(location)) {
-                        itemsToRemove.MarkBit(location);
-                    }
-                }
-            }
-
-            // if anything marked, remove it
-            for (int i = 0; i < originalLastIndex; i++) {
-                if (itemsToRemove.IsMarked(i)) {
-                    Remove(m_slots[i].value);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Add if not already in hashset. Returns an out param indicating index where added. This 
-        /// is used by SymmetricExcept because it needs to know the following things:
-        /// - whether the item was already present in the collection or added from other
-        /// - where it's located (if already present, it will get marked for removal, otherwise
-        /// marked for keeping)
-        /// </summary>
-        /// <param name="value"></param>
-        /// <param name="location"></param>
-        /// <returns></returns>
-        private bool AddOrGetLocation(T value, out int location) {
-            Debug.Assert(m_buckets != null, "m_buckets is null, callers should have checked");
-
-            int hashCode = InternalGetHashCode(value);
-            int bucket = hashCode % m_buckets.Length;
-            for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, value)) {
-                    location = i;
-                    return false; //already present
-                }
-            }
-            int index;
-            if (m_freeList >= 0) {
-                index = m_freeList;
-                m_freeList = m_slots[index].next;
-            }
-            else {
-                if (m_lastIndex == m_slots.Length) {
-                    IncreaseCapacity();
-                    // this will change during resize
-                    bucket = hashCode % m_buckets.Length;
-                }
-                index = m_lastIndex;
-                m_lastIndex++;
-            }
-            m_slots[index].hashCode = hashCode;
-            m_slots[index].value = value;
-            m_slots[index].next = m_buckets[bucket] - 1;
-            m_buckets[bucket] = index + 1;
-            m_count++;
-            m_version++;
-            location = index;
-            return true;
-        }
-
-        /// <summary>
-        /// Determines counts that can be used to determine equality, subset, and superset. This
-        /// is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
-        /// these properties can be checked faster without use of marking because we can assume 
-        /// other has no duplicates.
-        /// 
-        /// The following count checks are performed by callers:
-        /// 1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = m_count; i.e. everything 
-        /// in other is in this and everything in this is in other
-        /// 2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = m_count; i.e. other may
-        /// have elements not in this and everything in this is in other
-        /// 3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = m_count; i.e
-        /// other must have at least one element not in this and everything in this is in other
-        /// 4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
-        /// than m_count; i.e. everything in other was in this and this had at least one element
-        /// not contained in other.
-        /// 
-        /// An earlier implementation used delegates to perform these checks rather than returning
-        /// an ElementCount struct; however this was changed due to the perf overhead of delegates.
-        /// </summary>
-        /// <param name="other"></param>
-        /// <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
-        /// because unfoundCount must be 0.</param>
-        /// <returns></returns>
-        [System.Security.SecuritySafeCritical]
-        private unsafe ElementCount CheckUniqueAndUnfoundElements(IEnumerable<T> other, bool returnIfUnfound) {
-            ElementCount result;
-
-            // need special case in case this has no elements. 
-            if (m_count == 0) {
-                int numElementsInOther = 0;
-                foreach (T item in other) {
-                    numElementsInOther++;
-                    // break right away, all we want to know is whether other has 0 or 1 elements
-                    break;
-                }
-                result.uniqueCount = 0;
-                result.unfoundCount = numElementsInOther;
-                return result;
-            }
-
-
-            Debug.Assert((m_buckets != null) && (m_count > 0), "m_buckets was null but count greater than 0");
-
-            int originalLastIndex = m_lastIndex;
-            int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-            BitHelper bitHelper;
-            if (intArrayLength <= StackAllocThreshold) {
-                int* bitArrayPtr = stackalloc int[intArrayLength];
-                bitHelper = new BitHelper(bitArrayPtr, intArrayLength);
-            }
-            else {
-                int[] bitArray = new int[intArrayLength];
-                bitHelper = new BitHelper(bitArray, intArrayLength);
-            }
-
-            // count of items in other not found in this
-            int unfoundCount = 0;
-            // count of unique items in other found in this
-            int uniqueFoundCount = 0;
-
-            foreach (T item in other) {
-                int index = InternalIndexOf(item);
-                if (index >= 0) {
-                    if (!bitHelper.IsMarked(index)) {
-                        // item hasn't been seen yet
-                        bitHelper.MarkBit(index);
-                        uniqueFoundCount++;
-                    }
-                }
-                else {
-                    unfoundCount++;
-                    if (returnIfUnfound) {
-                        break;
-                    }
-                }
-            }
-
-            result.uniqueCount = uniqueFoundCount;
-            result.unfoundCount = unfoundCount;
-            return result;
-        }
-
-        /// <summary>
-        /// Copies this to an array. Used for DebugView
-        /// </summary>
-        /// <returns></returns>
-        internal T[] ToArray() {
-            T[] newArray = new T[Count];
-            CopyTo(newArray);
-            return newArray;
-        }
-
-        /// <summary>
-        /// Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
-        /// to specified comparer.
-        /// 
-        /// Because items are hashed according to a specific equality comparer, we have to resort
-        /// to n^2 search if they're using different equality comparers.
-        /// </summary>
-        /// <param name="set1"></param>
-        /// <param name="set2"></param>
-        /// <param name="comparer"></param>
-        /// <returns></returns>
-        internal static bool HashSetEquals(HashSet<T> set1, HashSet<T> set2, IEqualityComparer<T> comparer) {
-            // handle null cases first
-            if (set1 == null) {
-                return (set2 == null);
-            }
-            else if (set2 == null) {
-                // set1 != null
-                return false;
-            }
-
-            // all comparers are the same; this is faster
-            if (AreEqualityComparersEqual(set1, set2)) {
-                if (set1.Count != set2.Count) {
-                    return false;
-                }
-                // suffices to check subset
-                foreach (T item in set2) {
-                    if (!set1.Contains(item)) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-            else {  // n^2 search because items are hashed according to their respective ECs
-                foreach (T set2Item in set2) {
-                    bool found = false;
-                    foreach (T set1Item in set1) {
-                        if (comparer.Equals(set2Item, set1Item)) {
-                            found = true;
-                            break;
-                        }
-                    }
-                    if (!found) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-        }
-
-        /// <summary>
-        /// Checks if equality comparers are equal. This is used for algorithms that can
-        /// speed up if it knows the other item has unique elements. I.e. if they're using 
-        /// different equality comparers, then uniqueness assumption between sets break.
-        /// </summary>
-        /// <param name="set1"></param>
-        /// <param name="set2"></param>
-        /// <returns></returns>
-        private static bool AreEqualityComparersEqual(HashSet<T> set1, HashSet<T> set2) {
-            return set1.Comparer.Equals(set2.Comparer);
-        }
-
-        /// <summary>
-        /// Workaround Comparers that throw ArgumentNullException for GetHashCode(null).
-        /// </summary>
-        /// <param name="item"></param>
-        /// <returns>hash code</returns>
-        private int InternalGetHashCode(T item) {
-            if (item == null) {
-                return 0;
-            } 
-            return m_comparer.GetHashCode(item) & Lower31BitMask;
-        }
-
-        #endregion
-
-        // used for set checking operations (using enumerables) that rely on counting
-        internal struct ElementCount {
-            internal int uniqueCount;
-            internal int unfoundCount;
-        }
-
-        internal struct Slot {
-            internal int hashCode;      // Lower 31 bits of hash code, -1 if unused
-            internal T value;
-            internal int next;          // Index of next entry, -1 if last
-        }
-
-#if !SILVERLIGHT
-        [Serializable()]
-        [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
-#endif
-        public struct Enumerator : IEnumerator<T>, System.Collections.IEnumerator {
-            private HashSet<T> set;
-            private int index;
-            private int version;
-            private T current;
-
-            internal Enumerator(HashSet<T> set) {
-                this.set = set;
-                index = 0;
-                version = set.m_version;
-                current = default(T);
-            }
-
-            public void Dispose() {
-            }
-
-            public bool MoveNext() {
-                if (version != set.m_version) {
-                    throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
-                }
-
-                while (index < set.m_lastIndex) {
-                    if (set.m_slots[index].hashCode >= 0) {
-                        current = set.m_slots[index].value;
-                        index++;
-                        return true;
-                    }
-                    index++;
-                }
-                index = set.m_lastIndex + 1;
-                current = default(T);
-                return false;
-            }
-
-            public T Current {
-                get {
-                    return current;
-                }
-            }
-
-            Object System.Collections.IEnumerator.Current {
-                get {
-                    if (index == 0 || index == set.m_lastIndex + 1) {
-                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumOpCantHappen));
-                    }
-                    return Current;
-                }
-            }
-
-            void System.Collections.IEnumerator.Reset() {
-                if (version != set.m_version) {
-                    throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
-                }
-
-                index = 0;
-                current = default(T);
-            }
-        }
-    }
-
-}
diff --git a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSetDebugView.cs b/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSetDebugView.cs
deleted file mode 100644
index 5fd5651ac32..00000000000
--- a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSetDebugView.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-Ôªøusing System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Text;
-
-#nullable disable
-
-namespace System.Collections.Generic {
-
-    /// <summary>
-    /// Debug view for HashSet
-    /// </summary>
-    /// <typeparam name="T"></typeparam>
-    internal class HashSetDebugView<T> {
-        private HashSet<T> set;
-
-        public HashSetDebugView(HashSet<T> set) {
-            if (set == null) {
-                throw new ArgumentNullException("set");
-            }
-
-            this.set = set;
-        }
-
-        [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        public T[] Items {
-            get {
-                return set.ToArray();
-            }
-        }
-    }
-
-}
diff --git a/src/Build/Collections/WeakValueDictionary.cs b/src/Build/Collections/WeakValueDictionary.cs
index c4c04d802eb..34d1267a234 100644
--- a/src/Build/Collections/WeakValueDictionary.cs
+++ b/src/Build/Collections/WeakValueDictionary.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
@@ -15,7 +16,7 @@ namespace Microsoft.Build.Collections
     /// </summary>
     /// <typeparam name="K">Type of key</typeparam>
     /// <typeparam name="V">Type of value, without the WeakReference wrapper.</typeparam>
-    internal class WeakValueDictionary<K, V>
+    internal class WeakValueDictionary<K, V> : IEnumerable<KeyValuePair<K, V>>
         where V : class
     {
         /// <summary>
@@ -233,5 +234,22 @@ public void Clear()
         {
             _dictionary.Clear();
         }
+
+        public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
+        {
+            foreach (KeyValuePair<K, WeakReference<V>> kvp in _dictionary)
+            {
+                if (kvp.Value is null)
+                {
+                    yield return new KeyValuePair<K, V>(kvp.Key, null);
+                }
+                else if (kvp.Value.TryGetTarget(out V target))
+                {
+                    yield return new KeyValuePair<K, V>(kvp.Key, target);
+                }
+            }
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
     }
 }
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..e979313ca70
--- /dev/null
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -0,0 +1,9 @@
+Ôªø<?xml version="1.0" encoding="utf-8"?>
+<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
+  <Suppression>
+    <DiagnosticId>PKV006</DiagnosticId>
+    <Target>net7.0</Target>
+  </Suppression>
+</Suppressions>
diff --git a/src/Build/Construction/ProjectChooseElement.cs b/src/Build/Construction/ProjectChooseElement.cs
index 39d9fc749ac..4ecc4131aca 100644
--- a/src/Build/Construction/ProjectChooseElement.cs
+++ b/src/Build/Construction/ProjectChooseElement.cs
@@ -3,9 +3,7 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
 using System.Xml;
-using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
@@ -60,7 +58,7 @@ public override string Condition
         /// Get the When children.
         /// Will contain at least one entry.
         /// </summary>
-        public ICollection<ProjectWhenElement> WhenElements => new ReadOnlyCollection<ProjectWhenElement>(Children.OfType<ProjectWhenElement>());
+        public ICollection<ProjectWhenElement> WhenElements => GetChildrenOfType<ProjectWhenElement>();
 
         /// <summary>
         /// Get any Otherwise child.
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index b6208f51108..aab13ff3128 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -351,7 +351,7 @@ public ProjectElement Clone()
         public virtual void CopyFrom(ProjectElement element)
         {
             ErrorUtilities.VerifyThrowArgumentNull(element, nameof(element));
-            ErrorUtilities.VerifyThrowArgument(GetType().IsEquivalentTo(element.GetType()), nameof(element));
+            ErrorUtilities.VerifyThrowArgument(GetType().IsEquivalentTo(element.GetType()), "CannotCopyFromElementOfThatType");
 
             if (this == element)
             {
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 4eb8f8edb91..c138612fced 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
@@ -59,10 +60,15 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer
         }
 
         /// <summary>
-        /// Get an enumerator over all children, gotten recursively.
-        /// Walks the children in a depth-first manner.
+        /// Get an enumerator over all descendants in a depth-first manner.
         /// </summary>
-        public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();
+        public IEnumerable<ProjectElement> AllChildren => GetDescendants();
+
+        internal IEnumerable<T> GetAllChildrenOfType<T>()
+            where T : ProjectElement
+            => FirstChild == null
+                ? Array.Empty<T>()
+                : GetDescendantsOfType<T>();
 
         /// <summary>
         /// Get enumerable over all the children
@@ -70,26 +76,41 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer
         public ICollection<ProjectElement> Children
         {
             [DebuggerStepThrough]
-            get
-            {
-                return new Collections.ReadOnlyCollection<ProjectElement>(
-                        new ProjectElementSiblingEnumerable(FirstChild));
-            }
+            get => FirstChild == null
+                ? Array.Empty<ProjectElement>()
+                : new Collections.ReadOnlyCollection<ProjectElement>(new ProjectElementSiblingEnumerable(FirstChild));
         }
 
+#pragma warning disable RS0030 // The ref to the banned API is in a doc comment
+        /// <summary>
+        /// Use this instead of <see cref="Children"/> to avoid boxing.
+        /// </summary>
+#pragma warning restore RS0030
+        internal ProjectElementSiblingEnumerable ChildrenEnumerable => new ProjectElementSiblingEnumerable(FirstChild);
+
+        internal ProjectElementSiblingSubTypeCollection<T> GetChildrenOfType<T>()
+            where T : ProjectElement
+            => FirstChild == null
+                ? ProjectElementSiblingSubTypeCollection<T>.Empty
+                : new ProjectElementSiblingSubTypeCollection<T>(FirstChild);
+
         /// <summary>
         /// Get enumerable over all the children, starting from the last
         /// </summary>
         public ICollection<ProjectElement> ChildrenReversed
         {
             [DebuggerStepThrough]
-            get
-            {
-                return new Collections.ReadOnlyCollection<ProjectElement>(
-                        new ProjectElementSiblingEnumerable(LastChild, false /* reverse */));
-            }
+            get => LastChild == null
+                ? Array.Empty<ProjectElement>()
+                : new Collections.ReadOnlyCollection<ProjectElement>(new ProjectElementSiblingEnumerable(LastChild, forwards: false));
         }
 
+        internal ProjectElementSiblingSubTypeCollection<T> GetChildrenReversedOfType<T>()
+            where T : ProjectElement
+            => LastChild == null
+                ? ProjectElementSiblingSubTypeCollection<T>.Empty
+                : new ProjectElementSiblingSubTypeCollection<T>(LastChild, forwards: false);
+
         /// <summary>
         /// Number of children of any kind
         /// </summary>
@@ -318,7 +339,7 @@ public void RemoveChild(ProjectElement child)
         /// </remarks>
         public void RemoveAllChildren()
         {
-            foreach (ProjectElement child in Children)
+            foreach (ProjectElement child in ChildrenEnumerable)
             {
                 RemoveChild(child);
             }
@@ -331,7 +352,7 @@ public void RemoveAllChildren()
         public virtual void DeepCopyFrom(ProjectElementContainer element)
         {
             ErrorUtilities.VerifyThrowArgumentNull(element, nameof(element));
-            ErrorUtilities.VerifyThrowArgument(GetType().IsEquivalentTo(element.GetType()), nameof(element));
+            ErrorUtilities.VerifyThrowArgument(GetType().IsEquivalentTo(element.GetType()), "CannotCopyFromElementOfThatType");
 
             if (this == element)
             {
@@ -341,7 +362,7 @@ public virtual void DeepCopyFrom(ProjectElementContainer element)
             RemoveAllChildren();
             CopyFrom(element);
 
-            foreach (ProjectElement child in element.Children)
+            foreach (ProjectElement child in element.ChildrenEnumerable)
             {
                 if (child is ProjectElementContainer childContainer)
                 {
@@ -395,7 +416,7 @@ protected internal virtual ProjectElementContainer DeepClone(ProjectRootElement
             var clone = (ProjectElementContainer)Clone(factory);
             parent?.AppendChild(clone);
 
-            foreach (ProjectElement child in Children)
+            foreach (ProjectElement child in ChildrenEnumerable)
             {
                 if (child is ProjectElementContainer childContainer)
                 {
@@ -667,7 +688,7 @@ private void VerifyThrowInvalidOperationNotSelfAncestor(ProjectElement element)
         /// Result does NOT include the element passed in.
         /// The caller could filter these.
         /// </summary>
-        private IEnumerable<ProjectElement> GetChildrenRecursively()
+        private IEnumerable<ProjectElement> GetDescendants()
         {
             ProjectElement child = FirstChild;
 
@@ -687,6 +708,30 @@ private IEnumerable<ProjectElement> GetChildrenRecursively()
             }
         }
 
+        private IEnumerable<T> GetDescendantsOfType<T>()
+            where T : ProjectElement
+        {
+            ProjectElement child = FirstChild;
+
+            while (child != null)
+            {
+                if (child is T childOfType)
+                {
+                    yield return childOfType;
+                }
+
+                if (child is ProjectElementContainer container)
+                {
+                    foreach (T grandchild in container.GetAllChildrenOfType<T>())
+                    {
+                        yield return grandchild;
+                    }
+                }
+
+                child = child.NextSibling;
+            }
+        }
+
         private static bool TrySearchLeftSiblings(ProjectElement initialElement, Predicate<ProjectElement> siblingIsAcceptable, out ProjectElement referenceSibling)
         {
             return TrySearchSiblings(initialElement, siblingIsAcceptable, s => s.PreviousSibling, out referenceSibling);
@@ -721,44 +766,182 @@ private static bool TrySearchSiblings(
             return referenceSibling != null;
         }
 
+        internal sealed class ProjectElementSiblingSubTypeCollection<T> : ICollection<T>, ICollection
+            where T : ProjectElement
+        {
+            private readonly ProjectElement _initial;
+            private readonly bool _forwards;
+            private List<T> _realizedElements;
+
+            internal ProjectElementSiblingSubTypeCollection(ProjectElement initial, bool forwards = true)
+            {
+                _initial = initial;
+                _forwards = forwards;
+            }
+
+            public static ProjectElementSiblingSubTypeCollection<T> Empty { get; } = new ProjectElementSiblingSubTypeCollection<T>(initial: null);
+
+            public int Count => RealizedElements.Count;
+
+            public bool IsReadOnly => true;
+
+            bool ICollection.IsSynchronized => false;
+
+            object ICollection.SyncRoot => this;
+
+            private List<T> RealizedElements
+            {
+                get
+                {
+                    if (_realizedElements == null)
+                    {
+                        // Note! Don't use the List ctor which takes an IEnumerable as it casts to an ICollection and calls Count,
+                        // which leads to a StackOverflow exception in this implementation (see Count above)
+                        List<T> list = new();
+                        foreach (T element in this)
+                        {
+                            list.Add(element);
+                        }
+
+                        _realizedElements = list;
+                    }
+
+                    return _realizedElements;
+                }
+            }
+
+            public void Add(T item) => ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
+
+            public void Clear() => ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
+
+            public bool Contains(T item) => RealizedElements.Contains(item);
+
+            public void CopyTo(T[] array, int arrayIndex)
+            {
+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));
+
+                if (_realizedElements != null)
+                {
+                    _realizedElements.CopyTo(array, arrayIndex);
+                }
+                else
+                {
+                    int i = arrayIndex;
+                    foreach (T entry in this)
+                    {
+                        array[i] = entry;
+                        i++;
+                    }
+                }
+            }
+
+            public bool Remove(T item)
+            {
+                ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
+                return false;
+            }
+
+            public IEnumerator<T> GetEnumerator() => new Enumerator(_initial, _forwards);
+
+            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
+
+            void ICollection.CopyTo(Array array, int index)
+            {
+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));
+
+                int i = index;
+                foreach (T entry in this)
+                {
+                    array.SetValue(entry, i);
+                    i++;
+                }
+            }
+
+            public struct Enumerator : IEnumerator<T>
+            {
+                // Note! Should not be readonly or we run into infinite loop issues with mutable structs
+                private ProjectElementSiblingEnumerable.Enumerator _innerEnumerator;
+                private T _current;
+
+                internal Enumerator(ProjectElement initial, bool forwards = true)
+                {
+                    _innerEnumerator = new ProjectElementSiblingEnumerable.Enumerator(initial, forwards);
+                }
+
+                public T Current
+                {
+                    get
+                    {
+                        if (_current != null)
+                        {
+                            return _current;
+                        }
+
+                        throw new InvalidOperationException();
+                    }
+                }
+
+                object IEnumerator.Current => Current;
+
+                public readonly void Dispose()
+                {
+                }
+
+                public bool MoveNext()
+                {
+                    while (_innerEnumerator.MoveNext())
+                    {
+                        ProjectElement innerCurrent = _innerEnumerator.Current;
+                        if (innerCurrent is T innerCurrentOfType)
+                        {
+                            _current = innerCurrentOfType;
+                            return true;
+                        }
+                    }
+
+                    return false;
+                }
+
+                public void Reset()
+                {
+                    _innerEnumerator.Reset();
+                    _current = null;
+                }
+            }
+        }
+
         /// <summary>
         /// Enumerable over a series of sibling ProjectElement objects
         /// </summary>
-        private struct ProjectElementSiblingEnumerable : IEnumerable<ProjectElement>
+        internal readonly struct ProjectElementSiblingEnumerable : IEnumerable<ProjectElement>
         {
             /// <summary>
             /// The enumerator
             /// </summary>
-            private readonly ProjectElementSiblingEnumerator _enumerator;
+            private readonly Enumerator _enumerator;
 
             /// <summary>
             /// Constructor allowing reverse enumeration
             /// </summary>
             internal ProjectElementSiblingEnumerable(ProjectElement initial, bool forwards = true)
             {
-                _enumerator = new ProjectElementSiblingEnumerator(initial, forwards);
+                _enumerator = new Enumerator(initial, forwards);
             }
 
             /// <summary>
             /// Get enumerator
             /// </summary>
-            public IEnumerator<ProjectElement> GetEnumerator()
-            {
-                return _enumerator;
-            }
+            public readonly IEnumerator<ProjectElement> GetEnumerator() => _enumerator;
 
             /// <summary>
             /// Get non generic enumerator
             /// </summary>
-            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
-            {
-                return _enumerator;
-            }
+            IEnumerator IEnumerable.GetEnumerator() => _enumerator;
 
             /// <summary>
             /// Enumerator over a series of sibling ProjectElement objects
             /// </summary>
-            private struct ProjectElementSiblingEnumerator : IEnumerator<ProjectElement>
+            public struct Enumerator : IEnumerator<ProjectElement>
             {
                 /// <summary>
                 /// First element
@@ -775,7 +958,7 @@ private struct ProjectElementSiblingEnumerator : IEnumerator<ProjectElement>
                 /// <summary>
                 /// Constructor taking the first element
                 /// </summary>
-                internal ProjectElementSiblingEnumerator(ProjectElement initial, bool forwards)
+                internal Enumerator(ProjectElement initial, bool forwards)
                 {
                     _initial = initial;
                     Current = null;
@@ -792,7 +975,7 @@ internal ProjectElementSiblingEnumerator(ProjectElement initial, bool forwards)
                 /// Current element.
                 /// Throws if MoveNext() hasn't been called
                 /// </summary>
-                object System.Collections.IEnumerator.Current
+                object IEnumerator.Current
                 {
                     get
                     {
@@ -808,7 +991,7 @@ object System.Collections.IEnumerator.Current
                 /// <summary>
                 /// Dispose. Do nothing.
                 /// </summary>
-                public void Dispose()
+                public readonly void Dispose()
                 {
                 }
 
diff --git a/src/Build/Construction/ProjectExtensionsElement.cs b/src/Build/Construction/ProjectExtensionsElement.cs
index 3f9f6541d5a..83d6520abd8 100644
--- a/src/Build/Construction/ProjectExtensionsElement.cs
+++ b/src/Build/Construction/ProjectExtensionsElement.cs
@@ -162,7 +162,7 @@ public string this[string name]
         public override void CopyFrom(ProjectElement element)
         {
             ErrorUtilities.VerifyThrowArgumentNull(element, nameof(element));
-            ErrorUtilities.VerifyThrowArgument(GetType().IsEquivalentTo(element.GetType()), nameof(element));
+            ErrorUtilities.VerifyThrowArgument(GetType().IsEquivalentTo(element.GetType()), "CannotCopyFromElementOfThatType");
 
             if (this == element)
             {
diff --git a/src/Build/Construction/ProjectImportGroupElement.cs b/src/Build/Construction/ProjectImportGroupElement.cs
index d6c6979e996..d5131174811 100644
--- a/src/Build/Construction/ProjectImportGroupElement.cs
+++ b/src/Build/Construction/ProjectImportGroupElement.cs
@@ -3,8 +3,6 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
@@ -51,7 +49,7 @@ private ProjectImportGroupElement(XmlElementWithLocation xmlElement, ProjectRoot
         /// <summary>
         /// Get any contained properties.
         /// </summary>
-        public ICollection<ProjectImportElement> Imports => new ReadOnlyCollection<ProjectImportElement>(Children.OfType<ProjectImportElement>());
+        public ICollection<ProjectImportElement> Imports => GetChildrenOfType<ProjectImportElement>();
 
         #endregion // Properties
 
diff --git a/src/Build/Construction/ProjectItemDefinitionElement.cs b/src/Build/Construction/ProjectItemDefinitionElement.cs
index dc8fa52003f..85edb365e8a 100644
--- a/src/Build/Construction/ProjectItemDefinitionElement.cs
+++ b/src/Build/Construction/ProjectItemDefinitionElement.cs
@@ -3,9 +3,7 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
 using System.Xml;
-using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
@@ -52,7 +50,7 @@ private ProjectItemDefinitionElement(XmlElement xmlElement, ProjectRootElement c
         /// <summary>
         /// Get any child metadata definitions.
         /// </summary>
-        public ICollection<ProjectMetadataElement> Metadata => new ReadOnlyCollection<ProjectMetadataElement>(Children.OfType<ProjectMetadataElement>());
+        public ICollection<ProjectMetadataElement> Metadata => GetChildrenOfType<ProjectMetadataElement>();
 
         /// <summary>
         /// Convenience method to add a piece of metadata to this item definition.
diff --git a/src/Build/Construction/ProjectItemDefinitionGroupElement.cs b/src/Build/Construction/ProjectItemDefinitionGroupElement.cs
index 892b33cb8d6..36a034e32d2 100644
--- a/src/Build/Construction/ProjectItemDefinitionGroupElement.cs
+++ b/src/Build/Construction/ProjectItemDefinitionGroupElement.cs
@@ -3,9 +3,7 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
 using System.Xml;
-using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
@@ -47,7 +45,7 @@ private ProjectItemDefinitionGroupElement(XmlElement xmlElement, ProjectRootElem
         /// <summary>
         /// Get a list of child item definitions.
         /// </summary>
-        public ICollection<ProjectItemDefinitionElement> ItemDefinitions => new ReadOnlyCollection<ProjectItemDefinitionElement>(Children.OfType<ProjectItemDefinitionElement>());
+        public ICollection<ProjectItemDefinitionElement> ItemDefinitions => GetChildrenOfType<ProjectItemDefinitionElement>();
 
         /// <summary>
         /// Convenience method that picks a location based on a heuristic:
diff --git a/src/Build/Construction/ProjectItemElement.cs b/src/Build/Construction/ProjectItemElement.cs
index bb31b120e9f..fb98d908339 100644
--- a/src/Build/Construction/ProjectItemElement.cs
+++ b/src/Build/Construction/ProjectItemElement.cs
@@ -4,9 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
 using System.Xml;
-using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
@@ -285,7 +283,7 @@ public string KeepDuplicates
         /// <summary>
         /// Get any child metadata.
         /// </summary>
-        public ICollection<ProjectMetadataElement> Metadata => new ReadOnlyCollection<ProjectMetadataElement>(Children.OfType<ProjectMetadataElement>());
+        public ICollection<ProjectMetadataElement> Metadata => GetChildrenOfType<ProjectMetadataElement>();
 
         /// <summary>
         /// Location of the include attribute
diff --git a/src/Build/Construction/ProjectItemGroupElement.cs b/src/Build/Construction/ProjectItemGroupElement.cs
index b637161a355..03dc40eb8eb 100644
--- a/src/Build/Construction/ProjectItemGroupElement.cs
+++ b/src/Build/Construction/ProjectItemGroupElement.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
 using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
@@ -55,7 +54,7 @@ private ProjectItemGroupElement(XmlElementWithLocation xmlElement, ProjectRootEl
         /// Get any child items.
         /// This is a live collection.
         /// </summary>
-        public ICollection<ProjectItemElement> Items => new ReadOnlyCollection<ProjectItemElement>(Children.OfType<ProjectItemElement>());
+        public ICollection<ProjectItemElement> Items => GetChildrenOfType<ProjectItemElement>();
 
         /// <summary>
         /// True if it is known that no child items have wildcards in their
diff --git a/src/Build/Construction/ProjectMetadataElement.cs b/src/Build/Construction/ProjectMetadataElement.cs
index a8ba5cd5c10..473f39c0476 100644
--- a/src/Build/Construction/ProjectMetadataElement.cs
+++ b/src/Build/Construction/ProjectMetadataElement.cs
@@ -100,13 +100,13 @@ public string Value
         /// Creates an unparented ProjectMetadataElement, wrapping an unparented XmlElement.
         /// Caller should then ensure the element is added to a parent.
         /// </summary>
-        internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject)
+        internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject, ElementLocation location = null)
         {
             XmlUtilities.VerifyThrowArgumentValidElementName(name);
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             ErrorUtilities.VerifyThrowInvalidOperation(!XMakeElements.ReservedItemNames.Contains(name), "CannotModifyReservedItemMetadata", name);
 
-            XmlElementWithLocation element = containingProject.CreateElement(name);
+            XmlElementWithLocation element = containingProject.CreateElement(name, location);
 
             return new ProjectMetadataElement(element, containingProject);
         }
diff --git a/src/Build/Construction/ProjectOtherwiseElement.cs b/src/Build/Construction/ProjectOtherwiseElement.cs
index f3002cc8a8c..81adce4ec70 100644
--- a/src/Build/Construction/ProjectOtherwiseElement.cs
+++ b/src/Build/Construction/ProjectOtherwiseElement.cs
@@ -3,8 +3,6 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
@@ -57,17 +55,17 @@ public override string Condition
         /// <summary>
         /// Get an enumerator over any child item groups
         /// </summary>
-        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());
+        public ICollection<ProjectItemGroupElement> ItemGroups => GetChildrenOfType<ProjectItemGroupElement>();
 
         /// <summary>
         /// Get an enumerator over any child property groups
         /// </summary>
-        public ICollection<ProjectPropertyGroupElement> PropertyGroups => new ReadOnlyCollection<ProjectPropertyGroupElement>(Children.OfType<ProjectPropertyGroupElement>());
+        public ICollection<ProjectPropertyGroupElement> PropertyGroups => GetChildrenOfType<ProjectPropertyGroupElement>();
 
         /// <summary>
         /// Get an enumerator over any child chooses
         /// </summary>
-        public ICollection<ProjectChooseElement> ChooseElements => new ReadOnlyCollection<ProjectChooseElement>(Children.OfType<ProjectChooseElement>());
+        public ICollection<ProjectChooseElement> ChooseElements => GetChildrenOfType<ProjectChooseElement>();
 
         #endregion
 
diff --git a/src/Build/Construction/ProjectPropertyGroupElement.cs b/src/Build/Construction/ProjectPropertyGroupElement.cs
index 4c9fc27fe46..16932b3107e 100644
--- a/src/Build/Construction/ProjectPropertyGroupElement.cs
+++ b/src/Build/Construction/ProjectPropertyGroupElement.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
@@ -47,12 +45,12 @@ private ProjectPropertyGroupElement(XmlElementWithLocation xmlElement, ProjectRo
         /// <summary>
         /// Get any contained properties.
         /// </summary>
-        public ICollection<ProjectPropertyElement> Properties => new ReadOnlyCollection<ProjectPropertyElement>(Children.OfType<ProjectPropertyElement>());
+        public ICollection<ProjectPropertyElement> Properties => GetChildrenOfType<ProjectPropertyElement>();
 
         /// <summary>
         /// Get any contained properties.
         /// </summary>
-        public ICollection<ProjectPropertyElement> PropertiesReversed => new ReadOnlyCollection<ProjectPropertyElement>(ChildrenReversed.OfType<ProjectPropertyElement>());
+        public ICollection<ProjectPropertyElement> PropertiesReversed => GetChildrenReversedOfType<ProjectPropertyElement>();
 
         /// <summary>
         /// Convenience method that picks a location based on a heuristic:
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index b0ff4459c4a..1db13d96a4c 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -287,81 +287,81 @@ public override string Condition
         /// <remarks>
         /// The name is inconsistent to make it more understandable, per API review.
         /// </remarks>
-        public ICollection<ProjectChooseElement> ChooseElements => new ReadOnlyCollection<ProjectChooseElement>(Children.OfType<ProjectChooseElement>());
+        public ICollection<ProjectChooseElement> ChooseElements => GetChildrenOfType<ProjectChooseElement>();
 
         /// <summary>
         /// Get a read-only collection of the child item definition groups, if any
         /// </summary>
-        public ICollection<ProjectItemDefinitionGroupElement> ItemDefinitionGroups => new ReadOnlyCollection<ProjectItemDefinitionGroupElement>(Children.OfType<ProjectItemDefinitionGroupElement>());
+        public ICollection<ProjectItemDefinitionGroupElement> ItemDefinitionGroups => GetChildrenOfType<ProjectItemDefinitionGroupElement>();
 
         /// <summary>
         /// Get a read-only collection of the child item definitions, if any, in all item definition groups anywhere in the project file.
         /// </summary>
-        public ICollection<ProjectItemDefinitionElement> ItemDefinitions => new ReadOnlyCollection<ProjectItemDefinitionElement>(AllChildren.OfType<ProjectItemDefinitionElement>());
+        public ICollection<ProjectItemDefinitionElement> ItemDefinitions => new ReadOnlyCollection<ProjectItemDefinitionElement>(GetAllChildrenOfType<ProjectItemDefinitionElement>());
 
         /// <summary>
         /// Get a read-only collection over the child item groups, if any.
         /// Does not include any that may not be at the root, i.e. inside Choose elements.
         /// </summary>
-        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());
+        public ICollection<ProjectItemGroupElement> ItemGroups => GetChildrenOfType<ProjectItemGroupElement>();
 
         /// <summary>
         /// Get a read-only collection of the child items, if any, in all item groups anywhere in the project file.
         /// Not restricted to root item groups: traverses through Choose elements.
         /// </summary>
-        public ICollection<ProjectItemElement> Items => new ReadOnlyCollection<ProjectItemElement>(AllChildren.OfType<ProjectItemElement>());
+        public ICollection<ProjectItemElement> Items => new ReadOnlyCollection<ProjectItemElement>(GetAllChildrenOfType<ProjectItemElement>());
 
         /// <summary>
         /// Get a read-only collection of the child import groups, if any.
         /// </summary>
-        public ICollection<ProjectImportGroupElement> ImportGroups => new ReadOnlyCollection<ProjectImportGroupElement>(Children.OfType<ProjectImportGroupElement>());
+        public ICollection<ProjectImportGroupElement> ImportGroups => GetChildrenOfType<ProjectImportGroupElement>();
 
         /// <summary>
         /// Get a read-only collection of the child imports
         /// </summary>
-        public ICollection<ProjectImportElement> Imports => new ReadOnlyCollection<ProjectImportElement>(AllChildren.OfType<ProjectImportElement>());
+        public ICollection<ProjectImportElement> Imports => new ReadOnlyCollection<ProjectImportElement>(GetAllChildrenOfType<ProjectImportElement>());
 
         /// <summary>
         /// Get a read-only collection of the child property groups, if any.
         /// Does not include any that may not be at the root, i.e. inside Choose elements.
         /// </summary>
-        public ICollection<ProjectPropertyGroupElement> PropertyGroups => new ReadOnlyCollection<ProjectPropertyGroupElement>(Children.OfType<ProjectPropertyGroupElement>());
+        public ICollection<ProjectPropertyGroupElement> PropertyGroups => GetChildrenOfType<ProjectPropertyGroupElement>();
 
         /// <summary>
         /// Geta read-only collection of the child properties, if any, in all property groups anywhere in the project file.
         /// Not restricted to root property groups: traverses through Choose elements.
         /// </summary>
-        public ICollection<ProjectPropertyElement> Properties => new ReadOnlyCollection<ProjectPropertyElement>(AllChildren.OfType<ProjectPropertyElement>());
+        public ICollection<ProjectPropertyElement> Properties => new ReadOnlyCollection<ProjectPropertyElement>(GetAllChildrenOfType<ProjectPropertyElement>());
 
         /// <summary>
         /// Get a read-only collection of the child targets
         /// </summary>
-        public ICollection<ProjectTargetElement> Targets => new ReadOnlyCollection<ProjectTargetElement>(Children.OfType<ProjectTargetElement>());
+        public ICollection<ProjectTargetElement> Targets => GetChildrenOfType<ProjectTargetElement>();
 
         /// <summary>
         /// Get a read-only collection of the child usingtasks, if any
         /// </summary>
-        public ICollection<ProjectUsingTaskElement> UsingTasks => new ReadOnlyCollection<ProjectUsingTaskElement>(Children.OfType<ProjectUsingTaskElement>());
+        public ICollection<ProjectUsingTaskElement> UsingTasks => GetChildrenOfType<ProjectUsingTaskElement>();
 
         /// <summary>
         /// Get a read-only collection of the child item groups, if any, in reverse order
         /// </summary>
-        public ICollection<ProjectItemGroupElement> ItemGroupsReversed => new ReadOnlyCollection<ProjectItemGroupElement>(ChildrenReversed.OfType<ProjectItemGroupElement>());
+        public ICollection<ProjectItemGroupElement> ItemGroupsReversed => GetChildrenReversedOfType<ProjectItemGroupElement>();
 
         /// <summary>
         /// Get a read-only collection of the child item definition groups, if any, in reverse order
         /// </summary>
-        public ICollection<ProjectItemDefinitionGroupElement> ItemDefinitionGroupsReversed => new ReadOnlyCollection<ProjectItemDefinitionGroupElement>(ChildrenReversed.OfType<ProjectItemDefinitionGroupElement>());
+        public ICollection<ProjectItemDefinitionGroupElement> ItemDefinitionGroupsReversed => GetChildrenReversedOfType<ProjectItemDefinitionGroupElement>();
 
         /// <summary>
         /// Get a read-only collection of the child import groups, if any, in reverse order
         /// </summary>
-        public ICollection<ProjectImportGroupElement> ImportGroupsReversed => new ReadOnlyCollection<ProjectImportGroupElement>(ChildrenReversed.OfType<ProjectImportGroupElement>());
+        public ICollection<ProjectImportGroupElement> ImportGroupsReversed => GetChildrenReversedOfType<ProjectImportGroupElement>();
 
         /// <summary>
         /// Get a read-only collection of the child property groups, if any, in reverse order
         /// </summary>
-        public ICollection<ProjectPropertyGroupElement> PropertyGroupsReversed => new ReadOnlyCollection<ProjectPropertyGroupElement>(ChildrenReversed.OfType<ProjectPropertyGroupElement>());
+        public ICollection<ProjectPropertyGroupElement> PropertyGroupsReversed => GetChildrenReversedOfType<ProjectPropertyGroupElement>();
 
         #endregion
 
@@ -702,7 +702,7 @@ public override ElementLocation ConditionLocation
         /// Not public as we do not wish to encourage the use of ProjectExtensions.
         /// </remarks>
         internal ProjectExtensionsElement ProjectExtensions
-            => ChildrenReversed.OfType<ProjectExtensionsElement>().FirstOrDefault();
+            => GetChildrenReversedOfType<ProjectExtensionsElement>().FirstOrDefault();
 
         /// <summary>
         /// Returns an unlocalized indication of how this file was last dirtied.
@@ -1327,13 +1327,22 @@ public ProjectMetadataElement CreateMetadataElement(string name)
         /// Caller must add it to the location of choice in the project.
         /// </summary>
         public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue)
+        {
+            return this.CreateMetadataElement(name, unevaluatedValue, null);
+        }
+
+        /// <summary>
+        /// Creates a metadata node.
+        /// Caller must add it to the location of choice in the project.
+        /// </summary>
+        public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue, ElementLocation location)
         {
             if (Link != null)
             {
                 return RootLink.CreateMetadataElement(name, unevaluatedValue);
             }
 
-            ProjectMetadataElement metadatum = ProjectMetadataElement.CreateDisconnected(name, this);
+            ProjectMetadataElement metadatum = ProjectMetadataElement.CreateDisconnected(name, this, location);
 
             metadatum.Value = unevaluatedValue;
 
@@ -1785,14 +1794,23 @@ internal static ProjectRootElement OpenProjectOrSolution(string fullPath, IDicti
             return projectRootElement;
         }
 
+        /// <summary>
+        /// Creates a metadata node.
+        /// Caller must add it to the location of choice in the project.
+        /// </summary>
+        internal ProjectMetadataElement CreateMetadataElement(XmlAttributeWithLocation attribute)
+        {
+            return CreateMetadataElement(attribute.Name, attribute.Value, attribute.Location);
+        }
+
         /// <summary>
         /// Creates a XmlElement with the specified name in the document
         /// containing this project.
         /// </summary>
-        internal XmlElementWithLocation CreateElement(string name)
+        internal XmlElementWithLocation CreateElement(string name, ElementLocation location = null)
         {
             ErrorUtilities.VerifyThrow(Link == null, "External project");
-            return (XmlElementWithLocation)XmlDocument.CreateElement(name, XmlNamespace);
+            return (XmlElementWithLocation)XmlDocument.CreateElement(name, XmlNamespace, location);
         }
 
         /// <summary>
@@ -1887,15 +1905,18 @@ internal List<ProjectImportElement> GetImplicitImportNodes(ProjectRootElement cu
                 }
             }
 
-            foreach (var sdkNode in Children.OfType<ProjectSdkElement>())
+            foreach (ProjectElement child in ChildrenEnumerable)
             {
-                var referencedSdk = new SdkReference(
-                    sdkNode.XmlElement.GetAttribute("Name"),
-                    sdkNode.XmlElement.GetAttribute("Version"),
-                    sdkNode.XmlElement.GetAttribute("MinimumVersion"));
+                if (child is ProjectSdkElement sdkNode)
+                {
+                    var referencedSdk = new SdkReference(
+                        sdkNode.XmlElement.GetAttribute("Name"),
+                        sdkNode.XmlElement.GetAttribute("Version"),
+                        sdkNode.XmlElement.GetAttribute("MinimumVersion"));
 
-                nodes.Add(ProjectImportElement.CreateImplicit("Sdk.props", currentProjectOrImport, ImplicitImportLocation.Top, referencedSdk, sdkNode));
-                nodes.Add(ProjectImportElement.CreateImplicit("Sdk.targets", currentProjectOrImport, ImplicitImportLocation.Bottom, referencedSdk, sdkNode));
+                    nodes.Add(ProjectImportElement.CreateImplicit("Sdk.props", currentProjectOrImport, ImplicitImportLocation.Top, referencedSdk, sdkNode));
+                    nodes.Add(ProjectImportElement.CreateImplicit("Sdk.targets", currentProjectOrImport, ImplicitImportLocation.Bottom, referencedSdk, sdkNode));
+                }
             }
 
             return nodes;
diff --git a/src/Build/Construction/ProjectTargetElement.cs b/src/Build/Construction/ProjectTargetElement.cs
index f7618c427be..e9893009031 100644
--- a/src/Build/Construction/ProjectTargetElement.cs
+++ b/src/Build/Construction/ProjectTargetElement.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
@@ -58,22 +56,22 @@ private ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootEleme
         /// <summary>
         /// Get an enumerator over any child item groups
         /// </summary>
-        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());
+        public ICollection<ProjectItemGroupElement> ItemGroups => GetChildrenOfType<ProjectItemGroupElement>();
 
         /// <summary>
         /// Get an enumerator over any child property groups
         /// </summary>
-        public ICollection<ProjectPropertyGroupElement> PropertyGroups => new ReadOnlyCollection<ProjectPropertyGroupElement>(Children.OfType<ProjectPropertyGroupElement>());
+        public ICollection<ProjectPropertyGroupElement> PropertyGroups => GetChildrenOfType<ProjectPropertyGroupElement>();
 
         /// <summary>
         /// Get an enumerator over any child tasks
         /// </summary>
-        public ICollection<ProjectTaskElement> Tasks => new ReadOnlyCollection<ProjectTaskElement>(Children.OfType<ProjectTaskElement>());
+        public ICollection<ProjectTaskElement> Tasks => GetChildrenOfType<ProjectTaskElement>();
 
         /// <summary>
         /// Get an enumerator over any child onerrors
         /// </summary>
-        public ICollection<ProjectOnErrorElement> OnErrors => new ReadOnlyCollection<ProjectOnErrorElement>(Children.OfType<ProjectOnErrorElement>());
+        public ICollection<ProjectOnErrorElement> OnErrors => GetChildrenOfType<ProjectOnErrorElement>();
 
         #endregion
 
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index 49048f632bd..94031b4994c 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
 using System.Diagnostics;
-using System.Linq;
 using System.Xml;
 using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
@@ -126,7 +125,7 @@ public string MSBuildArchitecture
         /// <summary>
         /// Gets any output children.
         /// </summary>
-        public ICollection<ProjectOutputElement> Outputs => new Collections.ReadOnlyCollection<ProjectOutputElement>(Children.OfType<ProjectOutputElement>());
+        public ICollection<ProjectOutputElement> Outputs => GetChildrenOfType<ProjectOutputElement>();
 
         /// <summary>
         /// Enumerable over the unevaluated parameters on the task.
diff --git a/src/Build/Construction/ProjectWhenElement.cs b/src/Build/Construction/ProjectWhenElement.cs
index 92140145ed1..a706a66b283 100644
--- a/src/Build/Construction/ProjectWhenElement.cs
+++ b/src/Build/Construction/ProjectWhenElement.cs
@@ -3,9 +3,7 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
 using System.Xml;
-using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
@@ -48,17 +46,17 @@ private ProjectWhenElement(XmlElement xmlElement, ProjectRootElement containingP
         /// <summary>
         /// Get an enumerator over any child chooses
         /// </summary>
-        public ICollection<ProjectChooseElement> ChooseElements => new ReadOnlyCollection<ProjectChooseElement>(Children.OfType<ProjectChooseElement>());
+        public ICollection<ProjectChooseElement> ChooseElements => GetChildrenOfType<ProjectChooseElement>();
 
         /// <summary>
         /// Get an enumerator over any child item groups
         /// </summary>
-        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());
+        public ICollection<ProjectItemGroupElement> ItemGroups => GetChildrenOfType<ProjectItemGroupElement>();
 
         /// <summary>
         /// Get an enumerator over any child property groups
         /// </summary>
-        public ICollection<ProjectPropertyGroupElement> PropertyGroups => new ReadOnlyCollection<ProjectPropertyGroupElement>(Children.OfType<ProjectPropertyGroupElement>());
+        public ICollection<ProjectPropertyGroupElement> PropertyGroups => GetChildrenOfType<ProjectPropertyGroupElement>();
 
         #endregion
 
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 6fe5e032d8d..b13b09f50a1 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -299,10 +299,11 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
             try
             {
                 // Read project thru a XmlReader with proper setting to avoid DTD processing
-                var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
                 var projectDocument = new XmlDocument();
 
-                using (XmlReader xmlReader = XmlReader.Create(AbsolutePath, xrSettings))
+                FileStream fs = File.OpenRead(AbsolutePath);
+                using (XmlReader xmlReader = XmlReader.Create(fs, xrSettings))
                 {
                     // Load the project file and get the first node    
                     projectDocument.Load(xmlReader);
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 4cdd0fe8ac1..a59fdb60e4d 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -888,10 +888,11 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
                 *</EFPROJECT>
                 **********************************************************************************/
                 // Make sure the XML reader ignores DTD processing
-                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
 
                 // Load the .etp project file thru the XML reader
-                using (XmlReader xmlReader = XmlReader.Create(fullPathToEtpProj, readerSettings))
+                FileStream fs = File.OpenRead(fullPathToEtpProj);
+                using (XmlReader xmlReader = XmlReader.Create(fs, readerSettings))
                 {
                     etpProjectDocument.Load(xmlReader);
                 }
@@ -1634,5 +1635,5 @@ internal string GetProjectRelativePathByGuid(string projectGuid)
         }
 
         #endregion
-    } // class SolutionParser
+    } // class SolutionFile
 } // namespace Microsoft.Build.Construction
diff --git a/src/Build/Construction/UsingTaskParameterGroupElement.cs b/src/Build/Construction/UsingTaskParameterGroupElement.cs
index a0fc796495a..3e76edb1e85 100644
--- a/src/Build/Construction/UsingTaskParameterGroupElement.cs
+++ b/src/Build/Construction/UsingTaskParameterGroupElement.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
@@ -59,7 +57,7 @@ public override string Condition
         /// <summary>
         /// Get any contained parameters.
         /// </summary>
-        public ICollection<ProjectUsingTaskParameterElement> Parameters => new ReadOnlyCollection<ProjectUsingTaskParameterElement>(Children.OfType<ProjectUsingTaskParameterElement>());
+        public ICollection<ProjectUsingTaskParameterElement> Parameters => GetChildrenOfType<ProjectUsingTaskParameterElement>();
 
         /// <summary>
         /// This does not allow conditions, so it should not be called.
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 7db7747eea1..106b1ca08ee 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -1809,18 +1809,6 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
             ErrorUtilities.VerifyThrowInvalidOperation(ReferenceEquals(Xml, otherXml), "OM_CannotModifyEvaluatedObjectInImportedFile", otherXml.Location.File);
         }
 
-        /// <summary>
-        /// Returns <see cref="IDirectoryCache"/> as provided by the <see cref="IDirectoryCacheFactory"/> passed when creating the
-        /// project, specific for a given evaluation ID.
-        /// </summary>
-        /// <param name="evaluationId">The evaluation ID for which the cache is requested.</param>
-        /// <returns>An <see cref="IDirectoryCache"/> implementation, or null if this project has no <see cref="IDirectoryCacheFactory"/>
-        /// associated with it or it returned null.</returns>
-        internal IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId)
-        {
-            return _directoryCacheFactory?.GetDirectoryCacheForEvaluation(evaluationId);
-        }
-
         /// <summary>
         /// Internal project evaluation implementation.
         /// </summary>
@@ -2558,7 +2546,7 @@ public static CumulativeRemoveElementData Create()
                     };
                 }
 
-                public void AccumulateInformationFromRemoveItemSpec(EvaluationItemSpec removeSpec)
+                public readonly void AccumulateInformationFromRemoveItemSpec(EvaluationItemSpec removeSpec)
                 {
                     IEnumerable<string> removeSpecFragmentStrings = removeSpec.FlattenFragmentsAsStrings();
                     var removeGlob = removeSpec.ToMSBuildGlob();
@@ -3737,6 +3725,7 @@ private void Reevaluate(
                     loggingServiceForEvaluation,
                     new ProjectItemFactory(Owner),
                     ProjectCollection,
+                    Owner._directoryCacheFactory,
                     ProjectCollection.ProjectRootElementCache,
                     s_buildEventContext,
                     evaluationContext.SdkResolverService,
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 1f24703fd5b..5d2bf851cef 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -87,8 +87,8 @@ public class ProjectCollection : IToolsetProvider, IBuildComponent, IDisposable
         /// <remarks>
         /// ProjectCollection is highly reentrant - project creation, toolset and logger changes, and so on
         /// all need lock protection, but there are a lot of read cases as well, and calls to create Projects
-        /// call back to the ProjectCollection under locks. Use a RW lock, but default to always using
-        /// upgradable read locks to avoid adding reentrancy bugs.
+        /// call back to the ProjectCollection under locks. Use a RW lock with recursion support to avoid
+        /// adding reentrancy bugs.
         /// </remarks>
         private readonly ReaderWriterLockSlim _locker = new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);
 
@@ -508,7 +508,7 @@ public string DefaultToolsVersion
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     ErrorUtilities.VerifyThrow(_defaultToolsVersion != null, "Should have a default");
                     return _defaultToolsVersion;
@@ -558,7 +558,7 @@ public IDictionary<string, string> GlobalProperties
             {
                 Dictionary<string, string> dictionary;
 
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     if (_globalProperties.Count == 0)
                     {
@@ -591,7 +591,7 @@ public int Count
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _loadedProjects.Count;
                 }
@@ -609,7 +609,7 @@ public ICollection<ILogger> Loggers
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _loggingService.Loggers == null
                         ? (ICollection<ILogger>)ReadOnlyEmptyCollection<ILogger>.Instance
@@ -628,7 +628,7 @@ public ICollection<Toolset> Toolsets
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return new List<Toolset>(_toolsets.Values);
                 }
@@ -650,7 +650,7 @@ public bool IsBuildEnabled
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _isBuildEnabled;
                 }
@@ -683,7 +683,7 @@ public bool OnlyLogCriticalEvents
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _onlyLogCriticalEvents;
                 }
@@ -720,17 +720,20 @@ public HostServices HostServices
             get
             {
                 // Avoid write lock if possible, this getter is called a lot during Project construction.
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     if (_hostServices != null)
                     {
                         return _hostServices;
                     }
-
-                    using (_locker.EnterDisposableWriteLock())
+                }
+                using (_locker.EnterDisposableWriteLock())
+                {
+                    if (_hostServices == null)
                     {
-                        return _hostServices ?? (_hostServices = new HostServices());
+                        _hostServices = new HostServices();
                     }
+                    return _hostServices;
                 }
             }
 
@@ -763,7 +766,7 @@ public bool SkipEvaluation
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _skipEvaluation;
                 }
@@ -799,7 +802,7 @@ public bool DisableMarkDirty
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _disableMarkDirty;
                 }
@@ -849,7 +852,7 @@ internal ILoggingService LoggingService
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _loggingService;
                 }
@@ -867,7 +870,7 @@ internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesCollection
             {
                 var clone = new PropertyDictionary<ProjectPropertyInstance>();
 
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     foreach (ProjectPropertyInstance property in _globalProperties)
                     {
@@ -886,23 +889,24 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                // Retrieves the environment properties.
+                // This is only done once, when the project collection is created. Any subsequent
+                // environment changes will be ignored. Child nodes will be passed this set
+                // of properties in their build parameters.
+                using (_locker.EnterDisposableReadLock())
                 {
-                    // Retrieves the environment properties.
-                    // This is only done once, when the project collection is created. Any subsequent
-                    // environment changes will be ignored. Child nodes will be passed this set
-                    // of properties in their build parameters.
-                    if (_environmentProperties == null)
+                    if (_environmentProperties != null)
                     {
-                        using (_locker.EnterDisposableWriteLock())
-                        {
-                            if (_environmentProperties == null)
-                            {
-                                _environmentProperties = Utilities.GetEnvironmentProperties();
-                            }
-                        }
+                        return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
                     }
+                }
 
+                using (_locker.EnterDisposableWriteLock())
+                {
+                    if (_environmentProperties == null)
+                    {
+                        _environmentProperties = Utilities.GetEnvironmentProperties();
+                    }
                     return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
                 }
             }
@@ -917,7 +921,7 @@ internal int ToolsetsVersion
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _toolsetsVersion;
                 }
@@ -931,7 +935,7 @@ internal int MaxNodeCount
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _maxNodeCount;
                 }
@@ -1419,7 +1423,7 @@ public void UnloadAllProjects()
         /// </summary>
         public ProjectPropertyInstance GetGlobalProperty(string name)
         {
-            using (_locker.EnterDisposableUpgradeableReadLock())
+            using (_locker.EnterDisposableReadLock())
             {
                 return _globalProperties[name];
             }
@@ -1544,6 +1548,13 @@ public bool TryUnloadProject(ProjectRootElement projectRootElement)
             }
         }
 
+        /// <summary>
+        /// Logs a BuildFinished event. This is used specifically when a ProjectCollection is created but never actually built, yet a BuildFinished event
+        /// is still desired. As an example, if a Project is just meant to be evaluated, but a binlog is also collected, that binlog should be able to
+        /// say the build succeeded or failed. This provides a mechanism to achieve that.
+        /// </summary>
+        public void LogBuildFinishedEvent(bool success) => _loggingService.LogBuildFinished(success);
+
         /// <summary>
         /// Called by a Project object to load itself into this collection.
         /// If the project was already loaded under a different name, it is unloaded.
diff --git a/src/Build/Definition/ProjectImportPathMatch.cs b/src/Build/Definition/ProjectImportPathMatch.cs
index 60e07850b99..12667ea117f 100644
--- a/src/Build/Definition/ProjectImportPathMatch.cs
+++ b/src/Build/Definition/ProjectImportPathMatch.cs
@@ -11,6 +11,9 @@ namespace Microsoft.Build.Evaluation
 {
     /// <summary>
     /// Class representing a reference to a project import path with property fall-back
+    /// This class is immutable.
+    /// If mutability would be needed in the future, it should be implemented via copy-on-write or
+    ///  a DeepClone would need to be added (and called from DeepClone methods of owning types)
     /// </summary>
     internal class ProjectImportPathMatch : ITranslatable
     {
@@ -19,14 +22,19 @@ internal class ProjectImportPathMatch : ITranslatable
         /// </summary>
         public static readonly ProjectImportPathMatch None = new ProjectImportPathMatch(string.Empty, new List<string>());
 
+        // Those are effectively readonly and should stay so. Cannot be marked readonly due to ITranslatable
+        private string _propertyName;
+        private string _msBuildPropertyFormat;
+        private List<string> _searchPaths;
+
         internal ProjectImportPathMatch(string propertyName, List<string> searchPaths)
         {
             ErrorUtilities.VerifyThrowArgumentNull(propertyName, nameof(propertyName));
             ErrorUtilities.VerifyThrowArgumentNull(searchPaths, nameof(searchPaths));
 
-            PropertyName = propertyName;
-            SearchPaths = searchPaths;
-            MsBuildPropertyFormat = $"$({PropertyName})";
+            _propertyName = propertyName;
+            _searchPaths = searchPaths;
+            _msBuildPropertyFormat = $"$({PropertyName})";
         }
 
         public ProjectImportPathMatch(ITranslator translator)
@@ -37,23 +45,23 @@ public ProjectImportPathMatch(ITranslator translator)
         /// <summary>
         /// String representation of the property reference - eg. "MSBuildExtensionsPath32"
         /// </summary>
-        public string PropertyName;
+        public string PropertyName => _propertyName;
 
         /// <summary>
         /// Returns the corresponding property name - eg. "$(MSBuildExtensionsPath32)"
         /// </summary>
-        public string MsBuildPropertyFormat;
+        public string MsBuildPropertyFormat => _msBuildPropertyFormat;
 
         /// <summary>
         /// Enumeration of the search paths for the property.
         /// </summary>
-        public List<string> SearchPaths;
+        public List<string> SearchPaths => _searchPaths;
 
         public void Translate(ITranslator translator)
         {
-            translator.Translate(ref PropertyName);
-            translator.Translate(ref MsBuildPropertyFormat);
-            translator.Translate(ref SearchPaths);
+            translator.Translate(ref _propertyName);
+            translator.Translate(ref _msBuildPropertyFormat);
+            translator.Translate(ref _searchPaths);
         }
 
         /// <summary>
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index 5cbad98cb06..cfffb456d72 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -26,7 +26,7 @@ namespace Microsoft.Build.Evaluation
     /// ProjectMetadataElement, and these can be added, removed, and modified.
     /// </remarks>
     [DebuggerDisplay("{_itemType} #Metadata={MetadataCount}")]
-    public class ProjectItemDefinition : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadata>, IProjectMetadataParent
+    public class ProjectItemDefinition : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadata>, IProjectMetadataParent, IItemTypeDefinition
     {
         /// <summary>
         /// Project that this item definition lives in.
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index ec59aaff465..58b18cadab1 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -8,7 +8,6 @@
 using System.IO;
 using System.Linq;
 using System.Xml;
-
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -190,11 +189,6 @@ public class Toolset : ITranslatable
         /// </summary>
         private Expander<ProjectPropertyInstance, ProjectItemInstance> _expander;
 
-        /// <summary>
-        /// Bag of properties for the expander to expand the properties and items in the using tasks files
-        /// </summary>
-        private PropertyDictionary<ProjectPropertyInstance> _propertyBag;
-
         /// <summary>
         /// SubToolsets that map to this toolset.
         /// </summary>
@@ -901,79 +895,79 @@ private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventCon
         /// </summary>
         private void InitializeProperties(ILoggingService loggingServices, BuildEventContext buildEventContext)
         {
+            if (_expander != null)
+            {
+                return;
+            }
+
             try
             {
-                if (_propertyBag == null)
-                {
-                    List<ProjectPropertyInstance> reservedProperties = new List<ProjectPropertyInstance>();
+                
+                List<ProjectPropertyInstance> reservedProperties = new List<ProjectPropertyInstance>();
 
-                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.binPath, EscapingUtilities.Escape(ToolsPath), mayBeReserved: true));
-                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.toolsVersion, ToolsVersion, mayBeReserved: true));
+                reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.binPath, EscapingUtilities.Escape(ToolsPath), mayBeReserved: true));
+                reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.toolsVersion, ToolsVersion, mayBeReserved: true));
 
-                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.toolsPath, EscapingUtilities.Escape(ToolsPath), mayBeReserved: true));
-                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));
-                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));
+                reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.toolsPath, EscapingUtilities.Escape(ToolsPath), mayBeReserved: true));
+                reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));
+                reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));
 
-                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,
+                reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,
 #if RUNTIME_TYPE_NETCORE
-                        Traits.Instance.ForceEvaluateAsFullFramework ? "Full" : "Core",
+                    Traits.Instance.ForceEvaluateAsFullFramework ? "Full" : "Core",
 #elif MONO
-                        NativeMethodsShared.IsMono ? "Mono" : "Full");
+                    NativeMethodsShared.IsMono ? "Mono" : "Full");
 #else
-                        "Full",
+                    "Full",
 #endif
-                        mayBeReserved: true));
+                    mayBeReserved: true));
 
 
-                    // Add one for the subtoolset version property -- it may or may not be set depending on whether it has already been set by the
-                    // environment or global properties, but it's better to create a dictionary that's one too big than one that's one too small.
-                    int count = _environmentProperties.Count + reservedProperties.Count + Properties.Values.Count + _globalProperties.Count + 1;
+                // Add one for the subtoolset version property -- it may or may not be set depending on whether it has already been set by the
+                // environment or global properties, but it's better to create a dictionary that's one too big than one that's one too small.
+                int count = _environmentProperties.Count + reservedProperties.Count + Properties.Values.Count + _globalProperties.Count + 1;
 
-                    // GenerateSubToolsetVersion checks the environment and global properties, so it's safe to go ahead and gather the
-                    // subtoolset properties here without fearing that we'll have somehow come up with the wrong subtoolset version.
-                    string subToolsetVersion = this.GenerateSubToolsetVersion();
-                    SubToolset subToolset;
-                    ICollection<ProjectPropertyInstance> subToolsetProperties = null;
+                // GenerateSubToolsetVersion checks the environment and global properties, so it's safe to go ahead and gather the
+                // subtoolset properties here without fearing that we'll have somehow come up with the wrong subtoolset version.
+                string subToolsetVersion = this.GenerateSubToolsetVersion();
+                SubToolset subToolset;
+                ICollection<ProjectPropertyInstance> subToolsetProperties = null;
 
-                    if (subToolsetVersion != null)
+                if (subToolsetVersion != null)
+                {
+                    if (SubToolsets.TryGetValue(subToolsetVersion, out subToolset))
                     {
-                        if (SubToolsets.TryGetValue(subToolsetVersion, out subToolset))
-                        {
-                            subToolsetProperties = subToolset.Properties.Values;
-                            count += subToolsetProperties.Count;
-                        }
+                        subToolsetProperties = subToolset.Properties.Values;
+                        count += subToolsetProperties.Count;
                     }
+                }
 
-                    _propertyBag = new PropertyDictionary<ProjectPropertyInstance>(count);
-
-                    // Should be imported in the same order as in the evaluator:
-                    // - Environment
-                    // - Toolset
-                    // - Subtoolset (if any)
-                    // - Global
-                    _propertyBag.ImportProperties(_environmentProperties);
+                PropertyDictionary<ProjectPropertyInstance> propertyBag = new PropertyDictionary<ProjectPropertyInstance>(count);
 
-                    _propertyBag.ImportProperties(reservedProperties);
+                // Should be imported in the same order as in the evaluator:
+                // - Environment
+                // - Toolset
+                // - Subtoolset (if any)
+                // - Global
+                propertyBag.ImportProperties(_environmentProperties);
 
-                    _propertyBag.ImportProperties(Properties.Values);
+                propertyBag.ImportProperties(reservedProperties);
 
-                    if (subToolsetVersion != null)
-                    {
-                        _propertyBag.Set(ProjectPropertyInstance.Create(Constants.SubToolsetVersionPropertyName, subToolsetVersion));
-                    }
-
-                    if (subToolsetProperties != null)
-                    {
-                        _propertyBag.ImportProperties(subToolsetProperties);
-                    }
+                propertyBag.ImportProperties(Properties.Values);
 
-                    _propertyBag.ImportProperties(_globalProperties);
+                if (subToolsetVersion != null)
+                {
+                    propertyBag.Set(ProjectPropertyInstance.Create(Constants.SubToolsetVersionPropertyName, subToolsetVersion));
                 }
 
-                if (_expander == null)
+                if (subToolsetProperties != null)
                 {
-                    _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_propertyBag, FileSystems.Default);
+                    propertyBag.ImportProperties(subToolsetProperties);
                 }
+
+                propertyBag.ImportProperties(_globalProperties);
+
+                _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, FileSystems.Default);
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
@@ -1044,10 +1038,35 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
         /// </summary>
         private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskFileError, ProjectRootElementCacheBase projectRootElementCache, TaskRegistry registry)
         {
-            foreach (string defaultTasksFile in defaultTaskFiles)
+            string currentTasksFile = null;
+            try
             {
-                try
+                TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<ProjectPropertyInstance, ProjectItemInstance>(
+                    loggingServices,
+                    buildEventContext,
+                    EnumerateTasksRegistrations(),
+                    registry,
+                    _expander,
+                    ExpanderOptions.ExpandProperties,
+                    FileSystems.Default);
+            }
+            catch (XmlException e)
+            {
+                // handle XML errors in the default tasks file
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(currentTasksFile, e),
+                    taskFileError, e.Message);
+            }
+            catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
+            {
+                loggingServices.LogError(buildEventContext, new BuildEventFileInfo(currentTasksFile),
+                    taskFileError, e.Message);
+            }
+
+            IEnumerable<(ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile)> EnumerateTasksRegistrations()
+            {
+                foreach (string defaultTasksFile in defaultTaskFiles)
                 {
+                    currentTasksFile = defaultTasksFile;
                     // Important to keep the following line since unit tests use the delegate.
                     ProjectRootElement projectRootElement;
                     if (_loadXmlFromPath != null)
@@ -1062,7 +1081,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
                             preserveFormatting: false);
                     }
 
-                    foreach (ProjectElement elementXml in projectRootElement.Children)
+                    foreach (ProjectElement elementXml in projectRootElement.ChildrenEnumerable)
                     {
                         ProjectUsingTaskElement usingTask = elementXml as ProjectUsingTaskElement;
 
@@ -1074,27 +1093,9 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
                                 elementXml.XmlElement.Name);
                         }
 
-                        TaskRegistry.RegisterTasksFromUsingTaskElement<ProjectPropertyInstance, ProjectItemInstance>(
-                            loggingServices,
-                            buildEventContext,
-                            Path.GetDirectoryName(defaultTasksFile),
-                            usingTask,
-                            registry,
-                            _expander,
-                            ExpanderOptions.ExpandProperties,
-                            FileSystems.Default);
+                        yield return (usingTask, Path.GetDirectoryName(defaultTasksFile));
                     }
                 }
-                catch (XmlException e)
-                {
-                    // handle XML errors in the default tasks file
-                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(defaultTasksFile, e), taskFileError, e.Message);
-                }
-                catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
-                {
-                    loggingServices.LogError(buildEventContext, new BuildEventFileInfo(defaultTasksFile), taskFileError, e.Message);
-                    break;
-                }
             }
         }
     }
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 9c064f5e68f..d7d81e88dc6 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -817,7 +817,7 @@ private MSBuildExtensionsPathReferenceKind(string value)
         /// <summary>
         /// Returns the corresponding property name - eg. "$(MSBuildExtensionsPath32)"
         /// </summary>
-        public string MSBuildPropertyName => String.Format($"$({StringRepresentation})");
+        public readonly string MSBuildPropertyName => String.Format($"$({StringRepresentation})");
 
         /// <summary>
         /// Tries to find a reference to MSBuildExtensionsPath* property in the given string
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index bbc34c86a57..88b0de71dbb 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.IO;
+using System.Threading;
 using System.Xml;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -59,6 +60,13 @@ internal class XmlDocumentWithLocation : XmlDocument
         /// </summary>
         private bool? _loadAsReadOnly;
 
+        /// <summary>
+        /// Location of the element to be created via 'CreateElement' call. So that we can
+        ///  receive and use location from the caller up the stack even if we are being called via
+        /// <see cref="XmlDocument"/> internal methods.
+        /// </summary>
+        private readonly AsyncLocal<ElementLocation> _elementLocation = new AsyncLocal<ElementLocation>();
+
         /// <summary>
         /// Constructor
         /// </summary>
@@ -180,6 +188,31 @@ public override void Load(string fullPath)
             }
         }
 
+        /// <summary>
+        /// Called during parse, to add an element.
+        /// </summary>
+        /// <remarks>
+        /// We create our own kind of element, that we can give location information to.
+        /// In order to pass the location through the callchain, that contains XmlDocument function
+        ///  that then calls back to our XmlDocumentWithLocation (so we cannot use call stack via passing via parameters),
+        ///  we use async local field, that simulates variable on call stack.
+        /// </remarks>
+        internal XmlElement CreateElement(string localName, string namespaceURI, ElementLocation location)
+        {
+            if (location != null)
+            {
+                this._elementLocation.Value = location;
+            }
+            try
+            {
+                return CreateElement(localName, namespaceURI);
+            }
+            finally
+            {
+                this._elementLocation.Value = null;
+            }
+        }
+
         /// <summary>
         /// Called during load, to add an element.
         /// </summary>
@@ -192,6 +225,10 @@ public override XmlElement CreateElement(string prefix, string localName, string
             {
                 return new XmlElementWithLocation(prefix, localName, namespaceURI, this, _reader.LineNumber, _reader.LinePosition);
             }
+            else if (_elementLocation?.Value != null)
+            {
+                return new XmlElementWithLocation(prefix, localName, namespaceURI, this, _elementLocation.Value.Line, _elementLocation.Value.Column);
+            }
 
             // Must be a subsequent edit; we can't provide location information
             return new XmlElementWithLocation(prefix, localName, namespaceURI, this);
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 06daa610cd9..1db485e55ea 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -9,6 +9,8 @@
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
+using System.Collections.Generic;
 
 #nullable disable
 
@@ -22,7 +24,7 @@ namespace Microsoft.Build.Exceptions
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public sealed class InternalLoggerException : Exception
+    public sealed class InternalLoggerException : BuildExceptionBase
     {
         #region Unusable constructors
 
@@ -63,9 +65,7 @@ public InternalLoggerException(string message)
         /// <exception cref="InvalidOperationException"></exception>
         public InternalLoggerException(string message, Exception innerException)
             : base(message, innerException)
-        {
-            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
-        }
+        { }
 
         #endregion
 
@@ -108,6 +108,9 @@ internal InternalLoggerException(
         /// </summary>
         /// <param name="info"></param>
         /// <param name="context"></param>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InternalLoggerException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -125,6 +128,9 @@ private InternalLoggerException(SerializationInfo info, StreamingContext context
         /// <param name="context"></param>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
@@ -136,6 +142,23 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("initializationException", initializationException);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+                { nameof(initializationException), initializationException.ToString() },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+            initializationException = bool.Parse(state[nameof(initializationException)]);
+        }
+
         /// <summary>
         /// Provide default values for optional members
         /// </summary>
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 71c7d93d2cc..7bc6e4a135d 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -3,10 +3,11 @@
 
 using System;
 using System.Runtime.Serialization;
+using System.Collections.Generic;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
-
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -21,7 +22,7 @@ namespace Microsoft.Build.Exceptions
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public sealed class InvalidProjectFileException : Exception
+    public sealed class InvalidProjectFileException : BuildExceptionBase
     {
         #region Basic constructors
 
@@ -84,6 +85,9 @@ internal InvalidProjectFileException(string message, InvalidProjectFileException
         /// </summary>
         /// <param name="info"></param>
         /// <param name="context"></param>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InvalidProjectFileException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -106,6 +110,9 @@ private InvalidProjectFileException(SerializationInfo info, StreamingContext con
         /// <param name="context"></param>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
@@ -122,6 +129,35 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("hasBeenLogged", hasBeenLogged);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(file), file },
+                { nameof(lineNumber), lineNumber.ToString() },
+                { nameof(columnNumber), columnNumber.ToString() },
+                { nameof(endLineNumber), endLineNumber.ToString() },
+                { nameof(endColumnNumber), endColumnNumber.ToString() },
+                { nameof(errorSubcategory), errorSubcategory },
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+                { nameof(hasBeenLogged), hasBeenLogged.ToString() },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            file = state[nameof(file)];
+            lineNumber = int.Parse(state[nameof(lineNumber)]);
+            columnNumber = int.Parse(state[nameof(columnNumber)]);
+            endLineNumber = int.Parse(state[nameof(endLineNumber)]);
+            endColumnNumber = int.Parse(state[nameof(endColumnNumber)]);
+            errorSubcategory = state[nameof(errorSubcategory)];
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+            hasBeenLogged = bool.Parse(state[nameof(hasBeenLogged)]);
+        }
+
         #endregion
 
         #region Rich constructors
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 9f7c51e0b61..1ebc9c9d1b1 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -1,10 +1,11 @@
 Ôªø// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
+using System;
 using System.Runtime.Serialization;
+using System.Collections.Generic;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -17,7 +18,7 @@ namespace Microsoft.Build.Exceptions
     /// Exception subclass that ToolsetReaders should throw.
     /// </summary>
     [Serializable]
-    public class InvalidToolsetDefinitionException : Exception
+    public class InvalidToolsetDefinitionException : BuildExceptionBase
     {
         /// <summary>
         /// The MSBuild error code corresponding with this exception.
@@ -54,6 +55,9 @@ public InvalidToolsetDefinitionException(string message, Exception innerExceptio
         /// <summary>
         /// Basic constructor.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -93,6 +97,9 @@ public InvalidToolsetDefinitionException(string message, string errorCode, Excep
         /// <param name="context"></param>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
@@ -103,6 +110,19 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("errorCode", errorCode);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode }
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+        }
+
         /// <summary>
         /// The MSBuild error code corresponding with this exception, or
         /// null if none was specified.
@@ -146,9 +166,7 @@ internal static void Throw(
             string resourceName,
             params string[] args)
         {
-#if DEBUG
             ResourceUtilities.VerifyResourceStringExists(resourceName);
-#endif
             string errorCode;
             string helpKeyword;
             string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errorCode, out helpKeyword, resourceName, (object[])args);
diff --git a/src/Build/Errors/RegistryException.cs b/src/Build/Errors/RegistryException.cs
index 13d4335634d..11d37991996 100644
--- a/src/Build/Errors/RegistryException.cs
+++ b/src/Build/Errors/RegistryException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -12,7 +13,7 @@ namespace Microsoft.Build.Exceptions
     /// Generic exception used to wrap exceptions thrown during Registry access.
     /// </summary>
     [Serializable]
-    internal class RegistryException : Exception
+    internal class RegistryException : BuildExceptionBase
     {
         /// <summary>
         /// Basic constructor.
@@ -56,6 +57,9 @@ public RegistryException(string message, string source)
         /// <summary>
         /// Since this class implements Iserializable this constructor is required to be implemented.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected RegistryException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
             // We don't have any reason at the moment to do any custom serizlization or deserialization, this methods was added
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 3ff00696595..aeb2bc7414e 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -4,26 +4,20 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Text.RegularExpressions;
 using System.Threading;
 
-#nullable disable
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using BuildEventContext = Microsoft.Build.Framework.BuildEventContext;
+using ElementLocation = Microsoft.Build.Construction.ElementLocation;
+using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
+using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 namespace Microsoft.Build.Evaluation
 {
-    using Microsoft.Build.BackEnd.Logging;
-    using Microsoft.Build.Shared;
-    using Microsoft.Build.Shared.FileSystem;
-    using BuildEventContext = Microsoft.Build.Framework.BuildEventContext;
-    using ElementLocation = Microsoft.Build.Construction.ElementLocation;
-    using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
-    using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
-
     internal static class ConditionEvaluator
     {
-        private static readonly Lazy<Regex> s_singlePropertyRegex = new Lazy<Regex>(
-            () => new Regex(@"^\$\(([^\$\(\)]*)\)$", RegexOptions.Compiled));
-
         /// <summary>
         /// Update our table which keeps track of all the properties that are referenced
         /// inside of a condition and the string values that they are being tested against.
@@ -61,9 +55,7 @@ internal static void UpdateConditionedPropertiesTable(
                     var lastPiece = pieceSeparator < 0;
                     var pieceEnd = lastPiece ? leftValue.Length : pieceSeparator;
 
-                    var singlePropertyMatch = s_singlePropertyRegex.Value.Match(leftValue, pieceStart, pieceEnd - pieceStart);
-
-                    if (singlePropertyMatch.Success)
+                    if (TryGetSingleProperty(leftValue.AsSpan(), pieceStart, pieceEnd - pieceStart, out ReadOnlySpan<char> propertyName))
                     {
                         // Find the first vertical bar on the right-hand-side expression.
                         var indexOfVerticalBar = rightValueExpanded.IndexOf('|');
@@ -88,18 +80,13 @@ internal static void UpdateConditionedPropertiesTable(
                             rightValueExpanded = rightValueExpanded.Substring(indexOfVerticalBar + 1);
                         }
 
-                        // Capture the property name out of the regular expression.
-                        var propertyName = singlePropertyMatch.Groups[1].ToString();
-
                         // Get the string collection for this property name, if one already exists.
-                        List<string> conditionedPropertyValues;
-
-                        // If this property is not already represented in the table, add a new entry
-                        // for it.
-                        if (!conditionedPropertiesTable.TryGetValue(propertyName, out conditionedPropertyValues))
+                        // If not already in the table, add a new entry for it.
+                        string propertyNameString = propertyName.ToString();
+                        if (!conditionedPropertiesTable.TryGetValue(propertyNameString, out List<string>? conditionedPropertyValues))
                         {
                             conditionedPropertyValues = new List<string>();
-                            conditionedPropertiesTable[propertyName] = conditionedPropertyValues;
+                            conditionedPropertiesTable[propertyNameString] = conditionedPropertyValues;
                         }
 
                         // If the "rightValueExpanded" is not already in the string collection
@@ -120,6 +107,32 @@ internal static void UpdateConditionedPropertiesTable(
             }
         }
 
+        // Internal for testing purposes
+        internal static bool TryGetSingleProperty(ReadOnlySpan<char> input, int beginning, int length, out ReadOnlySpan<char> propertyName)
+        {
+            // This code is simulating the regex pattern: ^\$\(([^\$\(\)]*)\)$
+            if (input.Length < beginning + 3 ||
+                input[beginning] != '$' ||
+                input[beginning + 1] != '(' ||
+                input[beginning + length - 1] != ')' ||
+                ContainsInvalidCharacter(input.Slice(beginning + 2, length - 3)))
+            {
+                propertyName = null;
+                return false;
+            }
+
+            propertyName = input.Slice(beginning + 2, length - 3);
+            return true;
+
+            static bool ContainsInvalidCharacter(ReadOnlySpan<char> span)
+            {
+                return
+                    span.IndexOf('$') != -1 ||
+                    span.IndexOf('(') != -1 ||
+                    span.IndexOf(')') != -1;
+            }
+        }
+
         // Implements a pool of expression trees for each condition.
         // This is because an expression tree is a mutually exclusive resource (has non thread safe state while it evaluates).
         // During high demand when all expression trees are busy evaluating, a new expression tree is created and added to the pool.
@@ -130,11 +143,11 @@ private struct ExpressionTreeForCurrentOptionsWithSize
             private readonly ConcurrentDictionary<string, ConcurrentStack<GenericExpressionNode>> _conditionPools;
             private int _mOptimisticSize;
 
-            public int OptimisticSize => _mOptimisticSize;
+            public readonly int OptimisticSize => _mOptimisticSize;
 
             public ExpressionTreeForCurrentOptionsWithSize(ConcurrentDictionary<string, ConcurrentStack<GenericExpressionNode>> conditionPools)
             {
-                this._conditionPools = conditionPools;
+                _conditionPools = conditionPools;
                 _mOptimisticSize = conditionPools.Count;
             }
 
@@ -176,8 +189,8 @@ internal static bool EvaluateCondition<P, I>(
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null,
-            LoggingContext loggingContext = null)
+            ProjectRootElementCacheBase? projectRootElementCache = null,
+            LoggingContext? loggingContext = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -186,7 +199,7 @@ internal static bool EvaluateCondition<P, I>(
                 options,
                 expander,
                 expanderOptions,
-                null /* do not collect conditioned properties */,
+                conditionedPropertiesTable: null /* do not collect conditioned properties */,
                 evaluationDirectory,
                 elementLocation,
                 loggingServices,
@@ -208,14 +221,14 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
             ParserOptions options,
             Expander<P, I> expander,
             ExpanderOptions expanderOptions,
-            Dictionary<string, List<string>> conditionedPropertiesTable,
+            Dictionary<string, List<string>>? conditionedPropertiesTable,
             string evaluationDirectory,
             ElementLocation elementLocation,
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null,
-            LoggingContext loggingContext = null)
+            ProjectRootElementCacheBase? projectRootElementCache = null,
+            LoggingContext? loggingContext = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -343,13 +356,13 @@ internal interface IConditionEvaluationState
             ///     If this is null, as it is for command line builds, conditioned properties
             ///     are not recorded.
             /// </summary>
-            Dictionary<string, List<string>> ConditionedPropertiesInProject { get; }
+            Dictionary<string, List<string>>? ConditionedPropertiesInProject { get; }
 
             /// <summary>
             ///     May return null if the expression would expand to non-empty and it broke out early.
             ///     Otherwise, returns the correctly expanded expression.
             /// </summary>
-            string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null);
+            string ExpandIntoStringBreakEarly(string expression, LoggingContext? loggingContext = null);
 
             /// <summary>
             ///     Expands the specified expression into a list of TaskItem's.
@@ -359,12 +372,12 @@ internal interface IConditionEvaluationState
             /// <summary>
             ///     Expands the specified expression into a string.
             /// </summary>
-            string ExpandIntoString(string expression, LoggingContext loggingContext = null);
+            string ExpandIntoString(string expression, LoggingContext? loggingContext = null);
 
             /// <summary>
             ///     PRE cache
             /// </summary>
-            ProjectRootElementCacheBase LoadedProjectsCache { get; }
+            ProjectRootElementCacheBase? LoadedProjectsCache { get; }
 
             IFileSystem FileSystem { get; }
         }
@@ -398,22 +411,22 @@ internal class ConditionEvaluationState<P, I> : IConditionEvaluationState
             /// If this is null, as it is for command line builds, conditioned properties
             /// are not recorded.
             /// </summary>
-            public Dictionary<string, List<string>> ConditionedPropertiesInProject { get; }
+            public Dictionary<string, List<string>>? ConditionedPropertiesInProject { get; }
 
             /// <summary>
             /// PRE collection. 
             /// </summary>
-            public ProjectRootElementCacheBase LoadedProjectsCache { get; }
+            public ProjectRootElementCacheBase? LoadedProjectsCache { get; }
 
             internal ConditionEvaluationState(
                 string condition,
                 Expander<P, I> expander,
                 ExpanderOptions expanderOptions,
-                Dictionary<string, List<string>> conditionedPropertiesInProject,
+                Dictionary<string, List<string>>? conditionedPropertiesInProject,
                 string evaluationDirectory,
                 ElementLocation elementLocation,
                 IFileSystem fileSystem,
-                ProjectRootElementCacheBase projectRootElementCache = null)
+                ProjectRootElementCacheBase? projectRootElementCache = null)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
                 ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
@@ -434,7 +447,7 @@ internal ConditionEvaluationState(
             /// May return null if the expression would expand to non-empty and it broke out early.
             /// Otherwise, returns the correctly expanded expression.
             /// </summary>
-            public string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null)
+            public string ExpandIntoStringBreakEarly(string expression, LoggingContext? loggingContext = null)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
@@ -467,7 +480,7 @@ public IList<TaskItem> ExpandIntoTaskItems(string expression)
             /// <param name="expression">The expression to expand.</param>
             /// <param name="loggingContext"></param>
             /// <returns>The expanded string.</returns>
-            public string ExpandIntoString(string expression, LoggingContext loggingContext = null)
+            public string ExpandIntoString(string expression, LoggingContext? loggingContext = null)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 35097b0aeda..f5db7b9d74a 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -202,6 +202,7 @@ private Evaluator(
             PropertyDictionary<ProjectPropertyInstance> environmentProperties,
             IItemFactory<I, I> itemFactory,
             IToolsetProvider toolsetProvider,
+            IDirectoryCacheFactory directoryCacheFactory,
             ProjectRootElementCacheBase projectRootElementCache,
             ISdkResolverService sdkResolverService,
             int submissionId,
@@ -231,7 +232,7 @@ private Evaluator(
 
             // If the host wishes to provide a directory cache for this evaluation, create a new EvaluationContext with the right file system.
             _evaluationContext = evaluationContext;
-            IDirectoryCache directoryCache = project?.GetDirectoryCacheForEvaluation(_evaluationLoggingContext.BuildEventContext.EvaluationId);
+            IDirectoryCache directoryCache = directoryCacheFactory?.GetDirectoryCacheForEvaluation(_evaluationLoggingContext.BuildEventContext.EvaluationId);
             if (directoryCache is not null)
             {
                 IFileSystem fileSystem = new DirectoryCacheFileSystemWrapper(evaluationContext.FileSystem, directoryCache);
@@ -308,6 +309,7 @@ internal static void Evaluate(
             ILoggingService loggingService,
             IItemFactory<I, I> itemFactory,
             IToolsetProvider toolsetProvider,
+            IDirectoryCacheFactory directoryCacheFactory,
             ProjectRootElementCacheBase projectRootElementCache,
             BuildEventContext buildEventContext,
             ISdkResolverService sdkResolverService,
@@ -326,6 +328,7 @@ internal static void Evaluate(
                 environmentProperties,
                 itemFactory,
                 toolsetProvider,
+                directoryCacheFactory,
                 projectRootElementCache,
                 sdkResolverService,
                 submissionId,
@@ -532,7 +535,7 @@ private static ProjectTargetInstance ReadNewTargetElement(ProjectTargetElement t
             List<ProjectTargetInstanceChild> targetChildren = new List<ProjectTargetInstanceChild>(targetElement.Count);
             List<ProjectOnErrorInstance> targetOnErrorChildren = new List<ProjectOnErrorInstance>();
 
-            foreach (ProjectElement targetChildElement in targetElement.Children)
+            foreach (ProjectElement targetChildElement in targetElement.ChildrenEnumerable)
             {
                 using (evaluationProfiler.TrackElement(targetChildElement))
                 {
@@ -708,10 +711,15 @@ private void Evaluate()
                 MSBuildEventSource.Log.EvaluatePass4Start(projectFile);
                 using (_evaluationProfiler.TrackPass(EvaluationPass.UsingTasks))
                 {
-                    foreach (var entry in _usingTaskElements)
-                    {
-                        EvaluateUsingTaskElement(entry.Key, entry.Value);
-                    }
+                    // Evaluate the usingtask and add the result into the data passed in
+                    TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<P, I>(
+                        _evaluationLoggingContext.LoggingService,
+                        _evaluationLoggingContext.BuildEventContext,
+                        _usingTaskElements.Select(p => (p.Value, p.Key)),
+                        _data.TaskRegistry,
+                        _expander,
+                        ExpanderOptions.ExpandPropertiesAndItems,
+                        _evaluationContext.FileSystem);
                 }
 
                 // If there was no DefaultTargets attribute found in the depth first pass,
@@ -878,7 +886,7 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
                     }
                 }
 
-                foreach (ProjectElement element in currentProjectOrImport.Children)
+                foreach (ProjectElement element in currentProjectOrImport.ChildrenEnumerable)
                 {
                     switch (element)
                     {
@@ -1012,22 +1020,6 @@ private void EvaluateItemGroupElement(ProjectItemGroupElement itemGroupElement,
             }
         }
 
-        /// <summary>
-        /// Evaluate the usingtask and add the result into the data passed in
-        /// </summary>
-        private void EvaluateUsingTaskElement(string directoryOfImportingFile, ProjectUsingTaskElement projectUsingTaskElement)
-        {
-            TaskRegistry.RegisterTasksFromUsingTaskElement<P, I>(
-                _evaluationLoggingContext.LoggingService,
-                _evaluationLoggingContext.BuildEventContext,
-                directoryOfImportingFile,
-                projectUsingTaskElement,
-                _data.TaskRegistry,
-                _expander,
-                ExpanderOptions.ExpandPropertiesAndItems,
-                _evaluationContext.FileSystem);
-        }
-
         /// <summary>
         /// Retrieve the matching ProjectTargetInstance from the cache and add it to the provided collection.
         /// If it is not cached already, read it and cache it.
@@ -1313,12 +1305,12 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                 {
                     // Is the property we are currently setting in the list of properties which have been used but not initialized
                     IElementLocation elementWhichUsedProperty;
-                    bool isPropertyInList = _expander.UsedUninitializedProperties.Properties.TryGetValue(propertyElement.Name, out elementWhichUsedProperty);
+                    bool isPropertyInList = _expander.UsedUninitializedProperties.TryGetPropertyElementLocation(propertyElement.Name, out elementWhichUsedProperty);
 
                     if (isPropertyInList)
                     {
                         // Once we are going to warn for a property once, remove it from the list so we do not add it again.
-                        _expander.UsedUninitializedProperties.Properties.Remove(propertyElement.Name);
+                        _expander.UsedUninitializedProperties.RemoveProperty(propertyElement.Name);
                         _evaluationLoggingContext.LogWarning(null, new BuildEventFileInfo(propertyElement.Location), "UsedUninitializedProperty", propertyElement.Name, elementWhichUsedProperty.LocationString);
                     }
                 }
@@ -1496,7 +1488,7 @@ private void EvaluateChooseElement(ProjectChooseElement chooseElement)
                 {
                     if (EvaluateConditionCollectingConditionedProperties(whenElement, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties))
                     {
-                        EvaluateWhenOrOtherwiseChildren(whenElement.Children);
+                        EvaluateWhenOrOtherwiseChildren(whenElement.ChildrenEnumerable);
                         return;
                     }
                 }
@@ -1504,7 +1496,7 @@ private void EvaluateChooseElement(ProjectChooseElement chooseElement)
                 // "Otherwise" elements never have a condition
                 if (chooseElement.OtherwiseElement != null)
                 {
-                    EvaluateWhenOrOtherwiseChildren(chooseElement.OtherwiseElement.Children);
+                    EvaluateWhenOrOtherwiseChildren(chooseElement.OtherwiseElement.ChildrenEnumerable);
                 }
             }
         }
@@ -1514,7 +1506,7 @@ private void EvaluateChooseElement(ProjectChooseElement chooseElement)
         /// Returns true if the condition was true, so subsequent
         /// WhenElements and Otherwise can be skipped.
         /// </summary>
-        private bool EvaluateWhenOrOtherwiseChildren(IEnumerable<ProjectElement> children)
+        private bool EvaluateWhenOrOtherwiseChildren(ProjectElementContainer.ProjectElementSiblingEnumerable children)
         {
             foreach (ProjectElement element in children)
             {
@@ -2519,7 +2511,7 @@ private string GetCurrentDirectoryForConditionEvaluation(ProjectElement element)
 
         private void RecordEvaluatedItemElement(ProjectItemElement itemElement)
         {
-            if (_loadSettings.HasFlag(ProjectLoadSettings.RecordEvaluatedItemElements))
+            if ((_loadSettings & ProjectLoadSettings.RecordEvaluatedItemElements) == ProjectLoadSettings.RecordEvaluatedItemElements)
             {
                 _data.EvaluatedItemElements.Add(itemElement);
             }
diff --git a/src/Build/Evaluation/EvaluatorMetadataTable.cs b/src/Build/Evaluation/EvaluatorMetadataTable.cs
index d48f458465c..6405834f994 100644
--- a/src/Build/Evaluation/EvaluatorMetadataTable.cs
+++ b/src/Build/Evaluation/EvaluatorMetadataTable.cs
@@ -8,8 +8,6 @@
 using Microsoft.Build.Construction;
 using EscapingUtilities = Microsoft.Build.Shared.EscapingUtilities;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -22,19 +20,25 @@ internal class EvaluatorMetadataTable : IMetadataTable
         /// <summary>
         /// The actual metadata dictionary.
         /// </summary>
-        private Dictionary<string, EvaluatorMetadata> _metadata;
+        private Dictionary<string, EvaluatorMetadata>? _metadata;
 
         /// <summary>
         /// The type of item the metadata should be considered to apply to.
         /// </summary>
         private string _implicitItemType;
 
+        /// <summary>
+        /// The expected number of metadata entries in this table.
+        /// </summary>
+        private readonly int _capacity;
+
         /// <summary>
         /// Creates a new table using the specified item type.
         /// </summary>
-        public EvaluatorMetadataTable(string implicitItemType)
+        public EvaluatorMetadataTable(string implicitItemType, int capacity = 0)
         {
             _implicitItemType = implicitItemType;
+            _capacity = capacity;
         }
 
         /// <summary>
@@ -56,7 +60,7 @@ public string GetEscapedValue(string name)
         /// Retrieves any value we have in our metadata table for the metadata name and item type specified.
         /// If no value is available, returns empty string.
         /// </summary>
-        public string GetEscapedValue(string itemType, string name)
+        public string GetEscapedValue(string? itemType, string name)
         {
             return GetEscapedValueIfPresent(itemType, name) ?? String.Empty;
         }
@@ -65,21 +69,18 @@ public string GetEscapedValue(string itemType, string name)
         /// Retrieves any value we have in our metadata table for the metadata name and item type specified.
         /// If no value is available, returns null.
         /// </summary>
-        public string GetEscapedValueIfPresent(string itemType, string name)
+        public string? GetEscapedValueIfPresent(string? itemType, string name)
         {
             if (_metadata == null)
             {
                 return null;
             }
 
-            string value = null;
+            string? value = null;
 
             if (itemType == null || String.Equals(_implicitItemType, itemType, StringComparison.OrdinalIgnoreCase))
             {
-                EvaluatorMetadata metadatum;
-                _metadata.TryGetValue(name, out metadatum);
-
-                if (metadatum != null)
+                if (_metadata.TryGetValue(name, out EvaluatorMetadata? metadatum))
                 {
                     value = metadatum.EvaluatedValueEscaped;
                 }
@@ -95,7 +96,7 @@ internal void SetValue(ProjectMetadataElement xml, string evaluatedValueEscaped)
         {
             if (_metadata == null)
             {
-                _metadata = new Dictionary<string, EvaluatorMetadata>(MSBuildNameIgnoreCaseComparer.Default);
+                _metadata = new Dictionary<string, EvaluatorMetadata>(_capacity, MSBuildNameIgnoreCaseComparer.Default);
             }
 
             _metadata[xml.Name] = new EvaluatorMetadata(xml, evaluatedValueEscaped);
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index c76c6a47780..fbfd660d303 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -78,7 +78,7 @@ internal enum ExpanderOptions
         /// When an error occurs expanding a property, just leave it unexpanded.
         /// </summary>
         /// <remarks>
-        /// This should only be used in cases where property evaluation isn't critcal, such as when attempting to log a
+        /// This should only be used in cases where property evaluation isn't critical, such as when attempting to log a
         /// message with a best effort expansion of a string, or when discovering partial information during lazy evaluation.
         /// </remarks>
         LeavePropertiesUnexpandedOnError = 0x20,
@@ -88,6 +88,13 @@ internal enum ExpanderOptions
         /// </summary>
         Truncate = 0x40,
 
+        /// <summary>
+        /// Issues build message if item references unqualified or qualified metadata odf self - as this can lead to unintended expansion and
+        ///  cross-combination of other items.
+        /// More info: https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-batching#item-batching-on-self-referencing-metadata
+        /// </summary>
+        LogOnItemMetadataSelfReference = 0x80,
+
         /// <summary>
         /// Expand only properties and then item lists
         /// </summary>
@@ -203,7 +210,7 @@ public void Add(ReadOnlyMemory<char> span)
             /// concatenation of the string representation of the values, each additionally subjected
             /// to file path adjustment.
             /// </returns>
-            public object GetResult()
+            public readonly object GetResult()
             {
                 CheckDisposed();
                 if (_firstObject != null)
@@ -228,7 +235,7 @@ public void Dispose()
             /// <summary>
             /// Throws <see cref="ObjectDisposedException"/> if this concatenator is already disposed.
             /// </summary>
-            private void CheckDisposed() =>
+            private readonly void CheckDisposed() =>
                 ErrorUtilities.VerifyThrowObjectDisposed(!_disposed, nameof(SpanBasedConcatenator));
 
             /// <summary>
@@ -278,7 +285,7 @@ private void FlushFirstValueIfNeeded()
 
         /// <summary>
         /// The CultureInfo from the invariant culture. Used to avoid allocations for
-        /// perfoming IndexOf etc.
+        /// performing IndexOf etc.
         /// </summary>
         private static CompareInfo s_invariantCompareInfo = CultureInfo.InvariantCulture.CompareInfo;
 
@@ -441,7 +448,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
 
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
-            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
+            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, loggingContext);
             result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
@@ -871,8 +878,9 @@ private static class MetadataExpander
             /// <param name="metadata">The metadata to be expanded.</param>
             /// <param name="options">Used to specify what to expand.</param>
             /// <param name="elementLocation">The location information for error reporting purposes.</param>
+            /// <param name="loggingContext">The logging context for this operation.</param>
             /// <returns>The string with item metadata expanded in-place, escaped.</returns>
-            internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation)
+            internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
             {
                 try
                 {
@@ -896,7 +904,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                     {
                         // if there are no item vectors in the string
                         // run a simpler Regex to find item metadata references
-                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options);
+                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options, elementLocation, loggingContext);
                         result = RegularExpressions.ItemMetadataPattern.Value.Replace(expression, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata));
                     }
                     else
@@ -915,7 +923,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         using SpanBasedStringBuilder finalResultBuilder = Strings.GetSpanBasedStringBuilder();
 
                         int start = 0;
-                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options);
+                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options, elementLocation, loggingContext);
 
                         if (itemVectorExpressions != null)
                         {
@@ -993,13 +1001,23 @@ private class MetadataMatchEvaluator
                 /// </summary>
                 private ExpanderOptions _options;
 
+                private IElementLocation _elementLocation;
+
+                private LoggingContext _loggingContext;
+
                 /// <summary>
                 /// Constructor taking a source of metadata.
                 /// </summary>
-                internal MetadataMatchEvaluator(IMetadataTable metadata, ExpanderOptions options)
+                internal MetadataMatchEvaluator(
+                    IMetadataTable metadata,
+                    ExpanderOptions options,
+                    IElementLocation elementLocation,
+                    LoggingContext loggingContext)
                 {
                     _metadata = metadata;
-                    _options = options & (ExpanderOptions.ExpandMetadata | ExpanderOptions.Truncate);
+                    _options = options & (ExpanderOptions.ExpandMetadata | ExpanderOptions.Truncate | ExpanderOptions.LogOnItemMetadataSelfReference);
+                    _elementLocation = elementLocation;
+                    _loggingContext = loggingContext;
 
                     ErrorUtilities.VerifyThrow(options != ExpanderOptions.Invalid, "Must be expanding metadata of some kind");
                 }
@@ -1030,6 +1048,17 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
                        (!isBuiltInMetadata && ((_options & ExpanderOptions.ExpandCustomMetadata) != 0)))
                     {
                         metadataValue = _metadata.GetEscapedValue(itemType, metadataName);
+
+                        if ((_options & ExpanderOptions.LogOnItemMetadataSelfReference) != 0 &&
+                            _loggingContext != null &&
+                            !string.IsNullOrEmpty(metadataName) &&
+                            _metadata is IItemTypeDefinition itemMetadata &&
+                            (string.IsNullOrEmpty(itemType) || string.Equals(itemType, itemMetadata.ItemType, StringComparison.Ordinal)))
+                        {
+                            _loggingContext.LogComment(MessageImportance.Low, new BuildEventFileInfo(_elementLocation),
+                                "ItemReferencingSelfInTarget", itemMetadata.ItemType, metadataName);
+                        }
+
                         if (IsTruncationEnabled(_options) && metadataValue.Length > CharacterLimitPerExpansion)
                         {
                             metadataValue = metadataValue.Substring(0, CharacterLimitPerExpansion - 3) + "...";
@@ -1309,7 +1338,7 @@ internal static object ExpandPropertyBody(
                         if (function != null)
                         {
                             // We will have either extracted the actual property name
-                            // or realised that there is none (static function), and have recorded a null
+                            // or realized that there is none (static function), and have recorded a null
                             propertyName = function.Receiver;
                         }
                         else
@@ -1492,18 +1521,16 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                     // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
                     // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
                     //
-                    // Another pattern used is where a property concatonates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
+                    // Another pattern used is where a property concatenates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
                     // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
                     if (usedUninitializedProperties.Warn && usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName != null)
                     {
                         // Check to see if the property name does not match the property we are currently evaluating, note the property we are currently evaluating in the element name, this means no $( or )
                         if (!MSBuildNameIgnoreCaseComparer.Default.Equals(usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName, propertyName, startIndex, endIndex - startIndex + 1))
                         {
-                            string propertyTrimed = propertyName.Substring(startIndex, endIndex - startIndex + 1);
-                            if (!usedUninitializedProperties.Properties.ContainsKey(propertyTrimed))
-                            {
-                                usedUninitializedProperties.Properties.Add(propertyTrimed, elementLocation);
-                            }
+                            usedUninitializedProperties.TryAdd(
+                                propertyName: propertyName.Substring(startIndex, endIndex - startIndex + 1),
+                                elementLocation);
                         }
                     }
 
@@ -2554,12 +2581,9 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
                             {
                                 metadataValue = item.Value.GetMetadataValueEscaped(metadataName);
                             }
-                            catch (ArgumentException ex) // Blank metadata name
-                            {
-                                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
-                            }
-                            catch (InvalidOperationException ex)
+                            catch (Exception ex) when (ex is ArgumentException || ex is InvalidOperationException)
                             {
+                                // Blank metadata name
                                 ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
                             }
 
@@ -2759,12 +2783,9 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                         {
                             metadataValue = item.Value.GetMetadataValueEscaped(metadataName);
                         }
-                        catch (ArgumentException ex) // Blank metadata name
-                        {
-                            ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
-                        }
-                        catch (InvalidOperationException ex)
+                        catch (Exception ex) when (ex is ArgumentException || ex is InvalidOperationException)
                         {
+                            // Blank metadata name
                             ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
                         }
 
@@ -2797,16 +2818,46 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                         {
                             metadataValue = item.Value.GetMetadataValueEscaped(metadataName);
                         }
-                        catch (ArgumentException ex) // Blank metadata name
+                        catch (Exception ex) when (ex is ArgumentException || ex is InvalidOperationException)
                         {
+                            // Blank metadata name
                             ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
                         }
-                        catch (InvalidOperationException ex)
+
+                        if (metadataValue != null && String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
                         {
+                            // return a result through the enumerator
+                            yield return new Pair<string, S>(item.Key, item.Value);
+                        }
+                    }
+                }
+
+                /// <summary>
+                /// Intrinsic function that returns those items don't have the given metadata value
+                /// Using a case insensitive comparison.
+                /// </summary>
+                internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                {
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
+
+                    string metadataName = arguments[0];
+                    string metadataValueToFind = arguments[1];
+
+                    foreach (Pair<string, S> item in itemsOfType)
+                    {
+                        string metadataValue = null;
+
+                        try
+                        {
+                            metadataValue = item.Value.GetMetadataValueEscaped(metadataName);
+                        }
+                        catch (Exception ex) when (ex is ArgumentException || ex is InvalidOperationException)
+                        {
+                            // Blank metadata name
                             ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
                         }
 
-                        if (metadataValue != null && String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
+                        if (!String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
                         {
                             // return a result through the enumerator
                             yield return new Pair<string, S>(item.Key, item.Value);
@@ -2836,12 +2887,9 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                             {
                                 metadataValue = item.Value.GetMetadataValueEscaped(metadataName);
                             }
-                            catch (ArgumentException ex) // Blank metadata name
-                            {
-                                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
-                            }
-                            catch (InvalidOperationException ex)
+                            catch (Exception ex) when (ex is ArgumentException || ex is InvalidOperationException)
                             {
+                                // Blank metadata name
                                 ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
                             }
 
@@ -3113,7 +3161,7 @@ private struct FunctionBuilder<T>
             /// </summary>
             public UsedUninitializedProperties UsedUninitializedProperties { get; set; }
 
-            internal Function<T> Build()
+            internal readonly Function<T> Build()
             {
                 return new Function<T>(
                     ReceiverType,
@@ -3133,7 +3181,7 @@ internal Function<T> Build()
         /// It is also responsible for executing the function.
         /// </summary>
         /// <typeparam name="T">Type of the properties used to expand the expression.</typeparam>
-        private class Function<T>
+        internal class Function<T>
             where T : class, IProperty
         {
             /// <summary>
@@ -3267,7 +3315,7 @@ internal static Function<T> ExtractPropertyFunction(
                         ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidFunctionStaticMethodSyntax", expressionFunction, String.Empty);
                     }
 
-                    var typeName = expressionRoot.Slice(1, typeEndIndex - 1).ToString();
+                    var typeName = Strings.WeakIntern(expressionRoot.Slice(1, typeEndIndex - 1));
                     var methodStartIndex = typeEndIndex + 1;
 
                     if (expressionRoot.Length > methodStartIndex + 2 && expressionRoot[methodStartIndex] == ':' && expressionRoot[methodStartIndex + 1] == ':')
@@ -3325,7 +3373,7 @@ internal static Function<T> ExtractPropertyFunction(
                     var rootEndIndex = expressionRoot.IndexOf('.');
 
                     // If this is an instance function rather than a static, then we'll capture the name of the property referenced
-                    var functionReceiver = expressionRoot.Slice(0, rootEndIndex).Trim().ToString();
+                    var functionReceiver = Strings.WeakIntern(expressionRoot.Slice(0, rootEndIndex).Trim());
 
                     // If propertyValue is null (we're not recursing), then we're expecting a valid property name
                     if (propertyValue == null && !IsValidPropertyName(functionReceiver))
@@ -3434,6 +3482,13 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     // that it matches the left hand side ready for the default binder‚Äôs method invoke.
                     if (objectInstance != null && args.Length == 1 && (String.Equals("Equals", _methodMethodName, StringComparison.OrdinalIgnoreCase) || String.Equals("CompareTo", _methodMethodName, StringComparison.OrdinalIgnoreCase)))
                     {
+                        // Support comparison when the lhs is an integer
+                        if (IsFloatingPointRepresentation(args[0]) && !IsFloatingPointRepresentation(objectInstance))
+                        {
+                            objectInstance = Convert.ChangeType(objectInstance, typeof(double), CultureInfo.InvariantCulture);
+                            _receiverType = objectInstance.GetType();
+                        }
+
                         // change the type of the final unescaped string into the destination
                         args[0] = Convert.ChangeType(args[0], objectInstance.GetType(), CultureInfo.InvariantCulture);
                     }
@@ -3441,14 +3496,11 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     if (_receiverType == typeof(IntrinsicFunctions))
                     {
                         // Special case a few methods that take extra parameters that can't be passed in by the user
-                        //
-
                         if (_methodMethodName.Equals("GetPathOfFileAbove") && args.Length == 1)
                         {
                             // Append the IElementLocation as a parameter to GetPathOfFileAbove if the user only
                             // specified the file name.  This is syntactic sugar so they don't have to always
                             // include $(MSBuildThisFileDirectory) as a parameter.
-                            //
                             string startingDirectory = String.IsNullOrWhiteSpace(elementLocation.File) ? String.Empty : Path.GetDirectoryName(elementLocation.File);
 
                             args = new[]
@@ -3501,7 +3553,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                                 functionResult = _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture);
                             }
                             // If we're invoking a method, then there are deeper attempts that can be made to invoke the method.
-                            // If not, we were asked to get a property or field but found that we cannot locate it. No further argument coersion is possible, so throw.
+                            // If not, we were asked to get a property or field but found that we cannot locate it. No further argument coercion is possible, so throw.
                             catch (MissingMethodException ex) when ((_bindingFlags & BindingFlags.InvokeMethod) == BindingFlags.InvokeMethod)
                             {
                                 // The standard binder failed, so do our best to coerce types into the arguments for the function
@@ -3887,6 +3939,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Unescape), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.Unescape(arg0);
+                                return true;
+                            }
+                        }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetPathOfFileAbove), StringComparison.OrdinalIgnoreCase))
                         {
                             if (TryGetArgs(args, out string arg0, out string arg1))
@@ -3897,33 +3957,36 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                         }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Add), StringComparison.OrdinalIgnoreCase))
                         {
-                            if (TryGetArgs(args, out double arg0, out double arg1))
+                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Add, IntrinsicFunctions.Add, out returnVal))
                             {
-                                returnVal = arg0 + arg1;
                                 return true;
                             }
                         }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Subtract), StringComparison.OrdinalIgnoreCase))
                         {
-                            if (TryGetArgs(args, out double arg0, out double arg1))
+                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Subtract, IntrinsicFunctions.Subtract, out returnVal))
                             {
-                                returnVal = arg0 - arg1;
                                 return true;
                             }
                         }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Multiply), StringComparison.OrdinalIgnoreCase))
                         {
-                            if (TryGetArgs(args, out double arg0, out double arg1))
+                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Multiply, IntrinsicFunctions.Multiply, out returnVal))
                             {
-                                returnVal = arg0 * arg1;
                                 return true;
                             }
                         }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Divide), StringComparison.OrdinalIgnoreCase))
                         {
-                            if (TryGetArgs(args, out double arg0, out double arg1))
+                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Divide, IntrinsicFunctions.Divide, out returnVal))
+                            {
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Modulo), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Modulo, IntrinsicFunctions.Modulo, out returnVal))
                             {
-                                returnVal = arg0 / arg1;
                                 return true;
                             }
                         }
@@ -4113,6 +4176,62 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseOr), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.BitwiseOr(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseAnd), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.BitwiseAnd(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseXor), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.BitwiseXor(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseNot), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0))
+                            {
+                                returnVal = IntrinsicFunctions.BitwiseNot(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.LeftShift), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.LeftShift(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RightShift), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.RightShift(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RightShiftUnsigned), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.RightShiftUnsigned(arg0, arg1);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Path))
                     {
@@ -4415,40 +4534,99 @@ private static bool TryConvertToVersion(object value, out Version arg0)
                 return true;
             }
 
-            private static bool TryConvertToInt(object value, out int arg0)
+            /// <summary>
+            /// Try to convert value to int.
+            /// </summary>
+            internal static bool TryConvertToInt(object value, out int arg)
             {
                 switch (value)
                 {
                     case double d:
-                        arg0 = Convert.ToInt32(d);
-                        return arg0 == d;
+                        if (d >= int.MinValue && d <= int.MaxValue)
+                        {
+                            arg = Convert.ToInt32(d);
+                            if (Math.Abs(arg - d) == 0)
+                            {
+                                return true;
+                            }
+                        }
+
+                        break;
+                    case long l:
+                        if (l >= int.MinValue && l <= int.MaxValue)
+                        {
+                            arg = Convert.ToInt32(l);
+                            return true;
+                        }
+
+                        break;
                     case int i:
-                        arg0 = i;
+                        arg = i;
                         return true;
-                    case string s when int.TryParse(s, out arg0):
+                    case string s when int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture.NumberFormat, out arg):
                         return true;
                 }
 
-                arg0 = 0;
+                arg = 0;
                 return false;
             }
 
-            private static bool TryConvertToDouble(object value, out double arg)
+            /// <summary>
+            /// Try to convert value to long.
+            /// </summary>
+            internal static bool TryConvertToLong(object value, out long arg)
             {
-                if (value is double unboxed)
-                {
-                    arg = unboxed;
-                    return true;
-                }
-                else if (value is string str && double.TryParse(str, out arg))
+                switch (value)
                 {
-                    return true;
+                    case double d:
+                        if (d >= long.MinValue && d <= long.MaxValue)
+                        {
+                            arg = (long)d;
+                            if (Math.Abs(arg - d) == 0)
+                            {
+                                return true;
+                            }
+                        }
+
+                        break;
+                    case long l:
+                        arg = l;
+                        return true;
+                    case int i:
+                        arg = i;
+                        return true;
+                    case string s when long.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture.NumberFormat, out arg):
+                        return true;
                 }
 
                 arg = 0;
                 return false;
             }
 
+            /// <summary>
+            /// Try to convert value to double.
+            /// </summary>
+            internal static bool TryConvertToDouble(object value, out double arg)
+            {
+                switch (value)
+                {
+                    case double unboxed:
+                        arg = unboxed;
+                        return true;
+                    case long l:
+                        arg = l;
+                        return true;
+                    case int i:
+                        arg = i;
+                        return true;
+                    case string str when double.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out arg):
+                        return true;
+                    default:
+                        arg = 0;
+                        return false;
+                }
+            }
+
             private static bool TryGetArg(object[] args, out string arg0)
             {
                 if (args.Length != 1)
@@ -4489,6 +4667,18 @@ private static bool TryGetArgs(object[] args, out string arg0, out StringCompari
                 return Enum.TryParse(comparisonTypeName, out arg1);
             }
 
+            private static bool TryGetArgs(object[] args, out int arg0)
+            {
+                arg0 = 0;
+
+                if (args.Length != 1)
+                {
+                    return false;
+                }
+
+                return TryConvertToInt(args[0], out arg0);
+            }
+
             private static bool TryGetArgs(object[] args, out int arg0, out int arg1)
             {
                 arg0 = 0;
@@ -4564,6 +4754,38 @@ private static bool TryGetArgs(object[] args, out string arg0, out int arg1)
                 return false;
             }
 
+            private static bool IsFloatingPointRepresentation(object value)
+            {
+                return value is double || (value is string str && double.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out double _));
+            }
+
+            private static bool TryExecuteArithmeticOverload(object[] args, Func<long, long, long> integerOperation, Func<double, double, double> realOperation, out object resultValue)
+            {
+                resultValue = null;
+
+                if (args.Length != 2)
+                {
+                    return false;
+                }
+
+                if (IntrinsicFunctionOverload.IsIntrinsicFunctionOverloadsEnabled())
+                {
+                    if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
+                    {
+                        resultValue = integerOperation(argLong0, argLong1);
+                        return true;
+                    }
+                }
+
+                if (TryConvertToDouble(args[0], out double argDouble0) && TryConvertToDouble(args[1], out double argDouble1))
+                {
+                    resultValue = realOperation(argDouble0, argDouble1);
+                    return true;
+                }
+
+                return false;
+            }
+
             [MethodImpl(MethodImplOptions.AggressiveInlining)]
             private void LogFunctionCall(string fileName, object objectInstance, object[] args)
             {
@@ -4594,7 +4816,7 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
                     return null;
                 }
 
-                // Check if the type is in the whitelist cache. If it is, use it or load it.
+                // Check if the type is in the allowlist cache. If it is, use it or load it.
                 cachedTypeInformation = AvailableStaticMethods.GetTypeInformationFromTypeCache(typeName, simpleMethodName);
                 if (cachedTypeInformation != null)
                 {
@@ -4617,7 +4839,7 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
 
                         // If the type information from the cache is not loadable, it means the cache information got corrupted somehow
                         // Throw here to prevent adding null types in the cache
-                        ErrorUtilities.VerifyThrowInternalNull(receiverType, $"Type information for {typeName} was present in the whitelist cache as {assemblyQualifiedTypeName} but the type could not be loaded.");
+                        ErrorUtilities.VerifyThrowInternalNull(receiverType, $"Type information for {typeName} was present in the allowlist cache as {assemblyQualifiedTypeName} but the type could not be loaded.");
 
                         // If we've used it once, chances are that we'll be using it again
                         // We can record the type here since we know it's available for calling from the fact that is was in the AvailableStaticMethods table
@@ -4635,7 +4857,7 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
                     // DO NOT CACHE THE TYPE HERE!
                     // We don't add the resolved type here in the AvailableStaticMethods table. This is because that table is used
                     // during function parse, but only later during execution do we check for the ability to call specific methods on specific types.
-                    // Caching it here would load any type into the white list.
+                    // Caching it here would load any type into the allow list.
                     return receiverType;
                 }
 
@@ -5038,7 +5260,7 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
             }
 
             /// <summary>
-            /// Check the property function whitelist whether this method is available.
+            /// Check the property function allowlist whether this method is available.
             /// </summary>
             private static bool IsStaticMethodAvailable(Type receiverType, string methodName)
             {
@@ -5076,7 +5298,6 @@ private static bool IsInstanceMethodAvailable(string methodName)
             /// </summary>
             private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object objectInstance /* null unless instance method */, object[] args, bool isConstructor)
             {
-
                 // First let's try for a method where all arguments are strings..
                 Type[] types = new Type[_arguments.Length];
                 for (int n = 0; n < _arguments.Length; n++)
@@ -5098,15 +5319,25 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                 // search for a method with the right number of arguments
                 if (memberInfo == null)
                 {
-                    MethodBase[] members;
                     // Gather all methods that may match
+                    IEnumerable<MethodBase> members;
                     if (isConstructor)
                     {
                         members = _receiverType.GetConstructors(bindingFlags);
                     }
+                    else if (_receiverType == typeof(IntrinsicFunctions) && IntrinsicFunctionOverload.IsKnownOverloadMethodName(_methodMethodName))
+                    {
+                        MemberInfo[] foundMembers = _receiverType.FindMembers(
+                            MemberTypes.Method,
+                            bindingFlags,
+                            (info, criteria) => string.Equals(info.Name, (string)criteria, StringComparison.OrdinalIgnoreCase),
+                            _methodMethodName);
+                        Array.Sort(foundMembers, IntrinsicFunctionOverload.IntrinsicFunctionOverloadMethodComparer);
+                        members = foundMembers.Cast<MethodBase>();
+                    }
                     else
                     {
-                        members = _receiverType.GetMethods(bindingFlags);
+                        members = _receiverType.GetMethods(bindingFlags).Where(m => string.Equals(m.Name, _methodMethodName, StringComparison.OrdinalIgnoreCase));
                     }
 
                     foreach (MethodBase member in members)
@@ -5116,22 +5347,19 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                         // Simple match on name and number of params, we will be case insensitive
                         if (parameters.Length == _arguments.Length)
                         {
-                            if (isConstructor || String.Equals(member.Name, _methodMethodName, StringComparison.OrdinalIgnoreCase))
+                            // Try to find a method with the right name, number of arguments and
+                            // compatible argument types
+                            // we have a match on the name and argument number
+                            // now let's try to coerce the arguments we have
+                            // into the arguments on the matching method
+                            object[] coercedArguments = CoerceArguments(args, parameters);
+
+                            if (coercedArguments != null)
                             {
-                                // Try to find a method with the right name, number of arguments and
-                                // compatible argument types
-                                // we have a match on the name and argument number
-                                // now let's try to coerce the arguments we have
-                                // into the arguments on the matching method
-                                object[] coercedArguments = CoerceArguments(args, parameters);
-
-                                if (coercedArguments != null)
-                                {
-                                    // We have a complete match
-                                    memberInfo = member;
-                                    args = coercedArguments;
-                                    break;
-                                }
+                                // We have a complete match
+                                memberInfo = member;
+                                args = coercedArguments;
+                                break;
                             }
                         }
                     }
@@ -5166,26 +5394,45 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
         }
     }
 
+#nullable enable
     /// <summary>
     /// This class wraps information about properties which have been used before they are initialized.
     /// </summary>
-    internal class UsedUninitializedProperties
+    internal sealed class UsedUninitializedProperties
     {
         /// <summary>
-        /// This class wraps information about properties which have been used before they are initialized.
+        /// Lazily allocated collection of properties and the element which used them.
         /// </summary>
-        internal UsedUninitializedProperties()
+        private Dictionary<string, IElementLocation>? _properties;
+
+        internal void TryAdd(string propertyName, IElementLocation elementLocation)
         {
-            Properties = new Dictionary<string, IElementLocation>(StringComparer.OrdinalIgnoreCase);
+            if (_properties is null)
+            {
+                _properties = new(StringComparer.OrdinalIgnoreCase);
+            }
+            else if (_properties.ContainsKey(propertyName))
+            {
+                return;
+            }
+
+            _properties.Add(propertyName, elementLocation);
         }
 
-        /// <summary>
-        /// Hash set of properties which have been used before being initialized.
-        /// </summary>
-        internal IDictionary<string, IElementLocation> Properties
+        internal bool TryGetPropertyElementLocation(string propertyName, [NotNullWhen(returnValue: true)] out IElementLocation? elementLocation)
         {
-            get;
-            set;
+            if (_properties is null)
+            {
+                elementLocation = null;
+                return false;
+            }
+
+            return _properties.TryGetValue(propertyName, out elementLocation);
+        }
+
+        internal void RemoveProperty(string propertyName)
+        {
+            _properties?.Remove(propertyName);
         }
 
         /// <summary>
@@ -5200,10 +5447,48 @@ internal bool Warn
         /// <summary>
         ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
         /// </summary>
-        internal string CurrentlyEvaluatingPropertyElementName
+        internal string? CurrentlyEvaluatingPropertyElementName
         {
             get;
             set;
         }
     }
+
+    internal static class IntrinsicFunctionOverload
+    {
+        private static readonly string[] s_knownOverloadName = { "Add", "Subtract", "Multiply", "Divide", "Modulo", };
+
+        // Order by the TypeCode of the first parameter.
+        // When change wave is enabled, order long before double.
+        // Otherwise preserve prior behavior of double before long.
+        // For reuse, the comparer is cached in a non-generic type.
+        // Both comparer instances can be cached to support change wave testing.
+        private static IComparer<MemberInfo>? s_comparerLongBeforeDouble;
+        private static IComparer<MemberInfo>? s_comparerDoubleBeforeLong;
+
+        internal static IComparer<MemberInfo> IntrinsicFunctionOverloadMethodComparer => IsIntrinsicFunctionOverloadsEnabled() ? LongBeforeDoubleComparer : DoubleBeforeLongComparer;
+
+        private static IComparer<MemberInfo> LongBeforeDoubleComparer => s_comparerLongBeforeDouble ??= Comparer<MemberInfo>.Create((key0, key1) => SelectTypeOfFirstParameter(key0).CompareTo(SelectTypeOfFirstParameter(key1)));
+
+        private static IComparer<MemberInfo> DoubleBeforeLongComparer => s_comparerDoubleBeforeLong ??= Comparer<MemberInfo>.Create((key0, key1) => SelectTypeOfFirstParameter(key1).CompareTo(SelectTypeOfFirstParameter(key0)));
+
+        // The arithmetic overload feature uses this method to test for the change wave.
+        internal static bool IsIntrinsicFunctionOverloadsEnabled() => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8);
+
+        internal static bool IsKnownOverloadMethodName(string methodName) => s_knownOverloadName.Any(name => string.Equals(name, methodName, StringComparison.OrdinalIgnoreCase));
+
+        private static TypeCode SelectTypeOfFirstParameter(MemberInfo member)
+        {
+            MethodBase? method = member as MethodBase;
+            if (method == null)
+            {
+                return TypeCode.Empty;
+            }
+
+            ParameterInfo[] parameters = method.GetParameters();
+            return parameters.Length > 0
+                ? Type.GetTypeCode(parameters[0].ParameterType)
+                : TypeCode.Empty;
+        }
+    }
 }
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index c555a10d0e2..360843f9b58 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -156,10 +156,7 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
 
                     // Grab the name, but continue to verify it's a well-formed expression
                     // before we store it.
-                    string name = expression.Substring(startOfName, i - startOfName);
-
-                    // return the item that we're working with
-                    string itemName = name;
+                    string itemName = Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startOfName, i - startOfName));
 
                     SinkWhitespace(expression, ref i);
                     bool transformOrFunctionFound = true;
@@ -251,10 +248,10 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
                         subExpressions = new List<ItemExpressionCapture>();
                     }
 
-                    // Create an expression capture that encompases the entire expression between the @( and the )
+                    // Create an expression capture that encompasses the entire expression between the @( and the )
                     // with the item name and any separator contained within it
                     // and each transform expression contained within it (i.e. each ->XYZ)
-                    ItemExpressionCapture expressionCapture = new ItemExpressionCapture(startPoint, endPoint - startPoint, expression.Substring(startPoint, endPoint - startPoint), itemName, separator, separatorStart, transformExpressions);
+                    ItemExpressionCapture expressionCapture = new ItemExpressionCapture(startPoint, endPoint - startPoint, Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startPoint, endPoint - startPoint)), itemName, separator, separatorStart, transformExpressions);
                     subExpressions.Add(expressionCapture);
 
                     continue;
@@ -601,7 +598,7 @@ private static ItemExpressionCapture SinkItemFunctionExpression(string expressio
 
                     if (endFunctionArguments > startFunctionArguments)
                     {
-                        capture.FunctionArguments = expression.Substring(startFunctionArguments, endFunctionArguments - startFunctionArguments);
+                        capture.FunctionArguments = Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startFunctionArguments, endFunctionArguments - startFunctionArguments));
                     }
 
                     return capture;
diff --git a/src/Build/Evaluation/IItem.cs b/src/Build/Evaluation/IItem.cs
index 1365978c41d..4483fb437e7 100644
--- a/src/Build/Evaluation/IItem.cs
+++ b/src/Build/Evaluation/IItem.cs
@@ -39,7 +39,7 @@ string ProjectDirectory
 
         /// <summary>
         /// Returns the metadata with the specified key.
-        /// Returns null if it does not exist.
+        /// Returns an empty string if it does not exist.
         /// Attempting to get built-in metadata on a value that is not a valid path throws InvalidOperationException.
         /// Metadata value is unescaped.
         /// </summary>
@@ -47,7 +47,7 @@ string ProjectDirectory
 
         /// <summary>
         /// Returns the metadata with the specified key.
-        /// Returns null if it does not exist.
+        /// Returns an empty string if it does not exist.
         /// Attempting to get built-in metadata on a value that is not a valid path throws InvalidOperationException.
         /// Metadata value is the escaped value initially set.
         /// </summary>
diff --git a/src/Build/Evaluation/IItemTypeDefinition.cs b/src/Build/Evaluation/IItemTypeDefinition.cs
new file mode 100644
index 00000000000..4d594e6ff39
--- /dev/null
+++ b/src/Build/Evaluation/IItemTypeDefinition.cs
@@ -0,0 +1,12 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Evaluation;
+
+internal interface IItemTypeDefinition
+{
+    /// <summary>
+    /// The item type to which this metadata applies.
+    /// </summary>
+    string ItemType { get; }
+}
diff --git a/src/Build/Evaluation/IMetadataTable.cs b/src/Build/Evaluation/IMetadataTable.cs
index e7c20680216..85a5505cefc 100644
--- a/src/Build/Evaluation/IMetadataTable.cs
+++ b/src/Build/Evaluation/IMetadataTable.cs
@@ -1,8 +1,6 @@
 Ôªø// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -21,12 +19,12 @@ internal interface IMetadataTable
         /// If item type is null, it is ignored.
         /// If no value is available, returns empty string.
         /// </summary>
-        string GetEscapedValue(string itemType, string name);
+        string GetEscapedValue(string? itemType, string name);
 
         /// <summary>
         /// Returns the value if it exists, null otherwise.
         /// If item type is null, it is ignored.
         /// </summary>
-        string GetEscapedValueIfPresent(string itemType, string name);
+        string? GetEscapedValueIfPresent(string? itemType, string name);
     }
 }
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 45ebc5e9a0c..3fff5c28e65 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -165,6 +165,21 @@ internal static int BitwiseNot(int first)
             return ~first;
         }
 
+        internal static int LeftShift(int operand, int count)
+        {
+            return operand << count;
+        }
+
+        internal static int RightShift(int operand, int count)
+        {
+            return operand >> count;
+        }
+
+        internal static int RightShiftUnsigned(int operand, int count)
+        {
+            return operand >>> count;
+        }
+
         /// <summary>
         /// Get the value of the registry key and value, default value is null
         /// </summary>
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 89b2ffd1938..c45edf0764b 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -80,7 +80,7 @@ public ItemExpressionFragment(
 
             public override int MatchCount(string itemToMatch)
             {
-                return ReferencedItems.Count(v => v.ItemAsValueFragment.MatchCount(itemToMatch) > 0);
+                return ReferencedItems.Count(v => v.ItemAsValueFragment.IsMatch(itemToMatch));
             }
 
             public override bool IsMatch(string itemToMatch)
diff --git a/src/Build/Evaluation/ItemsAndMetadataPair.cs b/src/Build/Evaluation/ItemsAndMetadataPair.cs
index 3348d1b1662..9ff1f7c3354 100644
--- a/src/Build/Evaluation/ItemsAndMetadataPair.cs
+++ b/src/Build/Evaluation/ItemsAndMetadataPair.cs
@@ -40,7 +40,7 @@ internal ItemsAndMetadataPair(HashSet<string> items, Dictionary<string, Metadata
         /// </summary>
         internal HashSet<string> Items
         {
-            get
+            readonly get
             {
                 return _items;
             }
@@ -58,7 +58,7 @@ internal HashSet<string> Items
         /// </summary>
         internal Dictionary<string, MetadataReference> Metadata
         {
-            get
+            readonly get
             {
                 return _metadata;
             }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 6bda7df146c..74e43ce6c93 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -3,6 +3,8 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Immutable;
+
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
@@ -19,13 +21,13 @@ internal partial class LazyItemEvaluator<P, I, M, D>
     {
         private class EvaluatorData : IEvaluatorData<P, I, M, D>
         {
-            private IEvaluatorData<P, I, M, D> _wrappedData;
-            private Func<string, ICollection<I>> _itemGetter;
+            private readonly IEvaluatorData<P, I, M, D> _wrappedData;
+            private readonly IReadOnlyDictionary<string, LazyItemList> _itemsByType;
 
-            public EvaluatorData(IEvaluatorData<P, I, M, D> wrappedData, Func<string, ICollection<I>> itemGetter)
+            public EvaluatorData(IEvaluatorData<P, I, M, D> wrappedData, IReadOnlyDictionary<string, LazyItemList> itemsByType)
             {
                 _wrappedData = wrappedData;
-                _itemGetter = itemGetter;
+                _itemsByType = itemsByType;
             }
 
             public ItemDictionary<I> Items
@@ -46,10 +48,11 @@ public List<ProjectItemElement> EvaluatedItemElements
 
             public ICollection<I> GetItems(string itemType)
             {
-                return _itemGetter(itemType);
+                return _itemsByType.TryGetValue(itemType, out LazyItemList items)
+                    ? items.GetMatchedItems(globsToIgnore: ImmutableHashSet<string>.Empty)
+                    : Array.Empty<I>();
             }
 
-
             public IDictionary<string, List<TargetSpecification>> AfterTargets
             {
                 get
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index f35b4cc322a..6adca4bf208 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -12,8 +12,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.CodeAnalysis.Collections;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     internal partial class LazyItemEvaluator<P, I, M, D>
@@ -21,9 +19,9 @@ internal partial class LazyItemEvaluator<P, I, M, D>
         private class IncludeOperation : LazyItemOperation
         {
             private readonly int _elementOrder;
-            private readonly string _rootDirectory;
+            private readonly string? _rootDirectory;
             private readonly ImmutableSegmentedList<string> _excludes;
-            private readonly ImmutableList<ProjectMetadataElement> _metadata;
+            private readonly ImmutableArray<ProjectMetadataElement> _metadata;
 
             public IncludeOperation(IncludeOperationBuilder builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)
                 : base(builder, lazyEvaluator)
@@ -35,11 +33,11 @@ public IncludeOperation(IncludeOperationBuilder builder, LazyItemEvaluator<P, I,
                 _metadata = builder.Metadata.ToImmutable();
             }
 
-            protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+            protected override ImmutableArray<I> SelectItems(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
-                var itemsToAdd = ImmutableList.CreateBuilder<I>();
+                ImmutableArray<I>.Builder? itemsToAdd = null;
 
-                Lazy<Func<string, bool>> excludeTester = null;
+                Lazy<Func<string, bool>>? excludeTester = null;
                 ImmutableList<string>.Builder excludePatterns = ImmutableList.CreateBuilder<string>();
                 if (_excludes != null)
                 {
@@ -57,7 +55,7 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                     }
                 }
 
-                ISet<string> excludePatternsForGlobs = null;
+                ISet<string>? excludePatternsForGlobs = null;
 
                 foreach (var fragment in _itemSpec.Fragments)
                 {
@@ -73,6 +71,7 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                             isTransformExpression: out _,
                             elementLocation: _itemElement.IncludeLocation);
 
+                        itemsToAdd ??= ImmutableArray.CreateBuilder<I>();
                         itemsToAdd.AddRange(
                             excludeTester != null
                                 ? itemsFromExpression.Where(item => !excludeTester.Value(item.EvaluatedInclude))
@@ -84,8 +83,8 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
 
                         if (excludeTester?.Value(EscapingUtilities.UnescapeAll(value)) != true)
                         {
-                            var item = _itemFactory.CreateItem(value, value, _itemElement.ContainingProject.FullPath);
-                            itemsToAdd.Add(item);
+                            itemsToAdd ??= ImmutableArray.CreateBuilder<I>();
+                            itemsToAdd.Add(_itemFactory.CreateItem(value, value, _itemElement.ContainingProject.FullPath));
                         }
                     }
                     else if (fragment is GlobFragment globFragment)
@@ -127,6 +126,7 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
 
                             foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
                             {
+                                itemsToAdd ??= ImmutableArray.CreateBuilder<I>();
                                 itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));
                             }
                         }
@@ -137,7 +137,7 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                     }
                 }
 
-                return itemsToAdd.ToImmutable();
+                return itemsToAdd?.ToImmutable() ?? ImmutableArray<I>.Empty;
             }
 
             private static ISet<string> BuildExcludePatternsForGlobs(ImmutableHashSet<string> globsToIgnore, ImmutableList<string>.Builder excludePatterns)
@@ -153,12 +153,12 @@ private static ISet<string> BuildExcludePatternsForGlobs(ImmutableHashSet<string
                 return anyExcludes ? excludePatterns.ToImmutableHashSet() : globsToIgnore;
             }
 
-            protected override void MutateItems(ImmutableList<I> items)
+            protected override void MutateItems(ImmutableArray<I> items)
             {
                 DecorateItemsWithMetadata(items.Select(i => new ItemBatchingContext(i)), _metadata);
             }
 
-            protected override void SaveItems(ImmutableList<I> items, OrderedItemDataCollection.Builder listBuilder)
+            protected override void SaveItems(ImmutableArray<I> items, OrderedItemDataCollection.Builder listBuilder)
             {
                 foreach (var item in items)
                 {
@@ -170,7 +170,7 @@ protected override void SaveItems(ImmutableList<I> items, OrderedItemDataCollect
         private class IncludeOperationBuilder : OperationBuilderWithMetadata
         {
             public int ElementOrder { get; set; }
-            public string RootDirectory { get; set; }
+            public string? RootDirectory { get; set; }
 
             public ImmutableSegmentedList<string>.Builder Excludes { get; } = ImmutableSegmentedList.CreateBuilder<string>();
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index bd7933842b0..43fffb961a6 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -43,7 +43,7 @@ protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M,
 
                 _lazyEvaluator = lazyEvaluator;
 
-                _evaluatorData = new EvaluatorData(_lazyEvaluator._outerEvaluatorData, itemType => GetReferencedItems(itemType, ImmutableHashSet<string>.Empty));
+                _evaluatorData = new EvaluatorData(_lazyEvaluator._outerEvaluatorData, _referencedItemLists);
                 _itemFactory = new ItemFactoryWrapper(_itemElement, _lazyEvaluator._itemFactory);
                 _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, _lazyEvaluator.EvaluationContext);
 
@@ -72,28 +72,16 @@ protected virtual void ApplyImpl(OrderedItemDataCollection.Builder listBuilder,
             /// <summary>
             /// Produce the items to operate on. For example, create new ones or select existing ones
             /// </summary>
-            protected virtual ImmutableList<I> SelectItems(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+            protected virtual ImmutableArray<I> SelectItems(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
                 return listBuilder.Select(itemData => itemData.Item)
-                                  .ToImmutableList();
+                                  .ToImmutableArray();
             }
 
             // todo Refactoring: MutateItems should clone each item before mutation. See https://github.com/dotnet/msbuild/issues/2328
-            protected virtual void MutateItems(ImmutableList<I> items) { }
+            protected virtual void MutateItems(ImmutableArray<I> items) { }
 
-            protected virtual void SaveItems(ImmutableList<I> items, OrderedItemDataCollection.Builder listBuilder) { }
-
-            private IList<I> GetReferencedItems(string itemType, ImmutableHashSet<string> globsToIgnore)
-            {
-                if (_referencedItemLists.TryGetValue(itemType, out var itemList))
-                {
-                    return itemList.GetMatchedItems(globsToIgnore);
-                }
-                else
-                {
-                    return ImmutableList<I>.Empty;
-                }
-            }
+            protected virtual void SaveItems(ImmutableArray<I> items, OrderedItemDataCollection.Builder listBuilder) { }
 
             [DebuggerDisplay(@"{DebugString()}")]
             protected readonly struct ItemBatchingContext
@@ -174,9 +162,9 @@ private string RouteCall(string itemType, string name, Func<IMetadataTable, stri
                 }
             }
 
-            protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBatchingContexts, ImmutableList<ProjectMetadataElement> metadata, bool? needToExpandMetadata = null)
+            protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBatchingContexts, ImmutableArray<ProjectMetadataElement> metadata, bool? needToExpandMetadata = null)
             {
-                if (metadata.Count > 0)
+                if (metadata.Length > 0)
                 {
                     ////////////////////////////////////////////////////
                     // UNDONE: Implement batching here.
@@ -238,11 +226,11 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                     {
                         // Metadata expressions are allowed here.
                         // Temporarily gather and expand these in a table so they can reference other metadata elements above.
-                        EvaluatorMetadataTable metadataTable = new EvaluatorMetadataTable(_itemType);
+                        EvaluatorMetadataTable metadataTable = new EvaluatorMetadataTable(_itemType, capacity: metadata.Length);
                         _expander.Metadata = metadataTable;
 
                         // Also keep a list of everything so we can get the predecessor objects correct.
-                        List<Pair<ProjectMetadataElement, string>> metadataList = new List<Pair<ProjectMetadataElement, string>>(metadata.Count);
+                        List<Pair<ProjectMetadataElement, string>> metadataList = new(metadata.Length);
 
                         foreach (var metadataElement in metadata)
                         {
@@ -282,7 +270,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                 }
             }
 
-            private static IEnumerable<string> GetMetadataValuesAndConditions(ImmutableList<ProjectMetadataElement> metadata)
+            private static IEnumerable<string> GetMetadataValuesAndConditions(ImmutableArray<ProjectMetadataElement> metadata)
             {
                 foreach (var metadataElement in metadata)
                 {
@@ -291,7 +279,7 @@ private static IEnumerable<string> GetMetadataValuesAndConditions(ImmutableList<
                 }
             }
 
-            protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElement> metadata, out ItemsAndMetadataPair itemsAndMetadataFound)
+            protected bool NeedToExpandMetadataForEachItem(ImmutableArray<ProjectMetadataElement> metadata, out ItemsAndMetadataPair itemsAndMetadataFound)
             {
                 itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetMetadataValuesAndConditions(metadata));
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index e773885225b..862e4e986a5 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -16,7 +16,7 @@ internal partial class LazyItemEvaluator<P, I, M, D>
     {
         private class UpdateOperation : LazyItemOperation
         {
-            private readonly ImmutableList<ProjectMetadataElement> _metadata;
+            private readonly ImmutableArray<ProjectMetadataElement> _metadata;
             private ImmutableList<ItemBatchingContext>.Builder _itemsToUpdate = null;
             private ItemSpecMatchesItem _matchItemSpec = null;
             private bool? _needToExpandMetadataForEachItem = null;
@@ -147,7 +147,7 @@ private void SetMatchItemSpec()
                 }
             }
 
-            private bool QualifiedMetadataReferencesExist(ImmutableList<ProjectMetadataElement> metadata, out bool? needToExpandMetadataForEachItem)
+            private bool QualifiedMetadataReferencesExist(ImmutableArray<ProjectMetadataElement> metadata, out bool? needToExpandMetadataForEachItem)
             {
                 needToExpandMetadataForEachItem = NeedToExpandMetadataForEachItem(metadata, out var itemsAndMetadataFound);
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index e02ef565869..bd34997b839 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -52,7 +52,7 @@ public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> ite
         {
             _outerEvaluatorData = data;
             _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext);
-            _evaluatorData = new EvaluatorData(_outerEvaluatorData, itemType => GetItems(itemType));
+            _evaluatorData = new EvaluatorData(_outerEvaluatorData, _itemLists);
             _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext);
             _itemFactory = itemFactory;
             _loggingContext = loggingContext;
@@ -61,13 +61,6 @@ public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> ite
             EvaluationContext = evaluationContext;
         }
 
-        private ImmutableList<I> GetItems(string itemType)
-        {
-            return _itemLists.TryGetValue(itemType, out LazyItemList itemList) ?
-                itemList.GetMatchedItems(ImmutableHashSet<string>.Empty) :
-                ImmutableList<I>.Empty;
-        }
-
         public bool EvaluateConditionWithCurrentState(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions)
         {
             return EvaluateCondition(element.Condition, element, expanderOptions, parserOptions, _expander, this);
@@ -135,7 +128,7 @@ public ItemData(I item, ProjectItemElement originatingItemElement, int elementOr
                 _normalizedItemValue = normalizedItemValue;
             }
 
-            public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initialItemElementForFactory)
+            public readonly ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initialItemElementForFactory)
             {
                 // setting the factory's item element to the original item element that produced the item
                 // otherwise you get weird things like items that appear to have been produced by update elements
@@ -492,7 +485,7 @@ public OperationBuilder(ProjectItemElement itemElement, bool conditionResult)
 
         private class OperationBuilderWithMetadata : OperationBuilder
         {
-            public ImmutableList<ProjectMetadataElement>.Builder Metadata = ImmutableList.CreateBuilder<ProjectMetadataElement>();
+            public readonly ImmutableArray<ProjectMetadataElement>.Builder Metadata = ImmutableArray.CreateBuilder<ProjectMetadataElement>();
 
             public OperationBuilderWithMetadata(ProjectItemElement itemElement, bool conditionResult) : base(itemElement, conditionResult)
             {
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index e622acbfdc5..5de3520dab8 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -324,7 +324,7 @@ private ProjectItemElement ParseProjectItemElement(XmlElementWithLocation elemen
                 }
                 else if (isValidMetadataNameInAttribute)
                 {
-                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute.Name, attribute.Value);
+                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute);
                     metadatum.ExpressedAsAttribute = true;
                     metadatum.Parent = item;
 
@@ -744,7 +744,7 @@ private ProjectItemDefinitionElement ParseProjectItemDefinitionXml(XmlElementWit
                 }
                 else if (isValidMetadataNameInAttribute)
                 {
-                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute.Name, attribute.Value);
+                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute);
                     metadatum.ExpressedAsAttribute = true;
                     metadatum.Parent = itemDefinition;
 
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 3303e62a056..0a910c0a334 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -522,25 +522,27 @@ internal override void DiscardImplicitReferences()
                 LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
                 _strongCache = new LinkedList<ProjectRootElement>();
 
-                foreach (string projectPath in oldWeakCache.Keys)
+                foreach (KeyValuePair<string, ProjectRootElement> kvp in oldWeakCache)
                 {
-                    ProjectRootElement rootElement;
+                    if (kvp.Value is null)
+                    {
+                        continue;
+                    }
 
-                    if (oldWeakCache.TryGetValue(projectPath, out rootElement))
+                    if (kvp.Value.IsExplicitlyLoaded)
                     {
-                        if (rootElement.IsExplicitlyLoaded)
-                        {
-                            _weakCache[projectPath] = rootElement;
-                        }
+                        _weakCache[kvp.Key] = kvp.Value;
+                    }
 
-                        if (rootElement.IsExplicitlyLoaded && oldStrongCache.Contains(rootElement))
+                    if (oldStrongCache.Contains(kvp.Value))
+                    {
+                        if (kvp.Value.IsExplicitlyLoaded)
                         {
-                            _strongCache.AddFirst(rootElement);
+                            _strongCache.AddFirst(kvp.Value);
                         }
                         else
                         {
-                            _strongCache.Remove(rootElement);
-                            RaiseProjectRootElementRemovedFromStrongCache(rootElement);
+                            RaiseProjectRootElementRemovedFromStrongCache(kvp.Value);
                         }
                     }
                 }
diff --git a/src/Build/FileAccess/DesiredAccess.cs b/src/Build/FileAccess/DesiredAccess.cs
new file mode 100644
index 00000000000..b9bdea98c0f
--- /dev/null
+++ b/src/Build/FileAccess/DesiredAccess.cs
@@ -0,0 +1,112 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.DesiredAccess.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// The requested access to the file or device.
+    /// </summary>
+    /// <remarks>
+    /// See https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants for a full list of values.
+    /// </remarks>
+    [Flags]
+    [CLSCompliant(false)]
+    public enum DesiredAccess : uint
+    {
+        /// <summary>
+        /// For a directory, the right to list the contents of the directory.
+        /// </summary>
+        FILE_LIST_DIRECTORY = 0x00000001,
+
+        /// <summary>
+        /// For a directory, the right to create a file in the directory.
+        /// </summary>
+        FILE_ADD_FILE = 0x00000002,
+
+        /// <summary>
+        /// For a directory, the right to create a subdirectory.
+        /// </summary>
+        FILE_ADD_SUBDIRECTORY = 0x00000004,
+
+        /// <summary>
+        /// The right to read extended file attributes.
+        /// </summary>
+        FILE_READ_EA = 0x00000008,
+
+        /// <summary>
+        /// Right to delete an object.
+        /// </summary>
+        DELETE = 0x00010000,
+
+        /// <summary>
+        /// Right to wait on a handle.
+        /// </summary>
+        SYNCHRONIZE = 0x00100000,
+
+        /// <summary>
+        /// For a file object, the right to append data to the file. (For local files, write operations will not overwrite existing
+        /// data if this flag is specified without <see cref="FILE_WRITE_DATA"/>.) For a directory object, the right to create a subdirectory
+        /// (<see cref="FILE_ADD_SUBDIRECTORY"/>).
+        /// </summary>
+        FILE_APPEND_DATA = 0x00000004,
+
+        /// <summary>
+        /// The right to write extended file attributes.
+        /// </summary>
+        FILE_WRITE_EA = 0x00000010,
+
+        /// <summary>
+        /// For a native code file, the right to execute the file. This access right given to scripts may cause the script to be executable, depending on the script interpreter.
+        /// </summary>
+        FILE_EXECUTE = 0x00000020,
+
+        /// <summary>
+        /// For a directory, the right to delete a directory and all the files it contains, including read-only files.
+        /// </summary>
+        FILE_DELETE_CHILD = 0x00000040,
+
+        /// <summary>
+        /// The right to read file attributes.
+        /// </summary>
+        FILE_READ_ATTRIBUTES = 0x00000080,
+
+        /// <summary>
+        /// The right to write file attributes.
+        /// </summary>
+        FILE_WRITE_ATTRIBUTES = 0x00000100,
+
+        /// <summary>
+        /// For a file object, the right to write data to the file. For a directory object, the right to create a file in the
+        /// directory (<see cref="FILE_ADD_FILE"/>).
+        /// </summary>
+        FILE_WRITE_DATA = 0x00000002,
+
+        /// <summary>
+        /// All possible access rights.
+        /// </summary>
+        GENERIC_ALL = 0x10000000,
+
+        /// <summary>
+        /// Execute access.
+        /// </summary>
+        GENERIC_EXECUTE = 0x20000000,
+
+        /// <summary>
+        /// Write access.
+        /// </summary>
+        GENERIC_WRITE = 0x40000000,
+
+        /// <summary>
+        /// Read access.
+        /// </summary>
+        GENERIC_READ = 0x80000000,
+    }
+}
diff --git a/src/Build/FileAccess/FileAccessData.cs b/src/Build/FileAccess/FileAccessData.cs
new file mode 100644
index 00000000000..64cd45a92d4
--- /dev/null
+++ b/src/Build/FileAccess/FileAccessData.cs
@@ -0,0 +1,125 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /// <summary>
+    /// File access data.
+    /// </summary>
+    [CLSCompliant(false)]
+    public struct FileAccessData
+        : ITranslatable
+    {
+        private ReportedFileOperation _operation;
+        private RequestedAccess _requestedAccess;
+        private uint _processId;
+        private uint _error;
+        private DesiredAccess _desiredAccess;
+        private FlagsAndAttributes _flagsAndAttributes;
+        private string _path;
+        private string? _processArgs;
+        private bool _isAnAugmentedFileAccess;
+
+        public FileAccessData(
+            ReportedFileOperation operation,
+            RequestedAccess requestedAccess,
+            uint processId,
+            uint error,
+            DesiredAccess desiredAccess,
+            FlagsAndAttributes flagsAndAttributes,
+            string path,
+            string? processArgs,
+            bool isAnAugmentedFileAccess)
+        {
+            _operation = operation;
+            _requestedAccess = requestedAccess;
+            _processId = processId;
+            _error = error;
+            _desiredAccess = desiredAccess;
+            _flagsAndAttributes = flagsAndAttributes;
+            _path = path;
+            _processArgs = processArgs;
+            _isAnAugmentedFileAccess = isAnAugmentedFileAccess;
+        }
+
+        /// <summary>The operation that performed the file access.</summary>
+        public ReportedFileOperation Operation
+        {
+            readonly get => _operation;
+            private set => _operation = value;
+        }
+
+        /// <summary>The requested access.</summary>
+        public RequestedAccess RequestedAccess
+        {
+            get => _requestedAccess;
+            private set => _requestedAccess = value;
+        }
+
+        /// <summary>The process id.</summary>
+        public uint ProcessId
+        {
+            readonly get => _processId;
+            private set => _processId = value;
+        }
+
+        /// <summary>The error code of the operation.</summary>
+        public uint Error
+        {
+            readonly get => _error;
+            private set => _error = value;
+        }
+
+        /// <summary>The desired access.</summary>
+        public DesiredAccess DesiredAccess
+        {
+            readonly get => _desiredAccess;
+            private set => _desiredAccess = value;
+        }
+
+        /// <summary>The file flags and attributes.</summary>
+        public FlagsAndAttributes FlagsAndAttributes
+        {
+            readonly get => _flagsAndAttributes;
+            private set => _flagsAndAttributes = value;
+        }
+
+        /// <summary>The path being accessed.</summary>
+        public string Path
+        {
+            readonly get => _path;
+            private set => _path = value;
+        }
+
+        /// <summary>The process arguments.</summary>
+        public string? ProcessArgs
+        {
+            readonly get => _processArgs;
+            private set => _processArgs = value;
+        }
+
+        /// <summary>Whether the file access is augmented.</summary>
+        public bool IsAnAugmentedFileAccess
+        {
+            readonly get => _isAnAugmentedFileAccess;
+            private set => _isAnAugmentedFileAccess = value;
+        }
+
+        void ITranslatable.Translate(ITranslator translator)
+        {
+            translator.TranslateEnum(ref _operation, (int)_operation);
+            translator.TranslateEnum(ref _requestedAccess, (int)_requestedAccess);
+            translator.Translate(ref _processId);
+            translator.Translate(ref _error);
+            translator.TranslateEnum(ref _desiredAccess, (int)_desiredAccess);
+            translator.TranslateEnum(ref _flagsAndAttributes, (int)_flagsAndAttributes);
+            translator.Translate(ref _path);
+            translator.Translate(ref _processArgs);
+            translator.Translate(ref _isAnAugmentedFileAccess);
+        }
+    }
+}
diff --git a/src/Build/FileAccess/FlagsAndAttributes.cs b/src/Build/FileAccess/FlagsAndAttributes.cs
new file mode 100644
index 00000000000..c02ca45a969
--- /dev/null
+++ b/src/Build/FileAccess/FlagsAndAttributes.cs
@@ -0,0 +1,185 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.FlagsAndAttributes.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// The file or device attributes and flags.
+    /// </summary>
+    [Flags]
+    [CLSCompliant(false)]
+    public enum FlagsAndAttributes : uint
+    {
+        /// <summary>
+        /// The file is read only. Applications can read the file but cannot write to or delete it.
+        /// </summary>
+        FILE_ATTRIBUTE_READONLY = 0x00000001,
+
+        /// <summary>
+        /// The file is hidden. Do not include it in an ordinary directory listing.
+        /// </summary>
+        FILE_ATTRIBUTE_HIDDEN = 0x00000002,
+
+        /// <summary>
+        /// The file is part of or used exclusively by an operating system.
+        /// </summary>
+        FILE_ATTRIBUTE_SYSTEM = 0x00000004,
+
+        /// <summary>
+        /// The path is a directory.
+        /// </summary>
+        FILE_ATTRIBUTE_DIRECTORY = 0x00000010,
+
+        /// <summary>
+        /// The file should be archived. Applications use this attribute to mark files for backup or removal.
+        /// </summary>
+        FILE_ATTRIBUTE_ARCHIVE = 0x00000020,
+
+        /// <summary>
+        /// The file does not have other attributes set. This attribute is valid only if used alone.
+        /// </summary>
+        FILE_ATTRIBUTE_NORMAL = 0x00000080,
+
+        /// <summary>
+        /// The file is being used for temporary storage.
+        /// </summary>
+        /// <remarks>
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_ATTRIBUTE_TEMPORARY = 0x00000100,
+
+        /// <summary>
+        /// The data of a file is not immediately available. This attribute indicates that file data is physically moved to offline
+        /// storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should
+        /// not arbitrarily change this attribute.
+        /// </summary>
+        FILE_ATTRIBUTE_OFFLINE = 0x00001000,
+
+        /// <summary>
+        /// The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory,
+        /// this means that encryption is the default for newly created files and subdirectories. For more information, see File
+        /// Encryption.
+        /// </summary>
+        /// <remarks>
+        /// This flag has no effect if <see cref="FILE_ATTRIBUTE_SYSTEM"/> is also specified.
+        /// This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.
+        /// </remarks>
+        FILE_ATTRIBUTE_ENCRYPED = 0x00004000,
+
+        /// <summary>
+        /// The file data is requested, but it should continue to be located in remote storage. It should not be transported back
+        /// to local storage. This flag is for use by remote storage systems.
+        /// </summary>
+        FILE_FLAG_OPEN_NO_RECALL = 0x00100000,
+
+        /// <summary>
+        /// Normal reparse point processing will not occur; CreateFile will attempt to open the reparse point. When a file is
+        /// opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
+        /// </summary>
+        /// <remarks>
+        /// This flag cannot be used with the CREATE_ALWAYS flag.
+        /// If the file is not a reparse point, then this flag is ignored.
+        /// For more information, see the Remarks section.
+        /// </remarks>
+        FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000,
+
+        /// <summary>
+        /// The file or device is being opened with session awareness. If this flag is not specified, then per-session devices
+        /// (such as a redirected USB device) cannot be opened by processes running in session 0. This flag has no effect for
+        /// callers not in session 0. This flag is supported only on server editions of Windows.
+        /// </summary>
+        /// <remarks>
+        /// Windows Server 2008 R2, Windows Server 2008, and Windows Server 2003: This flag is not supported before Windows Server
+        /// 2012.
+        /// </remarks>
+        FILE_FLAG_SESSION_AWARE = 0x00800000,
+
+        /// <summary>
+        /// Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case,
+        /// for file systems that support that naming. Use care when using this option, because files created with this flag may
+        /// not be accessible by applications that are written for MS-DOS or 16-bit Windows.
+        /// </summary>
+        FILE_FLAG_POSIX_SEMANTICS = 0x01000000,
+
+        /// <summary>
+        /// The file is being opened or created for a backup or restore operation. The system ensures that the calling process
+        /// overrides file security checks when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges. For more
+        /// information, see Changing Privileges in a Token.
+        /// </summary>
+        /// <remarks>
+        /// You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of
+        /// a file handle. For more information, see the Remarks section.
+        /// </remarks>
+        FILE_FLAG_BACKUP_SEMANTICS = 0x02000000,
+
+        /// <summary>
+        /// The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any
+        /// other open or duplicated handles.
+        /// </summary>
+        /// <remarks>
+        /// If there are existing open handles to a file, the call fails unless they were all opened with the FILE_SHARE_DELETE
+        /// share mode.
+        /// Subsequent open requests for the file fail, unless the FILE_SHARE_DELETE share mode is specified.
+        /// </remarks>
+        FILE_FLAG_DELETE_ON_CLOSE = 0x04000000,
+
+        /// <summary>
+        /// Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.
+        /// </summary>
+        /// <remarks>
+        /// This flag should not be used if read-behind (that is, reverse scans) will be used.
+        /// This flag has no effect if the file system does not support cached I/O and <see cref="FILE_FLAG_NO_BUFFERING"/> .
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000,
+
+        /// <summary>
+        /// Access is intended to be random. The system can use this as a hint to optimize file caching.
+        /// </summary>
+        /// <remarks>
+        /// This flag has no effect if the file system does not support cached I/O and <see cref="FILE_FLAG_NO_BUFFERING"/>.
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_RANDOM_ACCESS = 0x10000000,
+
+        /// <summary>
+        /// The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard
+        /// disk caching or memory mapped files.
+        /// </summary>
+        /// <remarks>
+        /// There are strict requirements for successfully working with files opened with CreateFile using this
+        /// flag; for details, see File Buffering.
+        /// </remarks>
+        FILE_FLAG_NO_BUFFERING = 0x20000000,
+
+        /// <summary>
+        /// The file or device is being opened or created for asynchronous I/O.
+        /// </summary>
+        /// <remarks>
+        /// When subsequent I/O operations are completed on this handle, the event specified in the OVERLAPPED structure will be
+        /// set to the signaled state.
+        /// If this flag is specified, the file can be used for simultaneous read and write operations.
+        /// If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions
+        /// specify an OVERLAPPED structure.
+        /// For information about considerations when using a file handle created with this flag, see the Synchronous and
+        /// Asynchronous I/O Handles section of this topic.
+        /// </remarks>
+        FILE_FLAG_OVERLAPPED = 0x40000000,
+
+        /// <summary>
+        /// Write operations will not go through any intermediate cache; they will go directly to disk.
+        /// </summary>
+        /// <remarks>
+        /// For additional information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_WRITE_THROUGH = 0x80000000,
+    }
+}
diff --git a/src/Build/FileAccess/ProcessData.cs b/src/Build/FileAccess/ProcessData.cs
new file mode 100644
index 00000000000..aa274054545
--- /dev/null
+++ b/src/Build/FileAccess/ProcessData.cs
@@ -0,0 +1,85 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /// <summary>
+    /// Process data.
+    /// </summary>
+    [CLSCompliant(false)]
+    public struct ProcessData : ITranslatable
+    {
+        private string _processName;
+        private uint _processId;
+        private uint _parentProcessId;
+        private DateTime _creationDateTime;
+        private DateTime _exitDateTime;
+        private uint _exitCode;
+
+        public ProcessData(string processName, uint processId, uint parentProcessId, DateTime creationDateTime, DateTime exitDateTime, uint exitCode)
+        {
+            _processName = processName;
+            _processId = processId;
+            _parentProcessId = parentProcessId;
+            _creationDateTime = creationDateTime;
+            _exitDateTime = exitDateTime;
+            _exitCode = exitCode;
+        }
+
+        /// <summary>The process name.</summary>
+        public string ProcessName
+        {
+            get => _processName;
+            private set => _processName = value;
+        }
+
+        /// <summary>The process id.</summary>
+        public uint ProcessId
+        {
+            get => _processId;
+            private set => _processId = value;
+        }
+
+        /// <summary>The parent process id.</summary>
+        public uint ParentProcessId
+        {
+            get => _parentProcessId;
+            private set => _parentProcessId = value;
+        }
+
+        /// <summary>The creation date time.</summary>
+        public DateTime CreationDateTime
+        {
+            get => _creationDateTime;
+            private set => _creationDateTime = value;
+        }
+
+        /// <summary>The exit date time.</summary>
+        public DateTime ExitDateTime
+        {
+            get => _exitDateTime;
+            private set => _exitDateTime = value;
+        }
+
+        /// <summary>The exit code.</summary>
+        public uint ExitCode
+        {
+            get => _exitCode;
+            private set => _exitCode = value;
+        }
+
+        void ITranslatable.Translate(ITranslator translator)
+        {
+            translator.Translate(ref _processName);
+            translator.Translate(ref _processId);
+            translator.Translate(ref _parentProcessId);
+            translator.Translate(ref _creationDateTime);
+            translator.Translate(ref _exitDateTime);
+            translator.Translate(ref _exitCode);
+        }
+    }
+}
diff --git a/src/Build/FileAccess/ReportedFileOperation.cs b/src/Build/FileAccess/ReportedFileOperation.cs
new file mode 100644
index 00000000000..c3b846cedde
--- /dev/null
+++ b/src/Build/FileAccess/ReportedFileOperation.cs
@@ -0,0 +1,263 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.ReportedFileOperation.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// Which operation resulted in a reported file access.
+    /// </summary>
+    public enum ReportedFileOperation : byte
+    {
+        /// <summary>
+        /// Unknown operation.
+        /// </summary>
+        Unknown = 0,
+
+        /// <summary>
+        /// CreateFile.
+        /// </summary>
+        CreateFile,
+
+        /// <summary>
+        /// CreateProcess.
+        /// </summary>
+        CreateProcess,
+
+        /// <summary>
+        /// GetFileAttributes.
+        /// </summary>
+        GetFileAttributes,
+
+        /// <summary>
+        /// GetFileAttributesEx.
+        /// </summary>
+        GetFileAttributesEx,
+
+        /// <summary>
+        /// Process forked.
+        /// </summary>
+        Process,
+
+        /// <summary>
+        /// FindFirstFileEx.
+        /// </summary>
+        /// <remarks>
+        /// FindFirstFile also indicates this op, since we implement it in terms of FindFirstFileEx.
+        /// </remarks>
+        FindFirstFileEx,
+
+        /// <summary>
+        /// FindNextFile.
+        /// </summary>
+        FindNextFile,
+
+        /// <summary>
+        /// CreateDirectory.
+        /// </summary>
+        CreateDirectory,
+
+        /// <summary>
+        /// DeleteFile.
+        /// </summary>
+        DeleteFile,
+
+        /// <summary>
+        /// MoveFile (source; read and deleted).
+        /// </summary>
+        MoveFileSource,
+
+        /// <summary>
+        /// MoveFile (destination; written).
+        /// </summary>
+        MoveFileDestination,
+
+        /// <summary>
+        /// SetFileInformationByHandleSource (source; read and deleted).
+        /// </summary>
+        SetFileInformationByHandleSource,
+
+        /// <summary>
+        /// SetFileInformationByHandleDest (destination; written).
+        /// </summary>
+        SetFileInformationByHandleDest,
+
+        /// <summary>
+        /// ZwSetRenameInformationFileSource (source; read and deleted).
+        /// </summary>
+        ZwSetRenameInformationFileSource,
+
+        /// <summary>
+        /// ZwSetRenameInformationFileDest (destination; written).
+        /// </summary>
+        ZwSetRenameInformationFileDest,
+
+        /// <summary>
+        /// ZwSetLinkInformationFileDest.
+        /// </summary>
+        ZwSetLinkInformationFile,
+
+        /// <summary>
+        /// ZwSetDispositionInformationFile (delete-on-close; deleted).
+        /// </summary>
+        ZwSetDispositionInformationFile,
+
+        /// <summary>
+        /// ZwSetModeInformationFile (delete-on-close; deleted).
+        /// </summary>
+        ZwSetModeInformationFile,
+
+        /// <summary>
+        /// ZwSetFileNameInformationFile (source; read and written).
+        /// </summary>
+        ZwSetFileNameInformationFileSource,
+
+        /// <summary>
+        /// ZwSetFileNameInformationFile (destination; written).
+        /// </summary>
+        ZwSetFileNameInformationFileDest,
+
+        /// <summary>
+        /// CopyFile (source; read).
+        /// </summary>
+        CopyFileSource,
+
+        /// <summary>
+        /// CopyFile (destination; written).
+        /// </summary>
+        CopyFileDestination,
+
+        /// <summary>
+        /// CreateHardLink (source; read).
+        /// </summary>
+        CreateHardLinkSource,
+
+        /// <summary>
+        /// CreateHardLink (destination; written).
+        /// </summary>
+        CreateHardLinkDestination,
+
+        /// <summary>
+        /// RemoveDirectory.
+        /// </summary>
+        RemoveDirectory,
+
+        /// <summary>
+        /// RemoveDirectory (source; written).
+        /// </summary>
+        RemoveDirectorySource,
+
+        /// <summary>
+        /// NtQueryDirectoryFile.
+        /// </summary>
+        NtQueryDirectoryFile,
+
+        /// <summary>
+        /// ZwQueryDirectoryFile.
+        /// </summary>
+        ZwQueryDirectoryFile,
+
+        /// <summary>
+        /// NtCreateFile.
+        /// </summary>
+        NtCreateFile,
+
+        /// <summary>
+        /// ZwCreateFile.
+        /// </summary>
+        ZwCreateFile,
+
+        /// <summary>
+        /// ZwOpenFile.
+        /// </summary>
+        ZwOpenFile,
+
+        /// <summary>
+        /// This is a quasi operation. We issue this
+        /// report when Detours is changing file open
+        /// request with Read/Write access to Read access only.
+        /// </summary>
+        ChangedReadWriteToReadAccess,
+
+        /// <summary>
+        /// This is a quasi operation. The sandbox issues this only when FileAccessPolicy.OverrideAllowWriteForExistingFiles is set, representing
+        /// that an allow for write check was performed for a given path for the first time (in the scope of a process, another process in the same process
+        /// tree may also report this for the same path).
+        /// </summary>
+        FirstAllowWriteCheckInProcess,
+
+        /// <summary>
+        /// This operation used to indicate to the engine by the Linux sandbox that a process being executed statically links libc
+        /// and may have missing file observations.
+        /// </summary>
+        StaticallyLinkedProcess,
+
+        /// <summary>
+        /// Access of reparse point target.
+        /// </summary>
+        ReparsePointTarget,
+
+        /// <summary>
+        /// Access of reparse point target, cached by Detours.
+        /// </summary>
+        ReparsePointTargetCached,
+
+        /// <summary>
+        /// Access checks for source of CreateSymbolicLink API.
+        /// </summary>
+        CreateSymbolicLinkSource,
+
+        /// <summary>
+        /// Access check for MoveFileWithgProgress source target.
+        /// </summary>
+        MoveFileWithProgressSource,
+
+        /// <summary>
+        /// Access check for MoveFileWithProgress dest target.
+        /// </summary>
+        MoveFileWithProgressDest,
+
+        /// <summary>
+        /// Multiple operations lumped into one.
+        /// </summary>
+        MultipleOperations,
+
+        /// <summary>
+        /// Process exited.
+        /// </summary>
+        ProcessExit,
+
+        #region Operation Names Reported by BuildXLSandbox (macOS sandbox implementation)
+        MacLookup,
+        MacReadlink,
+        MacVNodeCreate,
+        KAuthMoveSource,
+        KAuthMoveDest,
+        KAuthCreateHardlinkSource,
+        KAuthCreateHardlinkDest,
+        KAuthCopySource,
+        KAuthCopyDest,
+        KAuthDeleteDir,
+        KAuthDeleteFile,
+        KAuthOpenDir,
+        KAuthReadFile,
+        KAuthCreateDir,
+        KAuthWriteFile,
+        KAuthClose,
+        KAuthCloseModified,
+        KAuthGetAttributes,
+        KAuthVNodeExecute,
+        KAuthVNodeWrite,
+        KAuthVNodeRead,
+        KAuthVNodeProbe,
+        MacVNodeWrite,
+        MacVNodeCloneSource,
+        MacVNodeCloneDest,
+        #endregion
+    }
+}
diff --git a/src/Build/FileAccess/RequestedAccess.cs b/src/Build/FileAccess/RequestedAccess.cs
new file mode 100644
index 00000000000..e0e83f176ed
--- /dev/null
+++ b/src/Build/FileAccess/RequestedAccess.cs
@@ -0,0 +1,60 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.RequestedAccess.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// Level of access requested by a reported file operation.
+    /// </summary>
+    [Flags]
+    public enum RequestedAccess : byte
+    {
+        /// <summary>
+        /// No access requested.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// Read access requested.
+        /// </summary>
+        Read = 1,
+
+        /// <summary>
+        /// Write access requested.
+        /// </summary>
+        Write = 2,
+
+        /// <summary>
+        /// Metadata-only probe access requested (e.g. <see cref="ReportedFileOperation.GetFileAttributes"/>).
+        /// </summary>
+        Probe = 4,
+
+        /// <summary>
+        /// Directory enumeration access requested (on the directory itself; immediate children will be enumerated).
+        /// </summary>
+        Enumerate = 8,
+
+        /// <summary>
+        /// Metadata-only probe access requested; probed as part of a directory enumeration (e.g. <see cref="ReportedFileOperation.FindNextFile"/>).
+        /// </summary>
+        EnumerationProbe = 16,
+
+        /// <summary>
+        /// Both read and write access requested.
+        /// </summary>
+        ReadWrite = Read | Write,
+
+        /// <summary>
+        /// All defined access levels requested.
+        /// </summary>
+        All = Read | Write | Probe | Enumerate | EnumerationProbe,
+    }
+}
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index ec977d2f474..a92da0f73f9 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -5,6 +5,7 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Collections.Immutable;
+using System.IO;
 using System.Linq;
 using System.Text;
 using System.Threading;
@@ -257,7 +258,7 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
             ProjectGraphEntryPoint solutionEntryPoint = entryPoints.Single();
             ImmutableDictionary<string, string>.Builder solutionGlobalPropertiesBuilder = ImmutableDictionary.CreateBuilder(
                 keyComparer: StringComparer.OrdinalIgnoreCase,
-                valueComparer: StringComparer.OrdinalIgnoreCase);
+                valueComparer: StringComparer.Ordinal);
 
             if (solutionEntryPoint.GlobalProperties != null)
             {
@@ -278,10 +279,26 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
 
             IReadOnlyCollection<ProjectInSolution> projectsInSolution = GetBuildableProjects(solution);
 
+            // Mimic behavior of SolutionProjectGenerator
             SolutionConfigurationInSolution currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionEntryPoint.GlobalProperties);
+            solutionGlobalPropertiesBuilder["Configuration"] = currentSolutionConfiguration.ConfigurationName;
+            solutionGlobalPropertiesBuilder["Platform"] = currentSolutionConfiguration.PlatformName;
 
             string solutionConfigurationXml = SolutionProjectGenerator.GetSolutionConfiguration(solution, currentSolutionConfiguration);
             solutionGlobalPropertiesBuilder["CurrentSolutionConfigurationContents"] = solutionConfigurationXml;
+            solutionGlobalPropertiesBuilder["BuildingSolutionFile"] = "true";
+
+            string solutionDirectoryName = solution.SolutionFileDirectory;
+            if (!solutionDirectoryName.EndsWith(Path.DirectorySeparatorChar.ToString(), StringComparison.Ordinal))
+            {
+                solutionDirectoryName += Path.DirectorySeparatorChar;
+            }
+
+            solutionGlobalPropertiesBuilder["SolutionDir"] = EscapingUtilities.Escape(solutionDirectoryName);
+            solutionGlobalPropertiesBuilder["SolutionExt"] = EscapingUtilities.Escape(Path.GetExtension(solution.FullPath));
+            solutionGlobalPropertiesBuilder["SolutionFileName"] = EscapingUtilities.Escape(Path.GetFileName(solution.FullPath));
+            solutionGlobalPropertiesBuilder["SolutionName"] = EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(solution.FullPath));
+            solutionGlobalPropertiesBuilder[SolutionProjectGenerator.SolutionPathPropertyName] = EscapingUtilities.Escape(Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.FullPath)));
 
             // Project configurations are reused heavily, so cache the global properties for each
             Dictionary<string, ImmutableDictionary<string, string>> globalPropertiesForProjectConfiguration = new(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index 1e1248865be..39993e3a4fc 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -766,7 +766,7 @@ public ProjectGraphBuildRequest(ProjectGraphNode node, ImmutableList<string> tar
 
             public ImmutableList<string> RequestedTargets { get; }
 
-            public bool Equals(ProjectGraphBuildRequest other)
+            public readonly bool Equals(ProjectGraphBuildRequest other)
             {
                 if (Node != other.Node
                     || RequestedTargets.Count != other.RequestedTargets.Count)
@@ -786,12 +786,12 @@ public bool Equals(ProjectGraphBuildRequest other)
                 return true;
             }
 
-            public override bool Equals(object obj)
+            public override readonly bool Equals(object obj)
             {
                 return !(obj is null) && obj is ProjectGraphBuildRequest graphNodeWithTargets && Equals(graphNodeWithTargets);
             }
 
-            public override int GetHashCode()
+            public override readonly int GetHashCode()
             {
                 unchecked
                 {
diff --git a/src/Build/Graph/ProjectGraphEntryPoint.cs b/src/Build/Graph/ProjectGraphEntryPoint.cs
index 8e229b7bd61..6b0f4713494 100644
--- a/src/Build/Graph/ProjectGraphEntryPoint.cs
+++ b/src/Build/Graph/ProjectGraphEntryPoint.cs
@@ -61,7 +61,7 @@ internal static IEnumerable<ProjectGraphEntryPoint> CreateEnumerable(IEnumerable
             }
         }
 
-        internal IEnumerable<ProjectGraphEntryPoint> AsEnumerable()
+        internal readonly IEnumerable<ProjectGraphEntryPoint> AsEnumerable()
         {
             yield return this;
         }
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 93eb29782fd..d617f78e35a 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -34,8 +34,9 @@ internal sealed class ProjectInterpretation
         private const string PlatformLookupTableMetadataName = "PlatformLookupTable";
         private const string PlatformMetadataName = "Platform";
         private const string PlatformsMetadataName = "Platforms";
-        private const string EnableDynamicPlatformResolutionMetadataName = "EnableDynamicPlatformResolution";
+        private const string EnableDynamicPlatformResolutionPropertyName = "EnableDynamicPlatformResolution";
         private const string OverridePlatformNegotiationValue = "OverridePlatformNegotiationValue";
+        private const string ShouldUnsetParentConfigurationAndPlatformPropertyName = "ShouldUnsetParentConfigurationAndPlatform";
         private const string ProjectMetadataName = "Project";
         private const string ConfigurationMetadataName = "Configuration";
 
@@ -62,7 +63,7 @@ private readonly struct TargetSpecification
         {
             public TargetSpecification(string target, bool skipIfNonexistent)
             {
-                // Verify that if this target is skippable then it equals neither 
+                // Verify that if this target is skippable then it equals neither
                 // ".default" nor ".projectReferenceTargetsOrDefaultTargets".
                 ErrorUtilities.VerifyThrow(
                     !skipIfNonexistent || (!target.Equals(MSBuildConstants.DefaultTargetsMarker)
@@ -120,7 +121,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                 }
 
                 string projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
-                bool enableDynamicPlatformResolution = ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));
+                bool enableDynamicPlatformResolution = ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionPropertyName));
 
                 PropertyDictionary<ProjectPropertyInstance> referenceGlobalProperties = GetGlobalPropertiesForItem(
                     projectReferenceItem,
@@ -130,6 +131,8 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                     allowCollectionReuse: solutionConfiguration == null && !enableDynamicPlatformResolution,
                     globalPropertiesModifiers);
 
+                bool configurationDefined = false;
+
                 // Match what AssignProjectConfiguration does to resolve project references.
                 if (solutionConfiguration != null)
                 {
@@ -150,16 +153,28 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                         {
                             referenceGlobalProperties.Remove(PlatformMetadataName);
                         }
+
+                        configurationDefined = true;
                     }
                     else
                     {
-                        referenceGlobalProperties.Remove(ConfigurationMetadataName);
-                        referenceGlobalProperties.Remove(PlatformMetadataName);
+                        // Note: ShouldUnsetParentConfigurationAndPlatform defaults to true in the AssignProjectConfiguration target when building a solution, so check that it's not false instead of checking that it's true.
+                        bool shouldUnsetParentConfigurationAndPlatform = !ConversionUtilities.ValidBooleanFalse(requesterInstance.GetPropertyValue(ShouldUnsetParentConfigurationAndPlatformPropertyName));
+                        if (shouldUnsetParentConfigurationAndPlatform)
+                        {
+                            referenceGlobalProperties.Remove(ConfigurationMetadataName);
+                            referenceGlobalProperties.Remove(PlatformMetadataName);
+                        }
+                        else
+                        {
+                            configurationDefined = true;
+                        }
                     }
                 }
 
-                // Note: Dynamic platform resolution is not enabled for sln-based builds.
-                else if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && enableDynamicPlatformResolution)
+                // Note: Dynamic platform resolution is not enabled for sln-based builds,
+                // unless the project isn't known to the solution.
+                if (enableDynamicPlatformResolution && !configurationDefined && !projectReferenceItem.HasMetadata(SetPlatformMetadataName))
                 {
                     string requesterPlatform = requesterInstance.GetPropertyValue("Platform");
                     string requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
diff --git a/src/Build/Instance/HostObjectException.cs b/src/Build/Instance/HostObjectException.cs
index a38d07726c0..ee4613d1b14 100644
--- a/src/Build/Instance/HostObjectException.cs
+++ b/src/Build/Instance/HostObjectException.cs
@@ -2,13 +2,14 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
 namespace Microsoft.Build.Execution
 {
     [Serializable]
-    internal sealed class HostObjectException : Exception
+    internal sealed class HostObjectException : BuildExceptionBase
     {
         private const string ErrorMessagePrefix = "Error for HostObject:";
         private const string ErrorMessageProjectTargetTask = "In Project '{0}', Target '{1}', Task '{2}'.";
@@ -56,5 +57,11 @@ internal HostObjectException(
                 + string.Format(ErrorMessageProjectTargetTask, projectFile, targetName, taskName) + message)
         {
         }
+
+        internal HostObjectException(string message, Exception innerException)
+            : base(
+                message,
+                innerException)
+        { }
     }
 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 9a301afd793..c636ae81b41 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -19,6 +19,7 @@
 using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -241,7 +242,7 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, interactive: false)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
@@ -260,9 +261,11 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <param name="directoryCacheFactory">The directory cache factory to use for file I/O.</param>
         /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
         /// <returns>A new project instance</returns>
-        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, bool interactive)
+        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection,
+            ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -279,7 +282,8 @@ private ProjectInstance(string projectFile, IDictionary<string, string> globalPr
             BuildEventContext buildEventContext = new BuildEventContext(buildParameters.NodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
             ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, true /*Explicitly Loaded*/);
 
-            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version provided */, buildParameters, projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
+            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version provided */, buildParameters, projectCollection.LoggingService, buildEventContext,
+                projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext, directoryCacheFactory: directoryCacheFactory);
         }
 
         /// <summary>
@@ -327,7 +331,7 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, interactive: false)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
@@ -399,9 +403,11 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
         /// <param name="projectCollection">Project collection</param>
         /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <param name="directoryCacheFactory">The directory cache factory to use for file I/O.</param>
         /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
         /// <returns>A new project instance</returns>
-        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, bool interactive)
+        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection,
+            ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
 
@@ -410,7 +416,8 @@ private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glob
                 Interactive = interactive
             };
 
-            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, buildParameters, projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
+            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, buildParameters, projectCollection.LoggingService, buildEventContext,
+                projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext, directoryCacheFactory: directoryCacheFactory);
         }
 
         /// <summary>
@@ -554,7 +561,9 @@ internal ProjectInstance(Evaluation.Project.Data data, string directory, string
             this.CreateTargetsSnapshot(data.Targets, data.DefaultTargets, data.InitialTargets, data.BeforeTargets, data.AfterTargets);
             this.CreateImportsSnapshot(data.ImportClosure, data.ImportClosureWithDuplicates);
 
-            this.Toolset = data.Toolset; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
+            // Toolset and task registry are logically immutable after creation, and shareable by project instances
+            //  with same evaluation (global/local properties) - which is guaranteed here (the passed in data is recreated on evaluation if needed)
+            this.Toolset = data.Toolset;
             this.SubToolsetVersion = data.SubToolsetVersion;
             this.TaskRegistry = data.TaskRegistry;
 
@@ -602,7 +611,7 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                     _properties.Set(property.DeepClone(_isImmutable));
                 }
 
-                _items = new ItemDictionary<ProjectItemInstance>(that._items.ItemTypes.Count);
+                _items = new ItemDictionary<ProjectItemInstance>(that._items.Count);
 
                 foreach (ProjectItemInstance item in that.Items)
                 {
@@ -634,10 +643,8 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                     ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(
                     ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
                         ProjectItemDefinitionInstance>)that).AfterTargets, StringComparer.OrdinalIgnoreCase);
-                this.TaskRegistry =
-                    that.TaskRegistry; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
-
-                // These are immutable so we don't need to clone them:
+                // These are immutable (or logically immutable after creation) so we don't need to clone them:
+                this.TaskRegistry = that.TaskRegistry;
                 this.Toolset = that.Toolset;
                 this.SubToolsetVersion = that.SubToolsetVersion;
                 _targets = that._targets;
@@ -755,6 +762,7 @@ public static ProjectInstance FromFile(string file, ProjectOptions options)
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
+                options.DirectoryCacheFactory,
                 options.Interactive);
         }
 
@@ -773,6 +781,7 @@ public static ProjectInstance FromProjectRootElement(ProjectRootElement rootElem
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
+                options.DirectoryCacheFactory,
                 options.Interactive);
         }
 
@@ -2702,7 +2711,8 @@ private void Initialize(
             ISdkResolverService sdkResolverService = null,
             int submissionId = BuildEventContext.InvalidSubmissionId,
             ProjectLoadSettings? projectLoadSettings = null,
-            EvaluationContext evaluationContext = null)
+            EvaluationContext evaluationContext = null,
+            IDirectoryCacheFactory directoryCacheFactory = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(explicitToolsVersion, "toolsVersion");
@@ -2792,8 +2802,8 @@ private void Initialize(
             evaluationContext = evaluationContext?.ContextForNewProject() ?? EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated);
 
             Evaluator<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Evaluate(
-                this,
-                null,
+                data: this,
+                project: null,
                 xml,
                 projectLoadSettings ?? buildParameters.ProjectLoadSettings, /* Use override ProjectLoadSettings if specified */
                 buildParameters.MaxNodeCount,
@@ -2801,6 +2811,7 @@ private void Initialize(
                 loggingService,
                 new ProjectItemInstanceFactory(this),
                 buildParameters.ToolsetProvider,
+                directoryCacheFactory,
                 ProjectRootElementCache,
                 buildEventContext,
                 sdkResolverService ?? evaluationContext.SdkResolverService, /* Use override ISdkResolverService if specified */
@@ -2942,11 +2953,9 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollec
                 if (item.DirectMetadata != null)
                 {
                     directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-                    foreach (ProjectMetadata directMetadatum in item.DirectMetadata)
-                    {
-                        ProjectMetadataInstance directMetadatumInstance = new ProjectMetadataInstance(directMetadatum);
-                        directMetadata.Set(directMetadatumInstance);
-                    }
+
+                    IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
+                    directMetadata.ImportProperties(projectMetadataInstances);
                 }
 
                 // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 9bde7d2db83..fa41b3882ec 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -20,7 +21,7 @@ namespace Microsoft.Build.Execution
     /// Immutable.
     /// </summary>
     [DebuggerDisplay("{_itemType} #Metadata={MetadataCount}")]
-    public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadataInstance>, ITranslatable
+    public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadataInstance>, ITranslatable, IItemTypeDefinition
     {
         /// <summary>
         /// Item type, for example "Compile", that this item definition applies to
@@ -58,11 +59,9 @@ internal ProjectItemDefinitionInstance(ProjectItemDefinition itemDefinition)
             if (itemDefinition.MetadataCount > 0)
             {
                 _metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-            }
 
-            foreach (ProjectMetadata originalMetadata in itemDefinition.Metadata)
-            {
-                _metadata.Set(new ProjectMetadataInstance(originalMetadata));
+                IEnumerable<ProjectMetadataInstance> projectMetadataInstances = itemDefinition.Metadata.Select(originalMetadata => new ProjectMetadataInstance(originalMetadata));
+                _metadata.ImportProperties(projectMetadataInstances);
             }
         }
 
@@ -235,5 +234,7 @@ internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITransla
 
             return instance;
         }
+
+        string IItemTypeDefinition.ItemType => _itemType;
     }
 }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 9258eb5b33f..4db93ab3bb0 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -8,6 +8,9 @@
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
 using System.Linq;
+#if FEATURE_APPDOMAIN
+using System.Runtime.Remoting;
+#endif
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -33,7 +36,8 @@ public class ProjectItemInstance :
         ITaskItem2,
         IMetadataTable,
         ITranslatable,
-        IMetadataContainer
+        IMetadataContainer,
+        IItemTypeDefinition
     {
         /// <summary>
         /// The project instance to which this item belongs.
@@ -113,10 +117,8 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
             if (directMetadata?.GetEnumerator().MoveNext() == true)
             {
                 metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-                foreach (KeyValuePair<string, string> metadatum in directMetadata)
-                {
-                    metadata.Set(new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
-                }
+                IEnumerable<ProjectMetadataInstance> directMetadataInstances = directMetadata.Select(metadatum => new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
+                metadata.ImportProperties(directMetadataInstances);
             }
 
             CommonConstructor(project, itemType, includeEscaped, includeEscaped, metadata, null /* need to add item definition metadata */, definingFileEscaped);
@@ -522,6 +524,8 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
 
         IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata() => _taskItem.EnumerateMetadata();
 
+        void IMetadataContainer.ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata) => _taskItem.ImportMetadata(metadata);
+
         #region IMetadataTable Members
 
         /// <summary>
@@ -586,11 +590,10 @@ void ITranslatable.Translate(ITranslator translator)
         internal static void SetMetadata(IEnumerable<KeyValuePair<string, string>> metadataList, IEnumerable<ProjectItemInstance> items)
         {
             // Set up a single dictionary that can be applied to all the items
-            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-            foreach (KeyValuePair<string, string> metadatum in metadataList)
-            {
-                metadata.Set(new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
-            }
+            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new();
+
+            IEnumerable<ProjectMetadataInstance> projectMetadataInstances = metadataList.Select(metadatum => new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
+            metadata.ImportProperties(projectMetadataInstances);
 
             foreach (ProjectItemInstance item in items)
             {
@@ -1036,6 +1039,19 @@ public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
                 }
             }
 
+            /// <summary>
+            /// Sets the given metadata.
+            /// Equivalent to calling <see cref="SetMetadata(string,string)"/> for each item in <paramref name="metadata"/>.
+            /// </summary>
+            /// <param name="metadata">The metadata to set.</param>
+            public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
+            {
+                ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
+
+                _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                _directMetadata.ImportProperties(metadata.Select(kvp => new ProjectMetadataInstance(kvp.Key, kvp.Value, allowItemSpecModifiers: true)));
+            }
+
             /// <summary>
             /// Used to return metadata from another AppDomain. Can't use yield return because the
             /// generated state machine is not marked as [Serializable], so we need to allocate.
@@ -1095,40 +1111,45 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
 
                     CopyOnWritePropertyDictionary<ProjectMetadataInstance> allMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
 
-                    // Next, any inherited item definitions. Front of the list is highest priority,
-                    // so walk backwards.
-                    for (int i = _itemDefinitions.Count - 1; i >= 0; i--)
+                    allMetadata.ImportProperties(metaData());
+
+                    return allMetadata;
+
+                    IEnumerable<ProjectMetadataInstance> metaData()
                     {
-                        foreach (ProjectMetadataInstance metadatum in _itemDefinitions[i].Metadata)
+                        // Next, any inherited item definitions. Front of the list is highest priority,
+                        // so walk backwards.
+                        for (int i = _itemDefinitions.Count - 1; i >= 0; i--)
                         {
-                            if (metadatum != null)
-                            {
-                                allMetadata.Set(metadatum);
-                            }
-                            else
+                            foreach (ProjectMetadataInstance metadatum in _itemDefinitions[i].Metadata)
                             {
-                                Debug.Fail($"metadatum from {_itemDefinitions[i]} is null, see https://github.com/dotnet/msbuild/issues/5267");
+                                if (metadatum != null)
+                                {
+                                    yield return metadatum;
+                                }
+                                else
+                                {
+                                    Debug.Fail($"metadatum from {_itemDefinitions[i]} is null, see https://github.com/dotnet/msbuild/issues/5267");
+                                }
                             }
                         }
-                    }
 
-                    // Finally any direct metadata win.
-                    if (_directMetadata != null)
-                    {
-                        foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                        // Finally any direct metadata win.
+                        if (_directMetadata != null)
                         {
-                            if (metadatum != null)
+                            foreach (ProjectMetadataInstance metadatum in _directMetadata)
                             {
-                                allMetadata.Set(metadatum);
-                            }
-                            else
-                            {
-                                Debug.Fail("metadatum in _directMetadata is null, see https://github.com/dotnet/msbuild/issues/5267");
+                                if (metadatum != null)
+                                {
+                                    yield return metadatum;
+                                }
+                                else
+                                {
+                                    Debug.Fail("metadatum in _directMetadata is null, see https://github.com/dotnet/msbuild/issues/5267");
+                                }
                             }
                         }
                     }
-
-                    return allMetadata;
                 }
             }
 
@@ -1368,9 +1389,7 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                     originalItemSpec = destinationItem.GetMetadata("OriginalItemSpec");
                 }
 
-                TaskItem destinationAsTaskItem = destinationItem as TaskItem;
-
-                if (destinationAsTaskItem != null && destinationAsTaskItem._directMetadata == null)
+                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem._directMetadata == null)
                 {
                     ProjectInstance.VerifyThrowNotImmutable(destinationAsTaskItem._isImmutable);
 
@@ -1388,6 +1407,24 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                         destinationAsTaskItem._itemDefinitions.AddRange(_itemDefinitions);
                     }
                 }
+                else if (destinationItem is IMetadataContainer destinationItemAsMetadataContainer)
+                {
+                    // The destination implements IMetadataContainer so we can use the ImportMetadata bulk-set operation.
+                    IEnumerable<ProjectMetadataInstance> metadataEnumerable = MetadataCollection;
+                    IEnumerable<KeyValuePair<string, string>> metadataToImport = metadataEnumerable
+                        .Where(metadatum => string.IsNullOrEmpty(destinationItem.GetMetadata(metadatum.Name)))
+                        .Select(metadatum => new KeyValuePair<string, string>(metadatum.Name, GetMetadataEscaped(metadatum.Name)));
+
+#if FEATURE_APPDOMAIN
+                    if (RemotingServices.IsTransparentProxy(destinationItem))
+                    {
+                        // Linq is not serializable so materialize the collection before making the call.
+                        metadataToImport = metadataToImport.ToList();
+                    }
+#endif
+
+                    destinationItemAsMetadataContainer.ImportMetadata(metadataToImport);
+                }
                 else
                 {
                     // OK, most likely the destination item was a Microsoft.Build.Utilities.TaskItem.
@@ -1492,7 +1529,11 @@ public override int GetHashCode()
                 // This is ignore case to ensure that task items whose item specs differ only by
                 // casing still have the same hash code, since this is used to determine if we have duplicates when
                 // we do duplicate removal.
-                return StringComparer.OrdinalIgnoreCase.GetHashCode(ItemSpec);
+                //
+                // Ideally this would also hash in something like the metadata count. However this requires calculation,
+                // because local and inherited metadata are equally considered during equality comparison, and the
+                // former may mask some of the latter.
+                return StringComparer.OrdinalIgnoreCase.GetHashCode(_includeEscaped);
             }
 
             /// <summary>
@@ -1693,12 +1734,21 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                     if (translator.TranslateNullable(_directMetadata))
                     {
                         int count = translator.Reader.ReadInt32();
-                        _directMetadata = (count == 0) ? null : new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-                        for (int i = 0; i < count; i++)
+                        if (count > 0)
                         {
-                            int key = translator.Reader.ReadInt32();
-                            int value = translator.Reader.ReadInt32();
-                            _directMetadata.Set(new ProjectMetadataInstance(interner.GetString(key), interner.GetString(value), allowItemSpecModifiers: true));
+                            IEnumerable<ProjectMetadataInstance> metaData =
+                                Enumerable.Range(0, count).Select(_ =>
+                                {
+                                    int key = translator.Reader.ReadInt32();
+                                    int value = translator.Reader.ReadInt32();
+                                    return new ProjectMetadataInstance(interner.GetString(key), interner.GetString(value), allowItemSpecModifiers: true);
+                                });
+                            _directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                            _directMetadata.ImportProperties(metaData);
+                        }
+                        else
+                        {
+                            _directMetadata = null;
                         }
                     }
                 }
@@ -1961,10 +2011,8 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
                 {
                     // Set up a single dictionary that can be applied to all the items
                     CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-                    foreach (Pair<ProjectMetadataElement, string> metadatum in metadataList)
-                    {
-                        metadata.Set(new ProjectMetadataInstance(metadatum.Key.Name, metadatum.Value));
-                    }
+                    IEnumerable<ProjectMetadataInstance> projectMetadataInstances = metadataList.Select(metadatum => new ProjectMetadataInstance(metadatum.Key.Name, metadatum.Value));
+                    metadata.ImportProperties(projectMetadataInstances);
 
                     foreach (ProjectItemInstance item in destinationItems)
                     {
@@ -2137,7 +2185,7 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
             /// Also, more importantly, because typically the same regular metadata values can be shared by many items,
             /// and keeping item-specific metadata out of it could allow it to be implemented as a copy-on-write table.
             /// </summary>
-            private class BuiltInMetadataTable : IMetadataTable
+            private class BuiltInMetadataTable : IMetadataTable, IItemTypeDefinition
             {
                 /// <summary>
                 /// Item type
@@ -2195,6 +2243,8 @@ public string GetEscapedValueIfPresent(string requiredItemType, string name)
 
                     return value;
                 }
+
+                string IItemTypeDefinition.ItemType => _itemType;
             }
         }
 
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 0b874696321..09bbe0eb985 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -1,4 +1,4 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -9,7 +9,9 @@
 using System.Threading;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
@@ -433,6 +435,17 @@ private void HandlePacket(INodePacket packet, out bool taskFinished)
         /// </summary>
         private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplete)
         {
+#if FEATURE_REPORTFILEACCESSES
+            if (taskHostTaskComplete.FileAccessData?.Count > 0)
+            {
+                IFileAccessManager fileAccessManager = ((IFileAccessManager)_buildComponentHost.GetComponent(BuildComponentType.FileAccessManager));
+                foreach (FileAccessData fileAccessData in taskHostTaskComplete.FileAccessData)
+                {
+                    fileAccessManager.ReportFileAccess(fileAccessData, _buildComponentHost.BuildParameters.NodeId);
+                }
+            }
+#endif
+
             // If it crashed, or if it failed, it didn't succeed.   
             _taskExecutionSucceeded = taskHostTaskComplete.TaskResult == TaskCompleteType.Success ? true : false;
 
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 379987804ae..25c8c79067b 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -337,7 +337,11 @@ internal void MarkAsInactive()
         /// </summary>
         internal bool IsEventSerializable(BuildEventArgs e)
         {
-            if (!e.GetType().GetTypeInfo().IsSerializable)
+#pragma warning disable SYSLIB0050
+            // Types which are not serializable and are not IExtendedBuildEventArgs as
+            // those always implement custom serialization by WriteToStream and CreateFromStream.
+            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)
+#pragma warning restore SYSLIB0050
             {
                 _loggingContext.LogWarning(null, new BuildEventFileInfo(string.Empty), "ExpectedEventToBeSerializable", e.GetType().Name);
                 return false;
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index 58dcc1b4e7b..4f7d6eb4f01 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -8,8 +8,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Execution
 {
     /// <summary>
@@ -19,30 +17,50 @@ internal sealed class TaskFactoryWrapper
     {
         #region Data
 
+        private struct PropertyData
+        {
+            /// <summary>
+            /// Cache of names of required properties on this type
+            /// </summary>
+            public readonly IReadOnlyDictionary<string, string> NamesOfPropertiesWithRequiredAttribute;
+
+            /// <summary>
+            /// Cache of names of output properties on this type
+            /// </summary>
+            public readonly IReadOnlyDictionary<string, string> NamesOfPropertiesWithOutputAttribute;
+
+            /// <summary>
+            /// Cache of names of properties on this type whose names are ambiguous
+            /// </summary>
+            public readonly IReadOnlyDictionary<string, string> NamesOfPropertiesWithAmbiguousMatches;
+
+            /// <summary>
+            /// Cache of PropertyInfos for this type
+            /// </summary>
+            public readonly IReadOnlyDictionary<string, TaskPropertyInfo> PropertyInfoCache;
+
+            public PropertyData(
+                IReadOnlyDictionary<string, string> namesOfPropertiesWithRequiredAttribute,
+                IReadOnlyDictionary<string, string> namesOfPropertiesWithOutputAttribute,
+                IReadOnlyDictionary<string, string> namesOfPropertiesWithAmbiguousMatches,
+                IReadOnlyDictionary<string, TaskPropertyInfo> propertyInfoCache)
+            {
+                NamesOfPropertiesWithRequiredAttribute = namesOfPropertiesWithRequiredAttribute;
+                NamesOfPropertiesWithOutputAttribute = namesOfPropertiesWithOutputAttribute;
+                NamesOfPropertiesWithAmbiguousMatches = namesOfPropertiesWithAmbiguousMatches;
+                PropertyInfoCache = propertyInfoCache;
+            }
+        }
+
         /// <summary>
         /// Factory which is wrapped by the wrapper
         /// </summary>
         private ITaskFactory _taskFactory;
 
         /// <summary>
-        /// Cache of names of required properties on this type
-        /// </summary>
-        private IDictionary<string, string> _namesOfPropertiesWithRequiredAttribute;
-
-        /// <summary>
-        /// Cache of names of output properties on this type
-        /// </summary>
-        private IDictionary<string, string> _namesOfPropertiesWithOutputAttribute;
-
-        /// <summary>
-        /// Cache of names of properties on this type whose names are ambiguous
-        /// </summary>
-        private IDictionary<string, string> _namesOfPropertiesWithAmbiguousMatches;
-
-        /// <summary>
-        /// Cache of PropertyInfos for this type
+        /// Wrapper of lazy initializable property data.
         /// </summary>
-        private IDictionary<string, TaskPropertyInfo> _propertyInfoCache;
+        private Lazy<PropertyData> _propertyData;
 
         /// <summary>
         /// The name of the task this factory can create.
@@ -70,6 +88,7 @@ internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoad
             _taskName = taskName;
             TaskFactoryLoadedType = taskFactoryLoadInfo;
             _factoryIdentityParameters = factoryIdentityParameters;
+            _propertyData = new Lazy<PropertyData>(PopulatePropertyInfo);
         }
 
         #endregion
@@ -101,13 +120,11 @@ public ITaskFactory TaskFactory
         /// Caches the result - since it can't change during the build.
         /// </summary>
         /// <returns></returns>
-        public IDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute
+        public IReadOnlyDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute
         {
             get
             {
-                PopulatePropertyInfoCacheIfNecessary();
-
-                return _namesOfPropertiesWithRequiredAttribute;
+                return _propertyData.Value.NamesOfPropertiesWithRequiredAttribute;
             }
         }
 
@@ -116,13 +133,11 @@ public IDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute
         /// Caches the result - since it can't change during the build.
         /// </summary>
         /// <returns></returns>
-        public IDictionary<string, string> GetNamesOfPropertiesWithOutputAttribute
+        public IReadOnlyDictionary<string, string> GetNamesOfPropertiesWithOutputAttribute
         {
             get
             {
-                PopulatePropertyInfoCacheIfNecessary();
-
-                return _namesOfPropertiesWithOutputAttribute;
+                return _propertyData.Value.NamesOfPropertiesWithOutputAttribute;
             }
         }
 
@@ -158,18 +173,16 @@ public IDictionary<string, string> FactoryIdentityParameters
         /// </summary>
         /// <param name="propertyName">property name</param>
         /// <returns>PropertyInfo</returns>
-        public TaskPropertyInfo GetProperty(string propertyName)
+        public TaskPropertyInfo? GetProperty(string propertyName)
         {
-            PopulatePropertyInfoCacheIfNecessary();
-
-            TaskPropertyInfo propertyInfo;
-            if (!_propertyInfoCache.TryGetValue(propertyName, out propertyInfo))
+            TaskPropertyInfo? propertyInfo;
+            if (!_propertyData.Value.PropertyInfoCache.TryGetValue(propertyName, out propertyInfo))
             {
                 return null;
             }
             else
             {
-                if (_namesOfPropertiesWithAmbiguousMatches.ContainsKey(propertyName))
+                if (_propertyData.Value.NamesOfPropertiesWithAmbiguousMatches.ContainsKey(propertyName))
                 {
                     // See comment in PopulatePropertyInfoCache
                     throw new AmbiguousMatchException();
@@ -187,7 +200,7 @@ internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object val
             ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
             ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
-            IGeneratedTask generatedTask = task as IGeneratedTask;
+            IGeneratedTask? generatedTask = task as IGeneratedTask;
             if (generatedTask != null)
             {
                 generatedTask.SetPropertyValue(property, value);
@@ -195,29 +208,29 @@ internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object val
             else
             {
                 ReflectableTaskPropertyInfo propertyInfo = (ReflectableTaskPropertyInfo)property;
-                propertyInfo.Reflection.SetValue(task, value, null);
+                propertyInfo.Reflection?.SetValue(task, value, null);
             }
         }
 
         /// <summary>
         /// Gets the value of a given property on the given task.
         /// </summary>
-        internal object GetPropertyValue(ITask task, TaskPropertyInfo property)
+        internal object? GetPropertyValue(ITask task, TaskPropertyInfo property)
         {
             ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
             ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
-            IGeneratedTask generatedTask = task as IGeneratedTask;
+            IGeneratedTask? generatedTask = task as IGeneratedTask;
             if (generatedTask != null)
             {
                 return generatedTask.GetPropertyValue(property);
             }
             else
             {
-                ReflectableTaskPropertyInfo propertyInfo = property as ReflectableTaskPropertyInfo;
+                ReflectableTaskPropertyInfo? propertyInfo = property as ReflectableTaskPropertyInfo;
                 if (propertyInfo != null)
                 {
-                    return propertyInfo.Reflection.GetValue(task, null);
+                    return propertyInfo.Reflection?.GetValue(task, null);
                 }
                 else
                 {
@@ -242,77 +255,79 @@ internal bool IsCreatableByFactory(string taskName)
         /// <summary>
         /// Populate the cache of PropertyInfos for this type
         /// </summary>
-        private void PopulatePropertyInfoCacheIfNecessary()
+        private PropertyData PopulatePropertyInfo()
         {
-            if (_propertyInfoCache == null)
+            Dictionary<string, TaskPropertyInfo>? propertyInfoCache = null;
+            Dictionary<string, string>? namesOfPropertiesWithRequiredAttribute = null;
+            Dictionary<string, string>? namesOfPropertiesWithOutputAttribute = null;
+            Dictionary<string, string>? namesOfPropertiesWithAmbiguousMatches = null;
+
+            bool taskTypeImplementsIGeneratedTask = typeof(IGeneratedTask).IsAssignableFrom(_taskFactory.TaskType);
+            TaskPropertyInfo[] propertyInfos = _taskFactory.GetTaskParameters();
+
+            for (int i = 0; i < propertyInfos.Length; i++)
             {
-                bool taskTypeImplementsIGeneratedTask = typeof(IGeneratedTask).IsAssignableFrom(_taskFactory.TaskType);
-                TaskPropertyInfo[] propertyInfos = _taskFactory.GetTaskParameters();
+                // If the task implements IGeneratedTask, we must use the TaskPropertyInfo the factory gives us.
+                // Otherwise, we never have to hand the TaskPropertyInfo back to the task or factory, so we replace
+                // theirs with one of our own that will allow us to cache reflection data per-property.
+                TaskPropertyInfo propertyInfo = propertyInfos[i];
+                if (!taskTypeImplementsIGeneratedTask)
+                {
+                    propertyInfo = new ReflectableTaskPropertyInfo(propertyInfo, _taskFactory.TaskType);
+                }
 
-                for (int i = 0; i < propertyInfos.Length; i++)
+                try
                 {
-                    // If the task implements IGeneratedTask, we must use the TaskPropertyInfo the factory gives us.
-                    // Otherwise, we never have to hand the TaskPropertyInfo back to the task or factory, so we replace
-                    // theirs with one of our own that will allow us to cache reflection data per-property.
-                    TaskPropertyInfo propertyInfo = propertyInfos[i];
-                    if (!taskTypeImplementsIGeneratedTask)
+                    if (propertyInfoCache == null)
                     {
-                        propertyInfo = new ReflectableTaskPropertyInfo(propertyInfo, _taskFactory.TaskType);
+                        propertyInfoCache = new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
                     }
 
-                    try
-                    {
-                        if (_propertyInfoCache == null)
-                        {
-                            _propertyInfoCache = new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
-                        }
-
-                        _propertyInfoCache.Add(propertyInfo.Name, propertyInfo);
-                    }
-                    catch (ArgumentException)
+                    propertyInfoCache.Add(propertyInfo.Name, propertyInfo);
+                }
+                catch (ArgumentException)
+                {
+                    // We have encountered a duplicate entry in our hashtable; if we had used BindingFlags.IgnoreCase this
+                    // would have produced an AmbiguousMatchException. In the old code, before this cache existed,
+                    // that wouldn't have been thrown unless and until the project actually tried to set this ambiguous parameter.
+                    // So rather than fail here, we store a list of ambiguous names and throw later, when one of them
+                    // is requested.
+                    if (namesOfPropertiesWithAmbiguousMatches == null)
                     {
-                        // We have encountered a duplicate entry in our hashtable; if we had used BindingFlags.IgnoreCase this
-                        // would have produced an AmbiguousMatchException. In the old code, before this cache existed,
-                        // that wouldn't have been thrown unless and until the project actually tried to set this ambiguous parameter.
-                        // So rather than fail here, we store a list of ambiguous names and throw later, when one of them
-                        // is requested.
-                        if (_namesOfPropertiesWithAmbiguousMatches == null)
-                        {
-                            _namesOfPropertiesWithAmbiguousMatches = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                        }
-
-                        _namesOfPropertiesWithAmbiguousMatches[propertyInfo.Name] = String.Empty;
+                        namesOfPropertiesWithAmbiguousMatches = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                     }
 
-                    if (propertyInfos[i].Required)
-                    {
-                        if (_namesOfPropertiesWithRequiredAttribute == null)
-                        {
-                            _namesOfPropertiesWithRequiredAttribute = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                        }
-
-                        // we have a require attribute defined, keep a record of that
-                        _namesOfPropertiesWithRequiredAttribute[propertyInfo.Name] = String.Empty;
-                    }
+                    namesOfPropertiesWithAmbiguousMatches[propertyInfo.Name] = String.Empty;
+                }
 
-                    if (propertyInfos[i].Output)
+                if (propertyInfos[i].Required)
+                {
+                    if (namesOfPropertiesWithRequiredAttribute == null)
                     {
-                        if (_namesOfPropertiesWithOutputAttribute == null)
-                        {
-                            _namesOfPropertiesWithOutputAttribute = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                        }
-
-                        // we have a output attribute defined, keep a record of that
-                        _namesOfPropertiesWithOutputAttribute[propertyInfo.Name] = String.Empty;
+                        namesOfPropertiesWithRequiredAttribute = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                     }
+
+                    // we have a require attribute defined, keep a record of that
+                    namesOfPropertiesWithRequiredAttribute[propertyInfo.Name] = String.Empty;
                 }
 
-                _propertyInfoCache ??= ReadOnlyEmptyDictionary<string, TaskPropertyInfo>.Instance;
+                if (propertyInfos[i].Output)
+                {
+                    if (namesOfPropertiesWithOutputAttribute == null)
+                    {
+                        namesOfPropertiesWithOutputAttribute = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                    }
 
-                _namesOfPropertiesWithRequiredAttribute ??= ReadOnlyEmptyDictionary<string, string>.Instance;
-                _namesOfPropertiesWithOutputAttribute ??= ReadOnlyEmptyDictionary<string, string>.Instance;
-                _namesOfPropertiesWithAmbiguousMatches ??= ReadOnlyEmptyDictionary<string, string>.Instance;
+                    // we have a output attribute defined, keep a record of that
+                    namesOfPropertiesWithOutputAttribute[propertyInfo.Name] = String.Empty;
+                }
             }
+
+            return new PropertyData(
+                (IReadOnlyDictionary<string, string>?)namesOfPropertiesWithRequiredAttribute ?? ReadOnlyEmptyDictionary<string, string>.Instance,
+                (IReadOnlyDictionary<string, string>?)namesOfPropertiesWithOutputAttribute ?? ReadOnlyEmptyDictionary<string, string>.Instance,
+                (IReadOnlyDictionary<string, string>?)namesOfPropertiesWithAmbiguousMatches ?? ReadOnlyEmptyDictionary<string, string>.Instance,
+                (IReadOnlyDictionary<string, TaskPropertyInfo>?)propertyInfoCache ?? ReadOnlyEmptyDictionary<string, TaskPropertyInfo>.Instance);
         }
         #endregion
     }
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 33cf3ae1322..3627688d174 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -2,11 +2,14 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
 using System.Diagnostics;
 using System.IO;
+using System.Linq;
 using System.Reflection;
+using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -122,11 +125,17 @@ internal sealed class TaskRegistry : ITranslatable
         /// </summary>
         private static string s_potentialTasksCoreLocation = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksCoreFilename);
 
+        /// <summary>
+        /// Monotonically increasing counter for registered tasks.
+        /// </summary>
+        private int _nextRegistrationOrderId = 0;
+
         /// <summary>
         /// Cache of tasks already found using exact matching,
         /// keyed by the task identity requested.
         /// </summary>
-        private Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord> _cachedTaskRecordsWithExactMatch;
+        private readonly ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> _cachedTaskRecordsWithExactMatch =
+            new(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
 
         /// <summary>
         /// Cache of tasks already found using fuzzy matching,
@@ -134,16 +143,33 @@ internal sealed class TaskRegistry : ITranslatable
         /// Value is a dictionary of all possible matches for that
         /// task name, by unique identity.
         /// </summary>
-        private Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>> _cachedTaskRecordsWithFuzzyMatch;
+        private readonly ConcurrentDictionary<string, ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord>> _cachedTaskRecordsWithFuzzyMatch = new(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Cache of task declarations i.e. the &lt;UsingTask&gt; tags fed to this registry,
         /// keyed by the task name declared.
         /// Task name may be qualified or not.
         /// This field may be null.
+        /// This is expected to be modified only during initialization via a single call, and all reads will occur only after the initialization is done - so no need for a concurrent dictionary.
         /// </summary>
         private Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> _taskRegistrations;
 
+        /// <summary>
+        /// Create another set containing architecture-specific task entries.
+        ///  Then when we look for them, check if the name exists in that.
+        /// This is expected to be modified only during initialization via a single call, and all reads will occur only after the initialization is done - so no need for a concurrent dictionary.
+        /// </summary>
+        private readonly Dictionary<string, List<RegisteredTaskRecord>> _overriddenTasks = new Dictionary<string, List<RegisteredTaskRecord>>();
+
+#if DEBUG
+        /// <summary>
+        /// Indicates whether the task registry has been initialized.
+        /// Task registry cannot be used until it is initialized. And it cannot be initialized more than once.
+        /// This will help to guarantee logical immutability of TaskRegistry.
+        /// </summary>
+        private bool _isInitialized;
+#endif
+
         /// <summary>
         /// The cache to load the *.tasks files into
         /// </summary>
@@ -192,6 +218,12 @@ internal Toolset Toolset
             { return _toolset; }
         }
 
+        /// <summary>
+        /// Access the next registration sequence id.
+        /// FOR UNIT TESTING ONLY.
+        /// </summary>
+        internal int NextRegistrationOrderId => _nextRegistrationOrderId;
+
         /// <summary>
         /// Access list of task registrations.
         /// FOR UNIT TESTING ONLY.
@@ -216,7 +248,42 @@ internal IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> TaskReg
         /// </summary>
         /// <typeparam name="P">A type derived from IProperty</typeparam>
         /// <typeparam name="I">A type derived from IItem</typeparam>
-        internal static void RegisterTasksFromUsingTaskElement<P, I>(
+        internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
+            ILoggingService loggingService,
+            BuildEventContext buildEventContext,
+            IEnumerable<(ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile)> registrations,
+            TaskRegistry taskRegistry,
+            Expander<P, I> expander,
+            ExpanderOptions expanderOptions,
+            IFileSystem fileSystem)
+            where P : class, IProperty
+            where I : class, IItem
+        {
+            foreach ((ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile) registration in registrations)
+            {
+                RegisterTasksFromUsingTaskElement(
+                    loggingService,
+                    buildEventContext,
+                    registration.directoryOfImportingFile,
+                    registration.projectUsingTaskXml,
+                    taskRegistry,
+                    expander,
+                    expanderOptions,
+                    fileSystem);
+            }
+#if DEBUG
+            taskRegistry._isInitialized = true;
+            taskRegistry._taskRegistrations ??= TaskRegistry.CreateRegisteredTaskDictionary();
+#endif
+        }
+
+        /// <summary>
+        /// Evaluate the usingtask and add the result into the data passed in
+        /// </summary>
+        /// <typeparam name="P">A type derived from IProperty</typeparam>
+        /// <typeparam name="I">A type derived from IItem</typeparam>
+        private static void RegisterTasksFromUsingTaskElement
+            <P, I>(
             ILoggingService loggingService,
             BuildEventContext buildEventContext,
             string directoryOfImportingFile,
@@ -229,17 +296,20 @@ internal static void RegisterTasksFromUsingTaskElement<P, I>(
             where I : class, IItem
         {
             ErrorUtilities.VerifyThrowInternalNull(directoryOfImportingFile, nameof(directoryOfImportingFile));
+#if DEBUG
+            ErrorUtilities.VerifyThrowInternalError(!taskRegistry._isInitialized, "Attempt to modify TaskRegistry after it was initialized.");
+#endif
 
             if (!ConditionEvaluator.EvaluateCondition(
-                projectUsingTaskXml.Condition,
-                ParserOptions.AllowPropertiesAndItemLists,
-                expander,
-                expanderOptions,
-                projectUsingTaskXml.ContainingProject.DirectoryPath,
-                projectUsingTaskXml.ConditionLocation,
-                loggingService,
-                buildEventContext,
-                fileSystem))
+                    projectUsingTaskXml.Condition,
+                    ParserOptions.AllowPropertiesAndItemLists,
+                    expander,
+                    expanderOptions,
+                    projectUsingTaskXml.ContainingProject.DirectoryPath,
+                    projectUsingTaskXml.ConditionLocation,
+                    loggingService,
+                    buildEventContext,
+                    fileSystem))
             {
                 return;
             }
@@ -396,6 +466,9 @@ internal TaskFactoryWrapper GetRegisteredTask(
             TargetLoggingContext targetLoggingContext,
             ElementLocation elementLocation)
         {
+#if DEBUG
+            ErrorUtilities.VerifyThrowInternalError(_isInitialized, "Attempt to read from TaskRegistry before its initialization was finished.");
+#endif
             TaskFactoryWrapper taskFactory = null;
 
             // If there are no usingtask tags in the project don't bother caching or looking for tasks locally
@@ -457,7 +530,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             // Project-level override tasks are keyed by task name (unqualified).
             // Because Foo.Bar and Baz.Bar are both valid, they are stored
             // in a dictionary keyed as `Bar` because most tasks are called unqualified
-            if (overriddenTasks.TryGetValue(taskName, out List<RegisteredTaskRecord> recs))
+            if (_overriddenTasks.TryGetValue(taskName, out List<RegisteredTaskRecord> recs))
             {
                 // When we determine this task was overridden, search all task records
                 // to find the most correct registration. Search with the fully qualified name (if applicable)
@@ -483,7 +556,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             {
                 if (exactMatchRequired)
                 {
-                    if (_cachedTaskRecordsWithExactMatch != null && _cachedTaskRecordsWithExactMatch.TryGetValue(taskIdentity, out taskRecord))
+                    if (_cachedTaskRecordsWithExactMatch.TryGetValue(taskIdentity, out taskRecord))
                     {
                         retrievedFromCache = true;
                         return taskRecord;
@@ -491,9 +564,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
                 }
                 else
                 {
-                    Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords;
-
-                    if (_cachedTaskRecordsWithFuzzyMatch != null && _cachedTaskRecordsWithFuzzyMatch.TryGetValue(taskIdentity.Name, out taskRecords))
+                    if (_cachedTaskRecordsWithFuzzyMatch.TryGetValue(taskIdentity.Name, out ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords))
                     {
                         // if we've looked up this exact one before, just grab it and return
                         if (taskRecords.TryGetValue(taskIdentity, out taskRecord))
@@ -525,23 +596,11 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
                     }
                 }
 
-                Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> registrations = GetRelevantRegistrations(taskIdentity, exactMatchRequired);
+                IEnumerable<RegisteredTaskRecord> registrations = GetRelevantOrderedRegistrations(taskIdentity, exactMatchRequired);
 
                 // look for the given task name in the registry; if not found, gather all registered task names that partially
                 // match the given name
-                foreach (KeyValuePair<RegisteredTaskIdentity, List<RegisteredTaskRecord>> registration in registrations)
-                {
-                    // if the given task name is longer than the registered task name
-                    // we will use the longer name to help disambiguate between multiple matches
-                    string mostSpecificTaskName = (taskName.Length > registration.Key.Name.Length) ? taskName : registration.Key.Name;
-
-                    taskRecord = GetMatchingRegistration(mostSpecificTaskName, registration.Value, taskProjectFile, taskIdentityParameters, targetLoggingContext, elementLocation);
-
-                    if (taskRecord != null)
-                    {
-                        break;
-                    }
-                }
+                taskRecord = GetMatchingRegistration(taskName, registrations, taskProjectFile, taskIdentityParameters, targetLoggingContext, elementLocation);
             }
 
             // If we didn't find the task but we have a fallback registry in the toolset state, try that one.
@@ -554,13 +613,10 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             // Cache the result, even if it is null.  We should never again do the work we just did, for this task name.
             if (exactMatchRequired)
             {
-                _cachedTaskRecordsWithExactMatch ??= new Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
                 _cachedTaskRecordsWithExactMatch[taskIdentity] = taskRecord;
             }
             else
             {
-                _cachedTaskRecordsWithFuzzyMatch ??= new Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>>(StringComparer.OrdinalIgnoreCase);
-
                 // Since this is a fuzzy match, we could conceivably have several sets of task identity parameters that match
                 // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.  
                 //
@@ -575,11 +631,9 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
                 // 3. Look up Foo | baz (gets its own entry because it doesn't match Foo | bar)
                 // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up 
                 //    first, might get Foo | baz, which also matches, instead) 
-                Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords;
-                if (!_cachedTaskRecordsWithFuzzyMatch.TryGetValue(taskIdentity.Name, out taskRecords))
-                {
-                    taskRecords = new Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
-                }
+                ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords
+                    = _cachedTaskRecordsWithFuzzyMatch.GetOrAdd(taskIdentity.Name,
+                        _ => new(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));
 
                 taskRecords[taskIdentity] = taskRecord;
                 _cachedTaskRecordsWithFuzzyMatch[taskIdentity.Name] = taskRecords;
@@ -603,42 +657,26 @@ private static bool IsTaskFactoryClass(Type type, object unused)
         /// If no exact match is found, looks for partial matches.
         /// A task name that is not fully qualified may produce several partial matches.
         /// </summary>
-        private Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> GetRelevantRegistrations(RegisteredTaskIdentity taskIdentity, bool exactMatchRequired)
+        private IEnumerable<RegisteredTaskRecord> GetRelevantOrderedRegistrations(RegisteredTaskIdentity taskIdentity, bool exactMatchRequired)
         {
-            Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> relevantTaskRegistrations =
-                new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
-
-            List<RegisteredTaskRecord> taskAssemblies;
-
-            // if we find an exact match
-            if (_taskRegistrations.TryGetValue(taskIdentity, out taskAssemblies))
+            if (_taskRegistrations.TryGetValue(taskIdentity, out List<RegisteredTaskRecord> taskAssemblies))
             {
-                // we're done
-                relevantTaskRegistrations[taskIdentity] = taskAssemblies;
-                return relevantTaskRegistrations;
+                // (records for single key should be ordered by order of registrations - as they are inserted into the list)
+                return taskAssemblies;
             }
 
             if (exactMatchRequired)
             {
-                return relevantTaskRegistrations;
+                return Enumerable.Empty<RegisteredTaskRecord>();
             }
 
             // look through all task declarations for partial matches
-            foreach (KeyValuePair<RegisteredTaskIdentity, List<RegisteredTaskRecord>> taskRegistration in _taskRegistrations)
-            {
-                if (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(taskIdentity, taskRegistration.Key))
-                {
-                    relevantTaskRegistrations[taskRegistration.Key] = taskRegistration.Value;
-                }
-            }
-
-            return relevantTaskRegistrations;
+            return _taskRegistrations
+                .Where(tp => RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(taskIdentity, tp.Key))
+                .SelectMany(tp => tp.Value)
+                .OrderBy(r => r.RegistrationOrderId);
         }
 
-        // Create another set containing architecture-specific task entries.
-        // Then when we look for them, check if the name exists in that.
-        private Dictionary<string, List<RegisteredTaskRecord>> overriddenTasks = new Dictionary<string, List<RegisteredTaskRecord>>();
-
         /// <summary>
         /// Registers an evaluated using task tag for future
         /// consultation
@@ -673,7 +711,13 @@ private void RegisterTask(
                 _taskRegistrations[taskIdentity] = registeredTaskEntries;
             }
 
-            RegisteredTaskRecord newRecord = new RegisteredTaskRecord(taskName, assemblyLoadInfo, taskFactory, taskFactoryParameters, inlineTaskRecord);
+            RegisteredTaskRecord newRecord = new RegisteredTaskRecord(
+                taskName,
+                assemblyLoadInfo,
+                taskFactory,
+                taskFactoryParameters,
+                inlineTaskRecord,
+                Interlocked.Increment(ref _nextRegistrationOrderId));
 
             if (overrideTask)
             {
@@ -683,7 +727,7 @@ private void RegisterTask(
                 string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];
 
                 // Is the task already registered?
-                if (overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))
+                if (_overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))
                 {
                     foreach (RegisteredTaskRecord rec in recs)
                     {
@@ -700,7 +744,7 @@ private void RegisterTask(
                     // New record's name may be fully qualified. Use it anyway to account for partial matches.
                     List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();
                     unqualifiedTaskNameMatches.Add(newRecord);
-                    overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);
+                    _overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);
                     loggingService.LogComment(context, MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
                 }
             }
@@ -721,23 +765,21 @@ private static Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> Cr
         /// </summary>
         private RegisteredTaskRecord GetMatchingRegistration(
             string taskName,
-            List<RegisteredTaskRecord> taskRecords,
+            IEnumerable<RegisteredTaskRecord> taskRecords,
             string taskProjectFile,
             IDictionary<string, string> taskIdentityParameters,
             TargetLoggingContext targetLoggingContext,
             ElementLocation elementLocation)
-        {
-            foreach (RegisteredTaskRecord record in taskRecords)
-            {
-                if (record.CanTaskBeCreatedByFactory(taskName, taskProjectFile, taskIdentityParameters, targetLoggingContext, elementLocation))
-                {
-                    return record;
-                }
-            }
-
-            // Cannot find the task in any of the records
-            return null;
-        }
+            =>
+                taskRecords.FirstOrDefault(r =>
+                    r.CanTaskBeCreatedByFactory(
+                        // if the given task name is longer than the registered task name
+                        // we will use the longer name to help disambiguate between multiple matches
+                        (taskName.Length > r.TaskIdentity.Name.Length) ? taskName : r.TaskIdentity.Name,
+                        taskProjectFile,
+                        taskIdentityParameters,
+                        targetLoggingContext,
+                        elementLocation));
 
         /// <summary>
         /// An object representing the identity of a task -- not just task name, but also
@@ -762,7 +804,7 @@ internal RegisteredTaskIdentity(string name, IDictionary<string, string> taskIde
 
             private static IDictionary<string, string> CreateTaskIdentityParametersDictionary(IDictionary<string, string> initialState = null, int? initialCount = null)
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(initialState == null || initialCount == null, "at most one can be non-null");
+                ErrorUtilities.VerifyThrow(initialState == null || initialCount == null, "at most one can be non-null");
 
                 if (initialState != null)
                 {
@@ -1115,10 +1157,15 @@ internal class RegisteredTaskRecord : ITranslatable
             /// </summary>
             private ParameterGroupAndTaskElementRecord _parameterGroupAndTaskBody;
 
+            /// <summary>
+            /// The registration order id for this task.  This is used to determine the order in which tasks are registered.
+            /// </summary>
+            private int _registrationOrderId;
+
             /// <summary>
             /// Constructor
             /// </summary>
-            internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary<string, string> taskFactoryParameters, ParameterGroupAndTaskElementRecord inlineTask)
+            internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary<string, string> taskFactoryParameters, ParameterGroupAndTaskElementRecord inlineTask, int registrationOrderId)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(assemblyLoadInfo, "AssemblyLoadInfo");
                 _registeredName = registeredName;
@@ -1126,6 +1173,7 @@ internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLo
                 _taskFactoryParameters = taskFactoryParameters;
                 _taskIdentity = new RegisteredTaskIdentity(registeredName, taskFactoryParameters);
                 _parameterGroupAndTaskBody = inlineTask;
+                _registrationOrderId = registrationOrderId;
 
                 if (String.IsNullOrEmpty(taskFactory))
                 {
@@ -1206,6 +1254,11 @@ internal ParameterGroupAndTaskElementRecord ParameterGroupAndTaskBody
             /// </summary>
             internal RegisteredTaskIdentity TaskIdentity => _taskIdentity;
 
+            /// <summary>
+            /// The registration order id for this task.  This is used to determine the order in which tasks are registered.
+            /// </summary>
+            internal int RegistrationOrderId => _registrationOrderId;
+
             /// <summary>
             /// Ask the question, whether or not the task name can be created by the task factory.
             /// To answer this question we need to instantiate and initialize the task factory and ask it if it can create the given task name.
@@ -1426,7 +1479,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                                         initialized = factory.Initialize(RegisteredName, ParameterGroupAndTaskBody.UsingTaskParameters, ParameterGroupAndTaskBody.InlineTaskXmlBody, taskFactoryLoggingHost);
 
                                         // TaskFactoryParameters will always be null unless specifically created to have runtime and architecture parameters.
-                                        if (TaskFactoryParameters != null)
+                                        if (initialized && TaskFactoryParameters != null)
                                         {
                                             targetLoggingContext.LogWarning(
                                                 null,
@@ -1440,7 +1493,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                                     }
 
                                     // Throw an error if the ITaskFactory did not set the TaskType property.  If the property is null, it can cause NullReferenceExceptions in our code
-                                    if (factory.TaskType == null)
+                                    if (initialized && factory.TaskType == null)
                                     {
                                         throw new InvalidOperationException(AssemblyResources.GetString("TaskFactoryTaskTypeIsNotSet"));
                                     }
@@ -1765,6 +1818,7 @@ public void Translate(ITranslator translator)
                 translator.Translate(ref _taskFactoryAssemblyLoadInfo, AssemblyLoadInfo.FactoryForTranslation);
                 translator.Translate(ref _taskFactory);
                 translator.Translate(ref _parameterGroupAndTaskBody);
+                translator.Translate(ref _registrationOrderId);
 
                 IDictionary<string, string> localParameters = _taskFactoryParameters;
                 translator.TranslateDictionary(ref localParameters, count => CreateTaskFactoryParametersDictionary(count));
@@ -1787,13 +1841,16 @@ internal static RegisteredTaskRecord FactoryForDeserialization(ITranslator trans
         public void Translate(ITranslator translator)
         {
             translator.Translate(ref _toolset, Toolset.FactoryForDeserialization);
-
+            translator.Translate(ref _nextRegistrationOrderId);
             IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> copy = _taskRegistrations;
             translator.TranslateDictionary(ref copy, TranslateTaskRegistrationKey, TranslateTaskRegistrationValue, count => CreateRegisteredTaskDictionary(count));
 
             if (translator.Mode == TranslationDirection.ReadFromStream)
             {
                 _taskRegistrations = (Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>)copy;
+#if DEBUG
+                _isInitialized = _taskRegistrations != null;
+#endif
             }
         }
 
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index ce386341186..f4143ccaae7 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -4,10 +4,12 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Text;
+using System.Threading;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
@@ -24,7 +26,7 @@ namespace Microsoft.Build.BackEnd.Logging
     internal delegate void WriteLinePrettyFromResourceDelegate(int indentLevel, string resourceString, params object[] args);
     #endregion
 
-    internal abstract class BaseConsoleLogger : INodeLogger
+    internal abstract class BaseConsoleLogger : INodeLogger, IStringBuilderProvider
     {
         #region Properties
 
@@ -130,28 +132,7 @@ public int Compare(Object a, Object b)
         /// <param name="indent">Depth to indent.</param>
         internal string IndentString(string s, int indent)
         {
-            // It's possible the event has a null message
-            if (s == null)
-            {
-                return string.Empty;
-            }
-
-            // This will never return an empty array.  The returned array will always
-            // have at least one non-null element, even if "s" is totally empty.
-            String[] subStrings = SplitStringOnNewLines(s);
-
-            StringBuilder result = new StringBuilder(
-                (subStrings.Length * indent) +
-                (subStrings.Length * Environment.NewLine.Length) +
-                s.Length);
-
-            for (int i = 0; i < subStrings.Length; i++)
-            {
-                result.Append(' ', indent).Append(subStrings[i]);
-                result.AppendLine();
-            }
-
-            return result.ToString();
+            return OptimizedStringIndenter.IndentString(s, indent, (IStringBuilderProvider)this);
         }
 
         /// <summary>
@@ -291,12 +272,7 @@ internal void WriteLinePretty(int indentLevel, string formattedString)
         /// </summary>
         internal void IsRunningWithCharacterFileType()
         {
-            runningWithCharacterFileType = false;
-
-            if (NativeMethodsShared.IsWindows)
-            {
-                runningWithCharacterFileType = ConsoleConfiguration.OutputIsScreen;
-            }
+            runningWithCharacterFileType = NativeMethodsShared.IsWindows && ConsoleConfiguration.OutputIsScreen;
         }
 
         /// <summary>
@@ -1208,6 +1184,14 @@ private bool ApplyVerbosityParameter(string parameterValue)
 
         internal bool runningWithCharacterFileType = false;
 
+        /// <summary>
+        /// Since logging messages are processed serially, we can use a single StringBuilder wherever needed.
+        /// It should not be done directly, but rather through the <see cref="IStringBuilderProvider"/> interface methods.
+        /// </summary>
+        private StringBuilder _sharedStringBuilder = new StringBuilder(0x100);
+
+        #endregion
+
         #region Per-build Members
 
         /// <summary>
@@ -1252,6 +1236,72 @@ private bool ApplyVerbosityParameter(string parameterValue)
 
         #endregion
 
-        #endregion
+        /// <summary>
+        /// Since logging messages are processed serially, we can reuse a single StringBuilder wherever needed.
+        /// </summary>
+        StringBuilder IStringBuilderProvider.Acquire(int capacity)
+        {
+            StringBuilder shared = Interlocked.Exchange(ref _sharedStringBuilder, null);
+
+            Debug.Assert(shared != null, "This is not supposed to be used in multiple threads or multiple time. One method is expected to return it before next acquire. Most probably it was not returned.");
+            if (shared == null)
+            {
+                // This is not supposed to be used concurrently. One method is expected to return it before next acquire.
+                // However to avoid bugs in production, we will create new string builder
+                return StringBuilderCache.Acquire(capacity);
+            }
+
+            if (shared.Capacity < capacity)
+            {
+                const int minimumCapacity = 0x100; // 256 characters, 512 bytes
+                const int maximumBracketedCapacity = 0x80_000; // 512K characters, 1MB
+
+                if (capacity <= minimumCapacity)
+                {
+                    capacity = minimumCapacity;
+                }
+                else if (capacity < maximumBracketedCapacity)
+                {
+                    // GC likes arrays allocated with power of two bytes. Lets make it happy.
+
+                    // Find next power of two http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
+                    int v = capacity;
+
+                    v--;
+                    v |= v >> 1;
+                    v |= v >> 2;
+                    v |= v >> 4;
+                    v |= v >> 8;
+                    v |= v >> 16;
+                    v++;
+
+                    capacity = v;
+                }
+                // If capacity is > maximumCapacity we will respect it and use it as is.
+
+                // Lets create new instance with enough capacity.
+                shared = new StringBuilder(capacity);
+            }
+
+            // Prepare for next use.
+            // Equivalent of sb.Clear() that works on .Net 3.5
+            shared.Length = 0; 
+
+            return shared;
+        }
+
+        /// <summary>
+        /// Acquired StringBuilder must be returned before next use.
+        /// Unbalanced releases are not supported.
+        /// </summary>
+        string IStringBuilderProvider.GetStringAndRelease(StringBuilder builder)
+        {
+            // This is not supposed to be used concurrently. One method is expected to return it before next acquire.
+            // But just for sure if _sharedBuilder was already returned, keep the former.
+            StringBuilder previous = Interlocked.CompareExchange(ref _sharedStringBuilder, builder, null);
+            Debug.Assert(previous == null, "This is not supposed to be used in multiple threads or multiple time. One method is expected to return it before next acquire. Most probably it was double returned.");
+
+            return builder.ToString();
+        }
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index 8bdcfbf09d9..a19a06c2d37 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -9,8 +9,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Logging
 {
     /// <summary>
@@ -28,6 +26,11 @@ static BinaryLogReplayEventSource()
             _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
+        /// <summary>
+        /// Raised once <see cref="BuildEventArgsReader"/> is created during replaying
+        /// </summary>
+        public event Action<IBuildEventArgsReaderNotifications>? NotificationsSourceCreated;
+
         /// <summary>
         /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
         /// </summary>
@@ -38,48 +41,67 @@ public void Replay(string sourceFilePath)
         }
 
         /// <summary>
-        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// Creates a <see cref="BinaryReader"/> for the provided binary log file.
+        /// Performs decompression and buffering in the optimal way.
+        /// Caller is responsible for disposing the returned reader.
         /// </summary>
-        /// <param name="sourceFilePath">The full file path of the binary log file</param>
-        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
-        public void Replay(string sourceFilePath, CancellationToken cancellationToken)
+        /// <param name="sourceFilePath"></param>
+        /// <returns>BinaryReader of the given binlog file.</returns>
+        public static BinaryReader OpenReader(string sourceFilePath)
         {
-            using (var stream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
+            Stream? stream = null;
+            try
             {
-                var gzipStream = new GZipStream(stream, CompressionMode.Decompress, leaveOpen: true);
+                stream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read);
+                var gzipStream = new GZipStream(stream, CompressionMode.Decompress, leaveOpen: false);
 
                 // wrapping the GZipStream in a buffered stream significantly improves performance
                 // and the max throughput is reached with a 32K buffer. See details here:
                 // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847
                 var bufferedStream = new BufferedStream(gzipStream, 32768);
-                var binaryReader = new BinaryReader(bufferedStream);
+                return new BinaryReader(bufferedStream);
+            }
+            catch(Exception)
+            {
+                stream?.Dispose();
+                throw;
+            }
+        }
 
-                int fileFormatVersion = binaryReader.ReadInt32();
+        /// <summary>
+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// </summary>
+        /// <param name="sourceFilePath">The full file path of the binary log file</param>
+        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
+        public void Replay(string sourceFilePath, CancellationToken cancellationToken)
+        {
+            using var binaryReader = OpenReader(sourceFilePath);
+            Replay(binaryReader, cancellationToken);
+        }
 
-                // the log file is written using a newer version of file format
-                // that we don't know how to read
-                if (fileFormatVersion > BinaryLogger.FileFormatVersion)
-                {
-                    var text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnsupportedLogFileFormat", fileFormatVersion, BinaryLogger.FileFormatVersion);
-                    throw new NotSupportedException(text);
-                }
+        /// <summary>
+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// </summary>
+        /// <param name="binaryReader">The binary log content binary reader - caller is responsible for disposing.</param>
+        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
+        public void Replay(BinaryReader binaryReader, CancellationToken cancellationToken)
+        {
+            int fileFormatVersion = binaryReader.ReadInt32();
 
-                using var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
-                while (true)
-                {
-                    if (cancellationToken.IsCancellationRequested)
-                    {
-                        return;
-                    }
+            // the log file is written using a newer version of file format
+            // that we don't know how to read
+            if (fileFormatVersion > BinaryLogger.FileFormatVersion)
+            {
+                var text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnsupportedLogFileFormat", fileFormatVersion, BinaryLogger.FileFormatVersion);
+                throw new NotSupportedException(text);
+            }
 
-                    BuildEventArgs instance = reader.Read();
-                    if (instance == null)
-                    {
-                        break;
-                    }
+            using var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
+            NotificationsSourceCreated?.Invoke(reader);
 
-                    Dispatch(instance);
-                }
+            while (!cancellationToken.IsCancellationRequested && reader.Read() is { } instance)
+            {
+                Dispatch(instance);
             }
         }
     }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 29b259d2bef..fb8e59007e3 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -5,7 +5,9 @@
 using System.IO;
 using System.IO.Compression;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 #nullable disable
 
@@ -190,6 +192,8 @@ public void Initialize(IEventSource eventSource)
             LogInitialInfo();
 
             eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+
+            KnownTelemetry.LoggingConfigurationTelemetry.BinaryLogger = true;
         }
 
         private void EventArgsWriter_EmbedFile(string filePath)
@@ -226,12 +230,32 @@ public void Shutdown()
 
             if (projectImportsCollector != null)
             {
+                projectImportsCollector.Close();
+
                 if (CollectProjectImports == ProjectImportsCollectionMode.Embed)
                 {
-                    eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, projectImportsCollector.GetAllBytes());
+                    var archiveFilePath = projectImportsCollector.ArchiveFilePath;
+
+                    // It is possible that the archive couldn't be created for some reason.
+                    // Only embed it if it actually exists.
+                    if (FileSystems.Default.FileExists(archiveFilePath))
+                    {
+                        using (FileStream fileStream = File.OpenRead(archiveFilePath))
+                        {
+                            if (fileStream.Length > int.MaxValue)
+                            {
+                                LogMessage("Imported files archive exceeded 2GB limit and it's not embedded.");
+                            }
+                            else
+                            {
+                                eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, fileStream);
+                            }
+                        }
+
+                        File.Delete(archiveFilePath);
+                    }
                 }
 
-                projectImportsCollector.Close();
                 projectImportsCollector = null;
             }
 
@@ -335,6 +359,7 @@ private void ProcessParameters()
             {
                 FilePath = "msbuild.binlog";
             }
+            KnownTelemetry.LoggingConfigurationTelemetry.BinaryLoggerUsedDefaultName = FilePath == "msbuild.binlog";
 
             try
             {
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index ddb7520a7fd..4b13c438721 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -13,14 +13,12 @@
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Logging
 {
     /// <summary>
     /// Deserializes and returns BuildEventArgs-derived objects from a BinaryReader
     /// </summary>
-    public class BuildEventArgsReader : IDisposable
+    public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposable
     {
         private readonly BinaryReader binaryReader;
         private readonly int fileFormatVersion;
@@ -45,13 +43,13 @@ public class BuildEventArgsReader : IDisposable
         /// A "page-file" for storing strings we've read so far. Keeping them in memory would OOM the 32-bit MSBuild
         /// when reading large binlogs. This is a no-op in a 64-bit process.
         /// </summary>
-        private StringStorage stringStorage = new StringStorage();
+        private readonly StringStorage stringStorage = new StringStorage();
 
         // reflection is needed to set these three fields because public constructors don't provide
         // a way to set these from the outside
-        private static FieldInfo buildEventArgsFieldThreadId =
+        private static FieldInfo? buildEventArgsFieldThreadId =
             typeof(BuildEventArgs).GetField("threadId", BindingFlags.Instance | BindingFlags.NonPublic);
-        private static FieldInfo buildEventArgsFieldSenderName =
+        private static FieldInfo? buildEventArgsFieldSenderName =
             typeof(BuildEventArgs).GetField("senderName", BindingFlags.Instance | BindingFlags.NonPublic);
 
         /// <summary>
@@ -67,18 +65,27 @@ public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)
 
         public void Dispose()
         {
-            if (stringStorage != null)
-            {
-                stringStorage.Dispose();
-                stringStorage = null;
-            }
+            stringStorage.Dispose();
         }
 
+        /// <summary>
+        /// An event that allows the subscriber to be notified when a string is read from the binary log.
+        /// Subscriber may adjust the string by setting <see cref="StringReadEventArgs.StringToBeUsed"/> property.
+        /// The passed event arg can be reused and should not be stored.
+        /// </summary>
+        public event Action<StringReadEventArgs>? StringReadDone;
+
+        /// <summary>
+        /// An event that allows the caller to be notified when a string is encountered in the binary log.
+        /// BinaryReader passed in ctor is at the beginning of the string at this point.
+        /// </summary>
+        public event Action? StringEncountered;
+
         /// <summary>
         /// Raised when the log reader encounters a binary blob embedded in the stream.
         /// The arguments include the blob kind and the byte buffer with the contents.
         /// </summary>
-        internal event Action<BinaryLogRecordKind, byte[]> OnBlobRead;
+        internal event Action<BinaryLogRecordKind, byte[]>? OnBlobRead;
 
         /// <summary>
         /// Reads the next log record from the <see cref="BinaryReader"/>.
@@ -87,7 +94,7 @@ public void Dispose()
         /// The next <see cref="BuildEventArgs"/>.
         /// If there are no more records, returns <see langword="null"/>.
         /// </returns>
-        public BuildEventArgs Read()
+        public BuildEventArgs? Read()
         {
             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();
 
@@ -114,7 +121,7 @@ public BuildEventArgs Read()
                 recordKind = (BinaryLogRecordKind)ReadInt32();
             }
 
-            BuildEventArgs result = null;
+            BuildEventArgs? result = null;
             switch (recordKind)
             {
                 case BinaryLogRecordKind.EndOfFile:
@@ -242,8 +249,10 @@ private IDictionary<string, string> GetNameValueList(int id)
                 var dictionary = ArrayDictionary<string, string>.Create(list.Length);
                 for (int i = 0; i < list.Length; i++)
                 {
-                    string key = GetStringFromRecord(list[i].keyIndex);
-                    string value = GetStringFromRecord(list[i].valueIndex);
+                    string? key = GetStringFromRecord(list[i].keyIndex);
+                    // passing null forward would require changes to API surface of existing events
+                    // (BuildStartedEventArgs.BuildEnvironment and ProjectStartedEventArgs.GlobalProperties)
+                    string value = GetStringFromRecord(list[i].valueIndex) ?? string.Empty;
                     if (key != null)
                     {
                         dictionary.Add(key, value);
@@ -258,6 +267,7 @@ private IDictionary<string, string> GetNameValueList(int id)
                 $"NameValueList record number {recordNumber} is invalid: index {id} is not within {stringRecords.Count}.");
         }
 
+        private readonly StringReadEventArgs stringReadEventArgs = new StringReadEventArgs(string.Empty);
         private void ReadStringRecord()
         {
             string text = ReadString();
@@ -304,11 +314,11 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
             var targetName = ReadOptionalString();
             var parentTarget = ReadOptionalString();
 
-            string condition = null;
-            string evaluatedCondition = null;
+            string? condition = null;
+            string? evaluatedCondition = null;
             bool originallySucceeded = false;
             TargetSkipReason skipReason = TargetSkipReason.None;
-            BuildEventContext originalBuildEventContext = null;
+            BuildEventContext? originalBuildEventContext = null;
             if (fileFormatVersion >= 13)
             {
                 condition = ReadOptionalString();
@@ -381,7 +391,9 @@ private BuildEventArgs ReadBuildFinishedEventArgs()
         private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            var projectFile = ReadDeduplicatedString();
+            // Null message arg is not expected by the ProjectEvaluationStartedEventArgs
+            // Ensuring the non-null value - to avoid a need for public API change
+            var projectFile = ReadDeduplicatedString() ?? string.Empty;
 
             var e = new ProjectEvaluationStartedEventArgs(
                 ResourceUtilities.GetResourceString("EvaluationStarted"),
@@ -396,7 +408,8 @@ private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            var projectFile = ReadDeduplicatedString();
+            // Null message arg is not expected
+            var projectFile = ReadDeduplicatedString() ?? string.Empty;
 
             var e = new ProjectEvaluationFinishedEventArgs(
                 ResourceUtilities.GetResourceString("EvaluationFinished"),
@@ -408,7 +421,7 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
 
             if (fileFormatVersion >= 12)
             {
-                IEnumerable globalProperties = null;
+                IEnumerable? globalProperties = null;
                 if (ReadBoolean())
                 {
                     globalProperties = ReadStringDictionary();
@@ -448,7 +461,7 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
         private BuildEventArgs ReadProjectStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            BuildEventContext parentContext = null;
+            BuildEventContext? parentContext = null;
             if (ReadBoolean())
             {
                 parentContext = ReadBuildEventContext();
@@ -459,7 +472,7 @@ private BuildEventArgs ReadProjectStartedEventArgs()
             var targetNames = ReadDeduplicatedString();
             var toolsVersion = ReadOptionalString();
 
-            IDictionary<string, string> globalProperties = null;
+            IDictionary<string, string>? globalProperties = null;
 
             if (fileFormatVersion > 6)
             {
@@ -747,10 +760,10 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            string propertyName = ReadDeduplicatedString();
-            string previousValue = ReadDeduplicatedString();
-            string newValue = ReadDeduplicatedString();
-            string location = ReadDeduplicatedString();
+            string? propertyName = ReadDeduplicatedString();
+            string? previousValue = ReadDeduplicatedString();
+            string? newValue = ReadDeduplicatedString();
+            string? location = ReadDeduplicatedString();
 
             var e = new PropertyReassignmentEventArgs(
                 propertyName,
@@ -769,7 +782,7 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()
         private BuildEventArgs ReadUninitializedPropertyReadEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
-            string propertyName = ReadDeduplicatedString();
+            string? propertyName = ReadDeduplicatedString();
 
             var e = new UninitializedPropertyReadEventArgs(
                 propertyName,
@@ -786,9 +799,9 @@ private BuildEventArgs ReadPropertyInitialValueSetEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            string propertyName = ReadDeduplicatedString();
-            string propertyValue = ReadDeduplicatedString();
-            string propertySource = ReadDeduplicatedString();
+            string? propertyName = ReadDeduplicatedString();
+            string? propertyValue = ReadDeduplicatedString();
+            string? propertySource = ReadDeduplicatedString();
 
             var e = new PropertyInitialValueSetEventArgs(
                 propertyName,
@@ -808,11 +821,11 @@ private AssemblyLoadBuildEventArgs ReadAssemblyLoadEventArgs()
             var fields = ReadBuildEventArgsFields(readImportance: false);
 
             AssemblyLoadingContext context = (AssemblyLoadingContext)ReadInt32();
-            string loadingInitiator = ReadDeduplicatedString();
-            string assemblyName = ReadDeduplicatedString();
-            string assemblyPath = ReadDeduplicatedString();
+            string? loadingInitiator = ReadDeduplicatedString();
+            string? assemblyName = ReadDeduplicatedString();
+            string? assemblyPath = ReadDeduplicatedString();
             Guid mvid = ReadGuid();
-            string appDomainName = ReadDeduplicatedString();
+            string? appDomainName = ReadDeduplicatedString();
 
             var e = new AssemblyLoadBuildEventArgs(
                 context,
@@ -923,7 +936,7 @@ private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance = fals
             if ((flags & BuildEventArgsFieldFlags.Arguments) != 0)
             {
                 int count = ReadInt32();
-                object[] arguments = new object[count];
+                object?[] arguments = new object[count];
                 for (int i = 0; i < count; i++)
                 {
                     arguments[i] = ReadDeduplicatedString();
@@ -946,12 +959,12 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
 
             if ((fields.Flags & BuildEventArgsFieldFlags.ThreadId) != 0)
             {
-                buildEventArgsFieldThreadId.SetValue(buildEventArgs, fields.ThreadId);
+                buildEventArgsFieldThreadId?.SetValue(buildEventArgs, fields.ThreadId);
             }
 
             if ((fields.Flags & BuildEventArgsFieldFlags.SenderName) != 0)
             {
-                buildEventArgsFieldSenderName.SetValue(buildEventArgs, fields.SenderName);
+                buildEventArgsFieldSenderName?.SetValue(buildEventArgs, fields.SenderName);
             }
 
             if ((fields.Flags & BuildEventArgsFieldFlags.Timestamp) != 0)
@@ -960,7 +973,7 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
             }
         }
 
-        private IEnumerable ReadPropertyList()
+        private IEnumerable? ReadPropertyList()
         {
             var properties = ReadStringDictionary();
             if (properties == null || properties.Count == 0)
@@ -1007,7 +1020,7 @@ private BuildEventContext ReadBuildEventContext()
             return result;
         }
 
-        private IDictionary<string, string> ReadStringDictionary()
+        private IDictionary<string, string>? ReadStringDictionary()
         {
             if (fileFormatVersion < 10)
             {
@@ -1024,7 +1037,7 @@ private IDictionary<string, string> ReadStringDictionary()
             return record;
         }
 
-        private IDictionary<string, string> ReadLegacyStringDictionary()
+        private IDictionary<string, string>? ReadLegacyStringDictionary()
         {
             int count = ReadInt32();
             if (count == 0)
@@ -1046,16 +1059,16 @@ private IDictionary<string, string> ReadLegacyStringDictionary()
 
         private ITaskItem ReadTaskItem()
         {
-            string itemSpec = ReadDeduplicatedString();
+            string? itemSpec = ReadDeduplicatedString();
             var metadata = ReadStringDictionary();
 
             var taskItem = new TaskItemData(itemSpec, metadata);
             return taskItem;
         }
 
-        private IEnumerable ReadProjectItems()
+        private IEnumerable? ReadProjectItems()
         {
-            IList<DictionaryEntry> list;
+            IList<DictionaryEntry>? list;
 
             // starting with format version 10 project items are grouped by name
             // so we only have to write the name once, and then the count of items
@@ -1088,7 +1101,7 @@ private IEnumerable ReadProjectItems()
                 list = new List<DictionaryEntry>();
                 for (int i = 0; i < count; i++)
                 {
-                    string itemType = ReadDeduplicatedString();
+                    string itemType = ReadDeduplicatedString()!;
                     var items = ReadTaskItemList();
                     if (items != null)
                     {
@@ -1110,7 +1123,7 @@ private IEnumerable ReadProjectItems()
 
                 while (true)
                 {
-                    string itemType = ReadDeduplicatedString();
+                    string itemType = ReadDeduplicatedString()!;
                     if (string.IsNullOrEmpty(itemType))
                     {
                         break;
@@ -1135,7 +1148,7 @@ private IEnumerable ReadProjectItems()
             return list;
         }
 
-        private IEnumerable ReadTaskItemList()
+        private IEnumerable? ReadTaskItemList()
         {
             int count = ReadInt32();
             if (count == 0)
@@ -1156,10 +1169,18 @@ private IEnumerable ReadTaskItemList()
 
         private string ReadString()
         {
-            return binaryReader.ReadString();
+            this.StringEncountered?.Invoke();
+            string text = binaryReader.ReadString();
+            if (this.StringReadDone != null)
+            {
+                stringReadEventArgs.Reuse(text);
+                StringReadDone(stringReadEventArgs);
+                text = stringReadEventArgs.StringToBeUsed;
+            }
+            return text;
         }
 
-        private string ReadOptionalString()
+        private string? ReadOptionalString()
         {
             if (fileFormatVersion < 10)
             {
@@ -1176,7 +1197,7 @@ private string ReadOptionalString()
             return ReadDeduplicatedString();
         }
 
-        private string ReadDeduplicatedString()
+        private string? ReadDeduplicatedString()
         {
             if (fileFormatVersion < 10)
             {
@@ -1187,7 +1208,7 @@ private string ReadDeduplicatedString()
             return GetStringFromRecord(index);
         }
 
-        private string GetStringFromRecord(int index)
+        private string? GetStringFromRecord(int index)
         {
             if (index == 0)
             {
@@ -1310,11 +1331,11 @@ internal class StringPosition
         /// </summary>
         internal class StringStorage : IDisposable
         {
-            private readonly string filePath;
-            private FileStream stream;
-            private StreamWriter streamWriter;
-            private readonly StreamReader streamReader;
-            private readonly StringBuilder stringBuilder;
+            private readonly string? filePath;
+            private FileStream? stream;
+            private StreamWriter? streamWriter;
+            private readonly StreamReader? streamReader;
+            private readonly StringBuilder? stringBuilder;
 
             public const int StringSizeThreshold = 1024;
 
@@ -1368,9 +1389,9 @@ public object Add(string text)
 
                 var stringPosition = new StringPosition();
 
-                stringPosition.FilePosition = stream.Position;
+                stringPosition.FilePosition = stream!.Position;
 
-                streamWriter.Write(text);
+                streamWriter!.Write(text);
 
                 stringPosition.StringLength = text.Length;
                 return stringPosition;
@@ -1385,16 +1406,16 @@ public string Get(object storedString)
 
                 var position = (StringPosition)storedString;
 
-                stream.Position = position.FilePosition;
-                stringBuilder.Length = position.StringLength;
+                stream!.Position = position.FilePosition;
+                stringBuilder!.Length = position.StringLength;
                 for (int i = 0; i < position.StringLength; i++)
                 {
-                    char ch = (char)streamReader.Read();
+                    char ch = (char)streamReader!.Read();
                     stringBuilder[i] = ch;
                 }
 
                 stream.Position = stream.Length;
-                streamReader.DiscardBufferedData();
+                streamReader!.DiscardBufferedData();
 
                 string result = stringBuilder.ToString();
                 stringBuilder.Clear();
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index cf69bcbacbc..bc96814843e 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -156,6 +156,7 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     TaskCommandLine
                     TaskParameter
                     UninitializedPropertyRead
+                    ExtendedMessage
                 BuildStatus
                     TaskStarted
                     TaskFinished
@@ -168,11 +169,13 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     ProjectEvaluationStarted
                     ProjectEvaluationFinished
                 BuildError
+                    ExtendedBuildError
                 BuildWarning
+                    ExtendedBuildWarning
                 CustomBuild
                     ExternalProjectStarted
                     ExternalProjectFinished
-
+                    ExtendedCustomBuild
         */
 
         private void WriteCore(BuildEventArgs e)
@@ -218,6 +221,22 @@ public void WriteBlob(BinaryLogRecordKind kind, byte[] bytes)
             Write(bytes);
         }
 
+        public void WriteBlob(BinaryLogRecordKind kind, Stream stream)
+        {
+            if (stream.Length > int.MaxValue)
+            {
+                throw new ArgumentOutOfRangeException(nameof(stream));
+            }
+
+            // write the blob directly to the underlying writer,
+            // bypassing the memory stream
+            using var redirection = RedirectWritesToOriginalWriter();
+
+            Write(kind);
+            Write((int)stream.Length);
+            Write(stream);
+        }
+
         /// <summary>
         /// Switches the binaryWriter used by the Write* methods to the direct underlying stream writer
         /// until the disposable is disposed. Useful to bypass the currentRecordWriter to write a string,
@@ -1091,6 +1110,11 @@ private void Write(byte[] bytes)
             binaryWriter.Write(bytes);
         }
 
+        private void Write(Stream stream)
+        {
+            stream.CopyTo(binaryWriter.BaseStream);
+        }
+
         private void Write(byte b)
         {
             binaryWriter.Write(b);
diff --git a/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs b/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs
new file mode 100644
index 00000000000..415bd7c71fd
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs
@@ -0,0 +1,13 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An interface for notifications from BuildEventArgsReader
+    /// </summary>
+    public interface IBuildEventArgsReaderNotifications : IBuildEventStringsReader
+    {
+        /* For future use */
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs b/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs
new file mode 100644
index 00000000000..e9e7651ee78
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs
@@ -0,0 +1,26 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An interface for notifications about reading strings from the binary log.
+    /// </summary>
+    public interface IBuildEventStringsReader
+    {
+        /// <summary>
+        /// An event that allows the subscriber to be notified when a string is read from the binary log.
+        /// Subscriber may adjust the string by setting <see cref="StringReadEventArgs.StringToBeUsed"/> property.
+        /// The passed event arg can be reused and should not be stored.
+        /// </summary>
+        public event Action<StringReadEventArgs>? StringReadDone;
+
+        /// <summary>
+        /// An event that allows the caller to be notified when a string is encountered in the binary log.
+        /// BinaryReader passed in ctor is at the beginning of the string at this point.
+        /// </summary>
+        public event Action? StringEncountered;
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
index 41fa9daa780..27ededae8cc 100644
--- a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
+++ b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
@@ -7,6 +7,7 @@
 using System.IO.Compression;
 using System.Text;
 using System.Threading.Tasks;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -20,30 +21,10 @@ namespace Microsoft.Build.Logging
     /// </summary>
     internal class ProjectImportsCollector
     {
-        private Stream _stream;
-        public byte[] GetAllBytes()
-        {
-            if (_stream == null)
-            {
-                return Array.Empty<byte>();
-            }
-            else if (ArchiveFilePath == null)
-            {
-                var stream = _stream as MemoryStream;
-                // Before we can use the zip archive, it must be closed.
-                Close(false);
-                return stream.ToArray();
-            }
-            else
-            {
-                Close();
-                return File.ReadAllBytes(ArchiveFilePath);
-            }
-        }
-
+        private Stream _fileStream;
         private ZipArchive _zipArchive;
 
-        private string ArchiveFilePath { get; set; }
+        public string ArchiveFilePath { get; }
 
         /// <summary>
         /// Avoid visiting each file more than once.
@@ -55,33 +36,46 @@ public byte[] GetAllBytes()
 
         public ProjectImportsCollector(string logFilePath, bool createFile, string sourcesArchiveExtension = ".ProjectImports.zip")
         {
-            try
+            if (createFile)
             {
-                if (createFile)
-                {
-                    ArchiveFilePath = Path.ChangeExtension(logFilePath, sourcesArchiveExtension);
-                    _stream = new FileStream(ArchiveFilePath, FileMode.Create, FileAccess.ReadWrite, FileShare.Delete);
-                }
-                else
+                // Archive file will be stored alongside the binlog
+                ArchiveFilePath = Path.ChangeExtension(logFilePath, sourcesArchiveExtension);
+            }
+            else
+            {
+                string cacheDirectory = FileUtilities.GetCacheDirectory();
+                if (!Directory.Exists(cacheDirectory))
                 {
-                    _stream = new MemoryStream();
+                    Directory.CreateDirectory(cacheDirectory);
                 }
-                _zipArchive = new ZipArchive(_stream, ZipArchiveMode.Create, true);
+
+                // Archive file will be temporarily stored in MSBuild cache folder and deleted when no longer needed
+                ArchiveFilePath = Path.Combine(
+                    cacheDirectory,
+                    Path.ChangeExtension(
+                        Path.GetFileName(logFilePath),
+                        sourcesArchiveExtension));
+            }
+
+            try
+            {
+                _fileStream = new FileStream(ArchiveFilePath, FileMode.Create, FileAccess.ReadWrite, FileShare.Delete);
+                _zipArchive = new ZipArchive(_fileStream, ZipArchiveMode.Create);
             }
             catch
             {
                 // For some reason we weren't able to create a file for the archive.
                 // Disable the file collector.
-                _stream = null;
+                _fileStream = null;
                 _zipArchive = null;
             }
         }
 
         public void AddFile(string filePath)
         {
-            if (filePath != null && _stream != null)
+            if (filePath != null && _fileStream != null)
             {
-                lock (_stream)
+                lock (_fileStream)
                 {
                     // enqueue the task to add a file and return quickly
                     // to avoid holding up the current thread
@@ -101,9 +95,9 @@ public void AddFile(string filePath)
 
         public void AddFileFromMemory(string filePath, string data)
         {
-            if (filePath != null && data != null && _stream != null)
+            if (filePath != null && data != null && _fileStream != null)
             {
-                lock (_stream)
+                lock (_fileStream)
                 {
                     // enqueue the task to add a file and return quickly
                     // to avoid holding up the current thread
@@ -197,7 +191,7 @@ private static string CalculateArchivePath(string filePath)
             return archivePath;
         }
 
-        public void Close(bool closeStream = true)
+        public void Close()
         {
             // wait for all pending file writes to complete
             _currentTask.Wait();
@@ -208,10 +202,10 @@ public void Close(bool closeStream = true)
                 _zipArchive = null;
             }
 
-            if (closeStream && (_stream != null))
+            if (_fileStream != null)
             {
-                _stream.Dispose();
-                _stream = null;
+                _fileStream.Dispose();
+                _fileStream = null;
             }
         }
     }
diff --git a/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs b/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs
new file mode 100644
index 00000000000..e2a4c83d3cb
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs
@@ -0,0 +1,35 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An event args for <see cref="IBuildEventStringsReader.StringReadDone"/> callback.
+    /// </summary>
+    public sealed class StringReadEventArgs : EventArgs
+    {
+        /// <summary>
+        /// The original string that was read from the binary log.
+        /// </summary>
+        public string OriginalString { get; private set; }
+
+        /// <summary>
+        /// The adjusted string (or the original string of none subscriber replaced it) that will be used by the reader.
+        /// </summary>
+        public string StringToBeUsed { get; set; }
+
+        public StringReadEventArgs(string str)
+        {
+            OriginalString = str;
+            StringToBeUsed = str;
+        }
+
+        internal void Reuse(string newValue)
+        {
+            OriginalString = newValue;
+            StringToBeUsed = newValue;
+        }
+    }
+}
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index be295c3bf94..136b0c94d7f 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -4,6 +4,7 @@
 using System;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 using BaseConsoleLogger = Microsoft.Build.BackEnd.Logging.BaseConsoleLogger;
 using ParallelConsoleLogger = Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger;
@@ -158,10 +159,26 @@ private void InitializeBaseConsoleLogger()
             if (_numberOfProcessors == 1 && !useMPLogger)
             {
                 _consoleLogger = new SerialConsoleLogger(_verbosity, _write, _colorSet, _colorReset);
+                if (this is FileLogger)
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.FileLoggerType = "serial";
+                }
+                else
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLoggerType = "serial";
+                }
             }
             else
             {
                 _consoleLogger = new ParallelConsoleLogger(_verbosity, _write, _colorSet, _colorReset);
+                if (this is FileLogger)
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.FileLoggerType = "parallel";
+                }
+                else
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLoggerType = "parallel";
+                }
             }
 
             if (_showSummary != null)
@@ -339,6 +356,12 @@ public virtual void Initialize(IEventSource eventSource, int nodeCount)
             _numberOfProcessors = nodeCount;
             InitializeBaseConsoleLogger();
             _consoleLogger.Initialize(eventSource, nodeCount);
+
+            if (this is not FileLogger)
+            {
+                KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLogger = true;
+                KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLoggerVerbosity = Verbosity.ToString();
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index 4df6b2830f9..7f90d035fd6 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -97,6 +97,7 @@ public void Initialize(IEventSource eventSource)
             ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             ParseFileLoggerParameters();
             string fileName = _logFile;
+
             try
             {
                 // Create a new file logger and pass it some parameters to make the build log very detailed
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index 156ee0c58e5..bd0abc891b9 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -7,6 +7,7 @@
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -39,6 +40,11 @@ public FileLogger()
                 colorReset: BaseConsoleLogger.DontResetColor)
         {
             WriteHandler = Write;
+
+            if (EncodingUtilities.GetExternalOverriddenUILanguageIfSupportableWithEncoding() != null)
+            {
+                _encoding = Encoding.UTF8;
+            }
         }
 
         #endregion
@@ -82,6 +88,9 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)
             // Finally, ask the base console logger class to initialize. It may
             // want to make decisions based on our verbosity, so we do this last.
             base.Initialize(eventSource, nodeCount);
+            KnownTelemetry.LoggingConfigurationTelemetry.FileLoggersCount++;
+            KnownTelemetry.LoggingConfigurationTelemetry.FileLogger = true;
+            KnownTelemetry.LoggingConfigurationTelemetry.FileLoggerVerbosity = Verbosity.ToString();
 
             if (!SkipProjectStartedText && Verbosity >= LoggerVerbosity.Normal)
             {
diff --git a/src/Build/Logging/OptimizedStringIndenter.cs b/src/Build/Logging/OptimizedStringIndenter.cs
new file mode 100644
index 00000000000..d98f1d62094
--- /dev/null
+++ b/src/Build/Logging/OptimizedStringIndenter.cs
@@ -0,0 +1,181 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Buffers;
+
+#if NET7_0_OR_GREATER
+using System.Runtime.CompilerServices;
+#else
+using System.Text;
+#endif
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BackEnd.Logging;
+
+/// <summary>
+/// Helper class to indent all the lines of a potentially multi-line string with
+/// minimal CPU and memory overhead.
+/// </summary>
+/// <remarks>
+/// <see cref="IndentString"/> is a functional replacement for the following code:
+/// <code>
+///     string IndentString(string s, int indent)
+///     {
+///         string[] newLines = { "\r\n", "\n" };
+///         string[] subStrings = s.Split(newLines, StringSplitOptions.None);
+///
+///         StringBuilder result = new StringBuilder(
+///             (subStrings.Length * indent) +
+///             (subStrings.Length * Environment.NewLine.Length) +
+///             s.Length);
+///
+///         for (int i = 0; i &lt; subStrings.Length; i++)
+///         {
+///             result.Append(' ', indent).Append(subStrings[i]);
+///             result.AppendLine();
+///         }
+///
+///         return result.ToString();
+///     }
+/// </code>
+/// On net472, benchmarks show that the optimized version runs in about 50-60% of the time
+/// and has about 15% of the memory overhead of the code that it replaces.
+/// <para>
+/// On net7.0, the optimized version runs in about 45-55% of the time and has about 30%
+/// of the memory overhead of the code that it replaces.
+/// </para>
+/// </remarks>
+internal static class OptimizedStringIndenter
+{
+#nullable enable
+#if NET7_0_OR_GREATER
+    [SkipLocalsInit]
+#endif
+    internal static unsafe string IndentString(string? s, int indent, IStringBuilderProvider stringBuilderProvider)
+    {
+        if (s is null)
+        {
+            return string.Empty;
+        }
+
+        Span<StringSegment> segments = GetStringSegments(s.AsSpan(), stackalloc StringSegment[128], out StringSegment[]? pooledArray);
+
+        int indentedStringLength = segments.Length * (Environment.NewLine.Length + indent);
+        foreach (StringSegment segment in segments)
+        {
+            indentedStringLength += segment.Length;
+        }
+
+#if NET7_0_OR_GREATER
+#pragma warning disable CS8500
+        string result = string.Create(indentedStringLength, (s, (IntPtr)(&segments), indent), static (output, state) =>
+        {
+            ReadOnlySpan<char> input = state.s;
+            foreach (StringSegment segment in *(Span<StringSegment>*)state.Item2)
+            {
+                // Append indent
+                output.Slice(0, state.indent).Fill(' ');
+                output = output.Slice(state.indent);
+
+                // Append string segment
+                input.Slice(segment.Start, segment.Length).CopyTo(output);
+                output = output.Slice(segment.Length);
+
+                // Append newline
+                Environment.NewLine.CopyTo(output);
+                output = output.Slice(Environment.NewLine.Length);
+            }
+        });
+#pragma warning restore CS8500
+#else
+        StringBuilder builder = stringBuilderProvider.Acquire(indentedStringLength);
+
+        foreach (StringSegment segment in segments)
+        {
+            builder
+                .Append(' ', indent)
+                .Append(s, segment.Start, segment.Length)
+                .AppendLine();
+        }
+
+        string result = stringBuilderProvider.GetStringAndRelease(builder);
+#endif
+
+        if (pooledArray is not null)
+        {
+            ArrayPool<StringSegment>.Shared.Return(pooledArray);
+        }
+
+        return result;
+    }
+
+    private static Span<StringSegment> GetStringSegments(ReadOnlySpan<char> input, Span<StringSegment> segments, out StringSegment[]? pooledArray)
+    {
+        if (input.IsEmpty)
+        {
+            segments = segments.Slice(0, 1);
+            segments[0] = new StringSegment(0, 0);
+            pooledArray = null;
+            return segments;
+        }
+
+        int segmentCount = 1;
+        for (int i = 0; i < input.Length; i++)
+        {
+            if (input[i] == '\n')
+            {
+                segmentCount++;
+            }
+        }
+
+        if (segmentCount <= segments.Length)
+        {
+            pooledArray = null;
+            segments = segments.Slice(0, segmentCount);
+        }
+        else
+        {
+            pooledArray = ArrayPool<StringSegment>.Shared.Rent(segmentCount);
+            segments = pooledArray.AsSpan(0, segmentCount);
+        }
+
+        int start = 0;
+        for (int i = 0; i < segments.Length; i++)
+        {
+            int index = input.IndexOf('\n');
+            if (index < 0)
+            {
+                segments[i] = new StringSegment(start, input.Length);
+                break;
+            }
+
+            int newLineLength = 1;
+            if (index > 0 && input[index - 1] == '\r')
+            {
+                newLineLength++;
+                index--;
+            }
+
+            int totalLength = index + newLineLength;
+            segments[i] = new StringSegment(start, index);
+
+            start += totalLength;
+            input = input.Slice(totalLength);
+        }
+
+        return segments;
+    }
+
+    private struct StringSegment
+    {
+        public StringSegment(int start, int length)
+        {
+            Start = start;
+            Length = length;
+        }
+
+        public int Start { get; }
+        public int Length { get; }
+    }
+}
diff --git a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
index 204ed5ceee8..63e8f26bbe3 100644
--- a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
+++ b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Text;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd.Logging
@@ -18,19 +19,21 @@ internal class ConsoleOutputAligner
     {
         internal const int ConsoleTabWidth = 8;
 
-        private readonly StringBuilder _reusedStringBuilder = new(1024);
         private readonly int _bufferWidth;
         private readonly bool _alignMessages;
+        private readonly IStringBuilderProvider _stringBuilderProvider;
 
         /// <summary>
         /// Constructor.
         /// </summary>
         /// <param name="bufferWidth">Console buffer width. -1 if unknown/unlimited</param>
         /// <param name="alignMessages">Whether messages are aligned/wrapped into console buffer width</param>
-        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)
+        /// <param name="stringBuilderProvider"></param>
+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages, IStringBuilderProvider stringBuilderProvider)
         {
             _bufferWidth = bufferWidth;
             _alignMessages = alignMessages;
+            _stringBuilderProvider = stringBuilderProvider;
         }
 
         /// <summary>
@@ -50,9 +53,12 @@ public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int
             int i = 0;
             int j = message.IndexOfAny(MSBuildConstants.CrLf);
 
-            StringBuilder sb = _reusedStringBuilder;
-            // prepare reused StringBuilder instance for new use.
-            sb.Length = 0;
+            // Empiric value of average line length in console output. Used to estimate number of lines in message for StringBuilder capacity.
+            // Wrongly estimated capacity is not a problem as StringBuilder will grow as needed. It is just optimization to avoid multiple reallocations.
+            const int averageLineLength = 40;
+            int estimatedCapacity = message.Length + ((prefixAlreadyWritten ? 0 : prefixWidth)  + Environment.NewLine.Length) * (message.Length / averageLineLength + 1);
+            StringBuilder sb = _stringBuilderProvider.Acquire(estimatedCapacity);
+
             // The string contains new lines, treat each new line as a different string to format and send to the console
             while (j >= 0)
             {
@@ -64,7 +70,7 @@ public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int
             // Process rest of message
             AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, message.Length - i);
 
-            return sb.ToString();
+            return _stringBuilderProvider.GetStringAndRelease(sb);
         }
 
         /// <summary>
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 54ca8cba62e..d8d1dce3a34 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -101,7 +101,7 @@ private void CheckIfOutputSupportsAlignment()
                 }
             }
 
-            _consoleOutputAligner = new ConsoleOutputAligner(_bufferWidth, _alignMessages);
+            _consoleOutputAligner = new ConsoleOutputAligner(_bufferWidth, _alignMessages, (IStringBuilderProvider)this);
         }
 
         #endregion
diff --git a/src/Build/Logging/SimpleErrorLogger.cs b/src/Build/Logging/SimpleErrorLogger.cs
new file mode 100644
index 00000000000..6414324064b
--- /dev/null
+++ b/src/Build/Logging/SimpleErrorLogger.cs
@@ -0,0 +1,91 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Logging.TerminalLogger;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Logging.SimpleErrorLogger
+{
+    /// <summary>
+    /// This logger ignores all message-level output, writing errors and warnings to
+    /// standard error, colored red and yellow respectively.
+    ///
+    /// It is currently used only when the user requests information about specific
+    /// properties, items, or target results. In that case, we write the desired output
+    /// to standard out, but we do not want it polluted with any other kinds of information.
+    /// Users still might want diagnostic information if something goes wrong, so still
+    /// output that as necessary.
+    /// </summary>
+    public sealed class SimpleErrorLogger : INodeLogger
+    {
+        private readonly bool acceptAnsiColorCodes;
+        private readonly uint? originalConsoleMode;
+        public SimpleErrorLogger()
+        {
+            (acceptAnsiColorCodes, _, originalConsoleMode) = NativeMethods.QueryIsScreenAndTryEnableAnsiColorCodes(NativeMethods.StreamHandleType.StdErr);
+        }
+
+        public bool HasLoggedErrors { get; private set; } = false;
+
+        public LoggerVerbosity Verbosity
+        {
+            get => LoggerVerbosity.Minimal;
+            set { }
+        }
+
+        public string Parameters
+        {
+            get => string.Empty;
+            set { }
+        }
+
+        public void Initialize(IEventSource eventSource, int nodeCount)
+        {
+            eventSource.ErrorRaised += HandleErrorEvent;
+            eventSource.WarningRaised += HandleWarningEvent;
+
+            // This needs to happen so binary loggers can get evaluation properties and items
+            if (eventSource is IEventSource4 eventSource4)
+            {
+                eventSource4.IncludeEvaluationPropertiesAndItems();
+            }
+        }
+
+        private void HandleErrorEvent(object sender, BuildErrorEventArgs e)
+        {
+            HasLoggedErrors = true;
+            LogWithColor(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true),
+                TerminalColor.Red);
+        }
+
+        private void HandleWarningEvent(object sender, BuildWarningEventArgs e)
+        {
+            LogWithColor(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true),
+                TerminalColor.Yellow);
+        }
+
+        private void LogWithColor(string message, TerminalColor color)
+        {
+            if (acceptAnsiColorCodes)
+            {
+                Console.Error.Write(AnsiCodes.Colorize(message, color));
+            }
+            else
+            {
+                Console.Error.Write(message);
+            }
+        }
+
+        public void Initialize(IEventSource eventSource)
+        {
+            Initialize(eventSource, 1);
+        }
+
+        public void Shutdown()
+        {
+            NativeMethods.RestoreConsoleMode(originalConsoleMode, NativeMethods.StreamHandleType.StdErr);
+        }
+    }
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index f81f0ac23fa..ec790f452ea 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+Ôªø<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -32,13 +32,15 @@
 
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
+    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
-    <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+
+    <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildFromSource)' != 'true'">
@@ -47,18 +49,15 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <Reference Include="System.IO.Compression" />
     <PackageReference Include="System.Memory" />
+    <PackageReference Include="System.Text.Json" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="System.Reflection.Metadata" />
-    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <Link>SharedUtilities\EncodingUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\EnvironmentUtilities.cs">
       <Link>SharedUtilities\EnvironmentUtilities.cs</Link>
     </Compile>
@@ -113,9 +112,6 @@
     <Compile Include="..\Shared\INodePacket.cs" />
     <Compile Include="..\Shared\INodePacketFactory.cs" />
     <Compile Include="..\Shared\INodePacketHandler.cs" />
-    <Compile Include="..\Shared\ITranslatable.cs" />
-    <Compile Include="..\Shared\ITranslator.cs" />
-    <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\LogMessagePacketBase.cs" />
     <Compile Include="..\Shared\NodePacketFactory.cs" />
     <Compile Include="..\Shared\NodeBuildComplete.cs" />
@@ -158,11 +154,28 @@
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
     <Compile Include="BackEnd\Components\Communications\CurrentHost.cs" />
+    <Compile Include="BackEnd\Components\Communications\DetouredNodeLauncher.cs" />
+    <Compile Include="BackEnd\Components\Communications\SerializationContractInitializer.cs" />
     <Compile Include="BackEnd\Components\Communications\ServerNodeEndpointOutOfProc.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\IFileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\FileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\FileAccessReport.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\OutOfProcNodeFileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\ProcessReport.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\AssemblyLoadsTracker.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="Evaluation\IItemTypeDefinition.cs" />
+    <Compile Include="FileAccess\DesiredAccess.cs" />
+    <Compile Include="FileAccess\FileAccessData.cs" />
+    <Compile Include="FileAccess\FlagsAndAttributes.cs" />
+    <Compile Include="FileAccess\ProcessData.cs" />
+    <Compile Include="FileAccess\ReportedFileOperation.cs" />
+    <Compile Include="FileAccess\RequestedAccess.cs" />
+    <Compile Include="Logging\BinaryLogger\IBuildEventArgsReaderNotifications.cs" />
+    <Compile Include="Logging\BinaryLogger\IBuildEventStringsReader.cs" />
+    <Compile Include="Logging\BinaryLogger\StringReadEventArgs.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -362,6 +375,7 @@
     <Compile Include="BackEnd\Shared\TargetResult.cs" />
     <Compile Include="BackEnd\Shared\WorkUnitResult.cs" />
     <Compile Include="BackEnd\Components\BuildRequestEngine\IBuildRequestEngine.cs" />
+    <Compile Include="BackEnd\Components\Communications\INodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\INodeManager.cs" />
     <Compile Include="BackEnd\Components\Communications\INodeProvider.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeEndpointInProc.cs" />
@@ -621,12 +635,14 @@
     <Compile Include="Logging\LoggerDescription.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="Logging\OptimizedStringIndenter.cs" />
     <Compile Include="Logging\ParallelLogger\ParallelLoggerHelpers.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="Logging\ParallelLogger\ParallelConsoleLogger.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="Logging\SimpleErrorLogger.cs" />
     <Compile Include="Logging\ParallelLogger\ConsoleOutputAligner.cs" />
     <Compile Include="Logging\FileLogger.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
@@ -803,8 +819,4 @@
       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>
     </EmbeddedResource>
   </ItemGroup>
-
-  <ItemGroup>
-    <Compile Remove="Collections\RetrievableEntryHashSet\Originals\*" />
-  </ItemGroup>
 </Project>
diff --git a/src/Build/Microsoft.Build.pkgdef b/src/Build/Microsoft.Build.pkgdef
index 74546cfe4fe..5ade779232c 100644
--- a/src/Build/Microsoft.Build.pkgdef
+++ b/src/Build/Microsoft.Build.pkgdef
@@ -5,3 +5,27 @@
 "culture"="neutral"
 "oldVersion"="0.0.0.0-99.9.9.9"
 "newVersion"="15.1.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{F74A7C60-AC4A-4EC4-A8DB-1FE89FDB53CD}]
+"name"="BuildXL.Processes"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Processes.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{A038F286-A634-460D-9964-75465129EEF2}]
+"name"="BuildXL.Utilities.Core"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Utilities.Core.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{0EE5D593-1F73-4FA2-98D7-B347DFD50186}]
+"name"="BuildXL.Native"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Native.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index 2436979d94f..ed2e16683ba 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -365,6 +365,15 @@ private static void InitializeAvailableMethods()
                         availableStaticMethods.TryAdd("Microsoft.Build.Utilities.ToolLocationHelper", new Tuple<string, Type>("Microsoft.Build.Utilities.ToolLocationHelper, Microsoft.Build.Utilities.Core, Version=" + MSBuildConstants.CurrentAssemblyVersion + ", Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", null));
                         availableStaticMethods.TryAdd("System.Runtime.InteropServices.RuntimeInformation", runtimeInformationType);
                         availableStaticMethods.TryAdd("System.Runtime.InteropServices.OSPlatform", osPlatformType);
+#if NET5_0_OR_GREATER
+                        var operatingSystemType = new Tuple<string, Type>(null, typeof(OperatingSystem));
+                        availableStaticMethods.TryAdd("System.OperatingSystem", operatingSystemType);
+#else
+                        // Add alternate type for System.OperatingSystem static methods which aren't available on .NET Framework.
+                        var operatingSystemType = new Tuple<string, Type>("Microsoft.Build.Framework.OperatingSystem, Microsoft.Build.Framework, Version=" + MSBuildConstants.CurrentAssemblyVersion + ", Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", null);
+                        availableStaticMethods.TryAdd("System.OperatingSystem", operatingSystemType);
+                        availableStaticMethods.TryAdd("Microsoft.Build.Framework.OperatingSystem", operatingSystemType);
+#endif
 
                         s_availableStaticMethods = availableStaticMethods;
                     }
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 52faacfee31..0707bc3bbb4 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -463,6 +463,10 @@
     likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
     special exception to abort the build.</comment>
   </data>
+  <data name="General.TwoVectorsMustHaveSameLength">
+    <value>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</value>
+    <comment>{StrBegin="MSB3094: "}</comment>
+  </data>
   <data name="FatalTaskError" xml:space="preserve">
     <value>MSB4018: The "{0}" task failed unexpectedly.</value>
     <comment>{StrBegin="MSB4018: "}UE: This message is shown when a task terminates because of an unhandled exception. The cause is most likely a
@@ -474,7 +478,7 @@
     <comment>{StrBegin="MSB4187: "}</comment>
   </data>
   <data name="UnhandledMSBuildError" xml:space="preserve">
-    <value>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+    <value>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</value>
   </data>
   <data name="IllFormedCondition" xml:space="preserve">
@@ -1902,6 +1906,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProjectCacheShutdownFailed" xml:space="preserve">
     <value>MSB4268: The project cache failed to shut down properly.</value>
   </data>
+  <data name="ProjectCacheHandleBuildResultFailed" xml:space="preserve">
+    <value>MSB4269: The project cache failed while handling a build result for the following project: {0}.</value>
+  </data>
   <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
     <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
@@ -1983,4 +1990,22 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="NodeReused" xml:space="preserve">
     <value>Reusing node {0} (PID: {1}).</value>
   </data>
-</root>
\ No newline at end of file
+  <data name="ItemReferencingSelfInTarget" xml:space="preserve">
+    <value>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</value>
+    <comment>{StrBegin="MSB4120: "}</comment>
+  </data>
+  <data name="CannotCopyFromElementOfThatType" xml:space="preserve">
+    <value>MSB4277: Cannot copy from object of that type.</value>
+    <comment>{StrBegin="MSB4277: "}</comment>
+  </data>
+  <data name="ReportFileAccessesX64Only" xml:space="preserve">
+    <value>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</value>
+  </data>
+  <!--
+        The Build message bucket is: MSB4000 - MSB4999
+
+        Next message code should be MSB4278
+
+        Don't forget to update this comment after using a new code.
+  -->
+</root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 482f271ba03..1db6de11f1b 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: Nelze kop√≠rovat z objektu tohoto typu.</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: Nejde rozbalit metadata ve v√Ωrazu {0}. {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: Promƒõnn√° prost≈ôed√≠ MSBUILDDISABLEFEATURESFROMVERSION je nastavena na neplatn√Ω form√°t. Povolov√°n√≠ v≈°ech verz√≠ Change Waves. Zadan√° hodnota: {0}. Aktu√°ln√≠ Change Waves: {1}</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: Promƒõnn√° prost≈ôed√≠ MSBUILDDISABLEFEATURESFROMVERSION je nastavena na verzi, kter√° je mimo rotaci. N√°vrat k v√Ωchoz√≠ verzi Change Wave: {0}. Zadan√° hodnota: {1}. Aktu√°ln√≠ Change Waves: {2}</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: V√Ωchoz√≠ p≈ôekladaƒç sady SDK nedok√°zal p≈ôelo≈æit sadu SDK ‚Äû{0}‚Äú, proto≈æe adres√°≈ô ‚Äû{1}‚Äú neexistoval.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Vlastnost ‚Äû{0}‚Äú s hodnotou ‚Äû{1}‚Äú rozbalenou z prost≈ôed√≠.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Nepovedlo se p≈ôelo≈æit sadu SDK ‚Äû{0}‚Äú. P≈ôesnƒõ jedna z n√≠≈æe uveden√Ωch zpr√°v o testov√°n√≠ oznaƒçuje, proƒç se n√°m nepovedlo p≈ôelo≈æit sadu SDK. Pro≈°et≈ôete a vy≈ôe≈°te tuto zpr√°vu, abyste spr√°vnƒõ urƒçili sadu SDK.
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: Polo≈æka {2} odkazuje na {0} polo≈æek a polo≈æka {3} odkazuje na {1} polo≈æek. Mus√≠ m√≠t stejn√Ω poƒçet polo≈æek.</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Na pozici {1} podm√≠nky {0} je neoƒçek√°van√° mezera. Nezapomnƒõli jste ji odebrat?</target>
@@ -154,6 +164,11 @@
         <target state="translated">Objekty EvaluationContext vytvo≈ôen√© pomoc√≠ SharingPolicy.Isolated nepodporuj√≠ p≈ôed√°v√°n√≠ souborov√©ho syst√©mu MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: Definice polo≈æky ‚Äû{0}‚Äú v r√°mci c√≠le odkazuje sama na sebe prost≈ôednictv√≠m metadat (kvalifikovan√©ho nebo nekvalifikovan√©ho) ‚Äû{1}‚Äú. To m≈Ø≈æe v√©st k nezam√Ω≈°len√©mu roz≈°√≠≈ôen√≠ a k≈ô√≠≈æov√©mu pou≈æit√≠ ji≈æ existuj√≠c√≠ch polo≈æek. Dal≈°√≠ informace: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Ukonƒçuje se proces s pid = {0}.</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Naƒç√≠t√° se n√°sleduj√≠c√≠ modul plug-in mezipamƒõti projektu: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Opakovan√© pou≈æit√≠ {0} uzlu (PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: Mezipamƒõ≈• projektu vyvolala neo≈°et≈ôenou v√Ωjimku z metody {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Mezipamƒõ≈• projektu selhala p≈ôi zpracov√°n√≠ v√Ωsledku sestaven√≠ pro n√°sleduj√≠c√≠ projekt: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">P≈ô√≠stup do mezipamƒõti projektu pro ‚Äû{0}‚Äú (v√Ωchoz√≠ c√≠le).</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpozn√°n. Pokud jste chtƒõli, aby to byla vlastnost, uzav≈ôete ji do elementu &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: Zak√°z√°n√≠ uzlu inproc zp≈Øsob√≠ sn√≠≈æen√≠ v√Ωkonu p≈ôi pou≈æ√≠v√°n√≠ modul≈Ø plug-in mezipamƒõti projektu, kter√© vys√≠laj√≠ ≈æ√°dosti o sestaven√≠ proxy serveru.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">P≈ô√≠stupy k soubor≈Øm sestav se v souƒçasn√© dobƒõ podporuj√≠ jenom pomoc√≠ varianty x64 n√°stroje MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Selh√°n√≠ p≈ôekladaƒçe sady SDK: {0}</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">P≈ôekladaƒç sady SDK ‚Äû{0}‚Äú vr√°til hodnotu null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Sestaven√≠ naƒçten√© bƒõhem {0}{1}: {2} (um√≠stƒõn√≠: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,7 +475,7 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
         <target state="translated">Jedn√° se o neo≈°et≈ôenou v√Ωjimku v MSBuildu ‚Äì HLASUJTE PROS√çM PRO EXISTUJ√çC√ç PROBL√âM NEBO VYTVO≈òTE NOV√ù NA https://aka.ms/msbuild/unhandled.
     {0}</target>
@@ -1460,7 +1485,7 @@
       </trans-unit>
       <trans-unit id="SolutionVenusProjectSkipped">
         <source>Skipping because the "$(AspNetConfiguration)" configuration is not supported for this web project.  You can use the AspNetConfiguration property to override the configuration used for building web projects, by adding /p:AspNetConfiguration=&lt;value&gt; to the command line. Currently web projects only support Debug and Release configurations.</source>
-        <target state="translated">Vynech√°no, proto≈æe konfigurace $(AspNetConfiguration) nen√≠ pro tento webov√Ω projekt podporov√°na. Pomoc√≠ vlastnosti AspNetConfiguration m≈Ø≈æete p≈ôepsat konfiguraci pou≈æ√≠vanou k sestavov√°n√≠ webov√Ωch projekt≈Ø, a to p≈ôid√°n√≠m p≈ô√≠kazu /p:AspNetConfiguration=&lt;hodnota&gt; do p≈ô√≠kazov√©ho ≈ô√°dku. Webov√© projekty nyn√≠ podporuj√≠ pouze konfigurace Debug a Release.</target>
+        <target state="translated">Vynech√°no, proto≈æe konfigurace "$(AspNetConfiguration)" nen√≠ pro tento webov√Ω projekt podporov√°na. Pomoc√≠ vlastnosti AspNetConfiguration m≈Ø≈æete p≈ôepsat konfiguraci pou≈æ√≠vanou k sestavov√°n√≠ webov√Ωch projekt≈Ø, a to p≈ôid√°n√≠m p≈ô√≠kazu /p:AspNetConfiguration=&lt;hodnota&gt; do p≈ô√≠kazov√©ho ≈ô√°dku. Webov√© projekty nyn√≠ podporuj√≠ pouze konfigurace Debug a Release.</target>
         <note>
     UE: This is not an error, so doesn't need an error code.
     LOCALIZATION: Do NOT localize "AspNetConfiguration", "Debug", "Release".
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 35576a9f7af..69cc59f2ece 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: Aus einem Objekt dieses Typs kann nicht kopiert werden.</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: Metadaten k√∂nnen im Ausdruck "{0}" nicht erweitert werden. {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: Die Umgebungsvariable MSBUILDDISABLEFEATURESFROMVERSION ist auf ein ung√ºltiges Format festgelegt. Alle √Ñnderungszyklusversionen werden aktiviert. Eingegebener Wert: {0}. Aktuelle √Ñnderungszyklen: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: Die Umgebungsvariable MSBUILDDISABLEFEATURESFROMVERSION ist auf eine nicht rotierende Version festgelegt und wird auf die Standard-√Ñnderungszyklusversion gesetzt: {0}. Eingegebener Wert: {1}. Aktuelle √Ñnderungszyklen: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: Der SDK-Standardresolver konnte SDK "{0}" nicht aufl√∂sen, da das Verzeichnis "{1}" nicht vorhanden war.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Die Eigenschaft "{0}" mit dem Wert "{1}" wurde aus der Umgebung erweitert.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Das SDK "{0}" konnte nicht aufgel√∂st werden. Genau eine der folgenden Testmeldungen gibt an, warum das SDK nicht aufgel√∂st werden konnte. Untersuchen und beheben Sie diese Meldung, um das SDK richtig anzugeben.
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: "{2}" verweist auf {0} Element(e), und "{3}" verweist auf {1} Element(e). Die Anzahl von Elementen muss identisch sein.</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Unerwartetes Leerzeichen an Position "{1}" der Bedingung "{0}". Haben Sie vergessen, ein Leerzeichen zu entfernen?</target>
@@ -154,6 +164,11 @@
         <target state="translated">Die √úbergabe eines MSBuildFileSystemBase-Dateisystems an EvaluationContext-Objekte, die mit "SharingPolicy.Isolated" erstellt wurden, wird nicht unterst√ºtzt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: Element "{0}" Definition innerhalb des Zielverweises selbst √ºber (qualifiziertes oder nicht qualifiziertes) Metadatum "{1}". Dies kann zu einer unbeabsichtigten Erweiterung und einer kreuzseitigen Anwendung bereits vorhandener Elemente f√ºhren. Weitere Informationen: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Der Prozess mit PID {0} wird beendet.</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Folgendes Projektcache-Plug-In wird geladen: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Der Knoten "{0}" wird wiederverwendet (PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: Der Projektcache hat √ºber die Methode {0} eine unbehandelte Ausnahme ausgel√∂st.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Fehler beim Verarbeiten eines Buildergebnisses f√ºr das folgende Projekt im Projektcache: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Projektcachetreffer f√ºr ‚Äû{0}‚Äú (Standardziele).</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: Das Element &lt;{0}&gt; unterhalb des Elements &lt;{1}&gt; ist unbekannt. Wenn dies eine Eigenschaft sein sollte, schlie√üen Sie sie in ein &lt;PropertyGroup&gt;-Element ein.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: Das Deaktivieren des In-Process-Knotens f√ºhrt zu Leistungseinbu√üen bei der Verwendung von Projektcache-Plug-Ins, die Proxybuildanforderungen ausgeben.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Das Melden von Dateizugriffen wird derzeit nur mit der x64-Variante von MSBuild unterst√ºtzt.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Fehler bei SDK-Resolver: "{0}"</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">Der SDK-Resolver "{0}" hat NULL zur√ºckgegeben.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Assembly w√§hrend {0}{1} geladen: {2} (Speicherort: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,9 +475,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Dies ist eine nicht behandelte Ausnahme in MSBuild. RUFEN SIE EIN VORHANDENES PROBLEM AUF, ODER ERSTELLEN SIE EIN NEUES UNTER https://aka.ms/msbuild/unhandled.
+        <target state="translated">Dies ist ein Ausnahmefehler in MSBuild. STIMMEN SIE EINEM VORHANDENEN ISSUE ZU, ODER ERSTELLEN SIE EIN NEUES ISSUE UNTER https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 3b491802de3..b239a2147f8 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: No se puede copiar desde un objeto de ese tipo.</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: No se pueden expandir los metadatos en la expresi√≥n "{0}". {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: La variable de entorno MSBUILDDISABLEFEATURESFROMVERSION est√° establecida en un formato no v√°lido. Habilitando todas las versiones de oleadas de cambios. Valor especificado: {0}. Oleadas de cambios actuales: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: La variable de entorno MSBUILDDISABLEFEATURESFROMVERSION est√° establecida en una versi√≥n no incluida en la rotaci√≥n. Se va a cambiar a la versi√≥n de oleada de cambios de forma predeterminada: {0}. Valor especificado: {1}. Oleadas de cambios actuales: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: La resoluci√≥n predeterminada del SDK no pudo resolver el SDK "{0}" porque el directorio "{1}" no exist√≠a.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Propiedad "{0}" con el valor "{1}" expandido desde el entorno.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">No se ha podido resolver el SDK "{0}". Exactamente uno de los siguientes mensajes de sondeo indica por qu√© no se pudo resolver el SDK. Investigue y resuelva ese mensaje para especificar correctamente el SDK.
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: "{2}" hace referencia a {0} elementos y "{3}" hace referencia a {1} elementos. Deben tener el mismo n√∫mero de elementos.</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Espacio inesperado en la posici√≥n "{1}" de la condici√≥n "{0}". ¬øOlvid√≥ quitar un espacio?</target>
@@ -154,6 +164,11 @@
         <target state="translated">Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: Definici√≥n del elemento ''{0}'' dentro de las propias referencias de destino a trav√©s del metadato ''{1}'' (calificado o no calificado). Esto puede dar lugar a una expansi√≥n no deseada y la aplicaci√≥n cruzada de elementos preexistente. M√°s informaci√≥n: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Terminando el proceso con el PID = {0}.</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Cargando el complemento de cach√© de proyectos siguiente:{0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Reutilizando nodo {0} (PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: la cach√© del proyecto inici√≥ una excepci√≥n no controlada desde el m√©todo {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: error en la cach√© del proyecto al controlar un resultado de compilaci√≥n para el siguiente proyecto: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Acierto de cach√© de proyecto para "{0}" (destinos predeterminados).</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: No se reconoce el elemento &lt;{0}&gt; debajo del elemento &lt;{1}&gt;. Si pretend√≠a que fuera una propiedad, escr√≠bala dentro de un elemento &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: Al deshabilitar el nodo InProc, se degrada el rendimiento cuando use los complementos de cach√© de proyectos que emiten solicitudes de compilaci√≥n de proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Los accesos a archivos de informes solo se admiten actualmente con el tipo x64 de MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Error del solucionador del SDK: "{0}"</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">La resoluci√≥n del SDK "{0}" devolvi√≥ null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Ensamblado cargado durante {0}{1}: {2} (ubicaci√≥n: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,9 +475,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Esta es una excepci√≥n no controlada en MSBuild. VOTE POR UN PROBLEMA EXISTENTE O PRESENTE UNO NUEVO EN https://aka.ms/msbuild/unhandled.
+        <target state="translated">Esta es una excepci√≥n no controlada en MSBuild. VOTE POR UN PROBLEMA EXISTENTE O PRESENTE UNO NUEVO EN https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index fbbb2252b81..bac1148e509 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: Impossible de copier √† partir d‚Äôun objet de ce type.</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: Impossible d'√©tendre les m√©tadonn√©es dans l'expression "{0}". {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: la variable d'environnement MSBUILDDISABLEFEATURESFROMVERSION a un format non valide. Activation de toutes les versions des vagues de changements. Valeur entr√©e¬†: {0}. Vagues de changements actuelles¬†: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: la variable d'environnement MSBUILDDISABLEFEATURESFROMVERSION a une valeur correspondant √† une version hors rotation. Utilisation par d√©faut de la vague de changements version {0}. Valeur entr√©e¬†: {1}. Vagues de changements actuelles¬†: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: Le programme de r√©solution du SDK par d√©faut n‚Äôa pas pu r√©soudre le SDK ¬´{0}¬ª, car le r√©pertoire ¬´{1}¬ª n‚Äôexistait pas.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Propri√©t√© '{0}' avec la valeur '{1}' d√©velopp√©e √† partir de l‚Äôenvironnement.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Impossible de r√©soudre le SDK ¬´{0}¬ª. Exactement l‚Äôun des messages de sondage ci-dessous indique pourquoi nous n‚Äôavons pas pu r√©soudre le Kit de d√©veloppement logiciel (SDK). Examinez et r√©solvez ce message pour sp√©cifier correctement le Kit de d√©veloppement logiciel (SDK).
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: "{2}" fait r√©f√©rence √† {0} √©l√©ment(s) et "{3}", √† {1} √©l√©ment(s). Ils doivent avoir le m√™me nombre d'√©l√©ments.</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: espace inattendu √† la position "{1}" de la condition "{0}". Avez-vous oubli√© de supprimer un espace¬†?</target>
@@ -154,6 +164,11 @@
         <target state="translated">Les objets EvaluationContext cr√©√©s avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un syst√®me de fichiers MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: La d√©finition de l‚Äô√©l√©ment '{0}' dans la cible se r√©f√©rence elle-m√™me via la m√©tadonn√©e '{1}' (qualifi√©e ou non qualifi√©e). Cela peut entra√Æner l‚Äôexpansion involontaire et l‚Äôapplication crois√©e d‚Äô√©l√©ments pr√©existants. Plus d‚Äôinformations : https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Arr√™t du processus ayant le PID = {0}.</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Chargement du plug-in de cache de projet suivant¬†:{0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">R√©utilisation du {0} de n≈ìud (PID : {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: le cache de projet a lev√© une exception non g√©r√©e √† partir de la m√©thode {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: le cache du projet a √©chou√© lors de la gestion d‚Äôun r√©sultat de build pour le projet suivant : {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Le cache de projet a √©t√© atteint pour ¬´ {0} ¬ª (cibles par d√©faut).</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: L‚Äô√©l√©ment &lt;{0}&gt; sous l‚Äô√©l√©ment &lt;{1}&gt; n‚Äôest pas reconnu. Si vous souhaitiez qu‚Äôil s‚Äôagit d‚Äôune propri√©t√©, placez-la dans un √©l√©ment &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: la d√©sactivation du n≈ìud inproc entra√Æne une d√©t√©rioration des performances lors de l‚Äôutilisation de plug-ins de cache de projet qui √©mettent des requ√™tes de build proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Les acc√®s aux fichiers de cr√©ation de rapports sont uniquement pris en charge √† l‚Äôaide de la saveur x64 de MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: √âchec du Programme de R√©solution SDK : ¬´{0}¬ª</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">Le programme de r√©solution du Kit de d√©veloppement logiciel (SDK) ¬´{0}¬ª a retourn√© null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Assembly charg√© pendant {0}{1}: {2} (emplacement : {3}, MVID : {4}, AppDomain : {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,9 +475,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Il s‚Äôagit d‚Äôune exception non g√©r√©e dans MSBuild -- VOTEZ POUR UN PROBL√àME EXISTANT OU ENTREZ UN NOUVEAU FICHIER √Ä https://aka.ms/msbuild/unhandled.
+        <target state="translated">Il s‚Äôagit d‚Äôune exception non prise en charge dans MSBuild¬†‚Äì‚Äì VOTEZ POUR UN PROBL√àME EXISTANT OU CR√âEZ-EN UN SUR https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index a3a5cb9eca1..2b84a74df2e 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: non √® possibile eseguire la copia dall'oggetto di quel tipo.</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: non √® possibile espandere i metadati nell'espressione "{0}". {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: la variabile di ambiente MSBUILDDISABLEFEATURESFROMVERSION √® impostata su un formato non valido. Verranno abilitate tutte le versioni con flussi di modifiche. Valore immesso: {0}. Flussi di modifiche correnti: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: la variabile di ambiente MSBUILDDISABLEFEATURESFROMVERSION √® impostata su una versione esclusa dalla rotazione. Per impostazione predefinita, verr√† usata la versione con flussi di modifiche: {0}. Valore immesso: {1}. Flussi di modifiche correnti: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: il resolver SDK predefinito non √® riuscito a risolvere l'SDK "{0}" perch√© la directory "{1}" non esiste.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">La propriet√† '{0}' con valore '{1}' espansa dall'ambiente.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Non √® stato possibile risolvere l'SDK "{0}". Uno dei messaggi di verifica riportati seguenti indica il motivo per cui non √® stato possibile risolvere l'SDK. Esaminare e risolvere il messaggio per specificare correttamente l'SDK.
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: "{2}" fa riferimento a {0} elemento/i, mentre "{3}" fa riferimento a {1} elemento/i. Devono avere lo stesso numero di elementi.</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: spazio imprevisto alla posizione "{1}" della condizione "{0}". Si √® dimenticato di rimuovere uno spazio?</target>
@@ -154,6 +164,11 @@
         <target state="translated">Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non √® possibile passare un file system MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: la definizione dell'elemento '{0}' all'interno del target fa riferimento a se stessa tramite il metadatum (qualificato o non qualificato) '{1}'. Ci√≤ pu√≤ causare un'espansione involontaria e l'applicazione incrociata di elementi preesistenti. Altre informazioni: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Terminazione del processo con PID = {0}.</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Caricamento del plug-in della cache del progetto seguente: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Riutilizzo del nodo {0} (PID: {1} ).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: la cache del progetto ha generato un'eccezione non gestita dal metodo {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: errore della cache del progetto durante la gestione di un risultato di compilazione per il progetto seguente: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Riscontro nella cache del progetto per "{0}" (destinazioni predefinite).</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: l'elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non √® riconosciuto. Se era destinato a essere una propriet√†, racchiuderlo in un elemento &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: la disabilitazione del nodo InProc porta a una riduzione del livello delle prestazioni quando si usano plug-in della cache del progetto che emettono richieste di compilazione proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Gli accessi ai file di report sono attualmente supportati solo con la versione x64 di MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: errore sistema di risoluzione SDK: "{0}"</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">Il resolver SDK "{0}" ha restituito null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Assembly caricato durante {0}{1}: {2} (percorso: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,9 +475,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Si tratta di un'eccezione non gestita in MSBuild-- ESEGUIRE L'UPVOTE DI UN PROBLEMA ESISTENTE O DI UN FILE NUOVO IN https://aka.ms/msbuild/unhandled.
+        <target state="translated">Si tratta di un'eccezione non gestita in MSBuild-- ESEGUIRE L'UPVOTE DI UN PROBLEMA ESISTENTE O DI UN FILE NUOVO IN https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index e45710015a8..b542f06c26c 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: „Åù„ÅÆÂûã„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„Çâ„Ç≥„Éî„Éº„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: Âºè "{0}" „ÅÆ‰∏≠„ÅÆ„É°„Çø„Éá„Éº„Çø„ÇíÂ±ïÈñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: Áí∞Â¢ÉÂ§âÊï∞ MSBUILDDISABLEFEATURESFROMVERSION „ÅåÁÑ°Âäπ„Å™ÂΩ¢Âºè„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åô„Åπ„Å¶„ÅÆÂ§âÊõ¥„Ç¶„Çß„Éº„Éñ „Éê„Éº„Ç∏„Éß„É≥„ÇíÊúâÂäπ„Å´„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÖ•Âäõ„Åï„Çå„ÅüÂÄ§: {0}„ÄÇÁèæÂú®„ÅÆÂ§âÊõ¥„Ç¶„Çß„Éº„Éñ: {1}„ÄÇ</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: Áí∞Â¢ÉÂ§âÊï∞ MSBUILDDISABLEFEATURESFROMVERSION „Åå„ÄÅ„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥„Åã„ÇâÂ§ñ„Çå„Å¶„ÅÑ„Çã„Éê„Éº„Ç∏„Éß„É≥„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇÂ§âÊõ¥„Ç¶„Çß„Éº„Éñ „Éê„Éº„Ç∏„Éß„É≥„ÇíÊó¢ÂÆöÂÄ§„Å´„Åó„Å¶„ÅÑ„Åæ„Åô: {0}„ÄÇÂÖ•Âäõ„Åï„Çå„ÅüÂÄ§: {1}„ÄÇÁèæÂú®„ÅÆÂ§âÊõ¥„Ç¶„Çß„Éº„Éñ: {2}„ÄÇ</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: „Éá„Ç£„É¨„ÇØ„Éà„É™ "{0}" „ÅåÂ≠òÂú®„Åó„Å™„Åã„Å£„Åü„Åü„ÇÅ„ÄÅÊó¢ÂÆö„ÅÆ SDK „É™„Çæ„É´„Éê„Éº„ÅØ SDK "{1}" „ÇíËß£Ê±∫„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Áí∞Â¢É„Åã„ÇâÂ±ïÈñã„Åï„Çå„Åü '{1}' ÂÄ§„ÇíÊåÅ„Å§„Éó„É≠„Éë„ÉÜ„Ç£ '{0}'„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">SDK "{0}" „ÇíËß£Ê±∫„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ‰ª•‰∏ã„ÅÆ„Éó„É≠„Éº„Éñ „É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ 1 „Å§„ÅØ„ÄÅSDK „ÇíËß£Ê±∫„Åß„Åç„Å™„Åã„Å£„ÅüÁêÜÁî±„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇSDK „ÇíÊ≠£„Åó„ÅèÊåáÂÆö„Åô„Çã„Å´„ÅØ„ÄÅ„Åù„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË™øÊüª„Åó„Å¶Ëß£Ê±∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: "{2}" „ÅØ {0} È†ÖÁõÆ„ÇíÂèÇÁÖß„Åó„ÄÅ"{3}" „ÅØ {1} È†ÖÁõÆ„ÇíÂèÇÁÖß„Åó„Åæ„Åô„ÄÇ„Åì„Çå„Çâ„ÅØÂêå„ÅòÈ†ÖÁõÆÊï∞„ÇíÊåÅ„Åü„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Êù°‰ª∂ "{0}" „ÅÆ‰ΩçÁΩÆ "{1}" „Å´‰∫àÊúü„Åó„Å™„ÅÑ„Çπ„Éö„Éº„Çπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Çπ„Éö„Éº„Çπ„ÇíÂâäÈô§„Åó„Åü„ÅãÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
@@ -154,6 +164,11 @@
         <target state="translated">SharingPolicy.Isolated „ÇíÊåáÂÆö„Åó„Å¶‰ΩúÊàê„Åï„Çå„Åü EvaluationContext „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´ MSBuildFileSystemBase „Éï„Ç°„Ç§„É´ „Ç∑„Çπ„ÉÜ„É†„ÇíÊ∏°„Åô„Åì„Å®„ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: „Çø„Éº„Ç≤„ÉÉ„ÉàÂÜÖ„ÅÆÈ†ÖÁõÆ '{0}' ÂÆöÁæ©„ÅØ„ÄÅ„É°„Çø„ÉÄ„Çø„É† '{1}' „Çí‰ªã„Åó„Å¶ (‰øÆÈ£æ„Åæ„Åü„ÅØÈùû‰øÆÈ£æ) ÂèÇÁÖßËá™‰Ωì„ÇíÂèÇÁÖß„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„Å´„Çà„Çä„ÄÅÊÑèÂõ≥„Åó„Å™„ÅÑÂ±ïÈñã„ÇÑÊó¢Â≠ò„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅÆ„ÇØ„É≠„ÇπÈÅ©Áî®„ÅåÁô∫Áîü„Åô„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇË©≥Á¥∞ÊÉÖÂ†±: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">PID = {0} „ÅÆ„Éó„É≠„Çª„Çπ„Çí‰∏≠Ê≠¢„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Ê¨°„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Ç≠„É£„ÉÉ„Ç∑„É• „Éó„É©„Ç∞„Ç§„É≥„ÇíË™≠„ÅøËæº„Çì„Åß„ÅÑ„Åæ„Åô: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">„Éé„Éº„Éâ {0} „ÇíÂÜçÂà©Áî®„Åó„Å¶„ÅÑ„Åæ„Åô (PID: {1})„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: „Éó„É≠„Ç∏„Çß„ÇØ„Éà „Ç≠„É£„ÉÉ„Ç∑„É•„Åå {0} „É°„ÇΩ„ÉÉ„Éâ„ÅßÂá¶ÁêÜ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ‰æãÂ§ñ„ÅåËøî„Åï„Çå„Åæ„Åó„Åü„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Ê¨°„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ„Éì„É´„ÉâÁµêÊûú„ÇíÂá¶ÁêÜ‰∏≠„Å´„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Ç≠„É£„ÉÉ„Ç∑„É•„ÅåÂ§±Êïó„Åó„Åæ„Åó„Åü: {0}„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}" „ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Ç≠„É£„ÉÉ„Ç∑„É• „Éí„ÉÉ„Éà (Êó¢ÂÆö„ÅÆ„Çø„Éº„Ç≤„ÉÉ„Éà)„ÄÇ</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: Ë¶ÅÁ¥† &lt;{0}&gt; „ÅÆ‰∏ã &lt;{1}&gt; Ë¶ÅÁ¥†„ÇíË™çË≠ò„Åß„Åç„Åæ„Åõ„Çì„ÄÇ„Åì„Çå„Çí„Éó„É≠„Éë„ÉÜ„Ç£„Å´„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅ&lt;PropertyGroup&gt; Ë¶ÅÁ¥†ÂÜÖ„ÅßÂõ≤„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: „Éó„É≠„Ç≠„Ç∑„Éª„Éì„É´„ÉâË¶ÅÊ±Ç„ÇíÂá∫„Åô„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Ç≠„É£„ÉÉ„Ç∑„É• „Éó„É©„Ç∞„Ç§„É≥„Çí‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÄÅInProc „Éé„Éº„Éâ„ÇíÁÑ°Âäπ„Å´„Åô„Çã„Å®„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Åå‰Ωé‰∏ã„Åó„Åæ„Åô„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">„Éï„Ç°„Ç§„É´ „Ç¢„ÇØ„Çª„Çπ„ÅÆ„É¨„Éù„Éº„Éà„ÅØ„ÄÅÁèæÂú®„ÄÅMSBuild „ÅÆ x64 „Éï„É¨„Éº„Éê„Éº„Çí‰ΩøÁî®„Åó„Å¶„ÅÆ„Åø„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK „É™„Çæ„É´„Éê„Éº „Ç®„É©„Éº: "{0}"</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">SDK „É™„Çæ„É´„Éê„Éº "{0}" „Åå null „ÇíËøî„Åó„Åæ„Åó„Åü„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">{0}{1} ‰∏≠„Å´„Ç¢„Çª„É≥„Éñ„É™„ÅåË™≠„ÅøËæº„Åæ„Çå„Åæ„Åó„Åü: {2} (Â†¥ÊâÄ: {3}„ÄÅMVID: {4}„ÄÅAppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,7 +475,7 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
         <target state="translated">„Åì„Çå„ÅØ MSBuild „Åß„Éè„É≥„Éâ„É´„Åï„Çå„Å™„ÅÑ‰æãÂ§ñ„Åß„Åô -- Êó¢Â≠ò„ÅÆÂïèÈ°å„Å´Ë≥õÊàêÁ•®„ÇíÊäï„Åò„Çã„Åã„ÄÅhttps://aka.ms/msbuild/unhandled „ÅßÊñ∞„Åó„ÅÑÂïèÈ°å„ÇíÊèêËµ∑„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
     {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 78c2001194e..cc93c3d1c32 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: Ìï¥Îãπ ÌòïÏãùÏùò Í∞úÏ≤¥ÏóêÏÑú Î≥µÏÇ¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§.</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: "{0}" ÏãùÏóêÏÑú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Î•º ÌôïÏû•Ìï† Ïàò ÏóÜÏäµÎãàÎã§. {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: ÌôòÍ≤Ω Î≥ÄÏàò MSBUILDDISABLEFEATURESFROMVERSIONÏù¥ ÏûòÎ™ªÎêú ÌòïÏãùÏúºÎ°ú ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏäµÎãàÎã§. Î≥ÄÍ≤Ω Ïõ®Ïù¥Î∏å Î≤ÑÏ†ÑÏùÑ Î™®Îëê ÏÇ¨Ïö©ÌïòÎèÑÎ°ù ÏÑ§Ï†ïÌï©ÎãàÎã§. ÏûÖÎ†•Ìïú Í∞í: {0}. ÌòÑÏû¨ Î≥ÄÍ≤Ω Ïõ®Ïù¥Î∏å: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: ÌôòÍ≤Ω Î≥ÄÏàò MSBUILDDISABLEFEATURESFROMVERSIONÏù¥ ÏàúÌôòÎêòÏßÄ ÏïäÎäî Î≤ÑÏ†ÑÏúºÎ°ú ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏäµÎãàÎã§. Í∏∞Î≥∏Í∞íÏù∏ Î≥ÄÍ≤Ω Ïõ®Ïù¥Î∏å Î≤ÑÏ†Ñ {0}(Ïúº)Î°ú ÏÑ§Ï†ïÌï©ÎãàÎã§. ÏûÖÎ†•Ìïú Í∞í: {1}. ÌòÑÏû¨ Î≥ÄÍ≤Ω Ïõ®Ïù¥Î∏å: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: ÎîîÎ†âÌÑ∞Î¶¨ "{0}"Ïù¥(Í∞Ä) ÏóÜÏúºÎØÄÎ°ú Í∏∞Î≥∏ SDK ÌôïÏù∏ÏûêÍ∞Ä SDK "{1}"ÏùÑ(Î•º) ÌôïÏù∏ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">ÌôòÍ≤ΩÏóêÏÑú Í∞íÏù¥ '{0}'Ïù∏ ÏÜçÏÑ± '{1}'Ïù¥(Í∞Ä) ÌôïÏû•ÎêòÏóàÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">SDK "{0}"ÏùÑ(Î•º) ÌôïÏù∏Ìï† Ïàò ÏóÜÏäµÎãàÎã§. ÏïÑÎûò Í≤ÄÏÉâ Î©îÏãúÏßÄ Ï§ë Ï†ïÌôïÌûà ÌïòÎÇòÎäî SDKÎ•º ÌôïÏù∏Ìï† Ïàò ÏóÜÎäî Ïù¥Ïú†Î•º ÎÇòÌÉÄÎÉÖÎãàÎã§. Ìï¥Îãπ Î©îÏãúÏßÄÎ•º Ï°∞ÏÇ¨ÌïòÍ≥† ÌôïÏù∏ÌïòÏó¨ SDKÎ•º Ïò¨Î∞îÎ•¥Í≤å ÏßÄÏ†ïÌï©ÎãàÎã§.
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: "{2}"ÏùÄ(Îäî) Ìï≠Î™©ÏùÑ {0}Í∞ú Ï∞∏Ï°∞ÌïòÍ≥† "{3}"ÏùÄ(Îäî) Ìï≠Î™©ÏùÑ {1}Í∞ú Ï∞∏Ï°∞Ìï©ÎãàÎã§. Ï∞∏Ï°∞ÌïòÎäî Ìï≠Î™© ÏàòÎäî Í∞ôÏïÑÏïº Ìï©ÎãàÎã§.</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: "{0}" Ï°∞Í±¥Ïùò "{1}" ÏúÑÏπòÏóê ÏòàÍ∏∞Ïπò ÏïäÏùÄ Í≥µÎ∞±Ïù¥ ÏûàÏäµÎãàÎã§. Í≥µÎ∞±ÏùÑ Ï†úÍ±∞ÌñàÎäîÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.</target>
@@ -154,6 +164,11 @@
         <target state="translated">SharingPolicy.IsolatedÎ°ú ÎßåÎì† EvaluationContext Í∞úÏ≤¥Îäî MSBuildFileSystemBase ÌååÏùº ÏãúÏä§ÌÖú Ï†ÑÎã¨ÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: ÎåÄÏÉÅ ÎÇ¥Ïùò '{0}' Ìï≠Î™© Ï†ïÏùòÎäî (Ï†ïÍ∑úÌôîÎêú ÎòêÎäî Ï†ïÍ∑úÌôîÎêòÏßÄ ÏïäÏùÄ) Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ '{1}'Î•º ÌÜµÌï¥ ÏûêÏã†ÏùÑ Ï∞∏Ï°∞Ìï©ÎãàÎã§. Ïù¥Î°ú Ïù∏Ìï¥ ÏùòÎèÑÌïòÏßÄ ÏïäÏùÄ ÌôïÏû• Î∞è Í∏∞Ï°¥ Ìï≠Î™©Ïùò ÍµêÏ∞® Ï†ÅÏö©Ïù¥ Î∞úÏÉùÌï† Ïàò ÏûàÏäµÎãàÎã§. Ï∂îÍ∞Ä Ï†ïÎ≥¥: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">pidÍ∞Ä {0}Ïù∏ ÌîÑÎ°úÏÑ∏Ïä§Î•º Ï¢ÖÎ£åÌïòÎäî Ï§ëÏûÖÎãàÎã§.</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Îã§Ïùå ÌîÑÎ°úÏ†ùÌä∏ Ï∫êÏãú ÌîåÎü¨Í∑∏ Ïù∏ÏùÑ Î°úÎìúÌïòÎäî Ï§ë:{0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">ÎÖ∏Îìú {0}ÏùÑ(Î•º) Îã§Ïãú ÏÇ¨Ïö©ÌïòÎäî Ï§ëÏûÖÎãàÎã§(PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: ÌîÑÎ°úÏ†ùÌä∏ Ï∫êÏãúÎäî {0} Î©îÏÑúÎìúÏóêÏÑú Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ ÏòàÏô∏Î•º Î∞úÏÉùÏãúÏº∞ÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: {0} ÌîÑÎ°úÏ†ùÌä∏Ïóê ÎåÄÌïú ÎπåÎìú Í≤∞Í≥ºÎ•º Ï≤òÎ¶¨ÌïòÎäî ÎèôÏïà ÌîÑÎ°úÏ†ùÌä∏ Ï∫êÏãúÍ∞Ä Ïã§Ìå®ÌñàÏäµÎãàÎã§.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}"(Í∏∞Î≥∏ ÎåÄÏÉÅ)Ïóê ÎåÄÌïú ÌîÑÎ°úÏ†ùÌä∏ Ï∫êÏãú Ï†ÅÏ§ëÏûÖÎãàÎã§.</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: ÏöîÏÜå &lt;{0}&gt; ÏïÑÎûòÏóê ÏöîÏÜå &lt;{1}&gt;ÏùÑ(Î•º) Ïù∏ÏãùÌï† Ïàò ÏóÜÏäµÎãàÎã§. ÏÜçÏÑ±Ïù¥ ÎêòÎèÑÎ°ù ÌïòÎ†§Î©¥ &lt;PropertyGroup&gt; ÏöîÏÜå ÎÇ¥Ïóê Î¨∂ÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: ÌîÑÎ°ùÏãú ÎπåÎìú ÏöîÏ≤≠ÏùÑ ÎÇ¥Î≥¥ÎÇ¥Îäî ÌîÑÎ°úÏ†ùÌä∏ Ï∫êÏãú ÌîåÎü¨Í∑∏ Ïù∏ÏùÑ ÏÇ¨Ïö©Ìï† Îïå inproc ÎÖ∏ÎìúÎ•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎèÑÎ°ù ÏÑ§Ï†ïÌïòÎ©¥ ÏÑ±Îä•Ïù¥ Ï†ÄÌïòÎê©ÎãàÎã§.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">ÌååÏùº Ïï°ÏÑ∏Ïä§ Î≥¥Í≥†Îäî ÌòÑÏû¨ x64 Î≤ÑÏ†ÑÏùò MSBuildÎ•º ÏÇ¨Ïö©ÌïòÎäî Í≤ΩÏö∞ÏóêÎßå ÏßÄÏõêÎê©ÎãàÎã§.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK Ìï¥Í≤∞ ÌîÑÎ°úÍ∑∏Îû® Ïò§Î•ò: "{0}"</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">SDK ÌôïÏù∏Ïûê "{0}"Ïù¥(Í∞Ä) nullÏùÑ Î∞òÌôòÌñàÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">{0}{1} ÎèôÏïà Î°úÎìúÎêú Ïñ¥ÏÖàÎ∏îÎ¶¨: {2}(ÏúÑÏπò: {3}%1, MVID: {4}%2, AppDomain: {5}%2).</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,10 +475,10 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
         <target state="translated">MSBuildÏóêÏÑú Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ ÏòàÏô∏ÏûÖÎãàÎã§. https://aka.ms/msbuild/unhandledÏóêÏÑú Í∏∞Ï°¥ Î¨∏Ï†úÏóê Ï∞¨ÏÑ± Ìà¨ÌëúÌïòÍ±∞ÎÇò ÏÉà Î¨∏Ï†úÎ•º Ï†úÏ∂úÌïòÏÑ∏Ïöî.
- {0}</target>
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="UninitializedPropertyRead">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index bcc1dad73ba..09c3028c18c 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: Nie mo≈ºna skopiowaƒá z obiektu tego typu.</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: Nie mo≈ºna rozwinƒÖƒá metadanych w wyra≈ºeniu ‚Äû{0}‚Äù. {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: Zmienna ≈õrodowiskowa MSBUILDDISABLEFEATURESFROMVERSION ma nieprawid≈Çowy format. W≈ÇƒÖczenie wszystkich wersji fali zmian. Wprowadzona warto≈õƒá: {0}. Bie≈ºƒÖce fale zmian: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: Zmienna ≈õrodowiskowa MSBUILDDISABLEFEATURESFROMVERSION jest ustawiona na wersjƒô, kt√≥ra jest poza rotacjƒÖ. Domy≈õlnie ustawiona na Zmie≈Ñ wersjƒô fali: {0}. Wprowadzona warto≈õƒá: {1}. Aktualna wersja funkcji Zmie≈Ñ fale: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: Domy≈õlne narzƒôdzie Resolver zestawu SDK nie mo≈ºe rozpoznaƒá zestawu SDK ‚Äû{0}‚Äù, poniewa≈º katalog ‚Äû{1}‚Äù nie istnieje.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">W≈Ça≈õciwo≈õƒá ‚Äû{0}‚Äù o warto≈õci ‚Äû{1}‚Äù rozwiniƒôto ze ≈õrodowiska.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Nie mo≈ºna rozpoznaƒá zestawu SDK ‚Äû{0}‚Äù. Dok≈Çadnie jeden z poni≈ºszych komunikat√≥w sondujƒÖcych wskazuje, dlaczego nie mogli≈õmy rozpoznaƒá zestawu SDK. Zbadaj i rozwiƒÖ≈º ten komunikat, aby poprawnie okre≈õliƒá zestaw SDK.
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: ‚Äû{2}‚Äù odwo≈Çuje siƒô do nastƒôpujƒÖcej liczby element√≥w: {0}, a ‚Äû{3}‚Äù odwo≈Çuje siƒô do nastƒôpujƒÖcej liczby element√≥w: {1}. Liczba tych element√≥w musi byƒá taka sama.</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Nieoczekiwana spacja na pozycji ‚Äû{1}‚Äù warunku ‚Äû{0}‚Äù. Czy zapomniano o usuniƒôciu spacji?</target>
@@ -154,6 +164,11 @@
         <target state="translated">Obiekty EvaluationContext utworzone za pomocƒÖ elementu SharingPolicy.Isolated nie obs≈ÇugujƒÖ przekazywania za pomocƒÖ systemu plik√≥w MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: Definicja ‚Äû{0}‚Äù elementu w miejscu docelowym odwo≈Çuje siƒô do siebie za po≈õrednictwem metadanych (kwalifikowanych lub niekwalifikowanych) ‚Äû{1}‚Äù. Mo≈ºe to prowadziƒá do niezamierzonego rozszerzenia i krzy≈ºowego  zastosowania wcze≈õniej istniejƒÖcych element√≥w. Wiƒôcej informacji: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Kasowanie procesu z identyfikatorem pid = {0}.</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">≈Åadowanie nastƒôpujƒÖcej wtyczki pamiƒôci podrƒôcznej projektu: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Ponowne u≈ºycie wƒôz≈Ça {0} (identyfikator PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: pamiƒôƒá podrƒôczna projektu zg≈Çosi≈Ça nieobs≈Çugiwany wyjƒÖtek z metody {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: pamiƒôƒá podrƒôczna projektu nie powiod≈Ça siƒô podczas obs≈Çugi wyniku kompilacji dla nastƒôpujƒÖcego projektu: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Trafienie pamiƒôci podrƒôcznej projektu dla ‚Äû{0}‚Äù (domy≈õlne elementy docelowe).</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; jest nierozpoznany. Je≈õli ma to byƒá w≈Ça≈õciwo≈õƒá, umie≈õƒá jƒÖ w elemencie &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: wy≈ÇƒÖczenie wƒôz≈Ça InProc prowadzi do obni≈ºenia wydajno≈õci, gdy u≈ºywane sƒÖ wtyczki pamiƒôci podrƒôcznej projektu, kt√≥re emitujƒÖ ≈ºƒÖdania kompilowania serwera proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Raportowanie dostƒôpu do plik√≥w jest obecnie obs≈Çugiwane tylko przy u≈ºyciu wersji x64 programu MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: niepowodzenia programu do rozpoznawania zestawu SDK: ‚Äû{0}‚Äù</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">Narzƒôdzie Resolver zestawu SDK ‚Äû{0}‚Äù zwr√≥ci≈Ço warto≈õƒá null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Za≈Çadowano zestaw podczas {0}{1}: {2} (lokalizacja: {3}, MVID: {4}, domena aplikacji: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,9 +475,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">To jest nieobs≈Çugiwany wyjƒÖtek w programie MSBuild ‚Äî POPRZYJ ISTNIEJƒÑCY PROBLEM LUB ZAREJESTRUJ NOWY NA https://aka.ms/msbuild/unhandled.
+        <target state="translated">Jest to nieobs≈Çugiwany wyjƒÖtek na platformie MSBuild -- ZAG≈ÅOSUJ NA ISTNIEJƒÑCY PROBLEM LUB ZAREJESTRUJ NOWY W WITRYNIE https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index fcfbad3e5df..c5b5f835431 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: N√£o √© poss√≠vel copiar do objeto desse tipo.</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: N√£o √© poss√≠vel expandir os metadados na express√£o "{0}". {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: A vari√°vel de ambiente MSBUILDDISABLEFEATURESFROMVERSION est√° definida para um formato inv√°lido. Habilitando todas as vers√µes de onda de mudan√ßa. Valor inserido: {0}. Ondas de Mudan√ßa Atuais: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: A vari√°vel de ambiente MSBUILDDISABLEFEATURESFROMVERSION est√° definida para uma vers√£o que est√° fora de rota√ß√£o. Padr√£o para alterar a vers√£o do Wave: {0}. Valor inserido: {1}. Ondas de Mudan√ßa Atuais: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: O resolvedor SDK padr√£o falhou ao resolver SDK "{0}" porque o diret√≥rio "{1}" n√£o existia.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Im√≥vel '{0}' com valor '{1}' expandido do ambiente.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">N√£o foi poss√≠vel resolver SDK "{0}". Exatamente uma das mensagens de investiga√ß√£o abaixo indica por que n√£o foi poss√≠vel resolver o SDK. Investigue e resolva essa mensagem para especificar corretamente o SDK.
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: "{2}" refere-se ao(s) item(ns) {0} e "{3}" refere-se ao(s) item(ns) {1}. Eles devem ter o mesmo n√∫mero de itens.</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: espa√ßo inesperado na posi√ß√£o "{1}" da condi√ß√£o "{0}". Voc√™ esqueceu de remover um espa√ßo?</target>
@@ -154,6 +164,11 @@
         <target state="translated">Os objetos EvaluationContext criados com SharingPolicy.Isolated n√£o s√£o compat√≠veis com o recebimento de um sistema de arquivos MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: A defini√ß√£o do item '{0}' dentro do destino faz refer√™ncia a si mesmo via metadado (qualificado ou n√£o qualificado) '{1}'. Isso pode levar √† expans√£o n√£o intencional e √† aplica√ß√£o cruzada de itens pr√©-existentes. Mais informa√ß√µes: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Encerrando o processo com o PID = {0}.</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Carregando o seguinte plug-in de cache do projeto: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Reutilizando n√≥ {0} (PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: O cache do projeto lan√ßou uma exce√ß√£o sem tratamento do m√©todo {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: O cache do projeto falhou ao manipular um resultado de constru√ß√£o para o seguinte projeto: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Acerto de cache do projeto para "{0}" (destinos padr√£o).</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; n√£o √© reconhecido. Se voc√™ pretende que seja uma propriedade, coloque-a dentro de um elemento &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: desativar o n√≥ inproc leva √† degrada√ß√£o do desempenho ao usar plug-ins de cache de projeto que emitem solicita√ß√µes de constru√ß√£o de proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Atualmente, o relat√≥rio de acessos a arquivos s√≥ tem suporte usando o tipo x64 do MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Falha no Resolvedor do SDK: "{0}"</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">O resolvedor do SDK "{0}" retornou nulo.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Montagem carregada durante {0}{1}: {2} (localiza√ß√£o: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,9 +475,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Esta √© uma exce√ß√£o sem tratamento no MSBuild -- VOTE A FAVOR DE UM PROBLEMA EXISTENTE OU REGISTRE UM NOVO EM https://aka.ms/msbuild/unhandled.
+        <target state="translated">Essa √© uma exce√ß√£o n√£o tratada no MSBuild -- POR FAVOR, ATUALIZE UMA QUEST√ÉO EXISTENTE OU ENCAMINHE UMA NOVA EM https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 3b33882791c..1223960482a 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: –Ω–µ —É–¥–∞–µ—Ç—Å—è —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∏–∑ –æ–±—ä–µ–∫—Ç–∞ —ç—Ç–æ–≥–æ —Ç–∏–ø–∞.</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ "{0}". {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: –¥–ª—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å—Ä–µ–¥—ã MSBUILDDISABLEFEATURESFROMVERSION –∑–∞–¥–∞–Ω –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò–¥–µ—Ç –≤–∫–ª—é—á–µ–Ω–∏–µ –≤—Å–µ—Ö –≤–µ—Ä—Å–∏–π –≤–æ–ª–Ω –∏–∑–º–µ–Ω–µ–Ω–∏–π. –í–≤–µ–¥–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {0}. –¢–µ–∫—É—â–∏–µ –≤–æ–ª–Ω—ã –∏–∑–º–µ–Ω–µ–Ω–∏–π: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: –¥–ª—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å—Ä–µ–¥—ã MSBUILDDISABLEFEATURESFROMVERSION –∑–∞–¥–∞–Ω–∞ –≤–µ—Ä—Å–∏—è, –∫–æ—Ç–æ—Ä–∞—è –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤–µ—Ä—Å–∏—è –≤–æ–ª–Ω—ã –∏–∑–º–µ–Ω–µ–Ω–∏–π {0}. –í–≤–µ–¥–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {1}. –¢–µ–∫—É—â–∏–µ –≤–æ–ª–Ω—ã –∏–∑–º–µ–Ω–µ–Ω–∏–π: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º—É —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç–µ–ª—é –ø–∞–∫–µ—Ç–æ–≤ SDK –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑—Ä–µ—à–∏—Ç—å –ø–∞–∫–µ—Ç SDK "{0}", —Ç–∞–∫ –∫–∞–∫ –∫–∞—Ç–∞–ª–æ–≥ "{1}" –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">–°–≤–æ–π—Å—Ç–≤–æ "{0}" —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º "{1}" —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç–æ –∏–∑ –æ–∫—Ä—É–∂–µ–Ω–∏—è.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑—Ä–µ—à–∏—Ç—å –ø–∞–∫–µ—Ç SDK "{0}". –í –æ–¥–Ω–æ–º –∏–∑ –ø—Ä–∏–≤–µ–¥–µ–Ω–Ω—ã—Ö –Ω–∏–∂–µ —Å–æ–æ–±—â–µ–Ω–∏–π –ø—Ä–æ–≤–µ—Ä–∫–∏ —É–∫–∞–∑–∞–Ω–æ, –ø–æ—á–µ–º—É –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑—Ä–µ—à–∏—Ç—å –ø–∞–∫–µ—Ç SDK. –ò–∑—É—á–∏—Ç–µ –∏ —É—Å—Ç—Ä–∞–Ω–∏—Ç–µ –≤–æ–∑–Ω–∏–∫—à—É—é –ø—Ä–æ–±–ª–µ–º—É, —á—Ç–æ–±—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ —É–∫–∞–∑–∞—Ç—å –ø–∞–∫–µ—Ç SDK.
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: "{2}" —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–µ —á–∏—Å–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {0}, –∞ "{3}" ‚Äî –Ω–∞ {1}. –ß–∏—Å–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º.</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π –ø—Ä–æ–±–µ–ª –≤ –ø–æ–∑–∏—Ü–∏–∏ "{1}" —É—Å–ª–æ–≤–∏—è "{0}". –í—ã –∑–∞–±—ã–ª–∏ —É–¥–∞–ª–∏—Ç—å –ø—Ä–æ–±–µ–ª?</target>
@@ -154,6 +164,11 @@
         <target state="translated">–û–±—ä–µ–∫—Ç—ã EvaluationContext, —Å–æ–∑–¥–∞–Ω–Ω—ã–µ —Å –ø–æ–º–æ—â—å—é SharingPolicy.Isolated, –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –ø–µ—Ä–µ–¥–∞—á—É –≤ —Ñ–∞–π–ª–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ "{0}" –≤ —Ü–µ–ª–µ–≤–æ–º –æ–±—ä–µ–∫—Ç–µ —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ —Å–µ–±—è —á–µ—Ä–µ–∑ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ "{1}" (–∫–≤–∞–ª–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∏–ª–∏ –Ω–µ–∫–≤–∞–ª–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ). –≠—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –Ω–µ–ø—Ä–µ–¥–Ω–∞–º–µ—Ä–µ–Ω–Ω–æ–º—É —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é –∏ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–Ω–æ–º—É –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—é —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–≤–µ–¥–µ–Ω–∏—è: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ —Å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º {0}.</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">–ò–¥–µ—Ç –∑–∞–≥—Ä—É–∑–∫–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø–æ–¥–∫–ª—é—á–∞–µ–º–æ–≥–æ –º–æ–¥—É–ª—è –∫—ç—à–∞ –ø—Ä–æ–µ–∫—Ç–æ–≤: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">–ü–æ–≤—Ç–æ—Ä–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —É–∑–ª–∞ {0} (–ò–î –ø—Ä–æ—Ü–µ—Å—Å–∞: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: –≤ –∫—ç—à–µ –ø—Ä–æ–µ–∫—Ç–æ–≤ –≤–æ–∑–Ω–∏–∫–ª–æ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –∏–∑ –º–µ—Ç–æ–¥–∞ {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: —Å–±–æ–π –∫—ç—à–∞ –ø—Ä–æ–µ–∫—Ç–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å–±–æ—Ä–∫–∏ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">–ü–æ–ø–∞–¥–∞–Ω–∏–µ –≤ –∫—ç—à–µ –ø—Ä–æ–µ–∫—Ç–∞ –¥–ª—è "{0}" (—Ü–µ–ª–µ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é).</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: —ç–ª–µ–º–µ–Ω—Ç &lt;{0}&gt; –ø–æ–¥ —ç–ª–µ–º–µ–Ω—Ç–æ–º &lt;{1}&gt; –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω. –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –∫–∞–∫ —Å–≤–æ–π—Å—Ç–≤–æ, –≤–∫–ª—é—á–∏—Ç–µ –µ–≥–æ –≤ —ç–ª–µ–º–µ–Ω—Ç &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏–ø—Ä–æ—Ü–µ—Å—Å–Ω–æ–≥–æ —É–∑–ª–∞ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –∑–∞–º–µ–¥–ª–µ–Ω–∏—é –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø–ª–∞–≥–∏–Ω–æ–≤ –∫—ç—à–∞ –ø—Ä–æ–µ–∫—Ç–∞, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–∑–¥–∞—é—Ç –∑–∞–ø—Ä–æ—Å—ã –Ω–∞ —Å–±–æ—Ä–∫—É –ø—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä–∞.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">–î–æ—Å—Ç—É–ø –∫ —Ñ–∞–π–ª–∞–º –æ—Ç—á–µ—Ç–æ–≤ —Å–µ–π—á–∞—Å –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ 64-—Ä–∞–∑—Ä—è–¥–Ω–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: —Å–±–æ–π —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç–µ–ª—è SDK: "{0}"</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">–°–æ–ø–æ—Å—Ç–∞–≤–∏—Ç–µ–ª—å –ø–∞–∫–µ—Ç–æ–≤ SDK "{0}" –≤–µ—Ä–Ω—É–ª –∑–Ω–∞—á–µ–Ω–∏–µ null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">–°–±–æ—Ä–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –≤–æ –≤—Ä–µ–º—è {0}{1}: {2} (—Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ: {3}, MVID: {4}, –¥–æ–º–µ–Ω –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,9 +475,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">–≠—Ç–æ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –≤ MSBuild ‚Äî –ü–†–û–ì–û–õ–û–°–£–ô–¢–ï –ó–ê –°–£–©–ï–°–¢–í–£–Æ–©–£–Æ –ü–†–û–ë–õ–ï–ú–£ –ò–õ–ò –°–û–ó–î–ê–ô–¢–ï –ù–û–í–£–Æ –Ω–∞ —Å–∞–π—Ç–µ https://aka.ms/msbuild/unhandled.
+        <target state="translated">–≠—Ç–æ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –≤ MSBuild. –ü–†–û–ì–û–õ–û–°–£–ô–¢–ï –ó–ê –°–£–©–ï–°–¢–í–£–Æ–©–£–Æ –ü–†–û–ë–õ–ï–ú–£ –ò–õ–ò –°–û–û–ë–©–ò–¢–ï –û –ù–û–í–£–ô –ù–ê https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 8822dee74ae..7e5d02e1334 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: Bu t√ºrdeki nesneden kopyalanamadƒ±.</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: "{0}" ifadesindeki meta veriler geni≈ületilemiyor. {1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: MSBUILDDISABLEFEATURESFROMVERSION ortam deƒüi≈ükeni ge√ßersiz bir bi√ßime ayarlandƒ±. T√ºm deƒüi≈üiklik dalgasƒ± s√ºr√ºmleri etkinle≈ütiriliyor. Girilen deƒüer: {0}. Ge√ßerli Deƒüi≈üiklik Dalgalarƒ±: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: MSBUILDDISABLEFEATURESFROMVERSION ortam deƒüi≈ükeni, d√ºzenli deƒüi≈üiklik dƒ±≈üƒ± bir s√ºr√ºme ayarlandƒ±. Varsayƒ±lan Deƒüi≈üiklik Dalgasƒ± s√ºr√ºm√ºne d√∂n√ºl√ºyor: {0}. Girilen deƒüer: {1}. Ge√ßerli Deƒüi≈üiklik Dalgalarƒ±: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: "{1}" dizini olmadƒ±ƒüƒ±ndan, varsayƒ±lan SDK √ß√∂z√ºmleyicisi "{0}" SDK‚Äôsƒ±nƒ± √ß√∂z√ºmleyemedi.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">'{1}' deƒüerine sahip '{0}' √∂zelliƒüi ortamdan geni≈ületildi.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">SDK "{0}" √ß√∂z√ºmlenemedi. A≈üaƒüƒ±daki yoklama iletilerinden tam olarak biri, SDK'yƒ± neden √ß√∂z√ºmleyemediƒüimizi g√∂sterir. SDK'yƒ± doƒüru ≈üekilde belirtmek i√ßin bu iletiyi inceleyin ve √ß√∂z√ºmleyin.
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: "{2}", {0} √∂ƒüeye; "{3}", {1} √∂ƒüeye ba≈üvuruyor. Aynƒ± sayƒ±da √∂ƒüeye sahip olmalarƒ± gerekir.</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: "{0}" ko≈üulunun "{1}" konumunda beklenmeyen bo≈üluk var. Bo≈üluƒüu kaldƒ±rmayƒ± unutmu≈ü olabilirsiniz.</target>
@@ -154,6 +164,11 @@
         <target state="translated">SharingPolicy.Isolated ile olu≈üturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin ge√ßirilmesini desteklemez.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: (Nitelikli veya niteliksiz) meta veri dosyasƒ± '{1}' aracƒ±lƒ±ƒüƒ±yla hedef i√ßindeki '{0}' √∂ƒüesinin tanƒ±mƒ± kendi kendisine ba≈üvuruyor. Bu, √∂nceden var olan √∂ƒüelerin istenmeyen ≈üekilde geni≈ülemesine ve √ßapraz olarak uygulanmasƒ±na neden olabilir. Daha fazla bilgi: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">PID = {0} i≈ülemi sonlandƒ±rƒ±lƒ±yor.</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">≈ûu proje √∂nbelleƒüi eklentisi y√ºkleniyor:{0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">D√ºƒü√ºm {0} yeniden kullanƒ±lƒ±yor (PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: Proje √∂nbelleƒüi {0} y√∂nteminden yakalanamayan √∂zel durum olu≈üturdu.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Proje √∂nbelleƒüi ≈üu proje i√ßin bir derleme sonucu i≈ülenirken ba≈üarƒ±sƒ±z oldu: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}" (varsayƒ±lan hedefler) i√ßin proje √∂nbelleƒüi isabeti.</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: &lt;{1}&gt; altƒ±ndaki &lt;{0}&gt; √∂ƒüesi tanƒ±nmƒ±yor. Bunun bir √∂zellik olmasƒ±nƒ± ama√ßladƒ±ysanƒ±z, bir &lt;PropertyGroup&gt; √∂ƒüesi i√ßine ekleyin.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: InProc d√ºƒü√ºm√ºn√ºn devre dƒ±≈üƒ± bƒ±rakƒ±lmasƒ±, ara sunucu olu≈üturma istekleri g√∂nderen proje √∂nbelleƒüi eklentileri kullanƒ±lƒ±rken performans d√º≈ü√º≈ü√ºne yol a√ßar.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Raporlama dosyasƒ± eri≈üimleri ≈üu anda yalnƒ±zca MSBuild x64 varyantƒ± kullanƒ±ldƒ±ƒüƒ±nda destekleniyor.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK √á√∂z√ºmleyici Hatasƒ±: "{0}"</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">SDK √ß√∂z√ºmleyici "{0}" null d√∂nd√ºrd√º.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Derleme {0}{1} sƒ±rasƒ±nda y√ºklendi: {2} (konum: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,9 +475,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Bu, MSBuild'de i≈ülenmeyen bir √∂zel durumdur -- L√úTFEN MEVCUT BIR SORUNA DESTEK OYU VERIN VEYA MEVCUT BIR SORUNU Bƒ∞LDƒ∞Rƒ∞N: https://aka.ms/msbuild/unhandled.
+        <target state="translated">Bu, MSBuild'de i≈ülenmeyen bir istisnadƒ±r -- L√úTFEN MEVCUT Bƒ∞R SORUNU OYLAYIN VEYA https://aka.ms/msbuild/unhandled ADRESƒ∞NDE YENƒ∞ Bƒ∞R SORUN OLU≈ûTURUN
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 198d36450b9..be8d710612d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: Êó†Ê≥ï‰ªéËØ•Á±ªÂûãÁöÑÂØπË±°Â§çÂà∂„ÄÇ</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: Êó†Ê≥ïÂú®Ë°®ËææÂºè‚Äú{0}‚Äù‰∏≠Â±ïÂºÄÂÖÉÊï∞ÊçÆ„ÄÇ{1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: ËÆæÁΩÆÁöÑÁéØÂ¢ÉÂèòÈáè MSBUILDDISABLEFEATURESFROMVERSION Ê†ºÂºèÊó†Êïà„ÄÇÊ≠£Âú®ÂêØÁî®ÊâÄÊúâÊõ¥ÊîπÊâπÊ¨°ÁâàÊú¨„ÄÇËæìÂÖ•ÁöÑÂÄº: {0}„ÄÇÂΩìÂâçÊõ¥ÊîπÊâπÊ¨°:{1}„ÄÇ</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: ËÆæÁΩÆÁöÑÁéØÂ¢ÉÂèòÈáè MSBUILDDISABLEFEATURESFROMVERSION ÁâàÊú¨‰∏çÂú®ËΩÆÊç¢ËåÉÂõ¥ÂÜÖ„ÄÇÈªòËÆ§‰∏∫‚ÄúÊõ¥ÊîπÊâπÊ¨°‚ÄùÁâàÊú¨: {0}„ÄÇËæìÂÖ•ÁöÑÂÄº: {1}„ÄÇÂΩìÂâçÊõ¥ÊîπÊâπÊ¨°: {2}„ÄÇ</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: ÈªòËÆ§ SDK Ëß£ÊûêÁ®ãÂ∫èËß£Êûê SDK‚Äú{0}‚ÄùÂ§±Ë¥•ÔºåÂõ†‰∏∫ÁõÆÂΩï‚Äú{1}‚Äù‰∏çÂ≠òÂú®„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">ÂÄº‰∏∫‚Äú{1}‚ÄùÁöÑÂ±ûÊÄß‚Äú{0}‚Äù‰ªéÁéØÂ¢É‰∏≠Â±ïÂºÄ„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Êó†Ê≥ïËß£Êûê SDK‚Äú{0}‚Äù„ÄÇ‰∏ãÈù¢ÁöÑÊé¢ÊµãÊ∂àÊÅØ‰∏≠Ê≠£Â•ΩÊúâ‰∏ÄÊù°ÊåáÁ§∫Êàë‰ª¨Êó†Ê≥ïËß£Êûê SDK ÁöÑÂéüÂõ†„ÄÇË∞ÉÊü•Âπ∂Ëß£ÂÜ≥ËØ•Ê∂àÊÅØ‰ª•Ê≠£Á°ÆÊåáÂÆö SDK„ÄÇ
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: ‚Äú{2}‚ÄùÂºïÁî® {0} ‰∏™È°πÔºåËÄå‚Äú{3}‚ÄùÂºïÁî® {1} ‰∏™È°π„ÄÇÂÆÉ‰ª¨ÂøÖÈ°ªÂÖ∑ÊúâÁõ∏ÂêåÁöÑÈ°πÊï∞„ÄÇ</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Âú®Êù°‰ª∂‚Äú{0}‚ÄùÁöÑ‰ΩçÁΩÆ‚Äú{1}‚ÄùÂ§ÑÂá∫Áé∞ÊÑèÂ§ñÁ©∫Ê†º„ÄÇÊòØÂê¶ÂøòËÆ∞‰∫ÜÂà†Èô§Á©∫Ê†º?</target>
@@ -154,6 +164,11 @@
         <target state="translated">‰ΩøÁî® SharingPolicy.Isolated ÂàõÂª∫ÁöÑ EvaluationContext ÂØπË±°‰∏çÊîØÊåÅÈÄöËøá MSBuildFileSystemBase Êñá‰ª∂Á≥ªÁªü‰º†ÈÄí„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: ÁõÆÊ†áÂÜÖÁöÑÈ°π‚Äú{0}‚ÄùÂÆö‰πâÈÄöËøá(ÈôêÂÆöÊàñÈùûÈôêÂÆö)ÂÖÉÊï∞ÊçÆ‚Äú{1}‚ÄùÂºïÁî®Ëá™Ë∫´„ÄÇËøôÂèØËÉΩÂØºËá¥ÊÑèÂ§ñÊâ©Â±ïÂíå‰∫§ÂèâÂ∫îÁî®È¢ÑÂÖàÂ≠òÂú®ÁöÑÈ°π„ÄÇËØ¶ÁªÜ‰ø°ÊÅØ: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Ê≠£Âú®ÁªàÊ≠¢ËøõÁ®ãÔºåpid = {0}„ÄÇ</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Ê≠£Âú®Âä†ËΩΩ‰ª•‰∏ãÈ°πÁõÆÁºìÂ≠òÊèí‰ª∂: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Ê≠£Âú®ÈáçÂ§ç‰ΩøÁî®ËäÇÁÇπ {0} (PID: {1})„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: È°πÁõÆÁºìÂ≠ò‰ªé {0} ÊñπÊ≥ïÂºïÂèë‰∫ÜÊú™ÁªèÂ§ÑÁêÜÁöÑÂºÇÂ∏∏„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Â§ÑÁêÜ‰ª•‰∏ãÈ°πÁõÆÁöÑÁîüÊàêÁªìÊûúÊó∂ÔºåÈ°πÁõÆÁºìÂ≠òÂ§±Ë¥•: {0}„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">È°πÁõÆÁºìÂ≠òÂëΩ‰∏≠ "{0}" (ÈªòËÆ§ÁõÆÊ†á)„ÄÇ</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: Êó†Ê≥ïËØÜÂà´ÂÖÉÁ¥† &lt;{0}&gt; ‰∏ãÊñπ &lt;{1}&gt; ÂÖÉÁ¥†„ÄÇÂ¶ÇÊûúÊâìÁÆóÂ∞ÜÂÖ∂‰Ωú‰∏∫Â±ûÊÄßÔºåËØ∑Â∞ÜÂÖ∂Â∞ÅÈó≠Âú® &lt;PropertyGroup&gt; ÂÖÉÁ¥†‰∏≠„ÄÇ</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: ‰ΩøÁî®ÂèëÂá∫‰ª£ÁêÜÊûÑÂª∫ËØ∑Ê±ÇÁöÑÈ°πÁõÆÁºìÂ≠òÊèí‰ª∂Êó∂ÔºåÁ¶ÅÁî® inproc ËäÇÁÇπ‰ºöÂØºËá¥ÊÄßËÉΩ‰∏ãÈôç„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">ÂΩìÂâç‰ªÖÊîØÊåÅ‰ΩøÁî® x64 È£éÊ†ºÁöÑ MSBuild Êù•Êä•ÂëäÊñá‰ª∂ËÆøÈóÆÊÉÖÂÜµ„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK Ëß£ÊûêÁ®ãÂ∫èÂ§±Ë¥•: "{0}"</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">SDK Ëß£ÊûêÁ®ãÂ∫è‚Äú{0}‚ÄùËøîÂõû null„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Á®ãÂ∫èÈõÜÂä†ËΩΩÊúüÈó¥ {0}{1}: {2} (‰ΩçÁΩÆ: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,9 +475,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">ËøôÊòØ MSBuild ‰∏≠Êú™ÁªèÂ§ÑÁêÜÁöÑÂºÇÂ∏∏ -- ËØ∑ÂØπÁé∞ÊúâÈóÆÈ¢òÊäïËµûÊàêÁ•®ÊàñÂú® https://aka.ms/msbuild/unhandled ‰∏äÊèê‰∫§Êñ∞ÈóÆÈ¢ò„ÄÇ
+        <target state="translated">ËøôÊòØ MSBuild ‰∏≠Êú™ÁªèÂ§ÑÁêÜÁöÑÂºÇÂ∏∏ -- ËØ∑ÂØπÁé∞ÊúâÈóÆÈ¢òÊäïËµûÊàêÁ•®ÊàñÂú® https://aka.ms/msbuild/unhandled ‰∏äÊèê‰∫§Êñ∞ÈóÆÈ¢ò
     {0}</target>
         <note />
       </trans-unit>
@@ -2381,7 +2406,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="InvalidSdkFormat">
         <source>MSB4229: The value "{0}" is not valid for an Sdk specification. The attribute should be a semicolon-delimited list of Sdk-name/minimum-version pairs, separated by a forward slash.</source>
-        <target state="translated">MSB4229: ÂÄº‚Äú{0}‚ÄùÂØπ Sdk ËßÑËåÉÊó†Êïà„ÄÇÊ≠§Â±ûÊÄßÂ∫îËØ•ÊòØ‰ª•ÂàÜÂè∑ÂàÜÈöîÁöÑSdk-name/minimum-version ÂØπÔºàÁî®Ê≠£ÊñúÊù†ÂàÜÈöîÔºâÁöÑÂàóË°®„ÄÇ</target>
+        <target state="translated">MSB4229: ÂÄº‚Äú{0}‚ÄùÂØπ Sdk ËßÑËåÉÊó†Êïà„ÄÇÊ≠§Â±ûÊÄßÂ∫îËØ•ÊòØ‰ª•ÂàÜÂè∑ÂàÜÈöîÁöÑSdk-name/minimum-version ÂØπ (Áî®Ê≠£ÊñúÊù†ÂàÜÈöî) ÁöÑÂàóË°®„ÄÇ</target>
         <note>{StrBegin="MSB4229: "}</note>
       </trans-unit>
       <trans-unit id="TaskInstantiationFailureNotSupported">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 201836b008e..b2bdd01d43e 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -55,6 +55,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
+      <trans-unit id="CannotCopyFromElementOfThatType">
+        <source>MSB4277: Cannot copy from object of that type.</source>
+        <target state="translated">MSB4277: ÁÑ°Ê≥ïÂæûË©≤È°ûÂûãÁöÑÁâ©‰ª∂Ë§áË£Ω„ÄÇ</target>
+        <note>{StrBegin="MSB4277: "}</note>
+      </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
         <source>MSB4248: Cannot expand metadata in expression "{0}". {1}</source>
         <target state="translated">MSB4248: ÁÑ°Ê≥ïÂú®ÈÅãÁÆóÂºè "{0}" ‰∏≠Â±ïÈñã‰∏≠ÁπºË≥áÊñô„ÄÇ{1}</target>
@@ -64,12 +69,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: Áí∞Â¢ÉËÆäÊï∏ MSBUILDDISABLEFEATURESFROMVERSION Ë®≠ÁÇ∫ÁÑ°ÊïàÁöÑÊ†ºÂºè„ÄÇÊ≠£Âú®ÂïüÁî®ÊâÄÊúâËÆäÊõ¥Ê≥¢ÊÆµÁâàÊú¨„ÄÇËº∏ÂÖ•ÁöÑÂÄº: {0}„ÄÇÁõÆÂâçÁöÑËÆäÊõ¥Ê≥¢ÊÆµ: {1}„ÄÇ</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: Áí∞Â¢ÉËÆäÊï∏ MSBUILDDISABLEFEATURESFROMVERSION Ë®≠ÁÇ∫ÁÑ°Ê≥ïËº™ÊõøÁöÑÁâàÊú¨„ÄÇÈ†êË®≠ÁÇ∫ËÆäÊõ¥Ê≥¢ÊÆµÁâàÊú¨: {0}„ÄÇËº∏ÂÖ•ÁöÑÂÄº: {1}„ÄÇÁõÆÂâçÁöÑËÆäÊõ¥Ê≥¢ÊÆµ: {2}„ÄÇ</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +99,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: È†êË®≠ÁöÑ SDK Ëß£ÊûêÁ®ãÂºèÁÑ°Ê≥ïËß£Êûê SDK "{0}"ÔºåÂõ†ÁÇ∫ÁõÆÈåÑ "{1}" ‰∏çÂ≠òÂú®„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +114,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">ÂæûÁí∞Â¢ÉÂ±ïÈñãÂÄºÁÇ∫ '{1}' ÁöÑÂ±¨ÊÄß '{0}'„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,10 +135,15 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">ÁÑ°Ê≥ïËß£Êûê SDK "{0}"„ÄÇ‰∏ãÈù¢Êúâ‰∏ÄÂÄãÁ¢∫ÂàáÊé¢Êü•Ë®äÊÅØÊúÉÊåáÂá∫ÁÑ°Ê≥ïËß£Êûê SDK ÁöÑÂéüÂõ†„ÄÇË´ãË™øÊü•‰∏¶Ëß£ÊûêË©≤Ë®äÊÅØ‰ª•Ê≠£Á¢∫ÊåáÂÆö SDK„ÄÇ
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.TwoVectorsMustHaveSameLength">
+        <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
+        <target state="translated">MSB3094: "{2}" ÂèÉËÄÉ {0} ÂÄãÈ†ÖÁõÆÔºå"{3}" ÂâáÂèÉËÄÉ {1} ÂÄãÈ†ÖÁõÆ„ÄÇÂÖ©ËÄÖÂèÉËÄÉÁöÑÈ†ÖÁõÆÊï∏ÁõÆÂøÖÈ†àÁõ∏Âêå„ÄÇ</target>
+        <note>{StrBegin="MSB3094: "}</note>
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Ê¢ù‰ª∂ "{0}" ÁöÑ‰ΩçÁΩÆ "{1}" Âá∫ÁèæÈùûÈ†êÊúüÁöÑÁ©∫Ê†º„ÄÇÂøòË®òÁßªÈô§Á©∫Ê†º‰∫ÜÂóé?</target>
@@ -154,6 +164,11 @@
         <target state="translated">‰ΩøÁî® SharingPolicy.Isolated Âª∫Á´ãÁöÑ EvaluationContext Áâ©‰ª∂‰∏çÊîØÊè¥‰ª• MSBuildFileSystemBase Ê™îÊ°àÁ≥ªÁµ±ÂÇ≥ÈÅû„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="translated">MSB4120: ÁõÆÊ®ôÂÖßÁöÑÈ†ÖÁõÆ '{0}' ÂÆöÁæ©ÈÄèÈÅé (ÈôêÂÆöÊàñ‰∏çÈôêÂÆö) ‰∏≠ÁπºË≥áÊñô '{1}' ÂèÉËÄÉÊú¨Ë∫´„ÄÇÈÄôÂèØËÉΩÊúÉÂ∞éËá¥ÊÑèÂ§ñÁöÑÊì¥ÂÖÖÂíå‰∫§ÂèâÂ•óÁî®Êó¢ÊúâÁöÑÈ†ÖÁõÆ„ÄÇË©≥Á¥∞Ë≥áË®ä: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Ê≠£Âú®ÁµÇÊ≠¢ pid = {0} ÁöÑËôïÁêÜÂ∫è„ÄÇ</target>
@@ -161,7 +176,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">ËºâÂÖ•‰∏ãÂàóÂ∞àÊ°àÂø´ÂèñÂ§ñÊéõÁ®ãÂºè: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -193,7 +208,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">ÈáçË§á‰ΩøÁî®ÁØÄÈªû {0} (PID: {1})„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -226,7 +241,7 @@
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="translated">MatchOnMetadata ÁÑ°Ê≥ïÂú® &lt;ÁõÆÊ®ô&gt; ‰πãÂ§ñ‰ΩøÁî®„ÄÇ</target>
+        <target state="translated">MatchOnMetadata ÁÑ°Ê≥ïÂú® &lt;Target&gt; ‰πãÂ§ñ‰ΩøÁî®„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -249,6 +264,11 @@
         <target state="translated">MSB4273: Â∞àÊ°àÂø´ÂèñÂæû {0} ÊñπÊ≥ïÊì≤ÂõûÊú™ËôïÁêÜÁöÑ‰æãÂ§ñÁãÄÊ≥Å„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: ËôïÁêÜ‰∏ãÂàóÂ∞àÊ°àÁöÑÁµÑÂª∫ÁµêÊûúÊôÇÔºåÂ∞àÊ°àÂø´ÂèñÂ§±Êïó: {0}„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}" ÁöÑÂ∞àÊ°àÂø´ÂèñÂëΩ‰∏≠ (È†êË®≠ÁõÆÊ®ô)„ÄÇ</target>
@@ -347,7 +367,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: ÁÑ°Ê≥ïËæ®Ë≠òÂÖÉÁ¥† &lt;{1}&gt; ‰∏ãÁöÑÂÖÉÁ¥† &lt;{0}&gt;„ÄÇÂ¶ÇÊûúÊÇ®ÊÉ≥Ë¶ÅÂ∞áÊ≠§È†ÖÁõÆË®≠ÁÇ∫Â±¨ÊÄßÔºåË´ãÂ∞áÂÆÉÊã¨Âú® &lt;PropertyGroup&gt; ÂÖÉÁ¥†ÂÖß„ÄÇ</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -355,6 +375,11 @@
         <target state="translated">MSB4274: ÂÅúÁî® inproc ÁØÄÈªûÊúÉÂú®‰ΩøÁî®ÂèØÁôºÂá∫ proxy ÁµÑÂª∫Ë¶ÅÊ±ÇÁöÑÂ∞àÊ°àÂø´ÂèñÂ§ñÊéõÁ®ãÂºèÊôÇÔºåÂ∞éËá¥ÊïàËÉΩÈôç‰Ωé„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">ÁõÆÂâçÂè™ÊîØÊè¥‰ΩøÁî® MSBuild ÁöÑ x64 ËÆäÈ´î‰æÜÂ†±ÂëäÊ™îÊ°àÂ≠òÂèñ„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK Ëß£ÊûêÁ®ãÂºèÂ§±Êïó: "{0}"</target>
@@ -367,7 +392,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">SDK Ëß£ÊûêÁ®ãÂºè "{0}" ÂÇ≥Âõû Null„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -423,7 +448,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">ÁµÑ‰ª∂Âú® {0}{1} ÊúüÈñìËºâÂÖ•: {2} (‰ΩçÁΩÆ: {3}ÔºåMVID: {4}ÔºåAppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -450,9 +475,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">ÈÄôÊòØ MSBuild ‰∏≠Êú™ËôïÁêÜÁöÑ‰æãÂ§ñÁãÄÊ≥Å -- Ë´ãÈáùÂ∞çÁèæÊúâÁöÑÂïèÈ°åÈôÑË≠∞ÔºåÊàñÂú® https://aka.ms/msbuild/unhandled Êèê‰∫§Êñ∞ÁöÑÂïèÈ°å„ÄÇ
+        <target state="translated">ÈÄôÊòØ MSBuild ‰∏≠Êú™ËôïÁêÜÁöÑ‰æãÂ§ñÁãÄÊ≥Å -- Ë´ãÈáùÂ∞çÁèæÊúâÁöÑÂïèÈ°åÈôÑË≠∞ÔºåÊàñÂú® https://aka.ms/msbuild/unhandled Êèê‰∫§Êñ∞ÁöÑÂïèÈ°å
     {0}</target>
         <note />
       </trans-unit>
@@ -1886,7 +1911,7 @@
       </trans-unit>
       <trans-unit id="WhenNotAllowedAfterOtherwise">
         <source>MSB4084: A &lt;When&gt; element may not follow an &lt;Otherwise&gt; element in a &lt;Choose&gt;.</source>
-        <target state="translated">MSB4084: Âú® &lt;Choose&gt; ‰∏≠Ôºå&lt;When&gt; È†ÖÁõÆ‰∏çËÉΩÊé•Âú® &lt;Otherwise&gt; È†ÖÁõÆÂæåÈù¢„ÄÇ</target>
+        <target state="translated">MSB4084: Âú® &lt;Choose&gt; ‰∏≠Ôºå&lt;When&gt; ÂÖÉÁ¥†‰∏çËÉΩÊé•Âú® &lt;Otherwise&gt; ÂÖÉÁ¥†ÂæåÈù¢„ÄÇ</target>
         <note>{StrBegin="MSB4084: "}</note>
       </trans-unit>
       <trans-unit id="MustCallInitializeBeforeApplyParameter">
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index a0dd2580e23..0c26f6e1a8b 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -191,8 +191,10 @@ private static string[] GetFileList(
             FileMatcher.SearchAction action = FileMatcher.SearchAction.None;
             string excludeFileSpec = string.Empty;
 
-            if (!FilespecHasWildcards(filespecEscaped) ||
-                FilespecMatchesLazyWildcard(filespecEscaped, forceEvaluateWildCards))
+            var noWildcards = !FilespecHasWildcards(filespecEscaped) || FilespecMatchesLazyWildcard(filespecEscaped, forceEvaluateWildCards);
+
+            // It is possible to return original string if no wildcard matches and no entries in Exclude set. 
+            if (noWildcards && excludeSpecsEscaped?.Any() != true)
             {
                 // Just return the original string.
                 fileList = new string[] { returnEscaped ? filespecEscaped : EscapingUtilities.UnescapeAll(filespecEscaped) };
diff --git a/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs b/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs
index b9c06e9905e..0be6d375ffb 100644
--- a/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs
+++ b/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs
@@ -10,10 +10,10 @@ namespace Microsoft.Build.Internal;
 
 internal static class ReaderWriterLockSlimExtensions
 {
-    public static UpgradeableReadLockDisposer EnterDisposableUpgradeableReadLock(this ReaderWriterLockSlim rwLock)
+    public static DisposableReadLock EnterDisposableReadLock(this ReaderWriterLockSlim rwLock)
     {
-        rwLock.EnterUpgradeableReadLock();
-        return new UpgradeableReadLockDisposer(rwLock);
+        rwLock.EnterReadLock();
+        return new DisposableReadLock(rwLock);
     }
 
     public static DisposableWriteLock EnterDisposableWriteLock(this ReaderWriterLockSlim rwLock)
@@ -22,44 +22,21 @@ public static DisposableWriteLock EnterDisposableWriteLock(this ReaderWriterLock
         return new DisposableWriteLock(rwLock);
     }
 
-    // Officially, Dispose() being called more than once is allowable, but in this case if that were to happen
-    // that means something is very, very wrong. Since it's an internal type, better to be strict.
-
-    internal struct UpgradeableReadLockDisposer : IDisposable
+    internal readonly struct DisposableReadLock : IDisposable
     {
-        private ReaderWriterLockSlim? _rwLock;
-
-        public UpgradeableReadLockDisposer(ReaderWriterLockSlim rwLock) => _rwLock = rwLock;
-
-        public void Dispose()
-        {
-            var rwLockToDispose = Interlocked.Exchange(ref _rwLock, null);
+        private readonly ReaderWriterLockSlim _rwLock;
 
-            if (rwLockToDispose is null)
-            {
-                throw new ObjectDisposedException($"Somehow a {nameof(UpgradeableReadLockDisposer)} is being disposed twice.");
-            }
+        public DisposableReadLock(ReaderWriterLockSlim rwLock) => _rwLock = rwLock;
 
-            rwLockToDispose.ExitUpgradeableReadLock();
-        }
+        public void Dispose() => _rwLock.ExitReadLock();
     }
 
-    internal struct DisposableWriteLock : IDisposable
+    internal readonly struct DisposableWriteLock : IDisposable
     {
-        private ReaderWriterLockSlim? _rwLock;
+        private readonly ReaderWriterLockSlim _rwLock;
 
         public DisposableWriteLock(ReaderWriterLockSlim rwLock) => _rwLock = rwLock;
 
-        public void Dispose()
-        {
-            var rwLockToDispose = Interlocked.Exchange(ref _rwLock, null);
-
-            if (rwLockToDispose is null)
-            {
-                throw new ObjectDisposedException($"Somehow a {nameof(DisposableWriteLock)} is being disposed twice.");
-            }
-
-            rwLockToDispose.ExitWriteLock();
-        }
+        public void Dispose() => _rwLock.ExitWriteLock();
     }
 }
diff --git a/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs b/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
index acd3388da81..8fc5e75a7b5 100644
--- a/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
@@ -63,7 +63,7 @@ public XmlElementChildIterator GetEnumerator()
                 return this;
             }
 
-            public XmlElementWithLocation Current
+            public readonly XmlElementWithLocation Current
             {
                 get
                 {
@@ -73,7 +73,7 @@ public XmlElementWithLocation Current
                 }
             }
 
-            private XmlElementWithLocation GetNextNode(XmlNode child)
+            private readonly XmlElementWithLocation GetNextNode(XmlNode child)
             {
                 while (child != null)
                 {
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index 25667c21f6c..c5ef688824e 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -16,12 +17,17 @@ namespace Microsoft.Build.Internal
     /// <summary>
     /// Exception indicating that we tried to build a type of project MSBuild did not recognize.
     /// </summary>
-    internal sealed class UnbuildableProjectTypeException : Exception
+    internal sealed class UnbuildableProjectTypeException : BuildExceptionBase
     {
         internal UnbuildableProjectTypeException(string file)
             : base(file)
         {
         }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal UnbuildableProjectTypeException(string message, Exception inner)
+            : base(message, inner)
+        { }
     }
 
     /// <summary>
diff --git a/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs b/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
index 5a7f8163273..64fd843cc3b 100644
--- a/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
+++ b/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
@@ -1860,9 +1860,9 @@ public void ConvertEverettProjectWithSpecialCharaceters()
                                     HintPath = `D:\WINDOWS\Microsoft.NET\Framework\v1.1.4322\System.XML.dll`
                                 />
                                 <Reference
-                                    Name = `Microsoft.My'Crazy;Assemb%ly`
-                                    AssemblyName = `Microsoft.My'Crazy;Assemb%ly`
-                                    HintPath = `D:\myapps\Microsoft.My'Crazy;Assemb%ly.dll`
+                                    Name = `Microsoft.My'Different;Assemb%ly`
+                                    AssemblyName = `Microsoft.My'Different;Assemb%ly`
+                                    HintPath = `D:\myapps\Microsoft.My'Different;Assemb%ly.dll`
                                 />
                             </References>
                         </Build>
@@ -1954,9 +1954,9 @@ public void ConvertEverettProjectWithSpecialCharaceters()
                         <ErrorReport>prompt</ErrorReport>
                     </PropertyGroup>
                     <ItemGroup>
-                        <Reference Include=`Microsoft.My%27Crazy%3bAssemb%25ly`>
-                            <Name>Microsoft.My%27Crazy%3bAssemb%25ly</Name>
-                            <HintPath>D:\myapps\Microsoft.My%27Crazy%3bAssemb%25ly.dll</HintPath>
+                        <Reference Include=`Microsoft.My%27Different%3bAssemb%25ly`>
+                            <Name>Microsoft.My%27Different%3bAssemb%25ly</Name>
+                            <HintPath>D:\myapps\Microsoft.My%27Different%3bAssemb%25ly.dll</HintPath>
                         </Reference>
                         <Reference Include=`System`>
                             <Name>System</Name>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
index a29a9aaf8a6..7367de52082 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
@@ -332,7 +332,7 @@ public void AddNewImportToBecomeSelfReferential()
                 InvokeAddNewImportMethod(p, projectPath, "true");
                 Assertion.AssertEquals(0, p.Imports.Count);
                 object o = p.EvaluatedItems;  // force evaluation of imported projects.
-                Assertion.AssertEquals(0, p.Imports.Count); // This is bonkers, should be 1 because the XML DOES contain the import node.
+                Assertion.AssertEquals(0, p.Imports.Count); // Should be 1 because the XML DOES contain the import node.
             }
             finally
             {
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
index 6a7ee297fd3..78659e6084c 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
@@ -150,7 +150,7 @@ internal static class TestData
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ContentSimpleInvalidEncoding = @"<?xml version='1.0' encoding='crazy'?>
+        internal const string ContentSimpleInvalidEncoding = @"<?xml version='1.0' encoding='different'?>
                     <Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='TestTarget'>
                             <Message Text='Executed TestTarget'/>
diff --git a/src/Deprecated/Engine.UnitTests/EngineProxy_Tests.cs b/src/Deprecated/Engine.UnitTests/EngineProxy_Tests.cs
index 19716b7d824..972fb0ebc53 100644
--- a/src/Deprecated/Engine.UnitTests/EngineProxy_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/EngineProxy_Tests.cs
@@ -213,8 +213,8 @@ public void CustomBuildErrorEventIsPreserved()
             engine.RegisterLogger(myLogger);
             // Create a custom build event args that derives from MSBuild's BuildErrorEventArgs.
             // Set a custom field on this event (FXCopRule).
-            MyCustomBuildErrorEventArgs fxcopError = new MyCustomBuildErrorEventArgs("Your code is lame.");
-            fxcopError.FXCopRule = "CodeLamenessViolation";
+            MyCustomBuildErrorEventArgs fxcopError = new MyCustomBuildErrorEventArgs("Your code is bad.");
+            fxcopError.FXCopRule = "CodeBadnessViolation";
 
             // Log the custom event args.  (Pretend that the task actually did this.)
             engineProxy.LogErrorEvent(fxcopError);
@@ -225,8 +225,8 @@ public void CustomBuildErrorEventIsPreserved()
 
             // Make sure the special fields in the custom event match what we originally logged.
             fxcopError = myLogger.lastError as MyCustomBuildErrorEventArgs;
-            Assertion.AssertEquals("Your code is lame.", fxcopError.Message);
-            Assertion.AssertEquals("CodeLamenessViolation", fxcopError.FXCopRule);
+            Assertion.AssertEquals("Your code is bad.", fxcopError.Message);
+            Assertion.AssertEquals("CodeBadnessViolation", fxcopError.FXCopRule);
         }
 
         /// <summary>
@@ -400,7 +400,7 @@ public void ContinueOnErrorShouldConvertErrorsToWarnings()
                     </Target>
 
                 </Project>
-        
+
                 ");
 
             Assertion.AssertEquals("Expected zero errors", 0, logger.ErrorCount);
@@ -426,8 +426,8 @@ public void IsRunningMultipleNodes()
             // Verify TEM is running singleProc mode before we can test to make sure EngineProxy is correctly using the value
             Assertion.Assert("Expected TEM to be running singleProcMode", taskExecutionModule.GetExecutionModuleMode() == TaskExecutionModule.TaskExecutionModuleMode.SingleProcMode);
             Assertion.Assert("Expected EngineProxy for TEM running in singleProc mode to return false for IsRunningMultipleNodes", engineProxy.IsRunningMultipleNodes == false);
-            
-            // Verify TEM is running MultiProc mode before we can test to make sure EngineProxy is correctly using the value 
+
+            // Verify TEM is running MultiProc mode before we can test to make sure EngineProxy is correctly using the value
             TaskExecutionModule.TaskExecutionModuleMode moduleMode = taskExecutionModule2.GetExecutionModuleMode();
             Assertion.Assert("Expected TEM to be not be running SingleProcMode",moduleMode != TaskExecutionModule.TaskExecutionModuleMode.SingleProcMode);
             Assertion.Assert("Expected EngineProxy for TEM running in MultiProc mode to return true for IsRunningMultipleNodes", engineProxy2.IsRunningMultipleNodes);
@@ -620,7 +620,7 @@ public void UseSameProjectObjectIfChildIsEquivalent()
 
             //            string childProjectFullPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("child.proj", @"
             //                      <Project ToolsVersion='44.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-            //                          <UsingTask TaskName='CreateItem' AssemblyName='Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>    
+            //                          <UsingTask TaskName='CreateItem' AssemblyName='Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>
             //                          <Target Name='BuildTarget'>
             //                              <CreateItem Include='BuildTargetRan'>
             //                                  <Output TaskParameter='Include' ItemName='BuildTargetRan'/>
diff --git a/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs b/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
index 5904741689e..e724f3d0969 100644
--- a/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
@@ -752,13 +752,13 @@ public class Class1
 
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
-        /// have all sorts of crazy characters in their name (courtesy of DanMose who apparently
+        /// have all sorts of different characters in their name (courtesy of DanMose who apparently
         /// just ran his fingers up and down the on the upper row of his keyboard :) ).  There
         /// is even a P2P reference between the two projects in the .SLN.
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
-        public void SolutionWithLotsaCrazyCharacters()
+        public void SolutionWithLotsaDifferentCharacters()
         {
             if (ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35) == null)
             {
diff --git a/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs b/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
index 5fd283b96b8..5338d973fe7 100644
--- a/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
@@ -984,7 +984,7 @@ public void SetPropertyOnDifferentThread()
         }
 
         /// <summary>
-        /// Lame but simple way to get the lookup from another thread
+        /// Bad but simple way to get the lookup from another thread
         /// </summary>
         private static Lookup lookupPassedBetweenThreads;
 
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index 15f8d543192..fe15c1e9287 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -425,13 +425,13 @@ internal ItemsAndMetadataPair(Hashtable items, Dictionary<string, MetadataRefere
 
         internal Hashtable Items
         {
-            get { return items; }
+            readonly get { return items; }
             set { items = value; }
         }
 
         internal Dictionary<string, MetadataReference> Metadata
         {
-            get { return metadata; }
+            readonly get { return metadata; }
             set { metadata = value; }
         }
     }
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index f7fd9fdf988..1f574b8af5e 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -117,7 +117,6 @@ public override void Initialize(IEventSource eventSource, int nodeCount)
         /// <summary>
         /// The handler for the write delegate of the console logger we are deriving from.
         /// </summary>
-        /// <owner>KieranMo</owner>
         /// <param name="text">The text to write to the log</param>
         private void Write(string text)
         {
@@ -143,7 +142,6 @@ private void Write(string text)
         /// <summary>
         /// Shutdown method implementation of ILogger - we need to flush and close our logfile.
         /// </summary>
-        /// <owner>KieranMo</owner>
         public override void Shutdown()
         {
             fileWriter?.Close();
@@ -152,7 +150,6 @@ public override void Shutdown()
         /// <summary>
         /// Parses out the logger parameters from the Parameters string.
         /// </summary>
-        /// <owner>KieranMo</owner>
         private void ParseFileLoggerParameters()
         {
             if (this.Parameters != null)
@@ -180,7 +177,6 @@ private void ParseFileLoggerParameters()
         /// <summary>
         /// Apply a parameter parsed by the file logger.
         /// </summary>
-        /// <owner>KieranMo</owner>
         private void ApplyFileLoggerParameter(string parameterName, string parameterValue)
         {
             switch (parameterName.ToUpperInvariant())
diff --git a/src/Deprecated/Engine/Resources/xlf/Strings.es.xlf b/src/Deprecated/Engine/Resources/xlf/Strings.es.xlf
index c4dc32ae020..5505503def8 100644
--- a/src/Deprecated/Engine/Resources/xlf/Strings.es.xlf
+++ b/src/Deprecated/Engine/Resources/xlf/Strings.es.xlf
@@ -1963,7 +1963,7 @@
       </trans-unit>
       <trans-unit id="STARequired">
         <source>MSB4056: The MSBuild engine must be called on a single-threaded-apartment. Current threading model is "{0}". Proceeding, but some tasks may not function correctly.</source>
-        <target state="translated">MSB4056: Se debe llamar al motor de MSBuild en Singlethread-Apartment. El modelo de subprocesos actual es '"{0}". El proceso contin√∫a, pero es posible que algunas tareas no funcionen correctamente.</target>
+        <target state="translated">MSB4056: Se debe llamar al motor de MSBuild en Singlethread-Apartment. El modelo de subprocesos actual es "{0}". El proceso contin√∫a, pero es posible que algunas tareas no funcionen correctamente.</target>
         <note>{StrBegin="MSB4056: "}</note>
         <alt-trans match-quality="100%" tool="BlackBox/MSR MT">
           <target state-qualifier="tm-suggestion">MSB4056: Das MSBuild-Modul muss in einem Singlethread-Apartment aufgerufen werden. Das aktuelle Threadmodell ist {0}. Der Vorgang wird fortgesetzt, aber einige Aufgaben werden m√∂glicherweise nicht ordnungsgem√§√ü ausgef√ºhrt.</target>
diff --git a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
index 9d065a332ba..250ba817679 100644
--- a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
@@ -2419,7 +2419,7 @@
       </trans-unit>
       <trans-unit id="WhenNotAllowedAfterOtherwise">
         <source>MSB4084: A &lt;When&gt; element may not follow an &lt;Otherwise&gt; element in a &lt;Choose&gt;.</source>
-        <target state="translated">MSB4084: Âú® &lt;Choose&gt; ‰∏≠Ôºå&lt;When&gt; È†ÖÁõÆ‰∏çËÉΩÊé•Âú® &lt;Otherwise&gt; È†ÖÁõÆÂæåÈù¢„ÄÇ</target>
+        <target state="translated">MSB4084: Âú® &lt;Choose&gt; ‰∏≠Ôºå&lt;When&gt; ÂÖÉÁ¥†‰∏çËÉΩÊé•Âú® &lt;Otherwise&gt; ÂÖÉÁ¥†ÂæåÈù¢„ÄÇ</target>
         <note>{StrBegin="MSB4084: "}</note>
         <alt-trans match-quality="100%" tool="BlackBox/MSR MT">
           <target state-qualifier="mt-suggestion">MSB4084: A &lt; &gt;-Element kein Element &lt; Otherwise &gt; &lt; ausw√§hlen &gt; folgen.</target>
diff --git a/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs b/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
index 42750cc2964..1d28600ad11 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
@@ -290,7 +290,7 @@ static internal void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
         }
 
         /// <summary>
-        /// Parses the crazy string passed into AssertItemsMatch and returns a list of ITaskItems.
+        /// Parses the different string passed into AssertItemsMatch and returns a list of ITaskItems.
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <returns></returns>
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index d136a2607c9..0352fbf056b 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -117,4 +117,9 @@
     <FeatureMSIORedist>true</FeatureMSIORedist>
   </PropertyGroup>
 
+  <PropertyGroup Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">
+    <DefineConstants>$(DefineConstants);FEATURE_REPORTFILEACCESSES</DefineConstants>
+    <FeatureReportFileAccesses>true</FeatureReportFileAccesses>
+  </PropertyGroup>
+
 </Project>
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index f6809d2e4bf..fd9dc2a5974 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -15,7 +15,7 @@
     <!-- Ensure that compiler errors emit full paths so that files
          can be correctly annotated in GitHub. -->
     <GenerateFullPaths>true</GenerateFullPaths>
-    
+
     <!-- https://github.com/NuGet/Home/issues/8684 -->
     <NoWarn>$(NoWarn);NU5131</NoWarn>
 
@@ -36,7 +36,7 @@
     <PlatformTarget>AnyCPU</PlatformTarget>
 
     <!-- Target frameworks for Exe and unit test projects (ie projects with runtime output) -->
-    <RuntimeOutputTargetFrameworks>net7.0</RuntimeOutputTargetFrameworks>
+    <RuntimeOutputTargetFrameworks>$(LatestDotNetCoreForMSBuild)</RuntimeOutputTargetFrameworks>
     <RuntimeOutputTargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);$(RuntimeOutputTargetFrameworks)</RuntimeOutputTargetFrameworks>
     <RuntimeOutputTargetFrameworks Condition="'$(MonoBuild)' == 'true'">$(FullFrameworkTFM)</RuntimeOutputTargetFrameworks>
 
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index fe1a2d71613..68295e63b40 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -49,12 +49,6 @@
   </PropertyGroup>
 
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true'">
-    <!-- MSBuild isn't xunit analyzer clean, so remove the reference to the xunit package added by the repo toolset and
-         replace it with references to xunit.core and xunit.assert. -->
-    <PackageReference Remove="xunit" />
-    <PackageReference Include="xunit.core" />
-    <PackageReference Include="xunit.assert" />
-
     <!-- Force updated reference to this package because xunit and shouldly
          are netstandard1.6 and transitively bring in an old reference -->
     <PackageReference Include="System.Security.Cryptography.X509Certificates" />
@@ -79,7 +73,7 @@
     <PackageReference Update="Microsoft.NETCore.App" PrivateAssets="All" />
 
     <!-- Configure analyzer to forbid certain API calls -->
-    <AdditionalFiles Include="$(MSBuildThisFileDirectory)BannedSymbols.txt" />
+    <AdditionalFiles Include="$(MSBuildThisFileDirectory)BannedSymbols.txt" Condition=" '$(IsUnitTestProject)' != 'true' " />
   </ItemGroup>
 
   <PropertyGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true'">
@@ -129,7 +123,7 @@
     </ItemGroup>
   </Target>
 
-  <Target Name="CreateTypeLib" BeforeTargets="AfterBuild" Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(CreateTlb)' == 'true' and $([MSBuild]::IsOSPlatform('windows')) and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' != 'Core'">
+  <Target Name="CreateTypeLib" BeforeTargets="AfterBuild" Inputs="$(TargetPath)" Outputs="$(TargetDir)$(TargetName).tlb;$(TargetDir)x64\$(TargetName).tlb" Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(CreateTlb)' == 'true' and $([MSBuild]::IsOSPlatform('windows')) and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' != 'Core'">
     <PropertyGroup>
       <TlbExpPath>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPathToDotNetFrameworkSdkFile('tlbexp.exe'))</TlbExpPath>
       <!-- Provide a mechanism for turning on verbose TlbExp output for diagnosing issues -->
diff --git a/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs b/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
index 8e2bf7db11b..f93d085bef2 100644
--- a/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
@@ -29,14 +29,15 @@ public void SerializationDeserializationTest()
             stream.Position = 0;
             using BinaryReader br = new BinaryReader(stream);
             AssemblyLoadBuildEventArgs argDeserialized = new();
-            argDeserialized.CreateFromStream(br, 0);
-
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+            argDeserialized.CreateFromStream(br, packetVersion);
             argDeserialized.LoadingInitiator.ShouldBe(loadingInitiator);
             argDeserialized.AssemblyName.ShouldBe(assemblyName);
             argDeserialized.AssemblyPath.ShouldBe(assemblyPath);
             argDeserialized.MVID.ShouldBe(mvid);
             argDeserialized.AppDomainDescriptor.ShouldBe(appDomainName);
             argDeserialized.LoadingContext.ShouldBe(context);
+            argDeserialized.Importance.ShouldBe(arg.Importance);
         }
     }
 }
diff --git a/src/Framework.UnitTests/EventArgs_Tests.cs b/src/Framework.UnitTests/EventArgs_Tests.cs
index c2af0cbdef1..04a1c9e61ea 100644
--- a/src/Framework.UnitTests/EventArgs_Tests.cs
+++ b/src/Framework.UnitTests/EventArgs_Tests.cs
@@ -53,27 +53,6 @@ public void EventArgsCtors()
         }
         #endregion
 
-        /// <summary>
-        /// Verify a whidbey project started event can be deserialized, the whidbey event is stored in a serialized base64 string.
-        /// </summary>
-        [Fact]
-        public void TestDeserialization()
-        {
-            string base64OldProjectStarted = "AAEAAAD/////AQAAAAAAAAAMAgAAAFxNaWNyb3NvZnQuQnVpbGQuRnJhbWV3b3JrLCBWZXJzaW9uPTIuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49YjAzZjVmN2YxMWQ1MGEzYQUBAAAAMU1pY3Jvc29mdC5CdWlsZC5GcmFtZXdvcmsuUHJvamVjdFN0YXJ0ZWRFdmVudEFyZ3MHAAAAC3Byb2plY3RGaWxlC3RhcmdldE5hbWVzFkJ1aWxkRXZlbnRBcmdzK21lc3NhZ2UaQnVpbGRFdmVudEFyZ3MraGVscEtleXdvcmQZQnVpbGRFdmVudEFyZ3Mrc2VuZGVyTmFtZRhCdWlsZEV2ZW50QXJncyt0aW1lc3RhbXAXQnVpbGRFdmVudEFyZ3MrdGhyZWFkSWQBAQEBAQAADQgCAAAABgMAAAALcHJvamVjdEZpbGUGBAAAAAt0YXJnZXROYW1lcwYFAAAAB21lc3NhZ2UGBgAAAAtoZWxwS2V5d29yZAYHAAAAB01TQnVpbGQBl5vjTYvIiAsAAAAL";
-            BinaryFormatter bf = new BinaryFormatter();
-            MemoryStream ms = new MemoryStream();
-            byte[] binaryObject = Convert.FromBase64String(base64OldProjectStarted);
-            ms.Write(binaryObject, 0, binaryObject.Length);
-            ms.Position = 0;
-            ProjectStartedEventArgs pse = (ProjectStartedEventArgs)bf.Deserialize(ms);
-            pse.Message.ShouldBe("message", StringCompareShould.IgnoreCase);
-            pse.ProjectFile.ShouldBe("projectFile", StringCompareShould.IgnoreCase);
-            pse.ProjectId.ShouldBe(-1);
-            pse.TargetNames.ShouldBe("targetNames", StringCompareShould.IgnoreCase);
-            pse.BuildEventContext.ShouldBe(BuildEventContext.Invalid);
-            pse.ParentProjectBuildEventContext.ShouldBe(BuildEventContext.Invalid);
-        }
-
         /// <summary>
         /// Verify the BuildEventContext is exercised
         /// </summary>
diff --git a/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs b/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs
new file mode 100644
index 00000000000..d1bcb987a1f
--- /dev/null
+++ b/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs
@@ -0,0 +1,218 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using FluentAssertions;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests;
+
+public class ExtendedBuildEventArgs_Tests
+{
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedCustomBuildEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedCustomBuildEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { {"m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedCustomBuildEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedErrorEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedBuildErrorEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            subcategory: withOptionalData ? "sub-type" : null,
+            code: withOptionalData ? "a-code" : null,
+            file: withOptionalData ? ".\\dev\\my.csproj" : null,
+            lineNumber: withOptionalData ? 1 : default,
+            columnNumber: withOptionalData ? 2 : default,
+            endLineNumber: withOptionalData ? 3 : default,
+            endColumnNumber: withOptionalData ? 4 : default,
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            helpLink: withOptionalData ? "(001)2234456" : null,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+        {
+            ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+            ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { { "m1", "v1" }, { "m2", "v2" } } : null,
+            BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+        };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedBuildErrorEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedWarningEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedBuildWarningEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            subcategory: withOptionalData ? "sub-type" : null,
+            code: withOptionalData ? "a-code" : null,
+            file: withOptionalData ? ".\\dev\\my.csproj" : null,
+            lineNumber: withOptionalData ? 1 : default,
+            columnNumber: withOptionalData ? 2 : default,
+            endLineNumber: withOptionalData ? 3 : default,
+            endColumnNumber: withOptionalData ? 4 : default,
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            helpLink: withOptionalData ? "(001)2234456" : null,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+        {
+            ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+            ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { { "m1", "v1" }, { "m2", "v2" } } : null,
+            BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+        };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedBuildWarningEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedMessageEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedBuildMessageEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            subcategory: withOptionalData ? "sub-type" : null,
+            code: withOptionalData ? "a-code" : null,
+            file: withOptionalData ? ".\\dev\\my.csproj" : null,
+            lineNumber: withOptionalData ? 1 : default,
+            columnNumber: withOptionalData ? 2 : default,
+            endLineNumber: withOptionalData ? 3 : default,
+            endColumnNumber: withOptionalData ? 4 : default,
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            importance: withOptionalData ? MessageImportance.Normal : default,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+        {
+            ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+            ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { { "m1", "v1" }, { "m2", "v2" } } : null,
+            BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+        };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedBuildMessageEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+    [Fact]
+    public void ExtendedCustomBuildEventArgs_Ctors()
+    {
+        var ea = new ExtendedCustomBuildEventArgs();
+        ea = new ExtendedCustomBuildEventArgs("type");
+        ea = new ExtendedCustomBuildEventArgs("type", "Message {0}", "Help", "sender");
+        ea = new ExtendedCustomBuildEventArgs("type", "Message {0}", "Help", "sender", DateTime.Now);
+        ea = new ExtendedCustomBuildEventArgs("type", "Message {0}", "Help", "sender", DateTime.Now, "arg1");
+        ea = new ExtendedCustomBuildEventArgs("type");
+        ea = new ExtendedCustomBuildEventArgs("type", null, null, null);
+        ea = new ExtendedCustomBuildEventArgs("type", null, null, null, default(DateTime));
+        ea = new ExtendedCustomBuildEventArgs("type", null, null, null, default(DateTime), null);
+    }
+
+    [Fact]
+    public void ExtendedBuildErrorEventArgs_Ctors()
+    {
+        var ea = new ExtendedBuildErrorEventArgs();
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender");
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", DateTime.Now);
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", DateTime.Now, "Message");
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", "HelpLink", DateTime.Now, "Message");
+        ea = new ExtendedBuildErrorEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null);
+        ea = new ExtendedBuildErrorEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, DateTime.Now);
+        ea = new ExtendedBuildErrorEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, null, DateTime.Now, null);
+    }
+
+    [Fact]
+    public void ExtendedBuildWarningEventArgs_Ctors()
+    {
+        var ea = new ExtendedBuildWarningEventArgs();
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender");
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", DateTime.Now);
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", DateTime.Now, "Message");
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", "HelpLink", DateTime.Now, "Message");
+        ea = new ExtendedBuildWarningEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null);
+        ea = new ExtendedBuildWarningEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, DateTime.Now);
+        ea = new ExtendedBuildWarningEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, null, DateTime.Now, null);
+    }
+
+    [Fact]
+    public void ExtendedBuildMessageEventArgs_Ctors()
+    {
+        var ea = new ExtendedBuildMessageEventArgs();
+        ea = new ExtendedBuildMessageEventArgs("type");
+        ea = new ExtendedBuildMessageEventArgs("type", "Message", "HelpKeyword", "sender", MessageImportance.High);
+        ea = new ExtendedBuildMessageEventArgs("type", "Message", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", "Message", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now, "arg1");
+        ea = new ExtendedBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", MessageImportance.High);
+        ea = new ExtendedBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now, "Message");
+        ea = new ExtendedBuildMessageEventArgs("type");
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, default);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, default, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, default, default, null);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default, DateTime.Now, null);
+    }
+}
diff --git a/src/Framework.UnitTests/LoggerException_Tests.cs b/src/Framework.UnitTests/LoggerException_Tests.cs
deleted file mode 100644
index abc8c6fc726..00000000000
--- a/src/Framework.UnitTests/LoggerException_Tests.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.IO;
-using System.Runtime.Serialization.Formatters.Binary;
-using Microsoft.Build.Framework;
-using Shouldly;
-using Xunit;
-
-#nullable disable
-
-namespace Microsoft.Build.UnitTests
-{
-    public class LoggerExceptionTests
-    {
-        /// <summary>
-        /// Verify I implemented ISerializable correctly
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize()
-        {
-            LoggerException e = new LoggerException("message",
-                new Exception("innerException"),
-                "errorCode",
-                "helpKeyword");
-
-            using (MemoryStream memstr = new MemoryStream())
-            {
-                BinaryFormatter frm = new BinaryFormatter();
-
-                frm.Serialize(memstr, e);
-                memstr.Position = 0;
-
-                LoggerException e2 = (LoggerException)frm.Deserialize(memstr);
-
-                e2.ErrorCode.ShouldBe(e.ErrorCode);
-                e2.HelpKeyword.ShouldBe(e.HelpKeyword);
-                e2.Message.ShouldBe(e.Message);
-                e2.InnerException.ShouldNotBeNull();
-                e2.InnerException.Message.ShouldBe(e.InnerException?.Message);
-            }
-        }
-
-        /// <summary>
-        /// Verify I implemented ISerializable correctly, using other ctor
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize2()
-        {
-            LoggerException e = new LoggerException("message");
-
-            using (MemoryStream memstr = new MemoryStream())
-            {
-                BinaryFormatter frm = new BinaryFormatter();
-
-                frm.Serialize(memstr, e);
-                memstr.Position = 0;
-
-                LoggerException e2 = (LoggerException)frm.Deserialize(memstr);
-
-                e2.ErrorCode.ShouldBeNull();
-                e2.HelpKeyword.ShouldBeNull();
-                e2.Message.ShouldBe(e.Message);
-                e2.InnerException.ShouldBeNull();
-            }
-        }
-    }
-}
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index e3b953a332a..09c42cc408e 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -11,6 +11,7 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="FluentAssertions" />
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Shouldly" />
diff --git a/src/Framework.UnitTests/OperatingSystem_Tests.cs b/src/Framework.UnitTests/OperatingSystem_Tests.cs
new file mode 100644
index 00000000000..4fbaf7af615
--- /dev/null
+++ b/src/Framework.UnitTests/OperatingSystem_Tests.cs
@@ -0,0 +1,57 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Shouldly;
+
+using Xunit;
+using Xunit.NetCore.Extensions;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class OperatingSystem_Tests
+    {
+#if !NET5_0_OR_GREATER
+        [WindowsFullFrameworkOnlyTheory]
+        [InlineData("windows", true)]
+        [InlineData("linux", false)]
+        [InlineData("macOS", false)]
+        public void IsOSPlatform(string platform, bool expected)
+        {
+            Microsoft.Build.Framework.OperatingSystem.IsOSPlatform(platform).ShouldBe(expected);
+        }
+
+        [WindowsFullFrameworkOnlyTheory]
+        [InlineData("windows", 4, true)]
+        [InlineData("windows", 999, false)]
+        [InlineData("linux", 0, false)]
+        [InlineData("macOS", 0, false)]
+        public void IsOSPlatformVersionAtLeast(string platform, int major, bool expected)
+        {
+            Microsoft.Build.Framework.OperatingSystem.IsOSPlatformVersionAtLeast(platform, major).ShouldBe(expected);
+        }
+
+        [WindowsFullFrameworkOnlyFact]
+        public void IsWindows()
+        {
+            Microsoft.Build.Framework.OperatingSystem.IsWindows().ShouldBeTrue();
+        }
+
+        [WindowsFullFrameworkOnlyFact]
+        public void IsWindowsVersionAtLeast()
+        {
+            Microsoft.Build.Framework.OperatingSystem.IsWindowsVersionAtLeast(4).ShouldBeTrue();
+            Microsoft.Build.Framework.OperatingSystem.IsWindowsVersionAtLeast(999).ShouldBeFalse();
+        }
+
+        [WindowsFullFrameworkOnlyFact]
+        public void IsOtherThanWindows()
+        {
+            Microsoft.Build.Framework.OperatingSystem.IsFreeBSD().ShouldBeFalse();
+            Microsoft.Build.Framework.OperatingSystem.IsFreeBSDVersionAtLeast(0).ShouldBeFalse();
+            Microsoft.Build.Framework.OperatingSystem.IsLinux().ShouldBeFalse();
+            Microsoft.Build.Framework.OperatingSystem.IsMacOS().ShouldBeFalse();
+            Microsoft.Build.Framework.OperatingSystem.IsMacOSVersionAtLeast(0).ShouldBeFalse();
+        }
+#endif
+    }
+}
diff --git a/src/Framework/AssemblyLoadBuildEventArgs.cs b/src/Framework/AssemblyLoadBuildEventArgs.cs
index bb9d8e58e6f..49f827b19c9 100644
--- a/src/Framework/AssemblyLoadBuildEventArgs.cs
+++ b/src/Framework/AssemblyLoadBuildEventArgs.cs
@@ -20,11 +20,11 @@ public AssemblyLoadBuildEventArgs(
             AssemblyLoadingContext loadingContext,
             string? loadingInitiator,
             string? assemblyName,
-            string assemblyPath,
+            string? assemblyPath,
             Guid mvid,
             string? customAppDomainDescriptor,
             MessageImportance importance = MessageImportance.Low)
-            : base(null, null, null, importance, DateTime.UtcNow, assemblyName, assemblyPath, mvid)
+            : base(null, null, null, importance, DateTime.UtcNow, null)
         {
             LoadingContext = loadingContext;
             LoadingInitiator = loadingInitiator;
@@ -44,6 +44,8 @@ public AssemblyLoadBuildEventArgs(
 
         internal override void WriteToStream(BinaryWriter writer)
         {
+            base.WriteToStream(writer);
+
             writer.Write7BitEncodedInt((int)LoadingContext);
             writer.WriteTimestamp(RawTimestamp);
             writer.WriteOptionalBuildEventContext(BuildEventContext);
@@ -56,6 +58,8 @@ internal override void WriteToStream(BinaryWriter writer)
 
         internal override void CreateFromStream(BinaryReader reader, int version)
         {
+            base.CreateFromStream(reader, version);
+
             LoadingContext = (AssemblyLoadingContext)reader.Read7BitEncodedInt();
             RawTimestamp = reader.ReadTimestamp();
             BuildEventContext = reader.ReadOptionalBuildEventContext();
diff --git a/src/Framework/BinaryReaderFactory.cs b/src/Framework/BinaryReaderFactory.cs
new file mode 100644
index 00000000000..5cc76fe84ea
--- /dev/null
+++ b/src/Framework/BinaryReaderFactory.cs
@@ -0,0 +1,14 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.IO;
+
+namespace Microsoft.Build;
+
+/// <summary>
+/// Opaque holder of shared buffer.
+/// </summary>
+internal abstract class BinaryReaderFactory
+{
+    public abstract BinaryReader Create(Stream stream);
+}
diff --git a/src/Shared/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
similarity index 95%
rename from src/Shared/BinaryTranslator.cs
rename to src/Framework/BinaryTranslator.cs
index 055d34bb141..550f487f8ab 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -8,7 +8,7 @@
 using System.IO;
 using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -22,14 +22,16 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal static class BinaryTranslator
     {
+#nullable enable
         /// <summary>
         /// Returns a read-only serializer.
         /// </summary>
         /// <returns>The serializer.</returns>
-        internal static ITranslator GetReadTranslator(Stream stream, SharedReadBuffer buffer)
+        internal static ITranslator GetReadTranslator(Stream stream, BinaryReaderFactory buffer)
         {
             return new BinaryReadTranslator(stream, buffer);
         }
+#nullable disable
 
         /// <summary>
         /// Returns a write-only serializer.
@@ -56,14 +58,16 @@ private class BinaryReadTranslator : ITranslator
             /// </summary>
             private BinaryReader _reader;
 
+#nullable enable
             /// <summary>
             /// Constructs a serializer from the specified stream, operating in the designated mode.
             /// </summary>
-            public BinaryReadTranslator(Stream packetStream, SharedReadBuffer buffer)
+            public BinaryReadTranslator(Stream packetStream, BinaryReaderFactory buffer)
             {
                 _packetStream = packetStream;
-                _reader = InterningBinaryReader.Create(packetStream, buffer);
+                _reader = buffer.Create(packetStream);
             }
+#nullable disable
 
             /// <summary>
             /// Delegates the Dispose call the to the underlying BinaryReader.
@@ -88,7 +92,7 @@ public BinaryWriter Writer
             {
                 get
                 {
-                    ErrorUtilities.ThrowInternalError("Cannot get writer from reader.");
+                    EscapeHatches.ThrowInternalError("Cannot get writer from reader.");
                     return null;
                 }
             }
@@ -112,6 +116,26 @@ public void Translate(ref bool value)
                 value = _reader.ReadBoolean();
             }
 
+            /// <summary>
+            /// Translates an <see langword="bool"/> array.
+            /// </summary>
+            /// <param name="array">The array to be translated.</param>
+            public void Translate(ref bool[] array)
+            {
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                array = new bool[count];
+
+                for (int i = 0; i < count; i++)
+                {
+                    array[i] = _reader.ReadBoolean();
+                }
+            }
+
             /// <summary>
             /// Translates a byte.
             /// </summary>
@@ -148,6 +172,9 @@ public void Translate(ref int value)
                 value = _reader.ReadInt32();
             }
 
+            /// <inheritdoc/>
+            public void Translate(ref uint unsignedInteger) => unsignedInteger = _reader.ReadUInt32();
+
             /// <summary>
             /// Translates an <see langword="int"/> array.
             /// </summary>
@@ -396,7 +423,6 @@ public void Translate(ref BuildEventContext value)
                     _reader.ReadInt32(),
                     _reader.ReadInt32());
             }
-
 #endif
 
             /// <summary>
@@ -477,7 +503,12 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                TranslateDotNet<Exception>(ref value);
+                if (!TranslateNullable(value))
+                {
+                    return;
+                }
+
+                value = BuildExceptionBase.ReadExceptionFromTranslator(this);
             }
 
 
@@ -761,7 +792,7 @@ public BinaryReader Reader
             {
                 get
                 {
-                    ErrorUtilities.ThrowInternalError("Cannot get reader from writer.");
+                    EscapeHatches.ThrowInternalError("Cannot get reader from writer.");
                     return null;
                 }
             }
@@ -793,6 +824,26 @@ public void Translate(ref bool value)
                 _writer.Write(value);
             }
 
+            /// <summary>
+            /// Translates an <see langword="bool"/> array.
+            /// </summary>
+            /// <param name="array">The array to be translated.</param>
+            public void Translate(ref bool[] array)
+            {
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = array.Length;
+                _writer.Write(count);
+
+                for (int i = 0; i < count; i++)
+                {
+                    _writer.Write(array[i]);
+                }
+            }
+
             /// <summary>
             /// Translates a byte.
             /// </summary>
@@ -829,6 +880,9 @@ public void Translate(ref int value)
                 _writer.Write(value);
             }
 
+            /// <inheritdoc/>
+            public void Translate(ref uint unsignedInteger) => _writer.Write(unsignedInteger);
+
             /// <summary>
             /// Translates an <see langword="int"/> array.
             /// </summary>
@@ -1053,7 +1107,6 @@ public void Translate(ref BuildEventContext value)
                 _writer.Write(value.TargetId);
                 _writer.Write(value.TaskId);
             }
-
 #endif 
 
             /// <summary>
@@ -1100,7 +1153,12 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                TranslateDotNet<Exception>(ref value);
+                if (!TranslateNullable(value))
+                {
+                    return;
+                }
+
+                BuildExceptionBase.WriteExceptionToTranslator(this, value);
             }
 
             /// <summary>
diff --git a/src/Framework/BuildEngineResult.cs b/src/Framework/BuildEngineResult.cs
index 9bb2a0c0b08..4371726a8a3 100644
--- a/src/Framework/BuildEngineResult.cs
+++ b/src/Framework/BuildEngineResult.cs
@@ -42,7 +42,7 @@ public BuildEngineResult(bool result, List<IDictionary<string, ITaskItem[]>> tar
         /// <summary>
         /// Did the build pass or fail. True means the build succeeded, False means the build failed.
         /// </summary>
-        public bool Result
+        public readonly bool Result
         {
             get
             {
diff --git a/src/Framework/BuildException/BuildExceptionBase.cs b/src/Framework/BuildException/BuildExceptionBase.cs
new file mode 100644
index 00000000000..07db4994b93
--- /dev/null
+++ b/src/Framework/BuildException/BuildExceptionBase.cs
@@ -0,0 +1,157 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework.BuildException;
+
+public abstract class BuildExceptionBase : Exception
+{
+    private string? _remoteTypeName;
+    private string? _remoteStackTrace;
+
+    private protected BuildExceptionBase()
+        : base()
+    { }
+
+    private protected BuildExceptionBase(string message)
+        : base(message)
+    { }
+
+    private protected BuildExceptionBase(
+        string message,
+        Exception? inner)
+        : base(message, inner)
+    { }
+
+    // This is needed to allow opting back in to BinaryFormatter serialization
+#if NET8_0_OR_GREATER
+    [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
+    private protected BuildExceptionBase(SerializationInfo info, StreamingContext context)
+        : base(info, context)
+    { }
+
+    public override string? StackTrace => string.IsNullOrEmpty(_remoteStackTrace) ? base.StackTrace : _remoteStackTrace;
+
+    public override string ToString() => string.IsNullOrEmpty(_remoteTypeName) ? base.ToString() : $"{_remoteTypeName}->{base.ToString()}";
+
+    /// <summary>
+    /// Override this method to recover subtype-specific state from the remote exception.
+    /// </summary>
+    protected virtual void InitializeCustomState(IDictionary<string, string?>? customKeyedSerializedData)
+    { }
+
+    /// <summary>
+    /// Override this method to provide subtype-specific state to be serialized.
+    /// </summary>
+    /// <returns></returns>
+    protected virtual IDictionary<string, string?>? FlushCustomState()
+    {
+        return null;
+    }
+
+    private void InitializeFromRemoteState(BuildExceptionRemoteState remoteState)
+    {
+        _remoteTypeName = remoteState.RemoteTypeName;
+        _remoteStackTrace = remoteState.RemoteStackTrace;
+        base.Source = remoteState.Source;
+        base.HelpLink = remoteState.HelpLink;
+        base.HResult = remoteState.HResult;
+        if (remoteState.Source != null)
+        {
+            InitializeCustomState(remoteState.CustomKeyedSerializedData);
+        }
+    }
+
+    internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)
+    {
+        BinaryWriter writer = translator.Writer;
+        writer.Write(exception.InnerException != null);
+        if (exception.InnerException != null)
+        {
+            WriteExceptionToTranslator(translator, exception.InnerException);
+        }
+
+        string serializationType = BuildExceptionSerializationHelper.GetExceptionSerializationKey(exception.GetType());
+        writer.Write(serializationType);
+        writer.Write(exception.Message);
+        writer.WriteOptionalString(exception.StackTrace);
+        writer.WriteOptionalString(exception.Source);
+        writer.WriteOptionalString(exception.HelpLink);
+        // HResult is completely protected up till net4.5
+#if NET || NET45_OR_GREATER
+        int? hresult = exception.HResult;
+#else
+            int? hresult = null;
+#endif
+        writer.WriteOptionalInt32(hresult);
+
+        IDictionary<string, string?>? customKeyedSerializedData = (exception as BuildExceptionBase)?.FlushCustomState();
+        if (customKeyedSerializedData == null)
+        {
+            writer.Write((byte)0);
+        }
+        else
+        {
+            writer.Write((byte)1);
+            writer.Write(customKeyedSerializedData.Count);
+            foreach (var pair in customKeyedSerializedData)
+            {
+                writer.Write(pair.Key);
+                writer.WriteOptionalString(pair.Value);
+            }
+        }
+
+        Debug.Assert((exception.Data?.Count ?? 0) == 0,
+            "Exception Data is not supported in BuildTransferredException");
+    }
+
+    internal static Exception ReadExceptionFromTranslator(ITranslator translator)
+    {
+        BinaryReader reader = translator.Reader;
+        Exception? innerException = null;
+        if (reader.ReadBoolean())
+        {
+            innerException = ReadExceptionFromTranslator(translator);
+        }
+
+        string serializationType = reader.ReadString();
+        string message = reader.ReadString();
+        string? deserializedStackTrace = reader.ReadOptionalString();
+        string? source = reader.ReadOptionalString();
+        string? helpLink = reader.ReadOptionalString();
+        int hResult = reader.ReadOptionalInt32();
+
+        IDictionary<string, string?>? customKeyedSerializedData = null;
+        if (reader.ReadByte() == 1)
+        {
+            int count = reader.ReadInt32();
+            customKeyedSerializedData = new Dictionary<string, string?>(count, StringComparer.CurrentCulture);
+
+            for (int i = 0; i < count; i++)
+            {
+                customKeyedSerializedData[reader.ReadString()] = reader.ReadOptionalString();
+            }
+        }
+
+        BuildExceptionBase exception = BuildExceptionSerializationHelper.CreateExceptionFactory(serializationType)(message, innerException);
+
+        exception.InitializeFromRemoteState(
+            new BuildExceptionRemoteState(
+                serializationType,
+                deserializedStackTrace,
+                source,
+                helpLink,
+                hResult,
+                customKeyedSerializedData));
+
+        return exception;
+    }
+}
diff --git a/src/Framework/BuildException/BuildExceptionRemoteState.cs b/src/Framework/BuildException/BuildExceptionRemoteState.cs
new file mode 100644
index 00000000000..b4d8786f43d
--- /dev/null
+++ b/src/Framework/BuildException/BuildExceptionRemoteState.cs
@@ -0,0 +1,35 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework.BuildException;
+
+/// <summary>
+/// Remote exception internal data serving as the source for the exception deserialization.
+/// </summary>
+internal class BuildExceptionRemoteState
+{
+    public BuildExceptionRemoteState(
+        string remoteTypeName,
+        string? remoteStackTrace,
+        string? source,
+        string? helpLink,
+        int hResult,
+        IDictionary<string, string?>? customKeyedSerializedData)
+    {
+        RemoteTypeName = remoteTypeName;
+        RemoteStackTrace = remoteStackTrace;
+        Source = source;
+        HelpLink = helpLink;
+        HResult = hResult;
+        CustomKeyedSerializedData = customKeyedSerializedData;
+    }
+
+    public string RemoteTypeName { get; init; }
+    public string? RemoteStackTrace { get; init; }
+    public string? Source { get; init; }
+    public string? HelpLink { get; init; }
+    public int HResult { get; init; }
+    public IDictionary<string, string?>? CustomKeyedSerializedData { get; init; }
+}
diff --git a/src/Framework/BuildException/BuildExceptionSerializationHelper.cs b/src/Framework/BuildException/BuildExceptionSerializationHelper.cs
new file mode 100644
index 00000000000..030fd532e00
--- /dev/null
+++ b/src/Framework/BuildException/BuildExceptionSerializationHelper.cs
@@ -0,0 +1,91 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Threading;
+
+namespace Microsoft.Build.Framework.BuildException
+{
+    internal static class BuildExceptionSerializationHelper
+    {
+        public class TypeConstructionTuple
+        {
+            public TypeConstructionTuple(Type type, Func<string, Exception?, BuildExceptionBase> factory)
+            {
+                Type = type;
+                Factory = factory;
+            }
+
+            public Type Type { get; }
+            public Func<string, Exception?, BuildExceptionBase> Factory { get; }
+        }
+
+        private static Dictionary<string, Func<string, Exception?, BuildExceptionBase>>? s_exceptionFactories;
+
+        private static readonly Func<string, Exception?, BuildExceptionBase> s_defaultFactory =
+            (message, innerException) => new GenericBuildTransferredException(message, innerException);
+
+        internal static bool IsSupportedExceptionType(Type type)
+        {
+            return type.IsClass &&
+                   !type.IsAbstract &&
+                   type.IsSubclassOf(typeof(Exception)) &&
+                   type.IsSubclassOf(typeof(BuildExceptionBase));
+        }
+
+        internal static void InitializeSerializationContract(params TypeConstructionTuple[] exceptionsAllowlist)
+        {
+            InitializeSerializationContract((IEnumerable<TypeConstructionTuple>)exceptionsAllowlist);
+        }
+
+        internal static void InitializeSerializationContract(IEnumerable<TypeConstructionTuple> exceptionsAllowlist)
+        {
+            if (s_exceptionFactories != null)
+            {
+                return;
+            }
+
+            var exceptionFactories = new Dictionary<string, Func<string, Exception?, BuildExceptionBase>>();
+
+            foreach (TypeConstructionTuple typeConstructionTuple in exceptionsAllowlist)
+            {
+                Type exceptionType = typeConstructionTuple.Type;
+                Func<string, Exception?, BuildExceptionBase> exceptionFactory = typeConstructionTuple.Factory;
+
+                if (!IsSupportedExceptionType(exceptionType))
+                {
+                    EscapeHatches.ThrowInternalError($"Type {exceptionType.FullName} is not recognized as a build exception type.");
+                }
+
+                string key = GetExceptionSerializationKey(exceptionType);
+                exceptionFactories[key] = exceptionFactory;
+            }
+
+            if (Interlocked.Exchange(ref s_exceptionFactories, exceptionFactories) != null)
+            {
+                EscapeHatches.ThrowInternalError("Serialization contract was already initialized.");
+            }
+        }
+
+        internal static string GetExceptionSerializationKey(Type exceptionType)
+        {
+            return exceptionType.FullName ?? exceptionType.ToString();
+        }
+
+        internal static Func<string, Exception?, BuildExceptionBase> CreateExceptionFactory(string serializationType)
+        {
+            Func<string, Exception?, BuildExceptionBase>? factory = null;
+            if (s_exceptionFactories == null)
+            {
+                EscapeHatches.ThrowInternalError("Serialization contract was not initialized.");
+            }
+            else
+            {
+                s_exceptionFactories.TryGetValue(serializationType, out factory);
+            }
+
+            return factory ?? s_defaultFactory;
+        }
+    }
+}
diff --git a/src/Framework/BuildException/GenericBuildTransferredException.cs b/src/Framework/BuildException/GenericBuildTransferredException.cs
new file mode 100644
index 00000000000..0c0261c80d5
--- /dev/null
+++ b/src/Framework/BuildException/GenericBuildTransferredException.cs
@@ -0,0 +1,22 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework.BuildException;
+
+/// <summary>
+/// A catch-all type for remote exceptions that we don't know how to deserialize.
+/// </summary>
+internal sealed class GenericBuildTransferredException : BuildExceptionBase
+{
+    public GenericBuildTransferredException()
+        : base()
+    { }
+
+    internal GenericBuildTransferredException(
+        string message,
+        Exception? inner)
+        : base(message, inner)
+    { }
+}
diff --git a/src/Framework/BuildStartedEventArgs.cs b/src/Framework/BuildStartedEventArgs.cs
index d4c2882c4f9..09073ee9540 100644
--- a/src/Framework/BuildStartedEventArgs.cs
+++ b/src/Framework/BuildStartedEventArgs.cs
@@ -53,7 +53,7 @@ public BuildStartedEventArgs(
         public BuildStartedEventArgs(
             string? message,
             string? helpKeyword,
-            IDictionary<string, string> environmentOfBuild)
+            IDictionary<string, string>? environmentOfBuild)
             : this(message, helpKeyword, DateTime.UtcNow)
         {
             environmentOnBuildStart = environmentOfBuild;
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 2af7392c4d2..00507237987 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -24,10 +24,10 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves-Dev.md
     internal class ChangeWaves
     {
-        internal static readonly Version Wave17_2 = new Version(17, 2);
         internal static readonly Version Wave17_4 = new Version(17, 4);
         internal static readonly Version Wave17_6 = new Version(17, 6);
-        internal static readonly Version[] AllWaves = { Wave17_2, Wave17_4, Wave17_6 };
+        internal static readonly Version Wave17_8 = new Version(17, 8);
+        internal static readonly Version[] AllWaves = { Wave17_4, Wave17_6, Wave17_8 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
@@ -125,7 +125,7 @@ internal static void ApplyChangeWave()
                 ConversionState = ChangeWaveConversionState.Valid;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
             }
-            else if (!Version.TryParse(msbuildDisableFeaturesFromVersion, out _cachedWave))
+            else if (!TryParseVersion(msbuildDisableFeaturesFromVersion, out _cachedWave))
             {
                 ConversionState = ChangeWaveConversionState.InvalidFormat;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
@@ -173,5 +173,23 @@ internal static void ResetStateForTests()
             _cachedWave = null;
             _state = ChangeWaveConversionState.NotConvertedYet;
         }
+
+        private static bool TryParseVersion(string stringVersion, out Version version)
+        {
+#if FEATURE_NET35_TASKHOST
+            try
+            {
+                version = new Version(stringVersion);
+                return true;
+            }
+            catch (Exception)
+            {
+                version = null;
+                return false;
+            }
+#else
+            return Version.TryParse(stringVersion, out version);
+#endif
+        }
     }
 }
diff --git a/src/Framework/CompatibilitySuppressions.xml b/src/Framework/CompatibilitySuppressions.xml
index 993613f410e..1c5e56d19a3 100644
--- a/src/Framework/CompatibilitySuppressions.xml
+++ b/src/Framework/CompatibilitySuppressions.xml
@@ -1,4 +1,5 @@
 Ôªø<?xml version="1.0" encoding="utf-8"?>
+<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
        This is intentional, because you can only use MSBuild in the context of a .NET SDK
@@ -53,4 +54,9 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
+  <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
+  <Suppression>
+    <DiagnosticId>PKV006</DiagnosticId>
+    <Target>net7.0</Target>
+  </Suppression>
 </Suppressions>
diff --git a/src/Shared/EncodingUtilities.cs b/src/Framework/EncodingUtilities.cs
similarity index 66%
rename from src/Shared/EncodingUtilities.cs
rename to src/Framework/EncodingUtilities.cs
index b7d1813f368..298c740da96 100644
--- a/src/Shared/EncodingUtilities.cs
+++ b/src/Framework/EncodingUtilities.cs
@@ -3,10 +3,16 @@
 
 using System;
 using System.Diagnostics;
+using System.Globalization;
 using System.IO;
 using System.Linq;
+using System.Runtime.InteropServices;
+using System.Security;
 using System.Text;
 
+using Microsoft.Build.Framework;
+using Microsoft.Win32;
+
 #nullable disable
 
 namespace Microsoft.Build.Shared
@@ -48,17 +54,17 @@ internal static Encoding CurrentSystemOemEncoding
 
                 try
                 {
-                    if (NativeMethodsShared.IsWindows)
+                    if (NativeMethods.IsWindows)
                     {
 #if RUNTIME_TYPE_NETCORE
                         Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
 #endif
                         // get the current OEM code page
-                        s_currentOemEncoding = Encoding.GetEncoding(NativeMethodsShared.GetOEMCP());
+                        s_currentOemEncoding = Encoding.GetEncoding(NativeMethods.GetOEMCP());
                     }
                 }
                 // theoretically, GetEncoding may throw an ArgumentException or a NotSupportedException. This should never
-                // really happen, since the code page we pass in has just been returned from the "underlying platform", 
+                // really happen, since the code page we pass in has just been returned from the "underlying platform",
                 // so it really should support it. If it ever happens, we'll just fall back to the default encoding.
                 // No point in showing any errors to the users, since they most likely wouldn't be actionable.
                 catch (ArgumentException ex)
@@ -214,7 +220,7 @@ internal static bool CanEncodeString(int codePage, string stringToEncode)
         /// </remarks>
         internal static Encoding BatchFileEncoding(string contents, string encodingSpecification)
         {
-            if (!NativeMethodsShared.IsWindows)
+            if (!NativeMethods.IsWindows)
             {
                 return EncodingUtilities.Utf8WithoutBom;
             }
@@ -245,5 +251,96 @@ internal static Encoding BatchFileEncoding(string contents, string encodingSpeci
                         : EncodingUtilities.Utf8WithoutBom;
             }
         }
+#nullable enable
+        /// <summary>
+        /// The .NET SDK and Visual Studio both have environment variables that set a custom language. MSBuild should respect the SDK variable.
+        /// To use the corresponding UI culture, in certain cases the console encoding must be changed. This function will change the encoding in these cases.
+        /// This code introduces a breaking change in .NET 8 due to the encoding of the console being changed.
+        /// If the environment variables are undefined, this function should be a no-op.
+        /// </summary>
+        /// <returns>
+        /// The custom language that was set by the user for an 'external' tool besides MSBuild.
+        /// Returns <see langword="null"/> if none are set.
+        /// </returns>
+        public static CultureInfo? GetExternalOverriddenUILanguageIfSupportableWithEncoding()
+        {
+            if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+            {
+                return null;
+            }
+
+            CultureInfo? externalLanguageSetting = GetExternalOverriddenUILanguage();
+            if (externalLanguageSetting != null)
+            {
+                if (
+                    !externalLanguageSetting.TwoLetterISOLanguageName.Equals("en", StringComparison.InvariantCultureIgnoreCase) &&
+                    CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding()
+                    )
+                {
+                    // Setting both encodings causes a change in the CHCP, making it so we don't need to P-Invoke CHCP ourselves.
+                    Console.OutputEncoding = Encoding.UTF8;
+                    // If the InputEncoding is not set, the encoding will work in CMD but not in PowerShell, as the raw CHCP page won't be changed.
+                    Console.InputEncoding = Encoding.UTF8;
+                    return externalLanguageSetting;
+                }
+                else if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+                {
+                    return externalLanguageSetting;
+                }
+            }
+
+            return null;
+        }
+
+        public static bool CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding()
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && Environment.OSVersion.Version.Major >= 10) // UTF-8 is only officially supported on 10+.
+            {
+                try
+                {
+                    using RegistryKey? windowsVersionRegistry = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion");
+                    string? buildNumber = windowsVersionRegistry?.GetValue("CurrentBuildNumber")?.ToString();
+                    const int buildNumberThatOfficiallySupportsUTF8 = 18363;
+                    return buildNumber != null && (int.Parse(buildNumber) >= buildNumberThatOfficiallySupportsUTF8 || ForceUniversalEncodingOptInEnabled());
+                }
+                catch (Exception ex) when (ex is SecurityException or ObjectDisposedException)
+                {
+                    // We don't want to break those in VS on older versions of Windows with a non-en language.
+                    // Allow those without registry permissions to force the encoding, however.
+                    return ForceUniversalEncodingOptInEnabled();
+                }
+            }
+
+            return false;
+        }
+
+        private static bool ForceUniversalEncodingOptInEnabled()
+        {
+            return string.Equals(Environment.GetEnvironmentVariable("DOTNET_CLI_FORCE_UTF8_ENCODING"), "true", StringComparison.OrdinalIgnoreCase);
+        }
+
+        /// <summary>
+        /// Look at UI language overrides that can be set by known external invokers. (DOTNET_CLI_UI_LANGUAGE.)
+        /// Does NOT check System Locale or OS Display Language.
+        /// Ported from the .NET SDK: https://github.com/dotnet/sdk/blob/bcea1face15458814b8e53e8785b52ba464f6538/src/Cli/Microsoft.DotNet.Cli.Utils/UILanguageOverride.cs
+        /// </summary>
+        /// <returns>The custom language that was set by the user for an 'external' tool besides MSBuild.
+        /// Returns null if none are set.</returns>
+        private static CultureInfo? GetExternalOverriddenUILanguage()
+        {
+            // DOTNET_CLI_UI_LANGUAGE=<culture name> is the main way for users to customize the CLI's UI language via the .NET SDK.
+            string? dotnetCliLanguage = Environment.GetEnvironmentVariable("DOTNET_CLI_UI_LANGUAGE");
+            if (dotnetCliLanguage != null)
+            {
+                try
+                {
+                    return new CultureInfo(dotnetCliLanguage);
+                }
+                catch (CultureNotFoundException) { }
+            }
+
+            return null;
+        }
     }
 }
+
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
index 7270bb0b681..491604c7827 100644
--- a/src/Framework/EngineServices.cs
+++ b/src/Framework/EngineServices.cs
@@ -21,10 +21,13 @@ public abstract class EngineServices
         public const int Version1 = 1;
 
         /// <summary>
-        /// An explicit version of this class. Must be incremented whenever new members are added. Derived classes should override
-        /// the property to return the version actually being implemented.
+        /// Gets an explicit version of this class.
         /// </summary>
-        public virtual int Version => Version1; // Not updated since we have not shipped 17.0 yet. This comment is meant to bypass RequiredVersionBumps check in build.ps1 for PR #8336. If the changes in the file are cosmetic, change PR# in this comment to silence the build error on CI build.
+        /// <remarks>
+        /// Must be incremented whenever new members are added. Derived classes should override
+        /// the property to return the version actually being implemented.
+        /// </remarks>
+        public virtual int Version => Version1;
 
         /// <summary>
         /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
diff --git a/src/Framework/ErrorUtilities.cs b/src/Framework/ErrorUtilities.cs
index ca0375ee54d..2cfa8db5559 100644
--- a/src/Framework/ErrorUtilities.cs
+++ b/src/Framework/ErrorUtilities.cs
@@ -13,13 +13,6 @@ namespace Microsoft.Build.Framework
 
     internal class FrameworkErrorUtilities
     {
-        /// <summary>
-        /// Emergency escape hatch. If a customer hits a bug in the shipped product causing an internal exception,
-        /// and fortuitously it happens that ignoring the VerifyThrow allows execution to continue in a reasonable way,
-        /// then we can give them this undocumented environment variable as an immediate workaround.
-        /// </summary>
-        private static readonly bool s_throwExceptions = string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDONOTTHROWINTERNAL"));
-
         /// <summary>
         /// This method should be used in places where one would normally put
         /// an "assert". It should be used to validate that our assumptions are
@@ -29,14 +22,10 @@ internal class FrameworkErrorUtilities
         /// </summary>
         /// <param name="condition"></param>
         /// <param name="unformattedMessage"></param>
-        internal static void VerifyThrow(
-            bool condition,
-            string unformattedMessage)
+        internal static void VerifyThrow(bool condition, string unformattedMessage)
         {
             if (!condition)
             {
-                // PERF NOTE: explicitly passing null for the arguments array
-                // prevents memory allocation
                 ThrowInternalError(unformattedMessage, null, null);
             }
         }
@@ -47,7 +36,7 @@ internal static void VerifyThrow(
         /// anything caused by user action.
         /// </summary>
         /// <param name="parameter">The value of the argument.</param>
-        /// <param name="parameterName">Parameter that should not be null</param>
+        /// <param name="parameterName">Parameter that should not be null.</param>
         internal static void VerifyThrowInternalNull(object parameter, string parameterName)
         {
             if (parameter == null)
@@ -62,10 +51,7 @@ internal static void VerifyThrowInternalNull(object parameter, string parameterN
         /// </summary>
         internal static void ThrowInternalError(string message, Exception innerException, params object[] args)
         {
-            if (s_throwExceptions)
-            {
-                throw new InternalErrorException(string.Format(message, args), innerException);
-            }
+            throw new InternalErrorException(string.Format(message, args), innerException);
         }
     }
 }
diff --git a/src/Framework/ExtendedBuildErrorEventArgs.cs b/src/Framework/ExtendedBuildErrorEventArgs.cs
new file mode 100644
index 00000000000..85d10939236
--- /dev/null
+++ b/src/Framework/ExtendedBuildErrorEventArgs.cs
@@ -0,0 +1,126 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Generic custom error events including extended data for event enriching.
+/// Extended data are implemented by <see cref="IExtendedBuildEventArgs"/>
+/// </summary>
+public sealed class ExtendedBuildErrorEventArgs : BuildErrorEventArgs, IExtendedBuildEventArgs
+{
+    /// <inheritdoc />
+    public string ExtendedType { get; set; }
+
+    /// <inheritdoc />
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <inheritdoc />
+    public string? ExtendedData { get; set; }
+
+    /// <summary>
+    /// Default constructor. Used for deserialization.
+    /// </summary>
+    internal ExtendedBuildErrorEventArgs() : this("undefined") { }
+
+    /// <summary>
+    /// This constructor specifies only type of extended data.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    public ExtendedBuildErrorEventArgs(string type) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows all event data to be initialized
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    public ExtendedBuildErrorEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    public ExtendedBuildErrorEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildErrorEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="helpLink">A link pointing to more information about the error </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildErrorEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, string? helpLink, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, helpLink, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+        writer.WriteExtendedBuildEventData(this);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+        reader.ReadExtendedBuildEventData(this);
+    }
+}
diff --git a/src/Framework/ExtendedBuildMessageEventArgs.cs b/src/Framework/ExtendedBuildMessageEventArgs.cs
new file mode 100644
index 00000000000..53ec510c8da
--- /dev/null
+++ b/src/Framework/ExtendedBuildMessageEventArgs.cs
@@ -0,0 +1,144 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Generic custom build events including extended data for event enriching.
+/// Extended data are implemented by <see cref="IExtendedBuildEventArgs"/>
+/// </summary>
+public sealed class ExtendedBuildMessageEventArgs : BuildMessageEventArgs, IExtendedBuildEventArgs
+{
+    /// <inheritdoc />
+    public string ExtendedType { get; set; }
+
+    /// <inheritdoc />
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <inheritdoc />
+    public string? ExtendedData { get; set; }
+
+    /// <summary>
+    /// Default constructor. Used for deserialization.
+    /// </summary>
+    internal ExtendedBuildMessageEventArgs() : this("undefined") { }
+
+    /// <summary>
+    /// This constructor specifies only type of extended data.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    public ExtendedBuildMessageEventArgs(string type) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows all event data to be initialized
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    public ExtendedBuildMessageEventArgs(string type, string? message, string? helpKeyword, string? senderName, MessageImportance importance)
+        : base(message, helpKeyword, senderName, importance) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    public ExtendedBuildMessageEventArgs(string type, string? message, string? helpKeyword, string? senderName, MessageImportance importance, DateTime eventTimestamp)
+        : base(message, helpKeyword, senderName, importance, eventTimestamp) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildMessageEventArgs(string type, string? message, string? helpKeyword, string? senderName, MessageImportance importance, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(message, helpKeyword, senderName, importance, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows all event data to be initialized
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    public ExtendedBuildMessageEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, MessageImportance importance)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, importance) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    public ExtendedBuildMessageEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, MessageImportance importance, DateTime eventTimestamp)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, importance, eventTimestamp) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildMessageEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, MessageImportance importance, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, importance, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+        writer.WriteExtendedBuildEventData(this);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+        reader.ReadExtendedBuildEventData(this);
+    }
+}
diff --git a/src/Framework/ExtendedBuildWarningEventArgs.cs b/src/Framework/ExtendedBuildWarningEventArgs.cs
new file mode 100644
index 00000000000..9481d2bfbdc
--- /dev/null
+++ b/src/Framework/ExtendedBuildWarningEventArgs.cs
@@ -0,0 +1,126 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Generic custom warning events including extended data for event enriching.
+/// Extended data are implemented by <see cref="IExtendedBuildEventArgs"/>
+/// </summary>
+public sealed class ExtendedBuildWarningEventArgs : BuildWarningEventArgs, IExtendedBuildEventArgs
+{
+    /// <inheritdoc />
+    public string ExtendedType { get; set; }
+
+    /// <inheritdoc />
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <inheritdoc />
+    public string? ExtendedData { get; set; }
+
+    /// <summary>
+    /// Default constructor. Used for deserialization.
+    /// </summary>
+    internal ExtendedBuildWarningEventArgs() : this("undefined") { }
+
+    /// <summary>
+    /// This constructor specifies only type of extended data.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    public ExtendedBuildWarningEventArgs(string type) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows all event data to be initialized
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    public ExtendedBuildWarningEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    public ExtendedBuildWarningEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildWarningEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="helpLink">A link pointing to more information about the error </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildWarningEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, string? helpLink, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, helpLink, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+        writer.WriteExtendedBuildEventData(this);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+        reader.ReadExtendedBuildEventData(this);
+    }
+}
diff --git a/src/Framework/ExtendedCustomBuildEventArgs.cs b/src/Framework/ExtendedCustomBuildEventArgs.cs
new file mode 100644
index 00000000000..0669c025843
--- /dev/null
+++ b/src/Framework/ExtendedCustomBuildEventArgs.cs
@@ -0,0 +1,80 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Generic custom event.
+/// Extended data are implemented by <see cref="IExtendedBuildEventArgs"/>
+/// </summary>
+public sealed class ExtendedCustomBuildEventArgs : CustomBuildEventArgs, IExtendedBuildEventArgs
+{
+    /// <inheritdoc />
+    public string ExtendedType { get; set; }
+
+    /// <inheritdoc />
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <inheritdoc />
+    public string? ExtendedData { get; set; }
+
+    /// <summary>
+    /// This constructor allows event data to be initialized.
+    /// </summary>
+    /// <seealso cref="IExtendedBuildEventArgs.ExtendedType"/>
+    internal ExtendedCustomBuildEventArgs() : this("undefined") {}
+
+    /// <summary>
+    /// This constructor allows event data to be initialized.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <seealso cref="IExtendedBuildEventArgs.ExtendedType"/>
+    public ExtendedCustomBuildEventArgs(string type) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows event data to be initialized.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of sender</param>
+    public ExtendedCustomBuildEventArgs(string type, string? message, string? helpKeyword, string? senderName) : base(message, helpKeyword, senderName) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows event data to be initialized including timestamp.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    public ExtendedCustomBuildEventArgs(string type, string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp) : base(message, helpKeyword, senderName, eventTimestamp) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows event data to be initialized including timestamp.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">Message arguments</param>
+    public ExtendedCustomBuildEventArgs(string type, string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp, params object[]? messageArgs) : base(message, helpKeyword, senderName, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+        writer.WriteExtendedBuildEventData(this);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+        reader.ReadExtendedBuildEventData(this);
+    }
+}
diff --git a/src/Framework/ExternalProjectFinishedEventArgs.cs b/src/Framework/ExternalProjectFinishedEventArgs.cs
index e3960625c3a..4417569e8fc 100644
--- a/src/Framework/ExternalProjectFinishedEventArgs.cs
+++ b/src/Framework/ExternalProjectFinishedEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -16,6 +18,8 @@ namespace Microsoft.Build.Framework
     // immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both
     // forward and backward compatibility
+    // NOTE: Although this class has been modified and do not longer relay on [Serializable]
+    // and BinaryFormatter. We have left it [Serializable] for backward compatibility reasons.
     [Serializable]
     public class ExternalProjectFinishedEventArgs : CustomBuildEventArgs
     {
@@ -93,5 +97,19 @@ public bool Succeeded
                 return succeeded;
             }
         }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+            writer.WriteOptionalString(projectFile);
+            writer.Write(succeeded);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+            projectFile = reader.ReadOptionalString();
+            succeeded = reader.ReadBoolean();
+        }
     }
 }
diff --git a/src/Framework/ExternalProjectStartedEventArgs.cs b/src/Framework/ExternalProjectStartedEventArgs.cs
index 80488df82e9..0d25191f08e 100644
--- a/src/Framework/ExternalProjectStartedEventArgs.cs
+++ b/src/Framework/ExternalProjectStartedEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -16,6 +18,8 @@ namespace Microsoft.Build.Framework
     // immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both
     // forward and backward compatibility
+    // NOTE: Although this class has been modified and do not longer relay on [Serializable]
+    // and BinaryFormatter. We have left it [Serializable] for backward compatibility reasons.
     [Serializable]
     public class ExternalProjectStartedEventArgs : CustomBuildEventArgs
     {
@@ -95,5 +99,19 @@ public string TargetNames
                 return targetNames;
             }
         }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+            writer.WriteOptionalString(projectFile);
+            writer.WriteOptionalString(targetNames);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+            projectFile = reader.ReadOptionalString();
+            targetNames = reader.ReadOptionalString();
+        }
     }
 }
diff --git a/src/Framework/IExtendedBuildEventArgs.cs b/src/Framework/IExtendedBuildEventArgs.cs
new file mode 100644
index 00000000000..0c73ddb914f
--- /dev/null
+++ b/src/Framework/IExtendedBuildEventArgs.cs
@@ -0,0 +1,33 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Interface for Extended EventArgs to allow enriching particular events with extended data.
+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.
+/// </summary>
+public interface IExtendedBuildEventArgs
+{
+    /// <summary>
+    /// Unique string identifying type of extended data so receiver side knows how to interpret, deserialize and handle <see cref="ExtendedData"/>.
+    /// </summary>
+    string ExtendedType { get; set; }
+
+    /// <summary>
+    /// Metadata of <see cref="ExtendedData"/>.
+    /// Example usage:
+    ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref="ExtendedData"/>.
+    ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.
+    /// </summary>
+    Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <summary>
+    /// Transparent data as string.
+    /// Custom code is responsible to serialize and deserialize this string to structured data - if needed.
+    /// Custom code can use any serialization they deem safe - e.g. json for textual data, base64 for binary data...
+    /// </summary>
+    string? ExtendedData { get; set; }
+}
diff --git a/src/Framework/IIncrementalTask.cs b/src/Framework/IIncrementalTask.cs
new file mode 100644
index 00000000000..7a44e93f14b
--- /dev/null
+++ b/src/Framework/IIncrementalTask.cs
@@ -0,0 +1,19 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Interface for tasks which is supports incrementality.
+    /// </summary>
+    /// <remarks>The tasks implementing this interface should return false to stop the build when in <see cref="FailIfNotIncremental"/> is true and task is not fully incremental.  Try to provide helpful information to diagnose incremental behavior.</remarks>
+    public interface IIncrementalTask
+    {
+        /// <summary>
+        /// Set by MSBuild when Question flag is used.
+        /// </summary>
+        bool FailIfNotIncremental { set; }
+    }
+}
diff --git a/src/Framework/IMetadataContainer.cs b/src/Framework/IMetadataContainer.cs
index 7762bc33e31..cc6588f9839 100644
--- a/src/Framework/IMetadataContainer.cs
+++ b/src/Framework/IMetadataContainer.cs
@@ -20,5 +20,17 @@ internal interface IMetadataContainer
         /// in the binary logger.
         /// </summary>
         IEnumerable<KeyValuePair<string, string>> EnumerateMetadata();
+
+        /// <summary>
+        /// Sets the given metadata. The operation is equivalent to calling
+        /// <see cref="ITaskItem.SetMetadata"/> on all metadata, but takes
+        /// advantage of a faster bulk-set operation where applicable. The
+        /// implementation may not perform the same parameter validation
+        /// as SetMetadata.
+        /// </summary>
+        /// <param name="metadata">The metadata to set. The keys are assumed
+        /// to be unique and values are assumed to be escaped.
+        /// </param>
+        void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata);
     }
 }
diff --git a/src/Framework/IStringBuilderProvider.cs b/src/Framework/IStringBuilderProvider.cs
new file mode 100644
index 00000000000..d2f51c6a481
--- /dev/null
+++ b/src/Framework/IStringBuilderProvider.cs
@@ -0,0 +1,38 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+using System.Text;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Provider of <see cref="StringBuilder"/> instances.
+/// Main design goal is for reusable String Builders and string builder pools.
+/// </summary>
+/// <remarks>
+/// It is up to particular implementations to decide how to handle unbalanced releases.
+/// </remarks>
+internal interface IStringBuilderProvider
+{
+    /// <summary>
+    /// Get a <see cref="StringBuilder"/> of at least the specified capacity.
+    /// </summary>
+    /// <param name="capacity">The suggested starting size of this instance.</param>
+    /// <returns>A <see cref="StringBuilder"/> that may or may not be reused.</returns>
+    /// <remarks>
+    /// It can be called any number of times; if a <see cref="StringBuilder"/> is in the cache then
+    /// it will be returned and the cache emptied. Subsequent calls will return a new <see cref="StringBuilder"/>.
+    /// </remarks>
+    StringBuilder Acquire(int capacity);
+
+    /// <summary>
+    /// Get a string and return its builder to the cache.
+    /// </summary>
+    /// <param name="builder">Builder to cache (if it's not too big).</param>
+    /// <returns>The <see langword="string"/> equivalent to <paramref name="builder"/>'s contents.</returns>
+    /// <remarks>
+    /// The StringBuilder should not be used after it has been released.
+    /// </remarks>
+    string GetStringAndRelease(StringBuilder builder);
+}
diff --git a/src/Framework/ITaskItemExtensions.cs b/src/Framework/ITaskItemExtensions.cs
index 7dc7dbdaf86..6ba56e1a880 100644
--- a/src/Framework/ITaskItemExtensions.cs
+++ b/src/Framework/ITaskItemExtensions.cs
@@ -35,7 +35,9 @@ public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this I
                 return enumerableMetadata;
             }
 
-            // In theory this should never be reachable.
+            // Fallback for
+            //  * ITaskItem implementations from MSBuild 3.5 from the GAC
+            //  * Custom ITaskItems that don't use Dictionary<string,string>
             var list = new KeyValuePair<string, string>[customMetadata.Count];
             int i = 0;
 
diff --git a/src/Shared/ITranslatable.cs b/src/Framework/ITranslatable.cs
similarity index 100%
rename from src/Shared/ITranslatable.cs
rename to src/Framework/ITranslatable.cs
diff --git a/src/Shared/ITranslator.cs b/src/Framework/ITranslator.cs
similarity index 97%
rename from src/Shared/ITranslator.cs
rename to src/Framework/ITranslator.cs
index abe32f8d96f..8d267351591 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -104,6 +104,12 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref bool value);
 
+        /// <summary>
+        /// Translates an <see langword="bool"/> array.
+        /// </summary>
+        /// <param name="array">The array to be translated.</param>
+        void Translate(ref bool[] array);
+
         /// <summary>
         /// Translates a byte.
         /// </summary>
@@ -128,6 +134,12 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref int value);
 
+        /// <summary>
+        /// Translates an unsigned integer.
+        /// </summary>
+        /// <param name="unsignedInteger">The unsigned integer to translate.</param>
+        void Translate(ref uint unsignedInteger);
+
         /// <summary>
         /// Translates an <see langword="int"/> array.
         /// </summary>
@@ -227,8 +239,7 @@ BinaryWriter Writer
         /// </remarks>
         /// <param name="value">The context to be translated.</param>
         void Translate(ref BuildEventContext value);
-
-#endif 
+#endif
 
         /// <summary>
         /// Translates an enumeration.
diff --git a/src/Framework/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
index 86383e09bbb..e024e3f67a5 100644
--- a/src/Framework/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Diagnostics;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -15,7 +16,7 @@ namespace Microsoft.Build.Framework
     /// did wrong.
     /// </summary>
     [Serializable]
-    internal sealed class InternalErrorException : Exception
+    internal sealed class InternalErrorException : BuildExceptionBase
     {
         /// <summary>
         /// Default constructor.
@@ -45,9 +46,27 @@ internal InternalErrorException(
         internal InternalErrorException(
             String message,
             Exception innerException) :
-            base("MSB0001: Internal MSBuild Error: " + message + (innerException == null ? String.Empty : ("\n=============\n" + innerException.ToString() + "\n\n")), innerException)
+            this(message, innerException, false)
+        { }
+
+        internal static InternalErrorException CreateFromRemote(string message, Exception innerException)
         {
-            ConsiderDebuggerLaunch(message, innerException);
+            return new InternalErrorException(message, innerException, true /* calledFromDeserialization */);
+        }
+
+        private InternalErrorException(string message, Exception innerException, bool calledFromDeserialization)
+            : base(
+                calledFromDeserialization
+                    ? message
+                    : "MSB0001: Internal MSBuild Error: " + message + (innerException == null
+                        ? String.Empty
+                        : ("\n=============\n" + innerException.ToString() + "\n\n")),
+                innerException)
+        {
+            if (!calledFromDeserialization)
+            {
+                ConsiderDebuggerLaunch(message, innerException);
+            }
         }
 
         #region Serialization (update when adding new class members)
@@ -56,6 +75,9 @@ internal InternalErrorException(
         /// Private constructor used for (de)serialization. The constructor is private as this class is sealed
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InternalErrorException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index ba423ceba87..05e457d90ee 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions; // for SecurityPermissionAttribute
 #endif
@@ -20,7 +22,7 @@ namespace Microsoft.Build.Framework
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public class LoggerException : Exception
+    public class LoggerException : BuildExceptionBase
     {
         /// <summary>
         /// Default constructor.
@@ -80,6 +82,9 @@ public LoggerException(string message, Exception innerException, string errorCod
         /// </summary>
         /// <param name="info">Serialization info</param>
         /// <param name="context">Streaming context</param>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected LoggerException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -95,6 +100,9 @@ protected LoggerException(SerializationInfo info, StreamingContext context)
         /// <param name="context">Streaming context</param>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
@@ -104,7 +112,22 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("helpKeyword", helpKeyword);
         }
 
-        #endregion
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+        }
+
+#endregion
 
         #region Properties
 
diff --git a/src/Framework/Logging/AnsiCodes.cs b/src/Framework/Logging/AnsiCodes.cs
new file mode 100644
index 00000000000..016260d55f8
--- /dev/null
+++ b/src/Framework/Logging/AnsiCodes.cs
@@ -0,0 +1,144 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+/// <summary>
+/// A collection of standard ANSI/VT100 control codes.
+/// </summary>
+internal static class AnsiCodes
+{
+    /// <summary>
+    /// The control sequence introducer.
+    /// </summary>
+    public const string CSI = "\x1b[";
+
+    /// <summary>
+    /// Select graphic rendition.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/>color-code<see cref="SetColor"/> to change text color.
+    /// </remarks>
+    public const string SetColor = ";1m";
+
+    /// <summary>
+    /// Select graphic rendition - set bold mode.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/><see cref="SetBold"/> to change text to bold.
+    /// </remarks>
+    public const string SetBold = "1m";
+
+    /// <summary>
+    /// A shortcut to reset color back to normal.
+    /// </summary>
+    public const string SetDefaultColor = CSI + "m";
+
+    /// <summary>
+    /// Non-xterm extension to render a hyperlink.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="LinkPrefix"/>url<see cref="LinkInfix"/>text<see cref="LinkSuffix"/> to render a hyperlink.
+    /// </remarks>
+    public const string LinkPrefix = "\x1b]8;;";
+
+    /// <summary>
+    /// <see cref="LinkPrefix"/>
+    /// </summary>
+    public const string LinkInfix = "\x1b\\";
+
+    /// <summary>
+    /// <see cref="LinkPrefix"/>
+    /// </summary>
+    public const string LinkSuffix = "\x1b]8;;\x1b\\";
+
+    /// <summary>
+    /// Moves up the specified number of lines and puts cursor at the beginning of the line.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/>N<see cref="MoveUpToLineStart"/> to move N lines up.
+    /// </remarks>
+    public const string MoveUpToLineStart = "F";
+
+    /// <summary>
+    /// Moves forward (to the right) the specified number of characters.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/>N<see cref="MoveForward"/> to move N characters forward.
+    /// </remarks>
+    public const string MoveForward = "C";
+
+    /// <summary>
+    /// Moves backward (to the left) the specified number of characters.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/>N<see cref="MoveBackward"/> to move N characters backward.
+    /// </remarks>
+    public const string MoveBackward = "D";
+
+    /// <summary>
+    /// Clears everything from cursor to end of screen.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/><see cref="EraseInDisplay"/> to clear.
+    /// </remarks>
+    public const string EraseInDisplay = "J";
+
+    /// <summary>
+    /// Clears everything from cursor to the end of the current line.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/><see cref="EraseInLine"/> to clear.
+    /// </remarks>
+    public const string EraseInLine = "K";
+
+    /// <summary>
+    /// Hides the cursor.
+    /// </summary>
+    public const string HideCursor = "\x1b[?25l";
+
+    /// <summary>
+    /// Shows/restores the cursor.
+    /// </summary>
+    public const string ShowCursor = "\x1b[?25h";
+
+    /// <summary>
+    /// Set progress state to a busy spinner. <br/>
+    /// Note: this code works only on ConEmu terminals, and conflicts with push a notification code on iTerm2.
+    /// </summary>
+    /// <remarks>
+    /// <see href="https://conemu.github.io/en/AnsiEscapeCodes.html#ConEmu_specific_OSC">ConEmu specific OSC codes.</see><br/>
+    /// <see href="https://iterm2.com/documentation-escape-codes.html">iTerm2 proprietary escape codes.</see>
+    /// </remarks>
+    public const string SetProgressIndeterminate = "\x1b]9;4;3;\x1b\\";
+
+    /// <summary>
+    /// Remove progress state, restoring taskbar status to normal. <br/>
+    /// Note: this code works only on ConEmu terminals, and conflicts with push a notification code on iTerm2.
+    /// </summary>
+    /// <remarks>
+    /// <see href="https://conemu.github.io/en/AnsiEscapeCodes.html#ConEmu_specific_OSC">ConEmu specific OSC codes.</see><br/>
+    /// <see href="https://iterm2.com/documentation-escape-codes.html">iTerm2 proprietary escape codes.</see>
+    /// </remarks>
+    public const string RemoveProgress = "\x1b]9;4;0;\x1b\\";
+
+    public static string Colorize(string? s, TerminalColor color)
+    {
+        if (string.IsNullOrWhiteSpace(s))
+        {
+            return s ?? "";
+        }
+
+        return $"{CSI}{(int)color}{SetColor}{s}{SetDefaultColor}";
+    }
+
+    public static string MakeBold(string? s)
+    {
+        if (string.IsNullOrWhiteSpace(s))
+        {
+            return s ?? "";
+        }
+
+        return $"{CSI}{SetBold}{s}{SetDefaultColor}";
+    }
+}
diff --git a/src/Framework/Logging/TerminalColor.cs b/src/Framework/Logging/TerminalColor.cs
new file mode 100644
index 00000000000..55b63e915ac
--- /dev/null
+++ b/src/Framework/Logging/TerminalColor.cs
@@ -0,0 +1,20 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+/// <summary>
+/// Enumerates the text colors supported by VT100 terminal.
+/// </summary>
+internal enum TerminalColor
+{
+    Black = 30,
+    Red = 31,
+    Green = 32,
+    Yellow = 33,
+    Blue = 34,
+    Magenta = 35,
+    Cyan = 36,
+    White = 37,
+    Default = 39
+}
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index dbf6df5b071..a5dbe84a3ee 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -316,7 +316,7 @@ public void ParseStop(string projectFileName)
         }
 
         /// <summary>
-        /// Call this method to notify listeners of profiling for the method that removes blacklisted references from the reference table. It puts primary and dependency references in invalid file lists.
+        /// Call this method to notify listeners of profiling for the method that removes denylisted references from the reference table. It puts primary and dependency references in invalid file lists.
         /// </summary>
         [Event(35, Keywords = Keywords.All)]
         public void RarRemoveReferencesMarkedForExclusionStart()
@@ -661,6 +661,18 @@ public void MSBuildServerBuildStop(string commandLine, int countOfConsoleMessage
         {
             WriteEvent(90, commandLine, countOfConsoleMessages, sumSizeOfConsoleMessages, clientExitType, serverExitType);
         }
+
+        [Event(91, Keywords = Keywords.All)]
+        public void ProjectCacheHandleBuildResultStart(string pluginTypeName, string projectPath, string targets)
+        {
+            WriteEvent(91, pluginTypeName, projectPath, targets);
+        }
+
+        [Event(92, Keywords = Keywords.All)]
+        public void ProjectCacheHandleBuildResultStop(string pluginTypeName, string projectPath, string targets)
+        {
+            WriteEvent(92, pluginTypeName, projectPath, targets);
+        }
         #endregion
     }
 }
diff --git a/src/Framework/MetaProjectGeneratedEventArgs.cs b/src/Framework/MetaProjectGeneratedEventArgs.cs
index c18111d9459..1a529ed7171 100644
--- a/src/Framework/MetaProjectGeneratedEventArgs.cs
+++ b/src/Framework/MetaProjectGeneratedEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.Shared;
+using System.IO;
 
 #nullable disable
 
@@ -27,5 +29,19 @@ public MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPa
             this.metaprojectXml = metaprojectXml;
             this.ProjectFile = metaprojectPath;
         }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.WriteOptionalString(metaprojectXml);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            metaprojectXml = reader.ReadOptionalString();
+        }
     }
 }
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 724e1a38496..c0da0474e6c 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -15,10 +15,6 @@
     <PackageReference Include="Microsoft.CodeAnalysis.Collections" PrivateAssets="all" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <PackageReference Include="System.Security.Permissions" />
-  </ItemGroup>
-
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- Promote CompilerServices.Unsafe from the old version we get from System.Memory on net472. -->
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 85fbdddd446..d30a8ec85f5 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -35,6 +35,7 @@ internal static class NativeMethods
     internal const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40;
     internal const uint FILE_TYPE_CHAR = 0x0002;
     internal const Int32 STD_OUTPUT_HANDLE = -11;
+    internal const Int32 STD_ERROR_HANDLE = -12;
     internal const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;
     internal const uint RPC_S_CALLPENDING = 0x80010115;
     internal const uint E_ABORT = (uint)0x80004004;
@@ -76,6 +77,12 @@ internal static class NativeMethods
 
     #region Enums
 
+    internal enum StreamHandleType
+    {
+        StdOut = STD_OUTPUT_HANDLE,
+        StdErr = STD_ERROR_HANDLE,
+    };
+
     private enum PROCESSINFOCLASS : int
     {
         ProcessBasicInformation = 0,
@@ -345,7 +352,7 @@ private struct PROCESS_BASIC_INFORMATION
         public UIntPtr UniqueProcessId;
         public UIntPtr InheritedFromUniqueProcessId;
 
-        public uint Size
+        public readonly uint Size
         {
             get
             {
@@ -1300,7 +1307,7 @@ internal static int GetParentProcessId(int processId)
                 // using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
                 // and could be again when FileUtilities moves to Framework
 
-                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, FileAccess.Read);
+                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, System.IO.FileAccess.Read);
                 using StreamReader r = new(fileStream);
 
                 line = r.ReadLine();
@@ -1480,6 +1487,73 @@ internal static void VerifyThrowWin32Result(int result)
         }
     }
 
+#if !CLR2COMPATIBILITY
+    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes(StreamHandleType handleType = StreamHandleType.StdOut)
+    {
+        if (Console.IsOutputRedirected)
+        {
+            // There's no ANSI terminal support if console output is redirected.
+            return (acceptAnsiColorCodes: false, outputIsScreen: false, originalConsoleMode: null);
+        }
+
+        bool acceptAnsiColorCodes = false;
+        bool outputIsScreen = false;
+        uint? originalConsoleMode = null;
+        if (IsWindows)
+        {
+            try
+            {
+                IntPtr outputStream = GetStdHandle((int)handleType);
+                if (GetConsoleMode(outputStream, out uint consoleMode))
+                {
+                    if ((consoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == ENABLE_VIRTUAL_TERMINAL_PROCESSING)
+                    {
+                        // Console is already in required state.
+                        acceptAnsiColorCodes = true;
+                    }
+                    else
+                    {
+                        originalConsoleMode = consoleMode;
+                        consoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+                        if (SetConsoleMode(outputStream, consoleMode) && GetConsoleMode(outputStream, out consoleMode))
+                        {
+                            // We only know if vt100 is supported if the previous call actually set the new flag, older
+                            // systems ignore the setting.
+                            acceptAnsiColorCodes = (consoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+                        }
+                    }
+
+                    uint fileType = GetFileType(outputStream);
+                    // The std out is a char type (LPT or Console).
+                    outputIsScreen = fileType == FILE_TYPE_CHAR;
+                    acceptAnsiColorCodes &= outputIsScreen;
+                }
+            }
+            catch
+            {
+                // In the unlikely case that the above fails we just ignore and continue.
+            }
+        }
+        else
+        {
+            // On posix OSes we expect console always supports VT100 coloring unless it is explicitly marked as "dumb".
+            acceptAnsiColorCodes = Environment.GetEnvironmentVariable("TERM") != "dumb";
+            // It wasn't redirected as tested above so we assume output is screen/console
+            outputIsScreen = true; 
+        }
+        return (acceptAnsiColorCodes, outputIsScreen, originalConsoleMode);
+    }
+
+    internal static void RestoreConsoleMode(uint? originalConsoleMode, StreamHandleType handleType = StreamHandleType.StdOut)
+    {
+        if (IsWindows && originalConsoleMode is not null)
+        {
+            IntPtr stdOut = GetStdHandle((int)handleType);
+            _ = SetConsoleMode(stdOut, originalConsoleMode.Value);
+        }
+    }
+#endif // !CLR2COMPATIBILITY
+
     #endregion
 
     #region PInvoke
diff --git a/src/Framework/OperatingSystem.cs b/src/Framework/OperatingSystem.cs
new file mode 100644
index 00000000000..883ec55b924
--- /dev/null
+++ b/src/Framework/OperatingSystem.cs
@@ -0,0 +1,64 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if !NET5_0_OR_GREATER
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// System.OperatingSystem static methods were added in net5.0.
+    /// This class creates stand-in methods for net472 builds.
+    /// Assumes only Windows is supported.
+    /// </summary>
+    internal static class OperatingSystem
+    {
+        public static bool IsOSPlatform(string platform)
+        {
+            return platform?.Equals("WINDOWS", StringComparison.OrdinalIgnoreCase) ?? throw new ArgumentNullException(nameof(platform));
+        }
+
+        public static bool IsOSPlatformVersionAtLeast(string platform, int major, int minor = 0, int build = 0, int revision = 0)
+            => IsOSPlatform(platform) && IsOSVersionAtLeast(major, minor, build, revision);
+
+        public static bool IsLinux() => false;
+
+        public static bool IsFreeBSD() => false;
+
+        public static bool IsFreeBSDVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0) => false;
+
+        public static bool IsMacOS() => false;
+
+        public static bool IsMacOSVersionAtLeast(int major, int minor = 0, int build = 0) => false;
+
+        public static bool IsWindows() => true;
+
+        public static bool IsWindowsVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0)
+            => IsWindows() && IsOSVersionAtLeast(major, minor, build, revision);
+
+        private static bool IsOSVersionAtLeast(int major, int minor, int build, int revision)
+        {
+            Version current = Environment.OSVersion.Version;
+
+            if (current.Major != major)
+            {
+                return current.Major > major;
+            }
+
+            if (current.Minor != minor)
+            {
+                return current.Minor > minor;
+            }
+
+            if (current.Build != build)
+            {
+                return current.Build > build;
+            }
+
+            return current.Revision >= revision;
+        }
+    }
+}
+#endif
+
diff --git a/src/Framework/Profiler/EvaluationLocation.cs b/src/Framework/Profiler/EvaluationLocation.cs
index 43dc75bf28d..9f8f95ee9a6 100644
--- a/src/Framework/Profiler/EvaluationLocation.cs
+++ b/src/Framework/Profiler/EvaluationLocation.cs
@@ -101,7 +101,7 @@ public struct EvaluationLocation
         public EvaluationLocationKind Kind { get; }
 
         /// <nodoc/>
-        public bool IsEvaluationPass => File == null;
+        public readonly bool IsEvaluationPass => File == null;
 
         /// <nodoc/>
         public static EvaluationLocation CreateLocationForCondition(long? parentId, EvaluationPass evaluationPass, string evaluationDescription, string file,
@@ -183,7 +183,7 @@ public EvaluationLocation(EvaluationPass evaluationPass, string evaluationPassDe
         public static EvaluationLocation EmptyLocation { get; } = CreateEmptyLocation();
 
         /// <nodoc/>
-        public EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription = null)
+        public readonly EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription = null)
         {
             return new EvaluationLocation(this.Id, evaluationPass, passDescription ?? PassDefaultDescription[evaluationPass],
                 this.File, this.Line, this.ElementName, this.ElementDescription, this.Kind);
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 539fae2b5e1..eba6c9ac5ab 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -76,11 +76,11 @@ public ProjectStartedEventArgs(
             int projectId,
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
-            BuildEventContext parentBuildEventContext)
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
+            BuildEventContext? parentBuildEventContext)
             : this(projectId, message, helpKeyword, projectFile, targetNames, properties, items, parentBuildEventContext, DateTime.UtcNow)
         {
         }
@@ -103,13 +103,13 @@ public ProjectStartedEventArgs(
             int projectId,
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
-            BuildEventContext parentBuildEventContext,
-            IDictionary<string, string> globalProperties,
-            string toolsVersion)
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
+            BuildEventContext? parentBuildEventContext,
+            IDictionary<string, string>? globalProperties,
+            string? toolsVersion)
             : this(projectId, message, helpKeyword, projectFile, targetNames, properties, items, parentBuildEventContext)
         {
             this.GlobalProperties = globalProperties;
@@ -130,10 +130,10 @@ public ProjectStartedEventArgs(
         public ProjectStartedEventArgs(
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
             DateTime eventTimestamp)
             : base(message, helpKeyword, "MSBuild", eventTimestamp)
         {
@@ -160,11 +160,11 @@ public ProjectStartedEventArgs(
             int projectId,
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
-            BuildEventContext parentBuildEventContext,
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
+            BuildEventContext? parentBuildEventContext,
             DateTime eventTimestamp)
             : this(message, helpKeyword, projectFile, targetNames, properties, items, eventTimestamp)
         {
diff --git a/src/Framework/PropertyInitialValueSetEventArgs.cs b/src/Framework/PropertyInitialValueSetEventArgs.cs
index 2f623ad6648..318755fcde3 100644
--- a/src/Framework/PropertyInitialValueSetEventArgs.cs
+++ b/src/Framework/PropertyInitialValueSetEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -56,5 +58,23 @@ public PropertyInitialValueSetEventArgs(
         /// The source of the property.
         /// </summary>
         public string PropertySource { get; set; }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.WriteOptionalString(PropertyName);
+            writer.WriteOptionalString(PropertyValue);
+            writer.WriteOptionalString(PropertySource);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            PropertyName = reader.ReadOptionalString();
+            PropertyValue = reader.ReadOptionalString();
+            PropertySource = reader.ReadOptionalString();
+        }
     }
 }
diff --git a/src/Framework/PropertyReassignmentEventArgs.cs b/src/Framework/PropertyReassignmentEventArgs.cs
index 7c3c81f92e2..29ec2935e0b 100644
--- a/src/Framework/PropertyReassignmentEventArgs.cs
+++ b/src/Framework/PropertyReassignmentEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -79,5 +81,25 @@ public override string Message
                 return RawMessage;
             }
         }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.WriteOptionalString(PropertyName);
+            writer.WriteOptionalString(NewValue);
+            writer.WriteOptionalString(PreviousValue);
+            writer.WriteOptionalString(Location);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            PropertyName = reader.ReadOptionalString();
+            NewValue = reader.ReadOptionalString();
+            PreviousValue = reader.ReadOptionalString();
+            Location = reader.ReadOptionalString();
+        }
     }
 }
diff --git a/src/Framework/README.md b/src/Framework/README.md
index 8a86bc21cc5..562f1208165 100644
--- a/src/Framework/README.md
+++ b/src/Framework/README.md
@@ -6,6 +6,6 @@ The items in this namespace are primarily base-level classes and interfaces shar
 [`ITask`](https://docs.microsoft.com/dotnet/api/microsoft.build.framework.itask), and [`ILogger`](https://docs.microsoft.com/dotnet/api/microsoft.build.framework.ilogger).
 
 ### netstandard2.0 target
-The `netstandard2.0` target of this build is configured only to output reference assemblies; at runtime MSBuild will be `net7.0` or `net472`. Please use the `net7.0`-targeted assemblies for .NET Core 6+ scenarios.
+The `netstandard2.0` target of this build is configured only to output reference assemblies; at runtime MSBuild will be `net8.0` or `net472`. Please use the `net8.0`-targeted assemblies for .NET 8+ scenarios.
 
 For context, see https://github.com/dotnet/msbuild/pull/6148
\ No newline at end of file
diff --git a/src/Framework/ResponseFileUsedEventArgs.cs b/src/Framework/ResponseFileUsedEventArgs.cs
index bc027518a67..7e9f132a262 100644
--- a/src/Framework/ResponseFileUsedEventArgs.cs
+++ b/src/Framework/ResponseFileUsedEventArgs.cs
@@ -17,7 +17,7 @@ public ResponseFileUsedEventArgs()
         /// <summary>
         /// Initialize a new instance of the ResponseFileUsedEventArgs class.
         /// </summary>
-        public ResponseFileUsedEventArgs(string responseFilePath) : base()
+        public ResponseFileUsedEventArgs(string? responseFilePath) : base()
         {
             ResponseFilePath = responseFilePath;
         }
diff --git a/src/Framework/TaskItemData.cs b/src/Framework/TaskItemData.cs
index 560daa03662..48c3410d7d8 100644
--- a/src/Framework/TaskItemData.cs
+++ b/src/Framework/TaskItemData.cs
@@ -49,6 +49,9 @@ public TaskItemData(ITaskItem original)
 
         IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata() => Metadata;
 
+        void IMetadataContainer.ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
+            => throw new InvalidOperationException($"{nameof(TaskItemData)} does not support write operations");
+
         public int MetadataCount => Metadata.Count;
 
         public ICollection MetadataNames => (ICollection)Metadata.Keys;
@@ -63,7 +66,7 @@ public IDictionary CloneCustomMetadata()
 
         public void CopyMetadataTo(ITaskItem destinationItem)
         {
-            throw new NotImplementedException();
+            throw new InvalidOperationException($"{nameof(TaskItemData)} does not support write operations");
         }
 
         public string GetMetadata(string metadataName)
@@ -74,12 +77,12 @@ public string GetMetadata(string metadataName)
 
         public void RemoveMetadata(string metadataName)
         {
-            throw new NotImplementedException();
+            throw new InvalidOperationException($"{nameof(TaskItemData)} does not support write operations");
         }
 
         public void SetMetadata(string metadataName, string metadataValue)
         {
-            throw new NotImplementedException();
+            throw new InvalidOperationException($"{nameof(TaskItemData)} does not support write operations");
         }
 
         public override string ToString()
diff --git a/src/Framework/Telemetry/KnownTelemetry.cs b/src/Framework/Telemetry/KnownTelemetry.cs
index 2a335fa0930..7685bdda537 100644
--- a/src/Framework/Telemetry/KnownTelemetry.cs
+++ b/src/Framework/Telemetry/KnownTelemetry.cs
@@ -15,4 +15,9 @@ internal static class KnownTelemetry
     /// Null means there are no prior collected build telemetry data, new clean instance shall be created for particular build.
     /// </summary>
     public static BuildTelemetry? PartialBuildTelemetry { get; set; }
+
+    /// <summary>
+    /// Describes how logging was configured.
+    /// </summary>
+    public static LoggingConfigurationTelemetry LoggingConfigurationTelemetry { get; } = new LoggingConfigurationTelemetry();
 }
diff --git a/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
new file mode 100644
index 00000000000..5281c43b9d2
--- /dev/null
+++ b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
@@ -0,0 +1,150 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Globalization;
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+internal class LoggingConfigurationTelemetry : TelemetryBase
+{
+    public override string EventName => "loggingConfiguration";
+
+    /// <summary>
+    /// True if terminal logger was used.
+    /// </summary>
+    public bool TerminalLogger { get; set; }
+
+    /// <summary>
+    /// What was user intent:
+    ///   on | true -> user intent to enable logging
+    ///   off | false -> user intent to disable logging
+    ///   auto -> user intent to use logging if terminal allows it
+    ///   null -> no user intent, using default
+    /// </summary>
+    public string? TerminalLoggerUserIntent { get; set; }
+
+    /// <summary>
+    /// How was user intent signaled:
+    ///   arg -> from command line argument or rsp file
+    ///   MSBUILDTERMINALLOGGER -> from environment variable
+    ///   MSBUILDLIVELOGGER -> from environment variable
+    ///   null -> no user intent
+    /// </summary>
+    public string? TerminalLoggerUserIntentSource { get; set; }
+
+    /// <summary>
+    /// The default behavior of terminal logger if user intent is not specified:
+    ///   on | true -> enable logging
+    ///   off | false -> disable logging
+    ///   auto -> use logging if terminal allows it
+    ///   null -> unspecified
+    /// </summary>
+    public string? TerminalLoggerDefault { get; set; }
+
+    /// <summary>
+    /// How was default behavior signaled:
+    ///   sdk -> from SDK
+    ///   DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER -> from environment variable
+    ///   msbuild -> MSBuild hardcoded default
+    ///   null -> unspecified
+    /// </summary>
+    public string? TerminalLoggerDefaultSource { get; set; }
+
+    /// <summary>
+    /// True if console logger was used.
+    /// </summary>
+    public bool ConsoleLogger { get; set; }
+
+    /// <summary>
+    /// Type of console logger: serial | parallel
+    /// </summary>
+    public string? ConsoleLoggerType { get; set; }
+
+    /// <summary>
+    /// Verbosity of console logger: quiet | minimal | normal | detailed | diagnostic
+    /// </summary>
+    public string? ConsoleLoggerVerbosity { get; set; }
+
+
+    /// <summary>
+    /// True if file logger was used.
+    /// </summary>
+    public bool FileLogger { get; set; }
+
+    /// <summary>
+    /// Type of file logger: serial | parallel
+    /// </summary>
+    public string? FileLoggerType { get; set; }
+
+    /// <summary>
+    /// Number of file loggers.
+    /// </summary>
+    public int FileLoggersCount { get; set; }
+
+    /// <summary>
+    /// Verbosity of file logger: quiet | minimal | normal | detailed | diagnostic
+    /// </summary>
+    public string? FileLoggerVerbosity { get; set; }
+
+    /// <summary>
+    /// True if binary logger was used.
+    /// </summary>
+    public bool BinaryLogger { get; set; }
+
+    /// <summary>
+    /// True if binary logger used default name i.e. no LogFile was specified.
+    /// </summary>
+    public bool BinaryLoggerUsedDefaultName { get; set; }
+
+    public override void UpdateEventProperties()
+    {
+        Properties["TerminalLogger"] = TerminalLogger.ToString(CultureInfo.InvariantCulture);
+
+        if (TerminalLoggerUserIntent != null)
+        {
+            Properties["TerminalLoggerUserIntent"] = TerminalLoggerUserIntent;
+        }
+
+        if (TerminalLoggerUserIntentSource != null)
+        {
+            Properties["TerminalLoggerUserIntentSource"] = TerminalLoggerUserIntentSource;
+        }
+
+        if (TerminalLoggerDefault != null)
+        {
+            Properties["TerminalLoggerDefault"] = TerminalLoggerDefault;
+        }
+
+        if (TerminalLoggerDefaultSource != null)
+        {
+            Properties["TerminalLoggerDefaultSource"] = TerminalLoggerDefaultSource;
+        }
+
+        Properties["ConsoleLogger"] = ConsoleLogger.ToString(CultureInfo.InvariantCulture);
+        if (ConsoleLoggerType != null)
+        {
+            Properties["ConsoleLoggerType"] = ConsoleLoggerType;
+        }
+
+        if (ConsoleLoggerVerbosity != null)
+        {
+            Properties["ConsoleLoggerVerbosity"] = ConsoleLoggerVerbosity;
+        }
+
+        Properties["FileLogger"] = FileLogger.ToString(CultureInfo.InvariantCulture);
+        if (FileLoggerType != null)
+        {
+            Properties["FileLoggerType"] = FileLoggerType;
+            Properties["FileLoggersCount"] = FileLoggersCount.ToString(CultureInfo.InvariantCulture);
+        }
+
+        if (FileLoggerVerbosity != null)
+        {
+            Properties["FileLoggerVerbosity"] = FileLoggerVerbosity;
+        }
+
+        Properties["BinaryLogger"] = BinaryLogger.ToString(CultureInfo.InvariantCulture);
+        Properties["BinaryLoggerUsedDefaultName"] = BinaryLoggerUsedDefaultName.ToString(CultureInfo.InvariantCulture);
+    }
+}
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 7a4db37105c..04b2fc90237 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Globalization;
 
 #nullable disable
 
@@ -187,6 +188,11 @@ internal class EscapeHatches
         /// </summary>
         public readonly bool AlwaysDoImmutableFilesUpToDateCheck = Environment.GetEnvironmentVariable("MSBUILDDONOTCACHEMODIFICATIONTIME") == "1";
 
+        /// <summary>
+        /// When copying over an existing file, copy directly into the existing file rather than deleting and recreating.
+        /// </summary>
+        public readonly bool CopyWithoutDelete = Environment.GetEnvironmentVariable("MSBUILDCOPYWITHOUTDELETE") == "1";
+
         /// <summary>
         /// Emit events for project imports.
         /// </summary>
@@ -371,6 +377,50 @@ public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
             }
         }
 
+        /// <summary>
+        /// Allows displaying the deprecation warning for BinaryFormatter in your current environment.
+        /// </summary>
+        public bool EnableWarningOnCustomBuildEvent
+        {
+            get
+            {
+                var value = Environment.GetEnvironmentVariable("MSBUILDCUSTOMBUILDEVENTWARNING");
+
+                if (value == null)
+                {
+                    // If variable is not set explicitly, for .NETCORE warning appears.
+#if RUNTIME_TYPE_NETCORE
+                    return true;
+#else
+                    return false;
+#endif
+                }
+
+                return value == "1";
+            }
+        }
+
+        private bool? _isBinaryFormatterSerializationAllowed;
+        public bool IsBinaryFormatterSerializationAllowed
+        {
+            get
+            {
+                if (!_isBinaryFormatterSerializationAllowed.HasValue)
+                {
+#if RUNTIME_TYPE_NETCORE
+                    AppContext.TryGetSwitch("System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization",
+                        out bool enabled);
+                    _isBinaryFormatterSerializationAllowed = enabled;
+#else
+                    _isBinaryFormatterSerializationAllowed = true;
+#endif
+                }
+
+                return _isBinaryFormatterSerializationAllowed.Value;
+            }
+        }
+
+
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
             var value = Environment.GetEnvironmentVariable(environmentVariable);
@@ -469,27 +519,72 @@ public enum SdkReferencePropertyExpansionMode
         }
 
         /// <summary>
-        /// Emergency escape hatch. If a customer hits a bug in the shipped product causing an internal exception,
-        /// and fortuitously it happens that ignoring the VerifyThrow allows execution to continue in a reasonable way,
-        /// then we can give them this undocumented environment variable as an immediate workaround.
+        /// Throws InternalErrorException.
         /// </summary>
         /// <remarks>
-        /// Clone from ErrorUtilities which isn't (yet?) available in Framework.
+        /// Clone of ErrorUtilities.ThrowInternalError which isn't available in Framework.
         /// </remarks>
-        private static readonly bool s_throwExceptions = String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDONOTTHROWINTERNAL"));
+        internal static void ThrowInternalError(string message)
+        {
+            throw new InternalErrorException(message);
+        }
 
         /// <summary>
         /// Throws InternalErrorException.
+        /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
         /// <remarks>
-        /// Clone of ErrorUtilities.ThrowInternalError which isn't (yet?) available in Framework.
+        /// Clone from ErrorUtilities which isn't available in Framework.
         /// </remarks>
-        internal static void ThrowInternalError(string message)
+        internal static void ThrowInternalError(string message, params object[] args)
         {
-            if (s_throwExceptions)
+            throw new InternalErrorException(FormatString(message, args));
+        }
+
+        /// <summary>
+        /// Formats the given string using the variable arguments passed in.
+        /// 
+        /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
+        /// 
+        /// Thread safe.
+        /// </summary>
+        /// <param name="unformatted">The string to format.</param>
+        /// <param name="args">Optional arguments for formatting the given string.</param>
+        /// <returns>The formatted string.</returns>
+        /// <remarks>
+        /// Clone from ResourceUtilities which isn't available in Framework.
+        /// </remarks>
+        internal static string FormatString(string unformatted, params object[] args)
+        {
+            string formatted = unformatted;
+
+            // NOTE: String.Format() does not allow a null arguments array
+            if ((args?.Length > 0))
             {
-                throw new InternalErrorException(message);
+#if DEBUG
+                // If you accidentally pass some random type in that can't be converted to a string, 
+                // FormatResourceString calls ToString() which returns the full name of the type!
+                foreach (object param in args)
+                {
+                    // Check it has a real implementation of ToString() and the type is not actually System.String
+                    if (param != null)
+                    {
+                        if (string.Equals(param.GetType().ToString(), param.ToString(), StringComparison.Ordinal) &&
+                            param.GetType() != typeof(string))
+                        {
+                            ThrowInternalError("Invalid resource parameter type, was {0}",
+                                param.GetType().FullName);
+                        }
+                    }
+                }
+#endif
+                // Format the string, using the variable arguments passed in.
+                // NOTE: all String methods are thread-safe
+                formatted = String.Format(CultureInfo.CurrentCulture, unformatted, args);
             }
+
+            return formatted;
         }
     }
 }
diff --git a/src/Framework/UninitializedPropertyReadEventArgs.cs b/src/Framework/UninitializedPropertyReadEventArgs.cs
index ef638c5e101..781c8c33bc8 100644
--- a/src/Framework/UninitializedPropertyReadEventArgs.cs
+++ b/src/Framework/UninitializedPropertyReadEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -42,5 +44,18 @@ public UninitializedPropertyReadEventArgs(
         /// The name of the uninitialized property that was read.
         /// </summary>
         public string PropertyName { get; set; }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.WriteOptionalString(PropertyName);
+        }
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            PropertyName = reader.ReadOptionalString();
+        }
     }
 }
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 5ebb1fa8b8a..423de50897b 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -24,6 +24,7 @@
 
     <!-- Include NuGet build tasks -->
     <PackageReference Include="NuGet.Build.Tasks" />
+    <PackageReference Include="NuGet.Build.Tasks.Console" />
     <PackageReference Include="Microsoft.Build.NuGetSdkResolver" />
 
     <!-- As of 17.5, NuGet.Build.Tasks and Microsoft.Build.NuGetSdkResolver depends on Newtonsoft.Json version 13.0.1,
@@ -45,10 +46,10 @@
 
   <!-- Use deps file from this project with additional dependencies listed instead of the one generated in the MSBuild project -->
   <Target Name="UpdateMSBuildDepsFile" AfterTargets="Build" Condition="'$(MonoBuild)' != 'true' and ($([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp2.1')) or '$(TargetFramework)' == 'netstandard2.0')">
-    <Copy SourceFiles="$(OutputPath)$(AssemblyName).deps.json" DestinationFiles="$(OutputPath)MSBuild.deps.json" />
+    <Copy SourceFiles="$(OutputPath)$(AssemblyName).deps.json" DestinationFiles="$(OutputPath)MSBuild.deps.json" SkipUnchangedFiles="true" />
   </Target>
   <Target Name="UpdatePublishedMSBuildDepsFile" AfterTargets="Publish" Condition="'$(TargetFramework)' == '$(LatestDotNetCoreForMSBuild)'">
-    <Copy SourceFiles="$(PublishDir)$(AssemblyName).deps.json" DestinationFiles="$(PublishDir)MSBuild.deps.json" />
+    <Copy SourceFiles="$(PublishDir)$(AssemblyName).deps.json" DestinationFiles="$(PublishDir)MSBuild.deps.json" SkipUnchangedFiles="true" />
   </Target>
 
   <Import Project="..\Package\GetBinPaths.targets" Condition="$(TargetFramework.StartsWith('net4'))"/>
diff --git a/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets b/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets
new file mode 100644
index 00000000000..3571d7e37f5
--- /dev/null
+++ b/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets
@@ -0,0 +1,23 @@
+<Project>
+  <!-- The CoreCLR flavor of NuGet.Build.Tasks.Console.exe looks for dotnet under "..\..\dotnet", so we need to redirect it for the bootstrap to the currently executing dotnet.exe.
+       See: https://github.com/NuGet/NuGet.Client/blob/91f6fdb26b09e16c4520b1d13ee30bb38172a7bd/src/NuGet.Core/NuGet.Build.Tasks/StaticGraphRestoreTaskBase.cs#L240-L252 -->
+  <UsingTask
+    TaskName="GetCurrentProcessFileName"
+    TaskFactory="RoslynCodeTaskFactory"
+    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
+    <ParameterGroup>
+      <CurrentProcessFileName ParameterType="System.String" Output="true" />
+    </ParameterGroup>
+    <Task>
+      <Using Namespace="System.Diagnostics" />
+      <Code Type="Fragment" Language="cs"><![CDATA[
+      CurrentProcessFileName = Process.GetCurrentProcess().MainModule.FileName;
+      ]]></Code>
+    </Task>
+  </UsingTask>
+  <Target Name="RedirectNuGetConsoleProcess" BeforeTargets="Restore">
+    <GetCurrentProcessFileName>
+      <Output TaskParameter="CurrentProcessFileName" PropertyName="NuGetConsoleProcessFileName" />
+    </GetCurrentProcessFileName>
+  </Target>
+</Project>
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index ca52d2e3156..a3f744978d0 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
+using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -156,6 +157,31 @@ public void DistributedFileLoggerSwitchIdentificationTests(string distributedfil
             duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
+        [Theory]
+        [InlineData("ll")]
+        [InlineData("LL")]
+        [InlineData("livelogger")]
+        [InlineData("LiveLogger")]
+        [InlineData("LIVELOGGER")]
+        [InlineData("tl")]
+        [InlineData("TL")]
+        [InlineData("terminallogger")]
+        [InlineData("TerminalLogger")]
+        [InlineData("TERMINALLOGGER")]
+        public void TerminalLoggerSwitchIdentificationTests(string terminallogger)
+        {
+            CommandLineSwitches.ParameterizedSwitch parameterlessSwitch;
+            string duplicateSwitchErrorMessage;
+
+            CommandLineSwitches.IsParameterizedSwitch(terminallogger, out parameterlessSwitch, out duplicateSwitchErrorMessage, out bool multipleParametersAllowed, out string missingParametersErrorMessage, out bool unquoteParameters, out bool emptyParametersAllowed).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.TerminalLogger);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldBeNull();
+            unquoteParameters.ShouldBeTrue();
+            emptyParametersAllowed.ShouldBeTrue();
+        }
+
         [Theory]
         [InlineData("flp")]
         [InlineData("FLP")]
@@ -178,6 +204,28 @@ public void FileLoggerParametersIdentificationTests(string fileloggerparameters)
             unquoteParameters.ShouldBeTrue();
         }
 
+        [Theory]
+        [InlineData("tlp")]
+        [InlineData("TLP")]
+        [InlineData("terminalLoggerParameters")]
+        [InlineData("TERMINALLOGGERPARAMETERS")]
+        public void TerminalLoggerParametersIdentificationTests(string terminalLoggerParameters)
+        {
+            CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
+            string duplicateSwitchErrorMessage;
+            bool multipleParametersAllowed;
+            string missingParametersErrorMessage;
+            bool unquoteParameters;
+            bool emptyParametersAllowed;
+
+            CommandLineSwitches.IsParameterizedSwitch(terminalLoggerParameters, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.TerminalLoggerParameters);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeTrue();
+        }
+
 #if FEATURE_NODE_REUSE
         [Theory]
         [InlineData("nr")]
@@ -452,6 +500,60 @@ public void PreprocessSwitchIdentificationTests(string preprocess)
             unquoteParameters.ShouldBeTrue();
         }
 
+        [Fact]
+        public void GetPropertySwitchIdentificationTest()
+        {
+            CommandLineSwitches.IsParameterizedSwitch(
+                "getProperty",
+                out CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,
+                out string duplicateSwitchErrorMessage,
+                out bool multipleParametersAllowed,
+                out string missingParametersErrorMessage,
+                out _,
+                out _);
+
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GetProperty);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNullOrEmpty();
+        }
+
+        [Fact]
+        public void GetItemSwitchIdentificationTest()
+        {
+            CommandLineSwitches.IsParameterizedSwitch(
+                "getItem",
+                out CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,
+                out string duplicateSwitchErrorMessage,
+                out bool multipleParametersAllowed,
+                out string missingParametersErrorMessage,
+                out _,
+                out _);
+
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GetItem);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNullOrEmpty();
+        }
+
+        [Fact]
+        public void GetTargetResultSwitchIdentificationTest()
+        {
+            CommandLineSwitches.IsParameterizedSwitch(
+                "getTargetResult",
+                out CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,
+                out string duplicateSwitchErrorMessage,
+                out bool multipleParametersAllowed,
+                out string missingParametersErrorMessage,
+                out _,
+                out _);
+
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GetTargetResult);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNullOrEmpty();
+        }
+
         [Theory]
         [InlineData("targets")]
         [InlineData("tArGeTs")]
@@ -995,6 +1097,7 @@ public void InvalidToolsVersionErrors()
                     filename = FileUtilities.GetTemporaryFileName();
                     ProjectRootElement project = ProjectRootElement.Create();
                     project.Save(filename);
+                    BuildResult buildResult = null;
                     MSBuildApp.BuildProject(
                                         filename,
                                         null,
@@ -1023,8 +1126,14 @@ public void InvalidToolsVersionErrors()
                                         isolateProjects: ProjectIsolationMode.False,
                                         graphBuildOptions: null,
                                         lowPriority: false,
+                                        question: false,
                                         inputResultsCaches: null,
                                         outputResultsCache: null,
+                                        saveProjectResult: false,
+                                        ref buildResult,
+#if FEATURE_REPORTFILEACCESSES
+                                        reportFileAccesses: false,
+#endif
                                         commandLine: null);
                 }
                 finally
@@ -1343,6 +1452,26 @@ public void ProcessGraphBuildSwitch(string[] parameters, GraphBuildOptions expec
             }
         }
 
+        /// <summary>
+        /// Verifies that the /target switch is parsed properly with invalid characters.
+        /// </summary>
+        [Fact]
+        public void ProcessInvalidTargetSwitch()
+        {
+            string projectContent = """
+                <Project>
+                </Project>
+                """;
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            string project = testEnvironment.CreateTestProjectWithFiles("project.proj", projectContent).ProjectFile;
+
+#if FEATURE_GET_COMMANDLINE
+            MSBuildApp.Execute(@"msbuild.exe " + project + " /t:foo.bar").ShouldBe(MSBuildApp.ExitType.SwitchError);
+#else
+            MSBuildApp.Execute(new[] { @"msbuild.exe", project, "/t:foo.bar" }).ShouldBe(MSBuildApp.ExitType.SwitchError);
+#endif
+        }
+
         /// <summary>
         /// Verifies that when the /profileevaluation switch is used with invalid filenames an error is shown.
         /// </summary>
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index a7ea9759b10..1f0489284ab 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -71,10 +71,12 @@ public class MSBuildServer_Tests : IDisposable
         <Message Text=""Server ID is $(PID)"" Importance=""High"" />
     </Target>
 </Project>";
-        private static string sleepingTaskContents = @$"
+        private static string sleepingTaskContentsFormat = @$"
 <Project>
 <UsingTask TaskName=""SleepingTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
     <Target Name='Sleep'>
+        <!-- create a marker file that represents the build is started. -->
+        <WriteLinesToFile File=""{{0}}"" />
         <SleepingTask SleepTime=""100000"" />
     </Target>
 </Project>";
@@ -106,22 +108,23 @@ public void MSBuildServerTest()
             pidOfServerProcess.ShouldBe(ParseNumber(output, "Server ID is "), "Node used by both the first and second build should be the same.");
 
             // Prep to kill the long-lived task we're about to start.
-            Task t = Task.Run(() =>
+            TransientTestFile markerFile = _env.ExpectFile();
+            string? dir = Path.GetDirectoryName(markerFile.Path);
+            using var watcher = new System.IO.FileSystemWatcher(dir!);
+            watcher.Created += (o, e) =>
             {
-                // Wait for the long-lived task to start
-                // If this test seems to fail randomly, increase this time.
-                Thread.Sleep(1000);
-
+                _output.WriteLine($"The marker file {markerFile.Path} was created. The build task has been started. Ready to kill the server.");
                 // Kill the server
                 Process.GetProcessById(pidOfServerProcess).KillTree(1000);
-            });
+                _output.WriteLine($"The old server was killed.");
+            };
+            watcher.Filter = Path.GetFileName(markerFile.Path);
+            watcher.EnableRaisingEvents = true;
 
             // Start long-lived task execution
-            TransientTestFile sleepProject = _env.CreateFile("napProject.proj", sleepingTaskContents);
+            TransientTestFile sleepProject = _env.CreateFile("napProject.proj", string.Format(sleepingTaskContentsFormat, markerFile.Path));
             RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, sleepProject.Path, out _);
 
-            t.Wait();
-
             // Ensure that a new build can still succeed and that its server node is different.
             output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out success, false, _output);
 
@@ -176,7 +179,9 @@ public void BuildsWhileBuildIsRunningOnServer()
         {
             _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
             TransientTestFile project = _env.CreateFile("testProject.proj", printPidContents);
-            TransientTestFile sleepProject = _env.CreateFile("napProject.proj", sleepingTaskContents);
+
+            TransientTestFile markerFile = _env.ExpectFile();
+            TransientTestFile sleepProject = _env.CreateFile("napProject.proj", string.Format(sleepingTaskContentsFormat, markerFile.Path));
 
             int pidOfServerProcess;
             Task t;
@@ -185,13 +190,25 @@ public void BuildsWhileBuildIsRunningOnServer()
             pidOfServerProcess = ParseNumber(output, "Server ID is ");
             _env.WithTransientProcess(pidOfServerProcess);
 
+            string? dir = Path.GetDirectoryName(markerFile.Path);
+            using var watcher = new System.IO.FileSystemWatcher(dir!);
+            ManualResetEvent mre = new ManualResetEvent(false);
+            watcher.Created += (o, e) =>
+            {
+                _output.WriteLine($"The marker file {markerFile.Path} was created. The build task has been started.");
+                mre.Set();
+            };
+            watcher.Filter = Path.GetFileName(markerFile.Path);
+            watcher.EnableRaisingEvents = true;
             t = Task.Run(() =>
             {
                 RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, sleepProject.Path, out _, false, _output);
             });
 
             // The server will soon be in use; make sure we don't try to use it before that happens.
-            Thread.Sleep(1000);
+            _output.WriteLine("Waiting for the server to be in use.");
+            mre.WaitOne();
+            _output.WriteLine("It's OK to go ahead.");
 
             Environment.SetEnvironmentVariable("MSBUILDUSESERVER", "0");
 
@@ -221,10 +238,6 @@ public void CanShutdownServerProcess(bool byBuildManager)
         {
             _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
 
-            // This test seems to be flaky, lets enable better logging to investigate it next time
-            // TODO: delete after investigated its flakiness
-            _env.WithTransientDebugEngineForNewProcesses(true);
-
             TransientTestFile project = _env.CreateFile("testProject.proj", printPidContents);
 
             // Start a server node and find its PID.
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index 61f2c68c312..abb5f36de05 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -9,6 +9,7 @@
   <ItemGroup>
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
+    <PackageReference Include="Verify.Xunit" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
new file mode 100644
index 00000000000..0777ef5cc91
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
@@ -0,0 +1,5 @@
+Ôªø]9;4;3;\[?25l[1F
+  project [36;1mtfName[m Build (0.0s)
+[?25h[?25l[2F
+  project [36;1mtf2[m Build (0.0s)[K
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
new file mode 100644
index 00000000000..d860724e3ab
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
@@ -0,0 +1,5 @@
+Ôªø[?25l[1F
+  project [36;1mtfName[m Build (0.0s)
+[?25h[?25l[2F
+  project [36;1mtf2[m Build (0.0s)[K
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
new file mode 100644
index 00000000000..0777ef5cc91
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
@@ -0,0 +1,5 @@
+Ôªø]9;4;3;\[?25l[1F
+  project [36;1mtfName[m Build (0.0s)
+[?25h[?25l[2F
+  project [36;1mtf2[m Build (0.0s)[K
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
new file mode 100644
index 00000000000..d0cb5b914e0
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
@@ -0,0 +1,3 @@
+Ôªø]9;4;3;\[?25l[1F
+  project Build (0.0s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
new file mode 100644
index 00000000000..edce93c06c4
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
@@ -0,0 +1,3 @@
+Ôªø[?25l[1F
+  project Build (0.0s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
new file mode 100644
index 00000000000..d0cb5b914e0
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
@@ -0,0 +1,3 @@
+Ôªø]9;4;3;\[?25l[1F
+  project Build (0.0s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
new file mode 100644
index 00000000000..e397b179c6b
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
@@ -0,0 +1,4 @@
+Ôªø]9;4;3;\[?25l[1F
+[?25h
+Build [31;1mfailed[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
new file mode 100644
index 00000000000..5dac0df45b6
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
@@ -0,0 +1,3 @@
+Ôªø[?25l[1F
+[?25h
+Build [31;1mfailed[m in 0.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
new file mode 100644
index 00000000000..e397b179c6b
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
@@ -0,0 +1,4 @@
+Ôªø]9;4;3;\[?25l[1F
+[?25h
+Build [31;1mfailed[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
new file mode 100644
index 00000000000..0041a7257fe
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
@@ -0,0 +1,6 @@
+Ôªø]9;4;3;\  project [31;1mfailed with errors[m (0.0s)
+    directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
+[?25l[1F
+[?25h
+Build [31;1mfailed with errors[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
new file mode 100644
index 00000000000..cf0d8f1d6c9
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
@@ -0,0 +1,5 @@
+Ôªø  project [31;1mfailed with errors[m (0.0s)
+    directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
+[?25l[1F
+[?25h
+Build [31;1mfailed with errors[m in 0.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
new file mode 100644
index 00000000000..0041a7257fe
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
@@ -0,0 +1,6 @@
+Ôªø]9;4;3;\  project [31;1mfailed with errors[m (0.0s)
+    directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
+[?25l[1F
+[?25h
+Build [31;1mfailed with errors[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
new file mode 100644
index 00000000000..86c02fdb8df
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
@@ -0,0 +1,6 @@
+Ôªø]9;4;3;\  project [33;1msucceeded with warnings[m (0.0s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+[?25l[1F
+[?25h
+Build [33;1msucceeded with warnings[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
new file mode 100644
index 00000000000..43510237153
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
@@ -0,0 +1,5 @@
+Ôªø  project [33;1msucceeded with warnings[m (0.0s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+[?25l[1F
+[?25h
+Build [33;1msucceeded with warnings[m in 0.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
new file mode 100644
index 00000000000..86c02fdb8df
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
@@ -0,0 +1,6 @@
+Ôªø]9;4;3;\  project [33;1msucceeded with warnings[m (0.0s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+[?25l[1F
+[?25h
+Build [33;1msucceeded with warnings[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
new file mode 100644
index 00000000000..e6169b4e163
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
@@ -0,0 +1,4 @@
+Ôªø]9;4;3;\[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
new file mode 100644
index 00000000000..de2ebf4c55e
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
@@ -0,0 +1,3 @@
+Ôªø[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 0.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
new file mode 100644
index 00000000000..e6169b4e163
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
@@ -0,0 +1,4 @@
+Ôªø]9;4;3;\[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
new file mode 100644
index 00000000000..ed9f0458fba
--- /dev/null
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -0,0 +1,355 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Globalization;
+using System.IO;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Logging;
+using Microsoft.Build.Logging.TerminalLogger;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using VerifyTests;
+using VerifyXunit;
+using Xunit;
+using static VerifyXunit.Verifier;
+
+namespace Microsoft.Build.UnitTests
+{
+    [UsesVerify]
+    public class TerminalLogger_Tests : IEventSource, IDisposable
+    {
+        private const int _nodeCount = 8;
+        private const string _eventSender = "Test";
+        private readonly string _projectFile = NativeMethods.IsUnixLike ? "/src/project.proj" : @"C:\src\project.proj";
+
+        private StringWriter _outputWriter = new();
+
+        private readonly Terminal _mockTerminal;
+        private readonly TerminalLogger _terminallogger;
+
+        private readonly DateTime _buildStartTime = new DateTime(2023, 3, 30, 16, 30, 0);
+        private readonly DateTime _buildFinishTime = new DateTime(2023, 3, 30, 16, 30, 5);
+
+        private VerifySettings _settings = new();
+
+        private static Regex s_elapsedTime = new($@"\d+{Regex.Escape(CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator)}\ds", RegexOptions.Compiled);
+
+        public TerminalLogger_Tests()
+        {
+            _mockTerminal = new Terminal(_outputWriter);
+            _terminallogger = new TerminalLogger(_mockTerminal);
+
+            _terminallogger.Initialize(this, _nodeCount);
+
+            UseProjectRelativeDirectory("Snapshots");
+
+            // Scrub timestamps on intermediate execution lines,
+            // which are subject to the vagaries of the test machine
+            // and OS scheduler.
+            _settings.AddScrubber(static lineBuilder =>
+            {
+                string line = lineBuilder.ToString();
+                lineBuilder.Clear();
+                lineBuilder.Append(s_elapsedTime.Replace(line, "0.0s"));
+            });
+        }
+
+        #region IEventSource implementation
+
+#pragma warning disable CS0067
+        public event BuildMessageEventHandler? MessageRaised;
+
+        public event BuildErrorEventHandler? ErrorRaised;
+
+        public event BuildWarningEventHandler? WarningRaised;
+
+        public event BuildStartedEventHandler? BuildStarted;
+
+        public event BuildFinishedEventHandler? BuildFinished;
+
+        public event ProjectStartedEventHandler? ProjectStarted;
+
+        public event ProjectFinishedEventHandler? ProjectFinished;
+
+        public event TargetStartedEventHandler? TargetStarted;
+
+        public event TargetFinishedEventHandler? TargetFinished;
+
+        public event TaskStartedEventHandler? TaskStarted;
+
+        public event TaskFinishedEventHandler? TaskFinished;
+
+        public event CustomBuildEventHandler? CustomEventRaised;
+
+        public event BuildStatusEventHandler? StatusEventRaised;
+
+        public event AnyEventHandler? AnyEventRaised;
+#pragma warning restore CS0067
+
+        #endregion
+
+        #region IDisposable implementation
+
+        public void Dispose()
+        {
+            _terminallogger.Shutdown();
+        }
+
+        #endregion
+
+        #region Event args helpers
+
+        private BuildEventContext MakeBuildEventContext()
+        {
+            return new BuildEventContext(1, 1, 1, 1);
+        }
+
+        private BuildStartedEventArgs MakeBuildStartedEventArgs()
+        {
+            return new BuildStartedEventArgs(null, null, _buildStartTime);
+        }
+
+        private BuildFinishedEventArgs MakeBuildFinishedEventArgs(bool succeeded)
+        {
+            return new BuildFinishedEventArgs(null, null, succeeded, _buildFinishTime);
+        }
+
+        private ProjectStartedEventArgs MakeProjectStartedEventArgs(string projectFile, string targetNames = "Build")
+        {
+            return new ProjectStartedEventArgs("", "", projectFile, targetNames, new Dictionary<string, string>(), new List<DictionaryEntry>())
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private ProjectFinishedEventArgs MakeProjectFinishedEventArgs(string projectFile, bool succeeded)
+        {
+            return new ProjectFinishedEventArgs(null, null, projectFile, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TargetStartedEventArgs MakeTargetStartedEventArgs(string projectFile, string targetName)
+        {
+            return new TargetStartedEventArgs("", "", targetName, projectFile, targetFile: projectFile)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TargetFinishedEventArgs MakeTargetFinishedEventArgs(string projectFile, string targetName, bool succeeded)
+        {
+            return new TargetFinishedEventArgs("", "", targetName, projectFile, targetFile: projectFile, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TaskStartedEventArgs MakeTaskStartedEventArgs(string projectFile, string taskName)
+        {
+            return new TaskStartedEventArgs("", "", projectFile, taskFile: projectFile, taskName)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TaskFinishedEventArgs MakeTaskFinishedEventArgs(string projectFile, string taskName, bool succeeded)
+        {
+            return new TaskFinishedEventArgs("", "", projectFile, taskFile: projectFile, taskName, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private BuildWarningEventArgs MakeWarningEventArgs(string warning)
+        {
+            return new BuildWarningEventArgs("", "AA0000", "directory/file", 1, 2, 3, 4, warning, null, null)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private BuildErrorEventArgs MakeErrorEventArgs(string error)
+        {
+            return new BuildErrorEventArgs("", "AA0000", "directory/file", 1, 2, 3, 4, error, null, null)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        #endregion
+
+        #region Build summary tests
+
+        private void InvokeLoggerCallbacksForSimpleProject(bool succeeded, Action additionalCallbacks)
+        {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+            ProjectStarted?.Invoke(_eventSender, MakeProjectStartedEventArgs(_projectFile));
+
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
+            TaskStarted?.Invoke(_eventSender, MakeTaskStartedEventArgs(_projectFile, "Task"));
+
+            additionalCallbacks();
+
+            Thread.Sleep(1_000);
+
+            TaskFinished?.Invoke(_eventSender, MakeTaskFinishedEventArgs(_projectFile, "Task", succeeded));
+            TargetFinished?.Invoke(_eventSender, MakeTargetFinishedEventArgs(_projectFile, "Build", succeeded));
+
+            ProjectFinished?.Invoke(_eventSender, MakeProjectFinishedEventArgs(_projectFile, succeeded));
+            BuildFinished?.Invoke(_eventSender, MakeBuildFinishedEventArgs(succeeded));
+        }
+
+        [Fact]
+        public Task PrintsBuildSummary_Succeeded()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () => { });
+
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
+        [Fact]
+        public Task PrintBuildSummary_SucceededWithWarnings()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
+            {
+                WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Warning!"));
+            });
+
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
+        [Fact]
+        public Task PrintBuildSummary_Failed()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () => { });
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
+        [Fact]
+        public Task PrintBuildSummary_FailedWithErrors()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
+            {
+                ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
+            });
+
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
+        #endregion
+
+        [Fact]
+        public void DisplayNodesShowsCurrent()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, async () =>
+            {
+                _terminallogger.DisplayNodes();
+
+                await Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+            });
+        }
+
+        [Fact]
+        public async Task DisplayNodesOverwritesWithNewTargetFramework()
+        {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+
+            ProjectStartedEventArgs pse = MakeProjectStartedEventArgs(_projectFile, "Build");
+            pse.GlobalProperties = new Dictionary<string, string>() { ["TargetFramework"] = "tfName" };
+
+            ProjectStarted?.Invoke(_eventSender, pse);
+
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
+            TaskStarted?.Invoke(_eventSender, MakeTaskStartedEventArgs(_projectFile, "Task"));
+
+            _terminallogger.DisplayNodes();
+
+            // This is a bit fast and loose with the events that would be fired
+            // in a real "stop building that TF for the project and start building
+            // a new TF of the same project" situation, but it's enough now.
+            ProjectStartedEventArgs pse2 = MakeProjectStartedEventArgs(_projectFile, "Build");
+            pse2.GlobalProperties = new Dictionary<string, string>() { ["TargetFramework"] = "tf2" };
+
+            ProjectStarted?.Invoke(_eventSender, pse2);
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
+
+            _terminallogger.DisplayNodes();
+
+            await Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
+        [Fact]
+        public void TestTerminalLoggerTogetherWithOtherLoggers()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            { 
+                string contents = @"
+<Project>
+    <ItemGroup>
+        <Compile Include=""MyItem1.cs"" />
+        <Compile Include=""MyItem2.cs"" />
+    </ItemGroup>
+    <PropertyGroup>
+        <MyProp1>MyProperty1</MyProp1>
+    </PropertyGroup>
+    <Target Name = ""Build"">
+        <Message Text = ""Build target is executing."" Importance = ""High"" />
+    </Target>
+</Project>";
+                TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
+                TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
+
+                BinaryLogger loggerWithTL = new();
+                string logFileWithTL = env.ExpectFile(".binlog").Path;
+                loggerWithTL.Parameters = logFileWithTL;
+
+                BinaryLogger loggerWithoutTL = new();
+                string logFileWithoutTL = env.ExpectFile(".binlog").Path;
+                loggerWithoutTL.Parameters = logFileWithoutTL;
+
+                // Execute MSBuild with binary, file and terminal loggers
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} /m /bl:{logFileWithTL} -flp:logfile={Path.Combine(logFolder.Path, "logFileWithTL.log")};verbosity=diagnostic -tl:on", out bool success);
+                success.ShouldBeTrue();
+
+                // Execute MSBuild with binary and file loggers
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} /m /bl:{logFileWithoutTL} -flp:logfile={Path.Combine(logFolder.Path, "logFileWithoutTL.log")};verbosity=diagnostic", out success);
+                success.ShouldBeTrue();
+
+                // Read the binary log and replay into mockLogger
+                var mockLogFromPlaybackWithTL = new MockLogger();
+                var binaryLogReaderWithTL = new BinaryLogReplayEventSource();
+                mockLogFromPlaybackWithTL.Initialize(binaryLogReaderWithTL);
+
+                var mockLogFromPlaybackWithoutTL = new MockLogger();
+                var binaryLogReaderWithoutTL = new BinaryLogReplayEventSource();
+                mockLogFromPlaybackWithoutTL.Initialize(binaryLogReaderWithoutTL);
+
+                binaryLogReaderWithTL.Replay(logFileWithTL);
+                binaryLogReaderWithoutTL.Replay(logFileWithoutTL);
+
+                // Check that amount of events, warnings, errors is equal in both cases. Presence of other loggers should not change behavior
+                mockLogFromPlaybackWithoutTL.Errors.Count.ShouldBe(mockLogFromPlaybackWithTL.Errors.Count);
+                mockLogFromPlaybackWithoutTL.Warnings.Count.ShouldBe(mockLogFromPlaybackWithTL.Warnings.Count);
+                mockLogFromPlaybackWithoutTL.AllBuildEvents.Count.ShouldBe(mockLogFromPlaybackWithTL.AllBuildEvents.Count);
+
+                // Check presence of some items and properties and that they have at least 1 item and property
+                mockLogFromPlaybackWithoutTL.EvaluationFinishedEvents.ShouldContain(x => (x.Items != null) && x.Items.GetEnumerator().MoveNext());
+                mockLogFromPlaybackWithTL.EvaluationFinishedEvents.ShouldContain(x => (x.Items != null) && x.Items.GetEnumerator().MoveNext());
+
+                mockLogFromPlaybackWithoutTL.EvaluationFinishedEvents.ShouldContain(x => (x.Properties != null) && x.Properties.GetEnumerator().MoveNext());
+                mockLogFromPlaybackWithTL.EvaluationFinishedEvents.ShouldContain(x => (x.Properties != null) && x.Properties.GetEnumerator().MoveNext());
+            }
+        }
+    }
+}
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index c6029b73765..d9654d4e38c 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -9,6 +9,7 @@
 using System.IO.Compression;
 using System.Linq;
 using System.Reflection;
+using System.Runtime.InteropServices;
 using System.Threading;
 using Microsoft.Build.CommandLine;
 using Microsoft.Build.Framework;
@@ -565,6 +566,7 @@ public void InvalidVerbosity()
                 MSBuildApp.ProcessVerbositySwitch("loquacious");
             });
         }
+
         [Fact]
         public void ValidMaxCPUCountSwitch()
         {
@@ -616,6 +618,78 @@ public void InvalidMaxCPUCountSwitch4()
             });
         }
 
+        [Theory]
+        [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, true)]
+        [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, true)]
+        [InlineData("-getItem:MyItem", false, "", true, false, false, true)]
+        [InlineData("-getItem:MyItem -t:Build", false, "", true, true, false, true)]
+        [InlineData("-getItem:WrongItem -t:Build", false, "", false, false, false, true)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem -t:Build", true, "TargetValue", true, true, false, true)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem", true, "EvalValue", true, false, false, true)]
+        [InlineData("-getProperty:Foo;Bar -getTargetResult:MyTarget", true, "TargetValue", false, false, true, true)]
+        [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, false)]
+        [InlineData("-getItem:MyItem", false, "", true, false, false, false)]
+        [InlineData("-getItem:MyItem -t:Build", false, "", true, true, false, false)]
+        [InlineData("-getItem:WrongItem -t:Build", false, "", false, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem -t:Build", true, "TargetValue", true, true, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem", true, "EvalValue", true, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getTargetResult:MyTarget", true, "TargetValue", false, false, true, false)]
+        public void ExecuteAppWithGetPropertyItemAndTargetResult(
+            string extraSwitch,
+            bool fooPresent,
+            string fooResult,
+            bool itemIncludesAlwaysThere,
+            bool itemIncludesTargetItem,
+            bool targetResultPresent,
+            bool isGraphBuild)
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile project = env.CreateFile("testProject.csproj", @"
+<Project>
+
+  <PropertyGroup>
+    <Foo>EvalValue</Foo>
+    <Baz>InnocuousValue</Baz>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <MyItem Include=""itemAlwaysThere"" Metadatum=""metadatumValue"" />
+  </ItemGroup>
+
+  <Target Name=""MyTarget"" BeforeTargets=""Build"">
+    <PropertyGroup>
+      <Foo>TargetValue</Foo>
+    </PropertyGroup>
+    <ItemGroup>
+      <MyItem Include=""targetItem"" Metadato=""OtherMetadatum"" />
+    </ItemGroup>
+  </Target>
+
+  <Target Name=""Build"">
+
+  </Target>
+
+</Project>
+");
+            string graph = isGraphBuild ? "--graph" : "";
+            string results = RunnerUtilities.ExecMSBuild($" {project.Path} {extraSwitch} {graph}", out bool success);
+            success.ShouldBeTrue();
+            if (fooPresent)
+            {
+                results.ShouldContain($"\"Foo\": \"{fooResult}\"");
+                results.ShouldContain("\"Bar\": \"\"");
+            }
+
+            results.ShouldNotContain("InnocuousValue");
+
+            results.Contains("itemAlwaysThere").ShouldBe(itemIncludesAlwaysThere);
+            results.Contains("targetItem").ShouldBe(itemIncludesTargetItem);
+
+            results.Contains("MyTarget").ShouldBe(targetResultPresent);
+            results.Contains("\"Result\": \"Success\"").ShouldBe(targetResultPresent);
+        }
+
         /// <summary>
         /// Regression test for bug where the MSBuild.exe command-line app
         /// would sometimes set the UI culture to just "en" which is considered a "neutral" UI
@@ -642,6 +716,84 @@ public void SetConsoleUICulture()
             thisThread.CurrentUICulture = originalUICulture;
         }
 
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && !EncodingUtilities.CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding())
+            {
+                return; // The feature to detect .NET SDK Languages is not enabled on this machine, so don't test it.
+            }
+
+            const string DOTNET_CLI_UI_LANGUAGE = nameof(DOTNET_CLI_UI_LANGUAGE);
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            // Save the current environment info so it can be restored.
+            var originalUILanguage = Environment.GetEnvironmentVariable(DOTNET_CLI_UI_LANGUAGE);
+
+            var originalOutputEncoding = Console.OutputEncoding;
+            var originalInputEncoding = Console.InputEncoding;
+            Thread thisThread = Thread.CurrentThread;
+            CultureInfo originalUICulture = thisThread.CurrentUICulture;
+
+            try
+            {
+                // Set the UI language based on the SDK environment var.
+                testEnvironment.SetEnvironmentVariable(DOTNET_CLI_UI_LANGUAGE, "ja"); // Japanese chose arbitrarily.
+                ChangeWaves.ResetStateForTests();
+                if (!enableFeature)
+                {
+                    testEnvironment.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_8.ToString());
+                }
+                MSBuildApp.SetConsoleUI();
+
+                Assert.Equal(enableFeature ? new CultureInfo("ja") : CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture(), thisThread.CurrentUICulture);
+                if (enableFeature)
+                {
+                    Assert.Equal(65001, Console.OutputEncoding.CodePage); // UTF-8 enabled for correct rendering.
+                }
+            }
+            finally
+            {
+                // Restore the current UI culture back to the way it was at the beginning of this unit test.
+                thisThread.CurrentUICulture = originalUICulture;
+                // Restore for full framework
+                CultureInfo.CurrentCulture = originalUICulture;
+                CultureInfo.DefaultThreadCurrentUICulture = originalUICulture;
+
+                // MSBuild should also restore the encoding upon exit, but we don't create that context here.
+                Console.OutputEncoding = originalOutputEncoding;
+                Console.InputEncoding = originalInputEncoding;
+
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+        }
+
+        /// <summary>
+        /// We shouldn't change the UI culture if the current UI culture is invariant.
+        /// In other cases, we can get an exception on CultureInfo creation when System.Globalization.Invariant enabled.
+        /// </summary>
+
+        [Fact]
+        public void SetConsoleUICultureInInvariantCulture()
+        {
+            Thread thisThread = Thread.CurrentThread;
+
+            // Save the current UI culture, so we can restore it at the end of this unit test.
+            CultureInfo originalUICulture = thisThread.CurrentUICulture;
+
+            thisThread.CurrentUICulture = CultureInfo.InvariantCulture;
+            MSBuildApp.SetConsoleUI();
+
+            // Make sure we don't change culture.
+            thisThread.CurrentUICulture.ShouldBe(CultureInfo.InvariantCulture);
+
+            // Restore the current UI culture back to the way it was at the beginning of this unit test.
+            thisThread.CurrentUICulture = originalUICulture;
+        }
+
+
 #if FEATURE_SYSTEM_CONFIGURATION
         /// <summary>
         /// Invalid configuration file should not dump stack.
@@ -798,6 +950,10 @@ public void TestEnvironmentTest()
         [Fact]
         public void MSBuildEngineLogger()
         {
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            testEnvironment.SetEnvironmentVariable("DOTNET_CLI_UI_LANGUAGE", "en"); // build machines may have other values.
+            CultureInfo.CurrentUICulture = new CultureInfo("en"); // Validate that the thread will produce an english log regardless of the machine OS language
+
             string oldValueForMSBuildLoadMicrosoftTargetsReadOnly = Environment.GetEnvironmentVariable("MSBuildLoadMicrosoftTargetsReadOnly");
             string projectString =
                    "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
@@ -834,6 +990,8 @@ public void MSBuildEngineLogger()
 
                 var logFileContents = File.ReadAllText(logFile);
 
+                Assert.Equal(new CultureInfo("en"), Thread.CurrentThread.CurrentUICulture);
+
                 logFileContents.ShouldContain("Process = ");
                 logFileContents.ShouldContain("MSBuild executable path = ");
                 logFileContents.ShouldContain("Command line arguments = ");
diff --git a/src/MSBuild/AutomaticEncodingRestorer.cs b/src/MSBuild/AutomaticEncodingRestorer.cs
new file mode 100644
index 00000000000..b5696d62ab8
--- /dev/null
+++ b/src/MSBuild/AutomaticEncodingRestorer.cs
@@ -0,0 +1,68 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Security;
+using System.Text;
+
+namespace Microsoft.Build.CommandLine
+{
+    /// <summary>
+    /// Ported from https://github.com/dotnet/sdk/blob/bcea1face15458814b8e53e8785b52ba464f6538/src/Cli/dotnet/AutomaticEncodingRestorer.cs.
+    /// A program can change the encoding of the console which would affect other programs.
+    /// We would prefer to have a pattern where the program does not affect encoding of other programs.
+    /// Create this class in a function akin to Main and let it manage the console encoding resources to return it to the state before execution upon destruction.
+    /// </summary>
+    public class AutomaticEncodingRestorer : IDisposable
+    {
+        private Encoding? _originalOutputEncoding = null;
+        private Encoding? _originalInputEncoding = null;
+
+        public AutomaticEncodingRestorer()
+        {
+            try
+            {
+#if NET7_0_OR_GREATER
+                if (OperatingSystem.IsIOS() || OperatingSystem.IsAndroid() || OperatingSystem.IsTvOS()) // Output + Input Encoding are unavailable on these platforms per docs, and they're only available past net 5.
+                {
+                    return;
+                }
+#endif
+                _originalOutputEncoding = Console.OutputEncoding;
+
+#if NET7_0_OR_GREATER
+                if (OperatingSystem.IsBrowser()) // Input Encoding is also unavailable in this platform. (No concern for net472 as browser is unavailable.)
+                {
+                    return;
+                }
+#endif
+                _originalInputEncoding = Console.InputEncoding;
+            }
+            catch (Exception ex) when (ex is IOException || ex is SecurityException)
+            {
+                // The encoding is unavailable. Do nothing.
+            }
+        }
+
+        public void Dispose()
+        {
+            try
+            {
+                if (_originalOutputEncoding != null)
+                {
+                    Console.OutputEncoding = _originalOutputEncoding;
+                }
+                if (_originalInputEncoding != null)
+                {
+                    Console.InputEncoding = _originalInputEncoding;
+                }
+            }
+            catch (Exception ex) when (ex is IOException || ex is SecurityException)
+            {
+                // The encoding is unavailable. Do nothing.
+            }
+        }
+    }
+}
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index 50cca72257a..364fce6da5d 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -46,6 +46,9 @@ private CommandLineSwitchException(
         /// <summary>
         /// Serialization constructor
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private CommandLineSwitchException(
             SerializationInfo info,
             StreamingContext context) :
@@ -94,6 +97,9 @@ internal string CommandLineArg
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 9a7d968a673..847da8ba276 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -1,4 +1,4 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -47,7 +47,6 @@ internal enum ParameterlessSwitch
             FileLogger8,
             FileLogger9,
             DistributedFileLogger,
-            LiveLogger,
 #if DEBUG
             WaitForDebugger,
 #endif
@@ -90,6 +89,8 @@ internal enum ParameterizedSwitch
             FileLoggerParameters7,
             FileLoggerParameters8,
             FileLoggerParameters9,
+            TerminalLogger,
+            TerminalLoggerParameters,
             NodeReuse,
             Preprocess,
             Targets,
@@ -105,8 +106,15 @@ internal enum ParameterizedSwitch
             GraphBuild,
             InputResultsCaches,
             OutputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+            ReportFileAccesses,
+#endif
             LowPriority,
+            Question,
             DetailedSummary,
+            GetProperty,
+            GetItem,
+            GetTargetResult,
             NumberOfParameterizedSwitches,
         }
 
@@ -150,12 +158,15 @@ private struct ParameterizedSwitchInfo
             /// <summary>
             /// Initializes struct data.
             /// </summary>
-            /// <param name="switchNames"></param>
-            /// <param name="parameterizedSwitch"></param>
-            /// <param name="duplicateSwitchErrorMessage"></param>
-            /// <param name="multipleParametersAllowed"></param>
-            /// <param name="missingParametersErrorMessage"></param>
-            /// <param name="unquoteParameters"></param>
+            /// <param name="switchNames">Names of the switch (without leading switch indicator).</param>
+            /// <param name="parameterizedSwitch">The switch id.</param>
+            /// <param name="duplicateSwitchErrorMessage">If <see langword="null"/>, indicates that switch is allowed to appear multiple times on the command line; otherwise, holds the error message to display if switch appears more than once</param>
+            /// <param name="multipleParametersAllowed">Indicates if switch can take multiple parameters (equivalent to switch appearing multiple times on command line)
+            /// NOTE: for most switches, if a switch is allowed to appear multiple times on the command line, then multiple
+            /// parameters can be provided per switch; however, some switches cannot take multiple parameters.</param>
+            /// <param name="missingParametersErrorMessage">If <see langword="null"/>, indicates that switch is allowed to have no parameters; otherwise, holds the error message to show if switch is found without parameters on the command line</param>
+            /// <param name="unquoteParameters">Indicates if quotes should be removed from the switch parameters</param>
+            /// <param name="emptyParametersAllowed">Indicates if empty parameters are allowed and if so an empty string will be added to the list of parameter values.</param>
             internal ParameterizedSwitchInfo(
                 string[] switchNames,
                 ParameterizedSwitch parameterizedSwitch,
@@ -174,23 +185,12 @@ internal ParameterizedSwitchInfo(
                 this.emptyParametersAllowed = emptyParametersAllowed;
             }
 
-            // names of the switch (without leading switch indicator)
             internal string[] switchNames;
-            // if null, indicates that switch is allowed to appear multiple times on the command line; otherwise, holds the error
-            // message to display if switch appears more than once
             internal string duplicateSwitchErrorMessage;
-            // indicates if switch can take multiple parameters (equivalent to switch appearing multiple times on command line)
-            // NOTE: for most switches, if a switch is allowed to appear multiple times on the command line, then multiple
-            // parameters can be provided per switch; however, some switches cannot take multiple parameters
             internal bool multipleParametersAllowed;
-            // if null, indicates that switch is allowed to have no parameters; otherwise, holds the error message to show if
-            // switch is found without parameters on the command line
             internal string missingParametersErrorMessage;
-            // indicates if quotes should be removed from the switch parameters
             internal bool unquoteParameters;
-            // the switch id
             internal ParameterizedSwitch parameterizedSwitch;
-            // indicates if empty parameters are allowed and if so an empty string will be added to the list of parameter values
             internal bool emptyParametersAllowed;
         }
 
@@ -217,7 +217,6 @@ internal ParameterizedSwitchInfo(
             new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },                     ParameterlessSwitch.FileLogger8,           null),
             new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },                     ParameterlessSwitch.FileLogger9,           null),
             new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },           ParameterlessSwitch.DistributedFileLogger, null),
-            new ParameterlessSwitchInfo(  new string[] { "livelogger", "ll", "fancylogger", "flg" }, ParameterlessSwitch.LiveLogger,            null),
 #if DEBUG
             new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },                 ParameterlessSwitch.WaitForDebugger,       null),
 #endif
@@ -254,6 +253,9 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters7", "flp7" },     ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters8", "flp8" },     ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters9", "flp9" },     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
+            // To not break existing use, keep supporting live logger switches
+            new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true),
+            new ParameterizedSwitchInfo(  new string[] { "terminalloggerparameters", "tlp" },   ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false),
             new ParameterizedSwitchInfo(  new string[] { "nodereuse", "nr" },                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false),
             new ParameterizedSwitchInfo(  new string[] { "preprocess", "pp" },                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "targets", "ts" },                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false),
@@ -269,8 +271,15 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true),
             new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true),
+#if FEATURE_REPORTFILEACCESSES
+            new ParameterizedSwitchInfo(  new string[] { "reportfileaccesses" },                ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false),
+#endif
             new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getProperty" },                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",             true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",             true,   false),
         };
 
         /// <summary>
diff --git a/src/MSBuild/InitializationException.cs b/src/MSBuild/InitializationException.cs
index ff5a5e21ade..fea748158ae 100644
--- a/src/MSBuild/InitializationException.cs
+++ b/src/MSBuild/InitializationException.cs
@@ -51,6 +51,9 @@ private InitializationException(
         /// <summary>
         /// Serialization constructor
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InitializationException(
             SerializationInfo info,
             StreamingContext context) :
@@ -87,6 +90,9 @@ public override string Message
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/MSBuild/JsonOutputFormatter.cs b/src/MSBuild/JsonOutputFormatter.cs
new file mode 100644
index 00000000000..095f0761386
--- /dev/null
+++ b/src/MSBuild/JsonOutputFormatter.cs
@@ -0,0 +1,163 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Text.Json;
+using System.Text.Json.Nodes;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.CommandLine
+{
+    /// <summary>
+    /// This class is intended to take in names of properties, items, and/or target results and some means of computing
+    /// those data, then format them in a json object and provide a convenient means to stringify them.
+    /// </summary>
+    internal sealed class JsonOutputFormatter
+    {
+        private static readonly JsonSerializerOptions s_options = new() { AllowTrailingCommas = false, WriteIndented = true };
+        private readonly JsonNode _topLevelNode = new JsonObject();
+
+        public override string ToString()
+        {
+            return _topLevelNode.ToJsonString(s_options);
+        }
+
+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)
+        {
+            if (propertyNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["Properties"] is null, "Should not add multiple lists of properties to the json format.");
+
+            JsonNode propertiesNode = new JsonObject();
+            foreach (string property in propertyNames)
+            {
+                propertiesNode[property] = getProperty(property);
+            }
+
+            _topLevelNode["Properties"] = propertiesNode;
+        }
+
+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)
+        {
+            if (itemNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["Items"] is null, "Should not add multiple lists of items to the json format.");
+
+            JsonNode itemsNode = new JsonObject();
+            foreach (string itemName in itemNames)
+            {
+                JsonArray itemArray = new();
+                foreach (ProjectItemInstance item in project.GetItems(itemName))
+                {
+                    JsonObject jsonItem = new();
+                    jsonItem["Identity"] = item.GetMetadataValue("Identity");
+                    foreach (string metadatumName in item.MetadataNames)
+                    {
+                        if (metadatumName.Equals("Identity"))
+                        {
+                            continue;
+                        }
+
+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);
+                    }
+
+                    itemArray.Add(jsonItem);
+                }
+
+                itemsNode[itemName] = itemArray;
+            }
+
+            _topLevelNode["Items"] = itemsNode;
+        }
+
+        internal void AddItemsInJsonFormat(string[] itemNames, Project project)
+        {
+            if (itemNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["Items"] is null, "Should not add multiple lists of items to the json format.");
+
+            JsonObject itemsNode = new();
+            foreach (string itemName in itemNames)
+            {
+                JsonArray itemArray = new();
+                foreach (ProjectItem item in project.GetItems(itemName))
+                {
+                    JsonObject jsonItem = new();
+                    jsonItem["Identity"] = item.GetMetadataValue("Identity");
+                    foreach (ProjectMetadata metadatum in item.Metadata)
+                    {
+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;
+                    }
+
+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)
+                    {
+                        if (metadatumName.Equals("Identity"))
+                        {
+                            continue;
+                        }
+
+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);
+                    }
+
+                    itemArray.Add(jsonItem);
+                }
+
+                itemsNode[itemName] = itemArray;
+            }
+
+            _topLevelNode["Items"] = itemsNode;
+        }
+
+        internal void AddTargetResultsInJsonFormat(string[] targetNames, BuildResult result)
+        {
+            if (targetNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["TargetResults"] is null, "Should not add multiple lists of target results to the json format.");
+
+            JsonObject targetResultsNode = new();
+            foreach (string targetName in targetNames)
+            {
+                TargetResult targetResult = result.ResultsByTarget[targetName];
+                JsonObject targetResults = new();
+                targetResults["Result"] = targetResult.ResultCode.ToString();
+                JsonArray outputArray = new();
+                foreach (ITaskItem item in targetResult.Items)
+                {
+                    JsonObject jsonItem = new();
+                    jsonItem["Identity"] = item.GetMetadata("Identity");
+                    foreach (string metadatumName in item.MetadataNames)
+                    {
+                        if (metadatumName.Equals("Identity"))
+                        {
+                            continue;
+                        }
+
+                        jsonItem[metadatumName] = item.GetMetadata(metadatumName);
+                    }
+
+                    outputArray.Add(jsonItem);
+                }
+
+                targetResults["Items"] = outputArray;
+                targetResultsNode[targetName] = targetResults;
+            }
+
+            _topLevelNode["TargetResults"] = targetResultsNode;
+        }
+    }
+}
diff --git a/src/MSBuild/LiveLogger/ANSIBuilder.cs b/src/MSBuild/LiveLogger/ANSIBuilder.cs
deleted file mode 100644
index f787c2949b3..00000000000
--- a/src/MSBuild/LiveLogger/ANSIBuilder.cs
+++ /dev/null
@@ -1,452 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Text.RegularExpressions;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-    internal static class ANSIBuilder
-    {
-        public static string ANSIRegex = @"\x1b(?:[@-Z\-_]|\[[0-?]*[ -\/]*[@-~]|(?:\]8;;.*?\x1b\\))";
-        // TODO: This should replace ANSIRegex once LiveLogger's API is internal
-        public static Regex ANSIRegexRegex = new Regex(ANSIRegex);
-        public static string ANSIRemove(string text)
-        {
-            return ANSIRegexRegex.Replace(text, "");
-        }
-
-        /// <summary>
-        /// Find a place to break a string after a number of visible characters, not counting VT-100 codes.
-        /// </summary>
-        /// <param name="text">String to split.</param>
-        /// <param name="position">Number of visible characters to split after.</param>
-        /// <returns>Index in <paramref name="text"/> that represents <paramref name="position"/> visible characters.</returns>
-        // TODO: This should be an optional parameter for ANSIBreakpoint(string text, int positioon, int initialPosition = 0)
-        public static int ANSIBreakpoint(string text, int position)
-        {
-            return ANSIBreakpoint(text, position, 0);
-        }
-        public static int ANSIBreakpoint(string text, int position, int initialPosition)
-        {
-            if (position >= text.Length)
-            {
-                return text.Length;
-            }
-            int nonAnsiIndex = 0;
-            Match nextMatch = ANSIRegexRegex.Match(text, initialPosition);
-            int logicalIndex = 0;
-            while (logicalIndex < text.Length && nonAnsiIndex != position)
-            {
-                // Jump over ansi codes
-                if (logicalIndex == nextMatch.Index && nextMatch.Length > 0)
-                {
-                    logicalIndex += nextMatch.Length;
-                    nextMatch = nextMatch.NextMatch();
-                }
-                // Increment non ansi index
-                nonAnsiIndex++;
-                logicalIndex++;
-            }
-            return logicalIndex;
-        }
-
-        public static List<string> ANSIWrap(string text, int maxLength)
-        {
-            ReadOnlySpan<char> textSpan = text.AsSpan();
-            List<string> result = new();
-            int breakpoint = ANSIBreakpoint(text, maxLength);
-            while (textSpan.Length > breakpoint)
-            {
-                result.Add(textSpan.Slice(0, breakpoint).ToString());
-                textSpan = textSpan.Slice(breakpoint);
-                breakpoint = ANSIBreakpoint(text, maxLength, breakpoint);
-            }
-            result.Add(textSpan.ToString());
-            return result;
-        }
-
-        public static class Alignment
-        {
-            public static string Center(string text)
-            {
-                string result = String.Empty;
-                string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth)
-                {
-                    return text;
-                }
-
-                int space = (Console.BufferWidth - noFormatString.Length) / 2;
-                result += new string(' ', space);
-                result += text;
-                result += new string(' ', space);
-                return result;
-            }
-
-            public static string Right(string text)
-            {
-                string result = String.Empty;
-                string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth)
-                {
-                    return text;
-                }
-
-                int space = Console.BufferWidth - noFormatString.Length;
-                result += new string(' ', space);
-                result += text;
-                return result;
-            }
-
-            public static string Left(string text)
-            {
-                string result = String.Empty;
-                string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth)
-                {
-                    return text;
-                }
-
-                int space = Console.BufferWidth - noFormatString.Length;
-                result += text;
-                result += new string(' ', space);
-                return result;
-            }
-
-            public static string SpaceBetween(string leftText, string rightText, int width)
-            {
-                string result = String.Empty;
-                string leftNoFormatString = ANSIRemove(leftText);
-                string rightNoFormatString = ANSIRemove(rightText);
-                if (leftNoFormatString.Length + rightNoFormatString.Length >= width)
-                {
-                    return leftText + rightText;
-                }
-
-                int space = width - (leftNoFormatString.Length + rightNoFormatString.Length);
-                result += leftText;
-                result += new string(' ', space - 1);
-                result += rightText;
-                return result;
-            }
-        }
-
-        public static class Formatting
-        {
-            public enum ForegroundColor
-            {
-                Black = 30,
-                Red = 31,
-                Green = 32,
-                Yellow = 33,
-                Blue = 34,
-                Magenta = 35,
-                Cyan = 36,
-                White = 37,
-                Default = 39
-            };
-
-            public enum BackgroundColor
-            {
-                Black = 40,
-                Red = 41,
-                Green = 42,
-                Yellow = 43,
-                Blue = 44,
-                Magenta = 45,
-                Cyan = 46,
-                White = 47,
-                Default = 49
-            }
-
-            public static string Color(string text, ForegroundColor color)
-            {
-                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
-            }
-
-            public static string Color(string text, BackgroundColor color)
-            {
-                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
-            }
-
-            public static string Color(string text, BackgroundColor backgrdoundColor, ForegroundColor foregroundColor)
-            {
-                return String.Format("\x1b[{0};{1}m{2}\x1b[0m", (int)backgrdoundColor, (int)foregroundColor, text);
-            }
-
-            public static string Bold(string text)
-            {
-                return String.Format("\x1b[1m{0}\x1b[22m", text);
-            }
-
-            public static string Dim(string text)
-            {
-                return String.Format("\x1b[2m{0}\x1b[22m", text);
-            }
-
-            public static string Italic(string text)
-            {
-                return String.Format("\x1b[3m{0}\x1b[23m", text);
-            }
-
-            public static string Underlined(string text)
-            {
-                return String.Format("\x1b[4m{0}\x1b[24m", text);
-            }
-
-            public static string DoubleUnderlined(string text)
-            {
-                return String.Format("\x1b[21m{0}\x1b[24m", text);
-            }
-
-            public static string Inverse(string text)
-            {
-                return String.Format("\x1b[7m{0}\x1b[27m", text);
-            }
-
-            public static string Invisible(string text)
-            {
-                return String.Format("\x1b[8m{0}\x1b[28m", text);
-            }
-
-            public static string CrossedOut(string text)
-            {
-                return String.Format("\x1b[9m{0}\x1b[29m", text);
-            }
-
-            public static string Overlined(string text)
-            {
-                return String.Format("\x1b[53m{0}\x1b[55m", text);
-            }
-
-            public static string Hyperlink(string text, string rawUrl)
-            {
-                string url = rawUrl.Length > 0 ? new System.Uri(rawUrl).AbsoluteUri : rawUrl;
-                return $"\x1b]8;;{url}\x1b\\{text}\x1b]8;;\x1b\\";
-            }
-
-            public static string DECLineDrawing(string text)
-            {
-                return String.Format("\x1b(0{0}\x1b(B", text);
-            }
-        }
-
-        public static class Cursor
-        {
-            public enum CursorStyle
-            {
-                Default = 0,
-                BlockBlinking = 1,
-                BlockSteady = 2,
-                UnderlineBlinking = 3,
-                UnderlineSteady = 4,
-                BarBlinking = 5,
-                BarSteady = 6,
-            }
-
-            public static string Style(CursorStyle style)
-            {
-                return String.Format("\x1b[{0} q", (int)style);
-            }
-
-            public static string Up(int n = 1)
-            {
-                return String.Format("\x1b[{0}A", n);
-            }
-
-            public static string UpAndScroll(int n)
-            {
-                string result = "";
-                for (int i = 0; i < n; i++)
-                {
-                    result += "\x1bM";
-                }
-                return result;
-            }
-
-            public static string Down(int n = 1)
-            {
-                return String.Format("\x1b[{0}B", n);
-            }
-
-            public static string Forward(int n = 1)
-            {
-                return String.Format("\x1b[{0}C", n);
-            }
-
-            public static string Backward(int n = 1)
-            {
-                return String.Format("\x1b[{0}D", n);
-            }
-
-            public static string Home()
-            {
-                return String.Format("\x1b[H");
-            }
-
-            public static string Position(int row, int column)
-            {
-                return String.Format("\x1b[{0};{1}H", row, column);
-            }
-
-            public static string SavePosition()
-            {
-                return String.Format("\x1b[s");
-            }
-
-            public static string RestorePosition()
-            {
-                return String.Format("\x1b[u");
-            }
-
-            public static string Invisible()
-            {
-                return "\x1b[?25l";
-            }
-
-            public static string Visible()
-            {
-                return "\x1b[?25h";
-            }
-        }
-
-        public static class Tabulator
-        {
-            public static string SetStop()
-            {
-                return String.Format("\x1bH");
-            }
-
-            public static string ForwardTab(int n)
-            {
-                if (n == 0)
-                {
-                    return "";
-                }
-
-                return String.Format("\x1b[{0}I", n);
-            }
-
-            public static string BackwardTab(int n)
-            {
-                return String.Format("\x1b[{0}Z", n);
-            }
-
-            public static string UnsetStop()
-            {
-                return String.Format("\x1b[0g");
-            }
-
-            public static string UnserAlStops()
-            {
-                return String.Format("\x1b[3g");
-            }
-        }
-
-        public static class Viewport
-        {
-            public static string ScrollDown(int n)
-            {
-                return String.Format("\x1b[{0}T", n);
-            }
-
-            public static string ScrollUp(int n)
-            {
-                return String.Format("\x1b[{0}S", n);
-            }
-
-            public static string SetScrollingRegion(int start, int end)
-            {
-                return String.Format("\x1b[{0};{1}r", start, end);
-            }
-
-            public static string PrependLines(int n)
-            {
-                return String.Format("\x1b[{0}L", n);
-            }
-
-            public static string DeleteLines(int n)
-            {
-                return String.Format("\x1b[{0}M", n);
-            }
-        }
-
-        public static class Eraser
-        {
-            public static string DisplayCursorToEnd()
-            {
-                return String.Format("\x1b[0J");
-            }
-
-            public static string DisplayStartToCursor()
-            {
-                return String.Format("\x1b[1J");
-            }
-
-            public static string Display()
-            {
-                return String.Format("\x1b[2J");
-            }
-
-            public static string LineCursorToEnd()
-            {
-                return String.Format("\x1b[0K");
-            }
-
-            public static string LineStartToCursor()
-            {
-                return String.Format("\x1b[1K");
-            }
-
-            public static string Line()
-            {
-                return String.Format("\x1b[2k");
-            }
-        }
-
-        public static class Graphics
-        {
-            private static int spinnerCounter = 0;
-            public static string Spinner()
-            {
-                return Spinner(spinnerCounter++);
-            }
-
-            public static string Spinner(int n)
-            {
-                char[] chars = { '\\', '|', '/', '-' };
-                return chars[n % (chars.Length - 1)].ToString();
-            }
-
-            public static string ProgressBar(float percentage, int width = 10, char completedChar = '‚ñà', char remainingChar = '‚ñë')
-            {
-                return new string(completedChar, (int)Math.Floor(width * percentage)) + new string(remainingChar, width - (int)Math.Floor(width * percentage));
-            }
-
-            public static string Bell()
-            {
-                return String.Format("\x07");
-            }
-        }
-
-        public static class Buffer
-        {
-            public static string Fill()
-            {
-                return String.Format("\x1b#8");
-            }
-
-            public static string UseAlternateBuffer()
-            {
-                return "\x1b[?1049h";
-            }
-
-            public static string UseMainBuffer()
-            {
-                return "\x1b[?1049l";
-            }
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
deleted file mode 100644
index 7068886ba69..00000000000
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ /dev/null
@@ -1,343 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Concurrent;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Threading.Tasks;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-    internal class LiveLogger : ILogger
-    {
-        private ConcurrentDictionary<int, ProjectNode> projects = new();
-
-        private bool succeeded;
-        private int startedProjects = 0;
-        private int finishedProjects = 0;
-        private ConcurrentDictionary<string, int> blockedProjects = new();
-
-        private Stopwatch? _stopwatch;
-
-        public LoggerVerbosity Verbosity { get; set; }
-        public string Parameters { get; set; }
-
-        /// <summary>
-        /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
-        /// </summary>
-        /// <remarks>
-        /// If LiveLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
-        /// </remarks>
-        public static readonly string[] ConfigurableForwardingLoggerParameters =
-        {
-            "BUILDSTARTEDEVENT",
-            "BUILDFINISHEDEVENT",
-            "PROJECTSTARTEDEVENT",
-            "PROJECTFINISHEDEVENT",
-            "TARGETSTARTEDEVENT",
-            "TARGETFINISHEDEVENT",
-            "TASKSTARTEDEVENT",
-            "HIGHMESSAGEEVENT",
-            "WARNINGEVENT",
-            "ERROREVENT"
-        };
-
-        public LiveLogger()
-        {
-            Parameters = "";
-        }
-
-        public void Initialize(IEventSource eventSource)
-        {
-            // Start the stopwatch as soon as the logger is initialized to capture
-            // any time before the BuildStarted event
-            _stopwatch = Stopwatch.StartNew();
-            // Register for different events. Make sure that ConfigurableForwardingLoggerParameters are in sync with them.
-            // Started and Finished events  
-            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);
-            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);
-            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);
-            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);
-            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
-            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
-            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
-
-            // Messages/Warnings/Errors
-            // BuildMessageEventHandler event handler below currently process only High importance events. 
-            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);
-            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);
-            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);
-
-            // Cancelled
-            Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);
-
-            Task.Run(() =>
-            {
-                Render();
-            });
-        }
-
-        private void Render()
-        {
-            // Initialize LiveLoggerBuffer
-            TerminalBuffer.Initialize();
-            // TODO: Fix. First line does not appear at top. Leaving empty line for now
-            TerminalBuffer.WriteNewLine(string.Empty);
-
-            // Top line indicates the number of finished projects.
-            TerminalBuffer.FinishedProjects = this.finishedProjects;
-
-            // First render
-            TerminalBuffer.Render();
-            int i = 0;
-            // Rerender periodically
-            while (!TerminalBuffer.IsTerminated)
-            {
-                i++;
-                // Delay by 1/60 seconds
-                // Use task delay to avoid blocking the task, so that keyboard input is listened continously
-                Task.Delay((i / 60) * 1_000).ContinueWith((t) =>
-                {
-                    TerminalBuffer.FinishedProjects = this.finishedProjects;
-
-                    // Rerender projects only when needed
-                    foreach (var project in projects)
-                    {
-                        project.Value.Log();
-                    }
-
-                    // Rerender buffer
-                    TerminalBuffer.Render();
-                });
-                // Handle keyboard input
-                if (Console.KeyAvailable)
-                {
-                    ConsoleKey key = Console.ReadKey().Key;
-                    switch (key)
-                    {
-                        case ConsoleKey.UpArrow:
-                            if (TerminalBuffer.TopLineIndex > 0)
-                            {
-                                TerminalBuffer.TopLineIndex--;
-                            }
-                            TerminalBuffer.ShouldRerender = true;
-                            break;
-                        case ConsoleKey.DownArrow:
-                            TerminalBuffer.TopLineIndex++;
-                            TerminalBuffer.ShouldRerender = true;
-                            break;
-                        default:
-                            break;
-                    }
-                }
-            }
-        }
-
-        private void UpdateFooter()
-        {
-            float percentage = startedProjects == 0 ? 0.0f : (float)finishedProjects / startedProjects;
-            TerminalBuffer.FooterText = ANSIBuilder.Alignment.SpaceBetween(
-                $"Build progress (approx.) [{ANSIBuilder.Graphics.ProgressBar(percentage)}]",
-                ANSIBuilder.Formatting.Italic(ANSIBuilder.Formatting.Dim("[Up][Down] Scroll")),
-                Console.BufferWidth);
-        }
-
-        // Build
-        private void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
-        {
-        }
-
-        private void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
-        {
-            succeeded = e.Succeeded;
-        }
-
-        // Project
-        private void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
-        {
-            startedProjects++;
-
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-
-            // If id does not exist...
-            projects.GetOrAdd(id, (_) =>
-            {
-                // Add project
-                ProjectNode node = new(e)
-                {
-                    ShouldRerender = true,
-                };
-                UpdateFooter();
-
-                return node;
-            });
-        }
-
-        private void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
-        {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-
-            // Update line
-            node.Finished = true;
-            node.ShouldRerender = true;
-            finishedProjects++;
-            UpdateFooter();
-        }
-
-        // Target
-        private void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
-        {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.AddTarget(e);
-            // Log
-            node.ShouldRerender = true;
-        }
-
-        private void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e)
-        {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.FinishedTargets++;
-            // Log
-            node.ShouldRerender = true;
-        }
-
-        // Task
-        private void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
-        {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.AddTask(e);
-            // Log
-            node.ShouldRerender = true;
-
-            if (e.TaskName.Equals("MSBuild"))
-            {
-                TerminalBufferLine? line = null; // TerminalBuffer.WriteNewLineAfterMidpoint($"{e.ProjectFile} is blocked by the MSBuild task.");
-                if (line is not null)
-                {
-                    blockedProjects[e.ProjectFile] = line.Id;
-                }
-            }
-        }
-
-        // Raised messages, warnings and errors
-        private void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
-        {
-            if (e is TaskCommandLineEventArgs)
-            {
-                return;
-            }
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.AddMessage(e);
-            // Log
-            node.ShouldRerender = true;
-        }
-
-        private void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
-        {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.AddWarning(e);
-            // Log
-            node.ShouldRerender = true;
-        }
-
-        private void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
-        {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.AddError(e);
-            // Log
-            node.ShouldRerender = true;
-        }
-
-        private void console_CancelKeyPressed(object? sender, ConsoleCancelEventArgs eventArgs)
-        {
-            // Shutdown logger
-            Shutdown();
-        }
-
-        public void Shutdown()
-        {
-            TerminalBuffer.Terminate();
-            int errorCount = 0;
-            int warningCount = 0;
-            foreach (var project in projects)
-            {
-                if (project.Value.AdditionalDetails.Count == 0)
-                {
-                    continue;
-                }
-
-                Console.WriteLine(project.Value.ToANSIString());
-                errorCount += project.Value.ErrorCount;
-                warningCount += project.Value.WarningCount;
-                foreach (var message in project.Value.AdditionalDetails)
-                {
-                    Console.WriteLine($"    ‚îî‚îÄ‚îÄ {message.ToANSIString()}");
-                }
-                Console.WriteLine();
-            }
-
-            // Empty line
-            Console.WriteLine();
-
-            Debug.Assert(_stopwatch is not null, $"Expected {nameof(_stopwatch)} to be initialized long before Shutdown()");
-            TimeSpan buildDuration = _stopwatch!.Elapsed;
-
-            string prettyDuration = buildDuration.TotalHours > 1.0 ?
-                buildDuration.ToString(@"h\:mm\:ss") :
-                buildDuration.ToString(@"m\:ss");
-
-            string status = succeeded ?
-                ANSIBuilder.Formatting.Color("succeeded", ANSIBuilder.Formatting.ForegroundColor.Green) :
-                ANSIBuilder.Formatting.Color("failed", ANSIBuilder.Formatting.ForegroundColor.Red);
-
-            Console.WriteLine($"Build {status} in {prettyDuration}");
-            Console.WriteLine($"\t{warningCount} Warnings(s)");
-            Console.WriteLine($"\t{errorCount} Errors(s)");
-            Console.WriteLine();
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/MessageNode.cs b/src/MSBuild/LiveLogger/MessageNode.cs
deleted file mode 100644
index 7d6029e041d..00000000000
--- a/src/MSBuild/LiveLogger/MessageNode.cs
+++ /dev/null
@@ -1,103 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.IO;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-
-    internal class MessageNode
-    {
-        // Use this to change the max lenngth (relative to screen size) of messages
-        private static int MAX_LENGTH = 3 * Console.BufferWidth;
-        public enum MessageType
-        {
-            HighPriorityMessage,
-            Warning,
-            Error,
-            ProjectOutputMessage
-        }
-        public string Message;
-        public TerminalBufferLine? Line;
-        public MessageType Type;
-        public string? Code;
-        public string? FilePath;
-        public int? LineNumber;
-        public int? ColumnNumber;
-        public string? ProjectOutputExecutablePath;
-        public MessageNode(LazyFormattedBuildEventArgs args)
-        {
-            Message = args.Message ?? string.Empty;
-            if (Message.Length > MAX_LENGTH)
-            {
-                Message = Message.Substring(0, MAX_LENGTH - 1) + "‚Ä¶";
-            }
-            // Get type
-            switch (args)
-            {
-                case BuildMessageEventArgs message:
-                    // Detect output messages
-                    var finalOutputMarker = " -> ";
-                    int i = message.Message!.IndexOf(finalOutputMarker, StringComparison.Ordinal);
-                    if (i > 0)
-                    {
-                        Type = MessageType.ProjectOutputMessage;
-                        ProjectOutputExecutablePath = message.Message!.Substring(i + finalOutputMarker.Length);
-                    }
-                    else
-                    {
-                        Type = MessageType.HighPriorityMessage;
-                        Code = message.Subcategory;
-                    }
-                    break;
-                case BuildWarningEventArgs warning:
-                    Type = MessageType.Warning;
-                    Code = warning.Code;
-                    FilePath = warning.File;
-                    LineNumber = warning.LineNumber;
-                    ColumnNumber = warning.ColumnNumber;
-                    break;
-                case BuildErrorEventArgs error:
-                    Type = MessageType.Error;
-                    Code = error.Code;
-                    FilePath = error.File;
-                    LineNumber = error.LineNumber;
-                    ColumnNumber = error.ColumnNumber;
-                    break;
-            }
-        }
-
-        public string ToANSIString()
-        {
-            switch (Type)
-            {
-                case MessageType.Warning:
-                    return $"‚ö†Ô∏è {ANSIBuilder.Formatting.Color(
-                        $"Warning {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
-                        ANSIBuilder.Formatting.ForegroundColor.Yellow)}";
-                case MessageType.Error:
-                    return $"‚ùå {ANSIBuilder.Formatting.Color(
-                        $"Error {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
-                        ANSIBuilder.Formatting.ForegroundColor.Red)}";
-                case MessageType.ProjectOutputMessage:
-                    return $"‚öôÔ∏è {ANSIBuilder.Formatting.Hyperlink(ProjectOutputExecutablePath!, Path.GetDirectoryName(ProjectOutputExecutablePath)!)}";
-                case MessageType.HighPriorityMessage:
-                default:
-                    return $"‚ÑπÔ∏è {Code}{(Code is not null ? ": " : string.Empty)} {ANSIBuilder.Formatting.Italic(Message)}";
-            }
-        }
-
-        // TODO: Rename to Log after LiveLogger's API becomes internal
-        public void Log()
-        {
-            if (Line == null)
-            {
-                return;
-            }
-
-            Line.Text = $"    ‚îî‚îÄ‚îÄ {ToANSIString()}";
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/ProjectNode.cs b/src/MSBuild/LiveLogger/ProjectNode.cs
deleted file mode 100644
index 9561ead1647..00000000000
--- a/src/MSBuild/LiveLogger/ProjectNode.cs
+++ /dev/null
@@ -1,233 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-    internal class ProjectNode
-    {
-        /// <summary>
-        /// Given a list of paths, this method will get the shortest not ambiguous path for a project.
-        /// Example: for `/users/documents/foo/project.csproj` and `/users/documents/bar/project.csproj`, the respective non ambiguous paths would be `foo/project.csproj` and `bar/project.csproj`
-        /// Still work in progress...
-        /// </summary>
-        private static string GetUnambiguousPath(string path)
-        {
-            return Path.GetFileName(path);
-        }
-
-        public int Id;
-        public string ProjectPath;
-        public string TargetFramework;
-        public bool Finished;
-        public string? ProjectOutputExecutable;
-        // Line to display project info
-        public TerminalBufferLine? Line;
-        // Targets
-        public int FinishedTargets;
-        public TerminalBufferLine? CurrentTargetLine;
-        public TargetNode? CurrentTargetNode;
-        // Messages, errors and warnings
-        public List<MessageNode> AdditionalDetails = new();
-        // Count messages, warnings and errors
-        public int MessageCount = 0;
-        public int WarningCount = 0;
-        public int ErrorCount = 0;
-        // Bool if node should rerender
-        internal bool ShouldRerender = true;
-        public ProjectNode(ProjectStartedEventArgs args)
-        {
-            Id = args.ProjectId;
-            ProjectPath = args.ProjectFile!;
-            Finished = false;
-            FinishedTargets = 0;
-            if (args.GlobalProperties != null && args.GlobalProperties.ContainsKey("TargetFramework"))
-            {
-                TargetFramework = args.GlobalProperties["TargetFramework"];
-            }
-            else
-            {
-                TargetFramework = "";
-            }
-        }
-
-        public string ToANSIString()
-        {
-            ANSIBuilder.Formatting.ForegroundColor color = ANSIBuilder.Formatting.ForegroundColor.Default;
-            string icon = ANSIBuilder.Graphics.Spinner() + " ";
-
-            if (Finished && WarningCount + ErrorCount == 0)
-            {
-                color = ANSIBuilder.Formatting.ForegroundColor.Green;
-                icon = "‚úì";
-            }
-            else if (ErrorCount > 0)
-            {
-                color = ANSIBuilder.Formatting.ForegroundColor.Red;
-                icon = "X";
-            }
-            else if (WarningCount > 0)
-            {
-                color = ANSIBuilder.Formatting.ForegroundColor.Yellow;
-                icon = "‚úì";
-            }
-            return icon + " " + ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), color) + " " + ANSIBuilder.Formatting.Inverse(TargetFramework);
-        }
-
-        // TODO: Rename to Render() after LiveLogger's API becomes internal
-        public void Log()
-        {
-            if (!ShouldRerender)
-            {
-                return;
-            }
-
-            ShouldRerender = false;
-            // Project details
-            string lineContents = ANSIBuilder.Alignment.SpaceBetween(ToANSIString(), $"({MessageCount} ‚ÑπÔ∏è, {WarningCount} ‚ö†Ô∏è, {ErrorCount} ‚ùå)", Console.BufferWidth - 1);
-            // Create or update line
-            if (Line is null)
-            {
-                Line = TerminalBuffer.WriteNewLineBeforeMidpoint(lineContents, false);
-            }
-            else
-            {
-                Line.Text = lineContents;
-            }
-
-            // For finished projects
-            if (Finished)
-            {
-                if (CurrentTargetLine is not null)
-                {
-                    TerminalBuffer.DeleteLine(CurrentTargetLine.Id);
-                }
-
-                bool foundErrorOrWarning = false;
-
-                foreach (MessageNode node in AdditionalDetails)
-                {
-                    if (node.Type != MessageNode.MessageType.HighPriorityMessage)
-                    {
-                        foundErrorOrWarning = true;
-                    }
-
-                    // Only delete high priority messages
-                    if (node.Type != MessageNode.MessageType.HighPriorityMessage)
-                    {
-                        continue;
-                    }
-
-                    if (node.Line is not null)
-                    {
-                        TerminalBuffer.DeleteLine(node.Line.Id);
-                    }
-                }
-
-                if (!foundErrorOrWarning && this.Line is not null)
-                {
-                    foreach (MessageNode node in AdditionalDetails)
-                    {
-                        int? id = node.Line?.Id;
-                        if (id is not null)
-                        {
-                            TerminalBuffer.DeleteLine(id.Value);
-                        }
-                    }
-
-                    TerminalBuffer.DeleteLine(this.Line.Id);
-                }
-            }
-
-            // Current target details
-            if (CurrentTargetNode is null)
-            {
-                return;
-            }
-
-            string currentTargetLineContents = $"    ‚îî‚îÄ‚îÄ {CurrentTargetNode.TargetName} : {CurrentTargetNode.CurrentTaskNode?.TaskName ?? String.Empty}";
-            if (CurrentTargetLine is null)
-            {
-                CurrentTargetLine = TerminalBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
-            }
-            else
-            {
-                CurrentTargetLine.Text = currentTargetLineContents;
-            }
-
-            // Messages, warnings and errors
-            foreach (MessageNode node in AdditionalDetails)
-            {
-                if (Finished && node.Type == MessageNode.MessageType.HighPriorityMessage)
-                {
-                    continue;
-                }
-
-                if (node.Line is null)
-                {
-                    node.Line = TerminalBuffer.WriteNewLineAfter(Line!.Id, "Message");
-                }
-
-                node.Log();
-            }
-        }
-
-        public TargetNode AddTarget(TargetStartedEventArgs args)
-        {
-            CurrentTargetNode = new TargetNode(args);
-            return CurrentTargetNode;
-        }
-        public TaskNode? AddTask(TaskStartedEventArgs args)
-        {
-            // Get target id
-            int targetId = args.BuildEventContext!.TargetId;
-            if (CurrentTargetNode?.Id == targetId)
-            {
-                return CurrentTargetNode.AddTask(args);
-            }
-            else
-            {
-                return null;
-            }
-        }
-        public MessageNode? AddMessage(BuildMessageEventArgs args)
-        {
-            if (args.Importance != MessageImportance.High)
-            {
-                return null;
-            }
-
-            MessageCount++;
-            MessageNode node = new MessageNode(args);
-            // Add output executable path
-            if (node.ProjectOutputExecutablePath is not null)
-            {
-                ProjectOutputExecutable = node.ProjectOutputExecutablePath;
-            }
-
-            AdditionalDetails.Add(node);
-            return node;
-        }
-        public MessageNode? AddWarning(BuildWarningEventArgs args)
-        {
-            WarningCount++;
-            MessageNode node = new MessageNode(args);
-            AdditionalDetails.Add(node);
-            TerminalBuffer.overallBuildState = TerminalBuffer.overallBuildState == OverallBuildState.Error ? OverallBuildState.Error : OverallBuildState.Warning;
-            return node;
-        }
-        public MessageNode? AddError(BuildErrorEventArgs args)
-        {
-            ErrorCount++;
-            MessageNode node = new MessageNode(args);
-            AdditionalDetails.Add(node);
-            TerminalBuffer.overallBuildState = OverallBuildState.Error;
-            return node;
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/TargetNode.cs b/src/MSBuild/LiveLogger/TargetNode.cs
deleted file mode 100644
index 06d61dd431a..00000000000
--- a/src/MSBuild/LiveLogger/TargetNode.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-
-    internal class TargetNode
-    {
-        public int Id;
-        public string TargetName;
-        public TaskNode? CurrentTaskNode;
-        public TargetNode(TargetStartedEventArgs args)
-        {
-            Id = args.BuildEventContext!.TargetId;
-            TargetName = args.TargetName;
-        }
-        public TaskNode AddTask(TaskStartedEventArgs args)
-        {
-            CurrentTaskNode = new TaskNode(args);
-            return CurrentTaskNode;
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/TaskNode.cs b/src/MSBuild/LiveLogger/TaskNode.cs
deleted file mode 100644
index 4e8d8118675..00000000000
--- a/src/MSBuild/LiveLogger/TaskNode.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-
-    internal class TaskNode
-    {
-        public int Id;
-        public string TaskName;
-        public TaskNode(TaskStartedEventArgs args)
-        {
-            Id = args.BuildEventContext!.TaskId;
-            TaskName = args.TaskName;
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/TerminalBuffer.cs b/src/MSBuild/LiveLogger/TerminalBuffer.cs
deleted file mode 100644
index d58b42c7689..00000000000
--- a/src/MSBuild/LiveLogger/TerminalBuffer.cs
+++ /dev/null
@@ -1,295 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Runtime.CompilerServices;
-using System.Text;
-using static System.Net.Mime.MediaTypeNames;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-    internal class TerminalBufferLine
-    {
-        private static int Counter = 0;
-        private string _text = string.Empty;
-        public List<string> WrappedText { get; private set; } = new();
-        public int Id;
-        public bool ShouldWrapLines;
-        public string Text
-        {
-            get => _text;
-            set
-            {
-                // Set text value and get wrapped lines
-                _text = value;
-                if (ShouldWrapLines)
-                {
-                    WrappedText = ANSIBuilder.ANSIWrap(value, Console.BufferWidth);
-                }
-                else
-                {
-                    WrappedText = new List<string> { value };
-                }
-                // Buffer should rerender
-                TerminalBuffer.ShouldRerender = true;
-            }
-        }
-
-        public TerminalBufferLine()
-        {
-            Id = Counter++;
-            Text = string.Empty;
-            ShouldWrapLines = false;
-        }
-        public TerminalBufferLine(string text)
-            : this()
-        {
-            Text = text;
-        }
-        public TerminalBufferLine(string text, bool shouldWrapLines)
-            : this()
-        {
-            ShouldWrapLines = shouldWrapLines;
-            Text = text;
-        }
-    }
-
-    internal class TerminalBuffer
-    {
-        private const char errorSymbol = '‚ùå';
-        private const char warningSymbol = '‚ö†';
-        private static List<TerminalBufferLine> Lines = new();
-        public static string FooterText = string.Empty;
-        public static int TopLineIndex = 0;
-        public static string Footer = string.Empty;
-        internal static bool IsTerminated = false;
-        internal static bool ShouldRerender = true;
-        internal static OverallBuildState overallBuildState = OverallBuildState.None;
-        internal static int FinishedProjects = 0;
-        private static int midLineId;
-        internal static int ScrollableAreaHeight
-        {
-            get
-            {
-                // Height of the buffer -3 (titlebar, footer, and footer line)
-                return Console.BufferHeight - 3;
-            }
-        }
-        public static void Initialize()
-        {
-            // Configure buffer, encoding and cursor
-            Console.OutputEncoding = Encoding.UTF8;
-            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
-            Console.Write(ANSIBuilder.Cursor.Invisible());
-            // TerminalBufferLine midLine = new(new string('-', Console.BufferWidth), true);
-            // WriteNewLine(midLine);
-            // midLineId = midLine.Id;
-            midLineId = -1;
-        }
-
-        public static void Terminate()
-        {
-            IsTerminated = true;
-            // Delete contents from alternate buffer before switching back to main buffer
-            Console.Write(
-                ANSIBuilder.Cursor.Home() +
-                ANSIBuilder.Eraser.DisplayCursorToEnd());
-            // Reset configuration for buffer and cursor, and clear screen
-            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
-            Console.Write(ANSIBuilder.Cursor.Visible());
-            Lines = new();
-        }
-
-        #region Rendering
-        public static void Render()
-        {
-            if (IsTerminated || !ShouldRerender)
-            {
-                return;
-            }
-
-            ShouldRerender = false;
-            ANSIBuilder.Formatting.ForegroundColor desiredColor =
-                overallBuildState == OverallBuildState.Error ? ANSIBuilder.Formatting.ForegroundColor.Red :
-                overallBuildState == OverallBuildState.Warning ? ANSIBuilder.Formatting.ForegroundColor.Yellow :
-                ANSIBuilder.Formatting.ForegroundColor.White;
-
-            string text = $"MSBuild - Build in progress - {FinishedProjects} finished projects";
-            text =
-                overallBuildState == OverallBuildState.Error ? $"{errorSymbol} {text} {errorSymbol}" :
-                overallBuildState == OverallBuildState.Warning ? $"{warningSymbol} {text} {warningSymbol}" :
-                text;
-
-            Console.Write(
-                // Write header
-                ANSIBuilder.Cursor.Home() +
-                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center(text)), ANSIBuilder.Formatting.BackgroundColor.Black, desiredColor) +
-                // Write footer
-                ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
-                    ANSIBuilder.Eraser.LineCursorToEnd() +
-                    new string('-', Console.BufferWidth) +
-                    Environment.NewLine +
-                    FooterText);
-
-            if (Lines.Count == 0)
-            {
-                return;
-            }
-
-            // Iterate over lines and display on terminal
-            string contents = string.Empty;
-            int accumulatedLineCount = 0;
-            int lineIndex = 0;
-            foreach (TerminalBufferLine line in Lines)
-            {
-                // Continue if accum line count + next lines < scrolling area
-                if (accumulatedLineCount + line.WrappedText.Count < TopLineIndex)
-                {
-                    accumulatedLineCount += line.WrappedText.Count;
-                    continue;
-                }
-
-                // Break if exceeds scrolling area
-                if (accumulatedLineCount - TopLineIndex > ScrollableAreaHeight)
-                {
-                    break;
-                }
-
-                foreach (string s in line.WrappedText)
-                {
-                    // Get line index relative to scroll area
-                    lineIndex = accumulatedLineCount - TopLineIndex;
-                    // Print if line in scrolling area
-                    if (lineIndex >= 0 && lineIndex < ScrollableAreaHeight)
-                    {
-                        contents += ANSIBuilder.Cursor.Position(lineIndex + 2, 0) + ANSIBuilder.Eraser.LineCursorToEnd() + s;
-                    }
-
-                    accumulatedLineCount++;
-                }
-            }
-            // Iterate for the rest of the screen
-            for (int i = lineIndex + 1; i < ScrollableAreaHeight; i++)
-            {
-                contents += ANSIBuilder.Cursor.Position(i + 2, 0) + ANSIBuilder.Eraser.LineCursorToEnd();
-            }
-            Console.Write(contents);
-        }
-        #endregion
-
-        #region Line identification
-        public static int GetLineIndexById(int lineId)
-        {
-            return Lines.FindIndex(x => x.Id == lineId);
-        }
-
-        public static TerminalBufferLine? GetLineById(int lineId)
-        {
-            int index = GetLineIndexById(lineId);
-            if (index == -1)
-            {
-                return null;
-            }
-
-            return Lines[index];
-        }
-        #endregion
-
-        #region Line create, update and delete
-        // Write new line
-        public static TerminalBufferLine? WriteNewLineAfter(int lineId, string text)
-        {
-            return WriteNewLineAfter(lineId, text, true);
-        }
-        public static TerminalBufferLine? WriteNewLineAfter(int lineId, string text, bool shouldWrapLines)
-        {
-            TerminalBufferLine line = new TerminalBufferLine(text, shouldWrapLines);
-            return WriteNewLineAfter(lineId, line);
-        }
-        public static TerminalBufferLine? WriteNewLineAfter(int lineId, TerminalBufferLine line)
-        {
-            if (lineId != -1)
-            {
-                // Get line index
-                int lineIndex = GetLineIndexById(lineId);
-                if (lineIndex == -1)
-                {
-                    return null;
-                }
-                // Get line end index
-                Lines.Insert(lineIndex + 1, line);
-            }
-            else
-            {
-                Lines.Add(line);
-            }
-            return line;
-        }
-
-        public static TerminalBufferLine? WriteNewLineAfterMidpoint(string text, bool shouldWrapLines = false)
-        {
-            TerminalBufferLine line = new(text, shouldWrapLines);
-            return WriteNewLineAfter(midLineId, line);
-        }
-
-        public static TerminalBufferLine? WriteNewLineBeforeMidpoint(string text, bool shouldWrapLines)
-        {
-            TerminalBufferLine line = new(text, shouldWrapLines);
-            int lineIndex = GetLineIndexById(midLineId);
-            if (lineIndex == -1)
-            {
-                WriteNewLine(line);
-                return null;
-            }
-
-            Lines.Insert(lineIndex, line);
-
-            return line;
-        }
-
-        public static TerminalBufferLine? WriteNewLine(string text)
-        {
-            return WriteNewLine(text, true);
-        }
-        public static TerminalBufferLine? WriteNewLine(string text, bool shouldWrapLines)
-        {
-            TerminalBufferLine line = new TerminalBufferLine(text, shouldWrapLines);
-            return WriteNewLine(line);
-        }
-        public static TerminalBufferLine? WriteNewLine(TerminalBufferLine line)
-        {
-            return WriteNewLineAfter(Lines.Count > 0 ? Lines.Last().Id : -1, line);
-        }
-
-        // Update line
-        // TODO: Remove. Use line.Text instead
-        public static TerminalBufferLine? UpdateLine(int lineId, string text)
-        {
-            return null;
-        }
-
-        // Delete line
-        public static void DeleteLine(int lineId)
-        {
-            // Get line index
-            int lineIndex = GetLineIndexById(lineId);
-            if (lineIndex == -1)
-            {
-                return;
-            }
-            // Delete
-            Lines.RemoveAt(lineIndex);
-            ShouldRerender = true;
-        }
-        #endregion
-    }
-
-    internal enum OverallBuildState
-    {
-        None,
-        Warning,
-        Error,
-    }
-}
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 345d27ecf51..f552d2c765f 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -1,4 +1,4 @@
-Ôªø<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -18,6 +18,7 @@
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
     <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
+    <UseRidGraph>true</UseRidGraph>
 
     <EnableDefaultItems>false</EnableDefaultItems>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
@@ -48,7 +49,8 @@
     <NoPackageAnalysis>true</NoPackageAnalysis>
     <AddAppConfigToBuildOutputs>false</AddAppConfigToBuildOutputs>
 
-    <DebugType Condition="'$(Platform)' == 'x64'">full</DebugType><!-- Setting DebugType here goes hand in hand with eng\AfterSigning.targets. This is to prompt the x64 build to produce a 'full' .pdb that's `more compatible` then 'portable' and 'embedded' .pdbs. This doesn't get set on 32 bit architecture, which will default to 'embedded' and 'pdb2pdb' will convert those as needed. See https://github.com/dotnet/msbuild/pull/5070 for context. -->
+    <!-- Setting DebugType here goes hand in hand with eng\AfterSigning.targets. This is to prompt the x64 build to produce a 'full' .pdb that's `more compatible` then 'portable' and 'embedded' .pdbs. This doesn't get set on 32 bit architecture, which will default to 'embedded' and 'pdb2pdb' will convert those as needed. See https://github.com/dotnet/msbuild/pull/5070 for context. -->
+    <DebugType Condition="'$(Platform)' == 'x64'">full</DebugType>
     <DefineConstants>$(DefineConstants);MSBUILDENTRYPOINTEXE</DefineConstants>
   </PropertyGroup>
 
@@ -102,6 +104,9 @@
     <Compile Include="..\Shared\Modifiers.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\XMakeElements.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\IKeyed.cs" />
@@ -126,10 +131,7 @@
     <Compile Include="..\Shared\INodePacketFactory.cs" />
     <Compile Include="..\Shared\NodePacketFactory.cs" />
     <Compile Include="..\Shared\INodePacketHandler.cs" />
-    <Compile Include="..\Shared\ITranslatable.cs" />
-    <Compile Include="..\Shared\ITranslator.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
-    <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
@@ -156,12 +158,14 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
+    <Compile Include="..\Shared\StringExtensions.cs" />
     <Compile Include="AssemblyInfo.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="AssemblyResources.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="AutomaticEncodingRestorer.cs" />
     <Compile Include="CommandLineSwitches.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -172,7 +176,7 @@
     <Compile Include="DistributedLoggerRecord.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="LiveLogger\*.cs" />
+    <Compile Include="TerminalLogger\*.cs" />
     <Compile Include="InitializationException.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -186,6 +190,7 @@
     <Compile Include="OutOfProcTaskAppDomainWrapperBase.cs" />
     <Compile Include="OutOfProcTaskAppDomainWrapper.cs" />
     <Compile Include="PerformanceLogEventListener.cs" />
+    <Compile Include="JsonOutputFormatter.cs" />
     <Compile Include="XMake.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -214,16 +219,17 @@
     </None>
   </ItemGroup>
   <ItemGroup>
+    <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
-    <!-- Manually download this library for RoslynCodeTaskFactory.
+  <!-- Manually download this library for RoslynCodeTaskFactory.
            See target AddRefAssemblies below. -->
-    <ItemGroup>
-      <PackageDownload Include="netstandard.library">
-        <Version>[2.0.3]</Version>
-      </PackageDownload>
-    </ItemGroup>
+  <ItemGroup>
+    <PackageDownload Include="netstandard.library">
+      <Version>[2.0.3]</Version>
+    </PackageDownload>
+  </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- File for Assemblies we depend on -->
     <Reference Include="System" />
@@ -244,7 +250,7 @@
 
   <!-- Xsds are not TF or arch-specific so copy once them in the outer build -->
   <Target Name="CopyXsds" BeforeTargets="Build" Condition="'$(IsInnerBuild)' != 'true'">
-    <Copy SourceFiles="@(XsdsForVS)" DestinationFiles="@(XsdsForVS-&gt;'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" />
+    <Copy SourceFiles="@(XsdsForVS)" DestinationFiles="@(XsdsForVS-&gt;'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')" SkipUnchangedFiles="true" />
   </Target>
 
   <!-- Include MSBuild.deps.json and MSBuild.runtimeconfig.json in ContentWithTargetPath so they will be copied to the output folder of projects
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 3f2d3d8cee2..16a70ef7da0 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1419,6 +1419,11 @@ elementFormDefault="qualified">
     <xs:element name="CLRSupport" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="UseDebugLibraries" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="CodePage" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="CompilerGeneratedFilesOutputPath" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="CompilerGeneratedFilesOutputPath" _locComment="" -->Controls where source generated files are saved.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="Configuration" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ConfigurationName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ConfigurationOverrideFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1700,6 +1705,11 @@ elementFormDefault="qualified">
         </xs:annotation>
     </xs:element>
     <xs:element name="DocumentationFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="EmitCompilerGeneratedFiles" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EmitCompilerGeneratedFiles" _locComment="" -->Controls whether source generated files will be saved.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="EnableASPDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EnableASPXDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EnableSQLServerDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1730,6 +1740,20 @@ elementFormDefault="qualified">
         <xs:documentation><!-- _locID_text="GenerateDocumentationFile" _locComment="" -->Value indicating whether a documentation file will be generated by the compiler</xs:documentation>
       </xs:annotation>
     </xs:element>
+    <xs:element name="CopyDebugSymbolFilesFromPackages" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation>
+                <!-- _locID_text="CopyDebugSymbolFilesFromPackages" _locComment="" -->Value indicating whether symbol files will be copied from NuGet packages by the compiler
+            </xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="CopyDocumentationFilesFromPackages" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation>
+                <!-- _locID_text="CopyDocumentationFilesFromPackages" _locComment="" -->Value indicating whether documentation files will be copied from NuGet packages by the compiler
+            </xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="GenerateManifests" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="GenerateLibraryLayout" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="GeneratePackageOnBuild" type="msb:boolean" substitutionGroup="msb:Property">
@@ -1820,6 +1844,11 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="EnableDefaultItems" _locComment="" -->Defaults to true, and if set to false will disable all default item globs.</xs:documentation>
         </xs:annotation>
     </xs:element>
+    <xs:element name="IsAotCompatible" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="IsAotCompatible" _locComment="" -->Indicates whether a class library is compatible with native AOT. Setting to true will enable analyzers for trimming, single file, and AOT.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="IsWebBootstrapper" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="JCPA" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="Keyword" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1904,6 +1933,11 @@ elementFormDefault="qualified">
         </xs:annotation>
     </xs:element>
     <xs:element name="OSVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="BaseOutputPath" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="BaseOutputPath" _locComment="" -->Base path of output folder, where all configuration-specific output folders will be created. Default value is bin\.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="OutputPath" type="msb:StringPropertyType" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="OutputPath" _locComment="" -->Path to output folder, with trailing slash</xs:documentation>
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index f1f7c3b7ffe..dc6cfcdf7e6 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -5,14 +5,16 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.IO;
 using System.Globalization;
-using System.Threading;
+using System.IO;
 using System.Reflection;
-
+using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Experimental.FileAccess;
+#endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 #if FEATURE_APPDOMAIN
@@ -165,6 +167,13 @@ internal class OutOfProcTaskHostNode :
         private RegisteredTaskObjectCacheBase _registeredTaskObjectCache;
 #endif
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// The file accesses reported by the most recently completed task.
+        /// </summary>
+        private List<FileAccessData> _fileAccessData = new List<FileAccessData>();
+#endif
+
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -531,11 +540,22 @@ public override bool IsTaskInputLoggingEnabled
                     return _taskHost._currentConfiguration.IsTaskInputLoggingEnabled;
                 }
             }
+
+#if FEATURE_REPORTFILEACCESSES
+            /// <summary>
+            /// Reports a file access from a task.
+            /// </summary>
+            /// <param name="fileAccessData">The file access to report.</param>
+            public void ReportFileAccess(FileAccessData fileAccessData)
+            {
+                _taskHost._fileAccessData.Add(fileAccessData);
+            }
+#endif
         }
 
         public EngineServices EngineServices { get; }
 
-        #endregion
+#endregion
 
 #endif
 
@@ -936,8 +956,11 @@ private void RunTask(object state)
                     lock (_taskCompleteLock)
                     {
                         _taskCompletePacket = new TaskHostTaskComplete(
-                                                        taskResult,
-                                                        currentEnvironment);
+                            taskResult,
+#if FEATURE_REPORTFILEACCESSES
+                            _fileAccessData,
+#endif
+                            currentEnvironment);
                     }
 
 #if FEATURE_APPDOMAIN
@@ -956,11 +979,20 @@ private void RunTask(object state)
                     lock (_taskCompleteLock)
                     {
                         // Create a minimal taskCompletePacket to carry the exception so that the TaskHostTask does not hang while waiting
-                        _taskCompletePacket = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedAfterExecution, e), null);
+                        _taskCompletePacket = new TaskHostTaskComplete(
+                            new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedAfterExecution, e),
+#if FEATURE_REPORTFILEACCESSES
+                            _fileAccessData,
+#endif
+                            null);
                     }
                 }
                 finally
                 {
+#if FEATURE_REPORTFILEACCESSES
+                    _fileAccessData = new List<FileAccessData>();
+#endif
+
                     // Call CleanupTask to unload any domains and other necessary cleanup in the taskWrapper
                     _taskWrapper.CleanupTask();
 
@@ -1146,7 +1178,11 @@ private void SendBuildEvent(BuildEventArgs e)
         {
             if (_nodeEndpoint?.LinkStatus == LinkStatus.Active)
             {
-                if (!e.GetType().GetTypeInfo().IsSerializable)
+#pragma warning disable SYSLIB0050
+                // Types which are not serializable and are not IExtendedBuildEventArgs as
+                // those always implement custom serialization by WriteToStream and CreateFromStream.
+                if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)
+#pragma warning disable SYSLIB0050
                 {
                     // log a warning and bail.  This will end up re-calling SendBuildEvent, but we know for a fact
                     // that the warning that we constructed is serializable, so everything should be good.
@@ -1154,7 +1190,8 @@ private void SendBuildEvent(BuildEventArgs e)
                     return;
                 }
 
-                _nodeEndpoint.SendData(new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(_currentConfiguration.NodeId, e)));
+                LogMessagePacket logMessage = new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(_currentConfiguration.NodeId, e));
+                _nodeEndpoint.SendData(logMessage);
             }
         }
 
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 3cea4a096b1..a753a09c5b6 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -277,6 +277,10 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </value>
     <comment>
       LOCALIZATION: The following should not be localized:
@@ -833,8 +837,7 @@
     </comment>
   </data>
   <data name="HelpMessage_40_WarnNotAsErrorSwitch" Visibility="Public">
-    <value>
-      -warnNotAsError[:code[;code2]]
+    <value>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -848,6 +851,32 @@
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </comment>
   </data>
+  <data name="HelpMessage_41_QuestionSwitch" Visibility="Public">
+    <value>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </value>
+    <comment>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
+  <data name="HelpMessage_42_ReportFileAccessesSwitch" Visibility="Public">
+    <value>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </value>
+    <comment>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
   <data name="InvalidConfigurationFile" Visibility="Public">
     <value>MSBUILD : Configuration error MSB1043: The application could not start. {0}</value>
     <comment>
@@ -1016,6 +1045,37 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
+  <data name="MissingGetPropertyError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+  <data name="MissingGetItemError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+  <data name="MissingGetTargetResultError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+  <data name="SolutionBuildInvalidForCommandLineEvaluation" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <data name="MissingToolsVersionError" UESanitized="false" Visibility="Public">
     <value>MSBUILD : error MSB1039: Specify the version of the toolset.</value>
     <comment>
@@ -1150,6 +1210,15 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
+  <data name="MissingTerminalLoggerParameterError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <data name="MissingNodeReuseParameterError" UESanitized="true" Visibility="Public">
     <value>MSBUILD : error MSB1041: Specify one or more parameters for node reuse if using the -nodeReuse switch</value>
     <comment>{StrBegin="MSBUILD : error MSB1041: "}
@@ -1218,6 +1287,24 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
+  <data name="InvalidLowPriorityValue" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1064: Low priority value is not valid. {0}</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+  <data name="InvalidTerminalLoggerValue" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <data name="AbortingBuild" UESanitized="true" Visibility="Public">
     <value>Attempting to cancel the build...</value>
   </data>
@@ -1261,6 +1348,15 @@
     <value>MSBUILD : error MSB1049: The {0} parameter must be specified</value>
     <comment>{StrBegin="MSBUILD : error MSB1049: "}</comment>
   </data>
+  <data name="InvalidReportFileAccessesValue" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <!-- #################################################################################################-->
   <!-- ######################################## Shared strings #########################################-->
   <!-- ###### These belong in Strings.shared.resx, but have been copied here for performance ###########-->
@@ -1350,10 +1446,134 @@
     <value>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</value>
     <comment>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</comment>
   </data>
+  <data name="UnsupportedSwitchForSolutionFiles" Visibility="Public">
+    <value>The '{0}' switch is not supported for solution files.</value>
+  </data>
+  <data name="NameInvalid" Visibility="Public">
+    <value>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB5016: "}
+    </comment>
+  </data>
+  <!-- **** TerminalLogger strings begin **** -->
+  <data name="RestoreComplete" xml:space="preserve">
+    <value>Restore complete ({0}s)</value>
+    <comment>
+      {0}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="RestoreCompleteWithMessage" xml:space="preserve">
+    <value>Restore {0} in {1}s</value>
+    <comment>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="BuildFinished" xml:space="preserve">
+    <value>Build {0} in {1}s</value>
+    <comment>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="BuildResult_FailedWithErrors" xml:space="preserve">
+    <value>failed with errors</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_FailedWithWarnings" xml:space="preserve">
+    <value>failed with warnings</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_Failed" xml:space="preserve">
+    <value>failed</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_Succeeded" xml:space="preserve">
+    <value>succeeded</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_SucceededWithWarnings" xml:space="preserve">
+    <value>succeeded with warnings</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="ProjectFinished_NoTF" xml:space="preserve">
+    <value>{0}{1} {2} ({3}s)</value>
+    <comment>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="ProjectFinished_WithTF" xml:space="preserve">
+    <value>{0}{1} {2} {3} ({4}s)</value>
+    <comment>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="ProjectFinished_OutputPath" xml:space="preserve">
+    <value> ‚Üí {0}</value>
+    <comment>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </comment>
+  </data>
+  <data name="ProjectBuilding_NoTF" xml:space="preserve">
+    <value>{0}{1} {2} ({3}s)</value>
+    <comment>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="ProjectBuilding_WithTF" xml:space="preserve">
+    <value>{0}{1} {2} {3} ({4}s)</value>
+    <comment>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="BuildFailedWithPropertiesItemsOrTargetResultsRequested" xml:space="preserve">
+    <value>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</value>
+  </data>
+  <data name="TerminalLoggerNotUsedDisabled" xml:space="preserve">
+    <value>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</value>
+  </data>
+  <data name="TerminalLoggerNotUsedNotSupported" xml:space="preserve">
+    <value>Terminal Logger was not used because the output is not supported.</value>
+  </data>
+  <data name="TerminalLoggerNotUsedRedirected" xml:space="preserve">
+    <value>Terminal Logger was not used because the output is being redirected to a file.</value>
+  </data>
+  <!-- **** TerminalLogger strings end **** -->
     <!--
         The command line message bucket is: MSB1001 - MSB1999
 
-        Next error code should be MSB1063.
+        Next error code should be MSB1067.
 
         Don't forget to update this comment after using the new code.
   -->
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 5d1c158a617..2a30dcd283d 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Sestaven√≠ se nezda≈ôilo. Nelze z√≠skat v√Ωsledky vlastnost√≠, polo≈æek a c√≠le. Viz podrobnosti ve stderr v√Ω≈°e.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Sestaven√≠ {0} za {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">ne√∫spƒõ≈°n√©</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">selhalo s chybami</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">selhalo s upozornƒõn√≠mi</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">√∫spƒõ≈°n√©</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">√∫spƒõ≈°nƒõ dokonƒçeno s upozornƒõn√≠mi</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,79 @@
         <target state="translated">MSBUILD : error MSB1027: P≈ôep√≠naƒç -noAutoResponse nelze zadat v souboru automatick√Ωch odpovƒõd√≠ MSBuild.rsp ani v ≈æ√°dn√©m jin√©m souboru odpovƒõd√≠, na kter√Ω se v souboru automatick√Ωch odpovƒõd√≠ odkazuje.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -question
+                     (experiment√°ln√≠) Dotaz, jestli je doch√°z√≠ k pr√°ci na sestaven√≠.
+                     MSBuild zobraz√≠ chybu p≈ôi zji≈°tƒõn√≠ c√≠le nebo √∫kolu
+,
+                     kter√Ω m≈Ø≈æe b√Ωt p≈ô√≠r≈Østkov√Ω (obsahuje vstupy a v√Ωstupy),
+                     ale nen√≠ aktu√°ln√≠.
+                     (Kr√°tk√Ω tvar: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Zp≈Øsob√≠, ≈æe MSBuild bude hl√°sit p≈ô√≠stupy k soubor≈Øm ve v≈°ech konfigurovan√Ωch
+                     modulech plug-in pro mezipamƒõ≈• projektu.
+
+                     Tento p≈ô√≠znak je experiment√°ln√≠ a nemus√≠ fungovat podle oƒçek√°v√°n√≠.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: Hodnota s n√≠zkou prioritou nen√≠ platn√°. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: Hodnota termin√°lov√©ho protokolovac√≠ho n√°stroje nen√≠ platn√°. Mƒõlo by to b√Ωt auto, true nebo false. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Hodnota p≈ô√≠stup≈Ø k soubor≈Øm sestavy nen√≠ platn√°. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">MSBuild verze {0} pro {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -150,25 +269,28 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageUponIsolationViolation| Nepravda]
+                     Zp≈Øsob√≠, ≈æe MSBuild sestav√≠ ka≈æd√Ω projekt v izolaci.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+Kdy≈æ se nastav√≠ na MessageUponIsolationViolation (nebo jeho kr√°tk√Ω
+                     tvar ‚ÄûZpr√°va‚Äú), jsou serializov√°ny pouze v√Ωsledky z c√≠l≈Ø nejvy≈°≈°√≠ √∫rovnƒõ
+                     pokud je dod√°n p≈ôep√≠naƒç -outputResultsCache
+.
+                     T√≠mto se zm√≠rn√≠ pravdƒõpodobnost
+                     c√≠le poru≈°uj√≠c√≠ho izolaci v projektu z√°vislosti pomoc√≠
+                     nespr√°vn√©ho stavu kv≈Øli sv√© z√°vislosti na c√≠li ulo≈æen√©m v mezipamƒõti
+,
+                     jeho≈æ vedlej≈°√≠ √∫ƒçinky by se nezohlednily.
+                     (Nap≈ô√≠klad definice vlastnosti.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                    Toto je p≈ô√≠snƒõj≈°√≠ re≈æim MSBuildu, proto≈æe vy≈æaduje
+,
+                     aby byl graf projektu staticky zjistiteln√Ω v
+                     obdob√≠ vyhodnocov√°n√≠, ale m≈Ø≈æe zlep≈°it pl√°nov√°n√≠ a sn√≠≈æit
+                     re≈æie pamƒõti p≈ôi sestavov√°n√≠ velk√© sady projekt≈Ø.
+                     (Kr√°tk√Ω tvar: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Tento p≈ô√≠znak je experiment√°ln√≠ a nemus√≠ fungovat podle oƒçek√°v√°n√≠.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -274,8 +396,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -284,11 +405,11 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
+        <target state="translated">  -warnNotAsError[:code[;code2]]
                      Seznam k√≥d≈Ø upozornƒõn√≠, kter√© se nemaj√≠ pova≈æovat za chyby.
-                     Pomoc√≠ st≈ôedn√≠ku nebo ƒç√°rky oddƒõlte
-                     v√≠ce k√≥d≈Ø upozornƒõn√≠. Nem√° ≈æ√°dn√Ω vliv, pokud p≈ôep√≠naƒç -warnaserror
+                     K oddƒõlen√≠
+ v√≠ce k√≥d≈Ø upozornƒõn√≠ pou≈æijte st≈ôedn√≠k 
+                     nebo ƒç√°rku. Nem√° ≈æ√°dn√Ω vliv, pokud p≈ôep√≠naƒç -warnaserror
                      nen√≠ nastaven√Ω.
 
                      P≈ô√≠klad:
@@ -447,20 +568,17 @@
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;protok_n√°st&gt;   Pou≈æ√≠t dan√Ω protokolovac√≠ n√°stroj k protokolov√°n√≠
-                     ud√°lost√≠ n√°stroje MSBuild. Chcete-li zadat v√≠ce protokolovac√≠ch.
-                     n√°stroj≈Ø, mus√≠te je zadat jednotlivƒõ.
-                     Syntaxe hodnoty &lt;protok_n√°st&gt;:
-                        [&lt;t≈ô√≠da_protok_n√°st&gt;,]&lt;sestaven√≠_protok_n√°st&gt;
-                        [;&lt;param_protok_n√°st&gt;]
-                     Syntaxe hodnoty &lt;t≈ô√≠da_protok_n√°st&gt;:
-                        [&lt;ƒç√°st/√∫pl_obor_n√°zv≈Ø&gt;.]&lt;n√°z_t≈ô_protok_n√°st&gt;
-                     Syntaxe hodnoty &lt;sestaven√≠_protok_n√°st&gt;:
-                        {&lt;n√°zev_sestaven√≠&gt;[,&lt;strong name&gt;] | &lt;soubor_sestaven√≠&gt;}
+        <target state="translated">  -logger:&lt;logger&gt;   Pou≈æ√≠t dan√Ω protokolovac√≠ n√°stroj k protokolov√°n√≠ ud√°lost√≠ n√°stroje MSBuild. Pokud chcete zadat 
+                     v√≠ce protokolovac√≠ch n√°stroj≈Ø, mus√≠te je zadat jednotlivƒõ.
+                     Syntaxe hodnoty &lt;logger&gt; je:
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                     Syntaxe hodnoty &lt;logger class&gt; je:
+                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
+                     Syntaxe hodnoty &lt;logger assembly&gt; je:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Parametry protokolovac√≠ho n√°stroje urƒçuj√≠, jak MSBuild vytvo≈ô√≠ protokolovac√≠ n√°stroj.
-                     Parametry &lt;param_protok_n√°st&gt; jsou voliteln√© a p≈ôed√°vaj√≠ se 
-                     protokolovac√≠mu n√°stroji p≈ôesnƒõ v tom tvaru, v jak√©m
-                     byly zad√°ny. (Kr√°tk√Ω tvar: -l)
+                     Parametry &lt;logger parameters&gt; jsou voliteln√© a p≈ôed√°vaj√≠ se
+                     protokolovac√≠mu n√°stroji p≈ôesnƒõ v tom tvaru, v jak√©m byly zad√°ny. (Kr√°tk√Ω tvar: -l)
                      P≈ô√≠klady:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
@@ -480,12 +598,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;√∫rove≈à&gt; Zobrazen√≠ dan√©ho mno≈æstv√≠ informac√≠ v protokolu
-                     ud√°lost√≠. Dostupn√© √∫rovnƒõ podrobnost√≠: q[uiet], m[inimal],
+        <target state="translated">  -verbosity:&lt;level&gt; Zobraz√≠ toto mno≈æstv√≠ informac√≠ v protokolu ud√°lost√≠.
+                     Dostupn√© √∫rovnƒõ podrobnosti: q[uiet], m[inimal],
                      n[ormal], d[etailed] a diag[nostic]. (Kr√°tk√Ω tvar: -v)
                      P≈ô√≠klad:
                        -verbosity:quiet
+
+                     Pozn√°mka: Podrobnost protokolov√°n√≠ soubor≈Ø
+                           je nastavena samostatnƒõ p≈ôes
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -534,40 +660,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleloggerparameters:&lt;parameters&gt;
+                     Parametry do protokolovac√≠ho n√°stroje konzoly. (Kr√°tk√Ω tvar: -clp)
+                     Dostupn√© parametry jsou:
+                        PerformanceSummary ‚Äì zobraz√≠ dobu zpracov√°n√≠ √∫loh, c√≠l≈Ø
+                            a projekt≈Ø.
+                        Summary ‚Äì zobraz√≠ souhrn chyb a upozornƒõn√≠ na konci.
+                        NoSummary ‚Äì nezobraz√≠ souhrny chyb a upozornƒõn√≠ na
+                            konci.
+                        ErrorsOnly ‚Äì zobraz√≠ jenom chyby.
+                        WarningsOnly ‚Äì zobraz√≠ jenom upozornƒõn√≠.
+                        NoItemAndPropertyList ‚Äì nezobraz√≠ na zaƒç√°tku sestaven√≠ ka≈æd√©ho
+                            projektu seznamy polo≈æek a vlastnost√≠.
+                        ShowCommandLine ‚Äì zobraz√≠ zpr√°vy TaskCommandLineEvent.
+                        ShowTimestamp ‚Äì p≈ôed ka≈ædou zpr√°vou zobraz√≠
+                            ƒçasov√© raz√≠tko.
+                        ShowEventId ‚Äì zobraz√≠ ID ud√°losti pro spu≈°tƒõn√© a dokonƒçen√©
+                            ud√°losti a zpr√°vy.
+                        ForceNoAlign ‚Äì nenastav9 text podle velikosti vyrovn√°vac√≠
+                            pamƒõti konzoly.
+                        DisableConsoleColor ‚Äì pou≈æije v√Ωchoz√≠ barvy konzoly
+                            pro v≈°echny zpr√°vy protokolov√°n√≠.
+                        DisableMPLogging ‚Äì zak√°≈æe v√≠ceprocesorov√Ω styl v√Ωstupu
+                            protokolov√°n√≠ p≈ôi pr√°ci v jin√©m ne≈æ v√≠ceprocesorov√©m
+                            re≈æimu.
+                        EnableMPLogging ‚Äì povol√≠ v√≠ceprocesorov√Ω styl v√Ωstupu
+                            protokolov√°n√≠ i p≈ôi pr√°ci v jin√©m
+                            re≈æimu. Tento styl protokolov√°n√≠ je v√Ωchoz√≠. 
+                        ForceConsoleColor ‚Äì pou≈æije barvy konzoly ANSI,
+                            i kdy≈æ to konzola nepodporuje.
+                        PreferConsoleColor‚Äì pou≈æije barvy konzoly ANSI, pouze pokud
+                            to c√≠lov√° konzola podporuje.
+                        Verbosity ‚Äì potlaƒç√≠ nastaven√≠ -verbosity
+                            pro tento protokolovac√≠ n√°stroj.
+                     P≈ô√≠klad:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -668,10 +794,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     St≈ôedn√≠ky oddƒõlen√Ω seznam vstupn√≠ch soubor≈Ø mezipamƒõti, kter√© MSBuild
+                     naƒçte v√Ωsledky sestaven√≠. Pokud je parametr -isolateProjects nastaven
+                     na hodnotu False, toto ho nastav√≠ na hodnotu True. (kr√°tk√Ω tvar: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -685,11 +811,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     v√Ωstupn√≠ soubor mezipamƒõti, do kter√©ho n√°stroj MSBuild zap√≠≈°e obsah
+                     mezipamƒõti v√Ωsledk≈Ø sestaven√≠ na konci sestaven√≠.
+                     Pokud je parametr -isolateProjects nastaven na hodnotu False, toto ho                                nastav√≠ na hodnotu True.
+                     (kr√°tk√Ω tvar: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -721,23 +847,20 @@
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedlogger:&lt;centr_protok_n√°st&gt;*&lt;p≈ôed√°v_protok_n√°st&gt;                     
-                     Pou≈æ√≠t zadan√Ω protokolovac√≠ n√°stroj pro protokolov√°n√≠ ud√°lost√≠
-                     z n√°stroje MSBuild; ke ka≈æd√©mu uzlu p≈ôipojit jinou instanci 
-                     protokolovac√≠ho n√°stroje. Chcete-li zadat v√≠ce 
-                     protokolovac√≠ch n√°stroj≈Ø, uveƒète je jednotlivƒõ. 
+        <target state="translated">  -distributedLogger:&lt;central logger&gt;*&lt;forwarding logger&gt;
+                     Pou≈æ√≠t zadan√Ω protokolovac√≠ n√°stroj pro protokolov√°n√≠ ud√°lost√≠ z n√°stroje MSBuild; ke ka≈æd√©mu uzlu p≈ôipojit
+                     jinou instanci protokolovac√≠ho n√°stroje. Pokud chcete zadat v√≠ce
+                     protokolovac√≠ch n√°stroj≈Ø, uveƒète je jednotlivƒõ.
                      (Kr√°tk√Ω tvar: -dl)
-                     Syntaxe hodnoty &lt;protok_n√°st&gt;:
-                        [&lt;t≈ô√≠da_protok_n√°st&gt;,]&lt;sestav_protok_n√°st&gt;
-                        [;&lt;param_protok_n√°st&gt;]
-                     Syntaxe hodnoty &lt;t≈ô√≠da_protok_n√°st&gt;:
-                        [&lt;ƒç√°st/√∫pl_obor_n√°zv≈Ø&gt;.]&lt;n√°z_t≈ô_protok_n√°st&gt;
-                     Syntaxe hodnoty &lt;sestav_protok_n√°st&gt;:
-                        {&lt;n√°zev_sestaven√≠&gt;[,&lt;strong name&gt;] | &lt;soubor_sestaven√≠&gt;}
+                     Syntaxe hodnoty &lt;logger&gt; je:
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                     Syntaxe hodnoty &lt;logger class&gt; je:
+                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
+                     Syntaxe hodnoty &lt;logger assembly&gt; je:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Parametry protokolovac√≠ho n√°stroje urƒçuj√≠, jak MSBuild vytvo≈ô√≠ protokolovac√≠ n√°stroj.
                      Parametry &lt;param_protok_n√°st&gt; jsou voliteln√© a p≈ôed√°vaj√≠ se
-                     protokolovac√≠mu n√°stroji p≈ôesnƒõ v zadan√©m tvaru.
-                     (Kr√°tk√Ω tvar: -l)
+                     protokolovac√≠mu n√°stroji p≈ôesnƒõ v zadan√©m tvaru. (Kr√°tk√Ω tvar: -l)
                      P≈ô√≠klady:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
@@ -925,7 +1048,7 @@
                                              Verbosity=diagnostic;Encoding=UTF-8
 
                        -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1198,6 +1321,33 @@
         <target state="translated">Protokoly MSBuild a informace o ladƒõn√≠ budou dostupn√© v ‚Äû{0}‚Äú</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: Je nutn√© zadat n√°zev polo≈æky pro p≈ôep√≠naƒç getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: Je nutn√© zadat n√°zev vlastnosti pro p≈ôep√≠naƒç getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: Je nutn√© zadat c√≠lov√Ω n√°zev pro p≈ôep√≠naƒç getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Zadejte protokolovac√≠ n√°stroj.</target>
@@ -1249,6 +1399,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: Pokud pou≈æ√≠v√°te p≈ôep√≠naƒç -terminalLoggerParameters, zadejte jeden nebo v√≠ce parametr≈Ø pro termin√°lov√Ω protokolovac√≠ n√°stroj.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1285,6 +1445,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: N√°zev {0} obsahuje neplatn√Ω znak {1}.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1315,6 +1482,60 @@
         <target state="translated">Proces = {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Soubor projektu neexistuje.</target>
@@ -1360,6 +1581,22 @@
         <target state="translated">{0} p≈ôi≈°la z {1}</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Obnoven√≠ dokonƒçeno ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Obnov√≠ se {0} za {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1388,6 +1625,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: P≈ôi vytv√°≈ôen√≠ soubor≈Ø ≈ôe≈°en√≠ nebo soubor≈Ø filtr≈Ø ≈ôe≈°en√≠ nelze z√≠skat p≈ô√≠stup k vlastnostem nebo polo≈æk√°m. Tato funkce je k dispozici jen p≈ôi sestavov√°n√≠ jednotliv√Ωch projekt≈Ø.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1403,6 +1648,21 @@
         <target state="translated">MSBUILD : error MSB1059: C√≠le se nepovedlo vypsat. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Termin√°lov√Ω protokolovaƒç se nepou≈æil, proto≈æe sestaven√≠ se spou≈°t√≠ v kontextu procesu (nap≈ô. dotnet test), kter√Ω po≈æaduje p≈ô√≠m√Ω p≈ô√≠stup k datov√©mu proudu stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Termin√°lov√Ω protokolovaƒç se nepou≈æil, proto≈æe v√Ωstup se nepodporuje.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Termin√°lov√Ω protokolovaƒç se nepou≈æil, proto≈æe v√Ωstup se p≈ôesmƒõrov√°v√° do souboru.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Pro tento p≈ôep√≠naƒç se nepou≈æ√≠vaj√≠ ≈æ√°dn√© parametry.</target>
@@ -1421,6 +1681,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild nejde spustit v t√©to verzi operaƒçn√≠ho syst√©mu. Podporuje se jenom v syst√©mech Windows 7 a novƒõj≈°√≠ch verz√≠ch.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">P≈ôep√≠naƒç ‚Äû{0}‚Äú se pro soubory ≈ôe≈°en√≠ nepodporuje.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Prob√≠h√° vynucen√≠ naƒçten√≠ Microsoft.Build.Engine, proto≈æe MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index f814cb4f8b9..db2e8f2c6b3 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Fehler beim Buildvorgang. Eigenschaften, Elemente und Zielergebnisse k√∂nnen nicht abgerufen werden. Details finden Sie oben in stderr.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Erstellen von {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">Fehlgeschlagen</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">Fehlgeschlagen mit Fehlern</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">Fehlgeschlagen mit Warnungen</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">Erfolgreich</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">Erfolgreich mit Warnungen</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: Der Schalter "-noAutoResponse" kann weder in der automatischen Antwortdatei "MSBuild.rsp" noch in einer anderen Antwortdatei verwendet werden, auf die die automatische Antwortdatei verweist.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -question
+                     (Experimentell) Fragen Sie, ob Buildarbeiten vorhanden sind.
+                     MSBuild f√ºhrt einen Fehler aus, wenn ein Ziel oder eine Aufgabe erkannt wird,
+                     das/die inkrementell sein kann (mit Eingaben und Ausgaben),
+                     aber nicht auf dem neuesten Stand ist.
+                     (Kurzform: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     F√ºhrt dazu, dass MSBuild Dateizugriffe auf ein beliebiges konfiguriertes
+                     Projektcache-Plug-In meldet.
+
+                     Dieses Flag ist experimentell und funktioniert m√∂glicherweise nicht wie vorgesehen.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: Der Wert mit niedriger Priorit√§t ist ung√ºltig. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: Der Terminalprotokollierungswert ist ung√ºltig. Es sollte "auto", "true" oder "false" sein. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Der Wert f√ºr den Zugriff auf die Berichtsdatei ist ung√ºltig. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">MSBuild-Version {0} f√ºr {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -150,25 +268,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageUponIsolationViolation| False]
+                     F√ºhrt dazu, dass MSBuild jedes Projekt isoliert erstellt.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+Bei Festlegung auf "MessageUponIsolationViolation" (oder die zugeh√∂rige Kurzform
+                      "Message"), werden die Resultate von Top Level-Zielen
+                     nur serialisiert, wenn der Parameter "-outputResultsCache"
+                     angegeben wurde. Dies dient dazu, die Wahrscheinlichkeit eines
+                     gegen die Isolation versto√üenden Ziels f√ºr ein Abh√§ngigkeitsprojekt mithilfe von
+                     Falscher Status aufgrund seiner Abh√§ngigkeit von einem zwischengespeicherten Ziel,
+                     dessen Nebenwirkungen nicht ber√ºcksichtigt w√ºrden, abzuschw√§chen.
+                     (Beispiel: Die Definition einer Eigenschaft.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+Dies ist ein restriktiverer Modus von MSBuild, da er erfordert,
+                     dass das Projektdiagramm zum Zeitpunkt der Auswertung statisch auffindbar ist,
+                     jedoch kann die Planung kann verbessert und
+                     der Arbeitsspeicheraufwand reduziert werden, wenn gro√üe Gruppen von Projekten erstellt werden.
+                     (Kurzform: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Dieses Kennzeichen ist experimentell und funktioniert m√∂glicherweise nicht wie vorgesehen.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -274,8 +392,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -284,14 +401,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     Liste der Warnungscodes, die nicht als Fehler behandelt werden sollen.
-                     Semikolon oder Komma zum Trennen verwenden
-                     mehrere Warnungscodes. Hat keine Auswirkungen, wenn der -warnaserror
-                     Switch nicht festgelegt ist.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Liste der Warnungscodes, die nicht als Fehler behandelt werden.
+                     Semikolon oder Komma zum Trennen 
+                     mehrerer Warnungscodes verwenden. Hat keine Auswirkungen, wenn der Switch -warnaserror
+                     nicht festgelegt ist.
 
-Beispiel:
+                     Beispiel:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -450,11 +566,11 @@ Beispiel:
         <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben, 
                      wird jede Protokollierung gesondert angegeben.
                      Die Syntax f√ºr die &lt;Protokollierung&gt; lautet:
-                       [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
+                       [&lt;Klasse&gt;,]&lt;assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
                      Die Syntax f√ºr die &lt;Protokollierungsklasse&gt; lautet:
                         [&lt;Teilweiser oder vollst√§ndiger Namespace&gt;.]&lt;Name der Protokollierungsklasse&gt;
                      Die Syntax f√ºr die &lt;Protokollierungsassembly&gt; lautet:
-                       {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
+                        {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
                      Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung √ºbergeben, wie sie eingegeben wurden. (Kurzform: -l)
@@ -477,12 +593,20 @@ Beispiel:
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;Grad&gt; Zeigt diesen Grad von Informationen im Ereignisprotokoll an.
-                     Folgende Ausf√ºhrlichkeitsgrade sind verf√ºgbar: q[uiet], m[inimal],
+        <target state="translated">  -verbosity:&lt;level&gt; Zeigt diese Menge von Informationen im Ereignisprotokoll an.
+                     Folgende Ausf√ºhrlichkeitsstufen sind verf√ºgbar: q[uiet], m[inimal],
                      n[ormal], d[etailed] und diag[nostic]. (Kurzform: -v)
                      Beispiel:
                        -verbosity:quiet
+
+Hinweis: Ausf√ºhrlichkeit der Dateiprotokollierungen
+                           wird separat festgelegt durch
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -531,40 +655,40 @@ Beispiel:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleloggerparameters:&lt;Parameter&gt;
+                     Parameter f√ºr die Konsolenprotokollierung. (Kurzform: -clp)
+                     Folgende Parameter sind verf√ºgbar:
+                        PerformanceSummary: Zeigt die in Aufgaben, Zielen und
+                            Projekten verbrachte Zeit an.
+                        Summary: Zeigt abschlie√üend eine Zusammenfassung der Fehler und Warnungen an.
+                        NoSummary: Zeigt keine Fehler- und Warnungs√ºbersicht am
+                            Ende an.
+                        ErrorsOnly: Zeigt nur Fehler an.
+                        WarningsOnly: Zeigt nur Warnungen an.
+                        NoItemAndPropertyList: Zeigt keine Liste der Elemente
+                            und Eigenschaften am Anfang jeder Projekterstellung an.
+                        ShowCommandLine: Zeigt TaskCommandLineEvent-Meldungen an. 
+                        ShowTimestamp: Zeigt den Timestamp als Pr√§fix einer
+                            Meldung an.
+                        ShowEventId: Zeigt die eventId f√ºr gestartete
+                            Ereignisse, abgeschlossene Ereignisse und Meldungen an.
+                        ForceNoAlign: Richtet den Text nicht an der Gr√∂√üe des
+                            Konsolenpuffers aus.
+                        DisableConsoleColor: Verwendet die Standardkonsolenfarben
+                            f√ºr alle Protokollierungsmeldungen.
+                        DisableMPLogging: Deaktiviert die Ausgabe wie
+                            bei der Mehrprozessorprotokollierung im Modus mit nur einem Prozessor.
+                        EnableMPLogging: Aktiviert das Format der
+                            Mehrprozessorprotokollierung auch bei der Ausf√ºhrung
+                            im Modus mit nur einem Prozessor.
+Dieses Protokollierungsformat ist standardm√§√üig aktiviert.
+                         ForceConsoleColor: Verwendet selbst dann
+                            ANSI-Konsolenfarben, wenn die Konsole dies nicht unterst√ºtzt.
+                        PreferConsoleColor: Verwendet ANSI-Konsolenfarben nur,
+                            wenn die Zielkonsole dies unterst√ºtzt.
+                     Verbosity: √úberschreibt die Einstellung f√ºr -verbosity f√ºr
+                            diese Protokollierung.
+                     Beispiel:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -665,10 +789,10 @@ Beispiel:
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Durch Semikolon getrennte Liste der Eingabecachedateien, aus denen MSBuild
+                     Buildergebnisse liest. Wenn "-isolateProjects"
+                     auf "False" festgelegt ist, wird dieser Wert auf "True" festgelegt. (Kurzform: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -682,11 +806,11 @@ Beispiel:
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     Ausgabecachedatei, in die MSBuild den Inhalt
+                     des Buildergebniscaches am Ende des Builds schreibt.
+                     Wenn "-isolateProjects" auf "False" festgelegt ist, wird diese Einstellung auf "True" festgelegt.
+                     (Kurzform: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -724,11 +848,11 @@ Beispiel:
                      gesondert angegeben.
                      (Kurzform -dl)
                      Die Syntax f√ºr die &lt;Protokollierung&gt; lautet:
-                       [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
+                       [&lt;Klasse&gt;,]&lt;assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
                      Die Syntax f√ºr die &lt;Protokollierungsklasse&gt; lautet:
                         [&lt;Teilweiser oder vollst√§ndiger Namespace&gt;.]&lt;Name der Protokollierungsklasse&gt;
                      Die Syntax f√ºr die &lt;Protokollierungsassembly&gt; lautet:
-                       {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
                      Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung √ºbergeben, wie sie eingegeben wurden. (Kurzform: -l)
@@ -1190,6 +1314,33 @@ Beispiel:
         <target state="translated">MSBuild-Protokolle und Debuginformationen befinden sich auf "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: Es muss ein Elementname f√ºr den getItem-Switch angegeben werden.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: F√ºr den getProperty-Switch muss ein Eigenschaftenname angegeben werden.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: F√ºr den GetTargetResult-Switch muss ein Zielname angegeben werden.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Geben Sie eine Protokollierung an.</target>
@@ -1241,6 +1392,16 @@ Beispiel:
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: Geben Sie mindestens einen Parameter f√ºr die Terminalprotokollierung an, wenn Sie den Schalter "-terminalLoggerParameters" verwenden.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1277,6 +1438,13 @@ Beispiel:
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: Der Name "{0}" enth√§lt ein ung√ºltiges Zeichen "{1}".</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1307,6 +1475,60 @@ Beispiel:
         <target state="translated">Prozess = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Die Projektdatei ist nicht vorhanden.</target>
@@ -1352,6 +1574,22 @@ Beispiel:
         <target state="translated">‚Äû{0}‚Äú stammt aus ‚Äû{1}‚Äú</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Wiederherstellung abgeschlossen ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Wiederherstellen von {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1380,6 +1618,14 @@ Beispiel:
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: Beim Erstellen von Projektmappendateien oder Projektmappenfilterdateien kann nicht auf Eigenschaften oder Elemente zugegriffen werden. Dieses Feature ist nur beim Erstellen einzelner Projekte verf√ºgbar.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1395,6 +1641,21 @@ Beispiel:
         <target state="translated">MSBUILD : error MSB1059: Ziele konnten nicht ausgegeben werden. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Die Terminalprotokollierung wurde nicht verwendet, da der Build im Kontext eines Prozesses (z. B. "dotnet test") ausgef√ºhrt wird, der direkten Zugriff auf den stdout-Stream anfordert.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Die Terminalprotokollierung wurde nicht verwendet, da die Ausgabe nicht unterst√ºtzt wird.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Die Terminalprotokollierung wurde nicht verwendet, da die Ausgabe an eine Datei umgeleitet wird.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Der Schalter erlaubt keine Parameter.</target>
@@ -1413,6 +1674,11 @@ Beispiel:
         <target state="translated">MSBUILD : error MSB1015: MSBuild kann unter dieser Version des Betriebssystems nicht ausgef√ºhrt werden. Nur Windows 7 und Folgeversionen werden unterst√ºtzt.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">Der Switch "{0}" wird f√ºr Projektmappendateien nicht unterst√ºtzt.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Laden von "Microsoft.Build.Engine" wird erzwungen, da MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 40f88a5277e..7fa80fd13de 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Error de compilaci√≥n. No se pueden obtener los resultados de propiedades, elementos y destinos. Vea los detalles en stderr anterior.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Compilaci√≥n {0} en {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">err√≥neo</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">error con errores</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">error con advertencias</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">realizado correctamente</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">correcto con advertencias</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: El modificador -noAutoResponse no puede especificarse en el archivo de respuesta autom√°tica MSBuild.rsp ni en ning√∫n archivo de respuesta al que el archivo de respuesta autom√°tica haga referencia.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -question
+                     (Experimental) Pregunta si hay alg√∫n trabajo de compilaci√≥n.
+                     MSBuild generar√° un error cuando detecte un destino o tarea
+                     que puede ser incremental (tiene entradas y salidas),
+                     pero no est√° actualizado.
+                     (Forma corta: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|Falso]
+                     Hace que MSBuild informe de los accesos a los archivos a cualquier
+                     complemento de cach√© de proyectos.
+
+                     Esta marca es experimental y puede que no funcione seg√∫n lo previsto.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: El valor de prioridad baja no es v√°lido. {0}.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: El valor del registrador de terminales no es v√°lido. Debe ser uno de "auto", "true", o "false".{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: el valor de acceso al archivo de informe no es v√°lido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Versi√≥n de MSBuild {0} para {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -150,25 +268,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageUponIsolationViolation| Falso]
+                     Hace que MSBuild compile cada proyecto de forma aislada.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     Cuando se establece en "MessageUponIsolationViolation" (o su valor corto
+                     forma "Mensaje"), solo los resultados de los destinos de nivel superior
+                     se serializan si el modificador -outputResultsCache es
+                     Suministrado. Esto es para mitigar las posibilidades de un
+                     destino que infringe el aislamiento en un proyecto de dependencia mediante
+                     un estado incorrecto debido a su dependencia en un destino almacenado en cach√©
+                     cuyos efectos secundarios no se tendr√°n en cuenta.
+                     (Por ejemplo, la definici√≥n de una propiedad.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     Este es un modo m√°s restrictivo de MSBuild, ya que requiere
+                     que el gr√°fico del proyecto se pueda detectar est√°ticamente en
+                     tiempo de evaluaci√≥n, pero puede mejorar la programaci√≥n y reducir
+                     la sobrecarga de memoria al compilar un gran conjunto de proyectos.
+                     (Forma corta: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Esta marca es experimental y puede que no funcione seg√∫n lo previsto.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -274,8 +392,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -284,8 +401,7 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
+        <target state="translated">  -warnNotAsError[:code[;code2]]
                      Lista de c√≥digos de advertencia para que no se traten como errores.
                      Use un punto y coma o una coma para separar
                      varios c√≥digos de advertencia. No tiene efecto si el modificador -warnaserror
@@ -448,18 +564,14 @@
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
         <target state="translated">  -logger:&lt;registrador&gt;   Use este registrador para registrar eventos
-                     de MSBuild. Para especificar varios registradores, especifique
-                     cada uno de ellos por separado.
+                     de MSBuild. Para especificar varios registradores, especifique cada uno de ellos por separado.
                      La sintaxis de &lt;registrador&gt; es:
-                       [&lt;clase&gt;,]&lt;ensamblado&gt;[,&lt;opciones&gt;][;&lt;par√°metros&gt;]
+                       [&lt;clase&gt;,]&lt;assembly&gt;[,&lt;opciones&gt;][;&lt;par√°metros&gt;]
                      La sintaxis de &lt;clase del registrador&gt; es:
-                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de
-                       clase del registrador&gt;
-                     La sintaxis de &lt;ensamblado del registrador&gt; es:
-                       {&lt;nombre del ensamblado&gt;[,&lt;strong name&gt;] | &lt;archivo
-                       de ensamblado&gt;}
-                     Las opciones del registrador especifican c√≥mo crea MSBuild
-                     el registrador.
+                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de clase del registrador&gt;
+                       La sintaxis de &lt;ensamblado del registrador&gt; es:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     Las opciones del registrador especifican c√≥mo crea MSBuild el registrador.
                      Los &lt;par√°metros del registrador&gt; son opcionales y se pasan
                      al registrador tal como se escriben. (Forma corta: -l)
                      Ejemplos:
@@ -481,12 +593,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;nivel&gt; Muestra en el registro de eventos la cantidad de informaci√≥n especificada.
+        <target state="translated">  -verbosity:&lt;level&gt; Muestra esta cantidad de informaci√≥n en el registro de eventos.
                      Los niveles de detalle disponibles son: q[uiet], m[inimal],
                      n[ormal], d[etailed] y diag[nostic]. (Forma corta: -v)
                      Ejemplo:
                        -verbosity:quiet
+
+                     Nota: nivel de detalle de los registradores de archivos
+                           se establece por separado por
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -535,40 +655,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Par√°metros del registrador de consola. (Forma corta: -clp)
+                     Los par√°metros disponibles son:
+                        PerformanceSummary: muestra el tiempo empleado en tareas, destinos
+                            y proyectos.
+                        Summary: muestra un resumen de errores y advertencias al final.
+                        NoSummary: no muestra el resumen de errores y advertencias al
+                            final.
+                        ErrorsOnly: muestra solo errores.
+                        WarningsOnly: muestra solo advertencias.
+                        NoItemAndPropertyList: no muestra la lista de elementos y
+                            propiedades al principio de cada compilaci√≥n del proyecto.
+                        ShowCommandLine: muestra los mensajes de TaskCommandLineEvent
+                        ShowTimestamp: muestra la marca de tiempo como un prefijo en los
+                            mensajes.
+                        ShowEventId: muestra el identificador de evento para los eventos iniciados, los eventos 
+                            finalizados y los mensajes.
+                        ForceNoAlign: no alinea el texto al tama√±o del
+                            b√∫fer de la consola
+                        DisableConsoleColor: usa los colores de consola predeterminados
+                            para todos los mensajes de registro.
+                        DisableMPLogging: deshabilita el estilo de registro de resultados
+                            de multiprocesador al ejecutarse en el
+                            modo de no multiprocesador.
+                        EnableMPLogging: habilita el estilo de registro de
+                            multiprocesador aunque se ejecute en el modo de
+                            no multiprocesador. Este estilo de registro est√° habilitado de forma predeterminada.
+                     ForceConsoleColor: usa los colores de consola ANSI incluso si
+                            la consola no lo admite.
+                        PreferConsoleColor--usa los colores de consola ANSI solo si
+                            la consola lo admite
+                        Verbosity: invalida el valor -verbosity para este
+                            registrador.
+                     Ejemplo:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -669,10 +789,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Lista separada por punto y coma de los archivos de cach√© de entrada que MSBuild
+                     leer√° los resultados de la compilaci√≥n. Si se establece -isolateProjects
+                     en False, esta se establece en True. (forma corta: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -686,11 +806,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[archivo-de-cach√©]
+                     Archivo de cach√© de salida donde MSBuild escribe el contenido de
+                     las memorias cach√© de resultados de compilaci√≥n cuando esta acaba.
+                     Si se establece -isolateProjects en False, esta se establece en True.
+                     (forma corta: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -728,15 +848,12 @@
                      Para especificar varios registradores, especifique cada uno
                      de ellos por separado. (Forma corta: -dl)
                      La sintaxis de &lt;registrador&gt; es:
-                       [&lt;clase&gt;,]&lt;ensamblado&gt;[,&lt;opciones&gt;][;&lt;par√°metros&gt;]
+                       [&lt;clase&gt;,]&lt;assembly&gt;[,&lt;opciones&gt;][;&lt;par√°metros&gt;]
                      La sintaxis de &lt;clase del registrador&gt; es:
-                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre
-                       de la clase del registrador&gt;
+                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de la clase del registrador&gt;
                      La sintaxis de &lt;ensamblado del registrador&gt; es:
-                       {&lt;nombre del ensamblado&gt;[,&lt;strong name&gt;] | &lt;archivo
-                      de ensamblado&gt;}
-                     Las opciones del registrador especifican c√≥mo crea MSBuild
-                     el registrador.
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     Las opciones del registrador especifican c√≥mo crea MSBuild el registrador.
                      Los &lt;par√°metros del registrador&gt; son opcionales y se pasan
                      al registrador tal como se escriben. (Forma corta: -l)
                      Ejemplos:
@@ -1197,6 +1314,33 @@
         <target state="translated">Los registros de MSBuild y la informaci√≥n de depuraci√≥n estar√°n en "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: debe proporcionar un nombre de elemento para el modificador getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: debe proporcionar un nombre de propiedad para el modificador getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: debe proporcionar un nombre de destino para el modificador getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Especifique un registrador.</target>
@@ -1248,6 +1392,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: Especifique uno o m√°s par√°metros para el registrador de terminales si utiliza la opci√≥n -terminalLoggerParameters</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1284,6 +1438,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: El nombre "{0}" contiene un car√°cter no v√°lido "{1}".</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1314,6 +1475,60 @@
         <target state="translated">Proceso: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: El archivo de proyecto no existe.</target>
@@ -1359,6 +1574,22 @@
         <target state="translated">'{0}' proced√≠a de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Restauraci√≥n completada ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Restaurar {0} en {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1387,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: no se puede tener acceso a propiedades o elementos al compilar archivos de soluci√≥n o archivos de filtro de soluciones. Esta caracter√≠stica solo est√° disponible al compilar proyectos individuales.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1402,6 +1641,21 @@
         <target state="translated">MSBUILD : error MSB1059: No se pudieron imprimir los destinos. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">No se us√≥ el terminal de Logger porque la compilaci√≥n se ejecuta en el contexto de un proceso (por ejemplo, "dotnet test") que solicita acceso directo a la secuencia stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">No se us√≥ el terminal de Logger porque no se admite la salida.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">No se us√≥ el terminal de Logger porque la salida se est√° redirigiendo a un archivo.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Este modificador no tiene ning√∫n par√°metro.</target>
@@ -1420,6 +1674,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild no se ha podido ejecutar en esta versi√≥n del sistema operativo. Solo se admite en Windows 7 y versiones posteriores.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">El modificador '{0}' no es compatible con los archivos de soluci√≥n.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Forzando la carga de Microsoft.Build.Engine porque MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 8e9dc930886..a24135e19c2 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">√âchec de la g√©n√©ration. Impossible d‚Äôobtenir les propri√©t√©s, les √©l√©ments et les r√©sultats cibles. Consultez les d√©tails dans stderr ci-dessus.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">G√©n√©rer {0} dans {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">√©chec</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">a √©chou√© avec des erreurs</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">a √©chou√© avec des avertissements</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">a r√©ussi</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">a r√©ussi avec des avertissements</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: Impossible de sp√©cifier le commutateur -noAutoResponse dans le fichier r√©ponse automatique MSBuild.rsp, ni dans aucun autre fichier r√©ponse r√©f√©renc√© par le fichier r√©ponse automatique.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -question
+                     (Exp√©rimental) Sp√©cifiez s‚Äôil existe un travail de build.
+                     MSBuild g√©n√®re une erreur lorsqu‚Äôil d√©tecte une cible ou une t√¢che
+                     qui peut √™tre incr√©mentielle (a des entr√©es et des sorties),
+                     mais n‚Äôest pas √† jour.
+                     (Forme abr√©g√©e : -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Entra√Æne le signalement par MSBuild des acc√®s par fichiers aux plug-ins
+                     de cache de projet configur√©s.
+
+                     Cet indicateur est exp√©rimental et peut ne pas fonctionner comme pr√©vu.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: la valeur basse priorit√© n‚Äôest pas valide. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: La valeur du journal du terminal n‚Äôest pas valide. Il doit s‚Äôagir de 'auto', 'true' ou 'false'. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: la valeur d‚Äôacc√®s au fichier de rapport n‚Äôest pas valide. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Version MSBuild {0} pour {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -150,25 +268,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageCalculIsolationViolation| Faux]
+                     Force MSBuild √† g√©n√©rer chaque projet en isolement.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+Lorsqu‚Äôil est d√©fini sur ¬´ MessageCalculIsolationViolation ¬ª (ou sa valeur
+                     formulaire ¬´¬†Message¬†¬ª), seuls les r√©sultats des cibles de niveau sup√©rieur
+                     sont s√©rialis√©es si le commutateur -outputResultsCache
+                     fourni. Ceci permet d‚Äôatt√©nuer les chances d‚Äôune
+                     violation d‚Äôisolation de la cible sur un projet de d√©pendance √† l‚Äôaide de
+                     √©tat incorrect en raison de sa d√©pendance sur une cible mise en cache
+                     dont les effets secondaires ne sont pas pris en compte.
+                     (Par exemple, d√©finition d‚Äôune propri√©t√©.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+Il s‚Äôagit d‚Äôun mode plus restrictif de MSBuild, car il n√©cessite
+                     que le graphe du projet soit statiquement d√©tectable sur
+                     temps d‚Äô√©valuation, mais peut am√©liorer la planification et r√©duire
+                     surcharge m√©moire lors de la g√©n√©ration d‚Äôun grand ensemble de projets.
+                     (Forme abr√©g√©e : -isolate)
 
-                     This flag is experimental and may not work as intended.
+Cet indicateur est exp√©rimental et peut ne pas fonctionner comme pr√©vu.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -274,8 +392,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -284,8 +401,7 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-     -warnNotAsError[:code[;code2]]
+        <target state="translated">  -warnNotAsError[:code[;code2]]
                      Liste des codes d‚Äôavertissement √† traiter non comme des erreurs.
                      Utiliser un point-virgule ou une virgule pour s√©parer
                      plusieurs codes d‚Äôavertissement. N‚Äôa aucun effet si -warnaserror
@@ -293,7 +409,7 @@
 
                      Exemple:
                        -warnNotAsError:MSB3026
-   </target>
+    </target>
         <note>
       LOCALIZATION: "-warnNotAsError" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -454,7 +570,7 @@
                      Syntaxe de &lt;classe de journalisation&gt;¬†:
                        [&lt;espace de noms partiels ou complets&gt;.]&lt;nom de la classe de journalisation&gt;
                      Syntaxe de &lt;assembly de journalisation&gt;¬†:
-                       {&lt;nom d'assembly&gt;[,&lt;strong name&gt;] | &lt;fichier d'assembly&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Les options de journalisation sp√©cifient la fa√ßon dont MSBuild cr√©e le journaliseur.
                      Les &lt;param√®tres de journalisation&gt; sont facultatifs. Ils sont pass√©s
                      au journaliseur tels que vous les avez tap√©s. (Forme abr√©g√©e¬†: -l)
@@ -477,12 +593,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;niveau&gt; Volume d'inform. affich√© dans le journal des √©v√©nements
-         Les niveaux de d√©tail disponibles sont¬†: q[uiet], m[inimal],
-         n[ormal], d[etailed] et diag[nostic]. (Forme abr√©g√©e¬†: -v)
-         Exemple¬†:
-           -verbosity:quiet
+        <target state="translated">  -verbosity:&lt;level&gt; Affiche cette quantit√© d‚Äôinformations dans le journal des √©v√©nements.
+                     Les niveaux de verbosit√© disponibles sont : q[uiet], m[inimal],
+                     n[ormal], d[etailed] et diag[nostic]. (Forme abr√©g√©e : -v)
+                     Exemple:
+                       -verbosity:quiet
+
+Remarque : verbosit√© des enregistreurs d‚Äô√©v√©nements de fichiers
+                           est d√©fini s√©par√©ment par
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -531,42 +655,42 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;param√®tres&gt;
+         Param√®tres du journaliseur de la console. (Forme abr√©g√©e¬†: -clp)
+         Param√®tres disponibles¬†:
+            PerformanceSummary--Affiche la dur√©e des t√¢ches, des cibles
+                et des projets.
+            Summary--R√©capitulatif des erreurs et des avertissements √† la fin.
+            NoSummary--Aucun r√©capitulatif des erreurs et des avertissements
+                √† la fin.
+            ErrorsOnly--Affiche uniquement les erreurs.
+            WarningsOnly--Affiche uniquement les avertissements.
+            NoItemAndPropertyList--N'affiche pas la liste des √©l√©ments et
+                des propri√©t√©s au d√©but de chaque build de projet.
+            ShowCommandLine--Affiche les messages de TaskCommandLineEvent
+            ShowTimestamp--Affiche l'horodatage en tant que pr√©fixe des
+                messages.
+            ShowEventId--Affiche eventId pour les √©v√©nements d√©marr√©s et
+                achev√©s ainsi que les messages
+            ForceNoAlign--N'aligne pas le texte par rapport √† la taille de la
+                m√©moire tampon de la console
+            DisableConsoleColor--Utilise les couleurs de la console par d√©faut
+                pour tous les messages de journalisation.
+            DisableMPLogging--D√©sactive le style de journalisation
+                multiprocesseur de la sortie durant l'ex√©cution en
+                mode non multiprocesseur.
+            EnableMPLogging--Active le style de journalisation multiprocesseur
+                m√™me durant l'ex√©cution en mode non
+                multiprocesseur. Style de journalisation activ√© par d√©faut.
+            ForceConsoleColor--Utilise les couleurs de la console ANSI m√™me si
+                cela n'est pas pris en charge par la console
+            PreferConsoleColor-Utilise les couleurs de console ANSI uniquement si
+                            la console cible le prend en charge
+                     Verbosity--Remplace le param√®tre -verbosity pour ce
+                            journaliseur.
+                     Exemple:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
-                                                 Verbosity=minimal
+                         Verbosity=minimal
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -665,10 +789,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Liste s√©par√©e par des points-virgules des fichiers de cache d‚Äôentr√©e que MSBuild
+                     lirea les r√©sultats de build √† partir de. Si -isolateProjects est d√©fini
+                     √† False, ce qui la d√©finit sur True. (forme abr√©g√©e : -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -682,11 +806,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     Fichier cache de sortie dans lequel MSBuild √©crit le contenu de
+                     ses caches de r√©sultats de build √† la fin de la build.
+                     Si -isolateProjects a la valeur False, la valeur est True.
+                     (forme abr√©g√©e : -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -728,7 +852,7 @@
                      Syntaxe de &lt;classe de journalisation&gt;¬†:
                        [&lt;espace de noms partiels ou complets&gt;.]&lt;nom de la classe de journalisation&gt;
                      Syntaxe de &lt;assembly de journalisation&gt;¬†:
-                       {&lt;nom d'assembly&gt;[,&lt;strong name&gt;] | &lt;fichier d'assembly&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Les options de journalisation sp√©cifient la fa√ßon dont MSBuild cr√©e le journaliseur.
                      Les &lt;param√®tres de journalisation&gt; sont facultatifs. Ils sont pass√©s
                      au journaliseur tels que vous les avez tap√©s. (Forme abr√©g√©e¬†: -l)
@@ -1190,6 +1314,33 @@
         <target state="translated">Les journaux MSBuild et les informations de d√©bogage seront au "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: Doit fournir un nom d'√©l√©ment pour le commutateur getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: Doit fournir un nom de propri√©t√© pour le commutateur getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: Doit fournir un nom de cible pour le commutateur getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Sp√©cifiez un journal.</target>
@@ -1241,6 +1392,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: sp√©cifiez un ou plusieurs param√®tres pour l‚Äôenregistreur d‚Äô√©v√©nements de terminal si vous utilisez le commutateur -terminalLoggerParameters</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1277,6 +1438,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: le nom ¬´{0}¬ª contient un caract√®re non valide ¬´{1}¬ª.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1307,6 +1475,60 @@
         <target state="translated">Processus = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Le fichier projet n'existe pas.</target>
@@ -1352,6 +1574,22 @@
         <target state="translated">'{0}' provient de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Restauration termin√©e ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Restaurer {0} en {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1380,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: Impossible d'acc√©der aux propri√©t√©s ou aux √©l√©ments lors de la cr√©ation de fichiers de solution ou de fichiers de filtre de solution. Cette fonctionnalit√© est disponible uniquement lors de la g√©n√©ration de projets individuels.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1395,6 +1641,21 @@
         <target state="translated">MSBUILD : error MSB1059: les cibles n'ont pas pu √™tre imprim√©es. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">L‚Äôenregistreur d‚Äô√©v√©nements de terminal n‚Äôa pas √©t√© utilis√©, car la build est ex√©cut√©e dans le contexte d‚Äôun processus (par exemple, 'dotnet test') qui demande un acc√®s direct au flux stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">L‚Äôenregistreur d‚Äô√©v√©nements de terminal n‚Äôa pas √©t√© utilis√©, car la sortie n‚Äôest pas prise en charge.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">L‚Äôenregistreur d‚Äô√©v√©nements du terminal n‚Äôa pas √©t√© utilis√© car la sortie est redirig√©e vers un fichier.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Ce commutateur n'accepte aucun param√®tre.</target>
@@ -1413,6 +1674,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild ne s'ex√©cute pas sur cette version du syst√®me d'exploitation. Il n'est pris en charge que sur Windows 7 et les versions ult√©rieures.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">Le commutateur '{0}' n‚Äôest pas pris en charge pour les fichiers solution.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Chargement forc√© de Microsoft.Build.Engine, car MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 68cec8932f2..4b68ece1c62 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Compilazione non riuscita. Non √® possibile ottenere propriet√†, elementi e risultati di destinazione. Vedere i dettagli in stderr sopra.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Compilazione {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">non riuscito</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">non riuscito con errori</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">non riuscito con avvisi</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">operazione riuscita</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">completato con avvisi</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: non √® possibile specificare l'opzione -noAutoResponse nel file di risposta automatica MSBuild.rsp o in file di risposta a cui il file di risposta automatica fa riferimento.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -domanda
+                     (Sperimentale) Domanda se sono presenti attivit√† di compilazione.
+                     MSBuild genera un errore quando rileva una destinazione o un'attivit√†
+                     che pu√≤ essere incrementale (con input e output),
+                     ma non √® aggiornata.
+                     (Forma breve: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Fa in modo che MSBuild segnali gli accessi ai file a qualsiasi
+                     plug-in della cache del progetto.
+
+                     Questo flag √® sperimentale e potrebbe non funzionare come previsto.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: il valore di priorit√† bassa non √® valido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: il valore del logger del terminale non √® valido. Deve essere 'auto', 'true' o 'false'. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: il valore degli accessi al file di report non √® valido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Versione di MSBuild ≈Å{0} per {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -151,25 +269,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageUponIsolationViolation| False]
+                     Fa in modo che MSBuild compili ogni progetto in isolamento.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+Se impostato su "MessageUponIsolationViolation" (o sul relativo breve
+                     modulo "Messaggio"), solo i risultati delle destinazioni di primo livello
+                     vengono serializzati se l'opzione -outputResultsCache √®
+                     Fornito. Consente di ridurre le probabilit√† di un
+                     destinazione che viola l'isolamento in un progetto di dipendenza tramite
+                     stato non corretto a causa della dipendenza da una destinazione memorizzata nella cache
+                     i cui effetti collaterali non verrebbero presi in considerazione.
+                     (Ad esempio, la definizione di una propriet√†.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+Questa √® una modalit√† pi√π restrittiva di MSBuild perch√© richiede
+                     che il grafico del progetto sia individuabile in modo statico
+                     tempo di valutazione, ma pu√≤ migliorare la pianificazione e ridurre
+                     sovraccarico di memoria durante la compilazione di un set di progetti di grandi dimensioni.
+                     (Forma breve: -isolate)
 
-                     This flag is experimental and may not work as intended.
+Questo flag √® sperimentale e potrebbe non funzionare come previsto.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -278,8 +396,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -288,14 +405,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
+        <target state="translated">  -warnNotAsError[:code[;code2]]
                      Elenco di codici di avviso da non considerare come errori.
                      Usare un punto e virgola o una virgola per separare
                      pi√π codici di avviso. Non ha alcun effetto se l‚Äôopzione -warnaserror
                      non √® impostata.
 
-Esempio:
+                     Esempio:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -460,8 +576,8 @@ Esempio:
                        [&lt;classe&gt;,]&lt;assembly&gt;[,&lt;opzioni&gt;][;&lt;parametri&gt;]
                      La sintassi di &lt;classe logger&gt; √® la seguente:
                        [&lt;spazio dei nomi parziale o completo&gt;.]&lt;nome classe logger&gt;
-                     La sintassi di &lt;assembly logger&gt; √® la seguente:
-                       {&lt;nome assembly&gt;[,&lt;strong name&gt;] | &lt;file di assembly&gt;}
+                     La sintassi di &lt;logger assembly&gt; √® la seguente:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Le opzioni di logger consentono di specificare in che modo MSBuild crea il logger.
                      I &lt;parametri logger&gt; sono facoltativi e vengono passati al
                      logger cos√¨ come vengono digitati. Forma breve: -l.
@@ -484,12 +600,20 @@ Esempio:
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;livello&gt; Visualizza la quantit√† di informazioni specificata nel log eventi.
+        <target state="translated">  -verbosity:&lt;level&gt; Visualizza questa quantit√† di informazioni nel registro eventi.
                      I livelli di dettaglio disponibili sono: q[uiet], m[inimal],
-                     n[ormal], d[etailed] e diag[nostic]. Forma breve: -v.
+                     n[ormal], d[etailed] e diag[nostic]. (Forma breve: -v)
                      Esempio:
-                     -verbosity:quiet
+                       -verbosity:quiet
+
+Nota: livello di dettaglio dei logger di file
+                           √® impostato separatamente da
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -538,40 +662,40 @@ Esempio:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parametri per il logger di console. (Forma breve: -clp)
+                     I parametri disponibili sono:
+                        PerformanceSummary: indica il tempo impiegato per le attivit√†, le destinazioni
+                            e i progetti.
+                        Summary: visualizza un riepilogo degli errori e degli avvisi alla fine.
+                        NoSummary: non visualizza un riepilogo degli errori e degli avvisi alla
+                            fine.
+                        ErrorsOnly: visualizza solo gli errori.
+                        WarningsOnly: visualizza solo gli avvisi.
+                        NoItemAndPropertyList: non visualizza l'elenco di elementi e
+                            propert√† all‚Äôinizio di ogni compilazione del progetto.
+                        ShowCommandLine: visualizza i messaggi TaskCommandLineEvent
+                        ShowTimestamp: visualizza il timestamp sotto forma di prefisso per ogni
+                            messaggio.
+                        ShowEventId: mostra l'ID evento per gli eventi iniziati, gli eventi finiti
+                            e i messaggi
+                        ForceNoAlign: non allinea il testo alle dimensioni del
+                            buffer della console
+                        DisableConsoleColor: usa i colori predefiniti della console
+                            per tutti i messaggi di registrazione.
+                        DisableMPLogging: disabilita lo stile di registrazione
+                            multiprocessore dell'output quando √® in esecuzione in
+                             modalit√† non multiprocessore.
+                        EnableMPLogging: abilita lo stile di registrazione
+                            multiprocessore anche quando √® in esecuzione in modalit√† non multiprocessore
+                            .  Si tratta dello stile di registrazione predefinito.
+                        ForceConsoleColor: usa i colori della console ANSI anche
+                            se non sono supportati dalla console.
+                        PreferConsoleColor: usa i colori della console ANSI solo se la
+                            console target li supporta.
+                     Verbosity: esegue l'override dell'impostazione per questo
                             logger.
-                     Example:
+                     Esempio:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -672,10 +796,10 @@ Esempio:
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Elenco di file di cache di input separati da punto e virgola da cui MSBuild
+                     legger√† i risultati della compilazione. Se -isolateProjects √® impostato
+                     su False, questo viene impostato su True. (forma breve: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -689,11 +813,11 @@ Esempio:
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     File della cache di output in cui MSBuild scriver√† il contenuto di
+                     cache dei risultati di compilazione al termine della compilazione.
+                     Se -isolateProjects √® impostato su False, questo viene impostato su True.
+                     (forma breve: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -734,8 +858,8 @@ Esempio:
                        [&lt;classe&gt;,]&lt;assembly&gt;[,&lt;opzioni&gt;][;&lt;parametri&gt;]
                      La sintassi di &lt;classe logger&gt; √® la seguente:
                        [&lt;spazio dei nomi parziale o completo&gt;.]&lt;nome classe logger&gt;
-                     La sintassi di &lt;assembly logger&gt; √® la seguente:
-                       {&lt;nome assembly&gt;[,&lt;strong name&gt;] | &lt;file di assembly&gt;}
+                     La sintassi di &lt;logger assembly&gt; √® la seguente:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Le opzioni di logger consentono di specificare in che modo MSBuild crea il logger.
                      I &lt;parametri logger&gt; sono facoltativi e vengono passati al
                      logger cos√¨ come vengono digitati. Forma breve: -l
@@ -854,9 +978,8 @@ Esempio:
                      √® la directory corrente. Per impostazione predefinita, ai
                      file viene assegnato il nome "MSBuild&lt;idnodo&gt;.log". Il
                      percorso dei file e altri parametri di fileLogger possono
-                     essere specificati aggiungendo l'opzione
+                     essere specificati aggiungendo l'opzione "-fileLoggerParameters".
 
-                     "-fileLoggerParameters".
                      Se il nome di un file di log viene impostato con l'opzione
                      fileLoggerParameters, il logger distribuito user√† il nome
                      file come modello e aggiunger√† l'ID del nodo per creare un
@@ -1201,6 +1324,33 @@ Esempio:
         <target state="translated">I log e le informazioni di debug di MSBuild sono contenuti in "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: √® necessario specificare un nome elemento per l'opzione getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: √® necessario specificare un nome propriet√† per l'opzione getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: √® necessario specificare un nome destinazione per l'opzione getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: specificare un logger.</target>
@@ -1252,6 +1402,16 @@ Esempio:
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: specificare uno o pi√π parametri per il logger del terminale se si usa l'opzione -terminalLoggerParameters</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1288,6 +1448,13 @@ Esempio:
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: il nome "{0}" contiene un carattere non valido "{1}".</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1318,6 +1485,60 @@ Esempio:
         <target state="translated">Processo = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: il file di progetto non esiste.</target>
@@ -1363,6 +1584,22 @@ Esempio:
         <target state="translated">'{0}' proviene da '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Ripristino completato ({0})</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Ripristinare {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1391,6 +1628,14 @@ Esempio:
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: non √® possibile accedere a propriet√† o elementi durante la compilazione di file di soluzione o file di filtro della soluzione. Questa funzionalit√† √® disponibile solo durante la compilazione di singoli progetti.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1406,6 +1651,21 @@ Esempio:
         <target state="translated">MSBUILD : error MSB1059: non √® stato possibile stampare le destinazioni. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Il logger di terminale non √® stato usato perch√© la compilazione viene eseguita nel contesto di un processo (ad esempio 'dotnet test') che richiede l'accesso diretto al flusso stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Il logger del terminale non √® stato usato perch√© l'output non √® supportato.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Il logger del terminale non √® stato usato perch√© l'output viene reindirizzato a un file.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: questa opzione non accetta parametri.</target>
@@ -1424,6 +1684,11 @@ Esempio:
         <target state="translated">MSBUILD : error MSB1015: MSBuild non pu√≤ essere eseguito su questa versione del sistema operativo. √à supportato solo in Windows 7 e versioni successive.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">L'opzione '{0}' non √® supportata per i file di soluzione.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Verr√† imposto il caricamento di Microsoft.Build.Engine perch√© MSBUILDOLDOM=1...</target>
@@ -1784,16 +2049,15 @@ Esegue la profilatura della valutazione di MSBuild e scrive
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                      Imposta queste propriet√† a livello di progetto o ne esegue
-                      l'override solo durante il ripristino e non usa le
-                      propriet√† specificate con l'argomento -property.
-                      &lt;v&gt; rappresenta il nome della propriet√† e &lt;v&gt; il
-                      valore della propriet√†. Usare il punto e virgola o la
-                      virgola per delimitare pi√π propriet√† o specificare ogni
-                      propriet√† separatamente.
-                      Forma breve: -rp.
-                      Esempio:
-                        -restoreProperty:IsRestore=true;MyProperty=value
+                     Imposta queste propriet√† a livello di progetto o ne esegue
+                     l'override solo durante il ripristino e non usa le
+                     propriet√† specificate con l'argomento -property.
+                     &lt;v&gt; rappresenta il nome della propriet√† e &lt;v&gt; il
+                     valore della propriet√†. Usare il punto e virgola o la
+                     virgola per delimitare pi√π propriet√† o specificare ogni propriet√† separatamente.
+                     (Forma breve: -rp)
+                     Esempio:
+                       -restoreProperty:IsRestore=true;MyProperty=value
     </target>
         <note>
       LOCALIZATION: "-restoreProperty" and "-rp" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index fd403b69216..e533daffc3b 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">„Éì„É´„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éó„É≠„Éë„ÉÜ„Ç£„ÄÅÈ†ÖÁõÆ„ÄÅ„Çø„Éº„Ç≤„ÉÉ„Éà„ÅÆÁµêÊûú„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„ÄÇ‰∏ä„ÅÆ stderr „ÅßË©≥Á¥∞„ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">{1} ÁßíÂæå„Å´ {0} „Çí„Éì„É´„Éâ</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">Â§±Êïó„Åó„Åæ„Åó„Åü</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">„Ç®„É©„Éº„ÅßÂ§±Êïó„Åó„Åæ„Åó„Åü</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">Â§±Êïó„Åó„ÄÅË≠¶Âëä„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">ÊàêÂäü„Åó„Åæ„Åó„Åü</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">Ë≠¶Âëä‰ªò„Åç„ÅßÊàêÂäü</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp Ëá™ÂãïÂøúÁ≠î„Éï„Ç°„Ç§„É´„ÇÑ„ÄÅËá™ÂãïÂøúÁ≠î„Éï„Ç°„Ç§„É´„Å´„Çà„Å£„Å¶ÂèÇÁÖß„Åï„Çå„ÇãÂøúÁ≠î„Éï„Ç°„Ç§„É´„Å´ -noAutoResponse „Çπ„Ç§„ÉÉ„ÉÅ„ÇíÊåáÂÆö„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -question
+                     (Ë©¶È®ìÊÆµÈöé) „Éì„É´„Éâ‰ΩúÊ•≠„Åå„ÅÇ„Çã„Åã„Å©„ÅÜ„Åã„Å´Èñ¢„Åô„ÇãË≥™Âïè„ÄÇ
+                     „Çø„Éº„Ç≤„ÉÉ„Éà„Åæ„Åü„ÅØ„Çø„Çπ„ÇØ„ÅåÊ§úÂá∫„Åï„Çå„Çã„Å® MSBuild „Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó
+                     „Ç§„É≥„ÇØ„É™„É°„É≥„Çø„É´„Åß„ÅÇ„ÇãÂèØËÉΩÊÄß„ÅØ„ÅÇ„Çã„Åå (ÂÖ•Âäõ„Å®Âá∫Âäõ„ÇíÂê´„ÇÄ)„ÄÅ
+                     ÊúÄÊñ∞„ÅÆÁä∂ÊÖã„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
+                     (Áü≠Á∏ÆÂΩ¢: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuild „Åå„ÄÅÊßãÊàê„Åï„Çå„Å¶„ÅÑ„Çã„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Ç≠„É£„ÉÉ„Ç∑„É• „Éó„É©„Ç∞„Ç§„É≥„Å∏„ÅÆ
+                     „Éï„Ç°„Ç§„É´ „Ç¢„ÇØ„Çª„Çπ„ÇíÂ†±Âëä„Åô„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ
+
+                     „Åì„ÅÆ„Éï„É©„Ç∞„ÅØÂÆüÈ®ìÁöÑ„Å™„ÇÇ„ÅÆ„Åß„ÅÇ„Çä„ÄÅÊÑèÂõ≥„Åó„Åü„Å®„Åä„Çä„Å´Âãï‰Ωú„Åó„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: ‰ΩéÂÑ™ÂÖàÂ∫¶ÂÄ§„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: „Çø„Éº„Éü„Éä„É´ „É≠„Ç¨„Éº„ÅÆÂÄ§„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ'auto'„ÄÅ'true'„ÄÅ„Åæ„Åü„ÅØ 'false' „ÅÆ„ÅÑ„Åö„Çå„Åã„Åß„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: „É¨„Éù„Éº„Éà „Éï„Ç°„Ç§„É´„ÅÆ„Ç¢„ÇØ„Çª„ÇπÂÄ§„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">MSBuild „ÅÆ„Éê„Éº„Ç∏„Éß„É≥ {0} ({1})</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -150,25 +268,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     MSBuild „ÅßÂêÑ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíÂàÜÈõ¢„Åó„Å¶„Éì„É´„Éâ„Åô„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     "MessageUponIsolationViolation" („Åæ„Åü„ÅØ„Åù„ÅÆÁü≠Á∏ÆÂΩ¢
+                     "Message") „Å´Ë®≠ÂÆö„Åó„ÅüÂ†¥Âêà„ÄÅÊúÄ‰∏ä‰Ωç„É¨„Éô„É´„ÅÆ„Çø„Éº„Ç≤„ÉÉ„Éà„Åã„Çâ„ÅÆÁµêÊûú„ÅÆ„Åø
+                     -outputResultsCache „Çπ„Ç§„ÉÉ„ÉÅ„Åå‰æõÁµ¶„Åï„Çå„ÅüÂ†¥Âêà„Å´„Ç∑„É™„Ç¢„É´Âåñ„Åï„Çå„Åæ„Åô„ÄÇ
+                     „Åì„Çå„ÅØ„ÄÅÊ¨°„ÅÆÂèØËÉΩÊÄß„ÇíËªΩÊ∏õ„Åô„Çã„Åü„ÇÅ„Åß„Åô:
+                     „Çø„Éº„Ç≤„ÉÉ„Éà„Åå„Ç≠„É£„ÉÉ„Ç∑„É•„Åï„Çå„Åü„Çø„Éº„Ç≤„ÉÉ„Éà„Å∏„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„ÅåÂéüÂõ†„Åß
+                     Áä∂ÊÖã„ÅåÊ≠£„Åó„Åè„Å™„Åè„ÄÅ‰æùÂ≠òÈñ¢‰øÇ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÂàÜÈõ¢ÈÅïÂèç„ÅÆÂ†¥Âêà„ÄÅ
+                     „Åù„ÅÆÂâØ‰ΩúÁî®„ÅØËÄÉÊÖÆ„Åï„Çå„Åæ„Åõ„Çì„ÄÇ
+                     („Åü„Å®„Åà„Å∞„ÄÅ„Éó„É≠„Éë„ÉÜ„Ç£„ÅÆÂÆöÁæ©„Å™„Å©)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     „Åì„Çå„ÅØ MSBuild „ÅÆ„Çà„ÇäÂà∂Èôê„ÅÆÂé≥„Åó„ÅÑ„É¢„Éº„Éâ„Åß„Åô„ÄÇ
+                     „Éó„É≠„Ç∏„Çß„ÇØ„Éà „Ç∞„É©„Éï„ÅåË©ï‰æ°ÊôÇ„Å´ÈùôÁöÑ„Å´Ê§úÂá∫ÂèØËÉΩ„Å™ÂøÖË¶ÅÊÄß„Åå„ÅÇ„Çä„ÄÅ
+                     „Çπ„Ç±„Ç∏„É•„Éº„É´„ÇíÊîπÂñÑ„Åó„ÄÅ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÂ§ßË¶èÊ®°„Å™„Çª„ÉÉ„Éà„Çí„Éì„É´„Éâ„Åô„Çã„Å®„Åç
+                     „ÅÆ„É°„É¢„É™ „Ç™„Éº„Éê„Éº„Éò„ÉÉ„ÉâÂâäÊ∏õ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Åü„ÇÅ„Åß„Åô„ÄÇ
+                     (Áü≠Á∏ÆÂΩ¢: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     „Åì„ÅÆ„Éï„É©„Ç∞„ÅØË©¶È®ìÊÆµÈöé„Åß„ÅÇ„Çã„Åü„ÇÅ„ÄÅÊÑèÂõ≥„Åó„Åü„Å®„Åä„Çä„Å´Âãï‰Ωú„Åó„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -274,8 +392,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -284,12 +401,11 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     „Ç®„É©„Éº„Å®„Åó„Å¶Êâ±„Çè„Å™„ÅÑË≠¶Âëä„Ç≥„Éº„Éâ„ÅÆ„É™„Çπ„Éà.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     „Ç®„É©„Éº„Å®„Åó„Å¶Êâ±„Çè„Å™„ÅÑË≠¶Âëä„Ç≥„Éº„Éâ„ÅÆ„É™„Çπ„Éà„ÄÇ
                      „Çª„Éü„Ç≥„É≠„É≥„Åæ„Åü„ÅØ„Ç≥„É≥„Éû„Çí‰ΩøÁî®„Åó„Å¶„ÄÅË§áÊï∞„ÅÆË≠¶Âëä„Ç≥„Éº„Éâ
-                     Âå∫Âàá„Çä„Åæ„Åô„ÄÇ-warnaserror „Çπ„Ç§„ÉÉ„ÉÅ„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà
-                     ÂäπÊûú„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
+                     „ÇíÂå∫Âàá„Çä„Åæ„Åô„ÄÇ-warnaserror „Çπ„Ç§„ÉÉ„ÉÅ„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà
+                     ÂäπÊûú„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì
 
                      ‰æã:
                        -warnNotAsError:MSB3026
@@ -477,12 +593,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;level&gt; „Ç§„Éô„É≥„Éà „É≠„Ç∞„Å´Ë°®Á§∫„Åô„ÇãÊÉÖÂ†±Èáè„Åß„Åô„ÄÇ
-                     Âà©Áî®ÂèØËÉΩ„Å™Ë©≥Á¥∞„É¨„Éô„É´: q[uiet]„ÄÅm[inimal]„ÄÅ
-                     n[ormal]„ÄÅd[etailed]„ÄÅdiag[nostic]„ÄÇ(Áü≠Á∏ÆÂΩ¢: -v)
-                     ‰æã:
+        <target state="translated">  -verbosity:&lt;level&gt; „Åì„ÅÆÈáè„ÅÆÊÉÖÂ†±„Çí„Ç§„Éô„É≥„Éà „É≠„Ç∞„Å´Ë°®Á§∫„Åó„Åæ„Åô„ÄÇ
+                     Âà©Áî®ÂèØËÉΩ„Å™Ë©≥Á¥∞„É¨„Éô„É´: q[uiet], m[inimal]„ÄÅ
+                     n[ormal], d[etailed]„ÄÅ„Åä„Çà„Å≥ diag[nostic]„ÄÇ(Áü≠Á∏ÆÂΩ¢: -v)
+                     ‰æã: 
                        -verbosity:quiet
+
+                     Ê≥®ÊÑè: „Éï„Ç°„Ç§„É´ „É≠„Ç¨„Éº„ÅÆË©≥Á¥∞Â∫¶„ÅØ
+                           ‰ª•‰∏ã„Å´„Çà„Å£„Å¶ÂÄãÂà•„Å´Ë®≠ÂÆö„Åï„Çå„Åæ„Åô
+                           -fileloggerparameters„ÄÇ
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -531,40 +655,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     „Ç≥„É≥„ÇΩ„Éº„É´ „É≠„Ç¨„Éº„Å∏„ÅÆ„Éë„É©„É°„Éº„Çø„Éº„Åß„Åô„ÄÇ(Áü≠Á∏ÆÂΩ¢: -clp)
+                     Âà©Áî®ÂèØËÉΩ„Å™„Éë„É©„É°„Éº„Çø„Éº: 
+                        PerformanceSummary--„Çø„Çπ„ÇØ„ÄÅ„Çø„Éº„Ç≤„ÉÉ„Éà„ÄÅ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Å´„Åã„Åã„Å£„ÅüÊôÇÈñì„Çí
+                            Ë°®Á§∫„Åó„Åæ„Åô„ÄÇ
+                        Summary--ÊúÄÂæå„Å´„Ç®„É©„Éº„Å®Ë≠¶Âëä„ÅÆÊ¶ÇË¶Å„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ
+                        NoSummary--ÊúÄÂæå„Å´„Ç®„É©„Éº„Å®Ë≠¶Âëä„ÅÆÊ¶ÇË¶Å„ÇíË°®Á§∫
+                            „Åó„Åæ„Åõ„Çì„ÄÇ
+                        ErrorsOnly--„Ç®„É©„Éº„ÅÆ„Åø„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ
+                        WarningsOnly--Ë≠¶Âëä„ÅÆ„Åø„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ
+                        NoItemAndPropertyList--ÂêÑ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ„Éì„É´„ÉâÈñãÂßãÊôÇ„Å´„ÄÅ
+                            È†ÖÁõÆ„Å®„Éó„É≠„Éë„ÉÜ„Ç£„ÅÆ„É™„Çπ„Éà„ÇíË°®Á§∫„Åó„Åæ„Åõ„Çì„ÄÇ
+                        ShowCommandLine--TaskCommandLineEvent „É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫„Åó„Åæ„Åô
+                        ShowTimestamp--Timestamp „Çí‰ªªÊÑè„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Å∏„ÅÆ„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„Å®„Åó„Å¶
+                            Ë°®Á§∫„Åó„Åæ„Åô„ÄÇ
+                        ShowEventId--ÈñãÂßã„Åï„Çå„Åü„Ç§„Éô„É≥„Éà„ÄÅÁµÇ‰∫Ü„Åó„Åü„Ç§„Éô„É≥„Éà„ÄÅ
+                            „É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ eventId „ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ
+                        ForceNoAlign--„ÉÜ„Ç≠„Çπ„Éà„Çí„ÄÅ„Ç≥„É≥„ÇΩ„Éº„É´ „Éê„ÉÉ„Éï„Ç°„Éº„ÅÆ
+                            „Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Åæ„Åõ„Çì
+                        DisableConsoleColor--„Åô„Åπ„Å¶„ÅÆ„É≠„Ç∞ „É°„ÉÉ„Çª„Éº„Ç∏„Å´ÂØæ„Åó„Å¶
+                            Êó¢ÂÆö„ÅÆ„Ç≥„É≥„ÇΩ„Éº„É´ „Ç´„É©„Éº„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ
+                        DisableMPLogging-- Èùû„Éû„É´„ÉÅ„Éó„É≠„Çª„ÉÉ„Çµ „É¢„Éº„Éâ„Åß
+                            ÂÆüË°å„Åô„ÇãÈöõ„ÄÅ„Éû„É´„ÉÅ„Éó„É≠„Çª„ÉÉ„Çµ„ÅÆ
+                            Âá∫Âäõ„É≠„Ç∞ÂΩ¢Âºè„ÇíÁÑ°Âäπ„Å´„Åó„Åæ„Åô„ÄÇ
+                        EnableMPLogging--Èùû„Éû„É´„ÉÅ„Éó„É≠„Çª„ÉÉ„Çµ „É¢„Éº„Éâ„Åß
+                            ÂÆüË°å„Åô„ÇãÂ†¥Âêà„ÇÇ„ÄÅ„Éû„É´„ÉÅ„Éó„É≠„Çª„ÉÉ„Çµ„ÅÆ„É≠„Ç∞ÂΩ¢Âºè„ÇíÊúâÂäπ„Å´„Åó„Åæ„Åô„ÄÇ
+                            „Åì„ÅÆ„É≠„Ç∞ÂΩ¢Âºè„ÅØ„ÄÅÊó¢ÂÆö„ÅßÊúâÂäπ„Åß„Åô„ÄÇ
+                        ForceConsoleColor--„Ç≥„É≥„ÇΩ„Éº„É´„Åß„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„Åß„ÇÇ„ÄÅ
+                            ANSI „Ç≥„É≥„ÇΩ„Éº„É´ „Ç´„É©„Éº„Çí‰ΩøÁî®„Åó„Åæ„Åô
+                        PreferConsoleColor--„Çø„Éº„Ç≤„ÉÉ„Éà „Ç≥„É≥„ÇΩ„Éº„É´„Åß„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„Åø
+                            ANSI „Ç≥„É≥„ÇΩ„Éº„É´ „Ç´„É©„Éº„Çí‰ΩøÁî®„Åó„Åæ„Åô
+                     Verbosity--„Åì„ÅÆ„É≠„Ç¨„Éº„ÅÆ -verbosity Ë®≠ÂÆö„Çí
+                            ‰∏äÊõ∏„Åç„Åó„Åæ„Åô„ÄÇ
+                     ‰æã::
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -665,10 +789,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     MSBuild „ÅåÂÖ•Âäõ„Ç≠„É£„ÉÉ„Ç∑„É• „Éï„Ç°„Ç§„É´„ÅÆ„Çª„Éü„Ç≥„É≠„É≥Âå∫Âàá„Çä„ÅÆ‰∏ÄË¶ß„ÅÆ
+                     „Éì„É´„ÉâÁµêÊûú„ÅÆË™≠„ÅøÂèñ„ÇäÂÖÉ„ÄÇ-isolateProjects „Åå
+                     False „Å´Ë®≠ÂÆö„Åï„Çå„ÅüÂ†¥Âêà„ÄÅTrue „Å´Ë®≠ÂÆö„Åï„Çå„Åæ„Åô„ÄÇ(Áü≠Á∏ÆÂΩ¢: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -682,11 +806,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                      MSBuild „Åå„Éì„É´„Éâ„ÅÆÁµÇ‰∫ÜÊôÇ„Å´„Éì„É´„ÉâÁµêÊûú„Ç≠„É£„ÉÉ„Ç∑„É•
+                     „ÅÆÂÜÖÂÆπ„ÇíÊõ∏„ÅçËæº„ÇÄÂá∫Âäõ„Ç≠„É£„ÉÉ„Ç∑„É• „Éï„Ç°„Ç§„É´„ÄÇ
+                     -isolateProjects „Åå False „Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅTrue „Å´Ë®≠ÂÆö„Åï„Çå„Åæ„Åô„ÄÇ
+                     (Áü≠Á∏ÆÂΩ¢: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1190,6 +1314,33 @@
         <target state="translated">MSBuild „ÅÆ„É≠„Ç∞„Å®„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÅØ„ÄÅ"{0}" „Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: getItem „Çπ„Ç§„ÉÉ„ÉÅ„Å´È†ÖÁõÆÂêç„ÇíÊåáÂÆö„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: getProperty „Çπ„Ç§„ÉÉ„ÉÅ„Å´„Éó„É≠„Éë„ÉÜ„Ç£Âêç„ÇíÊåáÂÆö„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult „Çπ„Ç§„ÉÉ„ÉÅ„Å´„Çø„Éº„Ç≤„ÉÉ„ÉàÂêç„ÇíÊåáÂÆö„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Logger „ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
@@ -1241,6 +1392,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters „Çπ„Ç§„ÉÉ„ÉÅ„Çí‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åì„ÅÆ„Çπ„Ç§„ÉÉ„ÉÅ„Å´„Çø„Éº„Éü„Éä„É´ „É≠„Ç¨„Éº„ÅÆ„Éë„É©„É°„Éº„Çø„Éº„Çí 1 „Å§‰ª•‰∏äÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1277,6 +1438,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: ÂêçÂâç "{0}" „Å´ÁÑ°Âäπ„Å™ÊñáÂ≠ó "{1}" „ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1307,6 +1475,60 @@
         <target state="translated">„Éó„É≠„Çª„Çπ = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} Áßí)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} Áßí)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} Áßí)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} Áßí)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: „Éó„É≠„Ç∏„Çß„ÇØ„Éà „Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ</target>
@@ -1352,6 +1574,22 @@
         <target state="translated">`{0}`„Åã„Çâ„ÅÆ `{1}`</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Âæ©ÂÖÉ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü ({0} Áßí)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">{1} ÁßíÂæå„Å´ {0} „ÇíÂæ©ÂÖÉ„Åô„Çã</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1380,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´„Åæ„Åü„ÅØ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç£„É´„Çø„Éº „Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê„Åô„Çã„Å®„Åç„Å´„Éó„É≠„Éë„ÉÜ„Ç£„ÇÑÈ†ÖÁõÆ„Å´„Ç¢„ÇØ„Çª„Çπ„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ„Åì„ÅÆÊ©üËÉΩ„ÅØ„ÄÅÂÄã„ÄÖ„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Çí„Éì„É´„Éâ„Åô„ÇãÂ†¥Âêà„Å´„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1395,6 +1641,21 @@
         <target state="translated">MSBUILD : error MSB1059: „Çø„Éº„Ç≤„ÉÉ„Éà„ÇíÂá∫Âäõ„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ{0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">„Éì„É´„Éâ„ÅØ stdout „Çπ„Éà„É™„Éº„É†„Å∏„ÅÆÁõ¥Êé•„Ç¢„ÇØ„Çª„Çπ„ÇíË¶ÅÊ±Ç„Åô„Çã„Éó„É≠„Çª„Çπ (‰æã: 'dotnet test') „ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅßÂÆüË°å„Åï„Çå„Çã„Åü„ÇÅ„ÄÅ„Çø„Éº„Éü„Éä„É´ „É≠„Ç¨„Éº„ÅØ‰ΩøÁî®„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Âá∫Âäõ„Åå„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅ„ÄÅ„Çø„Éº„Éü„Éä„É´ „É≠„Ç¨„Éº„ÅØ‰ΩøÁî®„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Âá∫Âäõ„Åå„Éï„Ç°„Ç§„É´„Å´„É™„ÉÄ„Ç§„É¨„ÇØ„Éà„Åï„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ„Çø„Éº„Éü„Éä„É´ „É≠„Ç¨„Éº„ÅØ‰ΩøÁî®„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: „Åì„ÅÆ„Çπ„Ç§„ÉÉ„ÉÅ„Å´„ÅØ„Éë„É©„É°„Éº„Çø„Éº„ÇíÊåáÂÆö„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
@@ -1413,6 +1674,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild „ÅØ„Åì„ÅÆ„Éê„Éº„Ç∏„Éß„É≥„ÅÆ„Ç™„Éö„É¨„Éº„ÉÜ„Ç£„É≥„Ç∞ „Ç∑„Çπ„ÉÜ„É†„Åß„ÅØÂÆüË°å„Åß„Åç„Åæ„Åõ„Çì„ÄÇWindows 7 „Åä„Çà„Å≥„Åù„Çå‰ª•Èôç„ÅÆ„Éê„Éº„Ç∏„Éß„É≥„Åß„ÅÆ„Åø„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">'{0}' „Çπ„Ç§„ÉÉ„ÉÅ„ÅØ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ „Éï„Ç°„Ç§„É´„Åß„ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">MSBUILDOLDOM=1 „ÅÆ„Åü„ÇÅ„ÄÅMicrosoft.Build.Engine „ÇíÂº∑Âà∂ÁöÑ„Å´Ë™≠„ÅøËæº„Çì„Åß„ÅÑ„Åæ„Åô...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 7c1bc406e1e..b94bd228977 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">ÎπåÎìúÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. ÏÜçÏÑ±, Ìï≠Î™© Î∞è ÎåÄÏÉÅ Í≤∞Í≥ºÎ•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§. ÏúÑÏùò stderrÏóêÏÑú ÏÑ∏Î∂Ä Ï†ïÎ≥¥Î•º Ï∞∏Ï°∞ÌïòÏÑ∏Ïöî.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">{0} ÎπåÎìú({1}Ï¥à)</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">Ïã§Ìå®</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">Ïã§Ìå®(Ïò§Î•ò Î∞úÏÉù)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">Ïã§Ìå®(Í≤ΩÍ≥† Î∞úÏÉù)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">ÏÑ±Í≥µ</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">ÏÑ±Í≥µ(Í≤ΩÍ≥† Î∞úÏÉù)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp ÏûêÎèô ÏßÄÏãú ÌååÏùºÍ≥º ÏûêÎèô ÏßÄÏãú ÌååÏùºÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî Î™®Îì† ÏßÄÏãú ÌååÏùºÏóêÎäî -noAutoResponse Ïä§ÏúÑÏπòÎ•º ÏßÄÏ†ïÌï† Ïàò ÏóÜÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -question
+                     (Ïã§Ìóò) ÎπåÎìú ÏûëÏóÖÏù¥ ÏûàÎäîÏßÄ ÏßàÎ¨∏Ìï©ÎãàÎã§.
+                     Ï¶ùÎ∂ÑÌï† Ïàò ÏûàÏßÄÎßå(ÏûÖÎ†• Î∞è Ï∂úÎ†•Ïù¥ ÏûàÏùå)
+                     ÏµúÏã† ÏÉÅÌÉúÍ∞Ä ÏïÑÎãå ÎåÄÏÉÅ ÎòêÎäî ÏûëÏóÖÏùÑ Í∞êÏßÄÌïòÎ©¥
+                     MSBuildÏóêÏÑú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌï©ÎãàÎã§.
+                     (ÏïΩÏãù: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuildÏóêÏÑú Î™®Îì† Íµ¨ÏÑ±Îêú ÌîÑÎ°úÏ†ùÌä∏ Ï∫êÏãú ÌîåÎü¨Í∑∏ Ïù∏Ïóê ÎåÄÌïú
+                     ÌååÏùº Ïï°ÏÑ∏Ïä§Î•º Î≥¥Í≥†ÌïòÎèÑÎ°ù Ìï©ÎãàÎã§.
+
+                     Ïù¥ ÌîåÎûòÍ∑∏Îäî Ïã§ÌóòÏ†ÅÏù¥Î©∞ ÏòàÏÉÅÎåÄÎ°ú ÏûëÎèôÌïòÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: ÎÇÆÏùÄ Ïö∞ÏÑ† ÏàúÏúÑ Í∞íÏù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞ Í∞íÏù¥ ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§. 'auto', 'true' ÎòêÎäî 'false' Ï§ë ÌïòÎÇòÏó¨Ïïº Ìï©ÎãàÎã§. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Î≥¥Í≥†ÏÑú ÌååÏùº Ïï°ÏÑ∏Ïä§ Í∞íÏù¥ ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">msbuild Î≤ÑÏ†Ñ {0}({1}Ïö©)</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -150,25 +268,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     MSBuildÍ∞Ä Í∞Å ÌîÑÎ°úÏ†ùÌä∏Î•º Í≤©Î¶¨ Î™®ÎìúÎ°ú ÎπåÎìúÌïòÎèÑÎ°ù Ìï©ÎãàÎã§.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     "MessageUponIsolationViolation"(ÎòêÎäî ÏïΩÏãù "Message")ÏúºÎ°ú
+                     ÏÑ§Ï†ïÌïòÎ©¥ -outputResultsCache Ïä§ÏúÑÏπòÍ∞Ä Ï†úÍ≥µÎêòÎäî
+                     Í≤ΩÏö∞ ÏµúÏÉÅÏúÑ ÏàòÏ§Ä ÎåÄÏÉÅÏùò Í≤∞Í≥ºÎßå ÏßÅÎ†¨ÌôîÎê©ÎãàÎã§.
+                     Ïù¥Îäî Î∂ÄÏûëÏö©Ïù¥ Í≥†Î†§ÎêòÏßÄ ÏïäÎäî Ï∫êÏãúÎêú ÎåÄÏÉÅÏóê ÎåÄÌïú
+                     Ï¢ÖÏÜçÏÑ±ÏúºÎ°ú Ïù∏Ìï¥ ÏûòÎ™ªÎêú ÏÉÅÌÉúÎ•º ÏÇ¨Ïö©ÌïòÎäî Ï¢ÖÏÜçÏÑ±
+                     ÌîÑÎ°úÏ†ùÌä∏Ïùò Í≤©Î¶¨ ÏúÑÎ∞ò ÎåÄÏÉÅ Ï°¥Ïû¨ Í∞ÄÎä•ÏÑ±ÏùÑ
+                     ÏôÑÌôîÌïòÍ∏∞ ÏúÑÌïú Í≤ÉÏûÖÎãàÎã§.
+                     (Ïòà: ÏÜçÏÑ± Ï†ïÏùò)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     Ïù¥ Î™®ÎìúÎäî ÌèâÍ∞Ä Ïãú ÌîÑÎ°úÏ†ùÌä∏ Í∑∏ÎûòÌîÑÎ•º Ï†ïÏ†ÅÏúºÎ°ú
+                     Í≤ÄÏÉâÌï† Ïàò ÏûàÏñ¥Ïïº ÌïòÎØÄÎ°ú Î≥¥Îã§ Ï†úÌïúÏ†ÅÏù∏ MSBuild
+                     Î™®ÎìúÏù¥ÏßÄÎßå ÎåÄÍ∑úÎ™® ÌîÑÎ°úÏ†ùÌä∏ ÏßëÌï©ÏùÑ ÎπåÎìúÌï† Îïå ÏòàÏïΩ
+                     Í∏∞Îä•ÏùÑ Í∞úÏÑ†ÌïòÍ≥† Î©îÎ™®Î¶¨ Ïò§Î≤ÑÌó§ÎìúÎ•º Ï§ÑÏùº Ïàò ÏûàÏäµÎãàÎã§.
+                     (ÏïΩÏãù: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Ïù¥ ÌîåÎûòÍ∑∏Îäî Ïã§ÌóòÏ†ÅÏù¥Î©∞ ÏùòÎèÑÌïú ÎåÄÎ°ú ÏûëÎèôÌïòÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -274,8 +392,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -284,16 +401,15 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-       -warnNotAsError[:code[;code2]]
+        <target state="translated">  -warnNotAsError[:code[;code2]]
                      Ïò§Î•òÎ°ú Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùÑ Í≤ΩÍ≥† ÏΩîÎìú Î™©Î°ùÏûÖÎãàÎã§.
-                     ÏÑ∏ÎØ∏ÏΩúÎ°†Ïù¥ÎÇò ÏâºÌëúÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Íµ¨Î∂ÑÌïòÏÑ∏Ïöî.
-                     Ïó¨Îü¨ Í≤ΩÍ≥† ÏΩîÎìú. -warnaserror
- Ïä§ÏúÑÏπòÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏßÄ ÏïäÏúºÎ©¥ Ìö®Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.
+                     ÏÑ∏ÎØ∏ÏΩúÎ°†Ïù¥ÎÇò ÏâºÌëúÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Ïó¨Îü¨ Í≤ΩÍ≥† ÏΩîÎìúÎ•º
+                     Íµ¨Î∂ÑÌï©ÎãàÎã§. -warnaserror Ïä§ÏúÑÏπòÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏßÄ
+                     ÏïäÏúºÎ©¥ Ìö®Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.
 
                      Ïòà:
-                     -warnNotAsError:MSB3026
-   </target>
+                       -warnNotAsError:MSB3026
+    </target>
         <note>
       LOCALIZATION: "-warnNotAsError" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -450,11 +566,11 @@
         <target state="translated">  -logger:&lt;Î°úÍ±∞&gt;   Ïù¥ Î°úÍ±∞Î•º ÏÇ¨Ïö©ÌïòÏó¨ MSBuildÏùò Ïù¥Î≤§Ìä∏Î•º Í∏∞Î°ùÌï©ÎãàÎã§. Ïó¨Îü¨
                      Î°úÍ±∞Î•º ÏßÄÏ†ïÌïòÎ†§Î©¥ Í∞Å Î°úÍ±∞Î•º Í∞úÎ≥ÑÏ†ÅÏúºÎ°ú ÏßÄÏ†ïÌï©ÎãàÎã§.
                      &lt;Î°úÍ±∞&gt; Íµ¨Î¨∏ÏùÄ Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§.
-                       [&lt;ÌÅ¥ÎûòÏä§&gt;,]&lt;Ïñ¥ÏÖàÎ∏îÎ¶¨&gt;[,&lt;ÏòµÏÖò&gt;][;&lt;Îß§Í∞ú Î≥ÄÏàò&gt;]
+                       [&lt;ÌÅ¥ÎûòÏä§&gt;,]&lt;assembly&gt;[,&lt;ÏòµÏÖò&gt;][;&lt;Îß§Í∞ú Î≥ÄÏàò&gt;]
                      &lt;Î°úÍ±∞ ÌÅ¥ÎûòÏä§&gt; Íµ¨Î¨∏ÏùÄ Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§.
                        [&lt;Î∂ÄÎ∂Ñ ÎòêÎäî Ï†ÑÏ≤¥ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§&gt;.]&lt;Î°úÍ±∞ ÌÅ¥ÎûòÏä§ Ïù¥Î¶Ñ&gt;
                      &lt;Î°úÍ±∞ Ïñ¥ÏÖàÎ∏îÎ¶¨&gt; Íµ¨Î¨∏ÏùÄ Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§.
-                       {&lt;Ïñ¥ÏÖàÎ∏îÎ¶¨ Ïù¥Î¶Ñ&gt;[,&lt;strong name&gt;] | &lt;Ïñ¥ÏÖàÎ∏îÎ¶¨ ÌååÏùº&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Î°úÍ±∞ ÏòµÏÖòÏùÄ MSBuildÍ∞Ä Î°úÍ±∞Î•º ÎßåÎìúÎäî Î∞©Î≤ïÏùÑ ÏßÄÏ†ïÌï©ÎãàÎã§.
                      &lt;Î°úÍ±∞ Îß§Í∞ú Î≥ÄÏàò&gt;Îäî ÏÑ†ÌÉù ÏÇ¨Ìï≠Ïù¥Í≥† ÏûÖÎ†•Ìïú ÎåÄÎ°ú Ï†ïÌôïÌûà
                      Î°úÍ±∞Ïóê Ï†ÑÎã¨Îê©ÎãàÎã§. (ÏïΩÏãù: -l)
@@ -477,12 +593,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;level&gt; Ïù¥Î≤§Ìä∏ Î°úÍ∑∏Ïóê Ïù¥ Ï†ïÎ≥¥Ïùò ÏñëÏùÑ ÌëúÏãúÌï©ÎãàÎã§.
-                     ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏÑ∏Î∂Ä Ï†ïÎ≥¥ ÌëúÏãú ÏàòÏ§ÄÏùÄ Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§. q[uiet], m[inimal],
-                     n[ormal], d[etailed], Î∞è diag[nostic]. (ÏïΩÏãù: -v)
+        <target state="translated">  -verbosity:&lt;level&gt; Ïù¥Î≤§Ìä∏ Î°úÍ∑∏Ïóê Ïù¥ Ï†ïÎèÑ ÏñëÏùò Ï†ïÎ≥¥Î•º ÌëúÏãúÌï©ÎãàÎã§.
+                     ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏÑ∏Î∂Ä Ï†ïÎ≥¥ ÌëúÏãú ÏàòÏ§ÄÏóêÎäî q[uiet], m[inimal],
+                     n[ormal], d[etailed], diag[nostic]Ïù¥ ÏûàÏäµÎãàÎã§. (ÏïΩÏãù: -v)
                      Ïòà:
                        -verbosity:quiet
+
+                     Ï∞∏Í≥†: ÌååÏùº Î°úÍ±∞Ïùò ÏÑ∏Î∂Ä Ï†ïÎ≥¥ ÌëúÏãúÎäî
+                           -fileloggerparametersÏóê ÏùòÌï¥
+                           Î≥ÑÎèÑÎ°ú ÏÑ§Ï†ïÎê©ÎãàÎã§.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -531,40 +655,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     ÏΩòÏÜî Î°úÍ±∞Ïóê ÎåÄÌïú Îß§Í∞ú Î≥ÄÏàòÏûÖÎãàÎã§. (ÏïΩÏãù: -clp)
+                     ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Îß§Í∞ú Î≥ÄÏàòÎäî Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§.
+                        PerformanceSummary--ÏûëÏóÖ, ÎåÄÏÉÅ, ÌîÑÎ°úÏ†ùÌä∏ÏóêÏÑú ÏÜåÏöîÎêú ÏãúÍ∞ÑÏùÑ 
+                            ÌëúÏãúÌï©ÎãàÎã§.
+                        Summary--Ï¢ÖÎ£å Ïãú Ïò§Î•ò Î∞è Í≤ΩÍ≥† ÏöîÏïΩÏùÑ ÌëúÏãúÌï©ÎãàÎã§.
+                        NoSummary--Ï¢ÖÎ£å Ïãú Ïò§Î•ò Î∞è Í≤ΩÍ≥† ÏöîÏïΩÏùÑ ÌëúÏãúÌïòÏßÄ
+                            ÏïäÏäµÎãàÎã§.
+                        ErrorsOnly--Ïò§Î•òÎßå ÌëúÏãúÌï©ÎãàÎã§.
+                        WarningsOnly--Í≤ΩÍ≥†Îßå ÌëúÏãúÌï©ÎãàÎã§.
+                        NoItemAndPropertyList--Í∞Å ÌîÑÎ°úÏ†ùÌä∏ ÎπåÎìúÎ•º ÏãúÏûëÌï† Îïå Ìï≠Î™© Î∞è ÏÜçÏÑ± Î™©Î°ùÏùÑ 
+                            ÌëúÏãúÌïòÏßÄ ÏïäÏäµÎãàÎã§.
+                        ShowCommandLine--TaskCommandLineEvent Î©îÏãúÏßÄÎ•º ÌëúÏãúÌï©ÎãàÎã§.
+                        ShowTimestamp--Î©îÏãúÏßÄ Ï†ëÎëêÏÇ¨Î°ú ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÎ•º 
+                            ÌëúÏãúÌï©ÎãàÎã§.
+                        ShowEventId--ÏãúÏûëÎêú Ïù¥Î≤§Ìä∏, ÏôÑÎ£åÎêú Ïù¥Î≤§Ìä∏, Î©îÏãúÏßÄÏùò eventIdÎ•º 
+                            ÌëúÏãúÌï©ÎãàÎã§.
+                        ForceNoAlign--ÏΩòÏÜî Î≤ÑÌçº ÌÅ¨Í∏∞Ïóê ÌÖçÏä§Ìä∏Î•º ÎßûÏ∂îÏßÄ 
+                            ÏïäÏäµÎãàÎã§.
+                        DisableConsoleColor--Î™®Îì† Î°úÍπÖ Î©îÏãúÏßÄÏóê Í∏∞Î≥∏ ÏΩòÏÜî ÏÉâÏùÑ
+                            ÏÇ¨Ïö©Ìï©ÎãàÎã§.
+                        DisableMPLogging--Îã§Ï§ë ÌîÑÎ°úÏÑ∏ÏÑúÍ∞Ä ÏïÑÎãå Î™®ÎìúÏóêÏÑú Ïã§ÌñâÌï† Í≤ΩÏö∞
+                            Ï∂úÎ†•Ïùò Îã§Ï§ë ÌîÑÎ°úÏÑ∏ÏÑú Î°úÍπÖ Ïä§ÌÉÄÏùºÏùÑ 
+                            ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎèÑÎ°ù ÏÑ§Ï†ïÌï©ÎãàÎã§.
+                        EnableMPLogging--Îã§Ï§ë ÌîÑÎ°úÏÑ∏ÏÑúÍ∞Ä ÏïÑÎãå Î™®ÎìúÏóêÏÑú Ïã§ÌñâÌï† Í≤ΩÏö∞ÏóêÎèÑ
+                            Îã§Ï§ë ÌîÑÎ°úÏÑ∏ÏÑú Î°úÍπÖ Ïä§ÌÉÄÏùºÏùÑ ÏÇ¨Ïö©ÌïòÎèÑÎ°ù ÏÑ§Ï†ïÌï©ÎãàÎã§.
+                            Ïù¥ Î°úÍπÖ Ïä§ÌÉÄÏùºÏùÄ Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÌôúÏÑ±ÌôîÎê©ÎãàÎã§.
+                        ForceConsoleColor--ÏΩòÏÜîÏóêÏÑú ÏßÄÏõêÌïòÏßÄ ÏïäÎçîÎùºÎèÑ ANSI ÏΩòÏÜî ÏÉâÏùÑ
+                            ÏÇ¨Ïö©Ìï©ÎãàÎã§
+                        PreferConsoleColor--ÎåÄÏÉÅ ÏΩòÏÜîÏóêÏÑú ÏßÄÏõêÎêòÎäî Í≤ΩÏö∞ÏóêÎßå
+                             ANSI ÏΩòÏÜî ÏÉâÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.
+                     Verbosity--Ïù¥ Î°úÍ±∞Ïóê ÎåÄÌïú -verbosity ÏÑ§Ï†ïÏùÑ 
+                            Ïû¨Ï†ïÏùòÌï©ÎãàÎã§.
+                     Ïòà:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -665,10 +789,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     MSBuildÍ∞Ä ÎπåÎìú Í≤∞Í≥ºÎ•º ÏùΩÏùÑ ÏûÖÎ†• Ï∫êÏãú ÌååÏùºÏùò
+                     ÏÑ∏ÎØ∏ÏΩúÎ°†ÏúºÎ°ú Íµ¨Î∂ÑÎêú Î™©Î°ùÏûÖÎãàÎã§. -isolateProjectsÍ∞Ä
+                     FalseÎ°ú ÏÑ§Ï†ïÎêú Í≤ΩÏö∞ Ïù¥Î°ú Ïù∏Ìï¥ TrueÎ°ú ÏÑ§Ï†ïÎê©ÎãàÎã§. (ÏïΩÏãù: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -682,11 +806,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     ÎπåÎìúÍ∞Ä ÎÅùÎÇ† Îïå MSBuildÏóêÏÑú ÎπåÎìú Í≤∞Í≥º Ï∫êÏãúÏùò
+                     ÏΩòÌÖêÏ∏†Î•º Ïì∏ Ï∂úÎ†• Ï∫êÏãú ÌååÏùºÏûÖÎãàÎã§.
+                     -isolateProjectsÍ∞Ä FalseÎ°ú ÏÑ§Ï†ïÎêú Í≤ΩÏö∞ Ïù¥Î°ú Ïù∏Ìï¥ TrueÎ°ú ÏÑ§Ï†ïÎê©ÎãàÎã§.
+                     (ÏïΩÏãù: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -724,11 +848,11 @@
                      Î°úÍ±∞Î•º ÏßÄÏ†ïÌïòÎ†§Î©¥ Í∞Å Î°úÍ±∞Î•º Í∞úÎ≥ÑÏ†ÅÏúºÎ°ú ÏßÄÏ†ïÌï©ÎãàÎã§.
                      (ÏïΩÏãù -dl)
                      &lt;Î°úÍ±∞&gt; Íµ¨Î¨∏ÏùÄ Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§.
-                       [&lt;ÌÅ¥ÎûòÏä§&gt;,]&lt;Ïñ¥ÏÖàÎ∏îÎ¶¨&gt;[,&lt;ÏòµÏÖò&gt;][;&lt;Îß§Í∞ú Î≥ÄÏàò&gt;]
+                       [&lt;ÌÅ¥ÎûòÏä§&gt;,]&lt;assembly&gt;[,&lt;ÏòµÏÖò&gt;][;&lt;Îß§Í∞ú Î≥ÄÏàò&gt;]
                      &lt;Î°úÍ±∞ ÌÅ¥ÎûòÏä§&gt; Íµ¨Î¨∏ÏùÄ Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§.
                        [&lt;Î∂ÄÎ∂Ñ ÎòêÎäî Ï†ÑÏ≤¥ ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§&gt;.]&lt;Î°úÍ±∞ ÌÅ¥ÎûòÏä§ Ïù¥Î¶Ñ&gt;
                      &lt;Î°úÍ±∞ Ïñ¥ÏÖàÎ∏îÎ¶¨&gt; Íµ¨Î¨∏ÏùÄ Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§.
-                       {&lt;Ïñ¥ÏÖàÎ∏îÎ¶¨ Ïù¥Î¶Ñ&gt;[,&lt;strong name&gt;] | &lt;Ïñ¥ÏÖàÎ∏îÎ¶¨ ÌååÏùº&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Î°úÍ±∞ ÏòµÏÖòÏùÄ MSBuildÍ∞Ä Î°úÍ±∞Î•º ÎßåÎìúÎäî Î∞©Î≤ïÏùÑ ÏßÄÏ†ïÌï©ÎãàÎã§.
                       &lt;Î°úÍ±∞ Îß§Í∞ú Î≥ÄÏàò&gt;Îäî ÏÑ†ÌÉù ÏÇ¨Ìï≠Ïù¥Í≥†
                      ÏûÖÎ†•Ìïú ÎåÄÎ°ú Ï†ïÌôïÌûà Î°úÍ±∞Ïóê Ï†ÑÎã¨Îê©ÎãàÎã§. (ÏïΩÏãù: -l)
@@ -1190,6 +1314,33 @@
         <target state="translated">MSBuild Î°úÍ∑∏ Î∞è ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥Îäî "{0}"Ïóê ÏûàÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: getItem Ïä§ÏúÑÏπòÏùò Ìï≠Î™© Ïù¥Î¶ÑÏùÑ Ï†úÍ≥µÌï¥Ïïº Ìï©ÎãàÎã§.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: getProperty Ïä§ÏúÑÏπòÏùò ÏÜçÏÑ± Ïù¥Î¶ÑÏùÑ Ï†úÍ≥µÌï¥Ïïº Ìï©ÎãàÎã§.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult Ïä§ÏúÑÏπòÏùò ÎåÄÏÉÅ Ïù¥Î¶ÑÏùÑ Ï†úÍ≥µÌï¥Ïïº Ìï©ÎãàÎã§.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Î°úÍ±∞Î•º ÏßÄÏ†ïÌïòÏã≠ÏãúÏò§.</target>
@@ -1241,6 +1392,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters Ïä§ÏúÑÏπòÎ•º ÏÇ¨Ïö©ÌïòÎäî Í≤ΩÏö∞ ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞Ïóê ÎåÄÌï¥ ÌïòÎÇò Ïù¥ÏÉÅÏùò Îß§Í∞ú Î≥ÄÏàòÎ•º ÏßÄÏ†ïÌïòÏÑ∏Ïöî.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1277,6 +1438,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: "{0}" Ïù¥Î¶ÑÏóê ÏûòÎ™ªÎêú Î¨∏Ïûê "{1}"Ïù¥(Í∞Ä) ÏÇ¨Ïö©ÎêòÏóàÏäµÎãàÎã§.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1307,6 +1475,60 @@
         <target state="translated">ÌîÑÎ°úÏÑ∏Ïä§ = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}Ï¥à)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}Ï¥à)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}Ï¥à)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}Ï¥à)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: ÌîÑÎ°úÏ†ùÌä∏ ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.</target>
@@ -1352,6 +1574,22 @@
         <target state="translated">'{0}'ÏùÄ(Îäî) '{1}'ÏóêÏÑú Ï†úÍ≥µÎêòÏóàÏäµÎãàÎã§.</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Î≥µÏõê ÏôÑÎ£å({0}Ï¥à)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">{0} Î≥µÏõê({1}Ï¥à)</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1380,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: ÏÜîÎ£®ÏÖò ÌååÏùº ÎòêÎäî ÏÜîÎ£®ÏÖò ÌïÑÌÑ∞ ÌååÏùºÏùÑ ÎπåÎìúÌï† Îïå ÏÜçÏÑ± ÎòêÎäî Ìï≠Î™©Ïóê Ïï°ÏÑ∏Ïä§Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Ïù¥ Í∏∞Îä•ÏùÄ Í∞úÎ≥Ñ ÌîÑÎ°úÏ†ùÌä∏Î•º ÎπåÎìúÌï† ÎïåÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1395,6 +1641,21 @@
         <target state="translated">MSBUILD : error MSB1059: ÎåÄÏÉÅÏùÑ Ï∂úÎ†•Ìï† Ïàò ÏóÜÏäµÎãàÎã§. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">ÎπåÎìúÍ∞Ä stdout Ïä§Ìä∏Î¶ºÏóê ÎåÄÌïú ÏßÅÏ†ë Ïï°ÏÑ∏Ïä§Î•º ÏöîÏ≤≠ÌïòÎäî ÌîÑÎ°úÏÑ∏Ïä§(Ïòà: 'dotnet test')Ïùò Ïª®ÌÖçÏä§Ìä∏ÏóêÏÑú Ïã§ÌñâÎêòÍ∏∞ ÎïåÎ¨∏Ïóê ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞Îäî ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Ï∂úÎ†•Ïù¥ ÏßÄÏõêÎêòÏßÄ ÏïäÏïÑ ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞Î•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Ï∂úÎ†•Ïù¥ ÌååÏùºÎ°ú Î¶¨ÎîîÎ†âÏÖòÎêòÍ∏∞ ÎïåÎ¨∏Ïóê ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞Í∞Ä ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Ïù¥ Ïä§ÏúÑÏπòÏóêÎäî Îß§Í∞ú Î≥ÄÏàòÎ•º ÏßÄÏ†ïÌï† Ïàò ÏóÜÏäµÎãàÎã§.</target>
@@ -1413,6 +1674,11 @@
         <target state="translated">MSBUILD : error MSB1015: Ïù¥ Ïö¥ÏòÅ Ï≤¥Ï†ú Î≤ÑÏ†ÑÏóêÏÑúÎäî MSBuildÎ•º Ïã§ÌñâÌï† Ïàò ÏóÜÏäµÎãàÎã§. MSBuildÎäî Windows 7 Ïù¥ÏÉÅÏùò Î≤ÑÏ†ÑÏóêÏÑúÎßå ÏßÄÏõêÎê©ÎãàÎã§.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">ÏÜîÎ£®ÏÖò ÌååÏùºÏóêÎäî '{0}' Ïä§ÏúÑÏπòÍ∞Ä ÏßÄÏõêÎêòÏßÄ ÏïäÏäµÎãàÎã§.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">MSBUILDOLDOM=1Ïù¥ÎØÄÎ°ú Microsoft.Build.EngineÏùÑ Í∞ïÏ†úÎ°ú Î°úÎìúÌïòÎäî Ï§ë...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index e623fd51e42..31ada718b8e 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Kompilacja nie powiod≈Ça siƒô. Nie mo≈ºna uzyskaƒá wynik√≥w w≈Ça≈õciwo≈õci, element√≥w i celu. Zobacz szczeg√≥≈Çy w sekcji stderr powy≈ºej.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Kompiluj {0} w {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">niepowodzenie</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">zako≈Ñczono niepowodzeniem, z b≈Çƒôdami</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">zako≈Ñczono niepowodzeniem, z ostrze≈ºeniami.</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">powodzenie</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">zako≈Ñczono powodzeniem, z ostrze≈ºeniem</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: prze≈ÇƒÖcznika -noAutoResponse nie mo≈ºna okre≈õliƒá w pliku autoodpowiedzi MSBuild.rsp ani w ≈ºadnym pliku odpowiedzi, do kt√≥rego odwo≈Çuje siƒô plik autoodpowiedzi.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -question
+                     (Eksperymentalne) Pytanie, czy istnieje jakakolwiek kompilacja.
+                     Program MSBuild wyrzuci b≈ÇƒÖd, gdy wykryje element docelowy lub zadanie
+                     , kt√≥re mo≈ºe byƒá przyrostowe (ma dane wej≈õciowe i wyj≈õciowe),
+                     ale nie jest aktualne.
+                     (Skr√≥cona forma: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Powoduje, ≈ºe platforma MSBuild zg≈Çasza dostƒôpy do wszystkich skonfigurowanych
+                     wtyczek pamiƒôci podrƒôcznej projektu.
+
+                     Ta flaga jest eksperymentalna i mo≈ºe nie dzia≈Çaƒá zgodnie z oczekiwaniami.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: warto≈õƒá niskiego priorytetu jest nieprawid≈Çowa. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: Warto≈õƒá rejestratora terminali jest nieprawid≈Çowa. Powinna to byƒá warto≈õƒá ‚Äûauto‚Äù, ‚Äûtrue‚Äù lub ‚Äûfalse‚Äù. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: warto≈õƒá dostƒôp√≥w do pliku raportu jest nieprawid≈Çowa. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Wersja programu MSBuild {0} dla {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -151,25 +269,26 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Powoduje, ≈ºe program MSBuild kompiluje ka≈ºdy projekt osobno.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     Po ustawieniu na warto≈õƒá ‚ÄûMessageUponIsolationViolation‚Äù (lub jej skr√≥conƒÖ
+                     formƒô ‚ÄûMessage‚Äù), serializowane sƒÖ tylko wyniki z cel√≥w najwy≈ºszego poziomu
+                     , je≈õli prze≈ÇƒÖcznik -outputResultsCache jest
+                     dostarczony. Ma to na celu zmniejszenie szans na to, ≈ºe cel 
+                     naruszy izolacjƒô w projekcie zale≈ºnym przy u≈ºyciu
+                     nieprawid≈Çowego stanu z powodu jego zale≈ºno≈õci od buforowanego celu
+                     kt√≥rego efekty uboczne nie by≈Çyby brane pod uwagƒô.
+                     (Na przyk≈Çad definicja w≈Ça≈õciwo≈õci).
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     Jest to bardziej restrykcyjny tryb MSBuild, poniewa≈º wymaga
+,
+                     aby graf projektu by≈Ç statycznie wykrywalny w
+                     czasie ewaluacji, ale mo≈ºe te≈º poprawiaƒá planowanie i zmniejszyƒá
+                     pamiƒôƒá podczas budowania du≈ºego zestawu projekt√≥w.
+                     (Skr√≥cona forma: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Ta flaga jest eksperymentalna i mo≈ºe nie dzia≈Çaƒá zgodnie z przeznaczeniem.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -278,8 +397,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -288,14 +406,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
- -warnNotAsError[:code[;code2]]
- Lista kod√≥w ostrze≈ºe≈Ñ, kt√≥re majƒÖ byƒá traktowane jako b≈Çƒôdy. 
- Rozdziel ≈õrednik lub przecinek
- wiele kod√≥w ostrze≈ºe≈Ñ. Nie ma ≈ºadnego efektu, je≈õli prze≈ÇƒÖcznik -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Lista kod√≥w ostrze≈ºe≈Ñ, kt√≥re nie sƒÖ traktowane jako b≈Çƒôdy.
+                     U≈ºyj ≈õrednika lub przecinka, aby oddzieliƒá
+                     wiele kod√≥w ostrze≈ºe≈Ñ. Nie ma wp≈Çywu, je≈õli prze≈ÇƒÖcznik -warnaserror
+                     nie jest ustawiony.
 
-                     Example:
+                     Przyk≈Çad:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -451,17 +568,14 @@
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;rejestrator&gt;  Umo≈ºliwia u≈ºycie podanego rejestratora do rejestrowania
-                         zdarze≈Ñ pochodzƒÖcych z programu MSBuild. Aby okre≈õliƒá
-                     wiele rejestrator√≥w, okre≈õl ka≈ºdy z nich osobno.
+        <target state="translated">  -logger:&lt;rejestrator&gt;  Umo≈ºliwia u≈ºycie podanego rejestratora do rejestrowania zdarze≈Ñ pochodzƒÖcych
+                     z programu MSBuild. Aby okre≈õliƒá wiele rejestrator√≥w, okre≈õl ka≈ºdy z nich osobno.
                      Sk≈Çadnia elementu &lt;rejestrator&gt;:
-                        [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;
-                        [;&lt;parametry rejestratora&gt;]
+                      [&lt;klasa rejestratora&gt;,]&lt;assembly&gt; [;&lt;parametry rejestratora&gt;]
                      Sk≈Çadnia elementu &lt;klasa rejestratora&gt;:
-                        [&lt;czƒô≈õciowa lub pe≈Çna przestrze≈Ñ nazw&gt;.]
-                        &lt;nazwa klasy rejestratora&gt;
+                       [&lt;czƒô≈õciowa lub pe≈Çna przestrze≈Ñ nazw&gt;.] &lt;nazwa klasy rejestratora&gt;
                      Sk≈Çadnia elementu &lt;zestaw rejestratora&gt;:
-                        {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Warto≈õci &lt;parametry rejestratora&gt; sƒÖ opcjonalne i sƒÖ
                      przekazywane do rejestratora dok≈Çadnie tak, jak zosta≈Çy
                      wpisane. (Kr√≥tka wersja: -l)
@@ -484,12 +598,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;poziom&gt; Wy≈õwietla podanƒÖ ilo≈õƒá informacji w dzienniku zdarze≈Ñ.
-                     Dostƒôpne poziomy szczeg√≥≈Çowo≈õci: q[uiet], m[inimal],
-                     n[ormal], d[etailed] i diag[nostic]. (Kr√≥tka wersja: /v)
+        <target state="translated">  -verbosity:&lt;level&gt; Wy≈õwietl tƒô ilo≈õƒá informacji w dzienniku zdarze≈Ñ.
+                     Dostƒôpne poziomy szczeg√≥≈Çowo≈õci to: q[uiet], m[inimal],
+                     n[ormal], d[etailed], and diag[nostic]. (Skr√≥cona forma: -v)
                      Przyk≈Çad:
-                       -verbosity:quiet
+                       -verbosity:cichy
+
+                     Note: szczeg√≥≈Çowo≈õƒá rejestrator√≥w plik√≥w
+                           jest ustawiana oddzielnie przez
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -538,40 +660,41 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parametry rejestratora konsoli. (Kr√≥tka wersja: -clp)
+                     Dostƒôpne parametry:
+                        PerformanceSummary--pokazuje czas spƒôdzony na zadaniach, elementach docelowych
+                        i projektach.
+                        Summary--pokazuje na ko≈Ñcu podsumowanie b≈Çƒôd√≥w i ostrze≈ºe≈Ñ.
+                        NoSummary--nie pokazuje na ko≈Ñcu podsumowania b≈Çƒôd√≥w
+                        i ostrze≈ºe≈Ñ.
+                        ErrorsOnly--pokazuje tylko b≈Çƒôdy.
+                        WarningsOnly--pokazuje tylko ostrze≈ºenia.
+                        NoItemAndPropertyList--nie pokazuje listy element√≥w i
+                        w≈Ça≈õciwo≈õci na poczƒÖtku ka≈ºdej kompilacji projektu.
+                        ShowCommandLine--pokazuje komunikaty TaskCommandLineEvent
+                        ShowTimestamp--wy≈õwietla sygnaturƒô czasowƒÖ jako prefiks ka≈ºdego
+                        komunikatu.
+                        ShowEventId--pokazuje identyfikator zdarzenia dla rozpoczƒôtych zdarze≈Ñ, zako≈Ñczonych
+                        zdarze≈Ñ i komunikat√≥w.
+                        ForceNoAlign--nie dopasowuje tekstu do rozmiaru
+                        buforu konsoli.
+                        DisableConsoleColor--u≈ºywa domy≈õlnych kolor√≥w konsoli
+                            dla wszystkich komunikat√≥w dotyczƒÖcych rejestrowania.
+                        DisableMPLogging--wy≈ÇƒÖcza styl rejestrowania
+                        wieloprocesorowego wynik√≥w podczas dzia≈Çania w
+                        trybie nie-wieloprocesorowym.
+                        EnableMPLogging--w≈ÇƒÖcza styl rejestrowania wieloprocesorowego
+                        nawet podczas dzia≈Çania w trybie nie-wieloprocesorowym
+                        Ten styl rejestrowania jest w≈ÇƒÖczony domy≈õlnie.
+                        ForceConsoleColor--u≈ºywa kolor√≥w konsoli ANSI nawet wtedy
+,
+                            gdy konsola ich nie obs≈Çuguje
+                        PreferConsoleColor--u≈ºywa kolor√≥w konsoli ANSI tylko gdy
+                            konsola docelowa obs≈Çuguje tƒô funkcjƒô
+                        Verbosity--zastƒôpuje ustawienie -szczeg√≥≈Çowo≈õƒá dla tego
+                        rejestratora.
+                     Przyk≈Çad:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -672,10 +795,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Rozdzielona ≈õrednikami lista wej≈õciowych plik√≥w pamiƒôci podrƒôcznej, z kt√≥rych MSBuild 
+                     odczyta wyniki kompilacji. Je≈õli jest ustawione -isolateProjects
+                     na warto≈õƒá Fa≈Çsz, ta opcja ustawia jƒÖ na warto≈õƒá Prawda. (skr√≥cona forma: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -689,11 +812,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     Wyj≈õciowy plik pamiƒôci podrƒôcznej, w kt√≥rym program MSBuild zapisze zawarto≈õƒá
+                     pamiƒôci podrƒôcznej wynik√≥w kompilacji na ko≈Ñcu kompilacji.
+                     Je≈õli -isolateProjects jest ustawiona na warto≈õƒá Fa≈Çsz, to ustawia je na warto≈õƒá Prawda.
+                     (skr√≥cona forma: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -731,11 +854,11 @@
                      wiele rejestrator√≥w, okre≈õl ka≈ºdy z nich osobno.
                      (Kr√≥tka wersja: -dl)
                      Sk≈Çadnia elementu &lt;rejestrator&gt;:
-                       [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;[;&lt;parametry rejestratora&gt;]
+                       [&lt;klasa rejestratora&gt;,]&lt;assembly&gt;[;&lt;parametry rejestratora&gt;]
                      Sk≈Çadnia elementu &lt;klasa rejestratora&gt;:
                        [&lt;czƒô≈õciowa lub pe≈Çna przestrze≈Ñ nazw&gt;.]&lt;nazwa klasy rejestratora&gt;
                      Sk≈Çadnia elementu &lt;zestaw rejestratora&gt;:
-                       {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Warto≈õci &lt;parametry rejestratora&gt; sƒÖ opcjonalne i sƒÖ
                      przekazywane do rejestratora dok≈Çadnie tak, jak zosta≈Çy
                      wpisane. (Kr√≥tka wersja: -l)
@@ -761,7 +884,7 @@
                      Example:
                        -ignoreProjectExtensions:.sln
     </source>
-        <target state="translated">-ignoreProjectExtensions:&lt;rozszerzenia&gt;
+        <target state="translated">  -ignoreProjectExtensions:&lt;rozszerzenia&gt;
                      Lista rozszerze≈Ñ, kt√≥re majƒÖ zostaƒá zignorowane podczas
                      ustalania pliku projektu do kompilacji. Przy u≈ºyciu ≈õrednika lub przecinka
                      mo≈ºna rozdzielaƒá wiele rozszerze≈Ñ.
@@ -847,13 +970,11 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     Rejestruje dane wyj≈õciowe kompilacji w wielu plikach
-                     dziennika, po jednym pliku na wƒôze≈Ç programu MSBuild.
-                     PoczƒÖtkowƒÖ lokalizacjƒÖ tych plik√≥w jest bie≈ºƒÖcy katalog.
-                     Domy≈õlnie pliki majƒÖ nazwƒô
+                     Rejestruje dane wyj≈õciowe kompilacji w wielu plikach dziennika,po jednym pliku
+                     na wƒôze≈Ç programu MSBuild. PoczƒÖtkowƒÖ lokalizacjƒÖ tych plik√≥w
+                     jest bie≈ºƒÖcy katalog. Domy≈õlnie pliki majƒÖ nazwƒô
                      ‚ÄûMSBuild&lt;identyfikator wƒôz≈Ça&gt;.log‚Äù. Lokalizacjƒô plik√≥w
                      i inne parametry rejestratora plik√≥w mo≈ºna okre≈õliƒá
-
                      przez dodanie prze≈ÇƒÖcznika ‚Äû-fileLoggerParameters‚Äù.
 
                      Je≈õli nazwa pliku zostanie ustawiona za pomocƒÖ prze≈ÇƒÖcznika
@@ -1199,6 +1320,33 @@
         <target state="translated">Dzienniki i informacje debugowania programu MSBuild bƒôdƒÖ znajdowaƒá siƒô w lokalizacji ‚Äû{0}‚Äù</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: Musi podaƒá nazwƒô elementu dla prze≈ÇƒÖcznika getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: Musi podaƒá nazwƒô w≈Ça≈õciwo≈õci dla prze≈ÇƒÖcznika getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: Musi podaƒá nazwƒô celu dla prze≈ÇƒÖcznika getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: okre≈õl rejestrator.</target>
@@ -1250,6 +1398,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: W przypadku korzystania z prze≈ÇƒÖcznika -terminalLoggerParameters okre≈õl co najmniej jeden parametr dla rejestratora terminalu</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1286,6 +1444,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: nazwa ‚Äû{0}‚Äù zawiera nieprawid≈Çowy znak ‚Äû{1}‚Äù.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1316,6 +1481,60 @@
         <target state="translated">Proces = ‚Äû{0}‚Äù</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: plik projektu nie istnieje.</target>
@@ -1361,6 +1580,22 @@
         <target state="translated">Element ‚Äû{0}‚Äú pochodzi z ‚Äû{1}‚Äú</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Zako≈Ñczono przywracanie ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Przywr√≥ƒá {0} w {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1389,6 +1624,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: Nie mo≈ºna uzyskaƒá dostƒôpu do w≈Ça≈õciwo≈õci lub element√≥w podczas tworzenia plik√≥w rozwiƒÖza≈Ñ lub plik√≥w filtr√≥w rozwiƒÖza≈Ñ. Ta funkcja jest dostƒôpna tylko podczas tworzenia pojedynczych projekt√≥w.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1404,6 +1647,21 @@
         <target state="translated">MSBUILD : error MSB1059: Nie mo≈ºna wydrukowaƒá element√≥w docelowych. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Rejestrator terminali nie zosta≈Ç u≈ºyty, poniewa≈º kompilacja jest uruchamiana w kontek≈õcie procesu (np. ‚Äûdotnet test‚Äù), kt√≥ry ≈ºƒÖda bezpo≈õredniego dostƒôpu do strumienia StdOut.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Rejestrator terminali nie zosta≈Ç u≈ºyty, poniewa≈º dane wyj≈õciowe nie sƒÖ obs≈Çugiwane.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Rejestrator terminali nie zosta≈Ç u≈ºyty, poniewa≈º dane wyj≈õciowe sƒÖ przekierowywane do pliku.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: ten prze≈ÇƒÖcznik nie ma ≈ºadnych parametr√≥w.</target>
@@ -1422,6 +1680,11 @@
         <target state="translated">MSBUILD : error MSB1015: Program MSBuild nie dzia≈Ça w tej wersji systemu operacyjnego. Jest obs≈Çugiwany tylko w¬†systemie Windows¬†7 i¬†nowszych wersjach.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">Prze≈ÇƒÖcznik ‚Äû{0}‚Äù nie jest obs≈Çugiwany dla plik√≥w rozwiƒÖza≈Ñ.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Wymuszanie za≈Çadowania aparatu Microsoft.Build.Engine, poniewa≈º MSBUILDOLDOM=1...</target>
@@ -1762,7 +2025,7 @@ dziennik√≥w                     tekstowych i wykorzystaƒá w innych narzƒôdziach
                      w okre≈õlonym pliku. Je≈õli rozszerzenie okre≈õlonego
                      pliku to ‚Äûmd‚Äù, wynik jest generowany w formacie znacznik√≥w
                      markdown. W przeciwnym razie jest tworzony plik rozdzielany tabulatorami.
-</target>
+    </target>
         <note />
       </trans-unit>
       <trans-unit id="HelpMessage_33_RestorePropertySwitch">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index d952f5673fe..cc9cfcffdf1 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Falha na compila√ß√£o. N√£o foi poss√≠vel obter os resultados de Propriedades, Itens e Destino. Veja os detalhes no stderr acima.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Construir {0} em {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">falhou</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">falhou com erros</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">falhou com avisos</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">√™xito</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">√™xito com avisos</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,79 @@
         <target state="translated">MSBUILD : error MSB1027: A op√ß√£o /noAutoResponse n√£o pode ser especificada no arquivo de resposta autom√°tica MSBuild.rsp nem em qualquer arquivo de resposta usado como refer√™ncia para o arquivo de resposta autom√°tica.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -pergunta
+                     (Experimental) Questione se h√° algum trabalho de constru√ß√£o.
+                     O MSBuild apresentar√° um erro ao detectar um destino ou tarefa
+                     que pode ser incremental (possui entradas e sa√≠das),
+                     n√£o est√° atualizado.
+                     (forma abreviada: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Faz com que o MSBuild relate acessos a arquivos a qualquer
+ configurado
+                     plug-ins de cache do projeto.
+
+                     Este sinalizador √© experimental e pode n√£o funcionar conforme o esperado.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: o valor de baixa prioridade n√£o √© v√°lido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: o valor do agente de terminal n√£o √© v√°lido. O valor deve ser "auto", "true" ou "false". {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: o valor de acesso ao arquivo de relat√≥rio n√£o √© v√°lido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Vers√£o do MSBuild {0} para {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -151,25 +270,25 @@ arquivo de resposta.
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolarProjects[:True|MessageUponIsolationViolation|False]
+                     Faz com que o MSBuild crie cada projeto isoladamente.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     Quando definido como "MessageUponIsolationViolation" (ou sua abrevia√ß√£o
+                     formul√°rio "Mensagem"), apenas os resultados dos alvos de n√≠vel superior
+                     s√£o serializados se a op√ß√£o -outputResultsCache for
+                     fornecido. Isso √© para mitigar as chances de um
+                     alvo de viola√ß√£o de isolamento em um projeto de depend√™ncia usando
+                     estado incorreto devido √† sua depend√™ncia de um destino armazenado em cache
+                     cujos efeitos colaterais n√£o seriam levados em considera√ß√£o.
+                     (Por exemplo, a defini√ß√£o de uma propriedade.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     Este √© um modo mais restritivo do MSBuild, pois requer
+                     que o gr√°fico do projeto seja descoberto estaticamente em
+                     tempo de avalia√ß√£o, mas pode melhorar o agendamento e reduzir
+                     sobrecarga de mem√≥ria ao criar um grande conjunto de projetos.
+                     (forma abreviada: -isolar)
 
-                     This flag is experimental and may not work as intended.
+                     Este sinalizador √© experimental e pode n√£o funcionar conforme o esperado.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -275,8 +394,7 @@ arquivo de resposta.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -285,14 +403,13 @@ arquivo de resposta.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
+        <target state="translated">  -warningNotAsError[:code[;code2]]
                      Lista de c√≥digos de aviso para tratar e n√£o tratar como erros.
                      Use ponto e v√≠rgula ou v√≠rgula para separar
-                     v√°rios c√≥digos de aviso. N√£o tem efeito se o -warnaserror
+                     v√°rios c√≥digos de advert√™ncia. N√£o tem efeito se o -warnaserror
                      interruptor n√£o est√° definido.
 
-                     Examplo:
+                     Exemplo:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -478,12 +595,20 @@ arquivo de resposta.
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;level&gt; Exibir este volume de informa√ß√µes no log de eventos.
-                     Os n√≠veis de detalhamento dispon√≠veis s√£o: q[uiet], m[inimal],
-                     n[ormal], d[etailed] e diag[nostic]. (Forma abreviada: -v)
+        <target state="translated">  -verbosidade:&lt;level&gt; Exibe essa quantidade de informa√ß√µes no log de eventos.
+                     Os n√≠veis de verbosidade dispon√≠veis s√£o: q[uiet], m[inimal],
+                     n[ormal], d[detalhado] e diag[n√≥stico]. (forma abreviada: -v)
                      Exemplo:
-                       -verbosity:quiet
+                       - verbosidade: quieto
+
+                     Nota: verbosidade dos registradores de arquivos
+                           √© definido separadamente por
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -532,42 +657,42 @@ arquivo de resposta.
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Par√¢metros para o logger do console. (forma abreviada: -clp)
+                     Os par√¢metros dispon√≠veis s√£o:
+                        PerformanceSummary--Mostra o tempo gasto em tarefas, alvos
+                            e projetos.
+                        Resumo--Mostra o resumo do erro e do aviso no final.
+                        NoSummary--N√£o mostra o resumo de erros e avisos no
+                            fim.
+                        ErrorOnly--Mostrar apenas erros.
+                        WarningsOnly--Mostra apenas avisos.
+                        NoItemAndPropertyList--N√£o mostra a lista de itens e
+                            properties no in√≠cio de cada compila√ß√£o do projeto.
+                        ShowCommandLine--Mostra mensagens TaskCommandLineEvent
+                        ShowTimestamp--Exibe o timestamp como um prefixo para qualquer
+                            mensagem.
+                        ShowEventId--Mostra eventId para eventos iniciados, conclu√≠dos
+                            eventos e mensagens
+                        ForceNoAlign--N√£o alinha o texto ao tamanho de
+                            o buffer do console
+                        DisableConsoleColor--Use as cores padr√£o do console
+                            para todas as mensagens de registro.
+                        DisableMPLogging-- Desativa o multiprocessador
+                            estilo de registro de sa√≠da ao executar em
+                            modo n√£o multiprocessador.
+                        EnableMPLogging--Habilita o log do multiprocessador
+                            estilo mesmo quando executado em n√£o multiprocessador
+                            modo. Esse estilo de cria√ß√£o de log est√° ativado por padr√£o.
+                        ForceConsoleColor--Use as cores do console ANSI mesmo se
+                            o console n√£o suporta isso
+                        PreferConsoleColor--Use as cores do console ANSI somente se
+                            o console de destino suporta isso
+                     Verbosity--substitui a configura√ß√£o -verbosity para este
+                            registrador.
+                     Exemplo:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
-                                                 Verbosity=minimal
+                                                 Verbosidade=m√≠nimo
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -666,10 +791,10 @@ arquivo de resposta.
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Lista separada por ponto-e-v√≠rgula de arquivos de cache de entrada que o MSBuild
+                     ir√° ler os resultados da compila√ß√£o. Se -isolateProjects estiver definido
+                     para Falso, isso o define como Verdadeiro. (forma abreviada: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -683,11 +808,11 @@ arquivo de resposta.
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     Arquivo de cache de sa√≠da onde o MSBuild gravar√° o conte√∫do de
+                     seu resultado de compila√ß√£o √© armazenado em cache no final da compila√ß√£o.
+                     Se -isolateProjects for definido como False, isso o definir√° como True.
+                     (forma abreviada: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1191,6 +1316,33 @@ arquivo de resposta.
         <target state="translated">Os logs e as informa√ß√µes de depura√ß√£o do MSBuild estar√£o no "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: √â preciso fornecer um nome de item para a chave getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: √â preciso fornecer um nome de propriedade para a chave getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: √â preciso fornecer um nome de destino para a chave getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Especificar um agente de log.</target>
@@ -1242,6 +1394,16 @@ arquivo de resposta.
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: Especifique um ou mais par√¢metros para o agente de terminal se estiver usando a op√ß√£o -terminalLoggerParameters</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1278,6 +1440,13 @@ arquivo de resposta.
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: O nome "{0}" cont√©m um caractere inv√°lido "{1}".</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1308,6 +1477,60 @@ arquivo de resposta.
         <target state="translated">Processo = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Arquivo de projeto n√£o existe.</target>
@@ -1353,6 +1576,22 @@ arquivo de resposta.
         <target state="translated">'{0}' proveniente de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Restaura√ß√£o conclu√≠da ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Restaurar {0} em {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1381,6 +1620,14 @@ arquivo de resposta.
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: N√£o foi poss√≠vel acessar propriedades ou itens ao compilar arquivos de solu√ß√£o ou arquivos de filtro de solu√ß√£o. Esse recurso s√≥ est√° dispon√≠vel para a compila√ß√£o de projetos individuais.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1396,6 +1643,21 @@ arquivo de resposta.
         <target state="translated">MSBUILD : error MSB1059: n√£o foi poss√≠vel imprimir destinos. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">O Agente de Terminal n√£o foi usado porque a compila√ß√£o √© executada no contexto de um processo (por exemplo, 'dotnet test') que solicita acesso direto ao fluxo stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">O Agente de Terminal n√£o foi usado porque n√£o h√° suporte para a sa√≠da.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">O Agente de Terminal n√£o foi usado porque a sa√≠da est√° sendo redirecionada para um arquivo.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Esta op√ß√£o n√£o aceita par√¢metros.</target>
@@ -1414,6 +1676,11 @@ arquivo de resposta.
         <target state="translated">MSBUILD : error MSB1015: O MSBuild n√£o √© executado nesta vers√£o do sistema operacional. √â suportado apenas no Windows 7 e em vers√µes posteriores.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">A op√ß√£o '{0}' n√£o √© suportada para arquivos de solu√ß√£o.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">For√ßando carregamento do Microsoft.Build.Engine porque MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 156bc64a2ef..3bb7dcc1c0a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">–°–±–æ—Ä–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å. –ù–µ —É–¥–∞–µ—Ç—Å—è –ø–æ–ª—É—á–∏—Ç—å —Å–≤–æ–π—Å—Ç–≤–∞, —ç–ª–µ–º–µ–Ω—Ç—ã –∏ —Ü–µ–ª–µ–≤—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã. –°–º. –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –≤ stderr –≤—ã—à–µ.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">–°–±–æ—Ä–∫–∞ {0} —á–µ—Ä–µ–∑ {1} —Å</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">—Å–±–æ–π</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">—Å–±–æ–π —Å –æ—à–∏–±–∫–∞–º–∏</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">—Å–±–æ–π —Å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è–º–∏</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">—É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">—É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —Å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ–º</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: –∫–ª—é—á noAutoResponse –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —É–∫–∞–∑–∞–Ω –≤ —Ñ–∞–π–ª–µ –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç–∞ MSBuild.rsp –∏–ª–∏ –≤ –ª—é–±–æ–º –¥—Ä—É–≥–æ–º —Ñ–∞–π–ª–µ –æ—Ç–≤–µ—Ç–∞, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π —Ñ–∞–π–ª –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç–∞ —Å—Å—ã–ª–∞–µ—Ç—Å—è.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -question
+                     (–≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä) –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç, –µ—Å—Ç—å –ª–∏ —Ä–∞–±–æ—Ç–∞ –ø–æ —Å–±–æ—Ä–∫–µ.
+                     MSBuild –≤—ã–¥–∞–µ—Ç –æ—à–∏–±–∫—É –ø—Ä–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–∏ —Ü–µ–ª–µ–≤–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ –∏–ª–∏ –∑–∞–¥–∞—á–∏,
+                     –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–æ—á–Ω—ã–º–∏ (—Å –≤—Ö–æ–¥–Ω—ã–º–∏ –∏ –≤—ã—Ö–æ–¥–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏),
+                     –Ω–æ –Ω–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã.
+                     (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     –í–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç—á–µ—Ç–æ–≤ MSBuild –æ –¥–æ—Å—Ç—É–ø–µ –∫ —Ñ–∞–π–ª–∞–º –¥–ª—è –≤—Å–µ—Ö –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö
+                     –ø–æ–¥–∫–ª—é—á–∞–µ–º—ã—Ö –º–æ–¥—É–ª–µ–π –∫—ç—à–∞ –ø—Ä–æ–µ–∫—Ç–∞.
+
+                     –≠—Ç–æ—Ç —Ñ–ª–∞–≥ —è–≤–ª—è–µ—Ç—Å—è —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–º –∏ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∏–∑–∫–æ–≥–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: –ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞. –≠—Ç–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ–¥–Ω–æ –∏–∑ —Å–ª–µ–¥—É—é—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π: "auto", "–ò–°–¢–ò–ù–ê" –∏–ª–∏ "–õ–û–ñ–¨". {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç—á–µ—Ç–∞ –æ –¥–æ—Å—Ç—É–ø–µ –∫ —Ñ–∞–π–ª–∞–º —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–º. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">–í–µ—Ä—Å–∏—è MSBuild {0} –¥–ª—è {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -149,25 +267,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     MSBuild –≤—ã–ø–æ–ª–Ω—è–µ—Ç —Å–±–æ—Ä–∫—É –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     –ï—Å–ª–∏ –∑–∞–¥–∞–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ "MessageUponIsolationViolation" –∏–ª–∏ –µ–≥–æ –∫—Ä–∞—Ç–∫–∞—è
+                     —Ñ–æ—Ä–º–∞ "Message"), —Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–æ–ª—å–∫–æ —Ü–µ–ª–µ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
+                     –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä -outputResultsCache.
+                     –≠—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏—Å–∫–ª—é—á–∏—Ç—å —Å–∏—Ç—É–∞—Ü–∏—é, –∫–æ–≥–¥–∞
+                     –Ω–∞—Ä—É—à–∞—é—â–∏–π –∏–∑–æ–ª—è—Ü–∏—é —Ü–µ–ª–µ–≤–æ–π –æ–±—ä–µ–∫—Ç –≤ –ø—Ä–æ–µ–∫—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
+                     –Ω–µ–≤–µ—Ä–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑-–∑–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ü–µ–ª–µ–≤–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞,
+                     –ø–æ–±–æ—á–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω–µ —É—á–∏—Ç—ã–≤–∞—é—Ç—Å—è.
+                     (–ù–∞–ø—Ä–∏–º–µ—Ä, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–∞–∫–æ–≥–æ-–ª–∏–±–æ —Å–≤–æ–π—Å—Ç–≤–∞.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     –≠—Ç–æ —Ä–µ–∂–∏–º MSBuild —Å –±–æ–ª–µ–µ —Å—Ç—Ä–æ–≥–∏–º–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏,
+                     –ø–æ—Å–∫–æ–ª—å–∫—É –¥–ª—è –Ω–µ–≥–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è, —á—Ç–æ–±—ã –≥—Ä–∞—Ñ –ø—Ä–æ–µ–∫—Ç–∞ –±—ã–ª —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ–º—ã–º –≤–æ
+                     –≤—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏. –¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, –ø—Ä–∏ —ç—Ç–æ–º —É–ª—É—á—à–∞–µ—Ç—Å—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Å–Ω–∏–∂–∞–µ—Ç—Å—è
+                     –∏–∑–±—ã—Ç–æ—á–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏ –ø—Ä–∏ —Å–±–æ—Ä–∫–∏ –∫—Ä—É–ø–Ω–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –ø—Ä–æ–µ–∫—Ç–æ–≤.
+                     (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     –≠—Ç–æ —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥, –æ–Ω –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -273,8 +391,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -283,11 +400,10 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     –°–ø–∏—Å–æ–∫ –∫–æ–¥–æ–≤ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –±—É–¥—É—Ç —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å—Å—è –∫–∞–∫ –æ—à–∏–±–∫–∏.
-                     –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π –∏–ª–∏ –∑–∞–ø—è—Ç—É—é –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
-                     –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∫–æ–¥–æ–≤ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è. –ù–µ –¥–µ–π—Å—Ç–≤—É–µ—Ç, –µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä -warnaserror
+        <target state="translated">  -warnNotAsError[:–∫–æ–¥[;–∫–æ–¥2]]
+                     –°–ø–∏—Å–æ–∫ –∫–æ–¥–æ–≤ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Å–ª–µ–¥—É–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –≤ –∫–∞—á–µ—Å—Ç–≤–µ –æ—à–∏–±–æ–∫.
+                     –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π –∏–ª–∏ –∑–∞–ø—è—Ç—É—é, —á—Ç–æ–±—ã —Ä–∞–∑–¥–µ–ª–∏—Ç—å
+                     –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–¥–æ–≤ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è. –ù–µ –¥–µ–π—Å—Ç–≤—É–µ—Ç, –µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä -warnaserror
                      –Ω–µ –∑–∞–¥–∞–Ω.
 
                      –ü—Ä–∏–º–µ—Ä:
@@ -476,12 +592,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;—É—Ä–æ–≤–µ–Ω—å&gt; –û—Ç–æ–±—Ä–∞–∂–∞—Ç—å —ç—Ç–∏ —Å–≤–µ–¥–µ–Ω–∏—è –≤ –∂—É—Ä–Ω–∞–ª–µ —Å–æ–±—ã—Ç–∏–π.
-                     –î–æ—Å—Ç—É–ø–Ω—ã–º–∏ —É—Ä–æ–≤–Ω—è–º–∏ –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ —è–≤–ª—è—é—Ç—Å—è: q[uiet], m[inimal],
-                     n[ormal], d[etailed] –∏ diag[nostic]. (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -v)
+        <target state="translated">  -verbosity:&lt;—É—Ä–æ–≤–µ–Ω—å&gt; –£—Ä–æ–≤–µ–Ω—å –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–≤–µ–¥–µ–Ω–∏–π –≤ –∂—É—Ä–Ω–∞–ª–µ —Å–æ–±—ã—Ç–∏–π.
+                     –î–æ—Å—Ç—É–ø–Ω—ã–µ —É—Ä–æ–≤–Ω–∏ –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏: q (–∏–ª–∏ quiet) ‚Äî –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, m (–∏–ª–∏ minimal) ‚Äî –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π,
+                     n (–∏–ª–∏ normal) ‚Äî –æ–±—ã—á–Ω—ã–π, d (–∏–ª–∏ detailed) ‚Äî –ø–æ–¥—Ä–æ–±–Ω—ã–π, diag (–∏–ª–∏ diagnostic) ‚Äî –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞. (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -v)
                      –ü—Ä–∏–º–µ—Ä:
                        -verbosity:quiet
+
+                     –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ. –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ä–µ–¥—Å—Ç–≤ –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–æ–≤ —Ñ–∞–π–ª–æ–≤
+                           —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ —Å –ø–æ–º–æ—â—å—é
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -530,40 +654,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;–ø–∞—Ä–∞–º–µ—Ç—Ä—ã&gt;
+                     –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ä–µ–¥—Å—Ç–≤–∞ –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞ –∫–æ–Ω—Å–æ–ª–∏. (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -clp)
+                     –î–æ—Å—Ç—É–ø–Ω—ã —Å–ª–µ–¥—É—é—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:
+                        PerformanceSummary--–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤—Ä–µ–º—è, –∑–∞—Ç—Ä–∞—á–µ–Ω–Ω–æ–µ –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞—á,
+                            —Ü–µ–ª–µ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –∏ –ø—Ä–æ–µ–∫—Ç–æ–≤.
+                        Summary--–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–≤–æ–¥–∫—É –æ—à–∏–±–æ–∫ –∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã.
+                        NoSummary--–Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–≤–æ–¥–∫—É –æ—à–∏–±–æ–∫ –∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –ø–æ
+                            –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã.
+                        ErrorsOnly--–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –æ—à–∏–±–∫–∏.
+                        WarningsOnly--–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è.
+                        NoItemAndPropertyList--–Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–ø–∏—Å–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏
+                            —Å–≤–æ–π—Å—Ç–≤ –≤ –Ω–∞—á–∞–ª–µ —Å–±–æ—Ä–∫–∏ –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞.
+                        ShowCommandLine--–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è TaskCommandLineEvent
+                        ShowTimestamp--–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –º–µ—Ç–∫—É –≤—Ä–µ–º–µ–Ω–∏ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø—Ä–µ—Ñ–∏–∫—Å–∞ –∫ –ª—é–±–æ–º—É
+                            —Å–æ–æ–±—â–µ–Ω–∏—é.
+                        ShowEventId--–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–æ–¥ —Å–æ–±—ã—Ç–∏—è eventId –¥–ª—è –∑–∞–ø—É—â–µ–Ω–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π,
+                            –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π –∏ —Å–æ–æ–±—â–µ–Ω–∏–π
+                        ForceNoAlign--–Ω–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞—Ç—å —Ç–µ–∫—Å—Ç –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–∑–º–µ—Ä–∞
+                            –±—É—Ñ–µ—Ä–∞ –∫–æ–Ω—Å–æ–ª–∏
+                        DisableConsoleColor--–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ü–≤–µ—Ç–∞ –∫–æ–Ω—Å–æ–ª–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
+                            –¥–ª—è –≤—Å–µ—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞.
+                        DisableMPLogging--–æ—Ç–∫–ª—é—á–∏—Ç—å –º–Ω–æ–≥–æ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–Ω—ã–π
+                            —Å—Ç–∏–ª—å –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞ –≤—ã—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ –≤
+                            —Ä–µ–∂–∏–º–µ, –æ—Ç–ª–∏—á–Ω–æ–º –æ—Ç –º–Ω–æ–≥–æ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–Ω–æ–≥–æ.
+                        EnableMPLogging--–≤–∫–ª—é—á–∏—Ç—å –º–Ω–æ–≥–æ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–Ω—ã–π —Å—Ç–∏–ª—å –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞
+                            –¥–∞–∂–µ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ –≤ —Ä–µ–∂–∏–º–µ, –æ—Ç–ª–∏—á–Ω–æ–º –æ—Ç
+                            –º–Ω–æ–≥–æ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–Ω–æ–≥–æ. –≠—Ç–æ—Ç —Å—Ç–∏–ª—å –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞ –≤–∫–ª—é—á–µ–Ω –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
+                        ForceConsoleColor--–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ü–≤–µ—Ç–∞ –∫–æ–Ω—Å–æ–ª–∏ ANSI, –¥–∞–∂–µ –µ—Å–ª–∏
+                            –∫–æ–Ω—Å–æ–ª—å –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏—Ö
+                        PreferConsoleColor--–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ü–≤–µ—Ç–∞ –∫–æ–Ω—Å–æ–ª–∏ ANSI –ª–∏—à—å –≤ —Å–ª—É—á–∞–µ, –µ—Å–ª–∏
+                            —Ü–µ–ª–µ–≤–∞—è –∫–æ–Ω—Å–æ–ª—å –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏—Ö
+                     Verbosity--–ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä -verbosity (—É—Ä–æ–≤–µ–Ω—å –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏) –¥–ª—è —ç—Ç–æ–≥–æ
+                            —Å—Ä–µ–¥—Å—Ç–≤–∞ –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞.
+                     –ü—Ä–∏–º–µ—Ä:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -664,10 +788,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;—Ñ–∞–π–ª –∫—ç—à–∞&gt;...
+                     –°–ø–∏—Å–æ–∫ –≤—Ö–æ–¥–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –∫—ç—à–∞ (—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å ‚Äî —Ç–æ—á–∫–∞ —Å –∑–∞–ø—è—Ç–æ–π), –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö MSBuild
+                     –±—É–¥–µ—Ç —á–∏—Ç–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–±–æ—Ä–∫–∏. –ï—Å–ª–∏ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ -isolateProjects –∑–∞–¥–∞–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ
+                     "False", —Ç–æ –æ–Ω–æ –±—É–¥–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ "True". (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -681,11 +805,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[—Ñ–∞–π–ª –∫—ç—à–∞]
+                     –í—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª –∫—ç—à–∞, –≤ –∫–æ—Ç–æ—Ä—ã–π MSBuild –±—É–¥–µ—Ç –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
+                     –∫—ç—à–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å–±–æ—Ä–∫–∏ –ø–æ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ —Å–±–æ—Ä–∫–∏.
+                     –ï—Å–ª–∏ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ -isolateProjects –∑–∞–¥–∞–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ "False", –æ–Ω–æ –±—É–¥–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ "True".
+                     (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1189,6 +1313,33 @@
         <target state="translated">–ñ—É—Ä–Ω–∞–ª—ã MSBuild –∏ –æ—Ç–ª–∞–¥–æ—á–Ω—ã–µ —Å–≤–µ–¥–µ–Ω–∏—è –±—É–¥—É—Ç –¥–æ—Å—Ç—É–ø–Ω—ã –ø–æ –∞–¥—Ä–µ—Å—É "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –∏–º—è —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –∏–º—è —Å–≤–æ–π—Å—Ç–≤–∞ –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å —Ü–µ–ª–µ–≤–æ–µ –∏–º—è –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: —É–∫–∞–∂–∏—Ç–µ –∂—É—Ä–Ω–∞–ª.</target>
@@ -1240,6 +1391,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: —É–∫–∞–∂–∏—Ç–µ –æ–¥–∏–Ω –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è -terminalLoggerParameters</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1276,6 +1437,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: –ò–º—è "{0}" —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Å–∏–º–≤–æ–ª "{1}".</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1306,6 +1474,60 @@
         <target state="translated">–ü—Ä–æ—Ü–µ—Å—Å = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} —Å)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} —Å)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} —Å)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} —Å)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: —Ñ–∞–π–ª –ø—Ä–æ–µ–∫—Ç–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.</target>
@@ -1351,6 +1573,22 @@
         <target state="translated">\"{0}\" –ø–æ–ª—É—á–µ–Ω –∏–∑ \"{1}\"</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ ({0} —Å)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ {0} —á–µ—Ä–µ–∑ {1} —Å</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1379,6 +1617,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: –Ω–µ —É–¥–∞–µ—Ç—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —Å–≤–æ–π—Å—Ç–≤–∞–º –∏–ª–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ñ–∞–π–ª–æ–≤ —Ä–µ—à–µ–Ω–∏–π –∏–ª–∏ —Ñ–∞–π–ª–æ–≤ —Ñ–∏–ª—å—Ç—Ä–æ–≤ —Ä–µ—à–µ–Ω–∏–π. –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1394,6 +1640,21 @@
         <target state="translated">MSBUILD : error MSB1059: –Ω–µ —É–¥–∞–ª–æ—Å—å –≤—ã–≤–µ—Å—Ç–∏ —Ü–µ–ª–µ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">–°—Ä–µ–¥—Å—Ç–≤–æ –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–≤ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, —Ç–∞–∫ –∫–∞–∫ —Å–±–æ—Ä–∫–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "dotnet test"), –∫–æ—Ç–æ—Ä—ã–π –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –ø—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ –ø–æ—Ç–æ–∫—É stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">–°—Ä–µ–¥—Å—Ç–≤–æ –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–≤ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, —Ç–∞–∫ –∫–∞–∫ –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">–°—Ä–µ–¥—Å—Ç–≤–æ –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–≤ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, —Ç–∞–∫ –∫–∞–∫ –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –≤ —Ñ–∞–π–ª.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: —É —ç—Ç–æ–≥–æ –∫–ª—é—á–∞ –Ω–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.</target>
@@ -1412,6 +1673,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã. –û–Ω –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ Windows 7, Windows XP –∏ –±–æ–ª–µ–µ –ø–æ–∑–¥–Ω–∏—Ö –≤–µ—Ä—Å–∏—è—Ö.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">–ü–∞—Ä–∞–º–µ—Ç—Ä "{0}" –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –¥–ª—è —Ñ–∞–π–ª–æ–≤ —Ä–µ—à–µ–Ω–∏–π.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ Microsoft.Build.Engine –ø–µ—Ä–µ–¥ MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index fa4daf5abf2..75d73f551ca 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Derleme ba≈üarƒ±sƒ±z oldu. √ñzellikler, √ñƒüeler ve Hedef sonu√ßlarƒ± alƒ±namƒ±yor. Yukarƒ±da stderr'de ayrƒ±ntƒ±lara bakƒ±n.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">"{1}" sn'de {0} olu≈üturun</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">ba≈üarƒ±sƒ±z oldu</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">hatalarla ba≈üarƒ±sƒ±z oldu</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">uyarƒ±larla ba≈üarƒ±sƒ±z oldu</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">ba≈üarƒ±lƒ±</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">uyarƒ±larla birlikte ba≈üarƒ±lƒ±</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse anahtarƒ±, MSBuild.rsp otomatik yanƒ±t dosyasƒ±nda ve bu dosyanƒ±n ba≈üvuruda bulunduƒüu herhangi bir yanƒ±t dosyasƒ±nda belirtilemez.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -soru
+                     (Deneysel) Derleme √ßalƒ±≈ümasƒ± olup olmadƒ±ƒüƒ±nƒ± sorgulayƒ±n.
+                     MSBuild bir hedef veya g√∂rev algƒ±landƒ±ƒüƒ±nda hataya neden olacak
+                     artƒ±mlƒ± (giri≈üler ve √ßƒ±kƒ±≈ülar i√ßeren),
+                     ancak g√ºncel deƒüil.
+                     (Kƒ±sa bi√ßim: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuild‚Äôin yapƒ±landƒ±rƒ±lmƒ±≈ü proje √∂nbelleƒüi eklentilerine dosya
+                     eri≈üimlerini bildirmesine neden olur.
+
+                     Bu bayrak deneme ama√ßlƒ±dƒ±r ve istendiƒüi gibi √ßalƒ±≈ümayabilir.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: D√º≈ü√ºk √∂ncelikli deƒüer ge√ßerli deƒüil. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: Terminal g√ºnl√ºk√ß√ºs√º deƒüeri ge√ßerli deƒüil. Deƒüer ≈üunlardan biri olmalƒ±dƒ±r: 'otomatik', 'doƒüru' veya 'yanlƒ±≈ü'. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Dosya eri≈üimleri deƒüerinin ge√ßerli olmadƒ±ƒüƒ±nƒ± bildirir. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">{1} i√ßin MSBuild s√ºr√ºm {0}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -150,25 +268,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageUponIsolationViolation| False]
+                     MSBuild'in her projeyi yalƒ±tƒ±mda derlemesini saƒülar.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     "MessageUponIsolationViolation" olarak ayarlandƒ±ƒüƒ±nda (veya kƒ±sa
+                     form "ƒ∞leti"), yalnƒ±zca √ºst d√ºzey hedeflerden gelen sonu√ßlar
+                     -outputResultsCache anahtarƒ± ≈üu olduƒüunda seri hale getirilebilir:
+                     Saƒülanan. Bu, bir
+                     yalƒ±tƒ±m ihlal eden hedef, bir baƒüƒ±mlƒ±lƒ±k projesini kullanan
+                     √∂nbelleƒüe alƒ±nmƒ±≈ü bir hedefte baƒüƒ±mlƒ±lƒ±ƒüƒ± nedeniyle hatalƒ± durum
+                     yan etkileri hesaplanmadƒ±.
+                     (√ñrneƒüin, bir √∂zelliƒüin tanƒ±mƒ±.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     Bu, gerektirdiƒüi ≈üekilde daha kƒ±sƒ±tlayƒ±cƒ± bir MSBuild modu
+                     proje grafiƒüi statik olarak bulunabilir
+                     ancak zamanlamanƒ±n geli≈ütirilmesine ve daha az
+                     b√ºy√ºk bir proje k√ºmesi olu≈üturulurken bellek ek y√ºk√º.
+                     (Kƒ±sa form: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Bu bayrak deneyseldir ve ama√ßlandƒ±k ≈üekilde √ßalƒ±≈ümayabilir.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -274,8 +392,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -284,14 +401,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
--warnNotAsError[:code[;code2]]
-                     Hata olarak kabul edilmeyen uyarƒ± kodlarƒ±nƒ±n listesi.
-                     Ayƒ±rmak i√ßin noktalƒ± virg√ºl veya virg√ºl kullanƒ±n
-                    √ßoklu uyarƒ± kodlarƒ± -warnaserror ise hi√ßbir etkisi yoktur
-                     anahtarƒ± ayarlanmadƒ±.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Hata olarak deƒüerlendirilmeyecek uyarƒ± kodlarƒ±nƒ±n listesi.
+                     Birden √ßok uyarƒ± kodunu ayƒ±rmak i√ßin noktalƒ± virg√ºl
+                     veya virg√ºl kullanƒ±n. -warnaserror anahtarƒ± ayarlanmamƒ±≈üsa
+                     hi√ßbir etkisi yoktur.
 
-√ñrnek:
+                     √ñrnek:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -450,13 +566,13 @@
         <target state="translated">  -logger:&lt;g√ºnl√ºk√ß√º&gt;   MSBuild'deki olaylarƒ± g√ºnl√ºƒüe almak i√ßin bu g√ºnl√ºk√ß√ºy√º kullanƒ±n. Birden fazla
                      g√ºnl√ºk√ß√º belirtmek i√ßin her g√ºnl√ºk√ß√ºy√º ayrƒ± ayrƒ± belirtin.
                      &lt;g√ºnl√ºk√ß√º&gt; s√∂z dizimi ≈ü√∂yledir:
-                       [&lt;sƒ±nƒ±f&gt;,]&lt;derleme&gt;[,&lt;se√ßenekler&gt;][;&lt;parametreler&gt;]
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
                      &lt;g√ºnl√ºk√ß√º sƒ±nƒ±fƒ± &gt; s√∂z dizimi ≈ü√∂yledir:
                        [&lt;kƒ±smi veya tam ad alanƒ± &gt;.]&lt;g√ºnl√ºk√ß√º sƒ±nƒ±fƒ± adƒ±&gt;
                      &lt;g√ºnl√ºk√ß√º derlemesi&gt; s√∂z dizimi ≈ü√∂yledir:
-                       {&lt;derleme adƒ±&gt;[,&lt;strong name&gt;] | &lt;derleme dosyasƒ±&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      G√ºnl√ºk√ß√º se√ßenekleri, MSBuild'in g√ºnl√ºk√ß√ºy√º olu≈üturma bi√ßimini belirtir.
-                     &lt;g√ºnl√ºk√ß√º parametreleri &gt; isteƒüe baƒülƒ±dƒ±r ve tam olarak 
+                     &lt;g√ºnl√ºk√ß√º parametreleri &gt; isteƒüe baƒülƒ±dƒ±r ve tam olarak
                      yazdƒ±ƒüƒ±nƒ±z ≈üekliyle g√ºnl√ºk√ß√ºye ge√ßirilir. (Kƒ±sa bi√ßim: -l)
                      √ñrnekler:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -477,12 +593,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;d√ºzey&gt; Olay g√ºnl√ºƒü√ºnde bu miktarda bilgi g√∂r√ºnt√ºler.
-                     Kullanƒ±labilen ayrƒ±ntƒ± d√ºzeyleri: q[uiet], m[inimal],
-                     n[ormal], d[etailed] ve diag[nostic]. (Kƒ±sa bi√ßim: -v)
+        <target state="translated">  -verbosity:&lt;level&gt; Bu miktarda bilgiyi olay g√ºnl√ºƒü√ºnde g√∂r√ºnt√ºle.
+                     Kullanƒ±labilir verbosity seviyeleri ≈üunlardƒ±r: q[uiet], m[inimal],
+                     n[ormal], d[etailed], and diag[nostic]. (Kƒ±sa bi√ßim: -v)
                      √ñrnek:
-                       /verbosity:quiet
+                       -verbosity:quiet
+
+                     Not: Dosya kaydedicilerin verbosity‚Äôsi
+                           -fileloggerparameters tarafƒ±ndan
+                           ayrƒ± olarak ayarlanƒ±r.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -531,40 +655,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Konsol g√ºnl√ºƒü√º i√ßin parametreler. (Kƒ±sa form: -clp)
+                     Mevcut parametreler:
+                        PerformanceSummary--G√∂revlerde, hedeflerde harcanan zamanƒ± g√∂ster
+                            ve projelerde.
+                        Summary--Sonunda hata ve uyarƒ± √∂zetini g√∂ster.
+                        NoSummary--Sonunda hata ve uyarƒ± √∂zeti
+                            g√∂sterme.
+                        ErrorsOnly--Yalnƒ±zca hatalarƒ± g√∂ster.
+                        WarningsOnly--Yalnƒ±zca uyarƒ±larƒ± g√∂ster.
+                        NoItemAndPropertyList--Her proje derlemesinin ba≈ülangƒ±cƒ±nda √∂ƒüe
+                            ve √∂zellik listesini g√∂sterme.
+                        ShowCommandLine--TaskCommandLineEvent mesajlarƒ±nƒ± g√∂ster
+                        ShowTimestamp--Zaman Damgasƒ±nƒ± herhangi bir iletinin √∂neki olarak
+                            g√∂r√ºnt√ºleyin.
+                        ShowEventId--Ba≈ülatƒ±lan olaylar, biten olaylar ve mesajlar i√ßin
+                            eventId'i g√∂ster
+                        ForceNoAlign--Metni konsol arabelleƒüinin boyutuna
+                            hizalamaz
+                        DisableConsoleColor--T√ºm g√ºnl√ºk iletileri i√ßin varsayƒ±lan konsol
+                            renklerini kullanƒ±n.
+                        DisableMPLogging-- √áok i≈ülemcili olmayan modda
+                            √ßalƒ±≈üƒ±rken √ßƒ±ktƒ±nƒ±n √ßok i≈ülemcili g√ºnl√ºƒüe kaydetme stilini
+                            devre dƒ±≈üƒ± bƒ±rakƒ±n.
+                        EnableMPLogging--√áok i≈ülemcili olmayan modda √ßalƒ±≈üƒ±rken bile
+                            √ßok i≈ülemcili g√ºnl√ºƒüe kaydetme stilini
+                            etkinle≈ütirin. Bu g√ºnl√ºk kaydƒ± stili varsayƒ±lan olarak a√ßƒ±ktƒ±r.
+                        ForceConsoleColor--Konsol desteklemese bile ANSI
+                            konsol renklerini kullanƒ±n
+                        PreferConsoleColor--ANSI konsol renklerini yalnƒ±zca
+                            hedef konsol destekliyorsa kullanƒ±n
+                     Verbosity--bu g√ºnl√ºk√ß√º i√ßin -verbosity ayarƒ±nƒ± ge√ßersiz
+                            kƒ±lar.
+                     √ñrnek:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -665,10 +789,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     MSBuild tarafƒ±ndan saƒülanan giri≈ü √∂nbelleƒüi dosyalarƒ±nƒ±n noktalƒ± virg√ºlle ayrƒ±lmƒ±≈ü listesi
+                     derleme sonu√ßlarƒ±nƒ± okuyacak. -isolateProjects False olarak
+                      ayarlanƒ±rsa bunu True olarak ayarlar. (kƒ±sa bi√ßim: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -682,11 +806,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     MSBuild'in i√ßeriklerini yazacaƒüƒ± √ßƒ±ktƒ± √∂nbellek dosyasƒ±
+                     derlemenin sonundaki derleme sonucu √∂nbellekleri.
+                     -isolateProjects False olarak ayarlanƒ±rsa, bunu True olarak ayarlar.
+                     (kƒ±sa bi√ßim: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -724,11 +848,11 @@
                      g√ºnl√ºk√ß√º belirtmek i√ßin her g√ºnl√ºk√ß√ºy√º ayrƒ± ayrƒ± belirtin.
                      (Kƒ±sa bi√ßim -dl)
                      &lt;g√ºnl√ºk√ß√º&gt; s√∂z dizimi ≈ü√∂yledir:
-                       [&lt;sƒ±nƒ±f&gt;,]&lt;derleme&gt;[,&lt;se√ßenekler&gt;][;&lt;parametreler&gt;]
+                       [&lt;sƒ±nƒ±f&gt;,]&lt;assembly&gt;[,&lt;se√ßenekler&gt;][;&lt;parametreler&gt;]
                      &lt;g√ºnl√ºk√ß√º sƒ±nƒ±fƒ±&gt; s√∂z dizimi ≈ü√∂yledir:
                        [&lt;kƒ±smi veya tam ad alanƒ±&gt;.]&lt;g√ºnl√ºk√ß√º sƒ±nƒ±fƒ± adƒ±&gt;
                      &lt;g√ºnl√ºk√ß√º derlemesi&gt; s√∂z dizimi ≈ü√∂yledir:
-                       {&lt;derleme adƒ±&gt;[,&lt;strong name&gt;] | &lt;derleme dosyasƒ±&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      G√ºnl√ºk√ß√º se√ßenekleri, MSBuild'in g√ºnl√ºk√ß√ºy√º olu≈üturma bi√ßimini belirtir.
                      &lt;g√ºnl√ºk√ß√º parametreleri&gt; isteƒüe baƒülƒ±dƒ±r ve tam olarak
                      yazdƒ±ƒüƒ±nƒ±z ≈üekliyle g√ºnl√ºk√ß√ºye ge√ßirilir. (Kƒ±sa bi√ßim: -l)
@@ -755,10 +879,9 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantƒ±lar&gt;
-                     Hangi proje dosyasƒ±nƒ±n olu≈üturulacaƒüƒ± belirlenirken 
-                     yoksayƒ±lacak uzantƒ±larƒ±n listesi. Birden √ßok uzantƒ±yƒ± 
-                     birbirinden ayƒ±rmak i√ßin noktalƒ± virg√ºl veya 
-                     virg√ºl kullanƒ±n.
+                     Hangi proje dosyasƒ±nƒ±n olu≈üturulacaƒüƒ± belirlenirken
+                     yoksayƒ±lacak uzantƒ±larƒ±n listesi. Birden √ßok uzantƒ±yƒ±
+                     birbirinden ayƒ±rmak i√ßin noktalƒ± virg√ºl veya virg√ºl kullanƒ±n.
                      (Kƒ±sa bi√ßim: -ignore)
                      √ñrnek:
                        -ignoreProjectExtensions:.sln
@@ -848,7 +971,6 @@
                      Dosyalarƒ±n konumu ve fileLogger'ƒ±n diƒüer parametreleri 
                      "/fileLoggerParameters" anahtarƒ±nƒ±n eklenmesi yoluyla
                      belirtilebilir.
-
                      G√ºnl√ºk dosyasƒ± adƒ± fileLoggerParameters anahtarƒ±
                      aracƒ±lƒ±ƒüƒ±yla ayarlanƒ±rsa daƒüƒ±tƒ±lmƒ±≈ü g√ºnl√ºk√ß√º fileName 
                      deƒüerini ≈üablon olarak kullanƒ±p her d√ºƒü√ºm√ºn g√ºnl√ºk dosyasƒ±nƒ±
@@ -895,32 +1017,31 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya g√ºnl√ºk√ß√ºleri i√ßin ek parametreler saƒülar.
-                     Bu anahtarƒ±n olmasƒ± kar≈üƒ±lƒ±k gelen -fileLogger[n] 
+                     Bu anahtarƒ±n olmasƒ± kar≈üƒ±lƒ±k gelen -fileLogger[n]
                      anahtarƒ±nƒ±n olduƒüu anlamƒ±na gelir.
                      "n" varsa, 1-9 arasƒ±nda bir rakam olabilir.
-                     Daƒüƒ±tƒ±lmƒ±≈ü dosya g√ºnl√ºk√ß√ºleri varsa -fileLoggerParameters 
-                     bunlar tarafƒ±ndan da kullanƒ±lƒ±r; -distributedFileLogger 
-                     a√ßƒ±klamasƒ±na bakƒ±n.
+                     Daƒüƒ±tƒ±lmƒ±≈ü dosya g√ºnl√ºk√ß√ºleri varsa -fileLoggerParameters
+                     bunlar tarafƒ±ndan da kullanƒ±lƒ±r; -distributedFileLogger a√ßƒ±klamasƒ±na bakƒ±n.
                      (Kƒ±sa bi√ßim: -flp[n])
-                     Konsol g√ºnl√ºk√ß√ºs√º i√ßin listelenenlerle aynƒ± parametreler 
+                     Konsol g√ºnl√ºk√ß√ºs√º i√ßin listelenenlerle aynƒ± parametreler
                      kullanƒ±labilir. Kullanƒ±labilecek bazƒ± ek parametreler:
-                        LogFile--Olu≈üturma g√ºnl√ºƒü√ºn√ºn yazƒ±lacaƒüƒ± g√ºnl√ºk 
+                        LogFile--Olu≈üturma g√ºnl√ºƒü√ºn√ºn yazƒ±lacaƒüƒ± g√ºnl√ºk
                             dosyasƒ±nƒ±n yolu.
-                        Append--Derleme g√ºnl√ºƒü√ºn√ºn g√ºn dosyasƒ±nƒ±n sonuna mƒ± 
-                            ekleneceƒüini yoksa √ºzerine mi yazƒ±lacaƒüƒ±nƒ± 
-                            belirler. Anahtar ayarlandƒ±ƒüƒ±nda olu≈üturma g√ºnl√ºƒü√º 
-                            dosyanƒ±n sonuna eklenir. Anahtar ayarlanmadƒ±ƒüƒ±nda 
-                            varolan g√ºnl√ºk dosyasƒ±nƒ±n √ºzerine yazƒ±lƒ±r. 
+                        Append--Derleme g√ºnl√ºƒü√ºn√ºn g√ºn dosyasƒ±nƒ±n sonuna mƒ±
+                            ekleneceƒüini yoksa √ºzerine mi yazƒ±lacaƒüƒ±nƒ±
+                            belirler. Anahtar ayarlandƒ±ƒüƒ±nda olu≈üturma g√ºnl√ºƒü√º
+                            dosyanƒ±n sonuna eklenir. Anahtar ayarlanmadƒ±ƒüƒ±nda
+                            varolan g√ºnl√ºk dosyasƒ±nƒ±n √ºzerine yazƒ±lƒ±r.
                             Varsayƒ±lan: g√ºnl√ºk dosyasƒ±nƒ±n sonuna eklenmez.
-                        Encoding--Dosyanƒ±n kodlamasƒ±nƒ± belirtir; √∂rneƒüin, 
+                        Encoding--Dosyanƒ±n kodlamasƒ±nƒ± belirtir; √∂rneƒüin,
                             UTF-8, Unicode veya ASCII
                      Varsayƒ±lan ayrƒ±ntƒ± d√ºzeyi ayarƒ± Detailed'dƒ±r.
                      √ñrnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -944,8 +1065,7 @@
                        -nr:true
     </source>
         <target state="translated">  -nodeReuse:&lt;parametreler&gt;
-                     MSBuild d√ºƒü√ºmlerinin yeniden kullanƒ±mƒ±nƒ± etkinle≈ütirir
-                     veya devre dƒ±≈üƒ± bƒ±rakƒ±r.
+                     MSBuild d√ºƒü√ºmlerinin yeniden kullanƒ±mƒ±nƒ± etkinle≈ütirir veya devre dƒ±≈üƒ± bƒ±rakƒ±r.
                      Parametreler:
                      True --Derleme tamamlandƒ±ktan sonra d√ºƒü√ºmler kalƒ±r ve
                             izleyen derlemelerde yeniden kullanƒ±lƒ±r (varsayƒ±lan)
@@ -1194,6 +1314,33 @@
         <target state="translated">MSBuild g√ºnl√ºkleri ve hata ayƒ±klama bilgileri "{0}" yolunda olacak</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: getItem anahtarƒ± i√ßin bir √∂ƒüe adƒ± saƒülanmasƒ± gerekiyor.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: getProperty anahtarƒ± i√ßin bir √∂zellik adƒ± belirtilmelidir.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult anahtarƒ± i√ßin bir hedef adƒ± saƒülanmasƒ± gerekiyor.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: G√ºnl√ºk√ß√º belirtin.</target>
@@ -1245,6 +1392,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: terminalLoggerParameters anahtarƒ± kullanƒ±lƒ±yorsa terminal g√ºnl√ºk√ß√ºs√º i√ßin bir veya birden √ßok parametre belirtin</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1281,6 +1438,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: "{0}" adƒ± "{1}" ge√ßersiz karakterini i√ßeriyor.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1311,6 +1475,60 @@
         <target state="translated">ƒ∞≈ülem = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}sn)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3}({4}sn)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}sn)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3}({4}sn)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Proje dosyasƒ± yok.</target>
@@ -1356,6 +1574,22 @@
         <target state="translated">'{0}', '{1}' kaynaƒüƒ±ndan geldi</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Geri y√ºkleme tamamlandƒ± ({0}sn)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">{1}sn i√ßinde {0} geri y√ºkle</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1384,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: √á√∂z√ºm dosyalarƒ± veya √ß√∂z√ºm filtresi dosyalarƒ± olu≈üturulurken √∂zelliklere veya √∂ƒüelere eri≈üilemiyor. Bu √∂zellik yalnƒ±zca tek tek projeler olu≈üturulurken kullanƒ±labilir.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1399,6 +1641,21 @@
         <target state="translated">MSBUILD : error MSB1059: Hedefler yazdƒ±rƒ±lamadƒ±. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Derleme StdOut akƒ±≈üƒ±na doƒürudan eri≈üim isteyen bir i≈ülem (√∂r. 'dotnet test') baƒülamƒ±nda √ßalƒ±≈ütƒ±ƒüƒ± i√ßin Terminal G√ºnl√ºk√ß√ºs√º kullanƒ±lmadƒ±.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">√áƒ±kƒ±≈ü desteklenmediƒüinden Terminal G√ºnl√ºk√ß√ºs√º kullanƒ±lmadƒ±.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">√áƒ±kƒ±≈ü bir dosyaya yeniden y√∂nlendirildiƒüi i√ßin Terminal G√ºnl√ºk√ß√ºs√º kullanƒ±lmadƒ±.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Bu anahtar parametreyle kullanƒ±lmaz.</target>
@@ -1417,6 +1674,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild i≈ületim sisteminin bu s√ºr√ºm√ºnde √ßalƒ±≈ümaz. Yalnƒ±zca Windows 7 ve √ºzeri s√ºr√ºmlerde desteklenir.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">√á√∂z√ºm dosyalarƒ± i√ßin '{0}' anahtarƒ± desteklenmez.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">MSBUILDOLDOM=1 olduƒüundan Microsoft.Build.Engine y√ºkleme zorlanƒ±yor...</target>
@@ -1757,7 +2019,7 @@
                      belirtilen dosyaya yazar. Belirtilen dosyanƒ±n uzantƒ±sƒ±
                      '.md' ise, sonu√ß markdown bi√ßiminde olu≈üturulur.
                      Aksi halde, sekme ayrƒ±lmƒ±≈ü bir dosya olu≈üturulur.
-</target>
+    </target>
         <note />
       </trans-unit>
       <trans-unit id="HelpMessage_33_RestorePropertySwitch">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 655c791a6eb..db252831300 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">ÁîüÊàêÂ§±Ë¥•„ÄÇÊó†Ê≥ïËé∑ÂèñÂ±ûÊÄß„ÄÅÈ°πÁõÆÂíåÁõÆÊ†áÁªìÊûú„ÄÇÂú®‰∏äÈù¢ÁöÑ stderr ‰∏≠Êü•ÁúãËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Âú® {1} ‰∏≠ÁîüÊàê {0}</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">Â§±Ë¥•</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">Â§±Ë¥•ÔºåÂá∫Áé∞ÈîôËØØ</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">Â§±Ë¥•ÔºåÂá∫Áé∞Ë≠¶Âëä</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">Â∑≤ÊàêÂäü</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">ÊàêÂäüÔºå‰ΩÜÂá∫Áé∞Ë≠¶Âëä</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: ‰∏çËÉΩÂú® MSBuild.rsp Ëá™Âä®ÂìçÂ∫îÊñá‰ª∂‰∏≠ÊàñÁî±ËØ•Ëá™Âä®ÂìçÂ∫îÊñá‰ª∂ÂºïÁî®ÁöÑ‰ªª‰ΩïÂìçÂ∫îÊñá‰ª∂‰∏≠ÊåáÂÆö -noAutoResponse ÂºÄÂÖ≥„ÄÇ</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -question
+                     (ÂÆûÈ™åÊÄß)ÈóÆÈ¢òÔºåÊòØÂê¶Â≠òÂú®‰ªª‰ΩïÁîüÊàêÂ∑•‰Ωú„ÄÇ
+                     ÂΩìMSBuildÊ£ÄÊµãÂà∞‰∏Ä‰∏™ÂèØ‰ª•Â¢ûÈáèÊâßË°åÁöÑ
+                     ÁõÆÊ†áÊàñ‰ªªÂä°Ôºå‰ΩÜ‰∏çÊòØÊúÄÊñ∞
+                     ÁâàÊú¨Êó∂ÔºåÂ∞Ü‰ºöÊä•Èîô„ÄÇ
+                     (Áº©ÂÜô: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     ÂØºËá¥ MSBuild Êä•ÂëäÂØπ‰ªª‰ΩïÂ∑≤ÈÖçÁΩÆ
+                     È°πÁõÆÁºìÂ≠òÊèí‰ª∂ÁöÑÊñá‰ª∂ËÆøÈóÆ„ÄÇ
+
+                     Ê≠§Ê†áÂøóÊòØÂÆûÈ™åÊÄßÁöÑÔºåÂèØËÉΩÊó†Ê≥ïÊåâÈ¢ÑÊúüÂ∑•‰Ωú„ÄÇ
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: ‰Ωé‰ºòÂÖàÁ∫ßÂÄºÊó†Êïà„ÄÇ{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: ÁªàÁ´ØËÆ∞ÂΩïÂô®ÂÄºÊó†Êïà„ÄÇÂÆÉÂ∫î‰∏∫ "auto"„ÄÅ"true" Êàñ "false" ‰πã‰∏Ä„ÄÇ{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Êä•Ë°®Êñá‰ª∂ËÆøÈóÆÂÄºÊó†Êïà„ÄÇ{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">ÈÄÇÁî®‰∫é {1} MSBuild ÁâàÊú¨ {0}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -150,25 +268,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     ‰Ωø MSBuild ‰ª•ÈöîÁ¶ªÊñπÂºèÁîüÊàêÊØè‰∏™È°πÁõÆ„ÄÇ
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     ËÆæÁΩÆ‰∏∫ ‚ÄúMessageUponIsolationViolation‚Äù (ÊàñÂÖ∂Áº©ÂÜô
+                     Á™ó‰Ωì‚ÄúMessage‚Äù)Êó∂Ôºå‰ªÖÂú®Êèê‰æõ‰∫Ü -outputResultsCache ÂºÄÂÖ≥ÁöÑÊÉÖÂÜµ‰∏ãÊâç‰ºö
+                     Â∫èÂàóÂåñÊù•Ëá™È°∂Á∫ßÁõÆÊ†áÁöÑ
+                     ÁªìÊûú„ÄÇËøôÊòØ‰∏∫‰∫ÜÂáèÂ∞ë‰æùËµñÈ°πÁõÆ‰∏äÁöÑÂ≠§Á´ã
+                     ËøùËßÑÁõÆÊ†á‰ΩøÁî®‰∏çÊ≠£Á°ÆÁä∂ÊÄÅÁöÑ
+                     ÂèØËÉΩÊÄßÔºåÂõ†‰∏∫ÂÆÉ‰æùËµñ‰∫é‰∏Ä‰∏™ÁºìÂ≠òÁõÆÊ†á
+                     ÂÖ∂ÂâØ‰ΩúÁî®‰∏ç‰ºöË¢´ËÄÉËôëÂú®ÂÜÖ„ÄÇ
+                     (‰æãÂ¶ÇÔºåÂ±ûÊÄßÁöÑÂÆö‰πâ„ÄÇ)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     ËøôÊòØ MSBuild ÁöÑÊõ¥‰∏•Ê†ºÁöÑÊ®°ÂºèÔºåÂõ†‰∏∫ÂÆÉÈúÄË¶Å
+                     Âú®ËØÑ‰º∞Êó∂ÈùôÊÄÅÂú∞ÂèëÁé∞È°πÁõÆÂõæ
+                     ‰ΩÜÂèØ‰ª•ÊîπÂñÑË∞ÉÂ∫¶Âπ∂ÂáèÂ∞ëÊûÑÂª∫
+                     Â§ßÈáèÈ°πÁõÆÊó∂ÁöÑÂÜÖÂ≠òÂºÄÈîÄ„ÄÇ
+                     (Áº©ÂÜô: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Ê≠§Ê†áÂøóÊòØÂÆûÈ™åÊÄßÁöÑÔºåÂèØËÉΩÊó†Ê≥ïÊåâÈ¢ÑÊúüÂ∑•‰Ωú„ÄÇ
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -274,8 +392,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -284,8 +401,7 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
+        <target state="translated">  -warnNotAsError[:code[;code2]]
                      ‰∏çËßÜ‰∏∫ÈîôËØØÁöÑË≠¶Âëä‰ª£Á†ÅÂàóË°®.
                      ‰ΩøÁî®ÂàÜÂè∑ÊàñÈÄóÂè∑ÂàÜÈöî
                      Â§ö‰∏™Ë≠¶Âëä‰ª£Á†Å„ÄÇÂ¶ÇÊûúÊú™ËÆæÁΩÆ -warnaserror
@@ -477,12 +593,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;level&gt; Âú®‰∫ã‰ª∂Êó•Âøó‰∏≠ÊòæÁ§∫Ê≠§Á∫ßÂà´ÁöÑ‰ø°ÊÅØÈáè„ÄÇ
-           ÂèØÁî®ÁöÑËØ¶ÁªÜÁ®ãÂ∫¶Êúâ: q[uiet]„ÄÅ m[inimal]„ÄÅ
-           n[ormal]„ÄÅd[etailed] Âíå diag[nostic]„ÄÇ(Áº©ÂÜô: -v)
-           Á§∫‰æã:
+        <target state="translated">  -verbosity:&lt;level&gt; ‰∫ã‰ª∂Êó•Âøó‰∏≠ÊòæÁ§∫Ê≠§‰ø°ÊÅØÈáè„ÄÇ
+                     ÂèØÁî®ÁöÑËØ¶ÁªÜÁ∫ßÂà´‰∏∫: q[uiet]„ÄÅm[inimal]„ÄÅ
+                     n[ormal]„ÄÅd[etailed] Âíå diag[nostic]„ÄÇ(Áº©ÂÜô: -v)
+                     Á§∫‰æã:
                        -verbosity:quiet
+
+                     Ê≥®ÊÑè: Êñá‰ª∂ËÆ∞ÂΩïÂô®ÁöÑËØ¶ÁªÜÁ®ãÂ∫¶
+                           Áî± -fileloggerparameters
+                           ÂçïÁã¨ËÆæÁΩÆ„ÄÇ
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -531,42 +655,42 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
-                        -consoleLoggerParameters:PerformanceSummary;NoSummary;
-                                                 Verbosity=minimal
+        <target state="translated">  -consoleloggerparameters:&lt;parameters&gt;
+           ÊéßÂà∂Âè∞ËÆ∞ÂΩïÂô®ÁöÑÂèÇÊï∞„ÄÇ(Áº©ÂÜô: -clp)
+           ÂèØÁî®ÂèÇÊï∞ÂåÖÊã¨:
+            PerformanceSummary -- ÊòæÁ§∫Âú®‰ªªÂä°„ÄÅÁõÆÊ†áÂíåÈ°πÁõÆ‰∏ä
+              Ëä±Ë¥πÁöÑÊó∂Èó¥„ÄÇ
+            Summary -- ÁªìÊùüÊó∂ÊòæÁ§∫ÈîôËØØÂíåË≠¶ÂëäÁöÑÊëòË¶Å„ÄÇ
+            NoSummary -- ÁªìÊùüÊó∂‰∏çÊòæÁ§∫ÈîôËØØÂíåË≠¶Âëä
+              ÁöÑÊëòË¶Å„ÄÇ
+            ErrorsOnly -- ‰ªÖÊòæÁ§∫ÈîôËØØ„ÄÇ
+            WarningsOnly -- ‰ªÖÊòæÁ§∫Ë≠¶Âëä„ÄÇ
+            NoItemAndPropertyList -- Âú®ÂºÄÂßãÁîüÊàêÊØè‰∏™È°πÁõÆÊó∂‰∏çÊòæÁ§∫
+              È°πÂíåÂ±ûÊÄßÁöÑÂàóË°®„ÄÇ
+            ShowCommandLine -- ÊòæÁ§∫ TaskCommandLineEvent Ê∂àÊÅØ 
+            ShowTimestamp -- Â∞ÜÊó∂Èó¥Êà≥‰Ωú‰∏∫ÊâÄÊúâÊ∂àÊÅØÁöÑÂâçÁºÄ
+              ÊòæÁ§∫„ÄÇ                      
+            ShowEventId -- ÊòæÁ§∫Â∑≤ÂºÄÂßã‰∫ã‰ª∂„ÄÅÂ∑≤ÂÆåÊàê‰∫ã‰ª∂ÂíåÊ∂àÊÅØ
+              ÁöÑ‰∫ã‰ª∂ ID„ÄÇ
+            ForceNoAlign -- ‰∏çÂ∞ÜÊñáÊú¨‰∏éÊéßÂà∂Âè∞ÁºìÂÜ≤Âå∫ÁöÑÂ§ßÂ∞è
+              ÂåπÈÖç„ÄÇ
+            DisableConsoleColor -- Â∞ÜÈªòËÆ§ÊéßÂà∂Âè∞È¢úËâ≤
+              Áî®‰∫éÊâÄÊúâËÆ∞ÂΩïÊ∂àÊÅØ„ÄÇ
+            DisableMPLogging -- Âú®ÈùûÂ§öÂ§ÑÁêÜÂô®
+              Ê®°Âºè‰∏ãËøêË°åÊó∂ÔºåÁ¶ÅÁî®ËæìÂá∫ÁöÑÂ§öÂ§ÑÁêÜÂô®
+              Êó•ÂøóËÆ∞ÂΩïÊ†∑Âºè„ÄÇ
+            EnableMPLogging -- Âç≥‰ΩøÂú®ÈùûÂ§öÂ§ÑÁêÜÂô®
+              Ê®°Âºè‰∏ãËøêË°åÔºå‰πüÂêØÁî®Â§öÂ§ÑÁêÜÂô®
+              Êó•ÂøóËÆ∞ÂΩïÊ†∑Âºè„ÄÇÈªòËÆ§ÊÉÖÂÜµ‰∏ãÂêØÁî®Ê≠§Êó•ÂøóËÆ∞ÂΩïÊ†∑Âºè„ÄÇ
+                        ForceConsoleColor--‰ΩøÁî® ANSI ÊéßÂà∂Âè∞È¢úËâ≤ÔºåÂç≥‰Ωø
+                            ÊéßÂà∂Âè∞‰∏çÊîØÊåÅÂÆÉ
+                        PreferConsoleColor--‰ªÖÂú®ÁõÆÊ†áÊéßÂà∂Âè∞ÊîØÊåÅÊó∂
+                            ‰ΩøÁî® ANSI ÊéßÂà∂Âè∞È¢úËâ≤
+                     Verbosity -- ÈáçÂÜôÊ≠§ËÆ∞ÂΩïÂô®ÁöÑ -verbosity
+              ËÆæÁΩÆ„ÄÇ
+           Á§∫‰æã:
+                        -consoleloggerparameters:PerformanceSummary;NoSummary;
+                         Verbosity=minimal
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -665,10 +789,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     ÂàÜÂè∑ÂàÜÈöîÁöÑËæìÂÖ•ÁºìÂ≠òÊñá‰ª∂ÂàóË°®ÔºåMSBuild
+                     Â∞Ü‰ªé‰∏≠ËØªÂèñÊûÑÂª∫ÁªìÊûú„ÄÇÂ¶ÇÊûú -isolateProjects ËÆæÁΩÆ
+                     ‰∏∫ FalseÔºåÂàôÂ∞ÜÂÖ∂ËÆæÁΩÆ‰∏∫ True„ÄÇ(Áº©ÂÜô: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -682,11 +806,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     Â∞ÜÊûÑÂª∫ÁªìÊûúÁºìÂ≠òÂÜÖÂÆπÂÜôÂÖ• MSBuild Â∞ÜÂú®
+                     ÊûÑÂª∫ÁªìÊùüÊó∂ÁîüÊàêÁöÑËæìÂá∫ÁºìÂ≠òÊñá‰ª∂„ÄÇ
+                     Â¶ÇÊûú -isolateProjects ËÆæÁΩÆ‰∏∫ FalseÔºåÂàôÂ∞ÜÂÖ∂ËÆæÁΩÆ‰∏∫ True„ÄÇ
+                     (Áº©ÂÜô: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1190,6 +1314,33 @@
         <target state="translated">MSBuild Êó•ÂøóÂíåË∞ÉËØï‰ø°ÊÅØÂ∞Ü‰Ωç‰∫é"{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: ÂøÖÈ°ª‰∏∫ getItem ÂºÄÂÖ≥Êèê‰æõÈ°πÂêçÁß∞„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: ÂøÖÈ°ª‰∏∫ getProperty ÂºÄÂÖ≥Êèê‰æõÂ±ûÊÄßÂêçÁß∞„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: ÂøÖÈ°ª‰∏∫ getTargetResult ÂºÄÂÖ≥Êèê‰æõÁõÆÊ†áÂêçÁß∞„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: ËØ∑ÊåáÂÆöËÆ∞ÂΩïÂô®„ÄÇ</target>
@@ -1241,6 +1392,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: ‰∏∫ÁªàÁ´ØËÆ∞ÂΩïÂô®ÊåáÂÆö‰∏Ä‰∏™ÊàñÂ§ö‰∏™ÂèÇÊï∞ (Â¶ÇÊûú‰ΩøÁî® -terminalLoggerParameters ÂºÄÂÖ≥)</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1277,6 +1438,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: ÂêçÁß∞‚Äú{0}‚ÄùÂåÖÂê´Êó†ÊïàÂ≠óÁ¨¶‚Äú{1}‚Äù„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1307,6 +1475,60 @@
         <target state="translated">ËøõÁ®ã = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3})</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4})</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3})</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4})</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: È°πÁõÆÊñá‰ª∂‰∏çÂ≠òÂú®„ÄÇ</target>
@@ -1352,6 +1574,22 @@
         <target state="translated">‚Äú{0}‚ÄùÊù•Ëá™‚Äú{1}‚Äù</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">ËøòÂéüÂÆåÊàê({0})</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Âú® {1} ‰∏≠ËøòÂéü {0}</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1380,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: ÁîüÊàêËß£ÂÜ≥ÊñπÊ°àÊñá‰ª∂ÊàñËß£ÂÜ≥ÊñπÊ°àÁ≠õÈÄâÂô®Êñá‰ª∂Êó∂Êó†Ê≥ïËÆøÈóÆÂ±ûÊÄßÊàñÈ°π„ÄÇÊ≠§ÂäüËÉΩ‰ªÖÂú®ÁîüÊàêÂçï‰∏™È°πÁõÆÊó∂ÂèØÁî®„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1395,6 +1641,21 @@
         <target state="translated">MSBUILD : error MSB1059: Êó†Ê≥ïÊâìÂç∞ÁõÆÊ†á„ÄÇ{0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Êú™‰ΩøÁî®ÁªàÁ´ØËÆ∞ÂΩïÂô®ÔºåÂõ†‰∏∫ÁîüÊàêÊòØÂú®ËØ∑Ê±ÇÁõ¥Êé•ËÆøÈóÆ stdout ÊµÅÁöÑËøõÁ®ãÁöÑ‰∏ä‰∏ãÊñá‰∏≠ËøêË°åÁöÑ(Â¶Ç‚Äúdotnet test‚Äù)„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Êú™‰ΩøÁî®ÁªàÁ´ØËÆ∞ÂΩïÂô®ÔºåÂõ†‰∏∫‰∏çÊîØÊåÅËæìÂá∫„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Êú™‰ΩøÁî®ÁªàÁ´ØËÆ∞ÂΩïÂô®ÔºåÂõ†‰∏∫Ê≠£Âú®Â∞ÜËæìÂá∫ÈáçÂÆöÂêëÂà∞Êñá‰ª∂„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Ê≠§ÂºÄÂÖ≥‰∏çÈááÁî®‰ªª‰ΩïÂèÇÊï∞„ÄÇ</target>
@@ -1413,6 +1674,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild ‰∏çÂú®Ê≠§ÁâàÊú¨Êìç‰ΩúÁ≥ªÁªü‰∏äËøêË°åÔºåËÄå‰ªÖÂú® Windows 7 ÂèäÊõ¥È´òÁâàÊú¨ÁöÑÊìç‰ΩúÁ≥ªÁªü‰∏äÂèóÊîØÊåÅ„ÄÇ</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">Ëß£ÂÜ≥ÊñπÊ°àÊñá‰ª∂‰∏çÊîØÊåÅ‚Äú{0}‚ÄùÂºÄÂÖ≥„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Âº∫Âà∂Âä†ËΩΩ Microsoft.Build.EngineÔºåÂõ†‰∏∫ MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 49e328d19ea..37b67b89bd3 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -9,6 +9,55 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Âª∫ÁΩÆÂ§±Êïó„ÄÇÁÑ°Ê≥ïÂèñÂæóÂ±¨ÊÄß„ÄÅÈ†ÖÁõÆÂèäÁõÆÊ®ôÁµêÊûú„ÄÇË´ãÂèÉÈñ±‰∏äËø∞ stderr ‰∏≠ÁöÑË©≥Á¥∞Ë≥áÊñô„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Âú® {1} ÁßíÂÖßÂª∫ÁΩÆ {0}</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">Â§±Êïó</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">Â§±Êïó‰ΩÜÊúâÈåØË™§</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">Â§±Êïó‰ΩÜÊúâË≠¶Âëä</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">ÊàêÂäü</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">ÊàêÂäü‰ΩÜÊúâË≠¶Âëä</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,9 +77,78 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse ÂèÉÊï∏‰∏çËÉΩÂú® MSBuild.rsp Ëá™ÂãïÂõûÊáâÊ™î‰∏≠ÊåáÂÆöÔºå‰πü‰∏çËÉΩÂú®Ëá™ÂãïÂõûÊáâÊ™îÊâÄÂèÉËÄÉÁöÑ‰ªª‰ΩïÂõûÊáâÊ™î‰∏≠ÊåáÂÆö„ÄÇ</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="translated">  -question
+                     (ÂØ¶È©óÊÄß) ÂïèÈ°å: ÊòØÂê¶Êúâ‰ªª‰ΩïÁµÑÂª∫ÂèØÈÅã‰Ωú„ÄÇ
+                     MSBuild ÂÅµÊ∏¨Âà∞ÂèØÂ¢ûÈáè (ÊúâËº∏ÂÖ•ÂíåËº∏Âá∫)
+                     ‰ΩÜ‰∏¶ÈùûÊúÄÊñ∞ÁöÑÁõÆÊ®ôÊàñÂ∑•‰ΩúÊôÇÔºå
+                     ÂÆÉÊúÉÁôºÁîüÈåØË™§„ÄÇ
+                     (Á∞°Áü≠ÂΩ¢Âºè: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Â∞éËá¥ MSBuild Â†±Âëä‰ªª‰ΩïÂ∑≤Ë®≠ÂÆö‰πãÂ∞àÊ°àÂø´ÂèñÂ§ñÊéõÁ®ãÂºèÁöÑ
+                     Ê™îÊ°àÂ≠òÂèñ„ÄÇ
+
+                     Ê≠§ÊóóÊ®ôÁÇ∫ÂØ¶È©óÊÄßË≥™ÔºåÂèØËÉΩÁÑ°Ê≥ïÂ¶ÇÈ†êÊúüËà¨ÈÅã‰Ωú„ÄÇ
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: ‰ΩéÂÑ™ÂÖàÈ†ÜÂ∫èÂÄºÁÑ°Êïà„ÄÇ{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: ÁµÇÁ´ØÊ©üË®òÈåÑÂô®ÂÄºÁÑ°Êïà„ÄÇÂÆÉÊáâË©≤ÊòØ 'auto'„ÄÅ'true' Êàñ 'false' ÂÖ∂‰∏≠‰πã‰∏Ä„ÄÇ{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Â†±ÂëäÊ™îÊ°àÂ≠òÂèñÂÄºÁÑ°Êïà„ÄÇ{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">{1} ÁöÑ MSBuild ÁâàÊú¨ {0}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -150,25 +268,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Â∞éËá¥ MSBuild Âú®ÈöîÈõ¢‰∏≠Âª∫ÁΩÆÊØèÂÄãÂ∞àÊ°à„ÄÇ
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     Ë®≠ÂÆöÁÇ∫ "MessageUponIsolationViolation" 
+                     (ÊàñÂÖ∂Á∞°Áü≠ÂΩ¢Âºè "Message") ÊôÇÔºåÂ¶ÇÊûúÊèê‰æõ 
+                     -outputResultsCache ÂàáÊèõÔºåÂâáÂè™ÊúÉÂ∫èÂàóÂåñ‰æÜËá™
+                     È†ÇÂ±§ÁõÆÊ®ôÁöÑÁµêÊûú„ÄÇÈÄôÊòØÁÇ∫‰∫ÜÈôç‰ΩéÁõ∏‰æùÊÄßÂ∞àÊ°à‰∏äÔºå
+                     Áî±ÊñºÂÖ∂Áõ∏‰æùÊÄß‰ΩçÊñºÂø´ÂèñÁõÆÊ®ô‰∏ä (ÂÖ∂ÂâØ‰ΩúÁî®
+                     ‰∏çÊúÉÁ¥çÂÖ•ËÄÉÈáè)ÔºåËÄå‰ΩøÁî®‰∏çÊ≠£Á¢∫ÁãÄÊÖã
+                     ÈÄ†ÊàêÈÅïÂèçÈöîÈõ¢ÁõÆÊ®ôÁöÑÊ©üÊúÉ„ÄÇ
+                     (‰æãÂ¶ÇÔºåÂ±¨ÊÄßÁöÑÂÆöÁæ©„ÄÇ)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     ÈÄôÊòØ MSBuild Êõ¥ÂÖ∑ÈôêÂà∂ÁöÑÊ®°ÂºèÔºå
+                     Âõ†ÁÇ∫ÂÆÉË¶ÅÊ±ÇÂ∞àÊ°àÂúñÂΩ¢Âú®Ë©ï‰º∞ÈöéÊÆµÂèØÈùúÊÖãÊé¢Á¥¢Ôºå
+                     ‰ΩÜÂèØËÉΩÊúÉÊîπÂñÑÊéíÁ®ãÔºå‰∏¶Ê∏õÂ∞ëÂª∫ÁΩÆÂ§ßÈáèÂ∞àÊ°àÊôÇ
+                     ÁöÑË®òÊÜ∂È´îÈ°çÂ§ñË≤†Ëç∑„ÄÇ
+                     (Á∞°Áü≠ÂΩ¢Âºè: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Ê≠§ÊóóÊ®ôÊòØÂØ¶È©óÊÄßÔºåÂèØËÉΩÁÑ°Ê≥ïÂ¶ÇÈ†êÊúüÈÅã‰Ωú„ÄÇ
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -274,8 +392,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -284,14 +401,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     Ë¶ÅË¶ñÁÇ∫‰∏çË¶ñÁÇ∫ÈåØË™§ÁöÑË≠¶ÂëäÁ¢ºÊ∏ÖÂñÆ„ÄÇ
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Ë¶ÅË¶ñÁÇ∫‰∏çË¶ñÁÇ∫ÈåØË™§ÁöÑË≠¶Âëä‰ª£Á¢ºÊ∏ÖÂñÆ„ÄÇ
                      ‰ΩøÁî®ÂàÜËôüÊàñÈÄóËôüÂàÜÈöî
-                     Â§öÂÄãË≠¶ÂëäÁ¢º„ÄÇÂ¶ÇÊûú -warnaserror Ê≤íÊúâ‰ΩúÁî®
-                     Êú™Ë®≠ÂÆöÂàáÊèõÂèÉÊï∏„ÄÇ
+                     Â§öÂÄãË≠¶Âëä‰ª£Á¢º„ÄÇÂ¶ÇÊûúÊú™Ë®≠ÂÆö -warnaserror
+                     ÂàáÊèõÔºåÂâáÊ≤íÊúâ‰ΩúÁî®„ÄÇ
 
-ÁØÑ‰æã:
+                     ÁØÑ‰æã:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -450,11 +566,11 @@
         <target state="translated">  -logger:&lt;Ë®òÈåÑÂô®&gt;   ‰ΩøÁî®Ê≠§Ë®òÈåÑÂô®ÂèØË®òÈåÑ MSBuild ÁöÑ‰∫ã‰ª∂„ÄÇ
                      Ëã•Ë¶ÅÊåáÂÆöÂ§öÂÄãË®òÈåÑÂô®ÔºåË´ãÂêÑÂà•ÊåáÂÆöÊØèÂÄãË®òÈåÑÂô®„ÄÇ
                      &lt;Ë®òÈåÑÂô®&gt; Ë™ûÊ≥ïÁÇ∫:
-                       [&lt;È°ûÂà•&gt;,]&lt;ÁµÑ‰ª∂&gt;[,&lt;ÈÅ∏È†Ö&gt;][;&lt;ÂèÉÊï∏&gt;]
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
                      &lt;Ë®òÈåÑÂô®È°ûÂà•&gt; Ë™ûÊ≥ïÁÇ∫:
                        [&lt;‰∏ÄÈÉ®ÂàÜÊàñÂÆåÊï¥ÁöÑÂëΩÂêçÁ©∫Èñì&gt;.]&lt;Ë®òÈåÑÂô®È°ûÂà•ÂêçÁ®±&gt;
                      &lt;Ë®òÈåÑÂô®ÁµÑ‰ª∂&gt; Ë™ûÊ≥ïÁÇ∫:
-                       {&lt;ÁµÑ‰ª∂ÂêçÁ®±&gt;[,&lt;strong name&gt;] | &lt;ÁµÑ‰ª∂Ê™îÊ°à&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Ë®òÈåÑÂô®ÈÅ∏È†ÖÊúÉÊåáÂÆö MSBuild Âª∫Á´ãË®òÈåÑÂô®ÁöÑÊñπÂºè„ÄÇ
                      &lt;Ë®òÈåÑÂô®ÂèÉÊï∏&gt; ÊòØÈÅ∏ÊìáÊÄßÂèÉÊï∏ÔºåÂÖ∂ÊúÉ‰æùÊÇ®Ëº∏ÂÖ•ÁöÑÂÖßÂÆπÔºå
                      ÂÆåÂÖ®‰∏ÄÊ®£Âú∞ÂÇ≥ÈÅûÂà∞Ë®òÈåÑÂô®„ÄÇ(Á∞°Áü≠ÂΩ¢Âºè: -l)
@@ -477,12 +593,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;Â±§Á¥ö&gt; Âú®‰∫ã‰ª∂Ë®òÈåÑÊ™î‰∏≠È°ØÁ§∫Ê≠§Êï∏ÈáèÁöÑË≥áË®ä„ÄÇ
-                     ÂèØÁî®ÁöÑË©≥Á¥∞Á®ãÂ∫¶Â±§Á¥öÁÇ∫: q[uiet]„ÄÅm[inimal]„ÄÅ
+        <target state="translated">  -verbosity:&lt;level&gt; Âú®‰∫ã‰ª∂Ë®òÈåÑ‰∏≠È°ØÁ§∫Ê≠§Êï∏ÈáèÁöÑË≥áË®ä„ÄÇ
+                    ÂèØÁî®ÁöÑË©≥Á¥∞Â±§Á¥öÁÇ∫: q[uiet]„ÄÅm[inimal]„ÄÅ
                      n[ormal]„ÄÅd[etailed] Âíå diag[nostic]„ÄÇ(Á∞°Áü≠ÂΩ¢Âºè: -v)
-                     ÁØÑ‰æã:
+                    ÁØÑ‰æã:
                        -verbosity:quiet
+
+                     Ê≥®ÊÑè: Ê™îÊ°àË®òÈåÑÂô®ÁöÑË©≥Á¥∞Â±§Á¥ö
+                           ÊòØÁî± -fileloggerparameters
+                           ÂÄãÂà•Ë®≠ÂÆö„ÄÇ
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -531,40 +655,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     ‰∏ªÊéßÂè∞Ë®òÈåÑÂô®ÁöÑÂèÉÊï∏„ÄÇ(Á∞°Áü≠ÂΩ¢Âºè: -clp)
+                     ÂèØÁî®ÁöÑÂèÉÊï∏ÁÇ∫:
+                        PerformanceSummary--È°ØÁ§∫Â∑•‰Ωú„ÄÅÁõÆÊ®ô
+                            ÂèäÂ∞àÊ°àÊâÄËä±Ë≤ªÁöÑÊôÇÈñì„ÄÇ
+                        Summary--ÁµêÊùüÊôÇÈ°ØÁ§∫ÈåØË™§ËàáË≠¶ÂëäÊëòË¶Å„ÄÇ
+                        NoSummary--ÁµêÊùüÊôÇ‰∏çÈ°ØÁ§∫ÈåØË™§
+                            ËàáË≠¶ÂëäÊëòË¶Å„ÄÇ
+                        ErrorsOnly--Âè™È°ØÁ§∫ÈåØË™§„ÄÇ
+                        WarningsOnly--Âè™È°ØÁ§∫Ë≠¶Âëä„ÄÇ
+                        NoItemAndPropertyList--‰∏çÂú®ÊØèÂÄãÂ∞àÊ°àÈñãÂßãÂª∫ÁΩÆÊôÇÔºå
+                            È°ØÁ§∫Â∞àÊ°àËàáÂ±¨ÊÄßÊ∏ÖÂñÆ„ÄÇ
+                        ShowCommandLine--È°ØÁ§∫ TaskCommandLineEvent Ë®äÊÅØ
+                        ShowTimestamp--Âú®ÊâÄÊúâË®äÊÅØÈñãÈ†≠È°ØÁ§∫
+                            ÊôÇÈñìÊà≥Ë®ò„ÄÇ
+                        ShowEventId--È°ØÁ§∫Â∑≤ÈñãÂßã‰πã‰∫ã‰ª∂„ÄÅÂ∑≤ÂÆåÊàê‰πã‰∫ã‰ª∂
+                            ‰ª•ÂèäË®äÊÅØÁöÑ‰∫ã‰ª∂Ë≠òÂà•Á¢º
+                        ForceNoAlign--‰∏çÂ∞áÊñáÂ≠óË™øÊï¥Êàê‰∏ªÊéßÂè∞
+                            Á∑©Ë°ùÂçÄÁöÑÂ§ßÂ∞è
+                        DisableConsoleColor--ÁÇ∫ÊâÄÊúâË®òÈåÑË®äÊÅØ‰ΩøÁî®È†êË®≠ÁöÑ
+                            ‰∏ªÊéßÂè∞Ëâ≤ÂΩ©„ÄÇ
+                        DisableMPLogging-- Âú®ÈùûÂ§öËôïÁêÜÂô®Ê®°Âºè‰∏ãÂü∑Ë°åÊôÇÔºå
+                            ÂÅúÁî®Ëº∏Âá∫ÁöÑÂ§öËôïÁêÜÂô®
+                            Ë®òÈåÑÊ®£Âºè„ÄÇ
+                        EnableMPLogging--Âú®ÈùûÂ§öËôïÁêÜÂô®Ê®°Âºè‰∏ãÂü∑Ë°åÊôÇÔºå
+                            ÂïüÁî®Â§öËôïÁêÜÂô®Ë®òÈåÑÊ®£Âºè„ÄÇ
+                            Ê≠§Ë®òÈåÑÊ®£ÂºèÈ†êË®≠ÁÇ∫ÂïüÁî®„ÄÇ
+                        ForceConsoleColor--Âç≥‰Ωø‰∏ªÊéßÂè∞‰∏çÊîØÊè¥ ANSI ‰∏ªÊéßÂè∞Ëâ≤ÂΩ©Ôºå
+                            ‰πü‰∏ÄÂæã‰ΩøÁî®Ë©≤Ëâ≤ÂΩ©
+                        PreferConsoleColor--ÂÉÖÂú®ÁõÆÊ®ô‰∏ªÊéßÂè∞ÁõÆÊ®ôÁ¢∫ÂØ¶ÊîØÊè¥ ANSI ‰∏ªÊéßÂè∞Ëâ≤ÂΩ©ÊôÇ
+                            Êâç‰ΩøÁî®ÂÆÉ
+                     Verbosity--Ë¶ÜÂØ´Ê≠§Ë®òÈåÑÂô®ÁöÑ -verbosity
+                             Ë®≠ÂÆö„ÄÇ
+                     ÁØÑ‰æã:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -665,10 +789,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     MSBuild ÊúÉÂæû‰∏≠ËÆÄÂèñÂª∫ÁΩÆÁµêÊûúÁöÑËº∏ÂÖ•Âø´ÂèñÊ™îÊ°à
+                     ‰ª•ÂàÜËôüÂàÜÈöîÁöÑÊ∏ÖÂñÆ„ÄÇÂ¶ÇÊûúÂ∑≤Â∞á -isolateProjects
+                     Ë®≠ÁÇ∫ FalseÔºåÂâáÈÄôÊúÉÂ∞áÂÆÉË®≠ÁÇ∫ True„ÄÇ(Á∞°Áü≠ÂΩ¢Âºè: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -682,11 +806,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     MSBuild Â∞áÂú®Âª∫ÁΩÆÁµêÊùüÊôÇÂØ´ÂÖ•ÂÖ∂Âª∫ÁΩÆÁµêÊûúÂø´ÂèñÂÖßÂÆπ
+                     ÊâÄÂú®ÁöÑËº∏Âá∫Âø´ÂèñÊ™îÊ°à„ÄÇ
+                     Â¶ÇÊûúÂ∑≤Â∞á -isolateProjects Ë®≠ÁÇ∫ FalseÔºåÂâáÈÄôÊúÉÂ∞áÂÆÉË®≠ÁÇ∫ True„ÄÇ
+                     (Á∞°Áü≠ÂΩ¢Âºè: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -724,11 +848,11 @@
                      Ëã•Ë¶ÅÊåáÂÆöÂ§öÂÄãË®òÈåÑÂô®ÔºåË´ãÂêÑÂà•ÊåáÂÆöÊØèÂÄãË®òÈåÑÂô®„ÄÇ
                      (Á∞°Áü≠ÂΩ¢Âºè -dl)
                      &lt;Ë®òÈåÑÂô®&gt; Ë™ûÊ≥ïÁÇ∫:
-                       [&lt;È°ûÂà•&gt;,]&lt;ÁµÑ‰ª∂&gt;[,&lt;ÈÅ∏È†Ö&gt;][;&lt;ÂèÉÊï∏&gt;]
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
                      &lt;Ë®òÈåÑÂô®È°ûÂà•&gt; Ë™ûÊ≥ïÁÇ∫:
                        [&lt;‰∏ÄÈÉ®ÂàÜÊàñÂÆåÊï¥ÁöÑÂëΩÂêçÁ©∫Èñì&gt;.]&lt;Ë®òÈåÑÂô®È°ûÂà•ÂêçÁ®±&gt;
                      &lt;Ë®òÈåÑÂô®ÁµÑ‰ª∂&gt; Ë™ûÊ≥ïÁÇ∫:
-                       {&lt;ÁµÑ‰ª∂ÂêçÁ®±&gt;[,&lt;strong name&gt;] | &lt;ÁµÑ‰ª∂Ê™îÊ°à&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Ë®òÈåÑÂô®ÈÅ∏È†ÖÊúÉÊåáÂÆö MSBuild Âª∫Á´ãË®òÈåÑÂô®ÁöÑÊñπÂºè„ÄÇ
                      &lt;Ë®òÈåÑÂô®ÂèÉÊï∏&gt; ÊòØÈÅ∏ÊìáÊÄßÂèÉÊï∏ÔºåÂÖ∂ÊúÉ‰æùÊÇ®Ëº∏ÂÖ•ÁöÑÂÖßÂÆπÔºå
                      ÂÆåÂÖ®‰∏ÄÊ®£Âú∞ÂÇ≥ÈÅûÂà∞Ë®òÈåÑÂô®„ÄÇ(Á∞°Áü≠ÂΩ¢Âºè: -l)
@@ -1190,6 +1314,33 @@
         <target state="translated">MSBuild Ë®òÈåÑÂíåÂÅµÈåØÂ∑•ÂÖ∑Ë≥áË®äÂ∞á‰ΩçÊñº "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: ÂøÖÈ†àÊèê‰æõ getItem ÂàáÊèõÁöÑÈ†ÖÁõÆÂêçÁ®±„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: ÂøÖÈ†àÊèê‰æõ getProperty ÂàáÊèõÁöÑÂ±¨ÊÄßÂêçÁ®±„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: ÂøÖÈ†àÊèê‰æõ getTargetResult ÂàáÊèõÁöÑÁõÆÊ®ôÂêçÁ®±„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: ÊåáÂÆöË®òÈåÑÂô®„ÄÇ</target>
@@ -1241,6 +1392,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: Â¶ÇÊûú‰ΩøÁî® -terminalLoggerParameters ÂèÉÊï∏ÔºåË´ãÁÇ∫ÁµÇÁ´ØÊ©üË®òÈåÑÂô®ÊåáÂÆö‰∏ÄÊàñÂ§öÂÄãÂèÉÊï∏</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1277,6 +1438,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: ÂêçÁ®± "{0}" ÂåÖÂê´ÁÑ°ÊïàÂ≠óÂÖÉ "{1}"„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1307,6 +1475,60 @@
         <target state="translated">ÊµÅÁ®ã = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} Áßí)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} Áßí)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} Áßí)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> ‚Üí {0}</source>
+        <target state="translated"> ‚Üí {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} Áßí)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Â∞àÊ°àÊ™î‰∏çÂ≠òÂú®„ÄÇ</target>
@@ -1352,6 +1574,22 @@
         <target state="translated">'{0}' ‰æÜËá™ '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">ÈÇÑÂéüÂÆåÊàê ({0} Áßí)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Âú® {1} ÁßíÂÖßÈÇÑÂéü {0}</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1380,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: Âª∫ÁΩÆÊñπÊ°àÊ™îÊ°àÊàñÊñπÊ°àÁØ©ÈÅ∏Ê™îÊ°àÊôÇÔºåÁÑ°Ê≥ïÂ≠òÂèñÂ±¨ÊÄßÊàñÈ†ÖÁõÆ„ÄÇÊ≠§ÂäüËÉΩÂÉÖÊñºÂª∫ÁΩÆÂÄãÂà•Â∞àÊ°àÊôÇÂèØÁî®„ÄÇ</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1395,6 +1641,21 @@
         <target state="translated">MSBUILD : error MSB1059: ÁÑ°Ê≥ïÂàóÂç∞ÁõÆÊ®ô„ÄÇ{0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Âõ†ÁÇ∫ÁµÑÂª∫ÊòØÂú®Ë¶ÅÊ±ÇÁõ¥Êé•Â≠òÂèñ stdout Ë≥áÊñôÊµÅÁöÑËôïÁêÜÂ∏∏Âºè (‰æãÂ¶Ç 'dotnet test') ÂÖßÂÆπ‰∏≠Âü∑Ë°åÔºåÊâÄ‰ª•Êú™‰ΩøÁî®ÁµÇÁ´ØË®òÈåÑÂô®„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Âõ†ÁÇ∫‰∏çÊîØÊè¥Ëº∏Âá∫ÔºåÊâÄ‰ª•Êú™‰ΩøÁî®ÁµÇÁ´ØË®òÈåÑÂô®„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Âõ†ÁÇ∫Ëº∏Âá∫Ê≠£ÈáçÊñ∞Â∞éÂêëËá≥Ê™îÊ°àÔºåÊâÄ‰ª•Êú™‰ΩøÁî®ÁµÇÁ´ØË®òÈåÑÂô®„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: ÈÄôÂÄãÂèÉÊï∏‰∏ç‰ΩøÁî®‰ªª‰ΩïÂèÉÊï∏„ÄÇ</target>
@@ -1413,6 +1674,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild ‰∏çÊúÉÂú®Ê≠§ÁâàÊú¨ÁöÑ‰ΩúÊ•≠Á≥ªÁµ±‰∏äÂü∑Ë°å„ÄÇÂè™ÊúâÂú® Windows 7 ÂèäÊõ¥Êñ∞ÁâàÊú¨ÊâçÂèóÊîØÊè¥„ÄÇ</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="translated">Ëß£Ê±∫ÊñπÊ°àÊ™îÊ°à‰∏çÊîØÊè¥ '{0}' ÂàáÊèõ„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Ê≠£Âú®Âº∑Âà∂ËºâÂÖ• Microsoft.Build.EngineÔºåÂõ†ÁÇ∫ MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/TerminalLogger/BuildMessage.cs b/src/MSBuild/TerminalLogger/BuildMessage.cs
new file mode 100644
index 00000000000..a204690d041
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/BuildMessage.cs
@@ -0,0 +1,10 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+/// <summary>
+/// Represents a piece of diagnostic output (message/warning/error).
+/// </summary>
+internal record struct BuildMessage(MessageSeverity Severity, string Message)
+{ }
diff --git a/src/MSBuild/TerminalLogger/ITerminal.cs b/src/MSBuild/TerminalLogger/ITerminal.cs
new file mode 100644
index 00000000000..04a6dd8039f
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/ITerminal.cs
@@ -0,0 +1,71 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+/// <summary>
+/// An abstraction of a terminal, built specifically to fit the <see cref="TerminalLogger"/> needs.
+/// </summary>
+internal interface ITerminal : IDisposable
+{
+    /// <summary>
+    /// Width of the terminal buffer.
+    /// </summary>
+    int Width { get; }
+
+    /// <summary>
+    /// Height of the terminal buffer.
+    /// </summary>
+    int Height { get; }
+
+    /// <summary>
+    /// <see langword="true"/> if the terminal emulator supports progress reporting.
+    /// </summary>
+    bool SupportsProgressReporting { get; }
+
+    /// <summary>
+    /// Starts buffering the text passed via the <c>Write*</c> methods.
+    /// </summary>
+    /// <remarks>
+    /// Upon calling this method, the terminal should be buffering all output internally until <see cref="EndUpdate"/> is called.
+    /// </remarks>
+    void BeginUpdate();
+
+    /// <summary>
+    /// Flushes the text buffered between <see cref="BeginUpdate"/> was called and now into the output.
+    /// </summary>
+    void EndUpdate();
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void Write(string text);
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void Write(ReadOnlySpan<char> text);
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteLine(string text);
+
+    /// <summary>
+    /// Writes a string to the output, truncating it if it wouldn't fit on one screen line.
+    /// Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteLineFitToWidth(ReadOnlySpan<char> text);
+
+    /// <summary>
+    /// Writes a string to the output using the given color. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteColor(TerminalColor color, string text);
+
+    /// <summary>
+    /// Writes a string to the output using the given color. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteColorLine(TerminalColor color, string text);
+}
diff --git a/src/MSBuild/TerminalLogger/MessageSeverity.cs b/src/MSBuild/TerminalLogger/MessageSeverity.cs
new file mode 100644
index 00000000000..07aa9058be3
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/MessageSeverity.cs
@@ -0,0 +1,9 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+/// <summary>
+/// Enumerates the supported message severities.
+/// </summary>
+internal enum MessageSeverity { Warning, Error }
diff --git a/src/MSBuild/TerminalLogger/Project.cs b/src/MSBuild/TerminalLogger/Project.cs
new file mode 100644
index 00000000000..5ed03039bcc
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/Project.cs
@@ -0,0 +1,52 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+/// <summary>
+/// Represents a project being built.
+/// </summary>
+internal sealed class Project
+{
+    /// <summary>
+    /// Initialized a new <see cref="Project"/> with the given <paramref name="targetFramework"/>.
+    /// </summary>
+    /// <param name="targetFramework">The target framework of the project or null if not multi-targeting.</param>
+    public Project(string? targetFramework)
+    {
+        TargetFramework = targetFramework;
+    }
+
+    /// <summary>
+    /// A stopwatch to time the build of the project.
+    /// </summary>
+    public Stopwatch Stopwatch { get; } = Stopwatch.StartNew();
+
+    /// <summary>
+    /// Full path to the primary output of the project, if known.
+    /// </summary>
+    public ReadOnlyMemory<char>? OutputPath { get; set; }
+
+    /// <summary>
+    /// The target framework of the project or null if not multi-targeting.
+    /// </summary>
+    public string? TargetFramework { get; }
+
+    /// <summary>
+    /// A lazily initialized list of build messages/warnings/errors raised during the build.
+    /// </summary>
+    public List<BuildMessage>? BuildMessages { get; private set; }
+
+    /// <summary>
+    /// Adds a build message of the given severity to <see cref="BuildMessages"/>.
+    /// </summary>
+    public void AddBuildMessage(MessageSeverity severity, string message)
+    {
+        BuildMessages ??= new List<BuildMessage>();
+        BuildMessages.Add(new BuildMessage(severity, message));
+    }
+}
diff --git a/src/MSBuild/TerminalLogger/Terminal.cs b/src/MSBuild/TerminalLogger/Terminal.cs
new file mode 100644
index 00000000000..91565e1f797
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/Terminal.cs
@@ -0,0 +1,205 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Text;
+#if NETFRAMEWORK
+using Microsoft.Build.Shared;
+#endif
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+/// <summary>
+/// An <see cref="ITerminal"/> implementation for ANSI/VT100 terminals.
+/// </summary>
+internal sealed class Terminal : ITerminal
+{
+    /// <summary>
+    /// The encoding read from <see cref="Console.OutputEncoding"/> when the terminal is constructed.
+    /// </summary>
+    private readonly Encoding _originalOutputEncoding;
+
+    /// <summary>
+    /// A string buffer used with <see cref="BeginUpdate"/>/<see cref="EndUpdate"/>.
+    /// </summary>
+    private readonly StringBuilder _outputBuilder = new();
+
+    /// <summary>
+    /// True if <see cref="BeginUpdate"/> was called and <c>Write*</c> methods are buffering instead of directly printing.
+    /// </summary>
+    private bool _isBuffering = false;
+
+    internal TextWriter Output { private get; set; }
+
+    private const int BigUnknownDimension = 2 << 23;
+
+    /// <inheritdoc/>
+    public int Height
+    {
+        get
+        {
+            if (Console.IsOutputRedirected)
+            {
+                return BigUnknownDimension;
+            }
+
+            return Console.BufferHeight;
+        }
+    }
+
+    /// <inheritdoc/>
+    public int Width
+    {
+        get
+        {
+            if (Console.IsOutputRedirected)
+            {
+                return BigUnknownDimension;
+            }
+
+            return Console.BufferWidth;
+        }
+    }
+
+    /// <inheritdoc/>
+    /// <remarks>
+    /// https://github.com/dotnet/msbuild/issues/8958: iTerm2 treats ;9 code to post a notification instead, so disable progress reporting on Mac.
+    /// </remarks>
+    public bool SupportsProgressReporting { get; } = !RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
+
+    public Terminal()
+    {
+        _originalOutputEncoding = Console.OutputEncoding;
+        Console.OutputEncoding = Encoding.UTF8;
+
+        // Capture the TextWriter AFTER setting the encoding, because setting
+        // the encoding creates a new TextWriter in the Console class, but it's
+        // possible to hang on to the old one (with the wrong encoding) and emit
+        // garbage, as in https://github.com/dotnet/msbuild/issues/9030.
+        Output = Console.Out;
+    }
+
+    internal Terminal(TextWriter output)
+    {
+        Output = output;
+
+        _originalOutputEncoding = Encoding.UTF8;
+    }
+
+    /// <inheritdoc/>
+    public void BeginUpdate()
+    {
+        if (_isBuffering)
+        {
+            throw new InvalidOperationException();
+        }
+        _isBuffering = true;
+    }
+
+    /// <inheritdoc/>
+    public void EndUpdate()
+    {
+        if (!_isBuffering)
+        {
+            throw new InvalidOperationException();
+        }
+        _isBuffering = false;
+
+        Output.Write(_outputBuilder.ToString());
+        _outputBuilder.Clear();
+    }
+
+    /// <inheritdoc/>
+    public void Write(string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(text);
+        }
+        else
+        {
+            Output.Write(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void Write(ReadOnlySpan<char> text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(text);
+        }
+        else
+        {
+            Output.Write(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteLine(string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.AppendLine(text);
+        }
+        else
+        {
+            Output.WriteLine(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteLineFitToWidth(ReadOnlySpan<char> text)
+    {
+        ReadOnlySpan<char> truncatedText = text.Slice(0, Math.Min(text.Length, Width - 1));
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(truncatedText);
+            _outputBuilder.AppendLine();
+        }
+        else
+        {
+            Output.WriteLine(truncatedText);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteColor(TerminalColor color, string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder
+                .Append(AnsiCodes.CSI)
+                .Append((int)color)
+                .Append(AnsiCodes.SetColor)
+                .Append(text)
+                .Append(AnsiCodes.SetDefaultColor);
+        }
+        else
+        {
+            Write(AnsiCodes.Colorize(text, color));
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteColorLine(TerminalColor color, string text)
+    {
+        if (_isBuffering)
+        {
+            WriteColor(color, text);
+            _outputBuilder.AppendLine();
+        }
+        else
+        {
+            WriteLine($"{AnsiCodes.CSI}{(int)color}{AnsiCodes.SetColor}{text}{AnsiCodes.SetDefaultColor}");
+        }
+    }
+
+    /// <inheritdoc/>
+    public void Dispose()
+    {
+        Console.OutputEncoding = _originalOutputEncoding;
+    }
+}
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
new file mode 100644
index 00000000000..0d5d5cd2b09
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -0,0 +1,873 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+using System.Text;
+using System.Threading;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+#if NETFRAMEWORK
+using Microsoft.IO;
+#else
+using System.IO;
+#endif
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+/// <summary>
+/// A logger which updates the console output "live" during the build.
+/// </summary>
+/// <remarks>
+/// Uses ANSI/VT100 control codes to erase and overwrite lines as the build is progressing.
+/// </remarks>
+internal sealed class TerminalLogger : INodeLogger
+{
+    /// <summary>
+    /// A wrapper over the project context ID passed to us in <see cref="IEventSource"/> logger events.
+    /// </summary>
+    internal record struct ProjectContext(int Id)
+    {
+        public ProjectContext(BuildEventContext context)
+            : this(context.ProjectContextId)
+        { }
+    }
+
+    /// <summary>
+    /// Encapsulates the per-node data shown in live node output.
+    /// </summary>
+    internal record NodeStatus(string Project, string? TargetFramework, string Target, Stopwatch Stopwatch)
+    {
+        public override string ToString()
+        {
+            string duration = Stopwatch.Elapsed.TotalSeconds.ToString("F1");
+
+            return string.IsNullOrEmpty(TargetFramework)
+                ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectBuilding_NoTF",
+                    Indentation,
+                    Project,
+                    Target,
+                    duration)
+                : ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectBuilding_WithTF",
+                    Indentation,
+                    Project,
+                    AnsiCodes.Colorize(TargetFramework, TargetFrameworkColor),
+                    Target,
+                    duration);
+        }
+    }
+
+    /// <summary>
+    /// The indentation to use for all build output.
+    /// </summary>
+    private const string Indentation = "  ";
+
+    private const TerminalColor TargetFrameworkColor = TerminalColor.Cyan;
+
+    /// <summary>
+    /// Protects access to state shared between the logger callbacks and the rendering thread.
+    /// </summary>
+    private readonly object _lock = new();
+
+    /// <summary>
+    /// A cancellation token to signal the rendering thread that it should exit.
+    /// </summary>
+    private readonly CancellationTokenSource _cts = new();
+
+    /// <summary>
+    /// Tracks the status of all relevant projects seen so far.
+    /// </summary>
+    /// <remarks>
+    /// Keyed by an ID that gets passed to logger callbacks, this allows us to quickly look up the corresponding project.
+    /// </remarks>
+    private readonly Dictionary<ProjectContext, Project> _projects = new();
+
+    /// <summary>
+    /// Tracks the work currently being done by build nodes. Null means the node is not doing any work worth reporting.
+    /// </summary>
+    private NodeStatus?[] _nodes = Array.Empty<NodeStatus>();
+
+    /// <summary>
+    /// The timestamp of the <see cref="IEventSource.BuildStarted"/> event.
+    /// </summary>
+    private DateTime _buildStartTime;
+
+    /// <summary>
+    /// The working directory when the build starts, to trim relative output paths.
+    /// </summary>
+    private readonly string _initialWorkingDirectory = Environment.CurrentDirectory;
+
+    /// <summary>
+    /// True if the build has encountered at least one error.
+    /// </summary>
+    private bool _buildHasErrors;
+
+    /// <summary>
+    /// True if the build has encountered at least one warning.
+    /// </summary>
+    private bool _buildHasWarnings;
+
+    /// <summary>
+    /// True if restore failed and this failure has already been reported.
+    /// </summary>
+    private bool _restoreFailed;
+
+    /// <summary>
+    /// The project build context corresponding to the <c>Restore</c> initial target, or null if the build is currently
+    /// bot restoring.
+    /// </summary>
+    private ProjectContext? _restoreContext;
+
+    /// <summary>
+    /// The thread that performs periodic refresh of the console output.
+    /// </summary>
+    private Thread? _refresher;
+
+    /// <summary>
+    /// What is currently displaying in Nodes section as strings representing per-node console output.
+    /// </summary>
+    private NodesFrame _currentFrame = new(Array.Empty<NodeStatus>(), 0, 0);
+
+    /// <summary>
+    /// The <see cref="Terminal"/> to write console output to.
+    /// </summary>
+    private ITerminal Terminal { get; }
+
+    /// <summary>
+    /// Should the logger's test environment refresh the console output manually instead of using a background thread?
+    /// </summary>
+    private bool _manualRefresh;
+
+    /// <summary>
+    /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
+    /// </summary>
+    /// <remarks>
+    /// If TerminalLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main
+    /// node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
+    /// Important: Note that TerminalLogger is special-cased in <see cref="BackEnd.Logging.LoggingService.UpdateMinimumMessageImportance"/>
+    /// so changing this list may impact the minimum message importance logging optimization.
+    /// </remarks>
+    public static readonly string[] ConfigurableForwardingLoggerParameters =
+    {
+            "BUILDSTARTEDEVENT",
+            "BUILDFINISHEDEVENT",
+            "PROJECTSTARTEDEVENT",
+            "PROJECTFINISHEDEVENT",
+            "TARGETSTARTEDEVENT",
+            "TARGETFINISHEDEVENT",
+            "TASKSTARTEDEVENT",
+            "HIGHMESSAGEEVENT",
+            "WARNINGEVENT",
+            "ERROREVENT"
+    };
+
+    /// <summary>
+    /// The two directory separator characters to be passed to methods like <see cref="String.IndexOfAny(char[])"/>.
+    /// </summary>
+    private static readonly char[] PathSeparators = { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar };
+
+    /// <summary>
+    /// Default constructor, used by the MSBuild logger infra.
+    /// </summary>
+    public TerminalLogger()
+    {
+        Terminal = new Terminal();
+    }
+
+    /// <summary>
+    /// Internal constructor accepting a custom <see cref="ITerminal"/> for testing.
+    /// </summary>
+    internal TerminalLogger(ITerminal terminal)
+    {
+        Terminal = terminal;
+        _manualRefresh = true;
+    }
+
+    #region INodeLogger implementation
+
+    /// <inheritdoc/>
+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }
+
+    /// <inheritdoc/>
+    public string Parameters { get => ""; set { } }
+
+    /// <inheritdoc/>
+    public void Initialize(IEventSource eventSource, int nodeCount)
+    {
+        _nodes = new NodeStatus[nodeCount];
+
+        Initialize(eventSource);
+    }
+
+    /// <inheritdoc/>
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.BuildStarted += BuildStarted;
+        eventSource.BuildFinished += BuildFinished;
+        eventSource.ProjectStarted += ProjectStarted;
+        eventSource.ProjectFinished += ProjectFinished;
+        eventSource.TargetStarted += TargetStarted;
+        eventSource.TargetFinished += TargetFinished;
+        eventSource.TaskStarted += TaskStarted;
+
+        eventSource.MessageRaised += MessageRaised;
+        eventSource.WarningRaised += WarningRaised;
+        eventSource.ErrorRaised += ErrorRaised;
+
+        if (eventSource is IEventSource4 eventSource4)
+        {
+            eventSource4.IncludeEvaluationPropertiesAndItems();
+        }
+    }
+
+    /// <inheritdoc/>
+    public void Shutdown()
+    {
+        Terminal.Dispose();
+    }
+
+    #endregion
+
+    #region Logger callbacks
+
+    /// <summary>
+    /// The <see cref="IEventSource.BuildStarted"/> callback.
+    /// </summary>
+    private void BuildStarted(object sender, BuildStartedEventArgs e)
+    {
+        if (!_manualRefresh)
+        {
+            _refresher = new Thread(ThreadProc);
+            _refresher.Start();
+        }
+
+        _buildStartTime = e.Timestamp;
+
+        if (Terminal.SupportsProgressReporting)
+        {
+            Terminal.Write(AnsiCodes.SetProgressIndeterminate);
+        }
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.BuildFinished"/> callback.
+    /// </summary>
+    private void BuildFinished(object sender, BuildFinishedEventArgs e)
+    {
+        _cts.Cancel();
+        _refresher?.Join();
+
+        _projects.Clear();
+
+        Terminal.BeginUpdate();
+        try
+        {
+            string duration = (e.Timestamp - _buildStartTime).TotalSeconds.ToString("F1");
+            string buildResult = RenderBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);
+
+            Terminal.WriteLine("");
+            if (_restoreFailed)
+            {
+                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreCompleteWithMessage",
+                    buildResult,
+                    duration));
+            }
+            else
+            {
+                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("BuildFinished",
+                    buildResult,
+                    duration));
+            }
+        }
+        finally
+        {
+            if (Terminal.SupportsProgressReporting)
+            {
+                Terminal.Write(AnsiCodes.RemoveProgress);
+            }
+
+            Terminal.EndUpdate();
+        }
+
+        _buildHasErrors = false;
+        _buildHasWarnings = false;
+        _restoreFailed = false;
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.ProjectStarted"/> callback.
+    /// </summary>
+    private void ProjectStarted(object sender, ProjectStartedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is null)
+        {
+            return;
+        }
+
+        ProjectContext c = new ProjectContext(buildEventContext);
+
+        if (_restoreContext is null)
+        {
+            if (e.GlobalProperties?.TryGetValue("TargetFramework", out string? targetFramework) != true)
+            {
+                targetFramework = null;
+            }
+            _projects[c] = new(targetFramework);
+        }
+
+        if (e.TargetNames == "Restore")
+        {
+            _restoreContext = c;
+            _nodes[0] = new NodeStatus(e.ProjectFile!, null, "Restore", _projects[c].Stopwatch);
+        }
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.ProjectFinished"/> callback.
+    /// </summary>
+    private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is null)
+        {
+            return;
+        }
+
+        // Mark node idle until something uses it again
+        if (_restoreContext is null)
+        {
+            lock (_lock)
+            {
+                _nodes[NodeIndexForContext(buildEventContext)] = null;
+            }
+        }
+
+        ProjectContext c = new(buildEventContext);
+
+        if (_projects.TryGetValue(c, out Project? project))
+        {
+            lock (_lock)
+            {
+                Terminal.BeginUpdate();
+                try
+                {
+                    EraseNodes();
+
+                    string duration = project.Stopwatch.Elapsed.TotalSeconds.ToString("F1");
+                    ReadOnlyMemory<char>? outputPath = project.OutputPath;
+
+                    string projectFile = e.ProjectFile is not null ?
+                        Path.GetFileNameWithoutExtension(e.ProjectFile) :
+                        string.Empty;
+
+                    // Build result. One of 'failed', 'succeeded with warnings', or 'succeeded' depending on the build result and diagnostic messages
+                    // reported during build.
+                    bool haveErrors = project.BuildMessages?.Exists(m => m.Severity == MessageSeverity.Error) == true;
+                    bool haveWarnings = project.BuildMessages?.Exists(m => m.Severity == MessageSeverity.Warning) == true;
+
+                    string buildResult = RenderBuildResult(e.Succeeded, haveErrors, haveWarnings);
+
+                    // Check if we're done restoring.
+                    if (c == _restoreContext)
+                    {
+                        if (e.Succeeded)
+                        {
+                            if (haveErrors || haveWarnings)
+                            {
+                                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreCompleteWithMessage",
+                                    buildResult,
+                                    duration));
+                            }
+                            else
+                            {
+                                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreComplete",
+                                    duration));
+                            }
+                        }
+                        else
+                        {
+                            // It will be reported after build finishes.
+                            _restoreFailed = true;
+                        }
+
+                        _restoreContext = null;
+                    }
+                    // If this was a notable project build, we print it as completed only if it's produced an output or warnings/error.
+                    else if (project.OutputPath is not null || project.BuildMessages is not null)
+                    {
+                        // Show project build complete and its output
+
+                        if (string.IsNullOrEmpty(project.TargetFramework))
+                        {
+                            Terminal.Write(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectFinished_NoTF",
+                                Indentation,
+                                projectFile,
+                                buildResult,
+                                duration));
+                        }
+                        else
+                        {
+                            Terminal.Write(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectFinished_WithTF",
+                                Indentation,
+                                projectFile,
+                                AnsiCodes.Colorize(project.TargetFramework, TargetFrameworkColor),
+                                buildResult,
+                                duration));
+                        }
+
+                        // Print the output path as a link if we have it.
+                        if (outputPath is not null)
+                        {
+                            ReadOnlySpan<char> outputPathSpan = outputPath.Value.Span;
+                            ReadOnlySpan<char> url = outputPathSpan;
+                            try
+                            {
+                                // If possible, make the link point to the containing directory of the output.
+                                url = Path.GetDirectoryName(url);
+                            }
+                            catch
+                            {
+                                // Ignore any GetDirectoryName exceptions.
+                            }
+
+                            // Generates file:// schema url string which is better handled by various Terminal clients than raw folder name.
+                            string urlString = url.ToString();
+                            if (Uri.TryCreate(urlString, UriKind.Absolute, out Uri? uri))
+                            {
+                                urlString = uri.AbsoluteUri;
+                            }
+
+                            // If the output path is under the initial working directory, make the console output relative to that to save space.
+                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))
+                            {
+                                if (outputPathSpan.Length > _initialWorkingDirectory.Length
+                                    && (outputPathSpan[_initialWorkingDirectory.Length] == Path.DirectorySeparatorChar
+                                        || outputPathSpan[_initialWorkingDirectory.Length] == Path.AltDirectorySeparatorChar))
+                                {
+                                    outputPathSpan = outputPathSpan.Slice(_initialWorkingDirectory.Length + 1);
+                                }
+                            }
+
+                            Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectFinished_OutputPath",
+                                $"{AnsiCodes.LinkPrefix}{urlString}{AnsiCodes.LinkInfix}{outputPathSpan.ToString()}{AnsiCodes.LinkSuffix}"));
+                        }
+                        else
+                        {
+                            Terminal.WriteLine(string.Empty);
+                        }
+                    }
+
+                    // Print diagnostic output under the Project -> Output line.
+                    if (project.BuildMessages is not null)
+                    {
+                        foreach (BuildMessage buildMessage in project.BuildMessages)
+                        {
+                            Terminal.WriteLine($"{Indentation}{Indentation}{buildMessage.Message}");
+                        }
+                    }
+
+                    _buildHasErrors |= haveErrors;
+                    _buildHasWarnings |= haveWarnings;
+
+                    DisplayNodes();
+                }
+                finally
+                {
+                    Terminal.EndUpdate();
+                }
+            }
+        }
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.TargetStarted"/> callback.
+    /// </summary>
+    private void TargetStarted(object sender, TargetStartedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (_restoreContext is null && buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        {
+            project.Stopwatch.Start();
+
+            string projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile);
+            NodeStatus nodeStatus = new(projectFile, project.TargetFramework, e.TargetName, project.Stopwatch);
+            lock (_lock)
+            {
+                _nodes[NodeIndexForContext(buildEventContext)] = nodeStatus;
+            }
+        }
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.TargetFinished"/> callback. Unused.
+    /// </summary>
+    private void TargetFinished(object sender, TargetFinishedEventArgs e)
+    {
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.TaskStarted"/> callback.
+    /// </summary>
+    private void TaskStarted(object sender, TaskStartedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (_restoreContext is null && buildEventContext is not null && e.TaskName == "MSBuild")
+        {
+            // This will yield the node, so preemptively mark it idle
+            lock (_lock)
+            {
+                _nodes[NodeIndexForContext(buildEventContext)] = null;
+            }
+
+            if (_projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+            {
+                project.Stopwatch.Stop();
+            }
+        }
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.MessageRaised"/> callback.
+    /// </summary>
+    private void MessageRaised(object sender, BuildMessageEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is null)
+        {
+            return;
+        }
+
+        string? message = e.Message;
+        if (message is not null && e.Importance == MessageImportance.High)
+        {
+            // Detect project output path by matching high-importance messages against the "$(MSBuildProjectName) -> ..."
+            // pattern used by the CopyFilesToOutputDirectory target.
+            int index = message.IndexOf(" -> ", StringComparison.Ordinal);
+            if (index > 0)
+            {
+                var projectFileName = Path.GetFileName(e.ProjectFile.AsSpan());
+                if (!projectFileName.IsEmpty &&
+                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) &&
+                    _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+                {
+                    ReadOnlyMemory<char> outputPath = e.Message.AsMemory().Slice(index + 4);
+                    project.OutputPath = outputPath;
+                }
+            }
+        }
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.WarningRaised"/> callback.
+    /// </summary>
+    private void WarningRaised(object sender, BuildWarningEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        {
+            string message = EventArgsFormatting.FormatEventMessage(
+                category: AnsiCodes.Colorize("warning", TerminalColor.Yellow),
+                subcategory: e.Subcategory,
+                message: e.Message,
+                code: AnsiCodes.Colorize(e.Code, TerminalColor.Yellow),
+                file: HighlightFileName(e.File),
+                projectFile: null,
+                lineNumber: e.LineNumber,
+                endLineNumber: e.EndLineNumber,
+                columnNumber: e.ColumnNumber,
+                endColumnNumber: e.EndColumnNumber,
+                threadId: e.ThreadId,
+                logOutputProperties: null);
+
+            project.AddBuildMessage(MessageSeverity.Warning, message);
+        }
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.ErrorRaised"/> callback.
+    /// </summary>
+    private void ErrorRaised(object sender, BuildErrorEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        {
+            string message = EventArgsFormatting.FormatEventMessage(
+                category: AnsiCodes.Colorize("error", TerminalColor.Red),
+                subcategory: e.Subcategory,
+                message: e.Message,
+                code: AnsiCodes.Colorize(e.Code, TerminalColor.Red),
+                file: HighlightFileName(e.File),
+                projectFile: null,
+                lineNumber: e.LineNumber,
+                endLineNumber: e.EndLineNumber,
+                columnNumber: e.ColumnNumber,
+                endColumnNumber: e.EndColumnNumber,
+                threadId: e.ThreadId,
+                logOutputProperties: null);
+
+            project.AddBuildMessage(MessageSeverity.Error, message);
+        }
+    }
+
+    #endregion
+
+    #region Refresher thread implementation
+
+    /// <summary>
+    /// The <see cref="_refresher"/> thread proc.
+    /// </summary>
+    private void ThreadProc()
+    {
+        while (!_cts.IsCancellationRequested)
+        {
+            Thread.Sleep(1_000 / 30); // poor approx of 30Hz
+
+            lock (_lock)
+            {
+                DisplayNodes();
+            }
+        }
+
+        EraseNodes();
+    }
+
+    /// <summary>
+    /// Render Nodes section.
+    /// It shows what all build nodes do.
+    /// </summary>
+    internal void DisplayNodes()
+    {
+        NodesFrame newFrame = new NodesFrame(_nodes, width: Terminal.Width, height: Terminal.Height);
+
+        // Do not render delta but clear everything if Terminal width or height have changed.
+        if (newFrame.Width != _currentFrame.Width || newFrame.Height != _currentFrame.Height)
+        {
+            EraseNodes();
+        }
+
+        string rendered = newFrame.Render(_currentFrame);
+
+        // Hide the cursor to prevent it from jumping around as we overwrite the live lines.
+        Terminal.Write(AnsiCodes.HideCursor);
+        try
+        {
+            // Move cursor back to 1st line of nodes.
+            Terminal.WriteLine($"{AnsiCodes.CSI}{_currentFrame.NodesCount + 1}{AnsiCodes.MoveUpToLineStart}");
+            Terminal.Write(rendered);
+        }
+        finally
+        {
+            Terminal.Write(AnsiCodes.ShowCursor);
+        }
+
+        _currentFrame = newFrame;
+    }
+
+    /// <summary>
+    /// Erases the previously printed live node output.
+    /// </summary>
+    private void EraseNodes()
+    {
+        if (_currentFrame.NodesCount == 0)
+        {
+            return;
+        }
+        Terminal.WriteLine($"{AnsiCodes.CSI}{_currentFrame.NodesCount + 1}{AnsiCodes.MoveUpToLineStart}");
+        Terminal.Write($"{AnsiCodes.CSI}{AnsiCodes.EraseInDisplay}");
+        _currentFrame.Clear();
+    }
+
+    /// <summary>
+    /// Capture states on nodes to be rendered on display.
+    /// </summary>
+    private sealed class NodesFrame
+    {
+        private readonly List<string> _nodeStrings = new();
+        private readonly StringBuilder _renderBuilder = new();
+
+        public int Width { get; }
+        public int Height { get; }
+        public int NodesCount { get; private set; }
+
+        public NodesFrame(NodeStatus?[] nodes, int width, int height)
+        {
+            Width = width;
+            Height = height;
+            Init(nodes);
+        }
+
+        public string NodeString(int index)
+        {
+            if (index >= NodesCount)
+            {
+                throw new ArgumentOutOfRangeException(nameof(index));
+            }
+
+            return _nodeStrings[index];
+        }
+
+        private void Init(NodeStatus?[] nodes)
+        {
+            int i = 0;
+            foreach (NodeStatus? n in nodes)
+            {
+                if (n is null)
+                {
+                    continue;
+                }
+                string str = n.ToString();
+
+                if (i < _nodeStrings.Count)
+                {
+                    _nodeStrings[i] = str;
+                }
+                else
+                {
+                    _nodeStrings.Add(str);
+                }
+                i++;
+
+                // We cant output more than what fits on screen
+                // -2 because cursor command F cant reach, in Windows Terminal, very 1st line, and last line is empty caused by very last WriteLine
+                if (i >= Height - 2)
+                {
+                    break;
+                }
+            }
+
+            NodesCount = i;
+        }
+
+        private ReadOnlySpan<char> FitToWidth(ReadOnlySpan<char> input)
+        {
+            return input.Slice(0, Math.Min(input.Length, Width - 1));
+        }
+
+        /// <summary>
+        /// Render VT100 string to update from current to next frame.
+        /// </summary>
+        public string Render(NodesFrame previousFrame)
+        {
+            StringBuilder sb = _renderBuilder;
+            sb.Clear();
+
+            int i = 0;
+            for (; i < NodesCount; i++)
+            {
+                var needed = FitToWidth(NodeString(i).AsSpan());
+
+                // Do we have previous node string to compare with?
+                if (previousFrame.NodesCount > i)
+                {
+                    var previous = FitToWidth(previousFrame.NodeString(i).AsSpan());
+
+                    if (!previous.SequenceEqual(needed))
+                    {
+                        int commonPrefixLen = previous.CommonPrefixLength(needed);
+
+                        if (commonPrefixLen != 0 && needed.Slice(0, commonPrefixLen).IndexOf('\x1b') == -1)
+                        {
+                            // no escape codes, so can trivially skip substrings
+                            sb.Append($"{AnsiCodes.CSI}{commonPrefixLen}{AnsiCodes.MoveForward}");
+                            sb.Append(needed.Slice(commonPrefixLen));
+                        }
+                        else
+                        {
+                            sb.Append(needed);
+                        }
+
+                        // Shall we clear rest of line
+                        if (needed.Length < previous.Length)
+                        {
+                            sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInLine}");
+                        }
+                    }
+                }
+                else
+                {
+                    // From now on we have to simply WriteLine
+                    sb.Append(needed);
+                }
+
+                // Next line
+                sb.AppendLine();
+            }
+
+            // clear no longer used lines
+            if (i < previousFrame.NodesCount)
+            {
+                sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInDisplay}");
+            }
+
+            return sb.ToString();
+        }
+
+        public void Clear()
+        {
+            NodesCount = 0;
+        }
+    }
+
+    #endregion
+
+    #region Helpers
+
+    /// <summary>
+    /// Print a build result summary to the output.
+    /// </summary>
+    /// <param name="succeeded">True if the build completed with success.</param>
+    /// <param name="hasError">True if the build has logged at least one error.</param>
+    /// <param name="hasWarning">True if the build has logged at least one warning.</param>
+    private string RenderBuildResult(bool succeeded, bool hasError, bool hasWarning)
+    {
+        if (!succeeded)
+        {
+            // If the build failed, we print one of three red strings.
+            string text = (hasError, hasWarning) switch
+            {
+                (true, _) => ResourceUtilities.GetResourceString("BuildResult_FailedWithErrors"),
+                (false, true) => ResourceUtilities.GetResourceString("BuildResult_FailedWithWarnings"),
+                _ => ResourceUtilities.GetResourceString("BuildResult_Failed"),
+            };
+            return AnsiCodes.Colorize(text, TerminalColor.Red);
+        }
+        else if (hasWarning)
+        {
+            return AnsiCodes.Colorize(ResourceUtilities.GetResourceString("BuildResult_SucceededWithWarnings"), TerminalColor.Yellow);
+        }
+        else
+        {
+            return AnsiCodes.Colorize(ResourceUtilities.GetResourceString("BuildResult_Succeeded"), TerminalColor.Green);
+        }
+    }
+
+    /// <summary>
+    /// Returns the <see cref="_nodes"/> index corresponding to the given <see cref="BuildEventContext"/>.
+    /// </summary>
+    private int NodeIndexForContext(BuildEventContext context)
+    {
+        // Node IDs reported by the build are 1-based.
+        return context.NodeId - 1;
+    }
+
+    /// <summary>
+    /// Colorizes the filename part of the given path.
+    /// </summary>
+    private static string? HighlightFileName(string? path)
+    {
+        if (path == null)
+        {
+            return null;
+        }
+
+        int index = path.LastIndexOfAny(PathSeparators);
+        return index >= 0
+            ? $"{path.Substring(0, index + 1)}{AnsiCodes.MakeBold(path.Substring(index + 1))}"
+            : path;
+    }
+
+    #endregion
+}
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index e3db80df525..dacfef278e2 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1,4 +1,4 @@
-// Licensed to the .NET Foundation under one or more agreements.
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -17,29 +17,30 @@
 using System.Text;
 using System.Text.RegularExpressions;
 using System.Threading;
-
+using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Graph;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
-
-using FileLogger = Microsoft.Build.Logging.FileLogger;
+using Microsoft.Build.Utilities;
+using static Microsoft.Build.CommandLine.MSBuildApp;
+using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
 using ConsoleLogger = Microsoft.Build.Logging.ConsoleLogger;
-using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
+using FileLogger = Microsoft.Build.Logging.FileLogger;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
-using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
-using Microsoft.Build.Shared.Debugging;
-using Microsoft.Build.Experimental;
-using Microsoft.Build.Framework.Telemetry;
-using Microsoft.Build.Internal;
-using Microsoft.Build.Logging.LiveLogger;
-using System.Runtime.InteropServices;
+using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
+using SimpleErrorLogger = Microsoft.Build.Logging.SimpleErrorLogger.SimpleErrorLogger;
+using TerminalLogger = Microsoft.Build.Logging.TerminalLogger.TerminalLogger;
 
 #nullable disable
 
@@ -221,6 +222,10 @@ string[] args
             )
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
         {
+            // Setup the console UI.
+            using AutomaticEncodingRestorer _ = new();
+            SetConsoleUI();
+
             DebuggerLaunchCheck();
 
             // Initialize new build telemetry and record start of this build.
@@ -664,9 +669,6 @@ public static ExitType Execute(
                 // check the operating system the code is running on
                 VerifyThrowSupportedOS();
 
-                // Setup the console UI.
-                SetConsoleUI();
-
                 // reset the application state for this new build
                 ResetBuildState();
 
@@ -706,6 +708,14 @@ public static ExitType Execute(
                 bool lowPriority = false;
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
+                bool question = false;
+                string[] getProperty = Array.Empty<string>();
+                string[] getItem = Array.Empty<string>();
+                string[] getTargetResult = Array.Empty<string>();
+                BuildResult result = null;
+#if FEATURE_REPORTFILEACCESSES
+                bool reportFileAccesses = false;
+#endif
 
                 GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile, out _);
                 bool buildCanBeInvoked = ProcessCommandLineSwitches(
@@ -740,7 +750,14 @@ public static ExitType Execute(
                                             ref graphBuildOptions,
                                             ref inputResultsCaches,
                                             ref outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+                                            ref reportFileAccesses,
+#endif
                                             ref lowPriority,
+                                            ref question,
+                                            ref getProperty,
+                                            ref getItem,
+                                            ref getTargetResult,
                                             recursing: false,
 #if FEATURE_GET_COMMANDLINE
                                             commandLine);
@@ -758,10 +775,13 @@ public static ExitType Execute(
                     // Only display the message if /m isn't provided
                     if (cpuCount == 1 && FileUtilities.IsSolutionFilename(projectFile) && verbosity > LoggerVerbosity.Minimal
                         && switchesNotFromAutoResponseFile[CommandLineSwitches.ParameterizedSwitch.MaxCPUCount].Length == 0
-                        && switchesFromAutoResponseFile[CommandLineSwitches.ParameterizedSwitch.MaxCPUCount].Length == 0)
+                        && switchesFromAutoResponseFile[CommandLineSwitches.ParameterizedSwitch.MaxCPUCount].Length == 0
+                        && preprocessWriter != null
+                        && targetsWriter != null)
                     {
                         Console.WriteLine(ResourceUtilities.GetResourceString("PossiblyOmittedMaxCPUSwitch"));
                     }
+
                     if (preprocessWriter != null && !BuildEnvironmentHelper.Instance.RunningTests)
                     {
                         // Indicate to the engine that it can NOT toss extraneous file content: we want to
@@ -771,12 +791,31 @@ public static ExitType Execute(
 
                     DateTime t1 = DateTime.Now;
 
+                    bool outputPropertiesItemsOrTargetResults = getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0;
+
                     // If the primary file passed to MSBuild is a .binlog file, play it back into passed loggers
                     // as if a build is happening
                     if (FileUtilities.IsBinaryLogFilename(projectFile))
                     {
                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);
                     }
+                    else if (outputPropertiesItemsOrTargetResults && FileUtilities.IsSolutionFilename(projectFile))
+                    {
+                        exitType = ExitType.BuildError;
+                        CommandLineSwitchException.Throw("SolutionBuildInvalidForCommandLineEvaluation",
+                            getProperty.Length > 0 ? "getProperty" :
+                            getItem.Length > 0 ? "getItem" :
+                            "getTargetResult");
+                    }
+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))
+                    {
+                        using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
+                        {
+                            Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
+                            exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project);
+                            collection.LogBuildFinishedEvent(exitType == ExitType.Success);
+                        }
+                    }
                     else // regular build
                     {
                         // if everything checks out, and sufficient information is available to start building
@@ -808,8 +847,14 @@ public static ExitType Execute(
                                     isolateProjects,
                                     graphBuildOptions,
                                     lowPriority,
+                                    question,
                                     inputResultsCaches,
                                     outputResultsCache,
+                                    saveProjectResult: outputPropertiesItemsOrTargetResults,
+                                    ref result,
+#if FEATURE_REPORTFILEACCESSES
+                                    reportFileAccesses,
+#endif
                                     commandLine))
                         {
                             exitType = ExitType.BuildError;
@@ -822,6 +867,11 @@ public static ExitType Execute(
 
                     string timerOutputFilename = Environment.GetEnvironmentVariable("MSBUILDTIMEROUTPUTS");
 
+                    if (outputPropertiesItemsOrTargetResults && targets?.Length > 0 && result is not null)
+                    {
+                        exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType);
+                    }
+
                     if (!string.IsNullOrEmpty(timerOutputFilename))
                     {
                         AppendOutputFile(timerOutputFilename, (long)elapsedTime.TotalMilliseconds);
@@ -961,6 +1011,8 @@ public static ExitType Execute(
                 // Wait for any pending cancel, so that we get any remaining messages
                 s_cancelComplete.WaitOne();
 
+                NativeMethodsShared.RestoreConsoleMode(s_originalConsoleMode);
+
 #if FEATURE_GET_COMMANDLINE
                 MSBuildEventSource.Log.MSBuildExeStop(commandLine);
 #else
@@ -977,6 +1029,64 @@ public static ExitType Execute(
             return exitType;
         }
 
+        private static ExitType OutputPropertiesAfterEvaluation(string[] getProperty, string[] getItem, Project project)
+        {
+            try
+            {
+                // Special case if the user requests exactly one property: skip json formatting
+                if (getProperty.Length == 1 && getItem.Length == 0)
+                {
+                    Console.WriteLine(project.GetPropertyValue(getProperty[0]));
+                }
+                else
+                {
+                    JsonOutputFormatter jsonOutputFormatter = new();
+                    jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => project.GetPropertyValue(property));
+                    jsonOutputFormatter.AddItemsInJsonFormat(getItem, project);
+                    Console.WriteLine(jsonOutputFormatter.ToString());
+                }
+
+                return ExitType.Success;
+            }
+            catch (InvalidProjectFileException e)
+            {
+                Console.Error.WriteLine(e.Message);
+                return ExitType.BuildError;
+            }
+        }
+
+        private static ExitType OutputBuildInformationInJson(BuildResult result, string[] getProperty, string[] getItem, string[] getTargetResult, ILogger[] loggers, ExitType exitType)
+        {
+            ProjectInstance builtProject = result.ProjectStateAfterBuild;
+
+            ILogger logger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);
+            if (logger is not null)
+            {
+                exitType = exitType == ExitType.Success && (logger as SimpleErrorLogger).HasLoggedErrors ? ExitType.BuildError : exitType;
+            }
+
+            if (builtProject is null)
+            {
+                // Build failed; do not proceed
+                Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildFailedWithPropertiesItemsOrTargetResultsRequested"));
+            }
+            // Special case if the user requests exactly one property: skip the json formatting
+            else if (getProperty.Length == 1 && getItem.Length == 0 && getTargetResult.Length == 0)
+            {
+                Console.WriteLine(builtProject.GetPropertyValue(getProperty[0]));
+            }
+            else
+            {
+                JsonOutputFormatter jsonOutputFormatter = new();
+                jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => builtProject.GetPropertyValue(property));
+                jsonOutputFormatter.AddItemInstancesInJsonFormat(getItem, builtProject);
+                jsonOutputFormatter.AddTargetResultsInJsonFormat(getTargetResult, result);
+                Console.WriteLine(jsonOutputFormatter.ToString());
+            }
+
+            return exitType;
+        }
+
         /// <summary>
         /// Handler for when CTRL-C or CTRL-BREAK is called.
         /// CTRL-BREAK means "die immediately"
@@ -1086,7 +1196,12 @@ private static void ResetGatheringSwitchesState()
         /// <summary>
         /// List of messages to be sent to the logger when it is attached
         /// </summary>
-        private static List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
+        private static readonly List<BuildManager.DeferredBuildMessage> s_globalMessagesToLogInBuildLoggers = new();
+
+        /// <summary>
+        /// The original console output mode if we changed it as part of initialization.
+        /// </summary>
+        private static uint? s_originalConsoleMode = null;
 
         /// <summary>
         /// Initializes the build engine, and starts the project building.
@@ -1121,8 +1236,14 @@ internal static bool BuildProject(
             ProjectIsolationMode isolateProjects,
             GraphBuildOptions graphBuildOptions,
             bool lowPriority,
+            bool question,
             string[] inputResultsCaches,
             string outputResultsCache,
+            bool saveProjectResult,
+            ref BuildResult result,
+#if FEATURE_REPORTFILEACCESSES
+            bool reportFileAccesses,
+#endif
 #if FEATURE_GET_COMMANDLINE
             string commandLine)
 #else
@@ -1207,8 +1328,8 @@ internal static bool BuildProject(
 
                 ToolsetDefinitionLocations toolsetDefinitionLocations = ToolsetDefinitionLocations.Default;
 
-                bool preprocessOnly = preprocessWriter != null && !FileUtilities.IsSolutionFilename(projectFile);
-                bool targetsOnly = targetsWriter != null && !FileUtilities.IsSolutionFilename(projectFile);
+                bool isPreprocess = preprocessWriter != null;
+                bool isTargets = targetsWriter != null;
 
                 projectCollection = new ProjectCollection(
                     globalProperties,
@@ -1217,7 +1338,7 @@ internal static bool BuildProject(
                     toolsetDefinitionLocations,
                     cpuCount,
                     onlyLogCriticalEvents,
-                    loadProjectsReadOnly: !preprocessOnly,
+                    loadProjectsReadOnly: !isPreprocess,
                     useAsynchronousLogging: true,
                     reuseProjectRootElementCache: s_isServerNode);
 
@@ -1226,9 +1347,11 @@ internal static bool BuildProject(
                     ThrowInvalidToolsVersionInitializationException(projectCollection.Toolsets, toolsVersion);
                 }
 
+                bool isSolution = FileUtilities.IsSolutionFilename(projectFile);
+
 #if FEATURE_XML_SCHEMA_VALIDATION
                 // If the user has requested that the schema be validated, do that here.
-                if (needToValidateProject && !FileUtilities.IsSolutionFilename(projectFile))
+                if (needToValidateProject && !isSolution)
                 {
                     Microsoft.Build.Evaluation.Project project = projectCollection.LoadProject(projectFile, globalProperties, toolsVersion);
                     Microsoft.Build.Evaluation.Toolset toolset = projectCollection.GetToolset(toolsVersion ?? project.ToolsVersion);
@@ -1246,22 +1369,41 @@ internal static bool BuildProject(
                 }
 #endif
 
-                if (preprocessOnly)
+                if (isPreprocess)
                 {
-                    Project project = projectCollection.LoadProject(projectFile, globalProperties, toolsVersion);
+                    // TODO: Support /preprocess for solution files. https://github.com/dotnet/msbuild/issues/7697
+                    if (isSolution)
+                    {
+                        Console.WriteLine(ResourceUtilities.GetResourceString("UnsupportedSwitchForSolutionFiles"), CommandLineSwitches.ParameterizedSwitch.Preprocess);
+                        success = false;
+                    }
+                    else
+                    {
+                        Project project = projectCollection.LoadProject(projectFile, globalProperties, toolsVersion);
 
-                    project.SaveLogicalProject(preprocessWriter);
+                        project.SaveLogicalProject(preprocessWriter);
 
-                    projectCollection.UnloadProject(project);
-                    success = true;
+                        projectCollection.UnloadProject(project);
+
+                        success = true;
+                    }
                 }
 
-                if (targetsOnly)
+                if (isTargets)
                 {
-                    success = PrintTargets(projectFile, toolsVersion, globalProperties, targetsWriter, projectCollection);
+                    // TODO: Support /targets for solution files. https://github.com/dotnet/msbuild/issues/7697
+                    if (isSolution)
+                    {
+                        Console.WriteLine(ResourceUtilities.GetResourceString("UnsupportedSwitchForSolutionFiles"), CommandLineSwitches.ParameterizedSwitch.Targets);
+                        success = false;
+                    }
+                    else
+                    {
+                        success = PrintTargets(projectFile, toolsVersion, globalProperties, targetsWriter, projectCollection);
+                    }
                 }
 
-                if (!preprocessOnly && !targetsOnly)
+                if (!isPreprocess && !isTargets)
                 {
                     BuildParameters parameters = new BuildParameters(projectCollection);
 
@@ -1292,6 +1434,10 @@ internal static bool BuildProject(
                     parameters.ProjectIsolationMode = isolateProjects;
                     parameters.InputResultsCacheFiles = inputResultsCaches;
                     parameters.OutputResultsCacheFile = outputResultsCache;
+                    parameters.Question = question;
+#if FEATURE_REPORTFILEACCESSES
+                    parameters.ReportFileAccesses = reportFileAccesses;
+#endif
 
                     // Propagate the profiler flag into the project load settings so the evaluator
                     // can pick it up
@@ -1319,9 +1465,12 @@ internal static bool BuildProject(
                         }
                     }
 
+                    List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
+
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
 
-                    BuildResultCode? result = null;
+                    result = null;
+                    GraphBuildResult graphResult = null;
 
                     if (!Traits.Instance.EscapeHatches.DoNotSendDeferredMessagesToBuildManager)
                     {
@@ -1338,7 +1487,9 @@ internal static bool BuildProject(
                         {
                             messagesToLogInBuildLoggers.Add(
                                 new BuildManager.DeferredBuildMessage(
-                                    String.Format("Included response file: {0}", responseFilePath),
+                                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                                        "PickedUpSwitchesFromAutoResponse",
+                                        responseFilePath),
                                     MessageImportance.Low,
                                     responseFilePath));
                         }
@@ -1363,21 +1514,30 @@ internal static bool BuildProject(
                             BuildRequestData buildRequest = null;
                             if (!restoreOnly)
                             {
+                                // By default, the project state is thrown out after a build. The ProvideProjectStateAfterBuild flag adds the project state after build
+                                // to the BuildResult passed back at the end of the build. This can then be used to find the value of properties, items, etc. after the
+                                // build is complete.
+                                BuildRequestDataFlags flags = BuildRequestDataFlags.None;
+                                if (saveProjectResult)
+                                {
+                                    flags |= BuildRequestDataFlags.ProvideProjectStateAfterBuild;
+                                }
+
                                 if (graphBuildOptions != null)
                                 {
-                                    graphBuildRequest = new GraphBuildRequestData(new[] { new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, BuildRequestDataFlags.None, graphBuildOptions);
+                                    graphBuildRequest = new GraphBuildRequestData(new[] { new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, flags, graphBuildOptions);
                                 }
                                 else
                                 {
-                                    buildRequest = new BuildRequestData(projectFile, globalProperties, toolsVersion, targets, null);
+                                    buildRequest = new BuildRequestData(projectFile, globalProperties, toolsVersion, targets, null, flags);
                                 }
                             }
 
                             if (enableRestore || restoreOnly)
                             {
-                                (result, exception) = ExecuteRestore(projectFile, toolsVersion, buildManager, restoreProperties.Count > 0 ? restoreProperties : globalProperties);
+                                result = ExecuteRestore(projectFile, toolsVersion, buildManager, restoreProperties.Count > 0 ? restoreProperties : globalProperties);
 
-                                if (result != BuildResultCode.Success)
+                                if (result.OverallResult != BuildResultCode.Success)
                                 {
                                     return false;
                                 }
@@ -1387,17 +1547,38 @@ internal static bool BuildProject(
                             {
                                 if (graphBuildOptions != null)
                                 {
-                                    (result, exception) = ExecuteGraphBuild(buildManager, graphBuildRequest);
+                                    graphResult = ExecuteGraphBuild(buildManager, graphBuildRequest);
+
+                                    if (saveProjectResult)
+                                    {
+                                        ProjectGraphEntryPoint entryPoint = graphBuildRequest.ProjectGraphEntryPoints.Single();
+                                        if (!entryPoint.GlobalProperties.ContainsKey(PropertyNames.IsGraphBuild))
+                                        {
+                                            entryPoint.GlobalProperties[PropertyNames.IsGraphBuild] = "true";
+                                        }
+
+                                        result = graphResult.ResultsByNode.Single(
+                                            nodeResultKvp =>
+                                            nodeResultKvp.Key.ProjectInstance.FullPath.Equals(entryPoint.ProjectFile) &&
+                                            nodeResultKvp.Key.ProjectInstance.GlobalProperties.Count == entryPoint.GlobalProperties.Count &&
+                                            nodeResultKvp.Key.ProjectInstance.GlobalProperties.All(propertyKvp => entryPoint.GlobalProperties.TryGetValue(propertyKvp.Key, out string entryValue) &&
+                                                                                                                                        entryValue.Equals(propertyKvp.Value)))
+                                            .Value;
+                                    }
+                                    else
+                                    {
+                                        success = graphResult.OverallResult == BuildResultCode.Success;
+                                    }
                                 }
                                 else
                                 {
-                                    (result, exception) = ExecuteBuild(buildManager, buildRequest);
+                                    result = ExecuteBuild(buildManager, buildRequest);
                                 }
                             }
 
-                            if (result != null && exception == null)
+                            if (result != null && result.Exception == null)
                             {
-                                success = result == BuildResultCode.Success;
+                                success = result.OverallResult == BuildResultCode.Success;
                             }
                         }
                         finally
@@ -1458,8 +1639,8 @@ internal static bool BuildProject(
             }
             finally
             {
-                FileUtilities.ClearCacheDirectory();
                 projectCollection?.Dispose();
+                FileUtilities.ClearCacheDirectory();
 
                 // Build manager shall be reused for all build sessions.
                 // If, for one reason or another, this behavior needs to change in future
@@ -1498,7 +1679,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
 
         private static List<BuildManager.DeferredBuildMessage> GetMessagesToLogInBuildLoggers(string commandLineString)
         {
-            List<BuildManager.DeferredBuildMessage> messages = new()
+            List<BuildManager.DeferredBuildMessage> messages = new(s_globalMessagesToLogInBuildLoggers)
             {
                 new BuildManager.DeferredBuildMessage(
                     ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
@@ -1540,7 +1721,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
             return messages;
         }
 
-        private static (BuildResultCode result, Exception exception) ExecuteBuild(BuildManager buildManager, BuildRequestData request)
+        private static BuildResult ExecuteBuild(BuildManager buildManager, BuildRequestData request)
         {
             BuildSubmission submission;
             lock (s_buildLock)
@@ -1556,11 +1737,10 @@ private static (BuildResultCode result, Exception exception) ExecuteBuild(BuildM
                 }
             }
 
-            var result = submission.Execute();
-            return (result.OverallResult, result.Exception);
+            return submission.Execute();
         }
 
-        private static (BuildResultCode result, Exception exception) ExecuteGraphBuild(BuildManager buildManager, GraphBuildRequestData request)
+        private static GraphBuildResult ExecuteGraphBuild(BuildManager buildManager, GraphBuildRequestData request)
         {
             GraphBuildSubmission submission;
             lock (s_buildLock)
@@ -1576,11 +1756,10 @@ private static (BuildResultCode result, Exception exception) ExecuteGraphBuild(B
                 }
             }
 
-            GraphBuildResult result = submission.Execute();
-            return (result.OverallResult, result.Exception);
+            return submission.Execute();
         }
 
-        private static (BuildResultCode result, Exception exception) ExecuteRestore(string projectFile, string toolsVersion, BuildManager buildManager, Dictionary<string, string> globalProperties)
+        private static BuildResult ExecuteRestore(string projectFile, string toolsVersion, BuildManager buildManager, Dictionary<string, string> globalProperties)
         {
             // Make a copy of the global properties
             Dictionary<string, string> restoreGlobalProperties = new Dictionary<string, string>(globalProperties);
@@ -1633,14 +1812,20 @@ internal static void SetConsoleUI()
             Thread thisThread = Thread.CurrentThread;
 
             // Eliminate the complex script cultures from the language selection.
-            thisThread.CurrentUICulture = CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture();
+            var desiredCulture = EncodingUtilities.GetExternalOverriddenUILanguageIfSupportableWithEncoding() ?? CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture();
+            thisThread.CurrentUICulture = desiredCulture;
+
+            // For full framework, both the above and below must be set. This is not true in core, but it is a no op in core.
+            // https://learn.microsoft.com/dotnet/api/system.globalization.cultureinfo.defaultthreadcurrentculture#remarks
+            CultureInfo.CurrentUICulture = desiredCulture;
+            CultureInfo.DefaultThreadCurrentUICulture = desiredCulture;
 
             // Determine if the language can be displayed in the current console codepage, otherwise set to US English
             int codepage;
 
             try
             {
-                codepage = System.Console.OutputEncoding.CodePage;
+                codepage = Console.OutputEncoding.CodePage;
             }
             catch (NotSupportedException)
             {
@@ -1654,7 +1839,8 @@ internal static void SetConsoleUI()
                     &&
                     codepage != thisThread.CurrentUICulture.TextInfo.OEMCodePage
                     &&
-                    codepage != thisThread.CurrentUICulture.TextInfo.ANSICodePage)
+                    codepage != thisThread.CurrentUICulture.TextInfo.ANSICodePage
+                    && !Equals(CultureInfo.InvariantCulture, thisThread.CurrentUICulture))
             {
                 thisThread.CurrentUICulture = new CultureInfo("en-US");
                 return;
@@ -2212,7 +2398,14 @@ private static bool ProcessCommandLineSwitches(
             ref GraphBuildOptions graphBuild,
             ref string[] inputResultsCaches,
             ref string outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+            ref bool reportFileAccesses,
+#endif
             ref bool lowPriority,
+            ref bool question,
+            ref string[] getProperty,
+            ref string[] getItem,
+            ref string[] getTargetResult,
             bool recursing,
             string commandLine)
         {
@@ -2237,9 +2430,15 @@ private static bool ProcessCommandLineSwitches(
             }
 #endif
 
+            bool shouldShowLogo = !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoLogo] &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Preprocess) &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GetProperty) &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GetItem) &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GetTargetResult);
+
             // show copyright message if nologo switch is not set
             // NOTE: we heed the nologo switch even if there are switch errors
-            if (!recursing && !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoLogo] && !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Preprocess))
+            if (!recursing && shouldShowLogo)
             {
                 DisplayVersionMessage();
             }
@@ -2265,6 +2464,13 @@ private static bool ProcessCommandLineSwitches(
             // leave priority where it was.
             catch (Win32Exception) { }
 
+#if FEATURE_REPORTFILEACCESSES
+            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.ReportFileAccesses))
+            {
+                reportFileAccesses = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ReportFileAccesses], defaultValue: true, resourceName: "");
+            }
+#endif
+
             // if help switch is set (regardless of switch errors), show the help message and ignore the other switches
             if (commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Help])
             {
@@ -2327,7 +2533,14 @@ private static bool ProcessCommandLineSwitches(
                                                            ref graphBuild,
                                                            ref inputResultsCaches,
                                                            ref outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+                                                           ref reportFileAccesses,
+#endif
                                                            ref lowPriority,
+                                                           ref question,
+                                                           ref getProperty,
+                                                           ref getItem,
+                                                           ref getTargetResult,
                                                            recursing: true,
                                                            commandLine);
                     }
@@ -2335,6 +2548,17 @@ private static bool ProcessCommandLineSwitches(
                     // figure out which targets we are building
                     targets = ProcessTargetSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Target]);
 
+                    // If we are looking for the value of a specific property or item post-evaluation or a target post-build, figure that out now
+                    getProperty = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetProperty] ?? Array.Empty<string>();
+                    getItem = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetItem] ?? Array.Empty<string>();
+                    getTargetResult = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetTargetResult] ?? Array.Empty<string>();
+                    if (getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0)
+                    {
+                        commandLineSwitches.SetParameterizedSwitch(CommandLineSwitches.ParameterizedSwitch.Verbosity, "q", "q", true, true, true);
+                    }
+
+                    targets = targets.Union(getTargetResult, MSBuildNameIgnoreCaseComparer.Default).ToArray();
+
                     // figure out which ToolsVersion has been set on the command line
                     toolsVersion = ProcessToolsVersionSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ToolsVersion]);
 
@@ -2391,10 +2615,14 @@ private static bool ProcessCommandLineSwitches(
                         graphBuild = ProcessGraphBuildSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GraphBuild]);
                     }
 
+                    question = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Question);
+
                     inputResultsCaches = ProcessInputResultsCaches(commandLineSwitches);
 
                     outputResultsCache = ProcessOutputResultsCache(commandLineSwitches);
 
+                    bool useTerminalLogger = ProcessTerminalLoggerConfiguration(commandLineSwitches, out string aggregatedTerminalLoggerParameters);
+
                     // figure out which loggers are going to listen to build events
                     string[][] groupedFileLoggerParameters = commandLineSwitches.GetFileLoggerParameters();
 
@@ -2404,12 +2632,14 @@ private static bool ProcessCommandLineSwitches(
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
-                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.LiveLogger],
+                        useTerminalLogger,
+                        aggregatedTerminalLoggerParameters,
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ProfileEvaluation],
                         groupedFileLoggerParameters,
+                        getProperty.Length + getItem.Length + getTargetResult.Length > 0,
                         out distributedLoggerRecords,
                         out verbosity,
                         out originalVerbosity,
@@ -2432,16 +2662,6 @@ private static bool ProcessCommandLineSwitches(
                         detailedSummary = true;
                     }
 
-                    // If we picked up switches from the autoresponse file, let the user know. This could be a useful
-                    // hint to a user that does not know that we are picking up the file automatically.
-                    // Since this is going to happen often in normal use, only log it in high verbosity mode.
-                    // Also, only log it to the console; logging to loggers would involve increasing the public API of
-                    // the Engine, and we don't want to do that.
-                    if (usingSwitchesFromAutoResponseFile && LoggerVerbosity.Diagnostic == verbosity)
-                    {
-                        Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("PickedUpSwitchesFromAutoResponse", autoResponseFileName));
-                    }
-
                     if (originalVerbosity == LoggerVerbosity.Diagnostic)
                     {
                         string equivalentCommandLine = commandLineSwitches.GetEquivalentCommandLineExceptProjectFile();
@@ -2471,6 +2691,203 @@ private static bool ProcessCommandLineSwitches(
             return invokeBuild;
         }
 
+        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)
+        {
+            aggregatedParameters = AggregateParameters(commandLineSwitches);
+            string defaultValue = FindDefaultValue(aggregatedParameters);
+
+            string terminalLoggerArg = null;
+            if (!TryFromCommandLine(commandLineSwitches) && !TryFromEnvironmentVariables())
+            {
+                ApplyDefault();
+            }
+
+            terminalLoggerArg = NormalizeIntoBooleanValues();
+
+            bool useTerminalLogger = false;
+            if (!TrueOrFalse())
+            {
+                ItMustBeAuto();
+            }
+
+            return KnownTelemetry.LoggingConfigurationTelemetry.TerminalLogger = useTerminalLogger;
+
+            static bool CheckIfTerminalIsSupportedAndTryEnableAnsiColorCodes()
+            {
+                (var acceptAnsiColorCodes, var outputIsScreen, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+
+                if (!outputIsScreen)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedRedirected"), MessageImportance.Low));
+                    return false;
+                }
+
+                // TerminalLogger is not used if the terminal does not support ANSI/VT100 escape sequences.
+                if (!acceptAnsiColorCodes)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedNotSupported"), MessageImportance.Low));
+                    return false;
+                }
+
+                if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedDisabled"), MessageImportance.Low));
+                    return false;
+                }
+
+                return true;
+            }
+
+            string FindDefaultValue(string s)
+            {
+                // Find default configuration so it is part of telemetry even when default is not used.
+                // Default can be stored in /tlp:default=true|false|on|off|auto
+                string terminalLoggerDefault = null;
+                foreach (string parameter in s.Split(MSBuildConstants.SemicolonChar))
+                {
+                    if (string.IsNullOrWhiteSpace(parameter))
+                    {
+                        continue;
+                    }
+
+                    string[] parameterAndValue = parameter.Split(MSBuildConstants.EqualsChar);
+                    if (parameterAndValue[0].Equals("default", StringComparison.InvariantCultureIgnoreCase) && parameterAndValue.Length > 1)
+                    {
+                        terminalLoggerDefault = parameterAndValue[1];
+                    }
+                }
+
+                if (terminalLoggerDefault == null)
+                {
+                    terminalLoggerDefault = bool.FalseString;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefault = bool.FalseString;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefaultSource = "msbuild";
+                }
+                else
+                {
+                    // Lets check DOTNET CLI env var
+                    string dotnetCliEnvVar = Environment.GetEnvironmentVariable("DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER");
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefault = terminalLoggerDefault;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefaultSource = string.IsNullOrWhiteSpace(dotnetCliEnvVar) ? "sdk" : "DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER";
+                }
+
+                return terminalLoggerDefault;
+            }
+
+            bool TryFromCommandLine(CommandLineSwitches commandLineSwitches1)
+            {
+                if (!commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.TerminalLogger))
+                {
+                    return false;
+                }
+
+                // There's a switch set, but there might be more than one
+                string[] switches = commandLineSwitches1[CommandLineSwitches.ParameterizedSwitch.TerminalLogger];
+
+                terminalLoggerArg = switches[switches.Length - 1];
+
+                // if the switch was set but not to an explicit value, the value is "auto"
+                if (string.IsNullOrEmpty(terminalLoggerArg))
+                {
+                    terminalLoggerArg = "auto";
+                }
+
+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalLoggerArg ?? string.Empty;
+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = "arg";
+
+                return true;
+            }
+
+            bool TryFromEnvironmentVariables()
+            {
+                // Keep MSBUILDLIVELOGGER supporitng existing use. But MSBUILDTERMINALLOGGER takes precedence.
+                string liveLoggerArg = Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER");
+                terminalLoggerArg = Environment.GetEnvironmentVariable("MSBUILDTERMINALLOGGER");
+                if (!string.IsNullOrEmpty(terminalLoggerArg))
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage($"The environment variable MSBUILDTERMINALLOGGER was set to {terminalLoggerArg}.", MessageImportance.Low));
+
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalLoggerArg;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = "MSBUILDTERMINALLOGGER";
+                }
+                else if (!string.IsNullOrEmpty(liveLoggerArg))
+                {
+                    terminalLoggerArg = liveLoggerArg;
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage($"The environment variable MSBUILDLIVELOGGER was set to {liveLoggerArg}.", MessageImportance.Low));
+
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalLoggerArg;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = "MSBUILDLIVELOGGER";
+                }
+                else
+                {
+                    return false;
+                }
+
+                return true;
+            }
+
+            string NormalizeIntoBooleanValues()
+            {
+                // We now have a string`. It can be "true" or "false" which means just that:
+                if (terminalLoggerArg.Equals("on", StringComparison.InvariantCultureIgnoreCase))
+                {
+                    terminalLoggerArg = bool.TrueString;
+                }
+                else if (terminalLoggerArg.Equals("off", StringComparison.InvariantCultureIgnoreCase))
+                {
+                    terminalLoggerArg = bool.FalseString;
+                }
+
+                return terminalLoggerArg;
+            }
+
+            void ApplyDefault()
+            {
+                terminalLoggerArg = defaultValue;
+            }
+
+            string AggregateParameters(CommandLineSwitches switches)
+            {
+                string[] terminalLoggerParameters = switches[CommandLineSwitches.ParameterizedSwitch.TerminalLoggerParameters];
+                return terminalLoggerParameters?.Length > 0 ? MSBuildApp.AggregateParameters(string.Empty, terminalLoggerParameters) : string.Empty;
+            }
+
+            bool TrueOrFalse()
+            {
+                if (bool.TryParse(terminalLoggerArg, out bool result))
+                {
+                    useTerminalLogger = result;
+
+                    // Try Enable Ansi Color Codes when terminal logger is enabled/enforced.
+                    if (result)
+                    {
+                        // This needs to be called so Ansi Color Codes are enabled for the terminal logger.
+                        (_, _, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+                    }
+
+                    return true;
+                }
+
+                return false;
+            }
+
+            void ItMustBeAuto()
+            {
+                // or it can be "auto", meaning "enable if we can"
+                if (!terminalLoggerArg.Equals("auto", StringComparison.OrdinalIgnoreCase))
+                {
+                    CommandLineSwitchException.Throw("InvalidTerminalLoggerValue", terminalLoggerArg);
+                }
+
+                useTerminalLogger = CheckIfTerminalIsSupportedAndTryEnableAnsiColorCodes();
+            }
+        }
+
         private static CommandLineSwitches CombineSwitchesRespectingPriority(CommandLineSwitches switchesFromAutoResponseFile, CommandLineSwitches switchesNotFromAutoResponseFile, string commandLine)
         {
             // combine the auto-response file switches with the command line switches in a left-to-right manner, where the
@@ -3147,6 +3564,14 @@ internal static int GetLengthOfSwitchIndicator(string unquotedSwitch)
         /// <returns>List of target names.</returns>
         private static string[] ProcessTargetSwitch(string[] parameters)
         {
+            foreach (string parameter in parameters)
+            {
+                int indexOfSpecialCharacter = parameter.IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
+                if (indexOfSpecialCharacter >= 0)
+                {
+                    CommandLineSwitchException.Throw("NameInvalid", nameof(XMakeElements.target), parameter, parameter[indexOfSpecialCharacter].ToString());
+                }
+            }
             return parameters;
         }
 
@@ -3218,12 +3643,14 @@ private static ILogger[] ProcessLoggingSwitches(
             string[] verbositySwitchParameters,
             bool noConsoleLogger,
             bool distributedFileLogger,
-            bool liveLoggerCommandLineOptIn,
+            bool terminalloggerOptIn,
+            string aggregatedTerminalLoggerParameters,
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
             string[] profileEvaluationParameters,
             string[][] groupedFileLoggerParameters,
+            bool useSimpleErrorLogger,
             out List<DistributedLoggerRecord> distributedLoggerRecords,
             out LoggerVerbosity verbosity,
             out LoggerVerbosity originalVerbosity,
@@ -3246,17 +3673,23 @@ private static ILogger[] ProcessLoggingSwitches(
             var outVerbosity = verbosity;
             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);
 
-            ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);
+            // When returning the result of evaluation from the command line, do not use custom loggers.
+            if (!useSimpleErrorLogger)
+            {
+                ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);
+            }
 
             // Add any loggers which have been specified on the commandline
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
 
-            // Choose default console logger
-            if (
-                (liveLoggerCommandLineOptIn || Environment.GetEnvironmentVariable("MSBUILDFANCYLOGGER") == "true" || Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER") == "true")
-                && DoesEnvironmentSupportLiveLogger())
+            // Otherwise choose default console logger: None, TerminalLogger, or the older ConsoleLogger
+            if (useSimpleErrorLogger)
             {
-                ProcessLiveLogger(noConsoleLogger, distributedLoggerRecords, cpuCount, loggers);
+                loggers.Add(new SimpleErrorLogger());
+            }
+            else if (terminalloggerOptIn)
+            {
+                ProcessTerminalLogger(noConsoleLogger, aggregatedTerminalLoggerParameters, distributedLoggerRecords, cpuCount, loggers);
             }
             else
             {
@@ -3267,9 +3700,6 @@ private static ILogger[] ProcessLoggingSwitches(
 
             ProcessFileLoggers(groupedFileLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
 
-            // TOOD: Review
-            // ProcessLiveLogger(noConsoleLogger, loggers);
-
             verbosity = outVerbosity;
 
             profilerLogger = ProcessProfileEvaluationSwitch(profileEvaluationParameters, loggers, out enableProfiler);
@@ -3435,29 +3865,8 @@ internal static void ProcessConsoleLoggerSwitch(
             }
         }
 
-        private static bool DoesEnvironmentSupportLiveLogger()
-        {
-            // If output is redirected
-            if (Console.IsOutputRedirected)
-            {
-                messagesToLogInBuildLoggers.Add(
-                    new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is being redirected to a file.", MessageImportance.Low));
-                return false;
-            }
-            // If terminal is dumb
-            if (
-                (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && string.IsNullOrEmpty(Environment.GetEnvironmentVariable("WT_SESSION")))
-                || Environment.GetEnvironmentVariable("TERM") == "dumb")
-            {
-                messagesToLogInBuildLoggers.Add(
-                    new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is not supported.", MessageImportance.Low));
-                return false;
-            }
-            return true;
-        }
-
-        private static void ProcessLiveLogger(
-            bool noConsoleLogger,
+        private static void ProcessTerminalLogger(bool noConsoleLogger,
+            string aggregatedLoggerParameters,
             List<DistributedLoggerRecord> distributedLoggerRecords,
             int cpuCount,
             List<ILogger> loggers)
@@ -3465,7 +3874,10 @@ private static void ProcessLiveLogger(
             if (!noConsoleLogger)
             {
                 // A central logger will be created for both single proc and multiproc.
-                LiveLogger logger = new LiveLogger();
+                TerminalLogger logger = new TerminalLogger()
+                {
+                    Parameters = aggregatedLoggerParameters
+                };
 
                 // Check to see if there is a possibility we will be logging from an out-of-proc node.
                 // If so (we're multi-proc or the in-proc node is disabled), we register a distributed logger.
@@ -3476,7 +3888,7 @@ private static void ProcessLiveLogger(
                 else
                 {
                     // For performance, register this logger using the forwarding logger mechanism.
-                    DistributedLoggerRecord forwardingLoggerRecord = CreateForwardingLoggerRecord(logger, string.Join(";", LiveLogger.ConfigurableForwardingLoggerParameters), LoggerVerbosity.Quiet);
+                    DistributedLoggerRecord forwardingLoggerRecord = CreateForwardingLoggerRecord(logger, string.Join(";", TerminalLogger.ConfigurableForwardingLoggerParameters), LoggerVerbosity.Quiet);
                     distributedLoggerRecords.Add(forwardingLoggerRecord);
                 }
             }
@@ -4042,7 +4454,11 @@ private static void ShowHelpMessage()
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_InputCachesFiles"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_OutputCacheFile"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_36_GraphBuildSwitch"));
+#if FEATURE_REPORTFILEACCESSES
+            Console.WriteLine(AssemblyResources.GetString("HelpMessage_42_ReportFileAccessesSwitch"));
+#endif
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_39_LowPrioritySwitch"));
+            Console.WriteLine(AssemblyResources.GetString("HelpMessage_41_QuestionSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_7_ResponseFile"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_8_NoAutoResponseSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_5_NoLogoSwitch"));
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 37ad6179283..1feab29307d 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -54,6 +54,18 @@
         </dependentAssembly>
 
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Native" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Native.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Processes" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Processes.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Utilities.Core" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Utilities.Core.dll"/>
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
@@ -69,6 +81,10 @@
           <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
           <codeBase version="1.0.0.0" href="..\Microsoft.NET.StringTools.net35.dll"/>
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="RuntimeContracts" publicKeyToken="3d487639874b2199" culture="neutral" />
+          <codeBase version="0.5.0.0" href="..\RuntimeContracts.dll" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
@@ -118,8 +134,13 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-7.0.0.3" newVersion="7.0.0.3" />
+          <codeBase version="7.0.0.3" href="..\System.Text.Json.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Text.Json.dll"/>
+          <codeBase version="7.0.0.0" href="..\System.Threading.Channels.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 195274749e3..51d2a26861e 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -90,7 +90,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-7.0.0.3" newVersion="7.0.0.3" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 0628e295bd9..aa4ce2eac58 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -14,6 +14,7 @@
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
     <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
+    <UseRidGraph>true</UseRidGraph>
 
     <EnableDefaultItems>false</EnableDefaultItems>
     <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST;NO_FRAMEWORK_IVT</DefineConstants>
@@ -61,6 +62,9 @@
     <Compile Include="..\Framework\ITaskItem2.cs">
       <Link>ITaskItem2.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\IExtendedBuildEventArgs.cs">
+      <Link>IExtendedBuildEventArgs.cs</Link>
+    </Compile>
     <Compile Include="..\Framework\AssemblyUtilities.cs" />
     <Compile Include="..\Framework\ResponseFileUsedEventArgs.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
@@ -70,9 +74,12 @@
     </Compile>
     <Compile Include="..\Shared\Constants.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
-    <Compile Include="..\Shared\ErrorUtilities.cs">
+    <Compile Include="..\Framework\ErrorUtilities.cs">
       <Link>ErrorUtilities.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\ErrorUtilities.cs">
+      <Link>SharedErrorUtilities.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\EscapingUtilities.cs">
       <Link>EscapingUtilities.cs</Link>
     </Compile>
@@ -97,10 +104,10 @@
     <Compile Include="..\Shared\INodePacketHandler.cs">
       <Link>INodePacketHandler.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\ITranslatable.cs">
+    <Compile Include="..\Framework\ITranslatable.cs">
       <Link>ITranslatable.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\ITranslator.cs">
+    <Compile Include="..\Framework\ITranslator.cs">
       <Link>ITranslator.cs</Link>
     </Compile>
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
@@ -110,6 +117,15 @@
     <Compile Include="..\Shared\InterningBinaryReader.cs">
       <Link>InterningBinaryReader.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\BinaryReaderFactory.cs">
+      <Link>BinaryReaderFactory.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\BinaryReaderExtensions.cs">
+      <Link>BinaryReaderExtensions.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\BinaryWriterExtensions.cs">
+      <Link>BinaryWriterExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\LogMessagePacketBase.cs">
       <Link>LogMessagePacketBase.cs</Link>
     </Compile>
@@ -132,9 +148,21 @@
     <Compile Include="..\Shared\NodePacketFactory.cs">
       <Link>NodePacketFactory.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\BinaryTranslator.cs">
+    <Compile Include="..\Framework\BinaryTranslator.cs">
       <Link>BinaryTranslator.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\BuildException\BuildExceptionBase.cs">
+      <Link>BuildExceptionBase.cs</Link>
+    </Compile>
+    <Compile Include="..\Framework\BuildException\BuildExceptionRemoteState.cs">
+      <Link>BuildExceptionRemoteState.cs</Link>
+    </Compile>
+    <Compile Include="..\Framework\BuildException\BuildExceptionSerializationHelper.cs">
+      <Link>BuildExceptionSerializationHelper.cs</Link>
+    </Compile>
+    <Compile Include="..\Framework\BuildException\GenericBuildTransferredException.cs">
+      <Link>GenericBuildTransferredException.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\NodeShutdown.cs">
       <Link>NodeShutdown.cs</Link>
     </Compile>
@@ -167,6 +195,9 @@
     </Compile>
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="AssemblyResources.cs" />
+    <Compile Include="..\Framework\ChangeWaves.cs">
+      <Link>ChangeWaves.cs</Link>
+    </Compile>
     <Compile Include="Concurrent\ConcurrentDictionary.cs" />
     <Compile Include="Concurrent\ConcurrentQueue.cs" />
     <Compile Include="Immutable\ImmutableDictionary.cs" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 3780b51c588..06d5e138401 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -36,13 +36,18 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe vs.file.ngenArchitecture=x86 vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe.config
-  file source=$(TaskHostBinPath)MSBuildTaskHost.exe 
+  file source=$(TaskHostBinPath)MSBuildTaskHost.exe
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
+  file source=$(X86BinPath)BuildXL.Native.dll
+  file source=$(X86BinPath)BuildXL.Processes.dll
+  file source=$(X86BinPath)BuildXL.Utilities.Core.dll
+  file source=$(X86BinPath)RuntimeContracts.dll
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Threading.Channels.dll
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -313,6 +318,13 @@ folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hant
   file source=$(X64BinPath)zh-Hant\MSBuild.resources.dll
   file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll
 
+folder InstallDir:\MSBuild\Current\Bin\x86
+  file source=$(X86BinPath)x86\DetoursServices.dll
+
+folder InstallDir:\MSBuild\Current\Bin\x64
+  file source=$(X86BinPath)x64\DetoursServices.dll
+  file source=$(X86BinPath)x64\BuildXLNatives.dll
+
 folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
   file source=$(SourceDir)Package\MSBuild.VSSetup\MSBuild.clientenabledpkg
   file source=$(SourceDir)Framework\Microsoft.Build.Framework.pkgdef
diff --git a/src/Samples/PortableTask/PortableTask.csproj b/src/Samples/PortableTask/PortableTask.csproj
index 944a7d713ac..47a2ca8a65f 100644
--- a/src/Samples/PortableTask/PortableTask.csproj
+++ b/src/Samples/PortableTask/PortableTask.csproj
@@ -18,6 +18,6 @@
 
   <!-- This is only needed for a test in the MSBuild repo; it is unrelated to the PortableTask sample itself. -->
   <Target Name="CopyMSBuildUtilitiesToNewFolder" BeforeTargets="CopyFilesToOutputDirectory">
-    <Copy SourceFiles="$(PkgMicrosoft_Build_Utilities_Core)\lib\net46\Microsoft.Build.Utilities.Core.dll" DestinationFiles="$(OutDir)\OldMSBuild\Microsoft.Build.Utilities.Core.dll" />
+    <Copy SourceFiles="$(PkgMicrosoft_Build_Utilities_Core)\lib\net46\Microsoft.Build.Utilities.Core.dll" DestinationFiles="$(OutDir)\OldMSBuild\Microsoft.Build.Utilities.Core.dll" SkipUnchangedFiles="true"/>
   </Target>
 </Project>
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index cb3857ff100..994c24341bd 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -10,13 +10,25 @@ namespace Microsoft.Build.Shared
 {
     internal static class BinaryReaderExtensions
     {
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static string? ReadOptionalString(this BinaryReader reader)
         {
             return reader.ReadByte() == 0 ? null : reader.ReadString();
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
+        public static int ReadOptionalInt32(this BinaryReader reader)
+        {
+            return reader.ReadByte() == 0 ? 0 : reader.ReadInt32();
+        }
+
+#if !TASKHOST
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static int Read7BitEncodedInt(this BinaryReader reader)
         {
             // Read out an Int32 7 bits at a time.  The high bit
@@ -41,7 +53,9 @@ public static int Read7BitEncodedInt(this BinaryReader reader)
             return count;
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static DateTime ReadTimestamp(this BinaryReader reader)
         {
             long timestampTicks = reader.ReadInt64();
@@ -50,6 +64,7 @@ public static DateTime ReadTimestamp(this BinaryReader reader)
             return timestamp;
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         public static BuildEventContext? ReadOptionalBuildEventContext(this BinaryReader reader)
         {
@@ -75,11 +90,39 @@ public static BuildEventContext ReadBuildEventContext(this BinaryReader reader)
             var buildEventContext = new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, targetId, taskId);
             return buildEventContext;
         }
+#endif
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static unsafe Guid ReadGuid(this BinaryReader reader)
         {
             return new Guid(reader.ReadBytes(sizeof(Guid)));
         }
+
+        public static void ReadExtendedBuildEventData(this BinaryReader reader, IExtendedBuildEventArgs data)
+        {
+            data.ExtendedType = reader.ReadString();
+            data.ExtendedData = reader.ReadOptionalString();
+
+            bool haveMetadata = reader.ReadBoolean();
+            if (haveMetadata)
+            {
+                data.ExtendedMetadata = new();
+
+                int count = reader.Read7BitEncodedInt();
+                for (int i = 0; i < count; i++)
+                {
+                    string key = reader.ReadString();
+                    string? value = reader.ReadOptionalString();
+
+                    data.ExtendedMetadata.Add(key, value);
+                }
+            }
+            else
+            {
+                data.ExtendedMetadata = null;
+            }
+        }
     }
 }
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index 2a221d573a5..5f7a0046a6e 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
 using System.Runtime.CompilerServices;
 using Microsoft.Build.Framework;
@@ -10,7 +11,9 @@ namespace Microsoft.Build.Shared
 {
     internal static class BinaryWriterExtensions
     {
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void WriteOptionalString(this BinaryWriter writer, string? value)
         {
             if (value == null)
@@ -24,14 +27,34 @@ public static void WriteOptionalString(this BinaryWriter writer, string? value)
             }
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
+        public static void WriteOptionalInt32(this BinaryWriter writer, int? value)
+        {
+            if (value == null)
+            {
+                writer.Write((byte)0);
+            }
+            else
+            {
+                writer.Write((byte)1);
+                writer.Write(value.Value);
+            }
+        }
+
+#if !TASKHOST
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void WriteTimestamp(this BinaryWriter writer, DateTime timestamp)
         {
             writer.Write(timestamp.Ticks);
             writer.Write((Int32)timestamp.Kind);
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void Write7BitEncodedInt(this BinaryWriter writer, int value)
         {
             // Write out an int 7 bits at a time.  The high bit of the byte,
@@ -46,6 +69,7 @@ public static void Write7BitEncodedInt(this BinaryWriter writer, int value)
             writer.Write((byte)v);
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         public static void WriteOptionalBuildEventContext(this BinaryWriter writer, BuildEventContext? context)
         {
@@ -71,8 +95,11 @@ public static void WriteBuildEventContext(this BinaryWriter writer, BuildEventCo
             writer.Write(context.ProjectInstanceId);
             writer.Write(context.EvaluationId);
         }
+#endif
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void WriteGuid(this BinaryWriter writer, Guid value)
         {
             Guid val = value;
@@ -85,5 +112,22 @@ public static void WriteGuid(this BinaryWriter writer, Guid value)
                 }
             }
         }
+
+        public static void WriteExtendedBuildEventData(this BinaryWriter writer, IExtendedBuildEventArgs data)
+        {
+            writer.Write(data.ExtendedType);
+            writer.WriteOptionalString(data.ExtendedData);
+
+            writer.Write(data.ExtendedMetadata != null);
+            if (data.ExtendedMetadata != null)
+            {
+                writer.Write7BitEncodedInt(data.ExtendedMetadata.Count);
+                foreach (KeyValuePair<string, string?> kvp in data.ExtendedMetadata)
+                {
+                    writer.Write(kvp.Key);
+                    writer.WriteOptionalString(kvp.Value);
+                }
+            }
+        }
     }
 }
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 76d42a328f6..0e596c6cf56 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -188,6 +188,10 @@ internal static class ItemMetadataNames
         internal const string subType = "SubType";
         internal const string executableExtension = "ExecutableExtension";
         internal const string embedInteropTypes = "EmbedInteropTypes";
+        internal const string frameworkReferenceName = "FrameworkReferenceName";
+        internal const string assemblyName = "AssemblyName";
+        internal const string assemblyVersion = "AssemblyVersion";
+        internal const string publicKeyToken = "PublicKeyToken";
 
         /// <summary>
         /// The output path for a given item.
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 048974719bb..58a982de12e 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -22,15 +22,8 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal static class ErrorUtilities
     {
-        /// <summary>
-        /// Emergency escape hatch. If a customer hits a bug in the shipped product causing an internal exception,
-        /// and fortuitously it happens that ignoring the VerifyThrow allows execution to continue in a reasonable way,
-        /// then we can give them this undocumented environment variable as an immediate workaround.
-        /// </summary>
-        private static readonly bool s_throwExceptions = String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDONOTTHROWINTERNAL"));
         private static readonly bool s_enableMSBuildDebugTracing = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDENABLEDEBUGTRACING"));
 
-        #region DebugTracing
         public static void DebugTraceMessage(string category, string formatstring, params object[] parameters)
         {
             if (s_enableMSBuildDebugTracing)
@@ -45,16 +38,14 @@ public static void DebugTraceMessage(string category, string formatstring, param
                 }
             }
         }
-        #endregion
 
 #if !BUILDINGAPPXTASKS
-        #region VerifyThrow -- for internal errors
 
         internal static void VerifyThrowInternalError(bool condition, string message, params object[] args)
         {
-            if (s_throwExceptions && !condition)
+            if (!condition)
             {
-                throw new InternalErrorException(ResourceUtilities.FormatString(message, args));
+                ThrowInternalError(message, args);
             }
         }
 
@@ -64,10 +55,7 @@ internal static void VerifyThrowInternalError(bool condition, string message, pa
         /// </summary>
         internal static void ThrowInternalError(string message, params object[] args)
         {
-            if (s_throwExceptions)
-            {
-                throw new InternalErrorException(ResourceUtilities.FormatString(message, args));
-            }
+            throw new InternalErrorException(ResourceUtilities.FormatString(message, args));
         }
 
         /// <summary>
@@ -76,10 +64,7 @@ internal static void ThrowInternalError(string message, params object[] args)
         /// </summary>
         internal static void ThrowInternalError(string message, Exception innerException, params object[] args)
         {
-            if (s_throwExceptions)
-            {
-                throw new InternalErrorException(ResourceUtilities.FormatString(message, args), innerException);
-            }
+            throw new InternalErrorException(ResourceUtilities.FormatString(message, args), innerException);
         }
 
         /// <summary>
@@ -89,10 +74,7 @@ internal static void ThrowInternalError(string message, Exception innerException
         /// </summary>
         internal static void ThrowInternalErrorUnreachable()
         {
-            if (s_throwExceptions)
-            {
-                throw new InternalErrorException("Unreachable?");
-            }
+            throw new InternalErrorException("Unreachable?");
         }
 
         /// <summary>
@@ -102,9 +84,9 @@ internal static void ThrowInternalErrorUnreachable()
         /// </summary>
         internal static void VerifyThrowInternalErrorUnreachable(bool condition)
         {
-            if (s_throwExceptions && !condition)
+            if (!condition)
             {
-                throw new InternalErrorException("Unreachable?");
+                ThrowInternalErrorUnreachable();
             }
         }
 
@@ -119,7 +101,7 @@ internal static void ThrowIfTypeDoesNotImplementToString(object param)
             // Check it has a real implementation of ToString()
             if (String.Equals(param.GetType().ToString(), param.ToString(), StringComparison.Ordinal))
             {
-                ErrorUtilities.ThrowInternalError("This type does not implement ToString() properly {0}", param.GetType().FullName);
+                ThrowInternalError("This type does not implement ToString() properly {0}", param.GetType().FullName);
             }
 #endif
         }
@@ -187,7 +169,7 @@ public static void VerifyThrowInternalLength<T>(T[] parameterValue, string param
         /// This should be used ONLY if this would indicate a bug in MSBuild rather than
         /// anything caused by user action.
         /// </summary>
-        /// <param name="value">Parameter that should be a rooted path</param>
+        /// <param name="value">Parameter that should be a rooted path.</param>
         internal static void VerifyThrowInternalRooted(string value)
         {
             if (!Path.IsPathRooted(value))
@@ -203,16 +185,10 @@ internal static void VerifyThrowInternalRooted(string value)
         /// code somewhere. This should not be used to throw errors based on bad
         /// user input or anything that the user did wrong.
         /// </summary>
-        /// <param name="condition"></param>
-        /// <param name="unformattedMessage"></param>
-        internal static void VerifyThrow(
-            bool condition,
-            string unformattedMessage)
+        internal static void VerifyThrow(bool condition, string unformattedMessage)
         {
             if (!condition)
             {
-                // PERF NOTE: explicitly passing null for the arguments array
-                // prevents memory allocation
                 ThrowInternalError(unformattedMessage, null, null);
             }
         }
@@ -220,17 +196,8 @@ internal static void VerifyThrow(
         /// <summary>
         /// Overload for one string format argument.
         /// </summary>
-        /// <param name="condition"></param>
-        /// <param name="unformattedMessage"></param>
-        /// <param name="arg0"></param>
-        internal static void VerifyThrow(
-            bool condition,
-            string unformattedMessage,
-            object arg0)
+        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowInternalError() method, because that method always
-            // allocates memory for its variable array of arguments
             if (!condition)
             {
                 ThrowInternalError(unformattedMessage, arg0);
@@ -240,19 +207,8 @@ internal static void VerifyThrow(
         /// <summary>
         /// Overload for two string format arguments.
         /// </summary>
-        /// <param name="condition"></param>
-        /// <param name="unformattedMessage"></param>
-        /// <param name="arg0"></param>
-        /// <param name="arg1"></param>
-        internal static void VerifyThrow(
-            bool condition,
-            string unformattedMessage,
-            object arg0,
-            object arg1)
+        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowInternalError() method, because that method always
-            // allocates memory for its variable array of arguments
             if (!condition)
             {
                 ThrowInternalError(unformattedMessage, arg0, arg1);
@@ -262,21 +218,8 @@ internal static void VerifyThrow(
         /// <summary>
         /// Overload for three string format arguments.
         /// </summary>
-        /// <param name="condition"></param>
-        /// <param name="unformattedMessage"></param>
-        /// <param name="arg0"></param>
-        /// <param name="arg1"></param>
-        /// <param name="arg2"></param>
-        internal static void VerifyThrow(
-            bool condition,
-            string unformattedMessage,
-            object arg0,
-            object arg1,
-            object arg2)
+        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowInternalError() method, because that method always
-            // allocates memory for its variable array of arguments
             if (!condition)
             {
                 ThrowInternalError(unformattedMessage, arg0, arg1, arg2);
@@ -286,33 +229,14 @@ internal static void VerifyThrow(
         /// <summary>
         /// Overload for four string format arguments.
         /// </summary>
-        /// <param name="condition"></param>
-        /// <param name="unformattedMessage"></param>
-        /// <param name="arg0"></param>
-        /// <param name="arg1"></param>
-        /// <param name="arg2"></param>
-        /// <param name="arg3"></param>
-        internal static void VerifyThrow(
-            bool condition,
-            string unformattedMessage,
-            object arg0,
-            object arg1,
-            object arg2,
-            object arg3)
+        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowInternalError() method, because that method always
-            // allocates memory for its variable array of arguments
             if (!condition)
             {
                 ThrowInternalError(unformattedMessage, arg0, arg1, arg2, arg3);
             }
         }
 
-        #endregion
-
-        #region VerifyThrowInvalidOperation
-
         /// <summary>
         /// Throws an InvalidOperationException with the specified resource string
         /// </summary>
@@ -320,28 +244,17 @@ internal static void VerifyThrow(
         /// <param name="args">Formatting args.</param>
         internal static void ThrowInvalidOperation(string resourceName, params object[] args)
         {
-#if DEBUG
-            ResourceUtilities.VerifyResourceStringExists(resourceName);
-#endif
-            if (s_throwExceptions)
-            {
-                throw new InvalidOperationException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, args));
-            }
+            throw new InvalidOperationException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, args));
         }
 
         /// <summary>
         /// Throws an InvalidOperationException if the given condition is false.
         /// </summary>
-        /// <param name="condition"></param>
-        /// <param name="resourceName"></param>
-        internal static void VerifyThrowInvalidOperation(
-            bool condition,
-            string resourceName)
+        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName)
         {
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
             if (!condition)
             {
-                // PERF NOTE: explicitly passing null for the arguments array
-                // prevents memory allocation
                 ThrowInvalidOperation(resourceName, null);
             }
         }
@@ -349,14 +262,9 @@ internal static void VerifyThrowInvalidOperation(
         /// <summary>
         /// Overload for one string format argument.
         /// </summary>
-        /// <param name="condition"></param>
-        /// <param name="resourceName"></param>
-        /// <param name="arg0"></param>
-        internal static void VerifyThrowInvalidOperation(
-            bool condition,
-            string resourceName,
-            object arg0)
+        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0)
         {
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
             // PERF NOTE: check the condition here instead of pushing it into
             // the ThrowInvalidOperation() method, because that method always
             // allocates memory for its variable array of arguments
@@ -369,16 +277,9 @@ internal static void VerifyThrowInvalidOperation(
         /// <summary>
         /// Overload for two string format arguments.
         /// </summary>
-        /// <param name="condition"></param>
-        /// <param name="resourceName"></param>
-        /// <param name="arg0"></param>
-        /// <param name="arg1"></param>
-        internal static void VerifyThrowInvalidOperation(
-            bool condition,
-            string resourceName,
-            object arg0,
-            object arg1)
+        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1)
         {
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
             // PERF NOTE: check the condition here instead of pushing it into
             // the ThrowInvalidOperation() method, because that method always
             // allocates memory for its variable array of arguments
@@ -391,18 +292,9 @@ internal static void VerifyThrowInvalidOperation(
         /// <summary>
         /// Overload for three string format arguments.
         /// </summary>
-        /// <param name="condition"></param>
-        /// <param name="resourceName"></param>
-        /// <param name="arg0"></param>
-        /// <param name="arg1"></param>
-        /// <param name="arg2"></param>
-        internal static void VerifyThrowInvalidOperation(
-            bool condition,
-            string resourceName,
-            object arg0,
-            object arg1,
-            object arg2)
+        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2)
         {
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
             // PERF NOTE: check the condition here instead of pushing it into
             // the ThrowInvalidOperation() method, because that method always
             // allocates memory for its variable array of arguments
@@ -415,20 +307,10 @@ internal static void VerifyThrowInvalidOperation(
         /// <summary>
         /// Overload for four string format arguments.
         /// </summary>
-        /// <param name="condition"></param>
-        /// <param name="resourceName"></param>
-        /// <param name="arg0"></param>
-        /// <param name="arg1"></param>
-        /// <param name="arg2"></param>
-        /// <param name="arg3"></param>
-        internal static void VerifyThrowInvalidOperation(
-            bool condition,
-            string resourceName,
-            object arg0,
-            object arg1,
-            object arg2,
-            object arg3)
+        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3)
         {
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
+
             // PERF NOTE: check the condition here instead of pushing it into
             // the ThrowInvalidOperation() method, because that method always
             // allocates memory for its variable array of arguments
@@ -438,10 +320,6 @@ internal static void VerifyThrowInvalidOperation(
             }
         }
 
-        #endregion
-
-        #region VerifyThrowArgument
-
         /// <summary>
         /// Throws an ArgumentException that can include an inner exception.
         ///
@@ -449,9 +327,7 @@ internal static void VerifyThrowInvalidOperation(
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
         /// </summary>
-        internal static void ThrowArgument(
-            string resourceName,
-            params object[] args)
+        internal static void ThrowArgument(string resourceName, params object[] args)
         {
             ThrowArgument(null, resourceName, args);
         }
@@ -469,29 +345,15 @@ internal static void ThrowArgument(
         /// <param name="innerException">Can be null.</param>
         /// <param name="resourceName"></param>
         /// <param name="args"></param>
-        internal static void ThrowArgument(
-            Exception innerException,
-            string resourceName,
-            params object[] args)
+        internal static void ThrowArgument(Exception innerException, string resourceName, params object[] args)
         {
-#if DEBUG
-            ResourceUtilities.VerifyResourceStringExists(resourceName);
-#endif
-            if (s_throwExceptions)
-            {
-                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, args), innerException);
-            }
+            throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, args), innerException);
         }
 
         /// <summary>
         /// Throws an ArgumentException if the given condition is false.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
-        /// <param name="condition"></param>
-        /// <param name="resourceName"></param>
-        internal static void VerifyThrowArgument(
-            bool condition,
-            string resourceName)
+        internal static void VerifyThrowArgument(bool condition, string resourceName)
         {
             VerifyThrowArgument(condition, null, resourceName);
         }
@@ -499,14 +361,7 @@ internal static void VerifyThrowArgument(
         /// <summary>
         /// Overload for one string format argument.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
-        /// <param name="condition"></param>
-        /// <param name="resourceName"></param>
-        /// <param name="arg0"></param>
-        internal static void VerifyThrowArgument(
-            bool condition,
-            string resourceName,
-            object arg0)
+        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0)
         {
             VerifyThrowArgument(condition, null, resourceName, arg0);
         }
@@ -514,16 +369,7 @@ internal static void VerifyThrowArgument(
         /// <summary>
         /// Overload for two string format arguments.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
-        /// <param name="condition"></param>
-        /// <param name="resourceName"></param>
-        /// <param name="arg0"></param>
-        /// <param name="arg1"></param>
-        internal static void VerifyThrowArgument(
-            bool condition,
-            string resourceName,
-            object arg0,
-            object arg1)
+        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1)
         {
             VerifyThrowArgument(condition, null, resourceName, arg0, arg1);
         }
@@ -531,13 +377,7 @@ internal static void VerifyThrowArgument(
         /// <summary>
         /// Overload for three string format arguments.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
-        internal static void VerifyThrowArgument(
-            bool condition,
-            string resourceName,
-            object arg0,
-            object arg1,
-            object arg2)
+        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2)
         {
             VerifyThrowArgument(condition, null, resourceName, arg0, arg1, arg2);
         }
@@ -545,14 +385,7 @@ internal static void VerifyThrowArgument(
         /// <summary>
         /// Overload for four string format arguments.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
-        internal static void VerifyThrowArgument(
-            bool condition,
-            string resourceName,
-            object arg0,
-            object arg1,
-            object arg2,
-            object arg3)
+        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3)
         {
             VerifyThrowArgument(condition, null, resourceName, arg0, arg1, arg2, arg3);
         }
@@ -561,19 +394,14 @@ internal static void VerifyThrowArgument(
         /// Throws an ArgumentException that includes an inner exception, if
         /// the given condition is false.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
         /// <param name="condition"></param>
         /// <param name="innerException">Can be null.</param>
         /// <param name="resourceName"></param>
-        internal static void VerifyThrowArgument(
-            bool condition,
-            Exception innerException,
-            string resourceName)
+        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName)
         {
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
             if (!condition)
             {
-                // PERF NOTE: explicitly passing null for the arguments array
-                // prevents memory allocation
                 ThrowArgument(innerException, resourceName, null);
             }
         }
@@ -581,20 +409,10 @@ internal static void VerifyThrowArgument(
         /// <summary>
         /// Overload for one string format argument.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
-        /// <param name="condition"></param>
-        /// <param name="innerException"></param>
-        /// <param name="resourceName"></param>
-        /// <param name="arg0"></param>
-        internal static void VerifyThrowArgument(
-            bool condition,
-            Exception innerException,
-            string resourceName,
-            object arg0)
+        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowArgument() method, because that method always allocates
-            // memory for its variable array of arguments
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
+
             if (!condition)
             {
                 ThrowArgument(innerException, resourceName, arg0);
@@ -604,22 +422,10 @@ internal static void VerifyThrowArgument(
         /// <summary>
         /// Overload for two string format arguments.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
-        /// <param name="condition"></param>
-        /// <param name="innerException"></param>
-        /// <param name="resourceName"></param>
-        /// <param name="arg0"></param>
-        /// <param name="arg1"></param>
-        internal static void VerifyThrowArgument(
-            bool condition,
-            Exception innerException,
-            string resourceName,
-            object arg0,
-            object arg1)
+        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowArgument() method, because that method always allocates
-            // memory for its variable array of arguments
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
+
             if (!condition)
             {
                 ThrowArgument(innerException, resourceName, arg0, arg1);
@@ -629,18 +435,10 @@ internal static void VerifyThrowArgument(
         /// <summary>
         /// Overload for three string format arguments.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
-        internal static void VerifyThrowArgument(
-            bool condition,
-            Exception innerException,
-            string resourceName,
-            object arg0,
-            object arg1,
-            object arg2)
+        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowArgument() method, because that method always allocates
-            // memory for its variable array of arguments
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
+
             if (!condition)
             {
                 ThrowArgument(innerException, resourceName, arg0, arg1, arg2);
@@ -650,38 +448,22 @@ internal static void VerifyThrowArgument(
         /// <summary>
         /// Overload for four string format arguments.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
-        internal static void VerifyThrowArgument(
-            bool condition,
-            Exception innerException,
-            string resourceName,
-            object arg0,
-            object arg1,
-            object arg2,
-            object arg3)
+        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowArgument() method, because that method always allocates
-            // memory for its variable array of arguments
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
+
             if (!condition)
             {
                 ThrowArgument(innerException, resourceName, arg0, arg1, arg2, arg3);
             }
         }
 
-        #endregion
-
-        #region VerifyThrowArgumentXXX
-
         /// <summary>
         /// Throws an argument out of range exception.
         /// </summary>
         internal static void ThrowArgumentOutOfRange(string parameterName)
         {
-            if (s_throwExceptions)
-            {
-                throw new ArgumentOutOfRangeException(parameterName);
-            }
+            throw new ArgumentOutOfRangeException(parameterName);
         }
 
         /// <summary>
@@ -700,15 +482,13 @@ internal static void VerifyThrowArgumentOutOfRange(bool condition, string parame
         /// Throws an ArgumentNullException if the given string parameter is null
         /// and ArgumentException if it has zero length.
         /// </summary>
-        /// <param name="parameter"></param>
-        /// <param name="parameterName"></param>
         internal static void VerifyThrowArgumentLength(string parameter, string parameterName)
         {
             VerifyThrowArgumentNull(parameter, parameterName);
 
-            if (parameter.Length == 0 && s_throwExceptions)
+            if (parameter.Length == 0)
             {
-                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
+                ThrowArgumentLength(parameterName);
             }
         }
 
@@ -717,45 +497,43 @@ internal static void VerifyThrowArgumentLength(string parameter, string paramete
         /// Throws an ArgumentNullException if the given collection is null
         /// and ArgumentException if it has zero length.
         /// </summary>
-        /// <param name="parameter"></param>
-        /// <param name="parameterName"></param>
         internal static void VerifyThrowArgumentLength<T>(IReadOnlyCollection<T> parameter, string parameterName)
         {
             VerifyThrowArgumentNull(parameter, parameterName);
 
-            if (parameter.Count == 0 && s_throwExceptions)
+            if (parameter.Count == 0)
             {
-                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
+                ThrowArgumentLength(parameterName);
             }
         }
 
         /// <summary>
         /// Throws an ArgumentException if the given collection is not null but of zero length.
         /// </summary>
-        /// <param name="parameter"></param>
-        /// <param name="parameterName"></param>
         internal static void VerifyThrowArgumentLengthIfNotNull<T>(IReadOnlyCollection<T> parameter, string parameterName)
         {
-            if (parameter?.Count == 0 && s_throwExceptions)
+            if (parameter?.Count == 0)
             {
-                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
+                ThrowArgumentLength(parameterName);
             }
         }
 #endif
+        private static void ThrowArgumentLength(string parameterName)
+        {
+            throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
+        }
 
         /// <summary>
         /// Throws an ArgumentNullException if the given string parameter is null
         /// and ArgumentException if it has zero length.
         /// </summary>
-        /// <param name="parameter"></param>
-        /// <param name="parameterName"></param>
         internal static void VerifyThrowArgumentInvalidPath(string parameter, string parameterName)
         {
             VerifyThrowArgumentNull(parameter, parameterName);
 
-            if (FileUtilities.PathIsInvalid(parameter) && s_throwExceptions)
+            if (FileUtilities.PathIsInvalid(parameter))
             {
-                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveInvalidPathChars", parameterName, parameter));
+                ThrowArgument("Shared.ParameterCannotHaveInvalidPathChars", parameterName, parameter);
             }
         }
 
@@ -765,18 +543,15 @@ internal static void VerifyThrowArgumentInvalidPath(string parameter, string par
         /// </summary>
         internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName)
         {
-            if (parameter?.Length == 0 && s_throwExceptions)
+            if (parameter?.Length == 0)
             {
-                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
+                ThrowArgumentLength(parameterName);
             }
         }
 
         /// <summary>
         /// Throws an ArgumentNullException if the given parameter is null.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
-        /// <param name="parameter"></param>
-        /// <param name="parameterName"></param>
         internal static void VerifyThrowArgumentNull(object parameter, string parameterName)
         {
             VerifyThrowArgumentNull(parameter, parameterName, "Shared.ParameterCannotBeNull");
@@ -785,52 +560,47 @@ internal static void VerifyThrowArgumentNull(object parameter, string parameterN
         /// <summary>
         /// Throws an ArgumentNullException if the given parameter is null.
         /// </summary>
-        /// <remarks>This method is thread-safe.</remarks>
         internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName)
         {
-            if (parameter == null && s_throwExceptions)
+            ResourceUtilities.VerifyResourceStringExists(resourceName);
+            if (parameter == null)
             {
-                // Most ArgumentNullException overloads append its own rather clunky multi-line message.
-                // So use the one overload that doesn't.
-                throw new ArgumentNullException(
-                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, parameterName),
-                    (Exception)null);
+                ThrowArgumentNull(parameterName, resourceName);
             }
         }
 
+        internal static void ThrowArgumentNull(string parameterName, string resourceName)
+        {
+            // Most ArgumentNullException overloads append its own rather clunky multi-line message. So use the one overload that doesn't.
+            throw new ArgumentNullException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, parameterName), (Exception)null);
+        }
+
         /// <summary>
         /// Verifies the given arrays are not null and have the same length
         /// </summary>
-        /// <param name="parameter1"></param>
-        /// <param name="parameter2"></param>
-        /// <param name="parameter1Name"></param>
-        /// <param name="parameter2Name"></param>
         internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name)
         {
             VerifyThrowArgumentNull(parameter1, parameter1Name);
             VerifyThrowArgumentNull(parameter2, parameter2Name);
 
-            if (parameter1.Length != parameter2.Length && s_throwExceptions)
+            if (parameter1.Length != parameter2.Length)
             {
-                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParametersMustHaveTheSameLength", parameter1Name, parameter2Name));
+                ThrowArgument("Shared.ParametersMustHaveTheSameLength", parameter1Name, parameter2Name);
             }
         }
 
-        #endregion
-
-        #region VerifyThrowObjectDisposed
-
         internal static void VerifyThrowObjectDisposed(bool condition, string objectName)
         {
+            if (!condition)
             {
-                if (s_throwExceptions && !condition)
-                {
-                    throw new ObjectDisposedException(objectName);
-                }
+                ThrowObjectDisposed(objectName);
             }
         }
 
-        #endregion
+        internal static void ThrowObjectDisposed(string objectName)
+        {
+            throw new ObjectDisposedException(objectName);
+        }
 #endif
     }
 }
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index a7ef74e8737..eca284ecb64 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -167,7 +167,9 @@ internal static bool IsIoRelatedException(Exception e)
         internal static bool IsXmlException(Exception e)
         {
             return e is XmlException
-                || e is XmlSyntaxException
+#if FEATURE_SECURITY_PERMISSIONS
+                || e is System.Security.XmlSyntaxException
+#endif
                 || e is XmlSchemaException
                 || e is UriFormatException; // XmlTextReader for example uses this under the covers
         }
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 36613d4cd52..e50a6b860d3 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -92,7 +92,7 @@ public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary<string, IReadOnl
                 path,
                 pattern,
                 projectDirectory,
-                stripProjectDirectory).ToArray(),
+                stripProjectDirectory),
             fileEntryExpansionCache)
         {
         }
@@ -135,8 +135,8 @@ internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemE
                         ? allEntriesForPath.Where(o => IsFileNameMatch(o, pattern))
                         : allEntriesForPath;
                     return stripProjectDirectory
-                        ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
-                        : filteredEntriesForPath.ToArray();
+                        ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToList()
+                        : filteredEntriesForPath.ToList();
                 };
         }
 
@@ -252,7 +252,7 @@ private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSyste
                         ? fileSystem.EnumerateFileSystemEntries(path, pattern)
                             .Where(o => IsFileNameMatch(o, pattern))
                         : fileSystem.EnumerateFileSystemEntries(path, pattern))
-                        .ToArray();
+                        .ToList();
                 }
                 // for OS security
                 catch (UnauthorizedAccessException)
@@ -349,7 +349,7 @@ private static IReadOnlyList<string> GetAccessibleFiles(
                     files = RemoveInitialDotSlash(files);
                 }
 
-                return files.ToArray();
+                return files.ToList();
             }
             catch (System.Security.SecurityException)
             {
@@ -405,7 +405,7 @@ private static IReadOnlyList<string> GetAccessibleDirectories(
                     directories = RemoveInitialDotSlash(directories);
                 }
 
-                return directories.ToArray();
+                return directories.ToList();
             }
             catch (System.Security.SecurityException)
             {
@@ -501,7 +501,7 @@ internal static string GetLongPathName(
                     }
                     else
                     {
-                        // getFileSystemEntries(...) returns an empty enumerable if longPath doesn't exist.
+                        // getFileSystemEntries(...) returns an empty list if longPath doesn't exist.
                         IReadOnlyList<string> entries = getFileSystemEntries(FileSystemEntity.FilesAndDirectories, longPath, parts[i], null, false);
 
                         if (0 == entries.Count)
@@ -796,7 +796,7 @@ private struct RecursionState
             /// <summary>
             /// True if a SearchData.DirectoryPattern is specified but we have not descended into a matching directory.
             /// </summary>
-            public bool IsLookingForMatchingDirectory => (SearchData.DirectoryPattern != null && !IsInsideMatchingDirectory);
+            public readonly bool IsLookingForMatchingDirectory => (SearchData.DirectoryPattern != null && !IsInsideMatchingDirectory);
         }
 
         /// <summary>
diff --git a/src/Shared/FileSystem/WindowsNative.cs b/src/Shared/FileSystem/WindowsNative.cs
index 63640a185be..8df4a0b2a2c 100644
--- a/src/Shared/FileSystem/WindowsNative.cs
+++ b/src/Shared/FileSystem/WindowsNative.cs
@@ -141,7 +141,7 @@ public EnumerateDirectoryResult(string directory, EnumerateDirectoryStatus statu
             /// <summary>
             /// Indicates if enumeration succeeded.
             /// </summary>
-            public bool Succeeded
+            public readonly bool Succeeded
             {
                 get { return Status == EnumerateDirectoryStatus.Success; }
             }
@@ -153,7 +153,7 @@ public bool Succeeded
             /// <remarks>
             /// This is a good <c>default:</c> case when switching on every possible <see cref="EnumerateDirectoryStatus"/>
             /// </remarks>
-            public NativeWin32Exception ThrowForUnknownError()
+            public readonly NativeWin32Exception ThrowForUnknownError()
             {
                 Debug.Assert(Status == EnumerateDirectoryStatus.UnknownError);
                 throw CreateExceptionForError();
@@ -173,7 +173,7 @@ public NativeWin32Exception ThrowForKnownError()
             /// <summary>
             /// Creates (but does not throw) an exception for this result. The result must not be successful.
             /// </summary>
-            public NativeWin32Exception CreateExceptionForError()
+            public readonly NativeWin32Exception CreateExceptionForError()
             {
                 Debug.Assert(Status != EnumerateDirectoryStatus.Success);
                 if (Status == EnumerateDirectoryStatus.UnknownError)
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index cb89889c3ac..52d335944af 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -190,6 +190,16 @@ internal enum NodePacketType : byte
         /// </summary>
         ResourceResponse,
 
+        /// <summary>
+        /// Message sent from a node reporting a file access.
+        /// </summary>
+        FileAccessReport,
+
+        /// <summary>
+        /// Message sent from a node reporting process data.
+        /// </summary>
+        ProcessReport,
+
         /// <summary>
         /// Command in form of MSBuild command line for server node - MSBuild Server.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 1fc332a0639..8513d60cee5 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -191,11 +191,19 @@ public override String ReadString()
         /// <remarks>
         /// The caller is responsible for managing the lifetime of the returned buffer and for passing it to <see cref="Create"/>.
         /// </remarks>
-        internal static SharedReadBuffer CreateSharedBuffer()
+        internal static BinaryReaderFactory CreateSharedBuffer()
         {
             return new Buffer();
         }
 
+        /// <summary>
+        /// A placeholder instructing InterningBinaryReader to use pooled buffer (to avoid extra allocations).
+        /// </summary>
+        /// <remarks>
+        /// Lifetime of the pooled buffer is managed by InterningBinaryReader (tied to BinaryReader lifetime wrapping the buffer)
+        /// </remarks> 
+        internal static BinaryReaderFactory PoolingBuffer => NullBuffer.Instance;
+
         /// <summary>
         /// Gets a buffer from the pool or creates a new one.
         /// </summary>
@@ -232,7 +240,7 @@ protected override void Dispose(bool disposing)
         /// Create a BinaryReader. It will either be an interning reader or standard binary reader
         /// depending on whether the interning reader is possible given the buffer and stream.
         /// </summary>
-        internal static BinaryReader Create(Stream stream, SharedReadBuffer sharedBuffer)
+        private static BinaryReader Create(Stream stream, BinaryReaderFactory sharedBuffer)
         {
             Buffer buffer = (Buffer)sharedBuffer;
             if (buffer != null)
@@ -245,7 +253,7 @@ internal static BinaryReader Create(Stream stream, SharedReadBuffer sharedBuffer
         /// <summary>
         /// Holds thepreallocated buffer. 
         /// </summary>
-        private class Buffer : SharedReadBuffer
+        private class Buffer : BinaryReaderFactory
         {
             private char[] _charBuffer;
             private byte[] _byteBuffer;
@@ -280,13 +288,24 @@ internal byte[] ByteBuffer
                     return _byteBuffer;
                 }
             }
+
+            public override BinaryReader Create(Stream stream)
+            {
+                return InterningBinaryReader.Create(stream, this);
+            }
         }
-    }
 
-    /// <summary>
-    /// Opaque holder of shared buffer.
-    /// </summary>
-    internal abstract class SharedReadBuffer
-    {
+        private class NullBuffer : BinaryReaderFactory
+        {
+            private NullBuffer()
+            { }
+
+            public static readonly BinaryReaderFactory Instance = new NullBuffer();
+
+            public override BinaryReader Create(Stream stream)
+            {
+                return InterningBinaryReader.Create(stream, null);
+            }
+        }
     }
 }
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index b885d081a74..4cfbf546ce0 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -145,6 +145,61 @@ internal enum LoggingEventType : int
         /// Event is an AssemblyLoadBuildEventArgs
         /// </summary>
         AssemblyLoadEvent = 21,
+
+        /// <summary>
+        /// Event is <see cref="ExternalProjectStartedEventArgs"/>
+        /// </summary>
+        ExternalProjectStartedEvent = 22,
+
+        /// <summary>
+        /// Event is <see cref="ExternalProjectFinishedEventArgs"/>
+        /// </summary>
+        ExternalProjectFinishedEvent = 23,
+
+        /// <summary>
+        /// Event is <see cref="ExtendedCustomBuildEventArgs"/>
+        /// </summary>
+        ExtendedCustomEvent = 24,
+
+        /// <summary>
+        /// Event is <see cref="ExtendedBuildErrorEventArgs"/>
+        /// </summary>
+        ExtendedBuildErrorEvent = 25,
+
+        /// <summary>
+        /// Event is <see cref="ExtendedBuildWarningEventArgs"/>
+        /// </summary>
+        ExtendedBuildWarningEvent = 26,
+
+        /// <summary>
+        /// Event is <see cref="ExtendedBuildMessageEventArgs"/>
+        /// </summary>
+        ExtendedBuildMessageEvent = 27,
+
+        /// <summary>
+        /// Event is <see cref="CriticalBuildMessageEventArgs"/>
+        /// </summary>
+        CriticalBuildMessage = 28,
+
+        /// <summary>
+        /// Event is <see cref="MetaprojectGeneratedEventArgs"/>
+        /// </summary>
+        MetaprojectGenerated = 29,
+
+        /// <summary>
+        /// Event is <see cref="PropertyInitialValueSetEventArgs"/>
+        /// </summary>
+        PropertyInitialValueSet = 30,
+
+        /// <summary>
+        /// Event is <see cref="PropertyReassignmentEventArgs"/>
+        /// </summary>
+        PropertyReassignment = 31,
+
+        /// <summary>
+        /// Event is <see cref="UninitializedPropertyReadEventArgs"/>
+        /// </summary>
+        UninitializedPropertyRead = 32
     }
     #endregion
 
@@ -230,8 +285,9 @@ internal LogMessagePacketBase(KeyValuePair<int, BuildEventArgs>? nodeBuildEvent,
         /// <summary>
         /// Constructor for deserialization
         /// </summary>
-        protected LogMessagePacketBase(ITranslator translator)
+        protected LogMessagePacketBase(ITranslator translator, TargetFinishedTranslator targetFinishedTranslator = null)
         {
+            _targetFinishedTranslator = targetFinishedTranslator;
             Translate(translator);
         }
 
@@ -339,7 +395,8 @@ internal void WriteToStream(ITranslator translator)
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs
                     or ProjectEvaluationFinishedEventArgs
-                    or EnvironmentVariableReadEventArgs)
+                    or EnvironmentVariableReadEventArgs
+                    or ResponseFileUsedEventArgs)
                 {
                     // switch to serialization methods that we provide in this file
                     // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
@@ -536,6 +593,17 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.ProjectImportedEvent => new ProjectImportedEventArgs(),
                 LoggingEventType.TargetSkipped => new TargetSkippedEventArgs(),
                 LoggingEventType.Telemetry => new TelemetryEventArgs(),
+                LoggingEventType.ExtendedCustomEvent => new ExtendedCustomBuildEventArgs(),
+                LoggingEventType.ExtendedBuildErrorEvent => new ExtendedBuildErrorEventArgs(),
+                LoggingEventType.ExtendedBuildWarningEvent => new ExtendedBuildWarningEventArgs(),
+                LoggingEventType.ExtendedBuildMessageEvent => new ExtendedBuildMessageEventArgs(),
+                LoggingEventType.ExternalProjectStartedEvent => new ExternalProjectStartedEventArgs(null, null, null, null, null),
+                LoggingEventType.ExternalProjectFinishedEvent => new ExternalProjectFinishedEventArgs(null, null, null, null, false),
+                LoggingEventType.CriticalBuildMessage => new CriticalBuildMessageEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),
+                LoggingEventType.MetaprojectGenerated => new MetaprojectGeneratedEventArgs(null, null, null),
+                LoggingEventType.PropertyInitialValueSet => new PropertyInitialValueSetEventArgs(),
+                LoggingEventType.PropertyReassignment => new PropertyReassignmentEventArgs(),
+                LoggingEventType.UninitializedPropertyRead => new UninitializedPropertyReadEventArgs(),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -573,6 +641,15 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.ProjectStartedEvent;
             }
+            else if (eventType == typeof(ExternalProjectStartedEventArgs))
+            {
+                return LoggingEventType.ExternalProjectStartedEvent;
+            }
+            else if (eventType == typeof(ExternalProjectFinishedEventArgs))
+            {
+                return LoggingEventType.ExternalProjectFinishedEvent;
+            }
+
 #if !TASKHOST
             else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))
             {
@@ -598,6 +675,42 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.AssemblyLoadEvent;
             }
+            else if (eventType == typeof(ExtendedCustomBuildEventArgs))
+            {
+                return LoggingEventType.ExtendedCustomEvent;
+            }
+            else if (eventType == typeof(ExtendedBuildErrorEventArgs))
+            {
+                return LoggingEventType.ExtendedBuildErrorEvent;
+            }
+            else if (eventType == typeof(ExtendedBuildWarningEventArgs))
+            {
+                return LoggingEventType.ExtendedBuildWarningEvent;
+            }
+            else if (eventType == typeof(ExtendedBuildMessageEventArgs))
+            {
+                return LoggingEventType.ExtendedBuildMessageEvent;
+            }
+            else if (eventType == typeof(CriticalBuildMessageEventArgs))
+            {
+                return LoggingEventType.CriticalBuildMessage;
+            }
+            else if (eventType == typeof(MetaprojectGeneratedEventArgs))
+            {
+                return LoggingEventType.MetaprojectGenerated;
+            }
+            else if (eventType == typeof(PropertyInitialValueSetEventArgs))
+            {
+                return LoggingEventType.PropertyInitialValueSet;
+            }
+            else if (eventType == typeof(PropertyReassignmentEventArgs))
+            {
+                return LoggingEventType.PropertyReassignment;
+            }
+            else if (eventType == typeof(UninitializedPropertyReadEventArgs))
+            {
+                return LoggingEventType.UninitializedPropertyRead;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
@@ -690,12 +803,6 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.BuildWarningEvent:
                     WriteBuildWarningEventToStream((BuildWarningEventArgs)buildEvent, translator);
                     break;
-                case LoggingEventType.ProjectStartedEvent:
-                    WriteExternalProjectStartedEventToStream((ExternalProjectStartedEventArgs)buildEvent, translator);
-                    break;
-                case LoggingEventType.ProjectFinishedEvent:
-                    WriteExternalProjectFinishedEventToStream((ExternalProjectFinishedEventArgs)buildEvent, translator);
-                    break;
                 case LoggingEventType.EnvironmentVariableReadEvent:
                     WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);
                     break;
@@ -712,37 +819,20 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
         private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)
         {
             string name = environmentVariableReadEventArgs.EnvironmentVariableName;
+            MessageImportance importance = environmentVariableReadEventArgs.Importance;
+
             translator.Translate(ref name);
-            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
+            translator.TranslateEnum(ref importance, (int)importance);
+
 #if !CLR2COMPATIBILITY
+            DateTime timestamp = environmentVariableReadEventArgs.RawTimestamp;
+            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
+
+            translator.Translate(ref timestamp);
             translator.Translate(ref context);
 #endif
         }
 
-        /// <summary>
-        /// Serialize ExternalProjectFinished Event Argument to the stream
-        /// </summary>
-        private void WriteExternalProjectFinishedEventToStream(ExternalProjectFinishedEventArgs externalProjectFinishedEventArgs, ITranslator translator)
-        {
-            string projectFile = externalProjectFinishedEventArgs.ProjectFile;
-            translator.Translate(ref projectFile);
-
-            bool succeeded = externalProjectFinishedEventArgs.Succeeded;
-            translator.Translate(ref succeeded);
-        }
-
-        /// <summary>
-        /// ExternalProjectStartedEvent
-        /// </summary>
-        private void WriteExternalProjectStartedEventToStream(ExternalProjectStartedEventArgs externalProjectStartedEventArgs, ITranslator translator)
-        {
-            string projectFile = externalProjectStartedEventArgs.ProjectFile;
-            translator.Translate(ref projectFile);
-
-            string targetNames = externalProjectStartedEventArgs.TargetNames;
-            translator.Translate(ref targetNames);
-        }
-
         #region Writes to Stream
 
         /// <summary>
@@ -829,7 +919,13 @@ private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEv
         private void WriteResponseFileUsedEventToStream(ResponseFileUsedEventArgs responseFileUsedEventArgs, ITranslator translator)
         {
             string filePath = responseFileUsedEventArgs.ResponseFilePath;
+
             translator.Translate(ref filePath);
+
+#if !CLR2COMPATIBILITY
+            DateTime timestamp = responseFileUsedEventArgs.RawTimestamp;
+            translator.Translate(ref timestamp);
+#endif
         }
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
@@ -1066,8 +1162,6 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
             {
                 LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.ResponseFileUsedEvent => ReadResponseFileUsedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
@@ -1082,60 +1176,24 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
         private EnvironmentVariableReadEventArgs ReadEnvironmentVariableReadEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
         {
             string environmentVariableName = null;
+            MessageImportance importance = default;
+
             translator.Translate(ref environmentVariableName);
-            BuildEventContext context = null;
+            translator.TranslateEnum(ref importance, (int)importance);
+
+            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message, helpKeyword, senderName, importance);
+
 #if !CLR2COMPATIBILITY
+            DateTime timestamp = default;
+            BuildEventContext context = null;
+            translator.Translate(ref timestamp);
             translator.Translate(ref context);
-#endif
-            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message);
+            args.RawTimestamp = timestamp;
             args.BuildEventContext = context;
+#endif
             return args;
         }
 
-        /// <summary>
-        /// Read and reconstruct a ProjectFinishedEventArgs from the stream
-        /// </summary>
-        private ExternalProjectFinishedEventArgs ReadExternalProjectFinishedEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
-        {
-            string projectFile = null;
-            translator.Translate(ref projectFile);
-
-            bool succeeded = true;
-            translator.Translate(ref succeeded);
-
-            ExternalProjectFinishedEventArgs buildEvent =
-                new ExternalProjectFinishedEventArgs(
-                    message,
-                    helpKeyword,
-                    senderName,
-                    projectFile,
-                    succeeded);
-
-            return buildEvent;
-        }
-
-        /// <summary>
-        /// Read and reconstruct a ProjectStartedEventArgs from the stream
-        /// </summary>
-        private ExternalProjectStartedEventArgs ReadExternalProjectStartedEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
-        {
-            string projectFile = null;
-            translator.Translate(ref projectFile);
-
-            string targetNames = null;
-            translator.Translate(ref targetNames);
-
-            ExternalProjectStartedEventArgs buildEvent =
-                new ExternalProjectStartedEventArgs(
-                    message,
-                    helpKeyword,
-                    senderName,
-                    projectFile,
-                    targetNames);
-
-            return buildEvent;
-        }
-
         /// <summary>
         /// Read and reconstruct a BuildWarningEventArgs from the stream
         /// </summary>
@@ -1256,6 +1314,14 @@ private ResponseFileUsedEventArgs ReadResponseFileUsedEventFromStream(ITranslato
             string responseFilePath = String.Empty;
             translator.Translate(ref responseFilePath);
             ResponseFileUsedEventArgs buildEvent = new ResponseFileUsedEventArgs(responseFilePath);
+
+#if !CLR2COMPATIBILITY
+            DateTime timestamp = default;
+            translator.Translate(ref timestamp);
+            buildEvent.RawTimestamp = timestamp;
+#endif
+
+
             return buildEvent;
         }
 
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index ac7f5509236..f9abb54236e 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -101,7 +101,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// <summary>
         /// Per-node shared read buffer.
         /// </summary>
-        private SharedReadBuffer _sharedReadBuffer;
+        private BinaryReaderFactory _sharedReadBuffer;
 
         /// <summary>
         /// A way to cache a byte array when writing out packets
diff --git a/src/Shared/Pair.cs b/src/Shared/Pair.cs
index 85e688acb50..ef5073b4835 100644
--- a/src/Shared/Pair.cs
+++ b/src/Shared/Pair.cs
@@ -44,7 +44,7 @@ public Pair(TKey key, TValue value)
         /// <summary>
         /// Key
         /// </summary>
-        internal TKey Key
+        internal readonly TKey Key
         {
             get { return _key; }
         }
@@ -52,7 +52,7 @@ internal TKey Key
         /// <summary>
         /// Value
         /// </summary>
-        internal TValue Value
+        internal readonly TValue Value
         {
             get { return _value; }
         }
diff --git a/src/Shared/ProcessExtensions.cs b/src/Shared/ProcessExtensions.cs
index 260d12cc5d2..d384a07e32b 100644
--- a/src/Shared/ProcessExtensions.cs
+++ b/src/Shared/ProcessExtensions.cs
@@ -1,10 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
 using System.Diagnostics;
-using System.IO;
 
 #nullable disable
 
@@ -14,6 +11,9 @@ internal static class ProcessExtensions
     {
         public static void KillTree(this Process process, int timeoutMilliseconds)
         {
+#if NETCOREAPP
+            process.Kill(entireProcessTree: true);
+#else
             if (NativeMethodsShared.IsWindows)
             {
                 try
@@ -21,7 +21,7 @@ public static void KillTree(this Process process, int timeoutMilliseconds)
                     // issue the kill command
                     NativeMethodsShared.KillTree(process.Id);
                 }
-                catch (InvalidOperationException)
+                catch (System.InvalidOperationException)
                 {
                     // The process already exited, which is fine,
                     // just continue.
@@ -29,85 +29,13 @@ public static void KillTree(this Process process, int timeoutMilliseconds)
             }
             else
             {
-                var children = new HashSet<int>();
-                GetAllChildIdsUnix(process.Id, children);
-                foreach (var childId in children)
-                {
-                    KillProcessUnix(childId);
-                }
-
-                KillProcessUnix(process.Id);
+                throw new System.NotSupportedException();
             }
-
+#endif
             // wait until the process finishes exiting/getting killed. 
             // We don't want to wait forever here because the task is already supposed to be dieing, we just want to give it long enough
             // to try and flush what it can and stop. If it cannot do that in a reasonable time frame then we will just ignore it.
             process.WaitForExit(timeoutMilliseconds);
         }
-
-        private static void GetAllChildIdsUnix(int parentId, ISet<int> children)
-        {
-            RunProcessAndWaitForExit(
-                "pgrep",
-                $"-P {parentId}",
-                out string stdout);
-
-            if (!string.IsNullOrEmpty(stdout))
-            {
-                using (var reader = new StringReader(stdout))
-                {
-                    while (true)
-                    {
-                        var text = reader.ReadLine();
-                        if (text == null)
-                        {
-                            return;
-                        }
-
-                        int id;
-                        if (int.TryParse(text, out id))
-                        {
-                            children.Add(id);
-                            // Recursively get the children
-                            GetAllChildIdsUnix(id, children);
-                        }
-                    }
-                }
-            }
-        }
-
-        private static void KillProcessUnix(int processId)
-        {
-            try
-            {
-                using Process process = Process.GetProcessById(processId);
-                process.Kill();
-            }
-            catch (ArgumentException)
-            {
-                // Process already terminated.
-                return;
-            }
-            catch (InvalidOperationException)
-            {
-                // Process already terminated.
-                return;
-            }
-        }
-
-        private static void RunProcessAndWaitForExit(string fileName, string arguments, out string stdout)
-        {
-            var startInfo = new ProcessStartInfo
-            {
-                FileName = fileName,
-                Arguments = arguments,
-                RedirectStandardOutput = true,
-                UseShellExecute = false
-            };
-
-            var process = Process.Start(startInfo);
-            stdout = process.StandardOutput.ReadToEnd();
-            process.WaitForExit();
-        }
     }
 }
diff --git a/src/Shared/ProjectErrorUtilities.cs b/src/Shared/ProjectErrorUtilities.cs
index 17e7fd9a914..cfcb32e793a 100644
--- a/src/Shared/ProjectErrorUtilities.cs
+++ b/src/Shared/ProjectErrorUtilities.cs
@@ -1,17 +1,6 @@
 Ôªø// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-
-/******************************************************************************
- * 
- *                              !! WARNING !!
- * 
- * This class depends on the build engine assembly! Do not share this class
- * into any assembly that is not supposed to take a dependency on the build
- * engine assembly!
- * 
- * 
- ******************************************************************************/
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
 #nullable disable
@@ -36,10 +25,7 @@ internal static class ProjectErrorUtilities
         /// <param name="condition">The condition to check.</param>
         /// <param name="elementLocation">The <see cref="IElementLocation"/> of the element.</param>
         /// <param name="resourceName">The resource string for the error message.</param>
-        internal static void VerifyThrowInvalidProject(
-            bool condition,
-            IElementLocation elementLocation,
-            string resourceName)
+        internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName)
         {
             VerifyThrowInvalidProject(condition, null, elementLocation, resourceName);
         }
@@ -50,10 +36,7 @@ internal static void VerifyThrowInvalidProject(
         /// <param name="elementLocation">The <see cref="IElementLocation"/> of the element.</param>
         /// <param name="resourceName">The resource string for the error message.</param>
         /// <param name="arg0"></param>
-        internal static void ThrowInvalidProject<T1>(
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0)
+        internal static void ThrowInvalidProject<T1>(IElementLocation elementLocation, string resourceName, T1 arg0)
         {
             ThrowInvalidProject(null, elementLocation, resourceName, arg0);
         }
@@ -65,11 +48,7 @@ internal static void ThrowInvalidProject<T1>(
         /// <param name="elementLocation">The <see cref="IElementLocation"/> of the element.</param>
         /// <param name="resourceName">The resource string for the error message.</param>
         /// <param name="arg0"></param>
-        internal static void VerifyThrowInvalidProject<T1>(
-            bool condition,
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0)
+        internal static void VerifyThrowInvalidProject<T1>(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0)
         {
             VerifyThrowInvalidProject(condition, null, elementLocation, resourceName, arg0);
         }
@@ -81,11 +60,7 @@ internal static void VerifyThrowInvalidProject<T1>(
         /// <param name="resourceName">The resource string for the error message.</param>
         /// <param name="arg0"></param>
         /// <param name="arg1"></param>
-        internal static void ThrowInvalidProject<T1, T2>(
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0,
-            T2 arg1)
+        internal static void ThrowInvalidProject<T1, T2>(IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1)
         {
             ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1);
         }
@@ -98,12 +73,7 @@ internal static void ThrowInvalidProject<T1, T2>(
         /// <param name="arg0"></param>
         /// <param name="arg1"></param>
         /// <param name="arg2"></param>
-        internal static void ThrowInvalidProject<T1, T2, T3>(
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0,
-            T2 arg1,
-            T3 arg2)
+        internal static void ThrowInvalidProject<T1, T2, T3>(IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2)
         {
             ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1, arg2);
         }
@@ -117,13 +87,7 @@ internal static void ThrowInvalidProject<T1, T2, T3>(
         /// <param name="arg1"></param>
         /// <param name="arg2"></param>
         /// <param name="arg3"></param>
-        internal static void ThrowInvalidProject<T1, T2, T3, T4>(
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0,
-            T2 arg1,
-            T3 arg2,
-            T4 arg3)
+        internal static void ThrowInvalidProject<T1, T2, T3, T4>(IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2, T4 arg3)
         {
             ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1, arg2, arg3);
         }
@@ -134,10 +98,7 @@ internal static void ThrowInvalidProject<T1, T2, T3, T4>(
         /// <param name="elementLocation">The <see cref="IElementLocation"/> of the element.</param>
         /// <param name="resourceName">The resource string for the error message.</param>
         /// <param name="args"></param>
-        internal static void ThrowInvalidProject(
-            IElementLocation elementLocation,
-            string resourceName,
-            params object[] args)
+        internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, params object[] args)
         {
             ThrowInvalidProject(null, elementLocation, resourceName, args);
         }
@@ -150,12 +111,7 @@ internal static void ThrowInvalidProject(
         /// <param name="resourceName">The resource string for the error message.</param>
         /// <param name="arg0"></param>
         /// <param name="arg1"></param>
-        internal static void VerifyThrowInvalidProject<T1, T2>(
-            bool condition,
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0,
-            T2 arg1)
+        internal static void VerifyThrowInvalidProject<T1, T2>(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1)
         {
             VerifyThrowInvalidProject(condition, null, elementLocation, resourceName, arg0, arg1);
         }
@@ -169,13 +125,7 @@ internal static void VerifyThrowInvalidProject<T1, T2>(
         /// <param name="arg0"></param>
         /// <param name="arg1"></param>
         /// <param name="arg2"></param>
-        internal static void VerifyThrowInvalidProject<T1, T2, T3>(
-            bool condition,
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0,
-            T2 arg1,
-            T3 arg2)
+        internal static void VerifyThrowInvalidProject<T1, T2, T3>(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2)
         {
             VerifyThrowInvalidProject(condition, null, elementLocation, resourceName, arg0, arg1, arg2);
         }
@@ -190,14 +140,7 @@ internal static void VerifyThrowInvalidProject<T1, T2, T3>(
         /// <param name="arg1"></param>
         /// <param name="arg2"></param>
         /// <param name="arg3"></param>
-        internal static void VerifyThrowInvalidProject<T1, T2, T3, T4>(
-            bool condition,
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0,
-            T2 arg1,
-            T3 arg2,
-            T4 arg3)
+        internal static void VerifyThrowInvalidProject<T1, T2, T3, T4>(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2, T4 arg3)
         {
             VerifyThrowInvalidProject(condition, null, elementLocation, resourceName, arg0, arg1, arg2, arg3);
         }
@@ -212,16 +155,10 @@ internal static void VerifyThrowInvalidProject<T1, T2, T3, T4>(
         /// error sub-category (can be null).</param>
         /// <param name="elementLocation">The <see cref="IElementLocation"/> of the element.</param>
         /// <param name="resourceName">The resource string for the error message.</param>
-        internal static void VerifyThrowInvalidProject(
-            bool condition,
-            string errorSubCategoryResourceName,
-            IElementLocation elementLocation,
-            string resourceName)
+        internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName)
         {
             if (!condition)
             {
-                // PERF NOTE: explicitly passing null for the arguments array
-                // prevents memory allocation
                 ThrowInvalidProject(errorSubCategoryResourceName, elementLocation, resourceName, null);
             }
         }
@@ -235,16 +172,8 @@ internal static void VerifyThrowInvalidProject(
         /// <param name="elementLocation">The <see cref="IElementLocation"/> of the element.</param>
         /// <param name="resourceName">The resource string for the error message.</param>
         /// <param name="arg0"></param>
-        internal static void VerifyThrowInvalidProject<T1>(
-            bool condition,
-            string errorSubCategoryResourceName,
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0)
+        internal static void VerifyThrowInvalidProject<T1>(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowInvalidProject() method, because that method always
-            // allocates memory for its variable array of arguments
             if (!condition)
             {
                 ThrowInvalidProject(errorSubCategoryResourceName, elementLocation, resourceName, arg0);
@@ -261,17 +190,8 @@ internal static void VerifyThrowInvalidProject<T1>(
         /// <param name="resourceName">The resource string for the error message.</param>
         /// <param name="arg0"></param>
         /// <param name="arg1"></param>
-        internal static void VerifyThrowInvalidProject<T1, T2>(
-            bool condition,
-            string errorSubCategoryResourceName,
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0,
-            T2 arg1)
+        internal static void VerifyThrowInvalidProject<T1, T2>(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowInvalidProject() method, because that method always
-            // allocates memory for its variable array of arguments
             if (!condition)
             {
                 ThrowInvalidProject(errorSubCategoryResourceName, elementLocation, resourceName, arg0, arg1);
@@ -289,18 +209,8 @@ internal static void VerifyThrowInvalidProject<T1, T2>(
         /// <param name="arg0"></param>
         /// <param name="arg1"></param>
         /// <param name="arg2"></param>
-        internal static void VerifyThrowInvalidProject<T1, T2, T3>(
-            bool condition,
-            string errorSubCategoryResourceName,
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0,
-            T2 arg1,
-            T3 arg2)
+        internal static void VerifyThrowInvalidProject<T1, T2, T3>(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowInvalidProject() method, because that method always
-            // allocates memory for its variable array of arguments
             if (!condition)
             {
                 ThrowInvalidProject(errorSubCategoryResourceName, elementLocation, resourceName, arg0, arg1, arg2);
@@ -319,19 +229,8 @@ internal static void VerifyThrowInvalidProject<T1, T2, T3>(
         /// <param name="arg1"></param>
         /// <param name="arg2"></param>
         /// <param name="arg3"></param>
-        internal static void VerifyThrowInvalidProject<T1, T2, T3, T4>(
-            bool condition,
-            string errorSubCategoryResourceName,
-            IElementLocation elementLocation,
-            string resourceName,
-            T1 arg0,
-            T2 arg1,
-            T3 arg2,
-            T4 arg3)
+        internal static void VerifyThrowInvalidProject<T1, T2, T3, T4>(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2, T4 arg3)
         {
-            // PERF NOTE: check the condition here instead of pushing it into
-            // the ThrowInvalidProject() method, because that method always
-            // allocates memory for its variable array of arguments
             if (!condition)
             {
                 ThrowInvalidProject(errorSubCategoryResourceName, elementLocation, resourceName, arg0, arg1, arg2, arg3);
@@ -351,11 +250,7 @@ internal static void VerifyThrowInvalidProject<T1, T2, T3, T4>(
         /// <param name="elementLocation">The <see cref="IElementLocation"/> of the element.</param>
         /// <param name="resourceName">The resource string for the error message.</param>
         /// <param name="args">Extra arguments for formatting the error message.</param>
-        private static void ThrowInvalidProject(
-            string errorSubCategoryResourceName,
-            IElementLocation elementLocation,
-            string resourceName,
-            params object[] args)
+        private static void ThrowInvalidProject(string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, params object[] args)
         {
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 #if DEBUG
diff --git a/src/Shared/ReadOnlyCollection.cs b/src/Shared/ReadOnlyCollection.cs
index 32d751d2749..d7e5c12ce5a 100644
--- a/src/Shared/ReadOnlyCollection.cs
+++ b/src/Shared/ReadOnlyCollection.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.Collections
     /// Thus this is an omission from the BCL.
     /// </remarks>
     /// <typeparam name="T">Type of element in the collection</typeparam>
-    internal class ReadOnlyCollection<T> : ICollection<T>, ICollection
+    internal sealed class ReadOnlyCollection<T> : ICollection<T>, ICollection
     {
         /// <summary>
         /// Backing live enumerable.
diff --git a/src/Shared/ReadOnlyEmptyDictionary.cs b/src/Shared/ReadOnlyEmptyDictionary.cs
index e4b1662bdeb..46b1b2738e9 100644
--- a/src/Shared/ReadOnlyEmptyDictionary.cs
+++ b/src/Shared/ReadOnlyEmptyDictionary.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Collections
     /// </summary>
     /// <typeparam name="K">Key</typeparam>
     /// <typeparam name="V">Value</typeparam>
-    internal class ReadOnlyEmptyDictionary<K, V> : IDictionary<K, V>, IDictionary
+    internal class ReadOnlyEmptyDictionary<K, V> : IDictionary<K, V>, IReadOnlyDictionary<K, V>, IDictionary
     {
         /// <summary>
         /// The single instance
@@ -127,6 +127,22 @@ ICollection IDictionary.Values
             get { return (ICollection)((IDictionary<K, V>)this).Values; }
         }
 
+        /// <summary>
+        /// Keys
+        /// </summary>
+        IEnumerable<K> IReadOnlyDictionary<K, V>.Keys
+        {
+            get { return Keys; }
+        }
+
+        /// <summary>
+        /// Values
+        /// </summary>
+        IEnumerable<V> IReadOnlyDictionary<K, V>.Values
+        {
+            get { return Values; }
+        }
+
         /// <summary>
         /// Indexer
         /// </summary>
@@ -292,3 +308,22 @@ public void CopyTo(System.Array array, int index)
         }
     }
 }
+
+#if NET35
+namespace System.Collections.Generic
+{
+    public interface IReadOnlyCollection<T> : IEnumerable<T>
+    {
+        int Count { get; }
+    }
+
+    public interface IReadOnlyDictionary<TKey, TValue> : IReadOnlyCollection<KeyValuePair<TKey, TValue>>
+    {
+        TValue this[TKey key] { get; }
+        IEnumerable<TKey> Keys { get; }
+        IEnumerable<TValue> Values { get; }
+        bool ContainsKey(TKey key);
+        bool TryGetValue(TKey key, out TValue value);
+    }
+}
+#endif
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index f6d9799f15f..2e2fec9ad0f 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -2,7 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-#if !BUILDINGAPPXTASKS && DEBUG
+#if !BUILDINGAPPXTASKS
 using System.Resources;
 using System.Diagnostics;
 #endif
@@ -261,9 +261,9 @@ internal static string FormatString(string unformatted, params object[] args)
         /// </summary>
         /// <remarks>This method is thread-safe.</remarks>
         /// <param name="resourceName">Resource string to check.</param>
+        [Conditional("DEBUG")]
         internal static void VerifyResourceStringExists(string resourceName)
         {
-#if DEBUG
             try
             {
                 // Look up the resource string in the engine's string table.
@@ -298,6 +298,5 @@ internal static void VerifyResourceStringExists(string resourceName)
             }
 #endif
         }
-#endif
     }
 }
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index 1d110f22384..9fb94751e2f 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -66,6 +66,9 @@
   <data name="ExpectedEventToBeSerializable" Visibility="Public">
     <value>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</value>
   </data>
+  <data name="DeprecatedEventSerialization" Visibility="Public">
+    <value>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</value>
+  </data>
   <data name="FileLocation" Visibility="Public">
     <value>{0} ({1},{2})</value>
     <comment>A file location to be embedded in a string.</comment>
@@ -283,6 +286,10 @@
     <comment>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</comment>
   </data>
+  <data name="LoggingBeforeTaskInitialization" UESanitized="false" Visibility="Public">
+    <value>MSB6005: Task attempted to log before it was initialized. Message was: {0}</value>
+    <comment>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</comment>
+  </data>
   <!--
         The shared message bucket is: MSB5001 - MSB5999
 
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 575278045ee..cdffb07fb6f 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Bylo nalezeno konfliktn√≠ sestaven√≠ pro sestaven√≠ √∫lohy {0} v um√≠stƒõn√≠ {1}.</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Pou≈æit√≠ nezabezpeƒçen√©ho BinaryFormatteru bƒõhem serializace vlastn√≠ho typu ud√°losti {0}. Tento zp≈Øsob bude brzy zastaral√Ω. M√≠sto toho pros√≠m pou≈æijte Extended*EventArgs. Dal≈°√≠ informace najdete zde: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Oƒçek√°valo se, ≈æe typ ud√°losti {0} bude mo≈æn√© serializovat pomoc√≠ serializ√°toru .NET. Ud√°lost nebylo mo≈æn√© serializovat a byla ignorov√°na.</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: √öloha se pokusila p≈ôihl√°sit p≈ôed t√≠m, ne≈æ byla inicializov√°na. Zpr√°va: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">P≈ôedt√≠m, ne≈æ bude pro hostitele √∫lohy pou≈æito prost≈ôed√≠ p≈ôijat√© z nad≈ôazen√©ho uzlu, budou provedeny jeho n√°sleduj√≠c√≠ √∫pravy:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: Hodnota {0} atributu {1} v elementu &lt;{2}&gt; v souboru {3} je z√°stupn√Ω znak, jeho≈æ v√Ωsledkem je v√Ωƒçet v≈°ech soubor≈Ø na jednotce, co≈æ pravdƒõpodobnƒõ nebylo zam√Ω≈°leno. Zkontrolujte, jestli jsou odkazovan√© vlastnosti v≈ædy definov√°ny.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 3b3a861a769..9faa13d7602 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Eine mit der Aufgabenassembly "{0}" in Konflikt stehende Assembly wurde in "{1}" gefunden.</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Verwendung eines unsicheren BinaryFormatter w√§hrend der Serialisierung des benutzerdefinierten Ereignistyps '{0}'. Dies wird in K√ºrze eingestellt. Verwenden Sie stattdessen Extended*EventArgs. Weitere Informationen: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Es wurde erwartet, dass der Ereignistyp "{0}" mithilfe des .NET-Serialisierers serialisierbar ist. Das Ereignis war nicht serialisierbar und wurde ignoriert.</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: Die Aufgabe hat versucht, eine Protokollierung durchzuf√ºhren, bevor sie initialisiert wurde. Meldung: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">Es werden folgende vom √ºbergeordneten Knoten empfangene √Ñnderungen an der Umgebung vorgenommen, bevor sie auf den Aufgabenhost angewendet wird:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: Der Wert "{0}" des Attributs "{1}" in Element &lt;{2}&gt; in der Datei "{3}" ist ein Platzhalter, der dazu f√ºhrt, dass alle Dateien auf dem Laufwerk aufgelistet werden, was wahrscheinlich nicht beabsichtigt war. √úberpr√ºfen Sie, ob Eigenschaften, auf die verwiesen wird, immer definiert sind.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 9193d9bf3b8..dc91f2bd810 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Se detect√≥ un ensamblado conflictivo para el ensamblado de tarea "{0}" en "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Uso de BinaryFormatter no seguro durante la serializaci√≥n del tipo de evento personalizado "{0}". Esto estar√° en desuso pronto. En su lugar, use Extended*EventArgs. M√°s informaci√≥n: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Se esperaba que el tipo de evento "{0}" fuera serializable con el serializador .NET. El evento no era serializable y se ha omitido.</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: La tarea intent√≥ registrarse antes de inicializarse. El mensaje era: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">Se est√°n realizando las siguientes modificaciones en el entorno recibido del nodo primario antes de aplicarlo al host de tareas:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: El valor ‚Äú{0}‚Äù del atributo ‚Äú{1}‚Äù en el elemento &lt;{2}&gt; en el archivo "{3}" es un car√°cter comod√≠n que da como resultado la enumeraci√≥n de todos los archivos de la unidad, lo que probablemente no estaba previsto. Compruebe que siempre se definan las propiedades a las que se hace referencia.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 7ba650edd28..c812aa833db 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: un assembly en conflit avec l'assembly de t√¢che "{0}" a √©t√© trouv√© sur "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Utilisation de BinaryFormatter non s√©curis√© lors de la s√©rialisation d‚Äôun type d‚Äô√©v√©nement personnalis√© '{0}'. Cette op√©ration sera bient√¥t d√©conseill√©e. Utilisez Extended*EventArgs √† la place. Plus d‚Äôinformations¬†: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Le type d'√©v√©nement "{0}" devait √™tre s√©rialisable √† l'aide du s√©rialiseur .NET. L'√©v√©nement n'√©tait pas s√©rialisable et a √©t√© ignor√©.</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: La t√¢che a tent√© d'ouvrir une session avant d'√™tre initialis√©e. Le message √©tait le suivant¬†: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">Modifications suivantes en cours sur l'environnement re√ßu du n≈ìud parent avant son application √† l'h√¥te de t√¢che :</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: La valeur ¬´{0}¬ª de l‚Äôattribut ¬´{1}¬ª dans l‚Äô√©l√©ment &lt;{2}&gt; dans le fichier ¬´{3}¬ª est un caract√®re g√©n√©rique qui entra√Æne l‚Äô√©num√©ration de tous les fichiers sur le lecteur, ce qui n‚Äô√©tait probablement pas pr√©vu. V√©rifiez que les propri√©t√©s r√©f√©renc√©es sont toujours d√©finies.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 5d0abb3e4e0..2ed5a530e64 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: rilevato un assembly in conflitto per l'assembly dell'attivit√† "{0}" in "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Utilizzo di BinaryFormatter non sicuro durante la serializzazione del tipo di evento personalizzato '{0}'. Questa operazione verr√† presto deprecata. Usare invece Extended*EventArgs. Altre informazioni: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">√à previsto un tipo di evento "{0}" serializzabile con il serializzatore .NET. L'evento non era serializzabile ed √® stato ignorato.</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: tentativo di registrazione prima dell'inizializzazione dell'attivit√†. Messaggio: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">Le modifiche seguenti verranno apportate all'ambiente ricevuto dal nodo padre prima dell'applicazione all'host attivit√†:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: il valore "{0}" dell'attributo "{1}" nell'elemento &lt;{2}&gt; nel file "{3}" √® un carattere jolly che determina l'enumerazione di tutti i file nell'unit√†, che probabilmente non era previsto. Verificare che le propriet√† di riferimento siano sempre definite.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index 2bfc6c3463f..0d17c4c2a44 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: „Çø„Çπ„ÇØ „Ç¢„Çª„É≥„Éñ„É™ "{0}" „Å´ÂØæ„Åó„Å¶Á´∂Âêà„Åó„Å¶„ÅÑ„Çã„Ç¢„Çª„É≥„Éñ„É™„Åå "{1}" „ÅßË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇ</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">„Ç´„Çπ„Çø„É† „Ç§„Éô„É≥„Éà„ÅÆÁ®ÆÈ°û '{0}' „ÅÆ„Ç∑„É™„Ç¢„É´Âåñ‰∏≠„ÅÆ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„Åß‰øùË≠∑„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ BinaryFormatter „ÅÆ‰ΩøÁî®„ÄÇ„Åì„Çå„ÅØÈñì„ÇÇ„Å™„ÅèÈùûÊé®Â•®„Å´„Å™„Çä„Åæ„Åô„ÄÇ‰ª£„Çè„Çä„Å´ Extended*EventArgs „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË©≥Á¥∞ÊÉÖÂ†±: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">„Ç§„Éô„É≥„Éà„ÅÆÁ®ÆÈ°û "{0}" „ÅØ .NET „Ç∑„É™„Ç¢„É©„Ç§„Ç∂„Éº„Çí‰ΩøÁî®„Åó„Å¶„Ç∑„É™„Ç¢„É´ÂåñÂèØËÉΩ„Åß„ÅÇ„Çã„Åì„Å®„ÅåÊÉ≥ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åó„Åü„Åå„ÄÅ„Ç∑„É™„Ç¢„É´ÂåñÂèØËÉΩ„Åß„Å™„Åã„Å£„Åü„Åü„ÇÅÁÑ°Ë¶ñ„Åï„Çå„Åæ„Åó„Åü„ÄÇ</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: „Çø„Çπ„ÇØ„ÅØ„ÄÅÂàùÊúüÂåñ„Åï„Çå„ÇãÂâç„Å´„É≠„Ç∞„ÇíË®òÈå≤„Åó„Çà„ÅÜ„Å®„Åó„Åæ„Åó„Åü„ÄÇ„É°„ÉÉ„Çª„Éº„Ç∏: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">Ë¶™„Éé„Éº„Éâ„Åã„ÇâÂèó„ÅëÂèñ„Å£„ÅüÁí∞Â¢É„Çí„Çø„Çπ„ÇØ „Éõ„Çπ„Éà„Å´ÈÅ©Áî®„Åô„ÇãÂâç„Å´„ÄÅÊ¨°„ÅÆÂ§âÊõ¥„ÇíË°å„Å£„Å¶„ÅÑ„Åæ„Åô:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: „Éï„Ç°„Ç§„É´ "{3}" ÂÜÖ„ÅÆË¶ÅÁ¥† &lt;{2}&gt; „ÅÆ "{1}" Â±ûÊÄß„ÅÆÂÄ§ "{0}" „ÅØ„ÉØ„Ç§„É´„Éâ„Ç´„Éº„Éâ„Åß„ÅÇ„Çä„ÄÅ„Éâ„É©„Ç§„Éñ‰∏ä„ÅÆ„Åô„Åπ„Å¶„ÅÆ„Éï„Ç°„Ç§„É´„ÅåÂàóÊåô„Åï„Çå„Åæ„Åô„ÄÇ„Åù„Çå„ÅØÊÑèÂõ≥„Åï„Çå„Å¶„ÅØ„ÅÑ„Å™„ÅÑ„Å®ÊÄù„Çè„Çå„Åæ„Åô„ÄÇÂèÇÁÖß„Åï„Çå„Çã„Éó„É≠„Éë„ÉÜ„Ç£„ÅåÂ∏∏„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 503baf9f4b0..e8bbabfd3e9 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: ÏûëÏóÖ Ïñ¥ÏÖàÎ∏îÎ¶¨ "{0}"Í≥º(ÏôÄ) Ï∂©ÎèåÌïòÎäî Ïñ¥ÏÖàÎ∏îÎ¶¨Í∞Ä "{1}"Ïóê ÏûàÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï Ïù¥Î≤§Ìä∏ Ïú†Ìòï '{0}'Ïùò ÏßÅÎ†¨Ìôî Ï§ë Î≥¥ÏïàÎêòÏßÄ ÏïäÏùÄ BinaryFormatter ÏÇ¨Ïö©. Ïù¥ Ìï≠Î™©ÏùÄ Í≥ß ÏßÄÏõê Ï§ëÎã®Îê† ÏòàÏ†ïÏûÖÎãàÎã§. ÎåÄÏã† Extended*EventArgsÎ•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî. Ï∂îÍ∞Ä Ï†ïÎ≥¥: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Ïù¥Î≤§Ìä∏ Ïú†Ìòï "{0}"ÏùÄ(Îäî) .NET serializerÎ•º ÏÇ¨Ïö©ÌïòÏó¨ serializeÌï† Ïàò ÏûàÏñ¥Ïïº Ìï©ÎãàÎã§. Ïù¥ Ïù¥Î≤§Ìä∏Îäî serializeÌï† Ïàò ÏóÜÏúºÎØÄÎ°ú Î¨¥ÏãúÎêòÏóàÏäµÎãàÎã§.</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0}({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: ÏûëÏóÖÏùÑ Ï¥àÍ∏∞ÌôîÌïòÍ∏∞ Ï†ÑÏóê Î°úÍπÖÌïòÎ†§Í≥† ÌñàÏäµÎãàÎã§. Î©îÏãúÏßÄ: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">ÏûëÏóÖ Ìò∏Ïä§Ìä∏Ïóê Ï†ÅÏö©ÌïòÍ∏∞ Ï†ÑÏóê Î∂ÄÎ™® ÎÖ∏ÎìúÎ°úÎ∂ÄÌÑ∞ Î∞õÏùÄ ÌôòÍ≤ΩÏùÑ Îã§ÏùåÍ≥º Í∞ôÏù¥ ÏàòÏ†ïÌïòÍ≥† ÏûàÏäµÎãàÎã§.</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: ÌååÏùº "{3}"Ïóê ÏûàÎäî ÏöîÏÜå &lt;{2}&gt; ÏöîÏÜåÏùò "{1}" ÌäπÏÑ±Ïùò Í∞í "{0}"ÏùÄ(Îäî) ÏùòÎèÑÌïòÏßÄ ÏïäÏùÄ ÎìúÎùºÏù¥Î∏åÏùò Î™®Îì† ÌååÏùºÏùÑ Ïó¥Í±∞ÌïòÎäî ÏôÄÏùºÎìúÏπ¥ÎìúÏûÖÎãàÎã§. Ï∞∏Ï°∞Îêú ÏÜçÏÑ±Ïù¥ Ìï≠ÏÉÅ Ï†ïÏùòÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index c026f00091e..272e8877783 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Zestaw, kt√≥ry wywo≈Çuje konflikt z zestawem zadania ‚Äû{0}‚Äù, zosta≈Ç znaleziony w ‚Äû{1}‚Äù.</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">U≈ºycie niezabezpieczonego formatu BinaryFormatter podczas serializacji niestandardowego typu zdarzenia ‚Äû{0}‚Äù. Wkr√≥tce ta funkcja bƒôdzie przestarza≈Ça. Zamiast tego nale≈ºy u≈ºyƒá Extended*EventArgs. Wiƒôcej informacji: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Oczekiwano, ≈ºe zdarzenie typu ‚Äû{0}‚Äù bƒôdzie uszeregowane przy u≈ºyciu serializatora platformy .NET. Zdarzenie nie mo≈ºe podlegaƒá szeregowaniu, dlatego zosta≈Ço zignorowane.</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: Zadanie podjƒô≈Ço pr√≥bƒô zarejestrowania przed zainicjowaniem. Pojawi≈Ç siƒô komunikat: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">Wymienione zmiany otrzymane z wƒôz≈Ça nadrzƒôdnego zostanƒÖ wprowadzone w ≈õrodowisku, a po sprawdzeniu dzia≈Çania zastosowane do hosta zada≈Ñ:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: Warto≈õƒá ‚Äû{0}‚Äù atrybutu ‚Äû{1}‚Äù w elemencie &lt;{2}&gt; w pliku ‚Äû{3}‚Äù jest symbolem wieloznacznym, kt√≥ry powoduje wyliczenie wszystkich plik√≥w na dysku, co prawdopodobnie nie by≈Ço zamierzone. Sprawd≈∫, aby przywo≈Çywane w≈Ça≈õciwo≈õci by≈Çy zawsze zdefiniowane.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 848ba95c3da..3b4308d3b6d 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Foi encontrado um assembly conflitante no assembly da tarefa "{0}" em "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Uso de BinaryFormatter n√£o seguro durante a serializa√ß√£o do tipo de evento personalizado '{0}'. Isso ser√° obsoleto em breve. Em vez disso, use Extended*EventArgs. Mais informa√ß√µes: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Era esperado que o tipo de evento "{0}" fosse serializ√°vel usando o serializador .NET. O evento n√£o era serializ√°vel e foi ignorado.</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: A tarefa tentou fazer o registro antes de ser inicializada. A mensagem era: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">Fazendo as seguintes modifica√ß√µes no ambiente recebido do n√≥ pai antes de aplic√°-lo ao host de tarefas:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: O valor "{0}" do atributo "{1}" no elemento &lt;{2}&gt; no arquivo "{3}" √© um curinga que resulta na enumera√ß√£o de todos os arquivos na unidade, o que provavelmente n√£o foi planejado. Verifique se as propriedades referenciadas est√£o sempre definidas.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index c23b63e3b4b..eebaa4e6caa 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: –≤ "{1}" –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —Å–±–æ—Ä–∫–∞, –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É—é—â–∞—è —Å–æ —Å–±–æ—Ä–∫–æ–π –∑–∞–¥–∞—á–∏ "{0}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ BinaryFormatter –≤–æ –≤—Ä–µ–º—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–æ–≥–æ —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è "{0}". –°–∫–æ—Ä–æ —ç—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä —Å—Ç–∞–Ω–µ—Ç –Ω–µ—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–º. –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ Extended*EventArgs. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–≤–µ–¥–µ–Ω–∏—è: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">–ù–µ–æ–±—Ö–æ–¥–∏–º–æ, —á—Ç–æ–±—ã —Ç–∏–ø —Å–æ–±—ã—Ç–∏—è "{0}" –±—ã–ª —Å–µ—Ä–∏–∞–ª–∏–∑—É–µ–º—ã–º —Å –ø–æ–º–æ—â—å—é —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ .NET. –°–æ–±—ã—Ç–∏–µ –Ω–µ –±—ã–ª–æ —Å–µ—Ä–∏–∞–ª–∏–∑—É–µ–º—ã–º –∏ –±—ã–ª–æ –ø—Ä–æ–ø—É—â–µ–Ω–æ.</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: –∑–∞–¥–∞—á–µ–π –ø—Ä–µ–¥–ø—Ä–∏–Ω—è—Ç–∞ –ø–æ–ø—ã—Ç–∫–∞ –≤–µ—Å—Ç–∏ –∂—É—Ä–Ω–∞–ª –¥–æ —Å–≤–æ–µ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏. –°–æ–æ–±—â–µ–Ω–∏–µ: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">–ü–µ—Ä–µ–¥ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º –æ–∫—Ä—É–∂–µ–Ω–∏—è, –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ –æ—Ç —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ —É–∑–ª–∞, –∫ —Å–µ—Ä–≤–µ—Ä—É –∑–∞–¥–∞—á –≤ –Ω–µ–º –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è —Å–ª–µ–¥—É—é—â–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: –∑–Ω–∞—á–µ–Ω–∏–µ "{0}" –∞—Ç—Ä–∏–±—É—Ç–∞ "{1}" –≤ —ç–ª–µ–º–µ–Ω—Ç–µ &lt;{2}&gt; –≤ —Ñ–∞–π–ª–µ "{3}" —è–≤–ª—è–µ—Ç—Å—è –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–æ—á–Ω—ã–º –∑–Ω–∞–∫–æ–º, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—é –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤ –Ω–∞ –¥–∏—Å–∫–µ, —á—Ç–æ, –≤–µ—Ä–æ—è—Ç–Ω–æ, –Ω–µ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–ª–æ—Å—å. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å—Å—ã–ª–æ—á–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ –≤—Å–µ–≥–¥–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 09e4f9aeae1..775a8cc8718 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: "{0}" g√∂rev derlemesi i√ßin "{1}" konumunda √ßakƒ±≈üan derleme bulundu.</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">'{0}' √∂zel olay t√ºr√ºn√º serile≈ütirme i≈ülemi sƒ±rasƒ±nda g√ºvenli olmayan BinaryFormatter kullanƒ±mƒ±. Bu √∂zellik yakƒ±nda kullanƒ±mdan kaldƒ±rƒ±lacak. L√ºtfen bunun yerine Extended*EventArgs √∂zelliƒüini kullanƒ±n. Daha fazla bilgi: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">"{0}" olay t√ºr√ºn√ºn .NET serile≈ütiricisi kullanƒ±larak serile≈ütirilebilir olmasƒ± bekleniyordu. Olay serile≈ütirilebilir deƒüildi ve yoksayƒ±ldƒ±.</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: G√∂rev ba≈ülatƒ±lmadan √∂nce g√ºnl√ºƒüe yazmaya √ßalƒ±≈ütƒ±. ƒ∞leti: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">√úst d√ºƒü√ºmden alƒ±nan ortam g√∂rev ana bilgisayarƒ±na uygulanmadan √∂nce ortamda a≈üaƒüƒ±daki deƒüi≈üiklikler yapƒ±lƒ±yor:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: "{3}" dosyasƒ±ndaki &lt;{2}&gt; √∂ƒüesinde "{1}" √∂zniteliƒüinin "{0}" deƒüeri, s√ºr√ºc√ºdeki t√ºm dosyalarƒ±n numaralandƒ±rƒ±lmasƒ±yla sonu√ßlanan (b√ºy√ºk olasƒ±lƒ±kla bunun olmasƒ± ama√ßlanmƒ±yordu) bir joker karakterdir. Ba≈üvurulan √∂zelliklerin her zaman tanƒ±mlƒ± olduƒüundan emin olun.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index e8a04e0bba0..7e9f0b6897d 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Âú®‚Äú{1}‚ÄùÂ§ÑÂèëÁé∞‰∫Ü‰∏é‰ªªÂä°Á®ãÂ∫èÈõÜ‚Äú{0}‚ÄùÂÜ≤Á™ÅÁöÑÁ®ãÂ∫èÈõÜ„ÄÇ</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Âú®Ëá™ÂÆö‰πâ‰∫ã‰ª∂Á±ªÂûã‚Äú{0}‚ÄùÁöÑÂ∫èÂàóÂåñÊúüÈó¥‰ΩøÁî®‰∫Ü‰∏çÂÆâÂÖ®ÁöÑ BinaryFormatter„ÄÇËøôÂ∞ÜÂæàÂø´Ë¢´ÂºÉÁî®„ÄÇËØ∑ÊîπÁî® Extended*EventArgs„ÄÇËØ¶ÁªÜ‰ø°ÊÅØ: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">‰∫ã‰ª∂Á±ªÂûã‚Äú{0}‚ÄùÂ∫îÂèØ‰ª•‰ΩøÁî® .NET Â∫èÂàóÂåñÁ®ãÂ∫èËøõË°åÂ∫èÂàóÂåñ„ÄÇÊ≠§‰∫ã‰ª∂‰∏çÂèØÂ∫èÂàóÂåñÔºåÂ∑≤ÂøΩÁï•ÂÆÉ„ÄÇ</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: ‰ªªÂä°Â∞öÊú™ÂàùÂßãÂåñÂ∞±Â∞ùËØïËøõË°åÊó•ÂøóËÆ∞ÂΩï„ÄÇÊ∂àÊÅØ‰∏∫: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">ÂÖàÂØπ‰ªéÁà∂ËäÇÁÇπÊî∂Âà∞ÁöÑÁéØÂ¢ÉËøõË°å‰ª•‰∏ã‰øÆÊîπÔºåÁÑ∂ÂêéÂÜçÂ∞ÜÂÖ∂Â∫îÁî®‰∫é‰ªªÂä°ÂÆø‰∏ª:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: Êñá‰ª∂ "{3}" ‰∏≠ÂÖÉÁ¥† &lt;{2}&gt; ‰∏≠ "{1}" Â±ûÊÄßÁöÑÂÄº "{0}" ÊòØÈÄöÈÖçÁ¨¶ÔºåÂèØÂØºËá¥Êûö‰∏æÈ©±Âä®Âô®‰∏äÁöÑÊâÄÊúâÊñá‰ª∂ÔºåËøôÂèØËÉΩ‰∏çÊòØÈ¢ÑÊúüÁöÑË°å‰∏∫„ÄÇËØ∑Ê£ÄÊü•ÊòØÂê¶ÂßãÁªàÂÆö‰πâ‰∫ÜÊâÄÂºïÁî®ÁöÑÂ±ûÊÄß„ÄÇ</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index a63f80f76e2..94fd6cd9fcc 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Â∑≤Âú® "{1}" ‰∏≠ÁôºÁèæÂ∑•‰ΩúÁµÑ‰ª∂ "{0}" ÁöÑË°ùÁ™ÅÁµÑ‰ª∂„ÄÇ</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Ëá™Ë®Ç‰∫ã‰ª∂È°ûÂûã '{0}' Â∫èÂàóÂåñÊúüÈñì‰ΩøÁî®‰∏çÂÆâÂÖ®ÁöÑ BinaryFormatter„ÄÇÂç≥Â∞áÂèñ‰ª£Ê≠§È†ÖÁõÆ„ÄÇË´ãÊîπÁî® Extended*EventArgs„ÄÇÊõ¥Â§öË≥áË®ä: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">‰∫ã‰ª∂È°ûÂûã "{0}" ÊáâË©≤ÂèØ‰ª•‰ΩøÁî® .NET Â∫èÂàóÂåñÁ®ãÂºèÂ∫èÂàóÂåñ„ÄÇÊ≠§‰∫ã‰ª∂‰∏çÂèØÂ∫èÂàóÂåñÔºåÂ∑≤Áï•ÈÅé„ÄÇ</target>
@@ -32,6 +37,11 @@
         <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
+      <trans-unit id="LoggingBeforeTaskInitialization">
+        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
+        <target state="translated">MSB6005: Â∑•‰ΩúÂú®ÂàùÂßãÂåñ‰πãÂâçÂ∞±ÂòóË©¶Ë®òÈåÑ„ÄÇË®äÊÅØÁÇ∫: {0}</target>
+        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
+      </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
         <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
         <target state="translated">Âú®Â•óÁî®Âà∞Â∑•‰Ωú‰∏ªÊ©ü‰πãÂâçÔºåÂ∞çÂæûÁà∂ÁØÄÈªûÊé•Êî∂ÁöÑÁí∞Â¢ÉÈÄ≤Ë°å‰∏ãÂàó‰øÆÊîπ:</target>
@@ -310,7 +320,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: Ê™îÊ°à„Äå{3}„ÄçÂÖÉÁ¥† &lt;{2}&gt; ‰∏≠Â±¨ÊÄß„Äå{1}„ÄçÁöÑÂÄº„Äå{0}„ÄçÊòØËê¨Áî®Â≠óÂÖÉÔºåÂ∞éËá¥ÂàóËàâÁ£ÅÁ¢üÊ©ü‰∏äÁöÑÊâÄÊúâÊ™îÊ°àÔºåÈÄôÂæàÂèØËÉΩ‰∏çÊòØÈ†êÊúüÁöÑÁµêÊûú„ÄÇÊ™¢Êü•ÊòØÂê¶‰∏ÄÁõ¥ÂÆöÁæ©ÂèÉËÄÉÂ±¨ÊÄß„ÄÇ</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/StringExtensions.cs b/src/Shared/StringExtensions.cs
index 40485f659b3..4fcf361bac8 100644
--- a/src/Shared/StringExtensions.cs
+++ b/src/Shared/StringExtensions.cs
@@ -2,6 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NETFRAMEWORK
+using System.IO;
+#endif
 using System.Text;
 
 #nullable disable
@@ -48,5 +51,46 @@ public static string Replace(this string aString, string oldValue, string newVal
 
             return builder.ToString();
         }
+
+#if NETFRAMEWORK
+        /// <summary>
+        /// Trivial implementation of CommonPrefixLength on spans of characters.
+        /// </summary>
+        public static int CommonPrefixLength(this ReadOnlySpan<char> span, ReadOnlySpan<char> other)
+        {
+            int commonPrefixLength = 0;
+            int length = Math.Min(span.Length, other.Length);
+
+            while (commonPrefixLength < length && span[commonPrefixLength] == other[commonPrefixLength])
+            {
+                commonPrefixLength++;
+            }
+            return commonPrefixLength;
+        }
+
+        /// <summary>
+        /// Adds the missing span-taking overload to .NET Framework version of <see cref="StringBuilder"/>.
+        /// </summary>
+        public static StringBuilder Append(this StringBuilder sb, ReadOnlySpan<char> value)
+        {
+            return sb.Append(value.ToString());
+        }
+
+        /// <summary>
+        /// Adds the missing span-taking overload to .NET Framework version of <see cref="TextWriter"/>.
+        /// </summary>
+        public static void Write(this TextWriter writer, ReadOnlySpan<char> buffer)
+        {
+            writer.Write(buffer.ToString());
+        }
+
+        /// <summary>
+        /// Adds the missing span-taking overload to .NET Framework version of <see cref="TextWriter"/>.
+        /// </summary>
+        public static void WriteLine(this TextWriter writer, ReadOnlySpan<char> buffer)
+        {
+            writer.WriteLine(buffer.ToString());
+        }
+#endif
     }
 }
diff --git a/src/Shared/TaskHostTaskComplete.cs b/src/Shared/TaskHostTaskComplete.cs
index faad07dd31e..6e5a9029b6e 100644
--- a/src/Shared/TaskHostTaskComplete.cs
+++ b/src/Shared/TaskHostTaskComplete.cs
@@ -1,9 +1,12 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Experimental.FileAccess;
+#endif
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -49,6 +52,10 @@ internal enum TaskCompleteType
     /// </summary>
     internal class TaskHostTaskComplete : INodePacket
     {
+#if FEATURE_REPORTFILEACCESSES
+        private List<FileAccessData> _fileAccessData;
+#endif
+
         /// <summary>
         /// Result of the task's execution. 
         /// </summary>
@@ -82,12 +89,21 @@ internal class TaskHostTaskComplete : INodePacket
         /// </summary>
         private Dictionary<string, string> _buildProcessEnvironment = null;
 
+
+#pragma warning disable CS1572 // XML comment has a param tag, but there is no parameter by that name. Justification: xmldoc doesn't seem to interact well with #ifdef of params.
         /// <summary>
-        /// Constructor
+        /// Initializes a new instance of the <see cref="TaskHostTaskComplete"/> class.
         /// </summary>
-        /// <param name="result">Result of the task's execution.</param>
+        /// <param name="result">The result of the task's execution.</param>
+        /// <param name="fileAccessData">The file accesses reported by the task.</param>
         /// <param name="buildProcessEnvironment">The build process environment as it was at the end of the task's execution.</param>
-        public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<string, string> buildProcessEnvironment)
+#pragma warning restore CS1572 // XML comment has a param tag, but there is no parameter by that name
+        public TaskHostTaskComplete(
+            OutOfProcTaskHostTaskResult result,
+#if FEATURE_REPORTFILEACCESSES
+            List<FileAccessData> fileAccessData,
+#endif
+            IDictionary<string, string> buildProcessEnvironment)
         {
             ErrorUtilities.VerifyThrowInternalNull(result, nameof(result));
 
@@ -95,6 +111,9 @@ public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<stri
             _taskException = result.TaskException;
             _taskExceptionMessage = result.ExceptionMessage;
             _taskExceptionMessageArgs = result.ExceptionMessageArgs;
+#if FEATURE_REPORTFILEACCESSES
+            _fileAccessData = fileAccessData;
+#endif
 
             if (result.FinalParameterValues != null)
             {
@@ -201,6 +220,17 @@ public NodePacketType Type
             get { return NodePacketType.TaskHostTaskComplete; }
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Gets the file accesses reported by the task.
+        /// </summary>
+        public List<FileAccessData> FileAccessData
+        {
+            [DebuggerStepThrough]
+            get => _fileAccessData;
+        }
+#endif
+
         /// <summary>
         /// Translates the packet to/from binary form.
         /// </summary>
@@ -213,6 +243,13 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _taskExceptionMessageArgs);
             translator.TranslateDictionary(ref _taskOutputParameters, StringComparer.OrdinalIgnoreCase, TaskParameter.FactoryForDeserialization);
             translator.TranslateDictionary(ref _buildProcessEnvironment, StringComparer.OrdinalIgnoreCase);
+#if FEATURE_REPORTFILEACCESSES
+            translator.Translate(ref _fileAccessData,
+                (ITranslator translator, ref FileAccessData data) => ((ITranslatable)data).Translate(translator));
+#else
+            bool hasFileAccessData = false;
+            translator.Translate(ref hasFileAccessData);
+#endif
         }
 
         /// <summary>
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index e3a4a2b9f7d..4e0c4548bd7 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -503,6 +503,23 @@ public void LogMessageFromResources(MessageImportance importance, string message
 #endif
         }
 
+        /// <summary>
+        /// Flatten the inner exception message
+        /// </summary>
+        /// <param name="e">Exception to flatten.</param>
+        /// <returns></returns>
+        public static string GetInnerExceptionMessageString(Exception e)
+        {
+            StringBuilder flattenedMessage = new StringBuilder(e.Message);
+            Exception excep = e;
+            while (excep.InnerException != null)
+            {
+                excep = excep.InnerException;
+                flattenedMessage.Append(" ---> ").Append(excep.Message);
+            }
+            return flattenedMessage.ToString();
+        }
+
         #endregion
 
         #region ExternalProjectStarted/Finished logging methods
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index cf4c7934afe..4595adaba62 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -24,47 +24,37 @@ namespace Microsoft.Build.BackEnd
     internal enum TaskParameterType
     {
         /// <summary>
-        /// Parameter is null
+        /// Parameter is null.
         /// </summary>
         Null,
 
         /// <summary>
-        /// Parameter is a string
+        /// Parameter is of a type described by a <see cref="TypeCode"/>.
         /// </summary>
-        String,
+        PrimitiveType,
 
         /// <summary>
-        /// Parameter is an array of strings
+        /// Parameter is an array of a type described by a <see cref="TypeCode"/>.
         /// </summary>
-        StringArray,
+        PrimitiveTypeArray,
 
         /// <summary>
-        /// Parameter is <c>true</c> or <c>false</c>.
-        /// </summary>
-        Bool,
-
-        /// <summary>
-        /// Parameter is an <see langword="int"/>.
-        /// </summary>
-        Int,
-
-        /// <summary>
-        /// Parameter is a value type.  Note:  Must be serializable
+        /// Parameter is a value type.  Note:  Must be <see cref="IConvertible"/>.
         /// </summary>
         ValueType,
 
         /// <summary>
-        /// Parameter is an array of value types.  Note:  Must be serializable.
+        /// Parameter is an array of value types.  Note:  Must be <see cref="IConvertible"/>.
         /// </summary>
         ValueTypeArray,
 
         /// <summary>
-        /// Parameter is an ITaskItem
+        /// Parameter is an ITaskItem.
         /// </summary>
         ITaskItem,
 
         /// <summary>
-        /// Parameter is an array of ITaskItems
+        /// Parameter is an array of ITaskItems.
         /// </summary>
         ITaskItemArray,
 
@@ -72,7 +62,7 @@ internal enum TaskParameterType
         /// An invalid parameter -- the value of this parameter contains the exception
         /// that is thrown when trying to access it.
         /// </summary>
-        Invalid
+        Invalid,
     }
 
     /// <summary>
@@ -86,10 +76,15 @@ internal class TaskParameter :
         ITranslatable
     {
         /// <summary>
-        /// The TaskParameterType of the wrapped parameter
+        /// The TaskParameterType of the wrapped parameter.
         /// </summary>
         private TaskParameterType _parameterType;
 
+        /// <summary>
+        /// The <see cref="TypeCode"/> of the wrapped parameter if it's a primitive type.
+        /// </summary>
+        private TypeCode _parameterTypeCode;
+
         /// <summary>
         /// The actual task parameter that we're wrapping
         /// </summary>
@@ -124,9 +119,11 @@ public TaskParameter(object wrappedParameter)
 
             if (wrappedParameterType.IsArray)
             {
-                if (wrappedParameterType == typeof(string[]))
+                TypeCode typeCode = Type.GetTypeCode(wrappedParameterType.GetElementType());
+                if (typeCode != TypeCode.Object && typeCode != TypeCode.DBNull)
                 {
-                    _parameterType = TaskParameterType.StringArray;
+                    _parameterType = TaskParameterType.PrimitiveTypeArray;
+                    _parameterTypeCode = typeCode;
                     _wrappedParameter = wrappedParameter;
                 }
                 else if (typeof(ITaskItem[]).GetTypeInfo().IsAssignableFrom(wrappedParameterType.GetTypeInfo()))
@@ -158,37 +155,27 @@ public TaskParameter(object wrappedParameter)
             else
             {
                 // scalar parameter
-                if (wrappedParameterType == typeof(string))
-                {
-                    _parameterType = TaskParameterType.String;
-                    _wrappedParameter = wrappedParameter;
-                }
-                else if (typeof(ITaskItem).IsAssignableFrom(wrappedParameterType))
-                {
-                    _parameterType = TaskParameterType.ITaskItem;
-                    _wrappedParameter = CreateNewTaskItemFrom((ITaskItem)wrappedParameter);
-                }
                 // Preserve enums as strings: the enum type itself may not
                 // be loaded on the other side of the serialization, but
                 // we would convert to string anyway after pulling the
                 // task output into a property or item.
-                else if (wrappedParameterType.IsEnum)
+                if (wrappedParameterType.IsEnum)
                 {
-                    _parameterType = TaskParameterType.String;
-                    _wrappedParameter = (string)Convert.ChangeType(wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                    wrappedParameter = (string)Convert.ChangeType(wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                    wrappedParameterType = typeof(string);
                 }
-                // Also stringify known common value types, to avoid calling
-                // TranslateDotNet when they'll just be stringified on the
-                // output side
-                else if (wrappedParameterType == typeof(bool))
+
+                TypeCode typeCode = Type.GetTypeCode(wrappedParameterType);
+                if (typeCode != TypeCode.Object && typeCode != TypeCode.DBNull)
                 {
-                    _parameterType = TaskParameterType.Bool;
+                    _parameterType = TaskParameterType.PrimitiveType;
+                    _parameterTypeCode = typeCode;
                     _wrappedParameter = wrappedParameter;
                 }
-                else if (wrappedParameterType == typeof(int))
+                else if (typeof(ITaskItem).IsAssignableFrom(wrappedParameterType))
                 {
-                    _parameterType = TaskParameterType.Int;
-                    _wrappedParameter = wrappedParameter;
+                    _parameterType = TaskParameterType.ITaskItem;
+                    _wrappedParameter = CreateNewTaskItemFrom((ITaskItem)wrappedParameter);
                 }
                 else if (wrappedParameterType.GetTypeInfo().IsValueType)
                 {
@@ -203,31 +190,26 @@ public TaskParameter(object wrappedParameter)
         }
 
         /// <summary>
-        /// Constructor for deserialization
+        /// Constructor for deserialization.
         /// </summary>
         private TaskParameter()
         {
         }
 
         /// <summary>
-        /// The TaskParameterType of the wrapped parameter
+        /// The TaskParameterType of the wrapped parameter.
         /// </summary>
-        public TaskParameterType ParameterType
-        {
-            [DebuggerStepThrough]
-            get
-            { return _parameterType; }
-        }
+        public TaskParameterType ParameterType => _parameterType;
 
         /// <summary>
-        /// The actual task parameter that we're wrapping
+        /// The <see cref="TypeCode"/> of the wrapper parameter if it's a primitive or array of primitives.
         /// </summary>
-        public object WrappedParameter
-        {
-            [DebuggerStepThrough]
-            get
-            { return _wrappedParameter; }
-        }
+        public TypeCode ParameterTypeCode => _parameterTypeCode;
+
+        /// <summary>
+        /// The actual task parameter that we're wrapping.
+        /// </summary>
+        public object WrappedParameter => _wrappedParameter;
 
         /// <summary>
         /// TaskParameter's ToString should just pass through to whatever it's wrapping.
@@ -242,44 +224,38 @@ public override string ToString()
         /// </summary>
         public void Translate(ITranslator translator)
         {
-            translator.TranslateEnum<TaskParameterType>(ref _parameterType, (int)_parameterType);
+            translator.TranslateEnum(ref _parameterType, (int)_parameterType);
 
             switch (_parameterType)
             {
                 case TaskParameterType.Null:
                     _wrappedParameter = null;
                     break;
-                case TaskParameterType.String:
-                    string stringParam = (string)_wrappedParameter;
-                    translator.Translate(ref stringParam);
-                    _wrappedParameter = stringParam;
+                case TaskParameterType.PrimitiveType:
+                    TranslatePrimitiveType(translator);
                     break;
-                case TaskParameterType.StringArray:
-                    string[] stringArrayParam = (string[])_wrappedParameter;
-                    translator.Translate(ref stringArrayParam);
-                    _wrappedParameter = stringArrayParam;
+                case TaskParameterType.PrimitiveTypeArray:
+                    TranslatePrimitiveTypeArray(translator);
                     break;
-                case TaskParameterType.Bool:
-                    bool boolParam = _wrappedParameter switch
+                case TaskParameterType.ValueType:
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
                     {
-                        bool hadValue => hadValue,
-                        _ => default,
-                    };
-                    translator.Translate(ref boolParam);
-                    _wrappedParameter = boolParam;
-                    break;
-                case TaskParameterType.Int:
-                    int intParam = _wrappedParameter switch
+                        TranslateValueType(translator);
+                    }
+                    else
                     {
-                        int hadValue => hadValue,
-                        _ => default,
-                    };
-                    translator.Translate(ref intParam);
-                    _wrappedParameter = intParam;
+                        translator.TranslateDotNet(ref _wrappedParameter);
+                    }
                     break;
-                case TaskParameterType.ValueType:
                 case TaskParameterType.ValueTypeArray:
-                    translator.TranslateDotNet(ref _wrappedParameter);
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+                    {
+                        TranslateValueTypeArray(translator);
+                    }
+                    else
+                    {
+                        translator.TranslateDotNet(ref _wrappedParameter);
+                    }
                     break;
                 case TaskParameterType.ITaskItem:
                     TranslateITaskItem(translator);
@@ -537,6 +513,223 @@ private bool TranslateNullable<T>(ITranslator translator, T value)
             return haveRef;
         }
 
+        /// <summary>
+        /// Serializes or deserializes a primitive type value wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        private void TranslatePrimitiveType(ITranslator translator)
+        {
+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);
+
+            switch (_parameterTypeCode)
+            {
+                case TypeCode.Boolean:
+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;
+                    translator.Translate(ref boolParam);
+                    _wrappedParameter = boolParam;
+                    break;
+
+                case TypeCode.Byte:
+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;
+                    translator.Translate(ref byteParam);
+                    _wrappedParameter = byteParam;
+                    break;
+
+                case TypeCode.Int16:
+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;
+                    translator.Translate(ref shortParam);
+                    _wrappedParameter = shortParam;
+                    break;
+
+                case TypeCode.UInt16:
+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;
+                    translator.Translate(ref ushortParam);
+                    _wrappedParameter = ushortParam;
+                    break;
+
+                case TypeCode.Int64:
+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;
+                    translator.Translate(ref longParam);
+                    _wrappedParameter = longParam;
+                    break;
+
+                case TypeCode.Double:
+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;
+                    translator.Translate(ref doubleParam);
+                    _wrappedParameter = doubleParam;
+                    break;
+
+                case TypeCode.String:
+                    string stringParam = (string)_wrappedParameter;
+                    translator.Translate(ref stringParam);
+                    _wrappedParameter = stringParam;
+                    break;
+
+                case TypeCode.DateTime:
+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;
+                    translator.Translate(ref dateTimeParam);
+                    _wrappedParameter = dateTimeParam;
+                    break;
+
+                default:
+                    // Fall back to converting to/from string for types that don't have ITranslator support.
+                    string stringValue = null;
+                    if (translator.Mode == TranslationDirection.WriteToStream)
+                    {
+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                    }
+
+                    translator.Translate(ref stringValue);
+
+                    if (translator.Mode == TranslationDirection.ReadFromStream)
+                    {
+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);
+                    }
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        private void TranslatePrimitiveTypeArray(ITranslator translator)
+        {
+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);
+
+            switch (_parameterTypeCode)
+            {
+                case TypeCode.Boolean:
+                    bool[] boolArrayParam = (bool[])_wrappedParameter;
+                    translator.Translate(ref boolArrayParam);
+                    _wrappedParameter = boolArrayParam;
+                    break;
+
+                case TypeCode.Int32:
+                    int[] intArrayParam = (int[])_wrappedParameter;
+                    translator.Translate(ref intArrayParam);
+                    _wrappedParameter = intArrayParam;
+                    break;
+
+                case TypeCode.String:
+                    string[] stringArrayParam = (string[])_wrappedParameter;
+                    translator.Translate(ref stringArrayParam);
+                    _wrappedParameter = stringArrayParam;
+                    break;
+
+                default:
+                    // Fall back to converting to/from string for types that don't have ITranslator support.
+                    if (translator.Mode == TranslationDirection.WriteToStream)
+                    {
+                        Array array = (Array)_wrappedParameter;
+                        int length = array.Length;
+
+                        translator.Translate(ref length);
+
+                        for (int i = 0; i < length; i++)
+                        {
+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);
+                            translator.Translate(ref valueString);
+                        }
+                    }
+                    else
+                    {
+                        Type elementType = _parameterTypeCode switch
+                        {
+                            TypeCode.Char => typeof(char),
+                            TypeCode.SByte => typeof(sbyte),
+                            TypeCode.Byte => typeof(byte),
+                            TypeCode.Int16 => typeof(short),
+                            TypeCode.UInt16 => typeof(ushort),
+                            TypeCode.UInt32 => typeof(uint),
+                            TypeCode.Int64 => typeof(long),
+                            TypeCode.UInt64 => typeof(ulong),
+                            TypeCode.Single => typeof(float),
+                            TypeCode.Double => typeof(double),
+                            TypeCode.Decimal => typeof(decimal),
+                            TypeCode.DateTime => typeof(DateTime),
+                            _ => throw new NotImplementedException(),
+                        };
+
+                        int length = 0;
+                        translator.Translate(ref length);
+
+                        Array array = Array.CreateInstance(elementType, length);
+                        for (int i = 0; i < length; i++)
+                        {
+                            string valueString = null;
+                            translator.Translate(ref valueString);
+                            array.SetValue(Convert.ChangeType(valueString, _parameterTypeCode, CultureInfo.InvariantCulture), i);
+                        }
+                        _wrappedParameter = array;
+                    }
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Serializes or deserializes the value type instance wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        /// <remarks>
+        /// The value type is converted to/from string using the <see cref="Convert"/> class. Note that we require
+        /// task parameter types to be <see cref="IConvertible"/> so this conversion is guaranteed to work for parameters
+        /// that have made it this far.
+        /// </remarks>
+        private void TranslateValueType(ITranslator translator)
+        {
+            string valueString = null;
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                valueString = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+            }
+
+            translator.Translate(ref valueString);
+
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                // We don't know how to convert the string back to the original value type. This is fine because output
+                // task parameters are anyway converted to strings by the engine (see TaskExecutionHost.GetValueOutputs)
+                // and input task parameters of custom value types are not supported.
+                _wrappedParameter = valueString;
+            }
+        }
+
+        /// <summary>
+        /// Serializes or deserializes the value type array instance wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        /// <remarks>
+        /// The array is assumed to be non-null.
+        /// </remarks>
+        private void TranslateValueTypeArray(ITranslator translator)
+        {
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                Array array = (Array)_wrappedParameter;
+                int length = array.Length;
+
+                translator.Translate(ref length);
+
+                for (int i = 0; i < length; i++)
+                {
+                    string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);
+                    translator.Translate(ref valueString);
+                }
+            }
+            else
+            {
+                int length = 0;
+                translator.Translate(ref length);
+
+                string[] stringArray = new string[length];
+                for (int i = 0; i < length; i++)
+                {
+                    translator.Translate(ref stringArray[i]);
+                }
+
+                // We don't know how to convert the string array back to the original value type array.
+                // This is fine because the engine would eventually convert it to strings anyway.
+                _wrappedParameter = stringArray;
+            }
+        }
+
         /// <summary>
         /// Super simple ITaskItem derivative that we can use as a container for read items.
         /// </summary>
@@ -856,6 +1049,14 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataLazy()
                     yield return unescaped;
                 }
             }
+
+            public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
+            {
+                foreach (KeyValuePair<string, string> kvp in metadata)
+                {
+                    SetMetadata(kvp.Key, kvp.Value);
+                }
+            }
         }
     }
 }
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index 71b52e4d565..d26f7127305 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -6,6 +6,7 @@
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 #if DEBUG
+using System.Globalization;
 using System.Reflection;
 #endif
 
@@ -58,7 +59,7 @@ static Tracing()
 
             string val = Environment.GetEnvironmentVariable("MSBUILDTRACEINTERVAL");
             double seconds;
-            if (!String.IsNullOrEmpty(val) && System.Double.TryParse(val, out seconds))
+            if (!String.IsNullOrEmpty(val) && System.Double.TryParse(val, NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture.NumberFormat, out seconds))
             {
                 s_interval = TimeSpan.FromSeconds(seconds);
             }
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index 12ef8396ae8..5efa28ce676 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -679,68 +679,6 @@ public void VerifyReverseVersionComparer()
             Assert.True(assemblies[2].Equals(y));
         }
 
-        [Theory]
-        [InlineData("System.Xml")]
-        [InlineData("System.XML, Version=2.0.0.0")]
-        [InlineData("System.Xml, Culture=de-DE")]
-        [InlineData("System.Xml, Version=10.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a, Retargetable=Yes")]
-        [InlineData("System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
-        public void VerifyAssemblyNameExSerialization(string assemblyName)
-        {
-            AssemblyNameExtension assemblyNameOriginal = new AssemblyNameExtension(assemblyName);
-            AssemblyNameExtension assemblyNameDeserialized;
-
-            byte[] bytes;
-
-            using (MemoryStream ms = new MemoryStream())
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-                formatter.Serialize(ms, assemblyNameOriginal);
-
-                bytes = ms.ToArray();
-            }
-
-            using (MemoryStream ms = new MemoryStream(bytes))
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-                assemblyNameDeserialized = (AssemblyNameExtension)formatter.Deserialize(ms);
-            }
-
-            assemblyNameDeserialized.ShouldBe(assemblyNameOriginal);
-        }
-
-        [Fact]
-        public void VerifyAssemblyNameExSerializationWithRemappedFrom()
-        {
-            AssemblyNameExtension assemblyNameOriginal = new AssemblyNameExtension("System.Xml, Version=10.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
-            AssemblyNameExtension assemblyRemappedFrom = new AssemblyNameExtension("System.Xml, Version=9.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
-            assemblyRemappedFrom.MarkImmutable();
-            assemblyNameOriginal.AddRemappedAssemblyName(assemblyRemappedFrom);
-            assemblyNameOriginal.RemappedFromEnumerator.Count().ShouldBe(1);
-
-            AssemblyNameExtension assemblyNameDeserialized;
-
-            byte[] bytes;
-
-            using (MemoryStream ms = new MemoryStream())
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-                formatter.Serialize(ms, assemblyNameOriginal);
-
-                bytes = ms.ToArray();
-            }
-
-            using (MemoryStream ms = new MemoryStream(bytes))
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-                assemblyNameDeserialized = (AssemblyNameExtension)formatter.Deserialize(ms);
-            }
-
-            assemblyNameDeserialized.Equals(assemblyNameOriginal).ShouldBeTrue();
-            assemblyNameDeserialized.RemappedFromEnumerator.Count().ShouldBe(1);
-            assemblyNameDeserialized.RemappedFromEnumerator.First().ShouldBe(assemblyRemappedFrom);
-        }
-
         [Theory]
         [InlineData("System.Xml")]
         [InlineData("System.XML, Version=2.0.0.0")]
@@ -758,7 +696,7 @@ public void VerifyAssemblyNameExSerializationByTranslator(string assemblyName)
             writeTranslator.Translate(ref assemblyNameOriginal, (ITranslator t) => new AssemblyNameExtension(t));
 
             serializationStream.Seek(0, SeekOrigin.Begin);
-            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, null);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, InterningBinaryReader.PoolingBuffer);
 
             readTranslator.Translate(ref assemblyNameDeserialized, (ITranslator t) => new AssemblyNameExtension(t));
 
@@ -782,7 +720,7 @@ public void VerifyAssemblyNameExSerializationWithRemappedFromByTranslator()
             writeTranslator.Translate(ref assemblyNameOriginal, (ITranslator t) => new AssemblyNameExtension(t));
 
             serializationStream.Seek(0, SeekOrigin.Begin);
-            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, null);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, InterningBinaryReader.PoolingBuffer);
 
             readTranslator.Translate(ref assemblyNameDeserialized, (ITranslator t) => new AssemblyNameExtension(t));
 
diff --git a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
index 9589762b100..8beef1b543f 100644
--- a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
+++ b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
@@ -192,53 +192,5 @@ public void CloneWritesNotVisibleToOriginal()
             Assert.Equal("1", dictionary["test"]);
             Assert.Equal("2", clone["test"]);
         }
-
-        /// <summary>
-        /// Serialize basic case
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize()
-        {
-            CopyOnWriteDictionary<string> dictionary = new CopyOnWriteDictionary<string>();
-            dictionary.Add("Key1", "1");
-
-            using (MemoryStream stream = new MemoryStream())
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-
-                formatter.Serialize(stream, dictionary);
-                stream.Position = 0;
-
-                var dictionary2 = (CopyOnWriteDictionary<string>)formatter.Deserialize(stream);
-
-                Assert.Equal(dictionary.Count, dictionary2.Count);
-                Assert.Equal(dictionary.Comparer, dictionary2.Comparer);
-                Assert.Equal("1", dictionary2["Key1"]);
-
-                dictionary2.Add("key2", "2");
-            }
-        }
-
-        /// <summary>
-        /// Serialize custom comparer
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize2()
-        {
-            CopyOnWriteDictionary<string> dictionary = new CopyOnWriteDictionary<string>(MSBuildNameIgnoreCaseComparer.Default);
-
-            using (MemoryStream stream = new MemoryStream())
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-
-                formatter.Serialize(stream, dictionary);
-                stream.Position = 0;
-
-                CopyOnWriteDictionary<string> deserialized = (CopyOnWriteDictionary<string>)formatter.Deserialize(stream);
-
-                deserialized.Count.ShouldBe(dictionary.Count);
-                deserialized.Comparer.ShouldBeOfType<MSBuildNameIgnoreCaseComparer>();
-            }
-        }
     }
 }
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index 9a9bec6d5c9..df21aa2f2e6 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -26,7 +26,7 @@ namespace Microsoft.Build.UnitTests
      * up a raw string (fullLog) that contains all messages, warnings, errors.
      * Thread-safe.
      */
-    internal sealed class MockLogger : ILogger
+    public sealed class MockLogger : ILogger
     {
         #region Properties
 
@@ -138,6 +138,11 @@ internal sealed class MockLogger : ILogger
         /// </summary>
         internal List<BuildFinishedEventArgs> BuildFinishedEvents { get; } = new List<BuildFinishedEventArgs>();
 
+        /// <summary>
+        /// List of Telemetry events
+        /// </summary>
+        internal List<TelemetryEventArgs> TelemetryEvents { get; } = new();
+
         internal List<BuildEventArgs> AllBuildEvents { get; } = new List<BuildEventArgs>();
 
         /*
@@ -175,11 +180,7 @@ internal string FullLog
          * The mock logger does not take parameters.
          * 
          */
-        public string Parameters
-        {
-            get => null;
-            set {/* do nothing */}
-        }
+        public string Parameters { get; set; }
 
         /*
          * Method:  Initialize
@@ -190,6 +191,10 @@ public string Parameters
         public void Initialize(IEventSource eventSource)
         {
             eventSource.AnyEventRaised += LoggerEventHandler;
+            if (eventSource is IEventSource2 eventSource2)
+            {
+                eventSource2.TelemetryLogged += TelemetryEventHandler;
+            }
 
             if (_profileEvaluation)
             {
@@ -197,6 +202,12 @@ public void Initialize(IEventSource eventSource)
                 eventSource3.ShouldNotBeNull();
                 eventSource3.IncludeEvaluationProfiles();
             }
+
+            // Apply parameters
+            if (Parameters?.IndexOf("reporttelemetry", StringComparison.OrdinalIgnoreCase) >= 0)
+            {
+                _reportTelemetry = true;
+            }
         }
 
         /// <summary>
@@ -222,6 +233,10 @@ public void Shutdown()
         }
         #endregion
 
+        public MockLogger() : this(null)
+        {
+        }
+
         public MockLogger(ITestOutputHelper testOutputHelper = null, bool profileEvaluation = false, bool printEventsToStdout = true, LoggerVerbosity verbosity = LoggerVerbosity.Normal)
         {
             _testOutputHelper = testOutputHelper;
@@ -282,8 +297,13 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                             bool logMessage = !(eventArgs is BuildFinishedEventArgs) || LogBuildFinished;
                             if (logMessage)
                             {
-                                _fullLog.AppendLine(eventArgs.Message);
-                                _testOutputHelper?.WriteLine(eventArgs.Message);
+                                string msg = eventArgs.Message;
+                                if (eventArgs is BuildMessageEventArgs m && m.LineNumber != 0)
+                                {
+                                    msg = $"{m.File}({m.LineNumber},{m.ColumnNumber}): {msg}";
+                                }
+                                _fullLog.AppendLine(msg);
+                                _testOutputHelper?.WriteLine(msg);
                             }
                             break;
                         }
@@ -378,6 +398,27 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
             }
         }
 
+        internal void TelemetryEventHandler(object sender, BuildEventArgs eventArgs)
+        {
+            lock (_lockObj)
+            {
+                if (eventArgs is TelemetryEventArgs telemetryEventArgs)
+                {
+                    TelemetryEvents.Add(telemetryEventArgs);
+
+                    if (_reportTelemetry)
+                    {
+                        // Log telemetry events to the full log so we can verify them in end-to-end tests by captured outputs.
+                        _fullLog.AppendLine($"Telemetry:{telemetryEventArgs.EventName}");
+                        foreach (KeyValuePair<string, string> pair in telemetryEventArgs.Properties)
+                        {
+                            _fullLog.AppendLine($"    {telemetryEventArgs.EventName}:{pair.Key}={pair.Value}");
+                        }
+                    }
+                }
+            }
+        }
+
         private void PrintFullLog()
         {
             if (_printEventsToStdout)
@@ -392,6 +433,7 @@ private void PrintFullLog()
             typeof(ProjectCollection).GetTypeInfo().Assembly));
 
         private static ResourceManager s_engineResourceManager;
+        private bool _reportTelemetry;
 
         // Gets the resource string given the resource ID
         public static string GetString(string stringId) => EngineResourceManager.GetString(stringId, CultureInfo.CurrentUICulture);
@@ -496,9 +538,9 @@ internal void AssertLogDoesntContain(string contains)
         /// </summary>
         internal void AssertNoWarnings() => Assert.Equal(0, WarningCount);
 
-        internal void AssertMessageCount(string message, int expectedCount)
+        internal void AssertMessageCount(string message, int expectedCount, bool regexSearch = true)
         {
-            var matches = Regex.Matches(FullLog, message);
+            var matches = Regex.Matches(FullLog, regexSearch ? message : Regex.Escape(message));
             matches.Count.ShouldBe(expectedCount);
         }
     }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 31ce5b63c29..659aea6dab9 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -499,7 +499,7 @@ internal static void AssertArrayContentsMatch(object[] expected, object[] actual
         }
 
         /// <summary>
-        /// Parses the crazy string passed into AssertItemsMatch and returns a list of ITaskItems.
+        /// Parses the string passed into AssertItemsMatch and returns a list of ITaskItems.
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <returns></returns>
@@ -1155,6 +1155,11 @@ internal static string GetOSPlatformAsString()
         /// </summary>
         internal static int Count(IEnumerable enumerable)
         {
+            if (enumerable is ICollection c)
+            {
+                return c.Count;
+            }
+
             int i = 0;
             foreach (object _ in enumerable)
             {
@@ -1341,7 +1346,7 @@ internal static MockLogger BuildProjectWithNewOMExpectSuccess(string content, Di
         /// </summary>
         private static void BuildProjectWithNewOM(string content, ref MockLogger logger, out bool result, bool allowTaskCrash, Dictionary<string, string> globalProperties = null)
         {
-            // Replace the crazy quotes with real ones
+            // Replace the nonstandard quotes with real ones
             content = ObjectModelHelpers.CleanupFileContents(content);
 
             Project project = new Project(XmlReader.Create(new StringReader(content)), globalProperties, toolsVersion: null);
@@ -1367,7 +1372,7 @@ public static MockLogger BuildProjectContentUsingBuildManagerExpectResult(string
 
         public static BuildResult BuildProjectContentUsingBuildManager(string content, MockLogger logger, BuildParameters parameters = null)
         {
-            // Replace the crazy quotes with real ones
+            // Replace the nonstandard quotes with real ones
             content = ObjectModelHelpers.CleanupFileContents(content);
 
             using (var env = TestEnvironment.Create())
@@ -1421,7 +1426,7 @@ internal enum ExpectedBuildResult
         }
 
         /// <summary>
-        /// Verify that a drive enumerating wildcard warning is logged or exception is thrown. 
+        /// Verify that a drive enumerating wildcard warning is logged or exception is thrown.
         /// </summary>
         internal static void CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(string content, string failOnDriveEnumerationEnvVar, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
         {
diff --git a/src/Shared/UnitTests/TaskParameter_Tests.cs b/src/Shared/UnitTests/TaskParameter_Tests.cs
index a33b226229a..6b23cbac9aa 100644
--- a/src/Shared/UnitTests/TaskParameter_Tests.cs
+++ b/src/Shared/UnitTests/TaskParameter_Tests.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
@@ -39,96 +40,124 @@ public void NullParameter()
             Assert.Equal(TaskParameterType.Null, t2.ParameterType);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a string parameter is OK.
-        /// </summary>
-        [Fact]
-        public void StringParameter()
+        [Theory]
+        [InlineData(typeof(bool), (int)TypeCode.Boolean, "True")]
+        [InlineData(typeof(byte), (int)TypeCode.Byte, "127")]
+        [InlineData(typeof(sbyte), (int)TypeCode.SByte, "-127")]
+        [InlineData(typeof(double), (int)TypeCode.Double, "3.14")]
+        [InlineData(typeof(float), (int)TypeCode.Single, "3.14")]
+        [InlineData(typeof(short), (int)TypeCode.Int16, "-20000")]
+        [InlineData(typeof(ushort), (int)TypeCode.UInt16, "30000")]
+        [InlineData(typeof(int), (int)TypeCode.Int32, "-1")]
+        [InlineData(typeof(uint), (int)TypeCode.UInt32, "1")]
+        [InlineData(typeof(long), (int)TypeCode.Int64, "-1000000000000")]
+        [InlineData(typeof(ulong), (int)TypeCode.UInt64, "1000000000000")]
+        [InlineData(typeof(decimal), (int)TypeCode.Decimal, "29.99")]
+        [InlineData(typeof(char), (int)TypeCode.Char, "q")]
+        [InlineData(typeof(string), (int)TypeCode.String, "foo")]
+        [InlineData(typeof(DateTime), (int)TypeCode.DateTime, "1/1/2000 12:12:12")]
+        public void PrimitiveParameter(Type type, int expectedTypeCodeAsInt, string testValueAsString)
         {
-            TaskParameter t = new TaskParameter("foo");
+            TypeCode expectedTypeCode = (TypeCode)expectedTypeCodeAsInt;
+
+            object value = Convert.ChangeType(testValueAsString, type, CultureInfo.InvariantCulture);
+            TaskParameter t = new TaskParameter(value);
 
-            Assert.Equal("foo", t.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t.ParameterType);
+            Assert.Equal(value, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveType, t.ParameterType);
+            Assert.Equal(expectedTypeCode, t.ParameterTypeCode);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal("foo", t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t2.ParameterType);
+            Assert.Equal(value, t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveType, t2.ParameterType);
+            Assert.Equal(expectedTypeCode, t2.ParameterTypeCode);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a string array parameter is OK.
-        /// </summary>
-        [Fact]
-        public void StringArrayParameter()
+        [Theory]
+        [InlineData(typeof(bool), (int)TypeCode.Boolean, "True;False;True")]
+        [InlineData(typeof(byte), (int)TypeCode.Byte, "127;100;0")]
+        [InlineData(typeof(sbyte), (int)TypeCode.SByte, "-127;-126;12")]
+        [InlineData(typeof(double), (int)TypeCode.Double, "3.14;3.15")]
+        [InlineData(typeof(float), (int)TypeCode.Single, "3.14;3.15")]
+        [InlineData(typeof(short), (int)TypeCode.Int16, "-20000;0;-1")]
+        [InlineData(typeof(ushort), (int)TypeCode.UInt16, "30000;20000;10")]
+        [InlineData(typeof(int), (int)TypeCode.Int32, "-1;-2")]
+        [InlineData(typeof(uint), (int)TypeCode.UInt32, "1;5;6")]
+        [InlineData(typeof(long), (int)TypeCode.Int64, "-1000000000000;0")]
+        [InlineData(typeof(ulong), (int)TypeCode.UInt64, "1000000000000;0")]
+        [InlineData(typeof(decimal), (int)TypeCode.Decimal, "29.99;0.88")]
+        [InlineData(typeof(char), (int)TypeCode.Char, "q;r;c")]
+        [InlineData(typeof(string), (int)TypeCode.String, "foo;bar")]
+        [InlineData(typeof(DateTime), (int)TypeCode.DateTime, "1/1/2000 12:12:12;2/2/2000 13:13:13")]
+        public void PrimitiveArrayParameter(Type type, int expectedTypeCodeAsInt, string testValueAsString)
         {
-            TaskParameter t = new TaskParameter(new string[] { "foo", "bar" });
+            TypeCode expectedTypeCode = (TypeCode)expectedTypeCodeAsInt;
 
-            Assert.Equal(TaskParameterType.StringArray, t.ParameterType);
+            string[] values = testValueAsString.Split(';');
+            Array array = Array.CreateInstance(type, values.Length);
+            for (int i = 0; i < values.Length; i++)
+            {
+                object value = Convert.ChangeType(values[i], type, CultureInfo.InvariantCulture);
+                array.SetValue(value, i);
+            }
 
-            string[] wrappedParameter = t.WrappedParameter as string[];
-            Assert.NotNull(wrappedParameter);
-            Assert.Equal(2, wrappedParameter.Length);
-            Assert.Equal("foo", wrappedParameter[0]);
-            Assert.Equal("bar", wrappedParameter[1]);
+            TaskParameter t = new TaskParameter(array);
+
+            Assert.Equal(array, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveTypeArray, t.ParameterType);
+            Assert.Equal(expectedTypeCode, t.ParameterTypeCode);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal(TaskParameterType.StringArray, t2.ParameterType);
-
-            string[] wrappedParameter2 = t2.WrappedParameter as string[];
-            Assert.NotNull(wrappedParameter2);
-            Assert.Equal(2, wrappedParameter2.Length);
-            Assert.Equal("foo", wrappedParameter2[0]);
-            Assert.Equal("bar", wrappedParameter2[1]);
+            Assert.Equal(array, t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveTypeArray, t2.ParameterType);
+            Assert.Equal(expectedTypeCode, t2.ParameterTypeCode);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a value type (integer) parameter is OK.
-        /// </summary>
         [Fact]
-        public void IntParameter()
+        public void ValueTypeParameter()
         {
-            TaskParameter t = new TaskParameter(1);
+            TaskBuilderTestTask.CustomStruct value = new TaskBuilderTestTask.CustomStruct(3.14);
+            TaskParameter t = new TaskParameter(value);
 
-            Assert.Equal(1, t.WrappedParameter);
-            Assert.Equal(TaskParameterType.Int, t.ParameterType);
+            Assert.Equal(value, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.ValueType, t.ParameterType);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal(1, t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.Int, t2.ParameterType);
+            // Custom IConvertible structs are deserialized into strings.
+            Assert.Equal(value.ToString(CultureInfo.InvariantCulture), t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.ValueType, t2.ParameterType);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.
-        /// </summary>
         [Fact]
-        public void IntArrayParameter()
+        public void ValueTypeArrayParameter()
         {
-            TaskParameter t = new TaskParameter(new int[] { 2, 15 });
-
+            TaskBuilderTestTask.CustomStruct[] value = new TaskBuilderTestTask.CustomStruct[]
+            {
+                new TaskBuilderTestTask.CustomStruct(3.14),
+                new TaskBuilderTestTask.CustomStruct(2.72),
+            };
+            TaskParameter t = new TaskParameter(value);
+
+            Assert.Equal(value, t.WrappedParameter);
             Assert.Equal(TaskParameterType.ValueTypeArray, t.ParameterType);
 
-            int[] wrappedParameter = t.WrappedParameter as int[];
-            Assert.NotNull(wrappedParameter);
-            Assert.Equal(2, wrappedParameter.Length);
-            Assert.Equal(2, wrappedParameter[0]);
-            Assert.Equal(15, wrappedParameter[1]);
-
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
+            // Custom IConvertible structs are deserialized into strings.
+            Assert.True(t2.WrappedParameter is string[]);
             Assert.Equal(TaskParameterType.ValueTypeArray, t2.ParameterType);
 
-            int[] wrappedParameter2 = t2.WrappedParameter as int[];
-            Assert.NotNull(wrappedParameter2);
-            Assert.Equal(2, wrappedParameter2.Length);
-            Assert.Equal(2, wrappedParameter2[0]);
-            Assert.Equal(15, wrappedParameter2[1]);
+            string[] stringArray = (string[])t2.WrappedParameter;
+            Assert.Equal(2, stringArray.Length);
+            Assert.Equal(value[0].ToString(CultureInfo.InvariantCulture), stringArray[0]);
+            Assert.Equal(value[1].ToString(CultureInfo.InvariantCulture), stringArray[1]);
         }
 
         private enum TestEnumForParameter
@@ -143,55 +172,15 @@ public void EnumParameter()
             TaskParameter t = new TaskParameter(TestEnumForParameter.SomethingElse);
 
             Assert.Equal("SomethingElse", t.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t.ParameterType);
+            Assert.Equal(TaskParameterType.PrimitiveType, t.ParameterType);
+            Assert.Equal(TypeCode.String, t.ParameterTypeCode);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
             Assert.Equal("SomethingElse", t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t2.ParameterType);
-        }
-
-        [Fact]
-        public void BoolParameter()
-        {
-            TaskParameter t = new TaskParameter(true);
-
-            Assert.Equal(true, t.WrappedParameter);
-            Assert.Equal(TaskParameterType.Bool, t.ParameterType);
-
-            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
-            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
-
-            Assert.Equal(true, t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.Bool, t2.ParameterType);
-        }
-
-        /// <summary>
-        /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.
-        /// </summary>
-        [Fact]
-        public void BoolArrayParameter()
-        {
-            TaskParameter t = new TaskParameter(new bool[] { false, true });
-
-            Assert.Equal(TaskParameterType.ValueTypeArray, t.ParameterType);
-
-            bool[] wrappedParameter = t.WrappedParameter as bool[];
-            Assert.NotNull(wrappedParameter);
-            Assert.Equal(2, wrappedParameter.Length);
-            Assert.False(wrappedParameter[0]);
-            Assert.True(wrappedParameter[1]);
-
-            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
-            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
-
-            Assert.Equal(TaskParameterType.ValueTypeArray, t2.ParameterType);
-
-            bool[] wrappedParameter2 = Assert.IsType<bool[]>(t2.WrappedParameter);
-            Assert.Equal(2, wrappedParameter2.Length);
-            Assert.False(wrappedParameter2[0]);
-            Assert.True(wrappedParameter2[1]);
+            Assert.Equal(TaskParameterType.PrimitiveType, t2.ParameterType);
+            Assert.Equal(TypeCode.String, t2.ParameterTypeCode);
         }
 
         /// <summary>
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 5d7d3d22d65..ad715d6c44b 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -9,6 +9,7 @@
 using System.IO.Compression;
 using System.Linq;
 using System.Text.RegularExpressions;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
@@ -95,6 +96,7 @@ private void Cleanup()
                 }
 
                 SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", "");
+                ChangeWaves.ResetStateForTests();
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
             }
         }
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index e37749e172c..27e32d603cb 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -32,9 +32,8 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
                 return oldElement;
             }
 
-            XmlElementWithLocation newElement = (xmlNamespace == null)
-                ? (XmlElementWithLocation)oldElement.OwnerDocument.CreateElement(newElementName)
-                : (XmlElementWithLocation)oldElement.OwnerDocument.CreateElement(newElementName, xmlNamespace);
+            XmlElementWithLocation newElement =
+                (XmlElementWithLocation)((XmlDocumentWithLocation)oldElement.OwnerDocument).CreateElement(newElementName, xmlNamespace ?? string.Empty, oldElement.Location);
 
             // Copy over all the attributes.
             foreach (XmlAttribute oldAttribute in oldElement.Attributes)
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
index 0c10b4d1f04..6b8d8eb14f0 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
@@ -18,8 +18,6 @@
 
   <ItemGroup>
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="xunit.core" />
-    <PackageReference Include="xunit.assert" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/StringTools/CompatibilitySuppressions.xml b/src/StringTools/CompatibilitySuppressions.xml
deleted file mode 100644
index b2f2578762f..00000000000
--- a/src/StringTools/CompatibilitySuppressions.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-Ôªø<?xml version="1.0" encoding="utf-8"?>
-<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <Suppression>
-    <!-- Dropped net35 for 17.5; see https://github.com/dotnet/msbuild/pull/8198 -->
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>.NETFramework,Version=v3.5</Target>
-  </Suppression>
-</Suppressions>
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
index 57789ab0700..4328bbc084e 100644
--- a/src/StringTools/InternableString.Simple.cs
+++ b/src/StringTools/InternableString.Simple.cs
@@ -57,7 +57,7 @@ public Enumerator(InternableString spanBuilder)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public char Current => (_string._builder == null ? _string.FirstString[_charIndex] : _string._builder[_charIndex]);
+            public readonly char Current => (_string._builder == null ? _string.FirstString[_charIndex] : _string._builder[_charIndex]);
 
             /// <summary>
             /// Moves to the next character.
@@ -88,7 +88,7 @@ public bool MoveNext()
         /// <summary>
         /// A convenience getter to ensure that we always operate on a non-null string.
         /// </summary>
-        private string FirstString => _firstString ?? string.Empty;
+        private readonly string FirstString => _firstString ?? string.Empty;
 
         /// <summary>
         /// Constructs a new InternableString wrapping the given string.
@@ -116,13 +116,13 @@ internal InternableString(SpanBasedStringBuilder builder)
         /// <summary>
         /// Gets the length of the string.
         /// </summary>
-        public int Length => (_builder == null ? FirstString.Length : _builder.Length);
+        public readonly int Length => (_builder == null ? FirstString.Length : _builder.Length);
 
         /// <summary>
         /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
         /// </summary>
         /// <returns>The enumerator.</returns>
-        public Enumerator GetEnumerator()
+        public readonly Enumerator GetEnumerator()
         {
             return new Enumerator(this);
         }
@@ -132,7 +132,7 @@ public Enumerator GetEnumerator()
         /// </summary>
         /// <param name="other">Another string.</param>
         /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
-        public bool Equals(string other)
+        public readonly bool Equals(string other)
         {
             if (other.Length != Length)
             {
@@ -163,7 +163,7 @@ public bool Equals(string other)
         /// System.String in which case the original string is returned.
         /// </summary>
         /// <returns>The string.</returns>
-        public string ExpensiveConvertToString()
+        public readonly string ExpensiveConvertToString()
         {
             // Special case: if we hold just one string, we can directly return it.
             if (_firstString != null)
@@ -178,9 +178,9 @@ public string ExpensiveConvertToString()
         /// </summary>
         /// <param name="str">The string to compare to.</param>
         /// <returns>True is this instance wraps the given string.</returns>
-        public bool ReferenceEquals(string str)
+        public readonly bool ReferenceEquals(string str)
         {
-            return Object.ReferenceEquals(str, _firstString);
+            return ReferenceEquals(str, _firstString);
         }
 
         /// <summary>
@@ -198,7 +198,7 @@ public override unsafe string ToString()
         /// Implements the simple yet very decently performing djb2 hash function (xor version).
         /// </summary>
         /// <returns>A stable hashcode of the string represented by this instance.</returns>
-        public override int GetHashCode()
+        public override readonly int GetHashCode()
         {
             uint hash = (5381 << 16) + 5381;
             bool isOddIndex = false;
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
index 413aad9fb88..7e657d56cdb 100644
--- a/src/StringTools/InternableString.cs
+++ b/src/StringTools/InternableString.cs
@@ -43,7 +43,7 @@ internal Enumerator(scoped ref InternableString str)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public ref readonly char Current
+            public readonly ref readonly char Current
             {
                 get
                 {
@@ -178,7 +178,7 @@ public Enumerator GetEnumerator()
         /// </summary>
         /// <param name="other">Another string.</param>
         /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
-        public bool Equals(string other)
+        public readonly bool Equals(string other)
         {
             if (other.Length != Length)
             {
@@ -210,7 +210,7 @@ public bool Equals(string other)
         /// System.String in which case the original string is returned.
         /// </summary>
         /// <returns>The string.</returns>
-        public unsafe string ExpensiveConvertToString()
+        public readonly unsafe string ExpensiveConvertToString()
         {
             if (Length == 0)
             {
@@ -268,7 +268,7 @@ public unsafe string ExpensiveConvertToString()
 
                 // The invariant that Length is the sum of span lengths is critical in this unsafe method.
                 // Violating it may lead to memory corruption and, since this code tends to run under a lock,
-                // to hangs caused by the lock getting orphaned. Attempt to detect that and throw now, 
+                // to hangs caused by the lock getting orphaned. Attempt to detect that and throw now,
                 // before the corruption causes further problems.
                 if (destPtr != resultPtr + Length)
                 {
@@ -283,7 +283,7 @@ public unsafe string ExpensiveConvertToString()
         /// </summary>
         /// <param name="str">The string to compare to.</param>
         /// <returns>True is this instance wraps the given string.</returns>
-        public bool ReferenceEquals(string str)
+        public readonly bool ReferenceEquals(string str)
         {
             if (_inlineSpan.Length == Length)
             {
@@ -317,7 +317,7 @@ public override string ToString()
         /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for
         /// a given string regardless of how it's split into spans (e.g. { "AB" } and { "A", "B" } have the same hash code).
         /// </remarks>
-        public override unsafe int GetHashCode()
+        public override readonly unsafe int GetHashCode()
         {
             uint hash = (5381 << 16) + 5381;
             bool hashedOddNumberOfCharacters = false;
diff --git a/src/StringTools/SpanBasedStringBuilder.Simple.cs b/src/StringTools/SpanBasedStringBuilder.Simple.cs
index 6090363a24f..a9c88b590c9 100644
--- a/src/StringTools/SpanBasedStringBuilder.Simple.cs
+++ b/src/StringTools/SpanBasedStringBuilder.Simple.cs
@@ -35,7 +35,7 @@ public Enumerator(StringBuilder builder)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public char Current => _builder[_charIndex];
+            public readonly char Current => _builder[_charIndex];
 
             /// <summary>
             /// Moves to the next character.
diff --git a/src/Tasks.UnitTests/.editorconfig b/src/Tasks.UnitTests/.editorconfig
new file mode 100644
index 00000000000..a618acbc288
--- /dev/null
+++ b/src/Tasks.UnitTests/.editorconfig
@@ -0,0 +1,3 @@
+# Files that have inline expected results that include trailing whitespace
+[RoslynCodeTaskFactory_Tests.cs]
+trim_trailing_whitespace = false
diff --git a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
index 74fa0155f91..49a843cbd54 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
@@ -187,15 +187,15 @@ public void BadAppconfigNewVersion()
         /// - An app.config was passed in that promotes UnifyMe version from 1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        /// -Version 2.0.0.0 of UnifyMe is in the Black List
+        /// -Version 2.0.0.0 of UnifyMe is in the Deny List
         /// Expected:
         /// - There should be a warning indicating that DependsOnUnified has a dependency UnifyMe 2.0.0.0 which is not in a TargetFrameworkSubset.
         /// - There will be no unified message.
         /// Rationale:
-        /// Strongly named dependencies should unify according to the bindingRedirects in the app.config, if the unified version is in the black list it should be removed and warned.
+        /// Strongly named dependencies should unify according to the bindingRedirects in the app.config, if the unified version is in the deny list it should be removed and warned.
         /// </summary>
         [Fact]
-        public void ExistsPromotedDependencyInTheBlackList()
+        public void ExistsPromotedDependencyInTheDenyList()
         {
             string implicitRedistListContents =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index d8a3e63f4e9..9caae9580dd 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -11,13 +12,14 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.UnitTests.Shared;
+using Microsoft.Build.Tasks.AssemblyDependency;
 using Microsoft.Build.Utilities;
 using Microsoft.Win32;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
 using Xunit.NetCore.Extensions;
+using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 
 #nullable disable
@@ -71,7 +73,7 @@ public sealed class Miscellaneous : ResolveAssemblyReferenceTestFixture
             "</FileList >";
 
         /// <summary>
-        /// The contents of a subsetFile which only contain the Microsoft.Build.Engine assembly in the white list
+        /// The contents of a subsetFile which only contain the Microsoft.Build.Engine assembly in the allow list
         /// </summary>
         private string _engineOnlySubset =
             "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -79,7 +81,7 @@ public sealed class Miscellaneous : ResolveAssemblyReferenceTestFixture
             "</FileList >";
 
         /// <summary>
-        /// The contents of a subsetFile which only contain the System.Xml assembly in the white list
+        /// The contents of a subsetFile which only contain the System.Xml assembly in the allow list
         /// </summary>
         private string _xmlOnlySubset =
             "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -87,7 +89,7 @@ public sealed class Miscellaneous : ResolveAssemblyReferenceTestFixture
             "</FileList >";
 
         /// <summary>
-        /// The contents of a subsetFile which contain both the Microsoft.Build.Engine and System.Xml assemblies in the white list
+        /// The contents of a subsetFile which contain both the Microsoft.Build.Engine and System.Xml assemblies in the allow list
         /// </summary>
         private string _engineAndXmlSubset =
             "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -5564,39 +5566,39 @@ public void GetRedistListPathsFromDisk_ThrowsArgumentNullException()
         }
 
         /// <summary>
-        /// Test the case where the redist list is empty and we pass in an empty set of white lists
-        /// We should return null as there is no point generating a white list if there is nothing to subtract from.
-        /// ResolveAssemblyReference will see this as null and log a warning indicating no redist assemblies were found therefore no black list could be
+        /// Test the case where the redist list is empty and we pass in an empty set of allow lists
+        /// We should return null as there is no point generating an allow list if there is nothing to subtract from.
+        /// ResolveAssemblyReference will see this as null and log a warning indicating no redist assemblies were found therefore no deny list could be
         /// generated
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListEmptyAssemblyInfoNoRedistAssemblies()
+        public void RedistListGenerateDenyListEmptyAssemblyInfoNoRedistAssemblies()
         {
             RedistList redistList = RedistList.GetRedistList(Array.Empty<AssemblyTableInfo>());
-            List<Exception> whiteListErrors = new List<Exception>();
-            List<string> whiteListErrorFileNames = new List<string>();
-            Dictionary<string, string> blackList = redistList.GenerateBlackList(Array.Empty<AssemblyTableInfo>(), whiteListErrors, whiteListErrorFileNames);
-            Assert.Null(blackList); // "Should return null if the AssemblyTableInfo is empty and the redist list is empty"
+            List<Exception> allowListErrors = new List<Exception>();
+            List<string> allowListErrorFileNames = new List<string>();
+            Dictionary<string, string> denyList = redistList.GenerateDenyList(Array.Empty<AssemblyTableInfo>(), allowListErrors, allowListErrorFileNames);
+            Assert.Null(denyList); // "Should return null if the AssemblyTableInfo is empty and the redist list is empty"
         }
 
         /// <summary>
-        /// Verify that when we go to generate a black list but there were no subset list files passed in that we get NO black list generated as there is nothing to subtract.
+        /// Verify that when we go to generate a deny list but there were no subset list files passed in that we get NO deny list generated as there is nothing to subtract.
         /// Nothing meaning, we don't have any matching subset list files to say there are no good files.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListEmptyAssemblyInfoWithRedistAssemblies()
+        public void RedistListGenerateDenyListEmptyAssemblyInfoWithRedistAssemblies()
         {
             string redistFile = CreateGenericRedistList();
             try
             {
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(Array.Empty<AssemblyTableInfo>(), whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(Array.Empty<AssemblyTableInfo>(), allowListErrors, allowListErrorFileNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
             }
             finally
             {
@@ -5605,32 +5607,32 @@ public void RedistListGenerateBlackListEmptyAssemblyInfoWithRedistAssemblies()
         }
 
         /// <summary>
-        /// Test the case where the subset lists cannot be read. The expectation is that the black list will be empty as we have no proper white lists to compare it to.
+        /// Test the case where the subset lists cannot be read. The expectation is that the deny list will be empty as we have no proper allow lists to compare it to.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListNotFoundSubsetFiles()
+        public void RedistListGenerateDenyListNotFoundSubsetFiles()
         {
             string redistFile = CreateGenericRedistList();
             try
             {
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
 
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(
                                                                    new AssemblyTableInfo[]
                                                                                          {
                                                                                            new AssemblyTableInfo("c:\\RandomDirectory.xml", "TargetFrameworkDirectory"),
                                                                                            new AssemblyTableInfo("c:\\AnotherRandomDirectory.xml", "TargetFrameworkDirectory")
                                                                                           },
-                                                                                          whiteListErrors,
-                                                                                          whiteListErrorFileNames);
+                                                                                          allowListErrors,
+                                                                                          allowListErrorFileNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Equal(2, whiteListErrors.Count); // "Expected there to be two errors in the whiteListErrors, one for each missing file"
-                Assert.Equal(2, whiteListErrorFileNames.Count); // "Expected there to be two errors in the whiteListErrorFileNames, one for each missing file"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Equal(2, allowListErrors.Count); // "Expected there to be two errors in the allowListErrors, one for each missing file"
+                Assert.Equal(2, allowListErrorFileNames.Count); // "Expected there to be two errors in the allowListErrorFileNames, one for each missing file"
             }
             finally
             {
@@ -5640,10 +5642,10 @@ public void RedistListGenerateBlackListNotFoundSubsetFiles()
 
         /// <summary>
         /// Test the case where there is random goo in the subsetList file. Expect the file to not be read in and a warning indicating the file was skipped due to a read error.
-        /// This should also cause the white list to be empty as the badly formatted file was the only whitelist subset file.
+        /// This should also cause the allow list to be empty as the badly formatted file was the only allowlist subset file.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGarbageSubsetListFiles()
+        public void RedistListGenerateDenyListGarbageSubsetListFiles()
         {
             string redistFile = CreateGenericRedistList();
             string garbageSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -5656,14 +5658,14 @@ public void RedistListGenerateBlackListGarbageSubsetListFiles()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(garbageSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Single(whiteListErrors); // "Expected there to be an error in the whiteListErrors"
-                Assert.Single(whiteListErrorFileNames); // "Expected there to be an error in the whiteListErrorFileNames"
-                Assert.DoesNotContain("MSB3257", ((Exception)whiteListErrors[0]).Message); // "Expect to not have the null redist warning"
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Single(allowListErrors); // "Expected there to be an error in the allowListErrors"
+                Assert.Single(allowListErrorFileNames); // "Expected there to be an error in the allowListErrorFileNames"
+                Assert.DoesNotContain("MSB3257", ((Exception)allowListErrors[0]).Message); // "Expect to not have the null redist warning"
             }
             finally
             {
@@ -5679,7 +5681,7 @@ public void RedistListGenerateBlackListGarbageSubsetListFiles()
         ///
         /// Expected:
         ///     Expect a warning that a redist list or subset list has no redist name.
-        ///     There should be no black list generated as no sub set lists were read in.
+        ///     There should be no deny list generated as no sub set lists were read in.
         ///
         /// Rational:
         ///     If we have no redist name to compare to the redist list redist name we cannot subtract the lists correctly.
@@ -5701,16 +5703,16 @@ public void RedistListNoSubsetListName()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
-
-                // If the names do not match then i expect there to be no black list items
-                Assert.Empty(blackList); // "Expected to have no assembly in the black list"
-                Assert.Single(whiteListErrors); // "Expected there to be one error in the whiteListErrors"
-                Assert.Single(whiteListErrorFileNames); // "Expected there to be one error in the whiteListErrorFileNames"
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
+
+                // If the names do not match then i expect there to be no deny list items
+                Assert.Empty(denyList); // "Expected to have no assembly in the deny list"
+                Assert.Single(allowListErrors); // "Expected there to be one error in the allowListErrors"
+                Assert.Single(allowListErrorFileNames); // "Expected there to be one error in the allowListErrorFileNames"
                 string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.NoSubSetRedistListName", subsetFile);
-                Assert.Contains(message, ((Exception)whiteListErrors[0]).Message); // "Expected assertion to contain correct error code"
+                Assert.Contains(message, ((Exception)allowListErrors[0]).Message); // "Expected assertion to contain correct error code"
             }
             finally
             {
@@ -5725,7 +5727,7 @@ public void RedistListNoSubsetListName()
         ///     Subset list which has a redist name and entries
         ///
         /// Expected:
-        ///     Expect no black list to be generated and no warnings to be emitted
+        ///     Expect no deny list to be generated and no warnings to be emitted
         ///
         /// Rational:
         ///     Since the redist list name is null or empty we have no way of matching any subset list up to it.
@@ -5754,14 +5756,14 @@ public void RedistListNullkRedistListName()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // If the names do not match then i expect there to be no black list items
-                Assert.Empty(blackList); // "Expected to have no assembly in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no errors in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no errors in the whiteListErrorFileNames"
+                // If the names do not match then i expect there to be no deny list items
+                Assert.Empty(denyList); // "Expected to have no assembly in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no errors in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no errors in the allowListErrorFileNames"
             }
             finally
             {
@@ -5776,11 +5778,11 @@ public void RedistListNullkRedistListName()
         ///     Subset list which has entries but has a different redist name than the redist list
         ///
         /// Expected:
-        ///     There should be no black list generated as no sub set lists with matching names were found.
+        ///     There should be no deny list generated as no sub set lists with matching names were found.
         ///
         /// Rational:
         ///     If the redist name does not match then that subset list should not be subtracted from the redist list.
-        ///     We only add assemblies to the black list if there is a corosponding white list even if it is empty to inform us what assemblies are good and which are not.
+        ///     We only add assemblies to the deny list if there is a corosponding allow list even if it is empty to inform us what assemblies are good and which are not.
         /// </summary>
         [Fact]
         public void RedistListDifferentNameToSubSet()
@@ -5799,14 +5801,14 @@ public void RedistListDifferentNameToSubSet()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // If the names do not match then i expect there to be no black list items
-                Assert.Empty(blackList); // "Expected to have no assembly in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // If the names do not match then i expect there to be no deny list items
+                Assert.Empty(denyList); // "Expected to have no assembly in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -5817,7 +5819,7 @@ public void RedistListDifferentNameToSubSet()
 
         /// <summary>
         /// Test the case where the subset list has the same name as the redist list but it has no entries In this case
-        /// the black list should contain ALL redist list entries because there are no white list files to remove from the black list.
+        /// the deny list should contain ALL redist list entries because there are no allow list files to remove from the deny list.
         /// </summary>
         [Fact]
         public void RedistListEmptySubsetMatchingName()
@@ -5834,19 +5836,19 @@ public void RedistListEmptySubsetMatchingName()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // If the names do not match then i expect there to be no black list items
-                Assert.Equal(2, blackList.Count); // "Expected to have two assembly in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // If the names do not match then i expect there to be no deny list items
+                Assert.Equal(2, denyList.Count); // "Expected to have two assembly in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
 
-                ArrayList whiteListErrors2 = new ArrayList();
-                ArrayList whiteListErrorFileNames2 = new ArrayList();
-                Dictionary<string, string> blackList2 = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
-                Assert.Same(blackList, blackList2);
+                ArrayList allowListErrors2 = new ArrayList();
+                ArrayList allowListErrorFileNames2 = new ArrayList();
+                Dictionary<string, string> denyList2 = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
+                Assert.Same(denyList, denyList2);
             }
             finally
             {
@@ -5857,8 +5859,8 @@ public void RedistListEmptySubsetMatchingName()
 
         /// <summary>
         /// Test the case where, no redist assemblies are read in.
-        /// In this case no blacklist can be generated.
-        /// We should get a warning informing us that we could not create a black list.
+        /// In this case no denylist can be generated.
+        /// We should get a warning informing us that we could not create a deny list.
         /// </summary>
         [Fact]
         public void RedistListNoAssembliesinRedistList()
@@ -5906,10 +5908,10 @@ public void RedistListNoAssembliesinRedistList()
 
         /// <summary>
         /// Test the case where the subset list is a subset of the redist list. Make sure that
-        /// even though there are two files in the redist list that only one shows up in the black list.
+        /// even though there are two files in the redist list that only one shows up in the deny list.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
+        public void RedistListGenerateDenyListGoodListsSubsetIsSubsetOfRedist()
         {
             string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -5920,14 +5922,14 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(goodSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                Assert.Single(blackList); // "Expected to have one assembly in the black list"
-                Assert.True(blackList.ContainsKey("System.Xml, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b03f5f7f11d50a3a")); // "Expected System.xml to be in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                Assert.Single(denyList); // "Expected to have one assembly in the deny list"
+                Assert.True(denyList.ContainsKey("System.Xml, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b03f5f7f11d50a3a")); // "Expected System.xml to be in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -5937,12 +5939,12 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
         }
 
         /// <summary>
-        /// Test the case where we generate a black list based on a set of subset file paths, and then ask for
-        /// another black list using the same file paths. We expect to get the exact same Dictionary out
+        /// Test the case where we generate a deny list based on a set of subset file paths, and then ask for
+        /// another deny list using the same file paths. We expect to get the exact same Dictionary out
         /// as it should be pulled from the cache.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListVerifyBlackListCache()
+        public void RedistListGenerateDenyListVerifyDenyListCache()
         {
             string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -5953,20 +5955,20 @@ public void RedistListGenerateBlackListVerifyBlackListCache()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(goodSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Single(blackList); // "Expected to have one assembly in the black list"
-                Assert.True(blackList.ContainsKey("System.Xml, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b03f5f7f11d50a3a")); // "Expected System.xml to be in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Single(denyList); // "Expected to have one assembly in the deny list"
+                Assert.True(denyList.ContainsKey("System.Xml, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b03f5f7f11d50a3a")); // "Expected System.xml to be in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
 
-                List<Exception> whiteListErrors2 = new List<Exception>();
-                List<string> whiteListErrorFileNames2 = new List<string>();
-                Dictionary<string, string> blackList2 = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors2, whiteListErrorFileNames2);
-                Assert.Same(blackList, blackList2);
+                List<Exception> allowListErrors2 = new List<Exception>();
+                List<string> allowListErrorFileNames2 = new List<string>();
+                Dictionary<string, string> denyList2 = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors2, allowListErrorFileNames2);
+                Assert.Same(denyList, denyList2);
             }
             finally
             {
@@ -5976,14 +5978,14 @@ public void RedistListGenerateBlackListVerifyBlackListCache()
         }
 
         /// <summary>
-        /// Test the case where the white list and the redist list are identical
-        /// In this case the black list should be empty.
+        /// Test the case where the allow list and the redist list are identical
+        /// In this case the deny list should be empty.
         ///
         /// We are also in a way testing the combining of subset files as we read in one assembly from two
         /// different subset lists while the redist list already contains both assemblies.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGoodListsSubsetIsSameAsRedistList()
+        public void RedistListGenerateDenyListGoodListsSubsetIsSameAsRedistList()
         {
             string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -5998,13 +6000,13 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSameAsRedistList()
                 AssemblyTableInfo subsetListInfo2 = new AssemblyTableInfo(goodSubsetFile2, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
 
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo, subsetListInfo2 }, whiteListErrors, whiteListErrorFileNames);
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo, subsetListInfo2 }, allowListErrors, allowListErrorFileNames);
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -6014,13 +6016,13 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSameAsRedistList()
         }
 
         /// <summary>
-        /// Test the case where the white list is a superset of the redist list.
-        /// This means there are more assemblies in the white list than in the black list.
+        /// Test the case where the allow list is a superset of the redist list.
+        /// This means there are more assemblies in the allow list than in the deny list.
         ///
-        /// The black list should be empty.
+        /// The deny list should be empty.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGoodListsSubsetIsSuperSet()
+        public void RedistListGenerateDenyListGoodListsSubsetIsSuperSet()
         {
             string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -6037,14 +6039,14 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSuperSet()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(goodSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -6058,7 +6060,7 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSuperSet()
         /// list are case sensitive or not, they should not be case sensitive.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGoodListsCheckCaseInsensitive()
+        public void RedistListGenerateDenyListGoodListsCheckCaseInsensitive()
         {
             string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -6069,14 +6071,14 @@ public void RedistListGenerateBlackListGoodListsCheckCaseInsensitive()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(goodSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -6086,11 +6088,11 @@ public void RedistListGenerateBlackListGoodListsCheckCaseInsensitive()
         }
 
         /// <summary>
-        /// Verify that when we go to generate a black list but there were no subset list files passed in that we get NO black list generated as there is nothing to subtract.
+        /// Verify that when we go to generate a deny list but there were no subset list files passed in that we get NO deny list generated as there is nothing to subtract.
         /// Nothing meaning, we don't have any matching subset list files to say there are no good files.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGoodListsMultipleIdenticalAssembliesInRedistList()
+        public void RedistListGenerateDenyListGoodListsMultipleIdenticalAssembliesInRedistList()
         {
             string redistFile = FileUtilities.GetTemporaryFileName();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -6110,14 +6112,14 @@ public void RedistListGenerateBlackListGoodListsMultipleIdenticalAssembliesInRed
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(goodSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFilesNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFilesNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFilesNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFilesNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFilesNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFilesNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -6312,10 +6314,10 @@ public void IgnoreDefaultInstalledAssemblyTables()
         }
 
         /// <summary>
-        /// A null black list should be the same as an empty one.
+        /// A null deny list should be the same as an empty one.
         /// </summary>
         [Fact]
-        public void ReferenceTableNullBlackList()
+        public void ReferenceTableNullDenyList()
         {
             TaskLoggingHelper log = new TaskLoggingHelper(new ResolveAssemblyReference());
             ReferenceTable referenceTable = MakeEmptyReferenceTable(log);
@@ -6337,10 +6339,10 @@ public void ReferenceTableNullBlackList()
         }
 
         /// <summary>
-        /// Test the case where the blacklist is empty.
+        /// Test the case where the denylist is empty.
         /// </summary>
         [Fact]
-        public void ReferenceTableEmptyBlackList()
+        public void ReferenceTableEmptyDenyList()
         {
             TaskLoggingHelper log = new TaskLoggingHelper(new ResolveAssemblyReference());
             ReferenceTable referenceTable = MakeEmptyReferenceTable(log);
@@ -6362,10 +6364,10 @@ public void ReferenceTableEmptyBlackList()
         }
 
         /// <summary>
-        /// Verify the case where there are primary references in the reference table which are also in the black list
+        /// Verify the case where there are primary references in the reference table which are also in the deny list
         /// </summary>
         [Fact]
-        public void ReferenceTablePrimaryItemInBlackList()
+        public void ReferenceTablePrimaryItemInDenyList()
         {
             MockEngine mockEngine = new MockEngine(_output);
             ResolveAssemblyReference rar = new ResolveAssemblyReference();
@@ -6383,12 +6385,12 @@ public void ReferenceTablePrimaryItemInBlackList()
             table.Add(engineAssemblyName, reference);
             table.Add(xmlAssemblyName, new Reference(isWinMDFile, fileExists, getRuntimeVersion));
 
-            var blackList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            blackList[engineAssemblyName.FullName] = null;
+            var denyList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            denyList[engineAssemblyName.FullName] = null;
             string[] targetFrameworks = new string[] { "Client", "Web" };
             string subSetName = ResolveAssemblyReference.GenerateSubSetName(targetFrameworks, null);
 
-            referenceTable.MarkReferencesForExclusion(blackList);
+            referenceTable.MarkReferencesForExclusion(denyList);
             referenceTable.RemoveReferencesMarkedForExclusion(false, subSetName);
 
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
@@ -6401,10 +6403,10 @@ public void ReferenceTablePrimaryItemInBlackList()
         }
 
         /// <summary>
-        /// Verify the case where there are primary references in the reference table which are also in the black list
+        /// Verify the case where there are primary references in the reference table which are also in the deny list
         /// </summary>
         [Fact]
-        public void ReferenceTablePrimaryItemInBlackListSpecificVersionTrue()
+        public void ReferenceTablePrimaryItemInDenyListSpecificVersionTrue()
         {
             MockEngine mockEngine = new MockEngine(_output);
             ResolveAssemblyReference rar = new ResolveAssemblyReference();
@@ -6423,11 +6425,11 @@ public void ReferenceTablePrimaryItemInBlackListSpecificVersionTrue()
             table.Add(engineAssemblyName, reference);
             table.Add(xmlAssemblyName, new Reference(isWinMDFile, fileExists, getRuntimeVersion));
 
-            var blackList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            blackList[engineAssemblyName.FullName] = null;
+            var denyList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            denyList[engineAssemblyName.FullName] = null;
             string[] targetFrameworks = new string[] { "Client", "Web" };
             string subSetName = ResolveAssemblyReference.GenerateSubSetName(targetFrameworks, null);
-            referenceTable.MarkReferencesForExclusion(blackList);
+            referenceTable.MarkReferencesForExclusion(denyList);
             referenceTable.RemoveReferencesMarkedForExclusion(false, subSetName);
 
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
@@ -6481,7 +6483,7 @@ public void TestGenerateFrameworkName()
         /// Verify the case where we just want to remove the references before conflict resolution and not print out the warning.
         /// </summary>
         [Fact]
-        public void ReferenceTablePrimaryItemInBlackListRemoveOnlyNoWarn()
+        public void ReferenceTablePrimaryItemInDenyListRemoveOnlyNoWarn()
         {
             MockEngine mockEngine = new MockEngine(_output);
             ResolveAssemblyReference rar = new ResolveAssemblyReference();
@@ -6499,9 +6501,9 @@ public void ReferenceTablePrimaryItemInBlackListRemoveOnlyNoWarn()
             table.Add(engineAssemblyName, reference);
             table.Add(xmlAssemblyName, new Reference(isWinMDFile, fileExists, getRuntimeVersion));
 
-            var blackList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            blackList[engineAssemblyName.FullName] = null;
-            referenceTable.MarkReferencesForExclusion(blackList);
+            var denyList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            denyList[engineAssemblyName.FullName] = null;
+            referenceTable.MarkReferencesForExclusion(denyList);
             referenceTable.RemoveReferencesMarkedForExclusion(true, String.Empty);
 
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
@@ -6515,16 +6517,16 @@ public void ReferenceTablePrimaryItemInBlackListRemoveOnlyNoWarn()
         }
 
         /// <summary>
-        /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference : sqlDependencyReference is in black list
+        /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference : sqlDependencyReference is in deny list
         /// expect to see one dependency warning message
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackList()
+        public void ReferenceTableDependentItemsInDenyList()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6548,7 +6550,7 @@ public void ReferenceTableDependentItemsInBlackList()
 
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
@@ -6557,17 +6559,17 @@ public void ReferenceTableDependentItemsInBlackList()
 
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
-        /// and enginePrimary->sqlDependencyReference: sqlDependencyReference is in black list
+        /// and enginePrimary->sqlDependencyReference: sqlDependencyReference is in deny list
         /// and systemxml->enginePrimary
         /// expect to see one dependency warning message
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackList2()
+        public void ReferenceTableDependentItemsInDenyList2()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6592,7 +6594,7 @@ public void ReferenceTableDependentItemsInBlackList2()
 
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
@@ -6603,12 +6605,12 @@ public void ReferenceTableDependentItemsInBlackList2()
         /// Testing case  enginePrimary->XmlPrimary with XMLPrimary in the BL
         /// </summary>
         [Fact]
-        public void ReferenceTablePrimaryToPrimaryDependencyWithOneInBlackList()
+        public void ReferenceTablePrimaryToPrimaryDependencyWithOneInDenyList()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension xmlAssemblyName = new AssemblyNameExtension("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             Reference enginePrimaryReference = new Reference(isWinMDFile, fileExists, getRuntimeVersion);
@@ -6628,7 +6630,7 @@ public void ReferenceTablePrimaryToPrimaryDependencyWithOneInBlackList()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, null, null, xmlAssemblyName, enginePrimaryReference, null, null, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { xmlAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { xmlAssemblyName }, out denyList);
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, xmlAssemblyName.FullName, subsetName);
             string warningMessage2 = rar.Log.FormatResourceString("ResolveAssemblyReference.FailedToResolveReferenceBecausePrimaryAssemblyInExclusionList", taskItem2.ItemSpec, subsetName);
@@ -6644,12 +6646,12 @@ public void ReferenceTablePrimaryToPrimaryDependencyWithOneInBlackList()
         /// Testing case  enginePrimary->XmlPrimary->dataDependency with dataDependency in the BL
         /// </summary>
         [Fact]
-        public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
+        public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInDenyList()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension xmlAssemblyName = new AssemblyNameExtension("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6674,7 +6676,7 @@ public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, null, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, null, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { dataAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { dataAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, dataAssemblyName.FullName, subsetName);
@@ -6690,16 +6692,16 @@ public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
 
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
-        /// and xmlPrimary->sqlDependencyReference: sqlDependencyReference is in black list
+        /// and xmlPrimary->sqlDependencyReference: sqlDependencyReference is in deny list
         /// expect to see one dependency warning message
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackList3()
+        public void ReferenceTableDependentItemsInDenyList3()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6726,7 +6728,7 @@ public void ReferenceTableDependentItemsInBlackList3()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
@@ -6736,11 +6738,11 @@ public void ReferenceTableDependentItemsInBlackList3()
 
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
-        /// and xmlPrimary->dataDependencyReference: sqlDependencyReference is in black list
+        /// and xmlPrimary->dataDependencyReference: sqlDependencyReference is in deny list
         /// expect to see one dependency warning message
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackList4()
+        public void ReferenceTableDependentItemsInDenyList4()
         {
             ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null,
 #if FEATURE_WIN32_REGISTRY
@@ -6749,7 +6751,7 @@ public void ReferenceTableDependentItemsInBlackList4()
                 null, null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6776,7 +6778,7 @@ public void ReferenceTableDependentItemsInBlackList4()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
@@ -6788,16 +6790,16 @@ public void ReferenceTableDependentItemsInBlackList4()
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
         /// enginePrimary -> dataDependencyReference
         /// xmlPrimaryReference ->DataDependency
-        /// dataDependencyReference and sqlDependencyReference are in black list
+        /// dataDependencyReference and sqlDependencyReference are in deny list
         /// expect to see two dependency warning messages in the enginePrimaryCase and one in the xmlPrimarycase
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackList5()
+        public void ReferenceTableDependentItemsInDenyList5()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6824,7 +6826,7 @@ public void ReferenceTableDependentItemsInBlackList5()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
@@ -6851,17 +6853,17 @@ public void ReferenceTableDependentItemsInBlackList5()
         /// Testing case
         /// enginePrimary -> dataDependencyReference   also enginePrimary->sqlDependencyReference   specific version = true on the primary
         /// xmlPrimaryReference ->dataDependencyReference specific version = false on the primary
-        /// dataDependencyReference and sqlDependencyReference is in the black list.
+        /// dataDependencyReference and sqlDependencyReference is in the deny list.
         /// Expect to see one dependency warning messages xmlPrimarycase and no message for enginePrimary
         /// Also expect to resolve all files except for xmlPrimaryReference
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackListPrimaryWithSpecificVersion()
+        public void ReferenceTableDependentItemsInDenyListPrimaryWithSpecificVersion()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6892,7 +6894,7 @@ public void ReferenceTableDependentItemsInBlackListPrimaryWithSpecificVersion()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem2.ItemSpec, dataAssemblyName.FullName, subsetName);
@@ -6929,7 +6931,7 @@ private static ReferenceTable MakeEmptyReferenceTable(TaskLoggingHelper log)
         }
 
         /// <summary>
-        /// Verify the correct references are still in the references table and that references which are in the black list are not in the references table
+        /// Verify the correct references are still in the references table and that references which are in the deny list are not in the references table
         /// Also verify any expected warning messages are seen in the log.
         /// </summary>
         private static void VerifyReferenceTable(ReferenceTable referenceTable, MockEngine mockEngine, AssemblyNameExtension engineAssemblyName, AssemblyNameExtension dataAssemblyName, AssemblyNameExtension sqlclientAssemblyName, AssemblyNameExtension xmlAssemblyName, string[] warningMessages)
@@ -7086,7 +7088,7 @@ private static void AddReferencesToReferenceTable(ReferenceTable referenceTable,
         }
 
         /// <summary>
-        /// Initialize the mock engine so we can look at the warning messages, also put the assembly name which is to be in the black list into the black list.
+        /// Initialize the mock engine so we can look at the warning messages, also put the assembly name which is to be in the deny list into the deny list.
         /// Call remove references so that we can then validate the results.
         /// </summary>
         private void InitializeMockEngine(out ReferenceTable referenceTable, out MockEngine mockEngine, out ResolveAssemblyReference rar)
@@ -7099,17 +7101,17 @@ private void InitializeMockEngine(out ReferenceTable referenceTable, out MockEng
         }
 
         /// <summary>
-        /// Initialize the black list and use it to remove references from the reference table
+        /// Initialize the deny list and use it to remove references from the reference table
         /// </summary>
-        private void InitializeExclusionList(ReferenceTable referenceTable, AssemblyNameExtension[] assembliesForBlackList, out Dictionary<string, string> blackList)
+        private void InitializeExclusionList(ReferenceTable referenceTable, AssemblyNameExtension[] assembliesForDenyList, out Dictionary<string, string> denyList)
         {
-            blackList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            foreach (AssemblyNameExtension assemblyName in assembliesForBlackList)
+            denyList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            foreach (AssemblyNameExtension assemblyName in assembliesForDenyList)
             {
-                blackList[assemblyName.FullName] = null;
+                denyList[assemblyName.FullName] = null;
             }
 
-            referenceTable.MarkReferencesForExclusion(blackList);
+            referenceTable.MarkReferencesForExclusion(denyList);
             referenceTable.RemoveReferencesMarkedForExclusion(false, "Client");
         }
 
@@ -7342,7 +7344,7 @@ public void FakeSubsetListPathsNoAdditionalSubsets()
 
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
-        /// black list is not used.
+        /// deny list is not used.
         /// </summary>
         [Fact]
         public void ResolveAssemblyReferenceVerifyFullClientName()
@@ -7375,7 +7377,7 @@ public void ResolveAssemblyReferenceVerifyFullClientName()
 
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
-        /// black list is not used.
+        /// deny list is not used.
         /// </summary>
         [Fact]
         public void ResolveAssemblyReferenceVerifyFullClientNameWithSubsetTables()
@@ -7410,7 +7412,7 @@ public void ResolveAssemblyReferenceVerifyFullClientNameWithSubsetTables()
 
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
-        /// black list is not used.
+        /// deny list is not used.
         /// </summary>
         [Fact]
         public void ResolveAssemblyReferenceVerifyFullClientNameNoTablesPassedIn()
@@ -7443,7 +7445,7 @@ public void ResolveAssemblyReferenceVerifyFullClientNameNoTablesPassedIn()
         }
 
         /// <summary>
-        /// Verify the correct references are still in the references table and that references which are in the black list are not in the references table
+        /// Verify the correct references are still in the references table and that references which are in the deny list are not in the references table
         /// Also verify any expected warning messages are seen in the log.
         /// </summary>
         private static void VerifyReferenceTable(ReferenceTable referenceTable, MockEngine mockEngine, AssemblyNameExtension engineAssemblyName, AssemblyNameExtension dataAssemblyName, AssemblyNameExtension sqlclientAssemblyName, AssemblyNameExtension xmlAssemblyName, string warningMessage, string warningMessage2)
@@ -8238,7 +8240,7 @@ public void VerifyAssemblyInRedistListDiffSimpleName()
         }
 
         /// <summary>
-        /// Verify when a p2p (assemblies in the AssemblyFiles property) are passed to rar that we properly un-resolve them if they depend on references which are in the black list for the profile.
+        /// Verify when a p2p (assemblies in the AssemblyFiles property) are passed to rar that we properly un-resolve them if they depend on references which are in the deny list for the profile.
         /// </summary>
         [Fact]
         public void Verifyp2pAndProfile()
@@ -8286,7 +8288,7 @@ public void Verifyp2pAndProfile()
         }
 
         /// <summary>
-        /// Verify when a p2p (assemblies in the AssemblyFiles property) are passed to rar that we properly resolve them if they depend on references which are in the black list for the profile but have specific version set to true.
+        /// Verify when a p2p (assemblies in the AssemblyFiles property) are passed to rar that we properly resolve them if they depend on references which are in the deny list for the profile but have specific version set to true.
         /// </summary>
         [Fact]
         public void Verifyp2pAndProfile2()
@@ -8483,7 +8485,7 @@ public void VerifyAssemblyInGacButNotInProfileIsNotResolved()
         }
 
         /// <summary>
-        /// Make sure when reading in the full framework redist list or when reading in the white list xml files.
+        /// Make sure when reading in the full framework redist list or when reading in the allow list xml files.
         /// Errors in reading the file should be logged as warnings and no assemblies should be excluded.
         ///
         /// </summary>
@@ -8564,5 +8566,87 @@ private static void GenerateRedistAndProfileXmlLocations(string fullRedistConten
 
             File.WriteAllText(profileRedistList, profileListContents);
         }
+
+        [Fact]
+        public void SDKReferencesAreResolvedWithoutIO()
+        {
+            InitializeRARwithMockEngine(_output, out MockEngine mockEngine, out ResolveAssemblyReference rar);
+
+            string refPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
+
+            TaskItem item = new TaskItem(refPath);
+            item.SetMetadata("ExternallyResolved", "true");
+
+            item.SetMetadata("FrameworkReferenceName", "Microsoft.NETCore.App");
+            item.SetMetadata("FrameworkReferenceVersion", "8.0.0");
+
+            item.SetMetadata("AssemblyName", "System.Candy");
+            item.SetMetadata("AssemblyVersion", "8.1.2.3");
+            item.SetMetadata("PublicKeyToken", "b03f5f7f11d50a3a");
+
+            rar.Assemblies = new ITaskItem[] { item };
+            rar.SearchPaths = new string[]
+            {
+                "{CandidateAssemblyFiles}",
+                "{HintPathFromItem}",
+                "{TargetFrameworkDirectory}",
+                "{RawFileName}",
+            };
+            rar.WarnOrErrorOnTargetArchitectureMismatch = "Warning";
+
+            // Execute RAR and assert that we receive no I/O callbacks because the task gets what it needs from item metadata.
+            rar.Execute(
+                _ => throw new ShouldAssertException("Unexpected FileExists callback"),
+                directoryExists,
+                getDirectories,
+                _ => throw new ShouldAssertException("Unexpected GetAssemblyName callback"),
+                (string path, ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache, out AssemblyNameExtension[] dependencies, out string[] scatterFiles, out FrameworkNameVersioning frameworkName)
+                  => throw new ShouldAssertException("Unexpected GetAssemblyMetadata callback"),
+#if FEATURE_WIN32_REGISTRY
+                getRegistrySubKeyNames,
+                getRegistrySubKeyDefaultValue,
+#endif
+                _ => throw new ShouldAssertException("Unexpected GetLastWriteTime callback"),
+                _ => throw new ShouldAssertException("Unexpected GetAssemblyRuntimeVersion callback"),
+#if FEATURE_WIN32_REGISTRY
+                openBaseKey,
+#endif
+                checkIfAssemblyIsInGac,
+                isWinMDFile,
+                readMachineTypeFromPEHeader).ShouldBeTrue();
+
+            rar.ResolvedFiles.Length.ShouldBe(1);
+            rar.ResolvedFiles[0].ItemSpec.ShouldBe(refPath);
+            rar.ResolvedFiles[0].GetMetadata("FusionName").ShouldBe("System.Candy, Version=8.1.2.3, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
+
+            // The reference is not worth persisting in the per-instance cache.
+            rar._cache.IsDirty.ShouldBeFalse();
+        }
+
+        [Fact]
+        public void ManagedRuntimeVersionReaderSupportsWindowsRuntime()
+        {
+            // This is a prefix of a .winmd file built using the Universal Windows runtime component project in Visual Studio.
+            string windowsRuntimeAssemblyHeaderBase64Encoded =
+                "TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1v" +
+                "ZGUuDQ0KJAAAAAAAAABQRQAATAEDAFD4XWQAAAAAAAAAAOAAIiALATAAAAwAAAAGAAAAAAAAXioAAAAgAAAAQAAAAAAAEAAgAAAAAgAABAAAAAAAAAAGAAIAAAAAAACAAAAAAgAAAAAAAAMAYIUAABAA" +
+                "ABAAAAAAEAAAEAAAAAAAABAAAAAAAAAAAAAAAAkqAABPAAAAAEAAANADAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAwAAABwKQAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
+                "AAAAIAAACAAAAAAAAAAAAAAACCAAAEgAAAAAAAAAAAAAAC50ZXh0AAAAZAoAAAAgAAAADAAAAAIAAAAAAAAAAAAAAAAAACAAAGAucnNyYwAAANADAAAAQAAAAAQAAAAOAAAAAAAAAAAAAAAAAABAAABA" +
+                "LnJlbG9jAAAMAAAAAGAAAAACAAAAEgAAAAAAAAAAAAAAAAAAQAAAQgAAAAAAAAAAAAAAAAAAAAA9KgAAAAAAAEgAAAACAAUAWCAAABgJAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
+                "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4CKAEAAAoqQlNKQgEAAQAAAAAAJAAAAFdpbmRvd3NSdW50aW1lIDEuNDtDTFIgdjQuMC4zMDMxOQAAAAAABQCEAAAA+AIAACN+AAB8AwAAoAMAACNTdHJpbmdz" +
+                "AAAAABwHAAAIAAAAI1VTACQHAAAQAAAAI0dVSUQAAAA0BwAA5AEAACNCbG9iAAAAAAAAAAIAAAFHFwACCQAAAAD6ATMAFgAAAQAAABwAAAAEAAAAAwAAAAEAAAADAAAAFwAAABwAAAABAAAAAQAAAAMA" +
+                "AAAAAE0AAQAAAAAABgCWA9ACCgCWA9ACDgBlANcCBgDdATQDBgBbAjQDBgC4AAIDGwBUAwAABgD1AOoCBgCPAeoCBgBwAeoCBgBCAuoCBgD9AeoCBgAWAuoCBgAfAeoCBgBTAeoCBgDhABUDBgA6AX8C" +
+                "DgDBASgADgCAACgADgAMASgADgDBAigADgBfASgADgDMACgADgAxAigABgCPADQDDgCqACgADgCsASgACgCKANACAAAAAB8AAAAAAAEAAQAABRAAAQANAAUAAQABAAFBEAAGAA0ACQABAAIAoEAAAGMD" +
+                "DQAAAAEABABQIAAAAACGGPwCAQABAAAAAAADAIYY/AIBAAEAAAAAAAMA4QGZAgUAAQAAAAAAeQICABAAAwAQAAMADQAJAPwCAQAZALgCBQAhAPwCCQApAPwCAQAxAPwCDgBBAPwCFABJAPwCFABRAPwC" +
+                "FABZAPwCFABhAPwCFABpAPwCFABxAPwCFAB5APwCFACBAPwCGQCJAPwCFACRAPwCHgChAPwCJACxAPwCKgC5APwCKgDBAPwCAQDJAPwCAQDRAPwCLwDZAPwCPgAlAKMAqgEuABsA2AAuACMA4QAuACsA" +
+                "AAEuADMACQEuADsAIAEuAEMAIAEuAEsAIAEuAFMACQEuAFsAJgEuAGMAIAEuAGsAPgEuAHMAIAEuAHsASwFDAIMAAAFDAIsAmAFDAJMAoQFDAJsAoQFFAKMAqgFjAIMAAAFjAIsAmAFjAJMAoQFjAKsA" +
+                "qgFjAJsAoQGDAKsAqgGDALMArwGDAJMAoQGDALsAxAEDAAYABQAEgAAAAQAAAAAAAAAAAgAAAAANAAAABAACAAEAAAAAAAAARABxAAAAAAD/AP8A/wD/AAAAAABNAEQAAABWAAQAAAAAAAAAAAIAAAAA";
+
+            using MemoryStream memoryStream = new MemoryStream(Convert.FromBase64String(windowsRuntimeAssemblyHeaderBase64Encoded));
+            using BinaryReader reader = new BinaryReader(memoryStream);
+            string runtimeVersion = ManagedRuntimeVersionReader.GetRuntimeVersion(reader);
+
+            runtimeVersion.ShouldBe("WindowsRuntime 1.4;CLR v4.0.30319");
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
index 8c5291e2f7a..5607a413d21 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
@@ -20,6 +20,8 @@ public class ResolveAssemblyReferenceCacheSerialization : IDisposable
         private readonly string _rarCacheFile;
         private readonly TaskLoggingHelper _taskLoggingHelper;
 
+        private static readonly DateTime s_now = DateTime.Now;
+
         public ResolveAssemblyReferenceCacheSerialization()
         {
             var tempPath = Path.GetTempPath();
@@ -38,14 +40,22 @@ public void Dispose()
             }
         }
 
+        private static DateTime GetLastWriteTime(string path) => path switch
+        {
+            "path1" => s_now,
+            "path2" => s_now,
+            "dllName" => s_now.AddSeconds(-10),
+            _ => throw new ArgumentException(),
+        };
+
         [Fact]
         public void RoundTripEmptyState()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper, serializeEmptyState: true);
 
-            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
+            var deserialized = StateFileBase.DeserializeCache<SystemState>(_rarCacheFile, _taskLoggingHelper);
 
             deserialized.ShouldNotBeNull();
         }
@@ -55,7 +65,7 @@ public void CorrectFileVersion()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper, serializeEmptyState: true);
             using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
             {
                 cacheStream.Seek(0, SeekOrigin.Begin);
@@ -63,7 +73,7 @@ public void CorrectFileVersion()
                 cacheStream.Close();
             }
 
-            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
+            var deserialized = StateFileBase.DeserializeCache<SystemState>(_rarCacheFile, _taskLoggingHelper);
 
             deserialized.ShouldNotBeNull();
         }
@@ -73,7 +83,7 @@ public void WrongFileVersion()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper, serializeEmptyState: true);
             using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
             {
                 cacheStream.Seek(0, SeekOrigin.Begin);
@@ -81,7 +91,7 @@ public void WrongFileVersion()
                 cacheStream.Close();
             }
 
-            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
+            var deserialized = StateFileBase.DeserializeCache<SystemState>(_rarCacheFile, _taskLoggingHelper);
 
             deserialized.ShouldBeNull();
         }
@@ -90,21 +100,30 @@ public void WrongFileVersion()
         public void ValidateSerializationAndDeserialization()
         {
             Dictionary<string, SystemState.FileState> cache = new() {
-                    { "path1", new SystemState.FileState(DateTime.Now) },
-                    { "path2", new SystemState.FileState(DateTime.Now) { Assembly = new AssemblyNameExtension("hi") } },
-                    { "dllName", new SystemState.FileState(DateTime.Now.AddSeconds(-10)) {
+                    { "path1", new SystemState.FileState(GetLastWriteTime("path1")) },
+                    { "path2", new SystemState.FileState(GetLastWriteTime("path2")) { Assembly = new AssemblyNameExtension("hi") } },
+                    { "dllName", new SystemState.FileState(GetLastWriteTime("dllName")) {
                         Assembly = null,
                         RuntimeVersion = "v4.0.30319",
                         FrameworkNameAttribute = new FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
                         scatterFiles = new string[] { "first", "second" } } } };
             SystemState sysState = new();
+            sysState.SetGetLastWriteTime(GetLastWriteTime);
             sysState.instanceLocalFileStateCache = cache;
+
+            // Get all FileState entries to make sure they are marked as having been used.
+            _ = sysState.GetFileState("path1");
+            _ = sysState.GetFileState("path2");
+            _ = sysState.GetFileState("dllName");
+
+            sysState.HasStateToSave.ShouldBe(true);
+
             SystemState sysState2 = null;
             using (TestEnvironment env = TestEnvironment.Create())
             {
                 TransientTestFile file = env.CreateFile();
                 sysState.SerializeCache(file.Path, null);
-                sysState2 = SystemState.DeserializeCache(file.Path, null, typeof(SystemState)) as SystemState;
+                sysState2 = StateFileBase.DeserializeCache<SystemState>(file.Path, null);
             }
 
             Dictionary<string, SystemState.FileState> cache2 = sysState2.instanceLocalFileStateCache;
@@ -119,5 +138,58 @@ public void ValidateSerializationAndDeserialization()
             dll2.scatterFiles.Length.ShouldBe(dll.scatterFiles.Length);
             dll2.scatterFiles[1].ShouldBe(dll.scatterFiles[1]);
         }
+
+        [Fact]
+        public void OutgoingCacheIsSmallerThanIncomingCache()
+        {
+            Dictionary<string, SystemState.FileState> cache = new() {
+                    { "path1", new SystemState.FileState(GetLastWriteTime("path1")) },
+                    { "path2", new SystemState.FileState(GetLastWriteTime("path2")) } };
+            SystemState sysState = new();
+            sysState.SetGetLastWriteTime(GetLastWriteTime);
+            sysState.instanceLocalFileStateCache = cache;
+
+            // Get only the first FileState entry.
+            _ = sysState.GetFileState("path1");
+
+            sysState.HasStateToSave.ShouldBe(true);
+
+            SystemState sysState2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile();
+                sysState.SerializeCache(file.Path, null);
+                sysState2 = StateFileBase.DeserializeCache<SystemState>(file.Path, null);
+            }
+
+            // The new cache has only the entry that was actually used.
+            Dictionary<string, SystemState.FileState> cache2 = sysState2.instanceLocalFileStateCache;
+            cache2.Count.ShouldBe(1);
+            cache2.ShouldContainKey("path1");
+        }
+
+        [Fact]
+        public void OutgoingCacheIsEmpty()
+        {
+            Dictionary<string, SystemState.FileState> cache = new() {
+                    { "path1", new SystemState.FileState(GetLastWriteTime("path1")) },
+                    { "path2", new SystemState.FileState(GetLastWriteTime("path2")) } };
+            SystemState sysState = new();
+            sysState.SetGetLastWriteTime(GetLastWriteTime);
+            sysState.instanceLocalFileStateCache = cache;
+
+            sysState.HasStateToSave.ShouldBe(false);
+
+            SystemState sysState2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile();
+                sysState.SerializeCache(file.Path, null);
+                sysState2 = StateFileBase.DeserializeCache<SystemState>(file.Path, null);
+            }
+
+            // The new cache was not written to disk at all because none of the entries were actually used.
+            sysState2.ShouldBeNull();
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 748cce32307..6b025c4256d 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -2911,7 +2911,7 @@ private static DateTime GetLastWriteTime(string path)
         /// </summary>
         /// <param name="appConfigFile"></param>
         /// <param name="redirects"></param>
-        protected static string WriteAppConfig(string redirects)
+        protected static string WriteAppConfig(string redirects, string appConfigNameSuffix = null)
         {
             string appConfigContents =
             "<configuration>\n" +
@@ -2920,7 +2920,7 @@ protected static string WriteAppConfig(string redirects)
             "    </runtime>\n" +
             "</configuration>";
 
-            string appConfigFile = FileUtilities.GetTemporaryFileName();
+            string appConfigFile = FileUtilities.GetTemporaryFileName() + appConfigNameSuffix;
             File.WriteAllText(appConfigFile, appConfigContents);
             return appConfigFile;
         }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
index 1c67ddd8750..c4f0bd34510 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
@@ -38,13 +38,16 @@ public StronglyNamedDependencyAppConfig(ITestOutputHelper output) : base(output)
         /// - An app.config was passed in that promotes UnifyMe version from 1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
+        /// - The case is attempted on special unicode characters in path as well.
         /// Expected:
         /// - The resulting UnifyMe returned should be 2.0.0.0.
         /// Rationale:
         /// Strongly named dependencies should unify according to the bindingRedirects in the app.config.
         /// </summary>
-        [Fact]
-        public void Exists()
+        [Theory]
+        [InlineData(null)]
+        [InlineData("\uE025\uE026")]
+        public void Exists(string appConfigNameSuffix)
         {
             // Create the engine.
             MockEngine engine = new MockEngine(_output);
@@ -59,7 +62,8 @@ public void Exists()
                     "        <dependentAssembly>\n" +
                     "            <assemblyIdentity name='UnifyMe' PublicKeyToken='b77a5c561934e089' culture='neutral' />\n" +
                     "            <bindingRedirect oldVersion='1.0.0.0' newVersion='2.0.0.0' />\n" +
-                    "        </dependentAssembly>\n");
+                    "        </dependentAssembly>\n",
+                    appConfigNameSuffix);
 
             // Now, pass feed resolved primary references into ResolveAssemblyReference.
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -88,15 +92,15 @@ public void Exists()
         /// - An app.config was passed in that promotes UnifyMe version from 1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        /// -Version 2.0.0.0 of UnifyMe is in the Black List
+        /// -Version 2.0.0.0 of UnifyMe is in the Deny List
         /// Expected:
         /// - There should be a warning indicating that DependsOnUnified has a dependency UnifyMe 2.0.0.0 which is not in a TargetFrameworkSubset.
         /// - There will be no unified message.
         /// Rationale:
-        /// Strongly named dependencies should unify according to the bindingRedirects in the app.config, if the unified version is in the black list it should be removed and warned.
+        /// Strongly named dependencies should unify according to the bindingRedirects in the app.config, if the unified version is in the deny list it should be removed and warned.
         /// </summary>
         [Fact]
-        public void ExistsPromotedDependencyInTheBlackList()
+        public void ExistsPromotedDependencyInTheDenyList()
         {
             string engineOnlySubset =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
index a283f172b13..d971ece54a5 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
@@ -100,15 +100,15 @@ internal void ExistsImpl(RARSimulationMode rarSimulationMode = RARSimulationMode
         /// - The AutoUnify flag is set to 'true'.
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        ///   - DependsOnUnified 2.0.0.0 is on the black list. 
+        ///   - DependsOnUnified 2.0.0.0 is on the deny list. 
         /// Expected:
         /// - There should be exactly one UnifyMe dependency returned and it should be version 1.0.0.0.
         /// Rationale:
         /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly 
-        /// dependency seen. However if the higher assembly is a dependency of an assembly in the black list it should not be considered during unification.
+        /// dependency seen. However if the higher assembly is a dependency of an assembly in the deny list it should not be considered during unification.
         /// </summary>
         [Fact]
-        public void ExistsWithPrimaryReferenceOnBlackList()
+        public void ExistsWithPrimaryReferenceOnDenyList()
         {
             string implicitRedistListContents =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -178,16 +178,16 @@ public void ExistsWithPrimaryReferenceOnBlackList()
         /// - The AutoUnify flag is set to 'true'.
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        /// - UnifyMe 2.0.0.0 is on the black list
+        /// - UnifyMe 2.0.0.0 is on the deny list
         /// Expected:
         /// - There should be exactly one UnifyMe dependency returned and it should be version 1.0.0.0.
-        ///  Also there should be a warning about the primary reference DependsOnUnified 2.0.0.0 having a dependency which was in the black list.
+        ///  Also there should be a warning about the primary reference DependsOnUnified 2.0.0.0 having a dependency which was in the deny list.
         /// Rationale:
         /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly 
-        /// dependency seen. However if the higher assembly is a dependency of an assembly in the black list it should not be considered during unification.
+        /// dependency seen. However if the higher assembly is a dependency of an assembly in the deny list it should not be considered during unification.
         /// </summary>
         [Fact]
-        public void ExistsPromotedDependencyInTheBlackList()
+        public void ExistsPromotedDependencyInTheDenyList()
         {
             string implicitRedistListContents =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -258,14 +258,14 @@ public void ExistsPromotedDependencyInTheBlackList()
         /// - The AutoUnify flag is set to 'true'.
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        ///   - UnifyMe 2.0.0.0 is on the black list because it is higher than what is in the redist list, 1.0.0.0 is also in a black list because it is not in the subset but is in the redist list.
+        ///   - UnifyMe 2.0.0.0 is on the deny list because it is higher than what is in the redist list, 1.0.0.0 is also in a deny list because it is not in the subset but is in the redist list.
         /// Expected:
         /// - There should be no UnifyMe dependency returned 
-        /// There should be a warning indicating the primary reference DependsOnUnified 1.0.0.0 has a dependency that in the black list
-        /// There should be a warning indicating the primary reference DependsOnUnified 2.0.0.0 has a dependency that in the black list
+        /// There should be a warning indicating the primary reference DependsOnUnified 1.0.0.0 has a dependency that in the deny list
+        /// There should be a warning indicating the primary reference DependsOnUnified 2.0.0.0 has a dependency that in the deny list
         /// </summary>
         [Fact]
-        public void ExistsWithBothDependentReferenceOnBlackList()
+        public void ExistsWithBothDependentReferenceOnDenyList()
         {
             string implicitRedistListContents =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -333,7 +333,7 @@ public void ExistsWithBothDependentReferenceOnBlackList()
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
         /// - Version 3.0.0.0 of UnifyMe exists.
-        /// - Version 3.0.0.0 of DependsOn is on black list
+        /// - Version 3.0.0.0 of DependsOn is on deny list
         /// Expected:
         /// - There should be exactly one UnifyMe dependency returned and it should be version 2.0.0.0.
         /// - There should be messages saying that 2.0.0.0 was unified from 1.0.0.0.
@@ -341,7 +341,7 @@ public void ExistsWithBothDependentReferenceOnBlackList()
         /// AutoUnify works even when unifying multiple prior versions.
         /// </summary>
         [Fact]
-        public void MultipleUnifiedFromNamesMiddlePrimaryOnBlackList()
+        public void MultipleUnifiedFromNamesMiddlePrimaryOnDenyList()
         {
             string implicitRedistListContents =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
diff --git a/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs b/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
index bf6e3c2a05c..af533432c22 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
@@ -59,7 +59,7 @@ private ITranslator GetReadTranslator()
             }
 
             _serializationStream.Seek(0, SeekOrigin.Begin);
-            return BinaryTranslator.GetReadTranslator(_serializationStream, null);
+            return BinaryTranslator.GetReadTranslator(_serializationStream, InterningBinaryReader.PoolingBuffer);
         }
 
         private ITranslator GetWriteTranslator()
diff --git a/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs b/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
index 8cf97318e7a..58e3021af56 100644
--- a/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
@@ -40,7 +40,7 @@ public void ExerciseCacheSerialization()
             {
                 TransientTestFile file = env.CreateFile();
                 arc.SerializeCache(file.Path, null);
-                arc2 = StateFileBase.DeserializeCache(file.Path, null, typeof(AssemblyRegistrationCache)) as AssemblyRegistrationCache;
+                arc2 = StateFileBase.DeserializeCache<AssemblyRegistrationCache>(file.Path, null);
             }
 
             arc2._assemblies.Count.ShouldBe(arc._assemblies.Count);
diff --git a/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs b/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs
new file mode 100644
index 00000000000..ea0a3b0f166
--- /dev/null
+++ b/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs
@@ -0,0 +1,37 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests
+{
+    public sealed class CombineTargetFrameworkInfoProperties_Tests
+    {
+        /// <summary>
+        /// https://github.com/dotnet/msbuild/issues/8320
+        /// </summary>
+        [Theory]
+        [InlineData(null, false, "MSB3991")]
+        [InlineData("", false, "MSB3991")]
+        [InlineData(null, true, "MSB3992")]
+        public void RootElementNameNotValid(string rootElementName, bool UseAttributeForTargetFrameworkInfoPropertyNames, string errorCode)
+        {
+            MockEngine e = new MockEngine();
+            var task = new CombineTargetFrameworkInfoProperties();
+            task.BuildEngine = e;
+            var items = new ITaskItem[]
+            {
+                new TaskItemData("ItemSpec1", null)
+            };
+            task.RootElementName = rootElementName;
+            task.PropertiesAndValues = items;
+            task.UseAttributeForTargetFrameworkInfoPropertyNames = UseAttributeForTargetFrameworkInfoPropertyNames;
+            task.Execute().ShouldBe(false);
+            e.AssertLogContains(errorCode);
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 8bdddb235b8..1792dad790f 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -27,19 +27,47 @@ namespace Microsoft.Build.UnitTests
 {
     public class Copy_Tests : IDisposable
     {
-        public bool UseHardLinks { get; protected set; }
+        /// <summary>
+        /// Gets data for testing with combinations of isUseHardLinks and isUseSymbolicLinks.
+        /// Index 0 is the value for isUseHardLinks.
+        /// Index 1 is the value for isUseSymbolicLinks.
+        /// </summary>
+        public static IEnumerable<object[]> GetHardLinksSymLinks() => new List<object[]>
+        {
+            new object[] { false, false },
+            new object[] { false, true },
+            new object[] { true, false },
 
-        public bool UseSymbolicLinks { get; protected set; }
+            /* Cases not covered
+            new object[] { true, true },
+            */
+        };
 
-        public bool UseSingleThreadedCopy
+        /// <summary>
+        /// Gets data for testing with combinations of isUseHardLinks, isUseSymbolicLinks, and isUseSingleThreadedCopy.
+        /// Index 0 is the value for isUseHardLinks.
+        /// Index 1 is the value for isUseSymbolicLinks.
+        /// Index 2 is the value for isUseSingleThreadedCopy.
+        /// </summary>
+        public static IEnumerable<object[]> GetHardLinksSymLinksSingleThreaded() => new List<object[]>
         {
-            get => _parallelismThreadCount == NoParallelismThreadCount;
-            protected set => _parallelismThreadCount = value ? NoParallelismThreadCount : DefaultParallelismThreadCount;
-        }
+            new object[] { false, false, false },
+            new object[] { false, false, true },
+            new object[] { false, true, false },
+            new object[] { true, false, false },
+
+            /* Cases not covered
+            new object[] { false, true, true },
+            new object[] { true, false, true },
+            new object[] { true, true, false },
+            new object[] { true, true, true },
+            */
+        };
 
         private const int NoParallelismThreadCount = 1;
         private const int DefaultParallelismThreadCount = int.MaxValue;
-        private int _parallelismThreadCount = DefaultParallelismThreadCount;
+
+        private int GetParallelismThreadCount(bool isUseSingleThreadedCopy) => isUseSingleThreadedCopy ? NoParallelismThreadCount : DefaultParallelismThreadCount;
 
         /// <summary>
         /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run
@@ -88,8 +116,9 @@ public void Dispose()
         /// If OnlyCopyIfDifferent is set to "true" then we shouldn't copy over files that
         /// have the same date and time.
         /// </summary>
-        [Fact]
-        public void DontCopyOverSameFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void DontCopyOverSameFile(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             string file = FileUtilities.GetTemporaryFile();
             try
@@ -111,11 +140,11 @@ public void DontCopyOverSameFile()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
-                t.Execute(m.CopyFile, _parallelismThreadCount);
+                t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -128,13 +157,176 @@ public void DontCopyOverSameFile()
             }
         }
 
+        /// <summary>
+        /// Question should not copy any files.
+        /// </summary>
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void QuestionCopyFile(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
+        {
+            string source = FileUtilities.GetTemporaryFile();
+            string destination = FileUtilities.GetTemporaryFile(null, ".tmp", false);
+            string content = "This is a source file.";
+
+            try
+            {
+                using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
+                {
+                    sw.Write(content);
+                }
+
+                ITaskItem sourceItem = new TaskItem(source);
+                ITaskItem destinationItem = new TaskItem(destination);
+                ITaskItem[] sourceFiles = { sourceItem };
+                ITaskItem[] destinationFiles = { destinationItem };
+
+                CopyMonitor m = new CopyMonitor();
+                Copy t = new Copy
+                {
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(_testOutputHelper),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
+                    FailIfNotIncremental = true,
+                };
+
+                Assert.False(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+
+                // Expect for there to have been no copies.
+                Assert.Equal(0, m.copyCount);
+
+                Assert.False(FileUtilities.FileExistsNoThrow(destination));
+            }
+            finally
+            {
+                File.Delete(source);
+            }
+        }
+
+        /// <summary>
+        /// Question copy should not error if copy did no work.
+        /// </summary>
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void QuestionCopyFileSameContent(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
+        {
+            string source = FileUtilities.GetTemporaryFile();
+            string destination = FileUtilities.GetTemporaryFile();
+            string content = "This is a source file.";
+            DateTime testTime = DateTime.Now;
+
+            try
+            {
+                using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
+                {
+                    sw.Write(content);
+                }
+
+                using (StreamWriter sw = FileUtilities.OpenWrite(destination, true))
+                {
+                    sw.Write(content);
+                }
+
+                FileInfo sourcefi = new FileInfo(source);
+                sourcefi.LastWriteTimeUtc = testTime;
+
+                FileInfo destinationfi = new FileInfo(destination);
+                destinationfi.LastWriteTimeUtc = testTime;
+
+                ITaskItem sourceItem = new TaskItem(source);
+                ITaskItem destinationItem = new TaskItem(destination);
+                ITaskItem[] sourceFiles = { sourceItem };
+                ITaskItem[] destinationFiles = { destinationItem };
+
+                CopyMonitor m = new CopyMonitor();
+                Copy t = new Copy
+                {
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(_testOutputHelper),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
+                    SkipUnchangedFiles = true,
+                    FailIfNotIncremental = true,
+                };
+                Assert.True(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+
+                // Expect for there to have been no copies.
+                Assert.Equal(0, m.copyCount);
+
+                ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
+            }
+            finally
+            {
+                File.Delete(source);
+                File.Delete(destination);
+            }
+        }
+
+        /// <summary>
+        /// Question copy should error if a copy will occur.
+        /// </summary>
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void QuestionCopyFileNotSameContent(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
+        {
+            string source = FileUtilities.GetTemporaryFile();
+            string destination = FileUtilities.GetTemporaryFile();
+            try
+            {
+                using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
+                {
+                    sw.Write("This is a source file.");
+                }
+
+                using (StreamWriter sw = FileUtilities.OpenWrite(destination, true))
+                {
+                    sw.Write("This is a destination file.");
+                }
+
+                ITaskItem sourceItem = new TaskItem(source);
+                ITaskItem destinationItem = new TaskItem(destination);
+                ITaskItem[] sourceFiles = { sourceItem };
+                ITaskItem[] destinationFiles = { destinationItem };
+
+                CopyMonitor m = new CopyMonitor();
+                Copy t = new Copy
+                {
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(_testOutputHelper),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
+                    SkipUnchangedFiles = true,
+                    FailIfNotIncremental = true,
+                };
+
+                Assert.False(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+
+                // Expect for there to have been no copies.
+                Assert.Equal(0, m.copyCount);
+
+                ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
+            }
+            finally
+            {
+                File.Delete(source);
+                File.Delete(destination);
+            }
+        }
+
         /// <summary>
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void DoNotNormallyCopyOverReadOnlyFile()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotNormallyCopyOverReadOnlyFile(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
@@ -165,8 +357,8 @@ public void DoNotNormallyCopyOverReadOnlyFile()
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
                     // OverwriteReadOnlyFiles defaults to false
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 // Should fail: target is readonly
@@ -193,10 +385,11 @@ public void DoNotNormallyCopyOverReadOnlyFile()
         /// If MSBUILDALWAYSOVERWRITEREADONLYFILES is set, then overwrite read-only even when
         /// OverwriteReadOnlyFiles is false
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void CopyOverReadOnlyFileEnvironmentOverride()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyOverReadOnlyFileEnvironmentOverride(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
@@ -231,8 +424,8 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
                     OverwriteReadOnlyFiles = false,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 // Should not fail although target is readonly
@@ -258,10 +451,11 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
         /// <summary>
         /// If MSBUILDALWAYSRETRY is set, keep retrying the copy.
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void AlwaysRetryCopyEnvironmentOverride()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void AlwaysRetryCopyEnvironmentOverride(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
@@ -298,8 +492,8 @@ public void AlwaysRetryCopyEnvironmentOverride()
                     SkipUnchangedFiles = true,
                     OverwriteReadOnlyFiles = false,
                     Retries = 5,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 // The file is read-only, so the retries will all fail.
@@ -329,10 +523,11 @@ public void AlwaysRetryCopyEnvironmentOverride()
         /// <summary>
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void CopyOverReadOnlyFileParameterIsSet()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyOverReadOnlyFileParameterIsSet(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
@@ -363,8 +558,8 @@ public void CopyOverReadOnlyFileParameterIsSet()
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
                     OverwriteReadOnlyFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 // Should not fail although target is readonly
@@ -388,8 +583,9 @@ public void CopyOverReadOnlyFileParameterIsSet()
         /// <summary>
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
-        [Fact]
-        public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string source1 = FileUtilities.GetTemporaryFile();
             string source2 = FileUtilities.GetTemporaryFile();
@@ -434,8 +630,8 @@ public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder()
                     SourceFiles = sourceFiles,
                     DestinationFolder = new TaskItem(destinationFolder),
                     OverwriteReadOnlyFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 // Should not fail although one target is readonly
@@ -472,8 +668,9 @@ public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder()
          * If OnlyCopyIfDifferent is set to "true" then we should still copy over files that
          * have different dates or sizes.
          */
-        [Fact]
-        public void DoCopyOverDifferentFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoCopyOverDifferentFile(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
             string destinationFile = FileUtilities.GetTemporaryFile();
@@ -499,8 +696,8 @@ public void DoCopyOverDifferentFile()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 t.Execute();
@@ -529,9 +726,13 @@ public void DoCopyOverDifferentFile()
          * If SkipUnchangedFiles is set to "true" then we should never copy over files that have same dates and sizes.
          */
         [Theory(Skip = "https://github.com/dotnet/msbuild/issues/4126")]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
+        [InlineData(false, false, false)]
+        [InlineData(false, false, true)]
+        [InlineData(false, true, false)]
+        [InlineData(true, false, false)]
+        [InlineData(true, false, true)]
+        [InlineData(true, true, false)]
+        public void DoCopyOverCopiedFile(bool skipUnchangedFiles, bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             using (var env = TestEnvironment.Create())
             {
@@ -551,8 +752,8 @@ public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
                         SourceFiles = new[] { new TaskItem(sourceFile) },
                         DestinationFiles = new[] { new TaskItem(destinationFile) },
                         SkipUnchangedFiles = skipUnchangedFiles,
-                        UseHardlinksIfPossible = UseHardLinks,
-                        UseSymboliclinksIfPossible = UseSymbolicLinks,
+                        UseHardlinksIfPossible = isUseHardLinks,
+                        UseSymboliclinksIfPossible = isUseSymbolicLinks,
                     };
 
                     var success = t.Execute();
@@ -562,10 +763,10 @@ public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
                                         i == 1 &&
                                         // SkipUnchanged check will always fail for symbolic links,
                                         // because we compare attributes of real file with attributes of symbolic link.
-                                        !UseSymbolicLinks &&
+                                        !isUseSymbolicLinks &&
                                         // On Windows and MacOS File.Copy already preserves LastWriteTime, but on Linux extra step is needed.
                                         // TODO - this need to be fixed on Linux
-                                        (!NativeMethodsShared.IsLinux || UseHardLinks);
+                                        (!NativeMethodsShared.IsLinux || isUseHardLinks);
 
                     if (shouldNotCopy)
                     {
@@ -599,8 +800,9 @@ public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
          * If OnlyCopyIfDifferent is set to "true" then we should still copy over files that
          * don't exist.
          */
-        [Fact]
-        public void DoCopyOverNonExistentFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoCopyOverNonExistentFile(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
             string destinationFile = FileUtilities.GetTemporaryFile();
@@ -629,8 +831,8 @@ public void DoCopyOverNonExistentFile()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 t.Execute();
@@ -648,8 +850,9 @@ public void DoCopyOverNonExistentFile()
         /// <summary>
         /// Make sure we do not retry when the source file has a misplaced colon
         /// </summary>
-        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Colon is special only on Windows.")]
-        public void DoNotRetryCopyNotSupportedException()
+        [WindowsFullFrameworkOnlyTheory(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Colon is special only on Windows.")]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryCopyNotSupportedException(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
             string destinationFile = "foobar:";
@@ -667,8 +870,8 @@ public void DoNotRetryCopyNotSupportedException()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -687,8 +890,9 @@ public void DoNotRetryCopyNotSupportedException()
         /// <summary>
         /// Make sure we do not retry when the source file does not exist
         /// </summary>
-        [Fact]
-        public void DoNotRetryCopyNonExistentSourceFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryCopyNonExistentSourceFile(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = "Nannanacat";
             string destinationFile = FileUtilities.GetTemporaryFile();
@@ -713,8 +917,8 @@ public void DoNotRetryCopyNonExistentSourceFile()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -733,8 +937,9 @@ public void DoNotRetryCopyNonExistentSourceFile()
         /// <summary>
         /// Make sure we do not retry when the source file is a folder
         /// </summary>
-        [Fact]
-        public void DoNotRetryCopyWhenSourceIsFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryCopyWhenSourceIsFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = Path.GetTempPath();
             string destinationFile = FileUtilities.GetTemporaryFile();
@@ -759,8 +964,8 @@ public void DoNotRetryCopyWhenSourceIsFolder()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -779,10 +984,11 @@ public void DoNotRetryCopyWhenSourceIsFolder()
         /// <summary>
         /// Most important case is when destination is locked
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void DoRetryWhenDestinationLocked()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoRetryWhenDestinationLocked(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string destinationFile = Path.GetTempFileName();
             string sourceFile = Path.GetTempFileName();
@@ -800,8 +1006,8 @@ public void DoRetryWhenDestinationLocked()
                         BuildEngine = engine,
                         SourceFiles = sourceFiles,
                         DestinationFiles = new ITaskItem[] { new TaskItem(destinationFile) },
-                        UseHardlinksIfPossible = UseHardLinks,
-                        UseSymboliclinksIfPossible = UseSymbolicLinks,
+                        UseHardlinksIfPossible = isUseHardLinks,
+                        UseSymboliclinksIfPossible = isUseSymbolicLinks,
                     };
 
                     bool result = t.Execute();
@@ -830,8 +1036,9 @@ public void DoRetryWhenDestinationLocked()
         /// <summary>
         /// When destination is inaccessible due to ACL, do NOT retry
         /// </summary>
-        [Fact]
-        public void DoNotRetryWhenDestinationLockedDueToAcl()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryWhenDestinationLockedDueToAcl(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string tempDirectory = Path.Combine(Path.GetTempPath(), "DoNotRetryWhenDestinationLockedDueToAcl");
             string destinationFile = Path.Combine(tempDirectory, "DestinationFile.txt");
@@ -870,8 +1077,8 @@ public void DoNotRetryWhenDestinationLockedDueToAcl()
                     BuildEngine = engine,
                     SourceFiles = new ITaskItem[] { new TaskItem(sourceFile) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(destinationFile) },
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -902,8 +1109,9 @@ public void DoNotRetryWhenDestinationLockedDueToAcl()
         /// <summary>
         /// Make sure we do not retry when the destination file is a folder
         /// </summary>
-        [Fact]
-        public void DoNotRetryCopyWhenDestinationFolderIsFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryCopyWhenDestinationFolderIsFile(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string destinationFile = FileUtilities.GetTemporaryFile();
             string sourceFile = FileUtilities.GetTemporaryFile();
@@ -925,8 +1133,8 @@ public void DoNotRetryCopyWhenDestinationFolderIsFile()
                     SourceFiles = sourceFiles,
                     DestinationFolder = new TaskItem(destinationFile),
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -947,8 +1155,9 @@ public void DoNotRetryCopyWhenDestinationFolderIsFile()
         /// <summary>
         /// Make sure we do not retry when the destination file is a folder
         /// </summary>
-        [Fact]
-        public void DoNotRetryCopyWhenDestinationFileIsFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryCopyWhenDestinationFileIsFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string destinationFile = Path.GetTempPath();
             string sourceFile = FileUtilities.GetTemporaryFile();
@@ -971,8 +1180,8 @@ public void DoNotRetryCopyWhenDestinationFileIsFolder()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -988,28 +1197,13 @@ public void DoNotRetryCopyWhenDestinationFileIsFolder()
             }
         }
 
-        internal sealed class CopyMonitor
-        {
-            internal int copyCount;
-
-            /*
-            * Method:   CopyFile
-            *
-            * Don't really copy the file, just count how many times this was called.
-            */
-            internal bool? CopyFile(FileState source, FileState destination)
-            {
-                Interlocked.Increment(ref copyCount);
-                return true;
-            }
-        }
-
         /// <summary>
         /// CopiedFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
-        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Under Unix all filenames are valid and this test is not useful.")]
-        public void OutputsOnlyIncludeSuccessfulCopies()
+        [WindowsFullFrameworkOnlyTheory(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Under Unix all filenames are valid and this test is not useful.")]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void OutputsOnlyIncludeSuccessfulCopies(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string temp = Path.GetTempPath();
             string inFile1 = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A392");
@@ -1038,8 +1232,8 @@ public void OutputsOnlyIncludeSuccessfulCopies()
                 {
                     RetryDelayMilliseconds = 1,  // speed up tests!
                     BuildEngine = engine,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 ITaskItem i1 = new TaskItem(inFile1);
@@ -1095,8 +1289,9 @@ public void OutputsOnlyIncludeSuccessfulCopies()
         /// Copying a file on top of itself should be a success (no-op) whether
         /// or not skipUnchangedFiles is true or false.
         /// </summary>
-        [Fact]
-        public void CopyFileOnItself()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyFileOnItself(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string temp = Path.GetTempPath();
             string file = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A395");
@@ -1122,8 +1317,8 @@ public void CopyFileOnItself()
                     SourceFiles = new ITaskItem[] { new TaskItem(file) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(file) },
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1141,8 +1336,8 @@ public void CopyFileOnItself()
                     SourceFiles = new ITaskItem[] { new TaskItem(file) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(file) },
                     SkipUnchangedFiles = false,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 success = t.Execute();
@@ -1164,8 +1359,9 @@ public void CopyFileOnItself()
         /// Copying a file on top of itself should be a success (no-op) whether
         /// or not skipUnchangedFiles is true or false. Variation with different casing/relativeness.
         /// </summary>
-        [WindowsOnlyFact(additionalMessage: "File names under Unix are case-sensitive and this test is not useful.")]
-        public void CopyFileOnItself2()
+        [WindowsOnlyTheory(additionalMessage: "File names under Unix are case-sensitive and this test is not useful.")]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyFileOnItself2(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string currdir = Directory.GetCurrentDirectory();
             string filename = "2A333ED756AF4dc392E728D0F864A396";
@@ -1192,8 +1388,8 @@ public void CopyFileOnItself2()
                     SourceFiles = new ITaskItem[] { new TaskItem(file) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(filename.ToLowerInvariant()) },
                     SkipUnchangedFiles = false,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1214,10 +1410,11 @@ public void CopyFileOnItself2()
         /// Copying a file on top of itself should be a success (no-op) whether
         /// or not skipUnchangedFiles is true or false. Variation with a second copy failure.
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void CopyFileOnItselfAndFailACopy()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyFileOnItselfAndFailACopy(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string temp = Path.GetTempPath();
             string file = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A395");
@@ -1245,8 +1442,8 @@ public void CopyFileOnItselfAndFailACopy()
                     SourceFiles = new ITaskItem[] { new TaskItem(file), new TaskItem(invalidFile) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(file), new TaskItem(dest2) },
                     SkipUnchangedFiles = false,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1279,8 +1476,9 @@ public void CopyFileOnItselfAndFailACopy()
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
-        public void CopyToDestinationFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyToDestinationFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
             string temp = Path.GetTempPath();
@@ -1305,8 +1503,8 @@ public void CopyToDestinationFolder()
                     SourceFiles = sourceFiles,
                     DestinationFolder = new TaskItem(destFolder),
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1320,7 +1518,7 @@ public void CopyToDestinationFolder()
                     destinationFileContents = sr.ReadToEnd();
                 }
 
-                if (!UseHardLinks)
+                if (!isUseHardLinks)
                 {
                     MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
                     me.AssertLogDoesntContainMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
@@ -1349,8 +1547,9 @@ public void CopyToDestinationFolder()
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
-        public void CopyDoubleEscapableFileToDestinationFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyDoubleEscapableFileToDestinationFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFileEscaped = Path.GetTempPath() + "a%253A_" + Guid.NewGuid().ToString("N") + ".txt";
             string sourceFile = EscapingUtilities.UnescapeAll(sourceFileEscaped);
@@ -1376,8 +1575,8 @@ public void CopyDoubleEscapableFileToDestinationFolder()
                     SourceFiles = sourceFiles,
                     DestinationFolder = new TaskItem(destFolder),
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1410,8 +1609,9 @@ public void CopyDoubleEscapableFileToDestinationFolder()
         /// Copying duplicates should only perform the actual copy once for each unique source/destination pair
         /// but should still produce outputs for all specified source/destination pairs.
         /// </summary>
-        [Fact]
-        public void CopyWithDuplicatesUsingFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void CopyWithDuplicatesUsingFolder(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             string tempPath = Path.GetTempPath();
 
@@ -1439,8 +1639,8 @@ public void CopyWithDuplicatesUsingFolder()
                 BuildEngine = new MockEngine(_testOutputHelper),
                 SourceFiles = sourceFiles,
                 DestinationFolder = new TaskItem(Path.Combine(tempPath, "foo")),
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             bool success = t.Execute(delegate (FileState source, FileState dest)
@@ -1450,7 +1650,7 @@ public void CopyWithDuplicatesUsingFolder()
                     filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
                 }
                 return true;
-            }, _parallelismThreadCount);
+            }, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.True(success);
             Assert.Equal(2, filesActuallyCopied.Count);
@@ -1466,8 +1666,9 @@ public void CopyWithDuplicatesUsingFolder()
         /// Copying duplicates should only perform the actual copy once for each unique source/destination pair
         /// but should still produce outputs for all specified source/destination pairs.
         /// </summary>
-        [Fact]
-        public void CopyWithDuplicatesUsingFiles()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void CopyWithDuplicatesUsingFiles(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             string tempPath = Path.GetTempPath();
 
@@ -1505,8 +1706,8 @@ public void CopyWithDuplicatesUsingFiles()
                 BuildEngine = new MockEngine(_testOutputHelper),
                 SourceFiles = sourceFiles,
                 DestinationFiles = destFiles,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             bool success = t.Execute(delegate (FileState source, FileState dest)
@@ -1516,7 +1717,7 @@ public void CopyWithDuplicatesUsingFiles()
                     filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
                 }
                 return true;
-            }, _parallelismThreadCount);
+            }, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.True(success);
             Assert.Equal(4, filesActuallyCopied.Count);
@@ -1542,8 +1743,9 @@ public void CopyWithDuplicatesUsingFiles()
         /// DestinationFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
-        [Fact]
-        public void DestinationFilesLengthNotEqualSourceFilesLength()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DestinationFilesLengthNotEqualSourceFilesLength(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string temp = Path.GetTempPath();
             string inFile1 = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
@@ -1573,8 +1775,8 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
                     BuildEngine = engine,
                     SourceFiles = new ITaskItem[] { new TaskItem(inFile1), new TaskItem(inFile2) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(outFile1) },
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1598,8 +1800,9 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
         /// If the destination path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException
         /// </summary>
-        [WindowsFullFrameworkOnlyFact]
-        public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
+        [WindowsFullFrameworkOnlyTheory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void Regress451057_ExitGracefullyIfPathNameIsTooLong(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
             const string destinationFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
@@ -1620,8 +1823,8 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
                     BuildEngine = new MockEngine(_testOutputHelper),
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -1641,8 +1844,9 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         /// If the source path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException
         /// </summary>
-        [WindowsFullFrameworkOnlyFact]
-        public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
+        [WindowsFullFrameworkOnlyTheory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void Regress451057_ExitGracefullyIfPathNameIsTooLong2(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             const string sourceFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
             string destinationFile = FileUtilities.GetTemporaryFile();
@@ -1657,8 +1861,8 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
                 BuildEngine = new MockEngine(_testOutputHelper),
                 SourceFiles = sourceFiles,
                 DestinationFiles = destinationFiles,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             bool result = t.Execute();
@@ -1673,8 +1877,9 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
         /// <summary>
         /// If the SourceFiles parameter is given invalid path characters, make sure the task exits gracefully.
         /// </summary>
-        [Fact]
-        public void ExitGracefullyOnInvalidPathCharacters()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void ExitGracefullyOnInvalidPathCharacters(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             var t = new Copy
             {
@@ -1682,8 +1887,8 @@ public void ExitGracefullyOnInvalidPathCharacters()
                 BuildEngine = new MockEngine(_testOutputHelper),
                 SourceFiles = new ITaskItem[] { new TaskItem("foo | bar") },
                 DestinationFolder = new TaskItem("dest"),
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             bool result = t.Execute();
@@ -1707,8 +1912,6 @@ public void InvalidRetryCount()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = -1,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
             };
 
             bool result = t.Execute();
@@ -1731,8 +1934,6 @@ public void InvalidRetryDelayCount()
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = 1,
                 RetryDelayMilliseconds = -1,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
             };
 
             bool result = t.Execute();
@@ -1745,8 +1946,9 @@ public void InvalidRetryDelayCount()
         /// Verifies that we do not log the retrying warning if we didn't request
         /// retries.
         /// </summary>
-        [Fact]
-        public void FailureWithNoRetries()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void FailureWithNoRetries(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1756,12 +1958,12 @@ public void FailureWithNoRetries()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = 0,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
+            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.False(result);
             engine.AssertLogDoesntContain("MSB3026");
@@ -1811,8 +2013,9 @@ public void DefaultNoHardlink()
         /// Verifies that we get the one retry we ask for after the first attempt fails,
         /// and we get appropriate messages.
         /// </summary>
-        [Fact]
-        public void SuccessAfterOneRetry()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void SuccessAfterOneRetry(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1822,12 +2025,12 @@ public void SuccessAfterOneRetry()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = 1,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
+            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.True(result);
             engine.AssertLogContains("MSB3026");
@@ -1837,8 +2040,9 @@ public void SuccessAfterOneRetry()
         /// <summary>
         /// Verifies that after a successful retry we continue to the next file
         /// </summary>
-        [Fact]
-        public void SuccessAfterOneRetryContinueToNextFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void SuccessAfterOneRetryContinueToNextFile(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1848,12 +2052,12 @@ public void SuccessAfterOneRetryContinueToNextFile()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source"), new TaskItem("c:\\source2") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination"), new TaskItem("c:\\destination2") },
                 Retries = 1,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
+            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.True(result);
             engine.AssertLogContains("MSB3026");
@@ -1868,8 +2072,9 @@ public void SuccessAfterOneRetryContinueToNextFile()
         /// The copy delegate can return false, or throw on failure.
         /// This test tests returning false.
         /// </summary>
-        [Fact]
-        public void TooFewRetriesReturnsFalse()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void TooFewRetriesReturnsFalse(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1879,12 +2084,12 @@ public void TooFewRetriesReturnsFalse()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = 2,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             var copyFunctor = new CopyFunctor(4, false /* do not throw */);
-            bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
+            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.False(result);
             engine.AssertLogContains("MSB3026");
@@ -1896,8 +2101,9 @@ public void TooFewRetriesReturnsFalse()
         /// The copy delegate can return false, or throw on failure.
         /// This test tests the throw case.
         /// </summary>
-        [Fact]
-        public void TooFewRetriesThrows()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void TooFewRetriesThrows(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1907,19 +2113,22 @@ public void TooFewRetriesThrows()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = 1,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             var copyFunctor = new CopyFunctor(3, true /* throw */);
-            bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
+            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.False(result);
             engine.AssertLogContains("MSB3026");
             engine.AssertLogContains("MSB3027");
         }
 
-        internal virtual void ErrorIfLinkFailedCheck()
+        [WindowsOnlyTheory]
+        [InlineData(false, true)]
+        [InlineData(true, false)]
+        public void ErrorIfLinkFailedCheck(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             using (var env = TestEnvironment.Create())
             {
@@ -1932,8 +2141,8 @@ internal virtual void ErrorIfLinkFailedCheck()
                 Copy t = new Copy
                 {
                     RetryDelayMilliseconds = 1,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                     ErrorIfLinkFails = true,
                     BuildEngine = engine,
                     SourceFiles = new ITaskItem[] { new TaskItem(source) },
@@ -1945,167 +2154,6 @@ internal virtual void ErrorIfLinkFailedCheck()
             }
         }
 
-        /// <summary>
-        /// Helper functor for retry tests.
-        /// Simulates the File.Copy method without touching the disk.
-        /// First copy fails as requested, subsequent copies succeed.
-        /// </summary>
-        private sealed class CopyFunctor
-        {
-            /// <summary>
-            /// Protects the counts and lists below.
-            /// </summary>
-            private readonly object _lockObj = new object();
-
-            /// <summary>
-            /// On what attempt count should we stop failing?
-            /// </summary>
-            private readonly int _countOfSuccess;
-
-            /// <summary>
-            /// Should we throw when we fail, instead of just returning false?
-            /// </summary>
-            private readonly bool _throwOnFailure;
-
-            /// <summary>
-            /// How many tries have we done so far
-            /// </summary>
-            private int _tries;
-
-            /// <summary>
-            /// Which files we actually copied
-            /// </summary>
-            internal List<FileState> FilesCopiedSuccessfully { get; } = new List<FileState>();
-
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            internal CopyFunctor(int countOfSuccess, bool throwOnFailure)
-            {
-                _countOfSuccess = countOfSuccess;
-                _throwOnFailure = throwOnFailure;
-            }
-
-            /// <summary>
-            /// Pretend to be File.Copy.
-            /// </summary>
-            internal bool? Copy(FileState source, FileState destination)
-            {
-                lock (_lockObj)
-                {
-                    _tries++;
-
-                    // 2nd and subsequent copies always succeed
-                    if (FilesCopiedSuccessfully.Count > 0 || _countOfSuccess == _tries)
-                    {
-                        Console.WriteLine("Copied {0} to {1} OK", source, destination);
-                        FilesCopiedSuccessfully.Add(source);
-                        return true;
-                    }
-                }
-
-                if (_throwOnFailure)
-                {
-                    throw new IOException("oops");
-                }
-
-                return null;
-            }
-        }
-    }
-
-    public class CopySingleThreaded_Tests : Copy_Tests
-    {
-        public CopySingleThreaded_Tests(ITestOutputHelper testOutputHelper)
-            : base(testOutputHelper)
-        {
-            UseSingleThreadedCopy = true;
-        }
-    }
-
-    public class CopyNotHardLink_Tests : Copy_Tests
-    {
-        public CopyNotHardLink_Tests(ITestOutputHelper testOutputHelper)
-            : base(testOutputHelper)
-        {
-            UseHardLinks = false;
-        }
-    }
-
-    public class CopyHardAndSymbolicLink_Tests
-    {
-        /// <summary>
-        /// Verify build sucessfully when UseHardlinksIfPossible and UseSymboliclinksIfPossible are true 
-        /// </summary>
-        [Fact]
-        public void CopyWithHardAndSymbolicLinks()
-        {
-            string sourceFile = FileUtilities.GetTemporaryFile();
-            string temp = Path.GetTempPath();
-            string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
-            string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
-
-            try
-            {
-                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
-
-                MockEngine me = new MockEngine(true);
-                Copy t = new Copy
-                {
-                    RetryDelayMilliseconds = 1, // speed up tests!
-                    UseHardlinksIfPossible = true,
-                    UseSymboliclinksIfPossible = true,
-                    BuildEngine = me,
-                    SourceFiles = sourceFiles,
-                    DestinationFolder = new TaskItem(destFolder),
-                    SkipUnchangedFiles = true
-                };
-
-                bool success = t.Execute();
-
-                Assert.True(success);
-                MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
-                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
-            }
-            finally
-            {
-                Helpers.DeleteFiles(sourceFile, destFile);
-            }
-        }
-
-        /// <summary>
-        /// Verifies that we error when ErrorIfLinkFailed is true when UseHardlinksIfPossible
-        /// and UseSymboliclinksIfPossible are false.
-        /// </summary>
-        [Fact]
-        public void InvalidErrorIfLinkFailed()
-        {
-            var engine = new MockEngine(true);
-            var t = new Copy
-            {
-                BuildEngine = engine,
-                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
-                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
-                UseHardlinksIfPossible = false,
-                UseSymboliclinksIfPossible = false,
-                ErrorIfLinkFails = true,
-            };
-
-            bool result = t.Execute();
-
-            Assert.False(result);
-            engine.AssertLogContains("MSB3892");
-        }
-    }
-
-    public class CopyHardLink_Tests : Copy_Tests
-    {
-        public CopyHardLink_Tests(ITestOutputHelper testOutputHelper)
-            : base(testOutputHelper)
-        {
-            UseHardLinks = true;
-        }
-
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
@@ -2362,21 +2410,6 @@ public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
             }
         }
 
-        [WindowsOnlyFact]
-        internal override void ErrorIfLinkFailedCheck()
-        {
-            base.ErrorIfLinkFailedCheck();
-        }
-    }
-
-    public class CopySymbolicLink_Tests : Copy_Tests
-    {
-        public CopySymbolicLink_Tests(ITestOutputHelper testOutputHelper)
-            : base(testOutputHelper)
-        {
-            UseSymbolicLinks = true;
-        }
-
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
@@ -2443,10 +2476,225 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
             }
         }
 
-        [WindowsOnlyFact]
-        internal override void ErrorIfLinkFailedCheck()
+        /// <summary>
+        /// Verify build successful when UseHardlinksIfPossible and UseSymboliclinksIfPossible are true
+        /// </summary>
+        [Fact]
+        public void CopyWithHardAndSymbolicLinks()
+        {
+            string sourceFile = FileUtilities.GetTemporaryFile();
+            string temp = Path.GetTempPath();
+            string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
+            string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
+
+            try
+            {
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+
+                MockEngine me = new MockEngine(true);
+                Copy t = new Copy
+                {
+                    RetryDelayMilliseconds = 1, // speed up tests!
+                    UseHardlinksIfPossible = true,
+                    UseSymboliclinksIfPossible = true,
+                    BuildEngine = me,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destFolder),
+                    SkipUnchangedFiles = true
+                };
+
+                bool success = t.Execute();
+
+                Assert.True(success);
+                MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
+                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
+            }
+            finally
+            {
+                Helpers.DeleteFiles(sourceFile, destFile);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that we error when ErrorIfLinkFailed is true when UseHardlinksIfPossible
+        /// and UseSymboliclinksIfPossible are false.
+        /// </summary>
+        [Fact]
+        public void InvalidErrorIfLinkFailed()
         {
-            base.ErrorIfLinkFailedCheck();
+            var engine = new MockEngine(true);
+            var t = new Copy
+            {
+                BuildEngine = engine,
+                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
+                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
+                UseHardlinksIfPossible = false,
+                UseSymboliclinksIfPossible = false,
+                ErrorIfLinkFails = true,
+            };
+
+            bool result = t.Execute();
+
+            Assert.False(result);
+            engine.AssertLogContains("MSB3892");
+        }
+
+        /// <summary>
+        /// An existing link source should not be modified.
+        /// </summary>
+        /// <remarks>
+        /// Related to issue [#8273](https://github.com/dotnet/msbuild/issues/8273)
+        /// </remarks>
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotCorruptSourceOfLink(bool useHardLink, bool useSymbolicLink)
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile sourceFile1 = env.CreateFile("source1.tmp", "This is the first source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
+            TransientTestFile sourceFile2 = env.CreateFile("source2.tmp", "This is the second source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
+            TransientTestFolder destFolder = env.CreateFolder(createFolder: false);
+            string destFile = Path.Combine(destFolder.Path, "The Destination");
+
+            // Don't create the dest folder, let task do that
+            ITaskItem[] sourceFiles = { new TaskItem(sourceFile1.Path) };
+            ITaskItem[] destinationFiles = { new TaskItem(destFile) };
+
+            var me = new MockEngine(true);
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1, // speed up tests!
+                BuildEngine = me,
+                SourceFiles = sourceFiles,
+                DestinationFiles = destinationFiles,
+                SkipUnchangedFiles = true,
+                UseHardlinksIfPossible = useHardLink,
+                UseSymboliclinksIfPossible = useSymbolicLink,
+            };
+
+            t.Execute().ShouldBeTrue();
+            File.Exists(destFile).ShouldBeTrue();
+            File.ReadAllText(destFile).ShouldBe("This is the first source temp file.");
+
+            sourceFiles = new TaskItem[] { new TaskItem(sourceFile2.Path) };
+
+            t = new Copy
+            {
+                RetryDelayMilliseconds = 1, // speed up tests!
+                BuildEngine = me,
+                SourceFiles = sourceFiles,
+                DestinationFiles = destinationFiles,
+                SkipUnchangedFiles = true,
+                UseHardlinksIfPossible = false,
+                UseSymboliclinksIfPossible = false,
+            };
+
+            t.Execute().ShouldBeTrue();
+            File.Exists(destFile).ShouldBeTrue();
+            File.ReadAllText(destFile).ShouldBe("This is the second source temp file.");
+
+            // Read the source file (it should not have been overwritten)
+            File.ReadAllText(sourceFile1.Path).ShouldBe("This is the first source temp file.");
+            ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
+
+            destinationFiles = new TaskItem[] { new TaskItem(
+                Path.Combine(Path.GetDirectoryName(sourceFile2.Path), ".", Path.GetFileName(sourceFile2.Path))) // sourceFile2.Path with a "." inserted before the file name
+            };
+
+            t = new Copy
+            {
+                RetryDelayMilliseconds = 1, // speed up tests!
+                BuildEngine = me,
+                SourceFiles = sourceFiles,
+                DestinationFiles = destinationFiles,
+                SkipUnchangedFiles = true,
+            };
+
+            t.Execute().ShouldBeTrue();
+            File.Exists(sourceFile2.Path).ShouldBeTrue();
+        }
+
+        internal sealed class CopyMonitor
+        {
+            internal int copyCount;
+
+            /*
+            * Method:   CopyFile
+            *
+            * Don't really copy the file, just count how many times this was called.
+            */
+            internal bool? CopyFile(FileState source, FileState destination)
+            {
+                Interlocked.Increment(ref copyCount);
+                return true;
+            }
+        }
+
+        /// <summary>
+        /// Helper functor for retry tests.
+        /// Simulates the File.Copy method without touching the disk.
+        /// First copy fails as requested, subsequent copies succeed.
+        /// </summary>
+        private sealed class CopyFunctor
+        {
+            /// <summary>
+            /// Protects the counts and lists below.
+            /// </summary>
+            private readonly object _lockObj = new object();
+
+            /// <summary>
+            /// On what attempt count should we stop failing?
+            /// </summary>
+            private readonly int _countOfSuccess;
+
+            /// <summary>
+            /// Should we throw when we fail, instead of just returning false?
+            /// </summary>
+            private readonly bool _throwOnFailure;
+
+            /// <summary>
+            /// How many tries have we done so far
+            /// </summary>
+            private int _tries;
+
+            /// <summary>
+            /// Which files we actually copied
+            /// </summary>
+            internal List<FileState> FilesCopiedSuccessfully { get; } = new List<FileState>();
+
+            /// <summary>
+            /// Constructor
+            /// </summary>
+            internal CopyFunctor(int countOfSuccess, bool throwOnFailure)
+            {
+                _countOfSuccess = countOfSuccess;
+                _throwOnFailure = throwOnFailure;
+            }
+
+            /// <summary>
+            /// Pretend to be File.Copy.
+            /// </summary>
+            internal bool? Copy(FileState source, FileState destination)
+            {
+                lock (_lockObj)
+                {
+                    _tries++;
+
+                    // 2nd and subsequent copies always succeed
+                    if (FilesCopiedSuccessfully.Count > 0 || _countOfSuccess == _tries)
+                    {
+                        Console.WriteLine("Copied {0} to {1} OK", source, destination);
+                        FilesCopiedSuccessfully.Add(source);
+                        return true;
+                    }
+                }
+
+                if (_throwOnFailure)
+                {
+                    throw new IOException("oops");
+                }
+
+                return null;
+            }
         }
     }
 }
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index 927348ec7e1..30545d61a74 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -289,7 +289,7 @@ public void AppConfigFileNotSavedWhenIdentical()
             // Verify it ran correctly and that it's still old
             redirectResults2.ExecuteResult.ShouldBeTrue();
             redirectResults2.TargetAppConfigContent.ShouldContain("<assemblyIdentity name=\"System\" publicKeyToken=\"b77a5c561934e089\" culture=\"neutral\" />");
-            redirectResults.TargetAppConfigContent.ShouldContain("newVersion=\"40.0.0.0\"");
+            redirectResults2.TargetAppConfigContent.ShouldContain("newVersion=\"40.0.0.0\"");
 
             File.GetCreationTime(outputAppConfigFile).ShouldBe(oldTimestamp, TimeSpan.FromSeconds(5));
             File.GetLastWriteTime(outputAppConfigFile).ShouldBe(oldTimestamp, TimeSpan.FromSeconds(5));
diff --git a/src/Tasks.UnitTests/Hash_Tests.cs b/src/Tasks.UnitTests/Hash_Tests.cs
index c335a54b6b3..aa41b686a6b 100644
--- a/src/Tasks.UnitTests/Hash_Tests.cs
+++ b/src/Tasks.UnitTests/Hash_Tests.cs
@@ -1,6 +1,7 @@
 Ôªø// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.Utilities;
@@ -16,7 +17,7 @@ public class Hash_Tests
         public void HashTaskTest()
         {
             // This hash was pre-computed. If the implementation changes it may need to be adjusted.
-            var expectedHash = "5593e2db83ac26117cd95ed8917f09b02a02e2a0";
+            var expectedHash = "3a9e94b896536fdab1343db5038239847e2db371f27e6ac9b5e3e6ea4aa2f2bf";
 
             var actualHash = ExecuteHashTask(new ITaskItem[]
             {
@@ -52,7 +53,7 @@ public void HashTaskEmptyInputTest()
         public void HashTaskLargeInputCountTest()
         {
             // This hash was pre-computed. If the implementation changes it may need to be adjusted.
-            var expectedHash = "8a996bbcb5e481981c2fba7ac408e20d0b4360a5";
+            var expectedHash = "ae8799dfc1f81c50b08d28ac138e25958947895c8563c8fce080ceb5cb44db6f";
 
             ITaskItem[] itemsToHash = new ITaskItem[1000];
             for (int i = 0; i < itemsToHash.Length; i++)
@@ -68,7 +69,7 @@ public void HashTaskLargeInputCountTest()
         public void HashTaskLargeInputSizeTest()
         {
             // This hash was pre-computed. If the implementation changes it may need to be adjusted.
-            var expectedHash = "0509142dd3d3a733f30a52a0eec37cd727d46122";
+            var expectedHash = "48a3fdf5cb1afc679497a418015edc85e571282bb70691d7a64f2ab2e32d5dbf";
 
             string[] array = new string[1000];
             for (int i = 0; i < array.Length; i++)
@@ -81,44 +82,36 @@ public void HashTaskLargeInputSizeTest()
             Assert.Equal(expectedHash, actualHash);
         }
 
-#pragma warning disable CA5350
         // This test verifies that hash computes correctly for various numbers of characters.
         // We would like to process edge of the buffer use cases regardless on the size of the buffer.
         [Fact]
         public void HashTaskDifferentInputSizesTest()
         {
             int maxInputSize = 2000;
-            string input = "";
-            using (var sha1 = System.Security.Cryptography.SHA1.Create())
+            MockEngine mockEngine = new();
+
+            var hashGroups =
+                Enumerable.Range(0, maxInputSize)
+                    .Select(cnt => new string('a', cnt))
+                    .Select(GetHash)
+                    .GroupBy(h => h)
+                    .Where(g => g.Count() > 1)
+                    .Select(g => g.Key);
+            // none of the hashes should repeat
+            Assert.Empty(hashGroups);
+
+            string GetHash(string input)
             {
-                var stringBuilder = new System.Text.StringBuilder(sha1.HashSize);
-                MockEngine mockEngine = new();
-                for (int i = 0; i < maxInputSize; i++)
+                Hash hashTask = new()
                 {
-                    input += "a";
-
-                    Hash hashTask = new()
-                    {
-                        BuildEngine = mockEngine,
-                        ItemsToHash = new ITaskItem[] { new TaskItem(input) },
-                        IgnoreCase = false
-                    };
-                    Assert.True(hashTask.Execute());
-                    string actualHash = hashTask.HashResult;
-
-                    byte[] hash = sha1.ComputeHash(System.Text.Encoding.UTF8.GetBytes(input + '\u2028'));
-                    stringBuilder.Clear();
-                    foreach (var b in hash)
-                    {
-                        stringBuilder.Append(b.ToString("x2"));
-                    }
-                    string expectedHash = stringBuilder.ToString();
-
-                    Assert.Equal(expectedHash, actualHash);
-                }
+                    BuildEngine = mockEngine,
+                    ItemsToHash = new ITaskItem[] { new TaskItem(input) },
+                    IgnoreCase = false
+                };
+                Assert.True(hashTask.Execute());
+                return hashTask.HashResult;
             }
         }
-#pragma warning restore CA5350
 
         [Fact]
         public void HashTaskIgnoreCaseTest()
diff --git a/src/Tasks.UnitTests/HintPathResolver_Tests.cs b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
index 800a3d7cb1a..599a5750961 100644
--- a/src/Tasks.UnitTests/HintPathResolver_Tests.cs
+++ b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
@@ -78,6 +78,7 @@ private bool ResolveHintPath(string hintPath)
                 sdkName: "",
                 rawFileNameCandidate: "FakeSystem.Net.Http",
                 isPrimaryProjectReference: true,
+                isImmutableFrameworkReference: false,
                 wantSpecificVersion: false,
                 executableExtensions: new string[] { ".winmd", ".dll", ".exe" },
                 hintPath: hintPath,
diff --git a/src/Tasks.UnitTests/MakeDir_Tests.cs b/src/Tasks.UnitTests/MakeDir_Tests.cs
index fd390661eb3..8a50acbd4c3 100644
--- a/src/Tasks.UnitTests/MakeDir_Tests.cs
+++ b/src/Tasks.UnitTests/MakeDir_Tests.cs
@@ -166,6 +166,63 @@ public void CreateNewDirectory()
             }
         }
 
+        /// <summary>
+        /// Question Create Directory when a directory is needed to be created should return false.
+        /// </summary>
+        [Fact]
+        public void QuestionCreateNewDirectory()
+        {
+            string temp = Path.GetTempPath();
+            string dir = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A38C");
+
+            try
+            {
+                var dirList = new ITaskItem[]
+                {
+                    new TaskItem(dir)
+                };
+                MakeDir t = new MakeDir();
+                MockEngine engine = new MockEngine();
+                t.BuildEngine = engine;
+                t.FailIfNotIncremental = true;
+                t.Directories = dirList;
+
+                bool success = t.Execute();
+
+                Assert.False(success);
+                Assert.Single(t.DirectoriesCreated);
+                Assert.Contains(
+                    String.Format(AssemblyResources.GetString("MakeDir.Comment"), dir),
+                    engine.Log);
+
+                // Actually create the directory
+                // Note: Need a new task to reset the Log.HasLoggedErrors
+                engine.Log = "";
+                t = new MakeDir();
+                t.BuildEngine = engine;
+                t.Directories = dirList;
+                success = t.Execute();
+                Assert.True(success);
+
+                // Question an existing directory should return true.
+                engine.Log = "";
+                t.FailIfNotIncremental = true;
+                success = t.Execute();
+                Assert.True(success);
+
+                // should still return directory even though it didn't need to be created
+                Assert.Single(t.DirectoriesCreated);
+                Assert.Equal(dir, t.DirectoriesCreated[0].ItemSpec);
+                Assert.DoesNotContain(
+                    String.Format(AssemblyResources.GetString("MakeDir.Comment"), dir),
+                    engine.Log);
+            }
+            finally
+            {
+                FileUtilities.DeleteWithoutTrailingBackslash(dir);
+            }
+        }
+
         /*
         * Method:   FileAlreadyExists
         *
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 473207bfe6f..a69b7fa2ea3 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -15,10 +15,7 @@
   </ItemGroup>
 
   <ItemGroup>
-    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
-
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
@@ -30,9 +27,11 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
+    <PackageReference Include="System.Security.Principal.Windows" />
     <Reference Include="System" />
     <Reference Include="System.Core" />
     <Reference Include="System.IO.Compression" />
+    <Reference Include="System.Net.Http" />
     <Reference Include="System.Xaml" />
     <Reference Include="System.Xml" />
     <Reference Include="PresentationFramework" Condition="$([MSBuild]::IsOSPlatform('windows'))" />
@@ -76,10 +75,10 @@
     </None>
   </ItemGroup>
 
-  <ItemGroup> 
-    <Content Include="TestDocuments\**"> 
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> 
-    </Content> 
+  <ItemGroup>
+    <Content Include="TestDocuments\**">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
index 062eab76b12..d3c94688e18 100644
--- a/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
+++ b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
@@ -21,14 +21,18 @@ public void TestPrecomputedCacheOutput()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
+                DateTime now = DateTime.Now;
                 TransientTestFile standardCache = env.CreateFile(".cache");
                 ResolveAssemblyReference t = new ResolveAssemblyReference()
                 {
                     _cache = new SystemState()
                 };
                 t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
-                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(DateTime.Now) },
-                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(now) },
+                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                t._cache.SetGetLastWriteTime(_ => now);
+                _ = t._cache.GetFileState("assembly1");
+                _ = t._cache.GetFileState("assembly2");
                 t._cache.IsDirty = true;
                 t.StateFile = standardCache.Path;
                 t.WriteStateFile();
@@ -52,13 +56,18 @@ public void StandardCacheTakesPrecedence()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
+                DateTime now = DateTime.Now;
                 TransientTestFile standardCache = env.CreateFile(".cache");
                 ResolveAssemblyReference rarWriterTask = new ResolveAssemblyReference()
                 {
                     _cache = new SystemState()
                 };
-                rarWriterTask._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>();
+                rarWriterTask._cache.instanceLocalFileStateCache = new() {
+                    { "path1", new SystemState.FileState(now) },
+                };
+                rarWriterTask._cache.SetGetLastWriteTime(_ => now);
                 rarWriterTask.StateFile = standardCache.Path;
+                _ = rarWriterTask._cache.GetFileState("path1");
                 rarWriterTask._cache.IsDirty = true;
                 // Write standard cache
                 rarWriterTask.WriteStateFile();
diff --git a/src/Tasks.UnitTests/RemoveDir_Tests.cs b/src/Tasks.UnitTests/RemoveDir_Tests.cs
index 08a081023ea..c0dd5b24cc2 100644
--- a/src/Tasks.UnitTests/RemoveDir_Tests.cs
+++ b/src/Tasks.UnitTests/RemoveDir_Tests.cs
@@ -47,7 +47,6 @@ public void AttributeForwarding()
         [Fact]
         public void SimpleDelete()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 List<TaskItem> list = new List<TaskItem>();
@@ -57,19 +56,36 @@ public void SimpleDelete()
                     list.Add(new TaskItem(env.CreateFolder().Path));
                 }
 
-                RemoveDir t = new RemoveDir();
-
-                t.Directories = list.ToArray();
-                t.BuildEngine = new MockEngine(_output);
-
-                t.Execute().ShouldBeTrue();
+                // Question RemoveDir when files exists.
+                RemoveDir t = new RemoveDir()
+                {
+                    Directories = list.ToArray(),
+                    BuildEngine = new MockEngine(_output),
+                    FailIfNotIncremental = true,
+                };
+                t.Execute().ShouldBeFalse();
 
-                t.RemovedDirectories.Length.ShouldBe(list.Count);
+                RemoveDir t2 = new RemoveDir()
+                {
+                    Directories = list.ToArray(),
+                    BuildEngine = new MockEngine(_output),
+                };
+                t2.Execute().ShouldBeTrue();
+                t2.RemovedDirectories.Length.ShouldBe(list.Count);
 
                 for (int i = 0; i < 20; i++)
                 {
                     Directory.Exists(list[i].ItemSpec).ShouldBeFalse();
                 }
+
+                // Question again to make sure all files were deleted.
+                RemoveDir t3 = new RemoveDir()
+                {
+                    Directories = list.ToArray(),
+                    BuildEngine = new MockEngine(_output),
+                    FailIfNotIncremental = true,
+                };
+                t3.Execute().ShouldBeTrue();
             }
         }
 
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index f71b3383a34..2bce4b5064f 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -74,7 +74,7 @@ public void TestSerializationAndDeserialization()
             {
                 TransientTestFile file = env.CreateFile();
                 cache.SerializeCache(file.Path, null);
-                cache2 = StateFileBase.DeserializeCache(file.Path, null, typeof(ResolveComReferenceCache)) as ResolveComReferenceCache;
+                cache2 = StateFileBase.DeserializeCache<ResolveComReferenceCache>(file.Path, null);
             }
 
             cache2.tlbImpLocation.ShouldBe(cache.tlbImpLocation);
@@ -431,11 +431,11 @@ public void CheckAddMissingTlbReference()
             ComReferenceInfo newTlbInfo = (ComReferenceInfo)rcr.allProjectRefs[3];
             Assert.Equal(axRefInfo.primaryOfAxImpRef, newTlbInfo); // "axRefInfo should hold back reference to tlbRefInfo"
             Assert.True(ComReference.AreTypeLibAttrEqual(newTlbInfo.attr, axRefInfo.attr)); // "The added reference should have the same attributes as the Ax reference"
-            Assert.Equal(newTlbInfo.typeLibName, axRefInfo.typeLibName); // "The added reference should have the same type lib name as the Ax reference"
-            Assert.Equal(newTlbInfo.strippedTypeLibPath, axRefInfo.strippedTypeLibPath); // "The added reference should have the same type lib path as the Ax reference"
+            Assert.Equal(axRefInfo.typeLibName, newTlbInfo.typeLibName); // "The added reference should have the same type lib name as the Ax reference"
+            Assert.Equal(axRefInfo.strippedTypeLibPath, newTlbInfo.strippedTypeLibPath); // "The added reference should have the same type lib path as the Ax reference"
 
             Assert.Equal(newTlbInfo.taskItem.ItemSpec, axRefInfo.taskItem.ItemSpec); // "The added reference should have the same task item spec as the Ax reference"
-            Assert.Equal(newTlbInfo.taskItem.GetMetadata(ComReferenceItemMetadataNames.wrapperTool), ComReferenceTypes.primaryortlbimp); // "The added reference should have the tlbimp/primary wrapper tool"
+            Assert.Equal(ComReferenceTypes.primaryortlbimp, newTlbInfo.taskItem.GetMetadata(ComReferenceItemMetadataNames.wrapperTool)); // "The added reference should have the tlbimp/primary wrapper tool"
 
             rcr.AddMissingTlbReferences();
             Assert.Equal(4, rcr.allProjectRefs.Count); // "There should still be four references"
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 94131f1e4b6..f704ef169a1 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -1940,6 +1940,48 @@ public void InvalidStateFile()
             }
         }
 
+        [Fact]
+        public void GenerateResourceWarnsWhenUsingBinaryFormatter()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile resource = env.CreateFile(".resx", @"<?xml version=""1.0"" encoding=""utf-8""?>
+<root>
+  <data name=""$this.Icon"" type=""System.Drawing.Icon, System.Drawing"" mimetype=""application/x-microsoft.net.object.binary.base64"">
+    <value>
+        AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAA
+        AAD///8BoqKiDaKiotmioqL5oqKiK////wH///8B////Af///wH///8B////AaKioiGioqLxoqKi5aKi
+        ohn///8B////AbS0tBW0tLTz29vb/7Ozsu18Wi+Be1gswXtYLO17WCzte1gswXtYLIGzs7Lz2dnZ/7S0
+        tPu0tLQj////Af///wH///8BxsbGQdPT0//Cv739nGs7/6ZsNf+ubzf/rm83/6ZsNf+hdkr/xcTD/8bG
+        xf/GxsY/////Af///wH///8B////AYxlNmejiGn1r3hE/7uMXv/Ck3H/xJF0/8OPcf+/kGz/uIpd/7SG
+        Wf+hhWT1jGU2Z////wH///8B////AZZtOzWWbTvVs31G/8KZcf/Yqon/79/P//r28//69fP/79/R/9en
+        hf++lGz/s31G/5ZtO9WWbTs1////Af///wGhdUGBsIBK/8abb//Zqoj///7r///67v///fL///7y///8
+        7////ev/2aN6/8KZbP+wgEr/oXVBgf///wH///8BrH5Iwb+PWP/No4H/8NvB///35v/68uP/xcC2//Ht
+        3v///Oj///Xf/+/Ur//ImXL/v49Y/6x+SMH///8B////AbeHTu3JnGb/z5+A//rz4v/99un/8vDj/42M
+        hP+Bf3f/0s/C///76//67Mz/x5Bt/8mcZv+3h07t////Af///wHCkFTtzqZx/9Glif/69un//fju////
+        +f+BgHn/sa6k/4F/d//Jxrr/+vDT/8mWcv/OpnH/wpBU7f///wH///8BzZlbwdOsdf/Zt5j/8ePW//77
+        9f/19fP/n56V//Dw6f/4+PL/vrmt//Dawv/Sqof/06x1/82ZW8H///8B////AbOddIvTrXf/38Sa/969
+        qv//////8PDu/+fl2v////f////3///+8//ctJj/28CW/8Kqfv/Gn2qF////AQCZ3T0KmtjZLpzF9d6/
+        iv/iyaf/37+u//Hj3P/z8ez/9PHr//Hi2f/cuqP/38Oe/4yxqf84ptH5DprWzwCZ3ScAoON9fNHy7WHD
+        6O86pMb74seS/+bRqf/gwqb/1a6W/9Wrkv/evaD/5M+m/7/Bnv9Hstf9q+P2/Smw6NkAoOMnAKfpe13J
+        8eW16Pn/Ycfr7zqqzPPsxIj/6cuU/+fQnf/n0J3/6cuU/97Cjv8yqtD1gdPw9XPQ8+sAp+nNAKfpBQCu
+        7wUAru+LW8v05b/s+v9cy/HpTbLJxfq8dMH6vHTt+rx07fq8dMFRssjDac/y7XzW9u0Aru/JAK7vHf//
+        /wH///8BALX0AwC19IEAtfTRALX0ywC19Af///8B////Af///wH///8BALX0FwC19NEAtfTJALX0J///
+        /wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA
+        //8AAP//AAD//w==
+</value>
+  </data>
+</root>
+");
+
+            GenerateResource gr = Utilities.CreateTask(_output, usePreserialized: true, env: env);
+            gr.Sources = new ITaskItem[] { new TaskItem(resource.Path) };
+            gr.WarnOnBinaryFormatterUse = true;
+
+            gr.Execute().ShouldBeTrue();
+
+            Utilities.AssertLogContainsResource(gr, "GenerateResource.BinaryFormatterUse", "$this.Icon", "System.Drawing.Icon, System.Drawing");
+        }
+
         /// <summary>
         ///  Cause failures in ResourceReader
         /// </summary>
diff --git a/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
index d1c0b84fdc0..c161b862071 100644
--- a/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
@@ -32,7 +32,7 @@ public void ParsesSingleStringAsString()
                     @"<data name=""StringResource"" xml:space=""preserve"">
     <value>StringValue</value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", "StringValue");
         }
@@ -45,7 +45,7 @@ public void ParsesSingleStringWithoutPreserveAsString()
                     @"<data name=""StringResource"">
     <value> StringValue </value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", " StringValue ");
         }
@@ -58,7 +58,7 @@ public void ParsesSingleWhitespaceStringAsString()
                     @"<data name=""StringResource"" xml:space=""preserve"">
     <value> </value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", " ");
         }
@@ -71,7 +71,7 @@ public void ParsesSingleWhitespaceStringWithNoPreserveAsEmptyString()
                     @"<data name=""StringResource"">
     <value> </value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", "");
         }
@@ -83,7 +83,7 @@ public void ParsesSingleStringWithPartialTypeName()
                 ResXHelper.SurroundWithBoilerplate(
                     @"<data name=""StringResource"" type=""System.String"">
     <value>StringValue</value>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", "StringValue");
         }
@@ -100,7 +100,7 @@ public void LoadsMultipleStringsPreservingOrder()
   </data>
   <data name=""2StringResource2"" xml:space=""preserve"">
     <value>2StringValue2</value>
-  </data>"));
+  </data>"), null, false);
 
             resxWithTwoStrings.Count.ShouldBe(2);
 
@@ -121,7 +121,7 @@ public void ResXNullRefProducesNullLiveObject()
 @"  <assembly alias=""System.Windows.Forms"" name=""System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"" />
   <data name=""$this.AccessibleDescription"" type=""System.Resources.ResXNullRef, System.Windows.Forms, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"">
     <value />
-  </data>"));
+  </data>"), null, false);
 
             resxWithNullRef.ShouldHaveSingleItem();
 
@@ -143,7 +143,7 @@ public void LoadsStringFromFileRefAsString(string stringType)
 $@"  <assembly alias=""System.Windows.Forms"" name=""System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"" />
   <data name=""TextFile1"" type=""System.Resources.ResXFileRef, System.Windows.Forms"">
     <value>ResourceHandling\TextFile1.txt;{stringType};utf-8</value>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithLinkedString, "TextFile1", "Contents of TextFile1");
         }
@@ -174,6 +174,8 @@ public void LoadsStringFromFileRefAsStringWithShiftJISEncoding()
   <data name=""TextFile1"" type=""System.Resources.ResXFileRef, System.Windows.Forms"">
     <value>ResourceHandling\TextFileInShiftJIS.txt;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;shift_jis</value>
   </data>"),
+                    null,
+                    false,
                     Path.Combine(baseDir.Path, nameof(LoadsStringFromFileRefAsStringWithShiftJISEncoding) + ".resx"),
                     useRelativePath: true);
 
@@ -210,7 +212,7 @@ public void PassesThroughBitmapInResx()
         b7eblRw4yy8Ta2GCpaZp1sIzz2LfCMS+EYh9401iw/gG1gYfvzjQIXcAAAAASUVORK5CYII=
 </value>
   </data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterByteArrayResource));
 
@@ -228,7 +230,7 @@ public void TypeConverterStringWellFormatted()
     <data name=""color"" type=""System.Drawing.Color, System.Drawing"">
       <value>Blue</value>
     </data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterStringResource));
 
@@ -252,7 +254,7 @@ public void TypeConverterStringDirectValue()
                 ResXHelper.SurroundWithBoilerplate(
 @"  <assembly alias=""System.Drawing"" name=""System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"" />
     <data name=""Color1"" type=""System.Drawing.Color, System.Drawing"">Blue</data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterStringResource));
 
@@ -272,7 +274,7 @@ public void ResXFileRefToBitmap()
 $@"  <data name='Image1' type='System.Resources.ResXFileRef, System.Windows.Forms'>
     <value>{bitmapPath};System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
   </data>
-"));
+"), null, false);
             resxWithLinkedBitmap.ShouldHaveSingleItem();
             resxWithLinkedBitmap[0].ShouldBeOfType(typeof(FileStreamResource));
 
@@ -301,7 +303,7 @@ public void ResXFileRefToMemoryStream(string typeNameInResx)
 $@"  <data name='Image1' type='System.Resources.ResXFileRef, System.Windows.Forms'>
     <value>{linkedTextFile.Path};{typeNameInResx}</value>
   </data>
-"));
+"), null, false);
 
             var resource = resources.ShouldHaveSingleItem()
                 .ShouldBeOfType<LiveObjectResource>();
@@ -321,7 +323,7 @@ public void AssemblyElementWithNoAliasInfersSimpleName()
                 ResXHelper.SurroundWithBoilerplate(
 @"  <assembly name=""System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"" />
     <data name=""Color1"" type=""System.Drawing.Color, System.Drawing""><value>Blue</value></data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterStringResource));
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
index d8462b8017b..6538fef25df 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
@@ -40,7 +40,7 @@ public void DirtyCleanScenario(bool useMSBuildResXReader)
                 cache.IsDirty.ShouldBeFalse();
 
                 // Getting a file that wasn't in the cache is a write operation.
-                cache.GetResXFileInfo(resx, useMSBuildResXReader);
+                cache.GetResXFileInfo(resx, useMSBuildResXReader, null, false);
                 cache.IsDirty.ShouldBeTrue();
 
                 // Add linkedFiles to further test serialization and deserialization.
@@ -72,7 +72,7 @@ public void DirtyCleanScenario(bool useMSBuildResXReader)
                 resX2.linkedFiles[1].ShouldBe(resX.linkedFiles[1]);
 
                 // Asking for a file that's in the cache should not dirty the cache.
-                cache2.GetResXFileInfo(resx, useMSBuildResXReader);
+                cache2.GetResXFileInfo(resx, useMSBuildResXReader, null, false);
                 cache2.IsDirty.ShouldBeFalse();
 
                 // Changing UseSourcePath to false should dirty the cache.
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 91692fb8aa7..5f9f39e9220 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -450,6 +450,9 @@ public void CodeLanguageFromTaskBody()
             TryLoadTaskBodyAndExpectSuccess("<Code Language=\"vb\">code</Code>", expectedCodeLanguage: "VB");
             TryLoadTaskBodyAndExpectSuccess("<Code Language=\"visualbasic\">code</Code>", expectedCodeLanguage: "VB");
             TryLoadTaskBodyAndExpectSuccess("<Code Language=\"ViSuAl BaSic\">code</Code>", expectedCodeLanguage: "VB");
+
+            // Default when the Language attribute is not present.
+            TryLoadTaskBodyAndExpectSuccess("<Code>code</Code>", expectedCodeLanguage: "CS");
         }
 
         [Fact]
@@ -474,6 +477,31 @@ public void CodeTypeFromTaskBody()
             }
         }
 
+        [Fact]
+        public void CSharpClass()
+        {
+            const string taskClassSourceCode = @"namespace InlineTask
+{
+    using Microsoft.Build.Utilities;
+
+    public class HelloWorld : Task
+    {
+        public override bool Execute()
+        {
+            Log.LogMessage(""Hello, world!"");
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
+";
+
+            TryLoadTaskBodyAndExpectSuccess(
+                $"<Code Type=\"Class\">{taskClassSourceCode}</Code>",
+                expectedSourceCode: taskClassSourceCode,
+                expectedCodeType: RoslynCodeTaskFactoryCodeType.Class,
+                expectedCodeLanguage: "CS");
+        }
+
         [Fact]
         public void CSharpFragment()
         {
@@ -690,6 +718,36 @@ public class MyInlineTask : Microsoft.Build.Utilities.Task {{
                 expectedCodeType: RoslynCodeTaskFactoryCodeType.Method);
         }
 
+        [Fact]
+        public void CSharpClassSourceCodeFromFile()
+        {
+            const string taskClassSourceCode = @"namespace InlineTask
+{
+    using Microsoft.Build.Utilities;
+
+    public class HelloWorld : Task
+    {
+        public override bool Execute()
+        {
+            Log.LogMessage(""Hello, world!"");
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
+";
+
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile(fileName: "CSharpClassSourceCodeFromFile.tmp", contents: taskClassSourceCode);
+
+                TryLoadTaskBodyAndExpectSuccess(
+                    $"<Code Source=\"{file.Path}\" />",
+                    expectedSourceCode: taskClassSourceCode,
+                    expectedCodeType: RoslynCodeTaskFactoryCodeType.Class,
+                    expectedCodeLanguage: "CS");
+            }
+        }
+
         [Fact]
         public void CSharpFragmentSourceCodeFromFile()
         {
@@ -969,6 +1027,47 @@ public void SourceCodeFromFile()
             }
         }
 
+        [Fact]
+        public void MismatchedTaskNameAndTaskClassName()
+        {
+            const string taskName = "SayHello";
+            const string className = "HelloWorld";
+            taskName.ShouldNotBe(className, "The test is misconfigured.");
+            string errorMessage = string.Format(ResourceUtilities.GetResourceString("CodeTaskFactory.CouldNotFindTaskInAssembly"), taskName);
+
+            const string projectContent = @"<Project>
+  <UsingTask TaskName=""" + taskName + @""" TaskFactory=""RoslynCodeTaskFactory"" AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"">
+    <Task>
+      <Code Type=""Class"">
+namespace InlineTask
+{
+    using Microsoft.Build.Utilities;
+
+    public class " + className + @" : Task
+    {
+        public override bool Execute()
+        {
+            Log.LogMessage(""Hello, world!"");
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
+      </Code>
+    </Task>
+  </UsingTask>
+  <Target Name=""Build"">
+    <" + taskName + @" />
+  </Target>
+</Project>";
+
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles(projectContent);
+                var logger = proj.BuildProjectExpectFailure();
+                logger.AssertLogContains(errorMessage);
+            }
+        }
+
         private void TryLoadTaskBodyAndExpectFailure(string taskBody, string expectedErrorMessage)
         {
             if (expectedErrorMessage == null)
diff --git a/src/Tasks.UnitTests/Touch_Tests.cs b/src/Tasks.UnitTests/Touch_Tests.cs
index d87d2e5a65d..72117637d4a 100644
--- a/src/Tasks.UnitTests/Touch_Tests.cs
+++ b/src/Tasks.UnitTests/Touch_Tests.cs
@@ -332,5 +332,80 @@ public void TouchNonExistingDirectoryDoesntExist()
             Assert.Contains("MSB3371", engine.Log);
             Assert.Contains(nonexisting_txt, engine.Log);
         }
+
+        /// <summary>
+        /// Question touch on non-existing file should return false.
+        /// </summary>
+        [Fact]
+        public void QuestionTouchNonExisting()
+        {
+            Touch t = new Touch();
+            MockEngine engine = new MockEngine();
+            t.BuildEngine = engine;
+            t.FailIfNotIncremental = true;
+
+            t.Files = new ITaskItem[]
+            {
+                new TaskItem(mynonexisting_txt)
+            };
+
+            bool success = Execute(t);
+
+            // Not success because the file doesn't exist
+            Assert.False(success);
+
+            Assert.Contains(
+                String.Format(AssemblyResources.GetString("Touch.FileDoesNotExist"), mynonexisting_txt),
+                engine.Log);
+        }
+
+        /// <summary>
+        /// Question touch on a non-existing file with AlwaysCreate property should return false.
+        /// </summary>
+        [Fact]
+        public void QuestionTouchNonExistingAlwaysCreate()
+        {
+            Touch t = new Touch();
+            MockEngine engine = new MockEngine();
+            t.BuildEngine = engine;
+            t.FailIfNotIncremental = true;
+            t.AlwaysCreate = true;
+            t.Files = new ITaskItem[]
+            {
+                new TaskItem(mynonexisting_txt)
+            };
+
+            bool success = Execute(t);
+
+            Assert.False(success);
+
+            Assert.Contains(
+                String.Format(AssemblyResources.GetString("Touch.CreatingFile"), mynonexisting_txt, "AlwaysCreate"),
+                engine.Log);
+        }
+
+        /// <summary>
+        /// Question touch should return true and the file is not touched.
+        /// </summary>
+        [Fact]
+        public void QuestionTouchExisting()
+        {
+            Touch t = new Touch();
+            MockEngine engine = new MockEngine();
+            t.BuildEngine = engine;
+            t.FailIfNotIncremental = true;
+            t.Files = new ITaskItem[]
+            {
+                new TaskItem(myexisting_txt)
+            };
+
+            bool success = Execute(t);
+
+            Assert.False(success);
+
+            Assert.Contains(
+                String.Format(AssemblyResources.GetString("Touch.Touching"), myexisting_txt),
+                engine.Log);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index 26de13ddc87..eb2dc83d338 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -60,19 +60,45 @@ public void CanUnzip()
 
                 TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
 
+                // Question new task, should be false.
                 Unzip unzip = new Unzip
                 {
                     BuildEngine = _mockEngine,
                     DestinationFolder = new TaskItem(destination.Path),
                     OverwriteReadOnlyFiles = true,
                     SkipUnchangedFiles = false,
-                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) }
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    FailIfNotIncremental = true,
                 };
+                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                _mockEngine.Log = string.Empty;
 
-                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                // Run the task.
+                Unzip unzip2 = new Unzip
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = false,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    FailIfNotIncremental = false,
+                };
+                unzip2.Execute().ShouldBeTrue(() => _mockEngine.Log);
 
                 _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), () => _mockEngine.Log);
                 _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), () => _mockEngine.Log);
+
+                // Question ran task, should be true
+                Unzip unzip3 = new Unzip
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = true,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    FailIfNotIncremental = true,
+                };
+                unzip3.Execute().ShouldBeTrue(() => _mockEngine.Log);
             }
         }
 
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index 893a3cfa3c4..d5495b9dfab 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -176,6 +176,119 @@ public void RedundantParametersAreLogged()
             engine.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", file);
         }
 
+        /// <summary>
+        /// Question WriteLines to return false when a write will be required.
+        /// </summary>
+        [Fact]
+        public void QuestionWriteLinesWriteOnlyWhenDifferentTest()
+        {
+            var file = FileUtilities.GetTemporaryFile();
+            try
+            {
+                // Write an initial file.
+                var a = new WriteLinesToFile
+                {
+                    Overwrite = true,
+                    BuildEngine = new MockEngine(_output),
+                    File = new TaskItem(file),
+                    WriteOnlyWhenDifferent = true,
+                    Lines = new ITaskItem[] { new TaskItem("File contents1") }
+                };
+
+                a.Execute().ShouldBeTrue();
+
+                // Verify contents
+                var r = new ReadLinesFromFile { File = new TaskItem(file) };
+                r.Execute().ShouldBeTrue();
+                r.Lines[0].ItemSpec.ShouldBe("File contents1");
+
+                var writeTime = DateTime.Now.AddHours(-1);
+
+                File.SetLastWriteTime(file, writeTime);
+
+                // Write the same contents to the file, timestamps should match.
+                var a2 = new WriteLinesToFile
+                {
+                    Overwrite = true,
+                    BuildEngine = new MockEngine(_output),
+                    File = new TaskItem(file),
+                    WriteOnlyWhenDifferent = true,
+                    Lines = new ITaskItem[] { new TaskItem("File contents1") },
+                    FailIfNotIncremental = true,
+                };
+                a2.Execute().ShouldBeTrue();
+                File.GetLastWriteTime(file).ShouldBe(writeTime, tolerance: TimeSpan.FromSeconds(1));
+
+                // Write different contents to the file, last write time should differ.
+                var a3 = new WriteLinesToFile
+                {
+                    Overwrite = true,
+                    BuildEngine = new MockEngine(_output),
+                    File = new TaskItem(file),
+                    WriteOnlyWhenDifferent = true,
+                    Lines = new ITaskItem[] { new TaskItem("File contents2") },
+                    FailIfNotIncremental = true,
+                };
+                a3.Execute().ShouldBeFalse();
+                File.GetLastWriteTime(file).ShouldBe(writeTime, tolerance: TimeSpan.FromSeconds(1));
+            }
+            finally
+            {
+                File.Delete(file);
+            }
+        }
+
+        /// <summary>
+        /// Question WriteLines to return true when Lines are empty.
+        /// </summary>
+        [Fact]
+        public void QuestionWriteLinesWhenLinesAreEmpty()
+        {
+            // Test the combination of:
+            // 1) File exists
+            // 2) Overwrite
+            // 3) WriteOnlyWhenDifferent
+
+            var fileExists = FileUtilities.GetTemporaryFile();
+            var fileNotExists = FileUtilities.GetTemporaryFileName();
+            try
+            {
+                TestWriteLines(fileExists, fileNotExists, Overwrite: true, WriteOnlyWhenDifferent: true);
+                TestWriteLines(fileExists, fileNotExists, Overwrite: false, WriteOnlyWhenDifferent: true);
+                TestWriteLines(fileExists, fileNotExists, Overwrite: true, WriteOnlyWhenDifferent: false);
+                TestWriteLines(fileExists, fileNotExists, Overwrite: false, WriteOnlyWhenDifferent: false);
+            }
+            finally
+            {
+                File.Delete(fileExists);
+            }
+
+            void TestWriteLines(string fileExists, string fileNotExists, bool Overwrite, bool WriteOnlyWhenDifferent)
+            {
+                var test1 = new WriteLinesToFile
+                {
+                    Overwrite = Overwrite,
+                    BuildEngine = new MockEngine(_output),
+                    File = new TaskItem(fileExists),
+                    WriteOnlyWhenDifferent = WriteOnlyWhenDifferent,
+                    FailIfNotIncremental = true,
+                    // Tests Lines = null.
+                };
+                test1.Execute().ShouldBeTrue();
+
+                var test2 = new WriteLinesToFile
+                {
+                    Overwrite = Overwrite,
+                    BuildEngine = new MockEngine(_output),
+                    File = new TaskItem(fileNotExists),
+                    WriteOnlyWhenDifferent = WriteOnlyWhenDifferent,
+                    FailIfNotIncremental = true,
+                    Lines = Array.Empty<ITaskItem>(),  // Test empty.
+                };
+                test2.Execute().ShouldBeTrue();
+            }
+        }
+
         /// <summary>
         /// Should create directory structure when target <see cref="WriteLinesToFile.File"/> does not exist.
         /// </summary>
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 10a4e43738a..e449c1e8dea 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -68,12 +68,10 @@ public sealed class XslTransformation_Tests
         private readonly string _xslDocument = "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:msxsl=\"urn:schemas-microsoft-com:xslt\" exclude-result-prefixes=\"msxsl\"><xsl:output method=\"xml\" indent=\"yes\"/><xsl:template match=\"@* | node()\"><surround><xsl:copy><xsl:apply-templates select=\"@* | node()\"/></xsl:copy></surround></xsl:template></xsl:stylesheet>";
 
 
-#if FEATURE_COMPILED_XSL
         /// <summary>
         /// The contents of another xsl document for tests
         /// </summary>
         private readonly string _xslDocument2 = "<?xml version = \"1.0\" ?><xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"><xsl:template match = \"myInclude\"><xsl:apply-templates select = \"document(@path)\"/></xsl:template><xsl:template match = \"@*|node()\"><xsl:copy><xsl:apply-templates select = \"@*|node()\"/></xsl:copy></xsl:template></xsl:stylesheet>";
-#endif
         /// <summary>
         /// The contents of xslparameters for tests.
         /// </summary>
@@ -1040,7 +1038,6 @@ public void MultipleXmlInputs_NotMatching()
             CleanUp(dir);
         }
 
-#if FEATURE_COMPILED_XSL
         /// <summary>
         /// Validate that the XslTransformation task allows use of the document function
         /// </summary>
@@ -1094,7 +1091,6 @@ public void XslDocumentFunctionWorks()
 
             CleanUp(dir);
         }
-#endif
 
         /// <summary>
         /// Prepares the test environment, creates necessary files.
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index 018a2ee5932..7f50e75cc29 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
 using System.Xml;
 
 using Microsoft.Build.Shared;
@@ -18,19 +19,22 @@ internal sealed class AppConfig
         /// <summary>
         /// Read the .config from a file.
         /// </summary>
-        /// <param name="appConfigFile"></param>
-        internal void Load(string appConfigFile)
+        /// <param name="appConfigFilePath"></param>
+        internal void Load(string appConfigFilePath)
         {
             XmlReader reader = null;
             try
             {
-                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true};
 
                 // it's important to normalize the path as it may contain two slashes
                 // see https://github.com/dotnet/msbuild/issues/4335 for details.
-                appConfigFile = FileUtilities.NormalizePath(appConfigFile);
+                appConfigFilePath = FileUtilities.NormalizePath(appConfigFilePath);
 
-                reader = XmlReader.Create(appConfigFile, readerSettings);
+                // Need a filestream as the XmlReader doesn't support nonstandard unicode characters in path.
+                // No need to dispose - as 'CloseInput' was passed to XmlReaderSettings
+                FileStream fs = File.OpenRead(appConfigFilePath);
+                reader = XmlReader.Create(fs, readerSettings);
                 Read(reader);
             }
             catch (XmlException e)
@@ -44,7 +48,7 @@ internal void Load(string appConfigFile)
                     linePosition = info.LinePosition;
                 }
 
-                throw new AppConfigException(e.Message, appConfigFile, lineNumber, linePosition, e);
+                throw new AppConfigException(e.Message, appConfigFilePath, lineNumber, linePosition, e);
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
@@ -57,7 +61,7 @@ internal void Load(string appConfigFile)
                     linePosition = info.LinePosition;
                 }
 
-                throw new AppConfigException(e.Message, appConfigFile, lineNumber, linePosition, e);
+                throw new AppConfigException(e.Message, appConfigFilePath, lineNumber, linePosition, e);
             }
             finally
             {
diff --git a/src/Tasks/AppConfig/AppConfigException.cs b/src/Tasks/AppConfig/AppConfigException.cs
index 82caefb8fc0..b059713b9da 100644
--- a/src/Tasks/AppConfig/AppConfigException.cs
+++ b/src/Tasks/AppConfig/AppConfigException.cs
@@ -66,6 +66,9 @@ public AppConfigException(string message, string fileName, int line, int column,
         /// <summary>
         /// Construct the exception.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected AppConfigException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
         }
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index 7aabd28ea93..51df4d81cad 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -183,26 +183,13 @@ private void LazyInitialize()
             }
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName">The sdkname of the reference.</param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index 00fbece8e58..2268765cfbf 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -151,26 +151,13 @@ private void LazyInitialize()
             }
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName">Not used by this type.</param>
-        /// <param name="rawFileNameCandidate">Not used by this type.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">Not used by this type.</param>
-        /// <param name="assemblyFolderKey">Not used by this type.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index 998e8abf552..9d1d89e75ab 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -27,26 +27,13 @@ public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAsse
         {
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName">The sdk name of the reference.</param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index a77c9b03360..2a247374d79 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -866,216 +866,216 @@ private class HeaderInfo
         }
 
         /// <summary>
-        /// Given a path get the CLR runtime version of the file
+        /// Given a path get the CLR runtime version of the file.
         /// </summary>
         /// <param name="path">path to the file</param>
         /// <returns>The CLR runtime version or empty if the path does not exist or the file is not an assembly.</returns>
         public static string GetRuntimeVersion(string path)
         {
-            using (var sr = new BinaryReader(File.OpenRead(path)))
+            if (!FileSystems.Default.FileExists(path))
             {
-                if (!FileSystems.Default.FileExists(path))
-                {
-                    return string.Empty;
-                }
-
-                // This algorithm for getting the runtime version is based on
-                // the ECMA Standard 335: The Common Language Infrastructure (CLI)
-                // http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf
+                return string.Empty;
+            }
 
-                try
-                {
-                    const uint PEHeaderPointerOffset = 0x3c;
-                    const uint PEHeaderSize = 20;
-                    const uint OptionalPEHeaderSize = 224;
-                    const uint OptionalPEPlusHeaderSize = 240;
-                    const uint SectionHeaderSize = 40;
+            using Stream stream = File.OpenRead(path);
+            using BinaryReader reader = new BinaryReader(stream);
+            return GetRuntimeVersion(reader);
+        }
 
-                    // The PE file format is specified in section II.25
+        /// <summary>
+        /// Given a <see cref="BinaryReader"/> get the CLR runtime version of the underlying file.
+        /// </summary>
+        /// <param name="sr">A <see cref="BinaryReader"/> positioned at the first byte of the file.</param>
+        /// <returns>The CLR runtime version or empty if the data does not represent an assembly.</returns>
+        internal static string GetRuntimeVersion(BinaryReader sr)
+        {
+            // This algorithm for getting the runtime version is based on
+            // the ECMA Standard 335: The Common Language Infrastructure (CLI)
+            // http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf
 
-                    // A PE image starts with an MS-DOS header followed by a PE signature, followed by the PE file header,
-                    // and then the PE optional header followed by PE section headers.
-                    // There must be room for all of that.
+            try
+            {
+                const uint PEHeaderPointerOffset = 0x3c;
+                const uint PEHeaderSize = 20;
+                const uint OptionalPEHeaderSize = 224;
+                const uint OptionalPEPlusHeaderSize = 240;
+                const uint SectionHeaderSize = 40;
 
-                    if (sr.BaseStream.Length < PEHeaderPointerOffset + 4 + PEHeaderSize + OptionalPEHeaderSize +
-                        SectionHeaderSize)
-                    {
-                        return string.Empty;
-                    }
+                // The PE file format is specified in section II.25
 
-                    // The PE format starts with an MS-DOS stub of 128 bytes.
-                    // At offset 0x3c in the DOS header is a 4-byte unsigned integer offset to the PE
-                    // signature (shall be ‚ÄúPE\0\0‚Äù), immediately followed by the PE file header
+                // A PE image starts with an MS-DOS header followed by a PE signature, followed by the PE file header,
+                // and then the PE optional header followed by PE section headers.
+                // There must be room for all of that.
 
-                    sr.BaseStream.Position = PEHeaderPointerOffset;
-                    var peHeaderOffset = sr.ReadUInt32();
+                if (sr.BaseStream.Length < PEHeaderPointerOffset + 4 + PEHeaderSize + OptionalPEHeaderSize +
+                    SectionHeaderSize)
+                {
+                    return string.Empty;
+                }
 
-                    if (peHeaderOffset + 4 + PEHeaderSize + OptionalPEHeaderSize + SectionHeaderSize >=
-                        sr.BaseStream.Length)
-                    {
-                        return string.Empty;
-                    }
+                // The PE format starts with an MS-DOS stub of 128 bytes.
+                // At offset 0x3c in the DOS header is a 4-byte unsigned integer offset to the PE
+                // signature (shall be ‚ÄúPE\0\0‚Äù), immediately followed by the PE file header
 
-                    // The PE header is specified in section II.25.2
-                    // Read the PE header signature
+                sr.BaseStream.Position = PEHeaderPointerOffset;
+                var peHeaderOffset = sr.ReadUInt32();
 
-                    sr.BaseStream.Position = peHeaderOffset;
-                    if (!ReadBytes(sr, (byte)'P', (byte)'E', 0, 0))
-                    {
-                        return string.Empty;
-                    }
+                if (peHeaderOffset + 4 + PEHeaderSize + OptionalPEHeaderSize + SectionHeaderSize >=
+                    sr.BaseStream.Length)
+                {
+                    return string.Empty;
+                }
 
-                    // The PE header immediately follows the signature
-                    var peHeaderBase = peHeaderOffset + 4;
+                // The PE header is specified in section II.25.2
+                // Read the PE header signature
 
-                    // At offset 2 of the PE header there is the number of sections
-                    sr.BaseStream.Position = peHeaderBase + 2;
-                    var numberOfSections = sr.ReadUInt16();
-                    if (numberOfSections > 96)
-                    {
-                        return string.Empty; // There can't be more than 96 sections, something is wrong
-                    }
+                sr.BaseStream.Position = peHeaderOffset;
+                if (!ReadBytes(sr, (byte)'P', (byte)'E', 0, 0))
+                {
+                    return string.Empty;
+                }
 
-                    // Immediately after the PE Header is the PE Optional Header.
-                    // This header is optional in the general PE spec, but always
-                    // present in assembly files.
-                    // From this header we'll get the CLI header RVA, which is
-                    // at offset 208 for PE32, and at offset 224 for PE32+
+                // The PE header immediately follows the signature
+                var peHeaderBase = peHeaderOffset + 4;
 
-                    var optionalHeaderOffset = peHeaderBase + PEHeaderSize;
+                // At offset 2 of the PE header there is the number of sections
+                sr.BaseStream.Position = peHeaderBase + 2;
+                var numberOfSections = sr.ReadUInt16();
+                if (numberOfSections > 96)
+                {
+                    return string.Empty; // There can't be more than 96 sections, something is wrong
+                }
 
-                    uint cliHeaderRvaOffset;
-                    uint optionalPEHeaderSize;
+                // Immediately after the PE Header is the PE Optional Header.
+                // This header is optional in the general PE spec, but always
+                // present in assembly files.
+                // From this header we'll get the CLI header RVA, which is
+                // at offset 208 for PE32, and at offset 224 for PE32+
 
-                    sr.BaseStream.Position = optionalHeaderOffset;
-                    var magicNumber = sr.ReadUInt16();
+                var optionalHeaderOffset = peHeaderBase + PEHeaderSize;
 
-                    if (magicNumber == 0x10b) // PE32
-                    {
-                        optionalPEHeaderSize = OptionalPEHeaderSize;
-                        cliHeaderRvaOffset = optionalHeaderOffset + 208;
-                    }
-                    else if (magicNumber == 0x20b) // PE32+
-                    {
-                        optionalPEHeaderSize = OptionalPEPlusHeaderSize;
-                        cliHeaderRvaOffset = optionalHeaderOffset + 224;
-                    }
-                    else
-                    {
-                        return string.Empty;
-                    }
+                uint cliHeaderRvaOffset;
+                uint optionalPEHeaderSize;
 
-                    // Read the CLI header RVA
+                sr.BaseStream.Position = optionalHeaderOffset;
+                var magicNumber = sr.ReadUInt16();
 
-                    sr.BaseStream.Position = cliHeaderRvaOffset;
-                    var cliHeaderRva = sr.ReadUInt32();
-                    if (cliHeaderRva == 0)
-                    {
-                        return string.Empty; // No CLI section
-                    }
+                if (magicNumber == 0x10b) // PE32
+                {
+                    optionalPEHeaderSize = OptionalPEHeaderSize;
+                    cliHeaderRvaOffset = optionalHeaderOffset + 208;
+                }
+                else if (magicNumber == 0x20b) // PE32+
+                {
+                    optionalPEHeaderSize = OptionalPEPlusHeaderSize;
+                    cliHeaderRvaOffset = optionalHeaderOffset + 224;
+                }
+                else
+                {
+                    return string.Empty;
+                }
 
-                    // Immediately following the optional header is the Section
-                    // Table, which contains a number of section headers.
-                    // Section headers are specified in section II.25.3
+                // Read the CLI header RVA
 
-                    // Each section header has the base RVA, size, and file
-                    // offset of the section. To find the file offset of the
-                    // CLI header we need to find a section that contains
-                    // its RVA, and the calculate the file offset using
-                    // the base file offset of the section.
+                sr.BaseStream.Position = cliHeaderRvaOffset;
+                var cliHeaderRva = sr.ReadUInt32();
+                if (cliHeaderRva == 0)
+                {
+                    return string.Empty; // No CLI section
+                }
 
-                    var sectionOffset = optionalHeaderOffset + optionalPEHeaderSize;
+                // Immediately following the optional header is the Section
+                // Table, which contains a number of section headers.
+                // Section headers are specified in section II.25.3
 
-                    // Read all section headers, we need them to make RVA to
-                    // offset conversions.
+                // Each section header has the base RVA, size, and file
+                // offset of the section. To find the file offset of the
+                // CLI header we need to find a section that contains
+                // its RVA, and the calculate the file offset using
+                // the base file offset of the section.
 
-                    var sections = new HeaderInfo[numberOfSections];
-                    for (int n = 0; n < numberOfSections; n++)
-                    {
-                        // At offset 8 of the section is the section size
-                        // and base RVA. At offset 20 there is the file offset
-                        sr.BaseStream.Position = sectionOffset + 8;
-                        var sectionSize = sr.ReadUInt32();
-                        var sectionRva = sr.ReadUInt32();
-                        sr.BaseStream.Position = sectionOffset + 20;
-                        var sectionDataOffset = sr.ReadUInt32();
-                        sections[n] = new HeaderInfo
-                        {
-                            VirtualAddress = sectionRva,
-                            Size = sectionSize,
-                            FileOffset = sectionDataOffset
-                        };
-                        sectionOffset += SectionHeaderSize;
-                    }
+                var sectionOffset = optionalHeaderOffset + optionalPEHeaderSize;
 
-                    uint cliHeaderOffset = RvaToOffset(sections, cliHeaderRva);
+                // Read all section headers, we need them to make RVA to
+                // offset conversions.
 
-                    // CLI section not found
-                    if (cliHeaderOffset == 0)
+                var sections = new HeaderInfo[numberOfSections];
+                for (int n = 0; n < numberOfSections; n++)
+                {
+                    // At offset 8 of the section is the section size
+                    // and base RVA. At offset 20 there is the file offset
+                    sr.BaseStream.Position = sectionOffset + 8;
+                    var sectionSize = sr.ReadUInt32();
+                    var sectionRva = sr.ReadUInt32();
+                    sr.BaseStream.Position = sectionOffset + 20;
+                    var sectionDataOffset = sr.ReadUInt32();
+                    sections[n] = new HeaderInfo
                     {
-                        return string.Empty;
-                    }
-
-                    // The CLI header is specified in section II.25.3.3.
-                    // It contains all of the runtime-specific data entries and other information.
-                    // From the CLI header we need to get the RVA of the metadata root,
-                    // which is located at offset 8.
-
-                    sr.BaseStream.Position = cliHeaderOffset + 8;
-                    var metadataRva = sr.ReadUInt32();
+                        VirtualAddress = sectionRva,
+                        Size = sectionSize,
+                        FileOffset = sectionDataOffset
+                    };
+                    sectionOffset += SectionHeaderSize;
+                }
 
-                    var metadataOffset = RvaToOffset(sections, metadataRva);
-                    if (metadataOffset == 0)
-                    {
-                        return string.Empty;
-                    }
+                uint cliHeaderOffset = RvaToOffset(sections, cliHeaderRva);
 
-                    // The metadata root is specified in section II.24.2.1
-                    // The first 4 bytes contain a signature.
-                    // The version string is at offset 12.
+                // CLI section not found
+                if (cliHeaderOffset == 0)
+                {
+                    return string.Empty;
+                }
 
-                    sr.BaseStream.Position = metadataOffset;
-                    if (!ReadBytes(sr, 0x42, 0x53, 0x4a, 0x42)) // Metadata root signature
-                    {
-                        return string.Empty;
-                    }
+                // The CLI header is specified in section II.25.3.3.
+                // It contains all of the runtime-specific data entries and other information.
+                // From the CLI header we need to get the RVA of the metadata root,
+                // which is located at offset 8.
 
-                    // Read the version string length
-                    sr.BaseStream.Position = metadataOffset + 12;
-                    var length = sr.ReadInt32();
-                    if (length > 255 || length <= 0 || sr.BaseStream.Position + length >= sr.BaseStream.Length)
-                    {
-                        return string.Empty;
-                    }
+                sr.BaseStream.Position = cliHeaderOffset + 8;
+                var metadataRva = sr.ReadUInt32();
 
-                    // Read the version string
-                    var v = Encoding.UTF8.GetString(sr.ReadBytes(length));
-                    if (v.Length < 2 || v[0] != 'v')
-                    {
-                        return string.Empty;
-                    }
+                var metadataOffset = RvaToOffset(sections, metadataRva);
+                if (metadataOffset == 0)
+                {
+                    return string.Empty;
+                }
 
-                    // Per II.24.2.1, version string length is rounded up
-                    // to a multiple of 4. So we may read eg "4.0.30319\0\0"
-                    // Version.Parse works fine, but it's not pretty in the log.
-                    int firstNull = v.IndexOf('\0');
-                    if (firstNull > 0)
-                    {
-                        v = v.Substring(0, firstNull);
-                    }
+                // The metadata root is specified in section II.24.2.1
+                // The first 4 bytes contain a signature.
+                // The version string is at offset 12.
 
-                    // Make sure it is a version number
-                    if (!Version.TryParse(v.Substring(1), out _))
-                    {
-                        return string.Empty;
-                    }
-                    return v;
+                sr.BaseStream.Position = metadataOffset;
+                if (!ReadBytes(sr, 0x42, 0x53, 0x4a, 0x42)) // Metadata root signature
+                {
+                    return string.Empty;
                 }
-                catch
+
+                // Read the version string length
+                sr.BaseStream.Position = metadataOffset + 12;
+                var length = sr.ReadInt32();
+                if (length > 255 || length <= 0 || sr.BaseStream.Position + length >= sr.BaseStream.Length)
                 {
-                    // Something went wrong in spite of all checks. Corrupt file?
                     return string.Empty;
                 }
+
+                // Read the version string
+                var v = Encoding.UTF8.GetString(sr.ReadBytes(length));
+
+                // Per II.24.2.1, version string length is rounded up
+                // to a multiple of 4. So we may read eg "4.0.30319\0\0"
+                // Version.Parse works fine, but it's not pretty in the log.
+                int firstNull = v.IndexOf('\0');
+                if (firstNull > 0)
+                {
+                    v = v.Substring(0, firstNull);
+                }
+
+                return v;
+            }
+            catch
+            {
+                // Something went wrong in spite of all checks. Corrupt file?
+                return string.Empty;
             }
         }
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyNameReference.cs b/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
index 91f87bd654e..818a00a7fe4 100644
--- a/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
@@ -19,7 +19,7 @@ internal struct AssemblyNameReference : IComparable<AssemblyNameReference>
         /// <summary>
         /// Display as string.
         /// </summary>
-        public override string ToString()
+        public override readonly string ToString()
         {
             return assemblyName + ", " + reference;
         }
@@ -27,7 +27,7 @@ public override string ToString()
         /// <summary>
         /// Compare by assembly name.
         /// </summary>
-        public int CompareTo(AssemblyNameReference other)
+        public readonly int CompareTo(AssemblyNameReference other)
         {
             return assemblyName.CompareTo(other.assemblyName);
         }
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index 2653a30a416..0d6ba23d997 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -34,6 +34,7 @@ internal static class AssemblyResolution
         /// <param name="sdkName"></param>
         /// <param name="rawFileNameCandidate">The file name to match if {RawFileName} is seen. (May be null).</param>
         /// <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
+        /// <param name="isImmutableFrameworkReference">True if <paramref name="rawFileNameCandidate"/> is immutable and guaranteed to exist.</param>
         /// <param name="wantSpecificVersion"></param>
         /// <param name="executableExtensions">The filename extension of the assembly. Must be this or its no match.</param>
         /// <param name="hintPath">This reference's hintpath</param>
@@ -48,6 +49,7 @@ internal static string ResolveReference(
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
@@ -79,6 +81,7 @@ internal static string ResolveReference(
                             sdkName,
                             rawFileNameCandidate,
                             isPrimaryProjectReference,
+                            isImmutableFrameworkReference,
                             wantSpecificVersion,
                             executableExtensions,
                             hintPath,
diff --git a/src/Tasks/AssemblyDependency/BadImageReferenceException.cs b/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
index 8a9cadcc29a..a6567717294 100644
--- a/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
+++ b/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
@@ -25,6 +25,9 @@ internal BadImageReferenceException(string message, Exception innerException)
         /// <summary>
         /// Construct
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private BadImageReferenceException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index 352b3e463a3..328bb6984a2 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -36,26 +36,13 @@ public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string se
             _candidateAssemblyFiles = candidateAssemblyFiles;
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/DependencyResolutionException.cs b/src/Tasks/AssemblyDependency/DependencyResolutionException.cs
index 402e4999988..2e174dadc3b 100644
--- a/src/Tasks/AssemblyDependency/DependencyResolutionException.cs
+++ b/src/Tasks/AssemblyDependency/DependencyResolutionException.cs
@@ -25,6 +25,9 @@ internal DependencyResolutionException(string message, Exception innerException)
         /// <summary>
         /// Construct
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private DependencyResolutionException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
diff --git a/src/Tasks/AssemblyDependency/DirectoryResolver.cs b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
index be0fe39554d..fedf7c18e38 100644
--- a/src/Tasks/AssemblyDependency/DirectoryResolver.cs
+++ b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
@@ -22,26 +22,13 @@ public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyNa
         {
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
index d51805918d3..cd57aa7d6b5 100644
--- a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
@@ -30,26 +30,13 @@ public FrameworkPathResolver(string[] frameworkPaths, InstalledAssemblies instal
             _installedAssemblies = installedAssemblies;
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/GacResolver.cs b/src/Tasks/AssemblyDependency/GacResolver.cs
index ac47511c1dc..bf416cc56ed 100644
--- a/src/Tasks/AssemblyDependency/GacResolver.cs
+++ b/src/Tasks/AssemblyDependency/GacResolver.cs
@@ -35,26 +35,13 @@ public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchit
             _getAssemblyPathInGac = getAssemblyPathInGac;
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assembly name object of the assembly.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index fbb3c2470cb..86bab7e2f57 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -1,4 +1,4 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -9,6 +9,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using System.IO;
 
 #nullable disable
 
@@ -103,8 +104,9 @@ public override bool Execute()
             runtimeNode.Add(redirectNodes);
 
             var writeOutput = true;
+            var outputExists = FileSystems.Default.FileExists(OutputAppConfigFile.ItemSpec);
 
-            if (FileSystems.Default.FileExists(OutputAppConfigFile.ItemSpec))
+            if (outputExists)
             {
                 try
                 {
@@ -131,6 +133,7 @@ public override bool Execute()
 
             if (writeOutput)
             {
+                Log.LogMessageFromResources(MessageImportance.Low, "GenerateBindingRedirects.CreatingBindingRedirectionFile", OutputAppConfigFile.ItemSpec);
                 using (var stream = FileUtilities.OpenWrite(OutputAppConfigFile.ItemSpec, false))
                 {
                     doc.Save(stream);
diff --git a/src/Tasks/AssemblyDependency/HintPathResolver.cs b/src/Tasks/AssemblyDependency/HintPathResolver.cs
index 1ae57169ce7..96a3b920491 100644
--- a/src/Tasks/AssemblyDependency/HintPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/HintPathResolver.cs
@@ -23,26 +23,13 @@ public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyNam
         {
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs b/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
index 42838f8dc21..55287a96840 100644
--- a/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
+++ b/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
@@ -26,6 +26,9 @@ internal InvalidReferenceAssemblyNameException(string sourceItemSpec)
         /// <summary>
         /// Construct
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InvalidReferenceAssemblyNameException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
         }
diff --git a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
index 5273445e3f8..72f1afb79a2 100644
--- a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
+++ b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
@@ -23,26 +23,13 @@ public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssembly
         {
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
@@ -57,7 +44,7 @@ public override bool Resolve(
             if (rawFileNameCandidate != null)
             {
                 // {RawFileName} was passed in.
-                if (fileExists(rawFileNameCandidate))
+                if (isImmutableFrameworkReference || fileExists(rawFileNameCandidate))
                 {
                     userRequestedSpecificFile = true;
                     foundPath = rawFileNameCandidate;
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index f25e796f1a7..5819184dc59 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -226,7 +226,7 @@ internal void AddDependee(Reference dependee)
         }
 
         /// <summary>
-        /// A dependee may be removed because it or its dependee's are in the black list
+        /// A dependee may be removed because it or its dependee's are in the deny list
         /// </summary>
         internal void RemoveDependee(Reference dependeeToRemove)
         {
@@ -234,7 +234,7 @@ internal void RemoveDependee(Reference dependeeToRemove)
         }
 
         /// <summary>
-        /// A dependency may be removed because it may not be referenced any more due this reference being in the black list or being removed due to it depending on something in the black list
+        /// A dependency may be removed because it may not be referenced any more due this reference being in the deny list or being removed due to it depending on something in the deny list
         /// </summary>
         internal void RemoveDependency(Reference dependencyToRemove)
         {
@@ -1140,7 +1140,7 @@ public override string ToString()
 
         /// <summary>
         /// There are a number of properties which are set when we generate exclusion lists and it is useful to have this information on the references so that
-        /// the correct reasons can be logged for these references being in the black list.
+        /// the correct reasons can be logged for these references being in the deny list.
         /// </summary>
         internal class ExclusionListProperties
         {
diff --git a/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs b/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs
index 621d8834891..c924e806f07 100644
--- a/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs
@@ -25,6 +25,9 @@ internal ReferenceResolutionException(string message, Exception innerException)
         /// <summary>
         /// Implement required constructors for serialization
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private ReferenceResolutionException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
         }
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 4272a5e149e..d6636913a1f 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -40,6 +40,11 @@ internal sealed class ReferenceTable
         /// </summary>
         private readonly HashSet<string> _externallyResolvedPrimaryReferences = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
+        /// <summary>
+        /// The keys are normalized full paths of primary references resolved by an external entity to RAR and considered immutable, the values are assembly names or null if not known.
+        /// </summary>
+        private readonly Dictionary<string, AssemblyNameExtension> _externallyResolvedImmutableFiles = new Dictionary<string, AssemblyNameExtension>(StringComparer.OrdinalIgnoreCase);
+
         /// <summary>The table of remapped assemblies. Used for Unification.</summary>
         private IEnumerable<DependentAssembly> _remappedAssemblies = Enumerable.Empty<DependentAssembly>();
 
@@ -148,9 +153,9 @@ internal sealed class ReferenceTable
 
         /// <summary>
         /// When we exclude an assembly from resolution because it is part of out exclusion list we need to let the user know why this is.
-        /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different black list. We need to log a specific message
-        /// depending on which black list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a black list so that when we
-        /// discover an assembly in the black list we can log the correct message.
+        /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different deny list. We need to log a specific message
+        /// depending on which deny list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a deny list so that when we
+        /// discover an assembly in the deny list we can log the correct message.
         /// </summary>
         internal delegate void LogExclusionReason(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
 
@@ -823,6 +828,33 @@ private static void TryGetAssemblyNameComponent(string fusionName, string compon
             }
         }
 
+        /// <summary>
+        /// Tries to create an <see cref="AssemblyNameExtension"/> out of a primary reference metadata.
+        /// </summary>
+        private static AssemblyNameExtension GetAssemblyNameFromItemMetadata(ITaskItem item)
+        {
+            string version = item.GetMetadata(ItemMetadataNames.assemblyVersion);
+            if (string.IsNullOrEmpty(version))
+            {
+                return null;
+            }
+
+            string publicKeyToken = item.GetMetadata(ItemMetadataNames.publicKeyToken);
+            if (string.IsNullOrEmpty(publicKeyToken))
+            {
+                return null;
+            }
+
+            string name = item.GetMetadata(ItemMetadataNames.assemblyName);
+            if (string.IsNullOrEmpty(name))
+            {
+                // Fall back to inferring assembly name from file name.
+                name = item.GetMetadata(FileUtilities.ItemSpecModifiers.Filename);
+            }
+
+            return new AssemblyNameExtension($"{name}, Version={version}, Culture=neutral, PublicKeyToken={publicKeyToken}");
+        }
+
         /// <summary>
         /// Given an item that refers to a file name, make it a primary reference.
         /// </summary>
@@ -1225,6 +1257,17 @@ private void ResolveReference(
             string rawFileNameCandidate,
             Reference reference)
         {
+            bool isImmutableFrameworkReference = false;
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+            {
+                // For a path to be an immutable reference, it must be externally resolved and has a FrameworkReferenceName defined.
+                if (assemblyName == null && !string.IsNullOrEmpty(rawFileNameCandidate) && reference.IsPrimary && reference.ExternallyResolved)
+                {
+                    string frameworkReferenceName = reference.PrimarySourceItem.GetMetadata(ItemMetadataNames.frameworkReferenceName);
+                    isImmutableFrameworkReference = !string.IsNullOrEmpty(frameworkReferenceName);
+                }
+            }
+
             // Now, resolve this reference.
             string resolvedPath = null;
             string resolvedSearchPath = String.Empty;
@@ -1272,6 +1315,7 @@ private void ResolveReference(
                     reference.SDKName,
                     rawFileNameCandidate,
                     reference.IsPrimary,
+                    isImmutableFrameworkReference,
                     reference.WantSpecificVersion,
                     reference.GetExecutableExtensions(_allowedAssemblyExtensions),
                     reference.HintPath,
@@ -1291,7 +1335,13 @@ private void ResolveReference(
             // If the path was resolved, then specify the full path on the reference.
             if (resolvedPath != null)
             {
-                reference.FullPath = FileUtilities.NormalizePath(resolvedPath);
+                resolvedPath = FileUtilities.NormalizePath(resolvedPath);
+                if (isImmutableFrameworkReference)
+                {
+                    _externallyResolvedImmutableFiles[resolvedPath] = GetAssemblyNameFromItemMetadata(reference.PrimarySourceItem);
+                }
+                reference.FullPath = resolvedPath;
+
                 reference.ResolvedSearchPath = resolvedSearchPath;
                 reference.UserRequestedSpecificFile = userRequestedSpecificFile;
             }
@@ -1308,15 +1358,15 @@ private void ResolveReference(
         }
 
         /// <summary>
-        /// This method will remove references from the reference table which are contained in the blacklist.
-        /// References which are primary references but are in the black list will be placed in the invalidResolvedFiles list.
-        /// References which are dependency references but are in the black list will be placed in the invalidResolvedDependencyFiles list.
+        /// This method will remove references from the reference table which are contained in the denylist.
+        /// References which are primary references but are in the deny list will be placed in the invalidResolvedFiles list.
+        /// References which are dependency references but are in the deny list will be placed in the invalidResolvedDependencyFiles list.
         /// </summary>
         internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, string subsetName)
         {
             MSBuildEventSource.Log.RarRemoveReferencesMarkedForExclusionStart();
             {
-                // Create a table which will contain the references which are not in the black list
+                // Create a table which will contain the references which are not in the deny list
                 var goodReferences = new Dictionary<AssemblyNameExtension, Reference>(AssemblyNameComparer.GenericComparer);
 
                 // List of references which were removed from the reference table, we will loop through these and make sure that we get rid of the dependent references also.
@@ -1330,7 +1380,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     subsetName = String.Empty;
                 }
 
-                // Go through each of the references, we go through this table because in general it will be considerably smaller than the blacklist. (10's of references vs 100's of black list items)
+                // Go through each of the references, we go through this table because in general it will be considerably smaller than the denylist. (10's of references vs 100's of deny list items)
                 foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
                 {
                     AssemblyNameExtension assemblyName = assembly.Key;
@@ -1338,14 +1388,14 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
 
                     AddToDependencyGraph(dependencyGraph, assemblyName, assemblyReference);
 
-                    // Is the assembly name not in the black list. This means the assembly could be allowed.
+                    // Is the assembly name not in the deny list. This means the assembly could be allowed.
                     bool isMarkedForExclusion = assemblyReference.ExclusionListLoggingProperties.IsInExclusionList;
                     LogExclusionReason logExclusionReason = assemblyReference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate;
 
                     // Case one, the assembly is a primary reference
                     if (assemblyReference.IsPrimary)
                     {
-                        // The assembly is good if it is not in the black list or it has specific version set to true.
+                        // The assembly is good if it is not in the deny list or it has specific version set to true.
                         if (!isMarkedForExclusion || assemblyReference.WantSpecificVersion)
                         {
                             // Do not add the reference to the good list if it has been added to the removed references list, possibly because of us processing another reference.
@@ -1364,16 +1414,16 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     // the current primary reference and they need to be removed.
                     ICollection<ITaskItem> dependees = assemblyReference.GetSourceItems();
 
-                    // Need to deal with dependencies, this can also include primary references who are dependencies themselves and are in the black list
+                    // Need to deal with dependencies, this can also include primary references who are dependencies themselves and are in the deny list
                     if (!assemblyReference.IsPrimary || (assemblyReference.IsPrimary && isMarkedForExclusion && (dependees?.Count > 1)))
                     {
                         // Does the assembly have specific version true, or does any of its primary parent references have specific version true.
-                        // This is checked because, if an assembly is in the black list, the only way it can possibly be allowed is if
+                        // This is checked because, if an assembly is in the deny list, the only way it can possibly be allowed is if
                         // ANY of the primary references which caused it have specific version set to true. To see if any primary references have the metadata we pass true to the method indicating 
                         // we want to know if any primary references have specific version set to true.
                         bool hasSpecificVersionTrue = assemblyReference.CheckForSpecificVersionMetadataOnParentsReference(true);
 
-                        // A dependency is "good" if it is not in the black list or any of its parents have specific version set to true
+                        // A dependency is "good" if it is not in the deny list or any of its parents have specific version set to true
                         if (!isMarkedForExclusion || hasSpecificVersionTrue)
                         {
                             // Do not add the reference to the good list if it has been added to the removed references list, possibly because of us processing another reference.
@@ -1383,8 +1433,8 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                             }
                         }
 
-                        // If the dependency is in the black list we need to remove the primary references which depend on this refernce.
-                        // note, a reference can both be in the good references list and in the black list. This can happen if a multiple primary references
+                        // If the dependency is in the deny list we need to remove the primary references which depend on this refernce.
+                        // note, a reference can both be in the good references list and in the deny list. This can happen if a multiple primary references
                         // depend on a single dependency. The dependency can be good for one reference but not allowed for the other.
                         if (isMarkedForExclusion)
                         {
@@ -1429,7 +1479,7 @@ private static void AddToDependencyGraph(Dictionary<Reference, List<ReferenceAss
         }
 
         /// <summary>
-        /// We have determined the given assembly reference is in the black list, we now need to find the primary references which caused it and make sure those are removed from the list of references.
+        /// We have determined the given assembly reference is in the deny list, we now need to find the primary references which caused it and make sure those are removed from the list of references.
         /// </summary>
         private void RemoveDependencyMarkedForExclusion(LogExclusionReason logExclusionReason, bool removeOnlyNoWarning, string subsetName, Dictionary<AssemblyNameExtension, Reference> goodReferences, List<Reference> removedReferences, AssemblyNameExtension assemblyName, Reference assemblyReference)
         {
@@ -1477,7 +1527,7 @@ private void RemoveDependencyMarkedForExclusion(LogExclusionReason logExclusionR
         }
 
         /// <summary>
-        /// A primary references has been determined to be in the black list, it needs to be removed from the list of references by not being added to the list of good references
+        /// A primary references has been determined to be in the deny list, it needs to be removed from the list of references by not being added to the list of good references
         /// and added to the list of removed references.
         /// </summary>
         private static void RemovePrimaryReferenceMarkedForExclusion(LogExclusionReason logExclusionReason, bool removeOnlyNoWarning, string subsetName, List<Reference> removedReferences, AssemblyNameExtension assemblyName, Reference assemblyReference)
@@ -1510,7 +1560,7 @@ internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec)
 
         /// <summary>
         /// Go through the dependency graph and make sure that for a reference to remove that we get rid of all dependency assemblies which are not referenced by any other
-        /// assembly. The remove reference list should contain ALL primary references which should be removed because they, or one of their dependencies is in the black list.
+        /// assembly. The remove reference list should contain ALL primary references which should be removed because they, or one of their dependencies is in the deny list.
         /// </summary>
         /// <param name="removedReference">Reference to remove dependencies for</param>
         /// <param name="referenceList">Reference list which contains reference to be used in unification and returned as resolved items</param>
@@ -2626,36 +2676,9 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
             // Set up the main item.
             TaskItem referenceItem = new TaskItem();
             referenceItem.ItemSpec = reference.FullPath;
-            referenceItem.SetMetadata(ItemMetadataNames.resolvedFrom, reference.ResolvedSearchPath);
 
-            // Set the CopyLocal metadata.
-            referenceItem.SetMetadata(ItemMetadataNames.copyLocal, reference.IsCopyLocal ? "true" : "false");
-
-            // Set the Redist name metadata.
-            if (!String.IsNullOrEmpty(reference.RedistName))
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.redist, reference.RedistName);
-            }
-
-            if (Reference.IsFrameworkFile(reference.FullPath, _frameworkPaths) || (_installedAssemblies?.FrameworkAssemblyEntryInRedist(assemblyName) == true))
-            {
-                if (!IsAssemblyRemovedFromDotNetFramework(assemblyName, reference.FullPath, _frameworkPaths, _installedAssemblies))
-                {
-                    referenceItem.SetMetadata(ItemMetadataNames.frameworkFile, "true");
-                }
-            }
-
-            if (!String.IsNullOrEmpty(reference.ImageRuntime))
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.imageRuntime, reference.ImageRuntime);
-            }
-
-            // The redist root is "null" when there was no IsRedistRoot flag in the Redist XML
-            // (or there was no redist XML at all for this item).
-            if (reference.IsRedistRoot != null)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, (bool)reference.IsRedistRoot ? "true" : "false");
-            }
+            IMetadataContainer referenceItemAsMetadataContainer = referenceItem;
+            referenceItemAsMetadataContainer.ImportMetadata(EnumerateCommonMetadata());
 
             // If there was a primary source item, then forward metadata from it.
             // It's important that the metadata from the primary source item
@@ -2829,13 +2852,45 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
             // nonForwardableMetadata should be null here if relatedFileExtensions, satellites, serializationAssemblyFiles, and scatterFiles were all empty.
             if (nonForwardableMetadata != null)
             {
-                foreach (KeyValuePair<string, string> kvp in nonForwardableMetadata)
-                {
-                    referenceItem.SetMetadata(kvp.Key, kvp.Value);
-                }
+                referenceItemAsMetadataContainer.ImportMetadata(nonForwardableMetadata);
             }
 
             return referenceItem;
+
+            // Enumerate common metadata with an iterator to allow using a more efficient bulk-set operation.
+            IEnumerable<KeyValuePair<string, string>> EnumerateCommonMetadata()
+            {
+                yield return new KeyValuePair<string, string>(ItemMetadataNames.resolvedFrom, reference.ResolvedSearchPath);
+
+                // Set the CopyLocal metadata.
+                yield return new KeyValuePair<string, string>(ItemMetadataNames.copyLocal, reference.IsCopyLocal ? "true" : "false");
+
+                // Set the Redist name metadata.
+                if (!string.IsNullOrEmpty(reference.RedistName))
+                {
+                    yield return new KeyValuePair<string, string>(ItemMetadataNames.redist, reference.RedistName);
+                }
+
+                if (Reference.IsFrameworkFile(reference.FullPath, _frameworkPaths) || (_installedAssemblies?.FrameworkAssemblyEntryInRedist(assemblyName) == true))
+                {
+                    if (!IsAssemblyRemovedFromDotNetFramework(assemblyName, reference.FullPath, _frameworkPaths, _installedAssemblies))
+                    {
+                        yield return new KeyValuePair<string, string>(ItemMetadataNames.frameworkFile, "true");
+                    }
+                }
+
+                if (!string.IsNullOrEmpty(reference.ImageRuntime))
+                {
+                    yield return new KeyValuePair<string, string>(ItemMetadataNames.imageRuntime, reference.ImageRuntime);
+                }
+
+                // The redist root is "null" when there was no IsRedistRoot flag in the Redist XML
+                // (or there was no redist XML at all for this item).
+                if (reference.IsRedistRoot != null)
+                {
+                    yield return new KeyValuePair<string, string>(ItemMetadataNames.isRedistRoot, (bool)reference.IsRedistRoot ? "true" : "false");
+                }
+            }
         }
 
         /// <summary>
@@ -3156,5 +3211,28 @@ internal bool MarkReferencesForExclusion(Dictionary<string, string> exclusionLis
 
             return anyMarkedReference;
         }
+
+        /// <summary>
+        /// Returns true if the full path passed in <paramref name="path"/> represents a file that came from an external trusted
+        /// entity and is guaranteed to be immutable.
+        /// </summary>
+        /// <param name="path">The path to check.</param>
+        /// <returns>True if known to be immutable, false otherwise.</returns>
+        internal bool IsImmutableFile(string path)
+        {
+            return _externallyResolvedImmutableFiles.ContainsKey(path);
+        }
+
+        /// <summary>
+        /// Returns the assembly name of a file if the file came from an external trusted entity and is considered immutable.
+        /// </summary>
+        /// <param name="path">The file path.</param>
+        /// <returns>Assembly name or null if not known.</returns>
+        internal AssemblyNameExtension GetImmutableFileAssemblyName(string path)
+        {
+            return _externallyResolvedImmutableFiles.TryGetValue(path, out AssemblyNameExtension assemblyNameExtension)
+                ? assemblyNameExtension
+                : null;
+        }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index a3942efd097..45d87afb04c 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Tasks
     /// Given a list of assemblyFiles, determine the closure of all assemblyFiles that
     /// depend on those assemblyFiles including second and nth-order dependencies too.
     /// </summary>
-    public class ResolveAssemblyReference : TaskExtension
+    public class ResolveAssemblyReference : TaskExtension, IIncrementalTask
     {
         /// <summary>
         /// key assembly used to trigger inclusion of facade references.
@@ -41,6 +41,11 @@ public class ResolveAssemblyReference : TaskExtension
         /// </summary>
         private const string NETStandardAssemblyName = "netstandard";
 
+        /// <summary>
+        /// The well-known CLR 4.0 metadata version used in all managed assemblies.
+        /// </summary>
+        private const string DotNetAssemblyRuntimeVersion = "v4.0.30319";
+
         /// <summary>
         /// Delegate to a method that takes a targetFrameworkDirectory and returns an array of redist or subset list paths
         /// </summary>
@@ -888,6 +893,8 @@ public string[] FullFrameworkFolders
             }
         }
 
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// This is a list of all primary references resolved to full paths.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
@@ -1961,7 +1968,7 @@ private void LogImageRuntime(Reference reference, MessageImportance importance)
             if (!reference.IsUnresolvable && !reference.IsBadImage)
             {
                 // Don't log the overwhelming default as it just pollutes the logs.
-                if (reference.ImageRuntime != "v4.0.30319")
+                if (reference.ImageRuntime != DotNetAssemblyRuntimeVersion)
                 {
                     Log.LogMessage(importance, Strings.ImageRuntimeVersion, reference.ImageRuntime);
                 }
@@ -2029,7 +2036,7 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
         /// </summary>
         internal void ReadStateFile(FileExists fileExists)
         {
-            _cache = SystemState.DeserializeCache(_stateFile, Log, typeof(SystemState)) as SystemState;
+            _cache = SystemState.DeserializeCache<SystemState>(_stateFile, Log);
 
             // Construct the cache only if we can't find any caches.
             if (_cache == null && AssemblyInformationCachePaths != null && AssemblyInformationCachePaths.Length > 0)
@@ -2048,12 +2055,20 @@ internal void ReadStateFile(FileExists fileExists)
         /// </summary>
         internal void WriteStateFile()
         {
-            if (!String.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
+            if (!string.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
             {
                 _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log);
             }
-            else if (!String.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
+            else if (!string.IsNullOrEmpty(_stateFile) && (_cache.IsDirty || _cache.instanceLocalOutgoingFileStateCache.Count < _cache.instanceLocalFileStateCache.Count))
             {
+                // Either the cache is dirty (we added or updated an item) or the number of items actually used is less than what
+                // we got by reading the state file prior to execution. Serialize the cache into the state file.
+                if (FailIfNotIncremental)
+                {
+                    Log.LogErrorFromResources("ResolveAssemblyReference.WritingCacheFile", _stateFile);
+                    return;
+                }
+
                 _cache.SerializeCache(_stateFile, Log);
             }
         }
@@ -2209,7 +2224,7 @@ internal bool Execute(
                             inclusionListSubsetTableInfo = GetInstalledAssemblyTableInfo(IgnoreDefaultInstalledAssemblySubsetTables, InstalledAssemblySubsetTables, new GetListPath(inclusionList.GetSubsetListPathsFromDisk), TargetFrameworkDirectories);
                             if (inclusionListSubsetTableInfo.Length > 0 && (redistList?.Count > 0))
                             {
-                                exclusionList = redistList.GenerateBlackList(inclusionListSubsetTableInfo, inclusionListErrors, inclusionListErrorFilesNames);
+                                exclusionList = redistList.GenerateDenyList(inclusionListSubsetTableInfo, inclusionListErrors, inclusionListErrorFilesNames);
                             }
                             else
                             {
@@ -2283,16 +2298,46 @@ internal bool Execute(
 
                     // Load any prior saved state.
                     ReadStateFile(fileExists);
-                    _cache.SetGetLastWriteTime(getLastWriteTime);
                     _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);
 
                     // Cache delegates.
-                    getAssemblyName = _cache.CacheDelegate(getAssemblyName);
                     getAssemblyMetadata = _cache.CacheDelegate(getAssemblyMetadata);
                     fileExists = _cache.CacheDelegate();
                     directoryExists = _cache.CacheDelegate(directoryExists);
                     getDirectories = _cache.CacheDelegate(getDirectories);
-                    getRuntimeVersion = _cache.CacheDelegate(getRuntimeVersion);
+
+                    ReferenceTable dependencyTable = null;
+
+                    // Wrap the GetLastWriteTime callback with a check for SDK/immutable files.
+                    _cache.SetGetLastWriteTime(path =>
+                    {
+                        if (dependencyTable?.IsImmutableFile(path) == true)
+                        {
+                            // We don't want to perform I/O to see what the actual timestamp on disk is so we return a fixed made up value.
+                            // Note that this value makes the file exist per the check in SystemState.FileTimestampIndicatesFileExists.
+                            return SystemState.FileState.ImmutableFileLastModifiedMarker;
+                        }
+                        return getLastWriteTime(path);
+                    });
+
+                    // Wrap the GetAssemblyName and GetRuntimeVersion callbacks with a check for SDK/immutable files.
+                    GetAssemblyName originalGetAssemblyName = getAssemblyName;
+                    getAssemblyName = _cache.CacheDelegate(path =>
+                    {
+                        AssemblyNameExtension assemblyName = dependencyTable?.GetImmutableFileAssemblyName(path);
+                        return assemblyName ?? originalGetAssemblyName(path);
+                    });
+
+                    GetAssemblyRuntimeVersion originalGetRuntimeVersion = getRuntimeVersion;
+                    getRuntimeVersion = _cache.CacheDelegate(path =>
+                    {
+                        if (dependencyTable?.IsImmutableFile(path) == true)
+                        {
+                            // There are no WinRT assemblies in the SDK, everything has the .NET metadata version.
+                            return DotNetAssemblyRuntimeVersion;
+                        }
+                        return originalGetRuntimeVersion(path);
+                    });
 
                     _projectTargetFramework = FrameworkVersionFromString(_projectTargetFrameworkAsString);
 
@@ -2322,7 +2367,7 @@ internal bool Execute(
                             : null;
 
                     // Start the table of dependencies with all of the primary references.
-                    ReferenceTable dependencyTable = new ReferenceTable(
+                    dependencyTable = new ReferenceTable(
                         BuildEngine,
                         _findDependencies,
                         _findSatellites,
@@ -2729,7 +2774,7 @@ private void HandleProfile(AssemblyTableInfo[] installedAssemblyTableInfo, out A
                     // Any errors reading the profile redist list will already be logged, we do not need to re-log the errors here.
                     List<Exception> inclusionListErrors = new List<Exception>();
                     List<string> inclusionListErrorFilesNames = new List<string>();
-                    exclusionList = fullFrameworkRedistList.GenerateBlackList(installedAssemblyTableInfo, inclusionListErrors, inclusionListErrorFilesNames);
+                    exclusionList = fullFrameworkRedistList.GenerateDenyList(installedAssemblyTableInfo, inclusionListErrors, inclusionListErrorFilesNames);
                 }
 
                 // Could get into this situation if the redist list files were full of junk and no assemblies were read in.
@@ -2852,7 +2897,7 @@ private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableIn
                 }
             }
 
-            Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader");
+            Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.TargetFrameworkAllowListLogHeader");
             if (inclusionListSubsetTableInfo != null)
             {
                 foreach (AssemblyTableInfo inclusionListInfo in inclusionListSubsetTableInfo)
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index b854a4015e5..667493a611d 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -72,6 +72,7 @@ protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, Fi
         /// <param name="sdkName">The name of the sdk to resolve.</param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
+        /// <param name="isImmutableFrameworkReference">True if <paramref name="rawFileNameCandidate"/> is guaranteed to exist on disk and never change.</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
         /// <param name="executableExtensions">Allowed executable extensions.</param>
         /// <param name="hintPath">The item's hintpath value.</param>
@@ -85,6 +86,7 @@ public abstract bool Resolve(
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyRegistrationCache.cs b/src/Tasks/AssemblyRegistrationCache.cs
index 8ac4f9ff065..b4975263b99 100644
--- a/src/Tasks/AssemblyRegistrationCache.cs
+++ b/src/Tasks/AssemblyRegistrationCache.cs
@@ -1,7 +1,6 @@
 Ôªø// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
@@ -13,8 +12,6 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// This class is a caching mechanism for the Register/UnregisterAssembly task to keep track of registered assemblies to clean up
     /// </remarks>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-    [Serializable]
     internal sealed class AssemblyRegistrationCache : StateFileBase, ITranslatable
     {
         /// <summary>
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index 343eabff36d..2ff7b10261f 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -1,4 +1,4 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -99,11 +99,11 @@ public class AssignCulture : TaskExtension
         /// The culture will only be stripped if it is a valid culture identifier.
         /// So for example,
         /// 
-        ///      MyCrazyFile.XX.txt
+        ///      MyDifferentFile.XX.txt
         /// 
         /// will result in exactly the same file name:
         /// 
-        ///      MyCrazyFile.XX.txt
+        ///      MyDifferentFile.XX.txt
         /// 
         /// because 'XX' is not a valid culture identifier.
         /// </summary>
@@ -139,7 +139,7 @@ public override bool Execute()
                             dependentUpon,
                             // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
                             // https://github.com/dotnet/msbuild/issues/3064
-                            AssignedFiles[i].GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase));
+                            ConversionUtilities.ValidBooleanFalse(AssignedFiles[i].GetMetadata("WithCulture")));
 
                     if (!string.IsNullOrEmpty(info.culture))
                     {
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 12e60df9bbc..b60f7b01d4a 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -532,14 +532,15 @@ private void RefreshResources()
                 foreach (string subDirectory in Directory.GetDirectories(startDirectory))
                 {
                     string resourceDirectory = System.IO.Path.Combine(startDirectory, subDirectory);
-                    string resourceFile = System.IO.Path.Combine(resourceDirectory, SETUP_RESOURCES_FILE);
-                    if (FileSystems.Default.FileExists(resourceFile))
+                    string resourceFilePath = System.IO.Path.Combine(resourceDirectory, SETUP_RESOURCES_FILE);
+                    if (FileSystems.Default.FileExists(resourceFilePath))
                     {
                         var resourceDoc = new XmlDocument();
                         try
                         {
-                            var xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                            using (var xr = XmlReader.Create(resourceFile, xrs))
+                            var xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+                            FileStream fs = File.OpenRead(resourceFilePath);
+                            using (var xr = XmlReader.Create(fs, xrs))
                             {
                                 resourceDoc.Load(xr);
                             }
@@ -836,8 +837,9 @@ private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFil
 #pragma warning disable 618 // Using XmlValidatingReader. TODO: We need to switch to using XmlReader.Create() with validation.
                         var validatingReader = new XmlValidatingReader(xmlReader);
 #pragma warning restore 618
-                        var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                        using (XmlReader xr = XmlReader.Create(schemaPath, xrSettings))
+                        var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+                        FileStream fs = File.OpenRead(schemaPath);
+                        using (XmlReader xr = XmlReader.Create(fs, xrSettings))
                         {
                             try
                             {
diff --git a/src/Tasks/ComDependencyWalker.cs b/src/Tasks/ComDependencyWalker.cs
index 9de8725cd65..f998d3be668 100644
--- a/src/Tasks/ComDependencyWalker.cs
+++ b/src/Tasks/ComDependencyWalker.cs
@@ -66,7 +66,7 @@ public AnalyzedTypesInfoKey(Guid guid, short major, short minor, int lcid, int i
                 this.index = index;
             }
 
-            public override string ToString()
+            public override readonly string ToString()
             {
                 return string.Format(CultureInfo.InvariantCulture, "{0}.{1}.{2}.{3}:{4}",
                     this.guid, this.wMajorVerNum,
diff --git a/src/Tasks/ComReferenceInfo.cs b/src/Tasks/ComReferenceInfo.cs
index f41dd573f48..7ba6eff1a9f 100644
--- a/src/Tasks/ComReferenceInfo.cs
+++ b/src/Tasks/ComReferenceInfo.cs
@@ -153,10 +153,10 @@ internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path
             {
                 case ProcessorArchitecture.AMD64:
                 case ProcessorArchitecture.IA64:
-                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_64BIT);
+                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_NONE | (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_64BIT);
                     break;
                 case ProcessorArchitecture.X86:
-                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_32BIT);
+                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_NONE | (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_32BIT);
                     break;
                 case ProcessorArchitecture.ARM:
                 case ProcessorArchitecture.MSIL:
diff --git a/src/Tasks/CombineTargetFrameworkInfoProperties.cs b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
index 6830ba9cb99..7506fbc8be0 100644
--- a/src/Tasks/CombineTargetFrameworkInfoProperties.cs
+++ b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
@@ -18,7 +18,6 @@ public class CombineTargetFrameworkInfoProperties : TaskExtension
         /// The root element name to use for the generated XML string
         /// </summary>
         public string RootElementName { get; set; }
-
         /// <summary>
         /// Items to include in the XML.  The ItemSpec should be the property name, and it should have Value metadata for its value.
         /// </summary>
@@ -39,16 +38,24 @@ public override bool Execute()
         {
             if (PropertiesAndValues != null)
             {
-                XElement root = UseAttributeForTargetFrameworkInfoPropertyNames ?
-                    new("TargetFramework", new XAttribute("Name", EscapingUtilities.Escape(RootElementName))) :
-                    new(RootElementName);
-
-                foreach (ITaskItem item in PropertiesAndValues)
+                if ((!UseAttributeForTargetFrameworkInfoPropertyNames && string.IsNullOrEmpty(RootElementName)) || (UseAttributeForTargetFrameworkInfoPropertyNames && RootElementName == null))
                 {
-                    root.Add(new XElement(item.ItemSpec, item.GetMetadata("Value")));
+                    string resource = UseAttributeForTargetFrameworkInfoPropertyNames ? "CombineTargetFrameworkInfoProperties.NotNullRootElementName" : "CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName";
+                    Log.LogErrorWithCodeFromResources(resource, nameof(RootElementName), nameof(UseAttributeForTargetFrameworkInfoPropertyNames));
                 }
+                else
+                {
+                    XElement root = UseAttributeForTargetFrameworkInfoPropertyNames ?
+                        new("TargetFramework", new XAttribute("Name", EscapingUtilities.Escape(RootElementName))) :
+                        new(RootElementName);
 
-                Result = root.ToString();
+                    foreach (ITaskItem item in PropertiesAndValues)
+                    {
+                        root.Add(new XElement(item.ItemSpec, item.GetMetadata("Value")));
+                    }
+
+                    Result = root.ToString();
+                }
             }
             return !Log.HasLoggedErrors;
         }
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
index 1314aae19e3..498513b70bc 100644
--- a/src/Tasks/CompatibilitySuppressions.xml
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -1,7 +1,8 @@
 Ôªø<?xml version="1.0" encoding="utf-8"?>
+<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <Suppression>
-    <!-- For ease of logging the "not supported on Core" message, this task is a
+<!-- For ease of logging the "not supported on Core" message, this task is a
          TaskExtension on netstandard/netcore. Since the type is sealed there,
          that shouldn't cause any implementation problems since no one can derive
          from it and try to call TaskExtension.Log. -->
@@ -11,6 +12,15 @@
     <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
 
+  <!-- We don't have the net7 reference assemblies handy to pass in to compare against the net8 ones -->
+  <Suppression>
+    <DiagnosticId>CP1002</DiagnosticId>
+    <Target>System.Security.Cryptography, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Target>
+    <Left>ref/net7.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
        This is intentional, because you can only use MSBuild in the context of a .NET SDK
        (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
@@ -64,4 +74,9 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
+<!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
+  <Suppression>
+    <DiagnosticId>PKV006</DiagnosticId>
+    <Target>net7.0</Target>
+  </Suppression>
 </Suppressions>
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 36fd9b90a26..606677f3305 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -21,7 +21,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// A task that copies files.
     /// </summary>
-    public class Copy : TaskExtension, ICancelableTask
+    public class Copy : TaskExtension, IIncrementalTask, ICancelableTask
     {
         internal const string AlwaysRetryEnvVar = "MSBUILDALWAYSRETRY";
         internal const string AlwaysOverwriteReadOnlyFilesEnvVar = "MSBUILDALWAYSOVERWRITEREADONLYFILES";
@@ -153,6 +153,8 @@ public Copy()
         /// </summary>
         public bool OverwriteReadOnlyFiles { get; set; }
 
+        public bool FailIfNotIncremental { get; set; }
+
         #endregion
 
         /// <summary>
@@ -209,11 +211,11 @@ internal static void RefreshInternalEnvironmentValues()
         /// If MSBUILDALWAYSRETRY is set, also log useful diagnostic information -- as 
         /// a warning, so it's easily visible. 
         /// </summary>
-        private void LogDiagnostic(string message, params object[] messageArgs)
+        private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, params object[] messageArgs)
         {
             if (s_alwaysRetryCopy)
             {
-                Log.LogWarning(message, messageArgs);
+                Log.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
             }
         }
 
@@ -223,11 +225,9 @@ private void LogDiagnostic(string message, params object[] messageArgs)
         /// </summary>
         /// <returns>Return true to indicate success, return false to indicate failure and NO retry, return NULL to indicate retry.</returns>
         private bool? CopyFileWithLogging(
-            FileState sourceFileState,      // The source file
-            FileState destinationFileState)  // The destination file
+            FileState sourceFileState,
+            FileState destinationFileState)
         {
-            bool destinationFileExists = false;
-
             if (destinationFileState.DirectoryExists)
             {
                 Log.LogErrorWithCodeFromResources("Copy.DestinationIsDirectory", sourceFileState.Name, destinationFileState.Name);
@@ -256,8 +256,16 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             {
                 if (!FileSystems.Default.DirectoryExists(destinationFolder))
                 {
-                    Log.LogMessage(MessageImportance.Normal, CreatesDirectory, destinationFolder);
-                    Directory.CreateDirectory(destinationFolder);
+                    if (FailIfNotIncremental)
+                    {
+                        Log.LogError(CreatesDirectory, destinationFolder);
+                        return false;
+                    }
+                    else
+                    {
+                        Log.LogMessage(MessageImportance.Normal, CreatesDirectory, destinationFolder);
+                        Directory.CreateDirectory(destinationFolder);
+                    }
                 }
 
                 // It's very common for a lot of files to be copied to the same folder. 
@@ -266,10 +274,23 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                 _directoriesKnownToExist.TryAdd(destinationFolder, true);
             }
 
+            if (FailIfNotIncremental)
+            {
+                Log.LogError(FileComment, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath);
+                return false;
+            }
+
             if (OverwriteReadOnlyFiles)
             {
                 MakeFileWriteable(destinationFileState, true);
-                destinationFileExists = destinationFileState.FileExists;
+            }
+
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) &&
+                Traits.Instance.EscapeHatches.CopyWithoutDelete != true &&
+                destinationFileState.FileExists &&
+                !destinationFileState.IsReadOnly)
+            {
+                FileUtilities.DeleteNoThrow(destinationFileState.Name);
             }
 
             bool symbolicLinkCreated = false;
@@ -279,17 +300,17 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             // Create hard links if UseHardlinksIfPossible is true
             if (UseHardlinksIfPossible)
             {
-                TryCopyViaLink(HardLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out hardLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage, Log));
+                TryCopyViaLink(HardLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, out hardLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage, Log));
                 if (!hardLinkCreated)
                 {
                     if (UseSymboliclinksIfPossible)
                     {
                         // This is a message for fallback to SymbolicLinks if HardLinks fail when UseHardlinksIfPossible and UseSymboliclinksIfPossible are true
-                        Log.LogMessage(MessageImportance.Normal, RetryingAsSymbolicLink, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                        Log.LogMessage(MessageImportance.Normal, RetryingAsSymbolicLink, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath, errorMessage);
                     }
                     else
                     {
-                        Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                        Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath, errorMessage);
                     }
                 }
             }
@@ -297,20 +318,21 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             // Create symbolic link if UseSymboliclinksIfPossible is true and hard link is not created
             if (!hardLinkCreated && UseSymboliclinksIfPossible)
             {
-                TryCopyViaLink(SymbolicLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out symbolicLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethodsShared.MakeSymbolicLink(destination, source, ref errorMessage));
-                if (!NativeMethodsShared.IsWindows)
-                {
-                    errorMessage = Log.FormatResourceString("Copy.NonWindowsLinkErrorMessage", "symlink()", errorMessage);
-                }
+                TryCopyViaLink(SymbolicLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, out symbolicLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethodsShared.MakeSymbolicLink(destination, source, ref errorMessage));
                 if (!symbolicLinkCreated)
                 {
-                    Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                    if (!NativeMethodsShared.IsWindows)
+                    {
+                        errorMessage = Log.FormatResourceString("Copy.NonWindowsLinkErrorMessage", "symlink()", errorMessage);
+                    }
+
+                    Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath, errorMessage);
                 }
             }
 
             if (ErrorIfLinkFails && !hardLinkCreated && !symbolicLinkCreated)
             {
-                Log.LogErrorWithCodeFromResources("Copy.LinkFailed", sourceFileState.Name, destinationFileState.Name);
+                Log.LogErrorWithCodeFromResources("Copy.LinkFailed", sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath);
                 return false;
             }
 
@@ -319,45 +341,30 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             if (!hardLinkCreated && !symbolicLinkCreated)
             {
                 // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
-                string sourceFilePath = FileUtilities.GetFullPathNoThrow(sourceFileState.Name);
-                string destinationFilePath = FileUtilities.GetFullPathNoThrow(destinationFileState.Name);
-                Log.LogMessage(MessageImportance.Normal, FileComment, sourceFilePath, destinationFilePath);
+                Log.LogMessage(MessageImportance.Normal, FileComment, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath);
 
                 File.Copy(sourceFileState.Name, destinationFileState.Name, true);
             }
 
-            // Files were successfully copied or linked. Those are equivalent here.
-            WroteAtLeastOneFile = true;
-
-            destinationFileState.Reset();
-
             // If the destinationFile file exists, then make sure it's read-write.
             // The File.Copy command copies attributes, but our copy needs to
             // leave the file writeable.
             if (sourceFileState.IsReadOnly)
             {
+                destinationFileState.Reset();
                 MakeFileWriteable(destinationFileState, false);
             }
 
+            // Files were successfully copied or linked. Those are equivalent here.
+            WroteAtLeastOneFile = true;
+
             return true;
         }
 
-        private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, ref bool destinationFileExists, out bool linkCreated, ref string errorMessage, Func<string, string, string, bool> createLink)
+        private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, out bool linkCreated, ref string errorMessage, Func<string, string, string, bool> createLink)
         {
             // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
-            Log.LogMessage(MessageImportance.Normal, linkComment, sourceFileState.Name, destinationFileState.Name);
-
-            if (!OverwriteReadOnlyFiles)
-            {
-                destinationFileExists = destinationFileState.FileExists;
-            }
-
-            // CreateHardLink and CreateSymbolicLink cannot overwrite an existing file or link
-            // so we need to delete the existing entry before we create the hard or symbolic link.
-            if (destinationFileExists)
-            {
-                FileUtilities.DeleteNoThrow(destinationFileState.Name);
-            }
+            Log.LogMessage(MessageImportance.Normal, linkComment, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath);
 
             linkCreated = createLink(sourceFileState.Name, destinationFileState.Name, errorMessage);
         }
@@ -418,9 +425,18 @@ internal bool Execute(
 
             // Use single-threaded code path when requested or when there is only copy to make
             // (no need to create all the parallel infrastructure for that case).
-            bool success = parallelism == 1 || DestinationFiles.Length == 1
-                ? CopySingleThreaded(copyFile, out destinationFilesSuccessfullyCopied)
-                : CopyParallel(copyFile, parallelism, out destinationFilesSuccessfullyCopied);
+            bool success = false;
+
+            try
+            {
+                success = parallelism == 1 || DestinationFiles.Length == 1
+                    ? CopySingleThreaded(copyFile, out destinationFilesSuccessfullyCopied)
+                    : CopyParallel(copyFile, parallelism, out destinationFilesSuccessfullyCopied);
+            }
+            catch (OperationCanceledException)
+            {
+                return false;
+            }
 
             // copiedFiles contains only the copies that were successful.
             CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();
@@ -740,16 +756,19 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
                         "true");
                     MSBuildEventSource.Log.CopyUpToDateStop(destinationFileState.Name, true);
                 }
-                // We only do the cheap check for identicalness here, we try the more expensive check
-                // of comparing the fullpaths of source and destination to see if they are identical,
-                // in the exception handler lower down.
-                else if (!String.Equals(
-                             sourceFileState.Name,
-                             destinationFileState.Name,
-                             StringComparison.OrdinalIgnoreCase))
+                else if (!PathsAreIdentical(sourceFileState, destinationFileState))
                 {
                     MSBuildEventSource.Log.CopyUpToDateStop(destinationFileState.Name, false);
-                    success = DoCopyWithRetries(sourceFileState, destinationFileState, copyFile);
+
+                    if (FailIfNotIncremental)
+                    {
+                        Log.LogError(FileComment, sourceFileState.Name, destinationFileState.Name);
+                        success = false;
+                    }
+                    else
+                    {
+                        success = DoCopyWithRetries(sourceFileState, destinationFileState, copyFile);
+                    }
                 }
                 else
                 {
@@ -807,7 +826,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                         case IOException: // Not clear why we can get one and not the other
                             int code = Marshal.GetHRForException(e);
 
-                            LogDiagnostic("Got {0} copying {1} to {2} and HR is {3}", e.ToString(), sourceFileState.Name, destinationFileState.Name, code);
+                            LogAlwaysRetryDiagnosticFromResources("Copy.IOException", e.ToString(), sourceFileState.Name, destinationFileState.Name, code);
                             if (code == NativeMethods.ERROR_ACCESS_DENIED)
                             {
                                 // ERROR_ACCESS_DENIED can either mean there's an ACL preventing us, or the file has the readonly bit set.
@@ -823,9 +842,14 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                                 }
                                 else
                                 {
-                                    LogDiagnostic("Retrying on ERROR_ACCESS_DENIED because MSBUILDALWAYSRETRY = 1");
+                                    LogAlwaysRetryDiagnosticFromResources("Copy.RetryingOnAccessDenied");
                                 }
                             }
+                            else if (code == NativeMethods.ERROR_INVALID_FILENAME)
+                            {
+                                // Invalid characters used in file name; no point retrying.
+                                throw;
+                            }
 
                             if (e is UnauthorizedAccessException)
                             {
@@ -839,13 +863,6 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                                 throw;
                             }
 
-                            // if this was just because the source and destination files are the
-                            // same file, that's not a failure.
-                            // Note -- we check this exceptional case here, not before the copy, for perf.
-                            if (PathsAreIdentical(sourceFileState.Name, destinationFileState.Name))
-                            {
-                                return true;
-                            }
                             break;
                     }
 
@@ -943,12 +960,16 @@ public override bool Execute()
         /// Compares two paths to see if they refer to the same file. We can't solve the general
         /// canonicalization problem, so we just compare strings on the full paths.
         /// </summary>
-        private static bool PathsAreIdentical(string source, string destination)
+        private static bool PathsAreIdentical(FileState source, FileState destination)
         {
-            string fullSourcePath = Path.GetFullPath(source);
-            string fullDestinationPath = Path.GetFullPath(destination);
-            StringComparison filenameComparison = NativeMethodsShared.IsWindows ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal;
-            return String.Equals(fullSourcePath, fullDestinationPath, filenameComparison);
+            if (string.Equals(source.Name, destination.Name, FileUtilities.PathComparison))
+            {
+                return true;
+            }
+
+            source.FileNameFullPath = Path.GetFullPath(source.Name);
+            destination.FileNameFullPath = Path.GetFullPath(destination.Name);
+            return string.Equals(source.FileNameFullPath, destination.FileNameFullPath, FileUtilities.PathComparison);
         }
 
         private static int GetParallelismFromEnvironment()
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index e2be751c69d..f45169c4d12 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -1,4 +1,4 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -44,7 +44,7 @@ protected override string CreateManifestName(
                 culture = item.GetMetadata("Culture");
                 // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
                 // https://github.com/dotnet/msbuild/issues/3064
-                treatAsCultureNeutral = item.GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase);
+                treatAsCultureNeutral = ConversionUtilities.ValidBooleanFalse(item.GetMetadata("WithCulture"));
             }
 
             /*
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 11ccf11e3a6..9b02e0109bc 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -1,9 +1,10 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.IO;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 #nullable disable
@@ -42,7 +43,7 @@ protected override string CreateManifestName(
                 culture = item.GetMetadata("Culture");
                 // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
                 // https://github.com/dotnet/msbuild/issues/3064
-                treatAsCultureNeutral = item.GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase);
+                treatAsCultureNeutral = ConversionUtilities.ValidBooleanFalse(item.GetMetadata("WithCulture"));
             }
 
             /*
diff --git a/src/Tasks/Delete.cs b/src/Tasks/Delete.cs
index bd782dd8bae..0dbe2f78609 100644
--- a/src/Tasks/Delete.cs
+++ b/src/Tasks/Delete.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Delete files from disk.
     /// </summary>
-    public class Delete : TaskExtension, ICancelableTask
+    public class Delete : TaskExtension, ICancelableTask, IIncrementalTask
     {
         #region Properties
 
@@ -57,6 +57,12 @@ public ITaskItem[] Files
 
         #endregion
 
+        /// <summary>
+        /// Set question parameter to verify if this is incremental.
+        /// </summary>
+        /// <remarks></remarks>
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// Verify that the inputs are correct.
         /// </summary>
@@ -115,10 +121,17 @@ public override bool Execute()
                     {
                         if (FileSystems.Default.FileExists(file.ItemSpec))
                         {
-                            // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
-                            Log.LogMessageFromResources(MessageImportance.Normal, "Delete.DeletingFile", file.ItemSpec);
-
-                            File.Delete(file.ItemSpec);
+                            if (FailIfNotIncremental)
+                            {
+                                Log.LogErrorFromResources("Delete.DeletingFile", file.ItemSpec);
+                            }
+                            else
+                            {
+                                // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
+                                Log.LogMessageFromResources(MessageImportance.Normal, "Delete.DeletingFile", file.ItemSpec);
+
+                                File.Delete(file.ItemSpec);
+                            }
                         }
                         else
                         {
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index 359a2dc7b03..9908267c4a8 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -14,9 +14,12 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// Represents a single input to a compilation-style task.
     /// Keeps track of timestamp for later comparison.
+    ///
+    /// Must be serializable because instances may be marshaled cross-AppDomain, see <see cref="ProcessResourceFiles.PortableLibraryCacheInfo"/>.
     /// </remarks>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
+#if FEATURE_APPDOMAIN
     [Serializable]
+#endif
     internal class DependencyFile
     {
         // Filename
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 6e5a029f286..efe54f514ca 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -5,7 +5,6 @@
 using System.IO;
 using System.Net;
 using System.Net.Http;
-using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
@@ -19,7 +18,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Represents a task that can download a file.
     /// </summary>
-    public sealed class DownloadFile : TaskExtension, ICancelableTask
+    public sealed class DownloadFile : TaskExtension, ICancelableTask, IIncrementalTask
     {
         private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
 
@@ -66,6 +65,8 @@ public sealed class DownloadFile : TaskExtension, ICancelableTask
         /// </summary>
         public int Timeout { get; set; } = 100_000;
 
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// Gets or sets a <see cref="HttpMessageHandler"/> to use.  This is used by unit tests to mock a connection to a remote server.
         /// </summary>
@@ -126,14 +127,8 @@ private async Task<bool> ExecuteAsync()
                     }
                     else
                     {
-                        StringBuilder flattenedMessage = new StringBuilder(actualException.Message);
-                        Exception excep = actualException;
-                        while (excep.InnerException != null)
-                        {
-                            excep = excep.InnerException;
-                            flattenedMessage.Append(" ---> ").Append(excep.Message);
-                        }
-                        Log.LogErrorWithCodeFromResources("DownloadFile.ErrorDownloading", SourceUrl, flattenedMessage.ToString());
+                        string flattenedMessage = TaskLoggingHelper.GetInnerExceptionMessageString(e);
+                        Log.LogErrorWithCodeFromResources("DownloadFile.ErrorDownloading", SourceUrl, flattenedMessage);
                         Log.LogMessage(MessageImportance.Low, actualException.ToString());
                         break;
                     }
@@ -192,6 +187,11 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
 
                         return;
                     }
+                    else if (FailIfNotIncremental)
+                    {
+                        Log.LogErrorFromResources("DownloadFile.Downloading", SourceUrl, destinationFile.FullName, response.Content.Headers.ContentLength);
+                        return;
+                    }
 
                     try
                     {
diff --git a/src/Tasks/FileIO/WriteLinesToFile.cs b/src/Tasks/FileIO/WriteLinesToFile.cs
index dcc9a4f69fa..9b94858fc12 100644
--- a/src/Tasks/FileIO/WriteLinesToFile.cs
+++ b/src/Tasks/FileIO/WriteLinesToFile.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Appends a list of items to a file. One item per line with carriage returns in-between.
     /// </summary>
-    public class WriteLinesToFile : TaskExtension
+    public class WriteLinesToFile : TaskExtension, IIncrementalTask
     {
         // Default encoding taken from System.IO.WriteAllText()
         private static readonly Encoding s_defaultEncoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true);
@@ -48,6 +48,14 @@ public class WriteLinesToFile : TaskExtension
         /// </summary>
         public bool WriteOnlyWhenDifferent { get; set; }
 
+        /// <summary>
+        /// Question whether this task is incremental.
+        /// </summary>
+        /// <remarks>When question is true, then this task would not write to disk.  If CanBeIncremental is true, then error out.</remarks>
+        public bool FailIfNotIncremental { get; set; }
+
+        public bool CanBeIncremental => WriteOnlyWhenDifferent;
+
         /// <summary>
         /// Execute the task.
         /// </summary>
@@ -61,7 +69,7 @@ public override bool Execute()
                 // do not return if Lines is null, because we may
                 // want to delete the file in that case
                 StringBuilder buffer = new StringBuilder();
-                if (Lines != null)
+                if (Lines != null && (!FailIfNotIncremental || WriteOnlyWhenDifferent))
                 {
                     foreach (ITaskItem line in Lines)
                     {
@@ -108,6 +116,11 @@ public override bool Execute()
                                             MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(File.ItemSpec, true);
                                             return true;
                                         }
+                                        else if (FailIfNotIncremental)
+                                        {
+                                            Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
+                                            return false;
+                                        }
                                     }
                                 }
                             }
@@ -118,16 +131,36 @@ public override bool Execute()
                             MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(File.ItemSpec, false);
                         }
 
-                        System.IO.File.WriteAllText(File.ItemSpec, contentsAsString, encoding);
+                        if (FailIfNotIncremental)
+                        {
+                            if (Lines?.Length > 0)
+                            {
+                                Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
+                                return false;
+                            }
+                        }
+                        else
+                        {
+                            System.IO.File.WriteAllText(File.ItemSpec, contentsAsString, encoding);
+                        }
                     }
                     else
                     {
-                        if (WriteOnlyWhenDifferent)
+                        if (FailIfNotIncremental && Lines?.Length > 0)
                         {
-                            Log.LogMessageFromResources(MessageImportance.Normal, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", File.ItemSpec);
+                            Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorOrWarning", File.ItemSpec, string.Empty);
+                            return false;
+                        }
+                        else
+                        {
+                            if (WriteOnlyWhenDifferent)
+                            {
+                                Log.LogMessageFromResources(MessageImportance.Normal, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", File.ItemSpec);
+                            }
+
+                            Directory.CreateDirectory(directoryPath);
+                            System.IO.File.AppendAllText(File.ItemSpec, buffer.ToString(), encoding);
                         }
-                        Directory.CreateDirectory(directoryPath);
-                        System.IO.File.AppendAllText(File.ItemSpec, buffer.ToString(), encoding);
                     }
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index f992f7bc76b..4e00e4af725 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -231,6 +231,11 @@ public void ThrowException()
         /// </summary>
         private readonly string _filename;
 
+        /// <summary>
+        /// Holds the full path equivalent of _filename
+        /// </summary>
+        public string FileNameFullPath;
+
         /// <summary>
         /// Actual file or directory information
         /// </summary>
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index fe22b568293..3c198c1d512 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -53,7 +53,7 @@ namespace Microsoft.Build.Tasks
     /// to transform resource files.
     /// </summary>
     [RequiredRuntime("v2.0")]
-    public sealed partial class GenerateResource : TaskExtension
+    public sealed partial class GenerateResource : TaskExtension, IIncrementalTask
     {
 
         #region Fields
@@ -274,6 +274,12 @@ public string StronglyTypedLanguage
             }
         }
 
+        // Indicates whether any BinaryFormatter use should lead to a warning.
+        public bool WarnOnBinaryFormatterUse
+        {
+            get; set;
+        }
+
         /// <summary>
         /// Specifies the namespace to use for the generated class source for the
         /// strongly typed resource. If left blank, no namespace is used.
@@ -546,6 +552,8 @@ public GenerateResource()
             // do nothing
         }
 
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// Logs a Resgen.exe command line that indicates what parameters were
         /// passed to this task. Since this task is replacing Resgen, and we used
@@ -715,6 +723,10 @@ public override bool Execute()
 
                     Log.LogMessageFromResources("GenerateResource.NothingOutOfDate");
                 }
+                else if (FailIfNotIncremental)
+                {
+                    Log.LogErrorFromResources("GenerateResource.OutOfDate");
+                }
                 else
                 {
                     if (!ComputePathToResGen())
@@ -808,7 +820,8 @@ public override bool Execute()
                                         StronglyTypedClassName,
                                         PublicClass,
                                         ExtractResWFiles,
-                                        OutputDirectory);
+                                        OutputDirectory,
+                                        WarnOnBinaryFormatterUse);
 
                             this.StronglyTypedClassName = process.StronglyTypedClassName; // in case a default was chosen
                             this.StronglyTypedFileName = process.StronglyTypedFilename;   // in case a default was chosen
@@ -1510,7 +1523,7 @@ private bool ShouldRebuildResgenOutputFile(string sourceFilePath, string outputF
             ResGenDependencies.ResXFile resxFileInfo;
             try
             {
-                resxFileInfo = _cache.GetResXFileInfo(sourceFilePath, UsePreserializedResources);
+                resxFileInfo = _cache.GetResXFileInfo(sourceFilePath, UsePreserializedResources, Log, WarnOnBinaryFormatterUse);
             }
             catch (Exception e) when (!ExceptionHandling.NotExpectedIoOrXmlException(e) || e is MSBuildResXException)
             {
@@ -1732,9 +1745,10 @@ private bool NeedSeparateAppDomain()
 
                     try
                     {
-                        XmlReaderSettings readerSettings = new XmlReaderSettings();
-                        readerSettings.DtdProcessing = DtdProcessing.Ignore;
-                        reader = XmlReader.Create(source.ItemSpec, readerSettings);
+                        XmlReaderSettings readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+
+                        FileStream fs = File.OpenRead(source.ItemSpec);
+                        reader = XmlReader.Create(fs, readerSettings);
 
                         while (reader.Read())
                         {
@@ -1971,7 +1985,7 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
         {
             byte[] serializedData = ByteArrayFromBase64WrappedString(data);
 
-            BinaryFormatter binaryFormatter = new BinaryFormatter();
+            BinaryFormatter binaryFormatter = new();
 
             using (MemoryStream memoryStream = new MemoryStream(serializedData))
             {
@@ -2337,6 +2351,8 @@ internal bool StronglyTypedResourceSuccessfullyCreated
         /// </summary>
         private bool _useSourcePath = false;
 
+        private bool _logWarningForBinaryFormatter = false;
+
         #endregion
 
         /// <summary>
@@ -2357,7 +2373,8 @@ internal void Run(
             string classname,
             bool publicClass,
             bool extractingResWFiles,
-            string resWOutputDirectory)
+            string resWOutputDirectory,
+            bool logWarningForBinaryFormatter)
         {
             _logger = log;
             _assemblyFiles = assemblyFilesList;
@@ -2376,6 +2393,7 @@ internal void Run(
             _resWOutputDirectory = resWOutputDirectory;
             _portableLibraryCacheInfo = new List<ResGenDependencies.PortableLibraryFile>();
             _usePreserializedResources = usePreserializedResources;
+            _logWarningForBinaryFormatter = logWarningForBinaryFormatter;
 
 #if !FEATURE_ASSEMBLYLOADCONTEXT
             // If references were passed in, we will have to give the ResxResourceReader an object
@@ -2980,7 +2998,7 @@ private void ReadResources(String filename, bool shouldUseSourcePath, String out
                             }
                             else
                             {
-                                foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, shouldUseSourcePath))
+                                foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, shouldUseSourcePath, _logger, _logWarningForBinaryFormatter))
                                 {
                                     AddResource(reader, resource, filename, 0, 0);
                                 }
@@ -3925,6 +3943,9 @@ internal sealed class TextFileException : Exception
             private int lineNumber;
             private int column;
 
+#if NET8_0_OR_GREATER
+            [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
             private TextFileException(SerializationInfo info, StreamingContext context)
                 : base(info, context)
             {
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 16985d1bb3d..c5bc3724e33 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -931,7 +931,7 @@ internal SDKInfo LoadAssemblyListFromCacheFile(string sdkIdentity, string sdkRoo
                     if (!string.IsNullOrEmpty(cacheFile))
                     {
                         using FileStream fs = new FileStream(cacheFile, FileMode.Open);
-                        using var translator = BinaryTranslator.GetReadTranslator(fs, buffer: null);
+                        using var translator = BinaryTranslator.GetReadTranslator(fs, InterningBinaryReader.PoolingBuffer);
                         SDKInfo sdkInfo = new SDKInfo();
                         sdkInfo.Translate(translator);
                         return sdkInfo;
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index e333d727f84..23615f93af7 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -14,8 +14,13 @@ namespace Microsoft.Build.Tasks
     /// Generates a hash of a given ItemGroup items. Metadata is not considered in the hash.
     /// </summary>
     /// <remarks>
-    /// Currently uses SHA1. Implementation subject to change between MSBuild versions.
-    /// This class is not intended as a cryptographic security measure, only uniqueness between build executions.
+    /// Currently uses SHA256. Implementation subject to change between MSBuild versions.
+    /// This class is not intended as a cryptographic security measure, only uniqueness between build executions
+    /// - collisions can theoretically be possible in the future (should we move to noncrypto hash) and should be handled gracefully by the caller.
+    ///
+    /// Usage of cryptographic secure hash brings slight performance penalty, but it is considered acceptable.
+    /// Would this need to be revised - XxHash64 from System.Io.Hashing could be used instead for better performance.
+    /// (That however currently requires load of additional binary into VS process which has it's own costs)
     /// </remarks>
     public class Hash : TaskExtension
     {
@@ -23,9 +28,9 @@ public class Hash : TaskExtension
         private static readonly Encoding s_encoding = Encoding.UTF8;
         private static readonly byte[] s_itemSeparatorCharacterBytes = s_encoding.GetBytes(new char[] { ItemSeparatorCharacter });
 
-        // Size of buffer where bytes of the strings are stored until sha1.TransformBlock is to be run on them.
-        // It is needed to get a balance between amount of costly sha1.TransformBlock calls and amount of allocated memory.
-        private const int Sha1BufferSize = 512;
+        // Size of buffer where bytes of the strings are stored until sha.TransformBlock is to be run on them.
+        // It is needed to get a balance between amount of costly sha.TransformBlock calls and amount of allocated memory.
+        private const int ShaBufferSize = 512;
 
         // Size of chunks in which ItemSpecs would be cut.
         // We have chosen this length so itemSpecChunkByteBuffer rented from ArrayPool will be close but not bigger than 512.
@@ -56,42 +61,42 @@ public override bool Execute()
         {
             if (ItemsToHash?.Length > 0)
             {
-                using (var sha1 = SHA1.Create())
+                using (var sha = CreateHashAlgorithm())
                 {
                     // Buffer in which bytes of the strings are to be stored until their number reaches the limit size.
-                    // Once the limit is reached, the sha1.TransformBlock is to be run on all the bytes of this buffer.
-                    byte[] sha1Buffer = null;
+                    // Once the limit is reached, the sha.TransformBlock is to be run on all the bytes of this buffer.
+                    byte[] shaBuffer = null;
 
                     // Buffer in which bytes of items' ItemSpec are to be stored.
                     byte[] itemSpecChunkByteBuffer = null;
 
                     try
                     {
-                        sha1Buffer = System.Buffers.ArrayPool<byte>.Shared.Rent(Sha1BufferSize);
+                        shaBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(ShaBufferSize);
                         itemSpecChunkByteBuffer = System.Buffers.ArrayPool<byte>.Shared.Rent(s_encoding.GetMaxByteCount(MaxInputChunkLength));
 
-                        int sha1BufferPosition = 0;
+                        int shaBufferPosition = 0;
                         for (int i = 0; i < ItemsToHash.Length; i++)
                         {
                             string itemSpec = IgnoreCase ? ItemsToHash[i].ItemSpec.ToUpperInvariant() : ItemsToHash[i].ItemSpec;
 
-                            // Slice the itemSpec string into chunks of reasonable size and add them to sha1 buffer.
+                            // Slice the itemSpec string into chunks of reasonable size and add them to sha buffer.
                             for (int itemSpecPosition = 0; itemSpecPosition < itemSpec.Length; itemSpecPosition += MaxInputChunkLength)
                             {
                                 int charsToProcess = Math.Min(itemSpec.Length - itemSpecPosition, MaxInputChunkLength);
                                 int byteCount = s_encoding.GetBytes(itemSpec, itemSpecPosition, charsToProcess, itemSpecChunkByteBuffer, 0);
 
-                                sha1BufferPosition = AddBytesToSha1Buffer(sha1, sha1Buffer, sha1BufferPosition, Sha1BufferSize, itemSpecChunkByteBuffer, byteCount);
+                                shaBufferPosition = AddBytesToShaBuffer(sha, shaBuffer, shaBufferPosition, ShaBufferSize, itemSpecChunkByteBuffer, byteCount);
                             }
 
-                            sha1BufferPosition = AddBytesToSha1Buffer(sha1, sha1Buffer, sha1BufferPosition, Sha1BufferSize, s_itemSeparatorCharacterBytes, s_itemSeparatorCharacterBytes.Length);
+                            shaBufferPosition = AddBytesToShaBuffer(sha, shaBuffer, shaBufferPosition, ShaBufferSize, s_itemSeparatorCharacterBytes, s_itemSeparatorCharacterBytes.Length);
                         }
 
-                        sha1.TransformFinalBlock(sha1Buffer, 0, sha1BufferPosition);
+                        sha.TransformFinalBlock(shaBuffer, 0, shaBufferPosition);
 
-                        using (var stringBuilder = new ReuseableStringBuilder(sha1.HashSize))
+                        using (var stringBuilder = new ReuseableStringBuilder(sha.HashSize))
                         {
-                            foreach (var b in sha1.Hash)
+                            foreach (var b in sha.Hash)
                             {
                                 stringBuilder.Append(b.ToString("x2"));
                             }
@@ -100,9 +105,9 @@ public override bool Execute()
                     }
                     finally
                     {
-                        if (sha1Buffer != null)
+                        if (shaBuffer != null)
                         {
-                            System.Buffers.ArrayPool<byte>.Shared.Return(sha1Buffer);
+                            System.Buffers.ArrayPool<byte>.Shared.Return(shaBuffer);
                         }
                         if (itemSpecChunkByteBuffer != null)
                         {
@@ -114,44 +119,54 @@ public override bool Execute()
             return true;
         }
 
+        private HashAlgorithm CreateHashAlgorithm()
+        {
+            return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) ? 
+                SHA256.Create() : 
+#pragma warning disable CA5350
+                // Kept for back compatibility reasons when chnange wave is opted-out
+                SHA1.Create();
+#pragma warning restore CA5350
+        }
+
         /// <summary>
-        /// Add bytes to the sha1 buffer. Once the limit size is reached, sha1.TransformBlock is called and the buffer is flushed.
+        /// Add bytes to the sha buffer. Once the limit size is reached, sha.TransformBlock is called and the buffer is flushed.
         /// </summary>
-        /// <param name="sha1">Hashing algorithm sha1.</param>
-        /// <param name="sha1Buffer">The sha1 buffer which stores bytes of the strings. Bytes should be added to this buffer.</param>
-        /// <param name="sha1BufferPosition">Number of used bytes of the sha1 buffer.</param>
-        /// <param name="sha1BufferSize">The size of sha1 buffer.</param>
-        /// <param name="byteBuffer">Bytes buffer which contains bytes to be written to sha1 buffer.</param>
-        /// <param name="byteCount">Amount of bytes that are to be added to sha1 buffer.</param>
-        /// <returns>Updated sha1BufferPosition.</returns>
-        private int AddBytesToSha1Buffer(SHA1 sha1, byte[] sha1Buffer, int sha1BufferPosition, int sha1BufferSize, byte[] byteBuffer, int byteCount)
+        /// <param name="sha">Hashing algorithm sha.</param>
+        /// <param name="shaBuffer">The sha buffer which stores bytes of the strings. Bytes should be added to this buffer.</param>
+        /// <param name="shaBufferPosition">Number of used bytes of the sha buffer.</param>
+        /// <param name="shaBufferSize">The size of sha buffer.</param>
+        /// <param name="byteBuffer">Bytes buffer which contains bytes to be written to sha buffer.</param>
+        /// <param name="byteCount">Amount of bytes that are to be added to sha buffer.</param>
+        /// <returns>Updated shaBufferPosition.</returns>
+        private int AddBytesToShaBuffer(HashAlgorithm sha, byte[] shaBuffer, int shaBufferPosition, int shaBufferSize, byte[] byteBuffer, int byteCount)
         {
             int bytesProcessed = 0;
-            while (sha1BufferPosition + byteCount >= sha1BufferSize)
+            while (shaBufferPosition + byteCount >= shaBufferSize)
             {
-                int sha1BufferFreeSpace = sha1BufferSize - sha1BufferPosition;
+                int shaBufferFreeSpace = shaBufferSize - shaBufferPosition;
 
-                if (sha1BufferPosition == 0)
+                if (shaBufferPosition == 0)
                 {
-                    // If sha1 buffer is empty and bytes number is big enough there is no need to copy bytes to sha1 buffer.
+                    // If sha buffer is empty and bytes number is big enough there is no need to copy bytes to sha buffer.
                     // Pass the bytes to TransformBlock right away.
-                    sha1.TransformBlock(byteBuffer, bytesProcessed, sha1BufferSize, null, 0);
+                    sha.TransformBlock(byteBuffer, bytesProcessed, shaBufferSize, null, 0);
                 }
                 else
                 {
-                    Array.Copy(byteBuffer, bytesProcessed, sha1Buffer, sha1BufferPosition, sha1BufferFreeSpace);
-                    sha1.TransformBlock(sha1Buffer, 0, sha1BufferSize, null, 0);
-                    sha1BufferPosition = 0;
+                    Array.Copy(byteBuffer, bytesProcessed, shaBuffer, shaBufferPosition, shaBufferFreeSpace);
+                    sha.TransformBlock(shaBuffer, 0, shaBufferSize, null, 0);
+                    shaBufferPosition = 0;
                 }
 
-                bytesProcessed += sha1BufferFreeSpace;
-                byteCount -= sha1BufferFreeSpace;
+                bytesProcessed += shaBufferFreeSpace;
+                byteCount -= shaBufferFreeSpace;
             }
 
-            Array.Copy(byteBuffer, bytesProcessed, sha1Buffer, sha1BufferPosition, byteCount);
-            sha1BufferPosition += byteCount;
+            Array.Copy(byteBuffer, bytesProcessed, shaBuffer, shaBufferPosition, byteCount);
+            shaBufferPosition += byteCount;
 
-            return sha1BufferPosition;
+            return shaBufferPosition;
         }
     }
 }
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index 101d5b29dc2..9fd40f7963e 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -30,14 +30,13 @@ public InstalledSDKResolver(Dictionary<string, ITaskItem> resolvedSDKs, string s
             _resolvedSDKs = resolvedSDKs;
         }
 
-        /// <summary>
-        /// Resolve references which are found in a specific SDK
-        /// </summary>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/InvalidParameterValueException.cs b/src/Tasks/InvalidParameterValueException.cs
index cfa9c9f52d6..ad9c727d1b8 100644
--- a/src/Tasks/InvalidParameterValueException.cs
+++ b/src/Tasks/InvalidParameterValueException.cs
@@ -38,6 +38,9 @@ internal InvalidParameterValueException(string paramName, string actualValue, st
         /// <summary>
         /// Constructor
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InvalidParameterValueException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
diff --git a/src/Tasks/MakeDir.cs b/src/Tasks/MakeDir.cs
index 4b5412534b0..eb7d2ef3281 100644
--- a/src/Tasks/MakeDir.cs
+++ b/src/Tasks/MakeDir.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// A task that creates a directory
     /// </summary>
-    public class MakeDir : TaskExtension
+    public class MakeDir : TaskExtension, IIncrementalTask
     {
         [Required]
         public ITaskItem[] Directories
@@ -31,6 +31,8 @@ public ITaskItem[] Directories
         [Output]
         public ITaskItem[] DirectoriesCreated { get; private set; }
 
+        public bool FailIfNotIncremental { get; set; }
+
         private ITaskItem[] _directories;
 
         #region ITask Members
@@ -59,10 +61,17 @@ public override bool Execute()
                             // Only log a message if we actually need to create the folder
                             if (!FileUtilities.DirectoryExistsNoThrow(directory.ItemSpec))
                             {
-                                // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
-                                Log.LogMessageFromResources(MessageImportance.Normal, "MakeDir.Comment", directory.ItemSpec);
+                                if (FailIfNotIncremental)
+                                {
+                                    Log.LogErrorFromResources("MakeDir.Comment", directory.ItemSpec);
+                                }
+                                else
+                                {
+                                    // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
+                                    Log.LogMessageFromResources(MessageImportance.Normal, "MakeDir.Comment", directory.ItemSpec);
 
-                                Directory.CreateDirectory(FileUtilities.FixFilePath(directory.ItemSpec));
+                                    Directory.CreateDirectory(FileUtilities.FixFilePath(directory.ItemSpec));
+                                }
                             }
 
                             items.Add(directory);
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 6b7965b66e4..228d7f70fe4 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -527,8 +527,9 @@ private void ValidateConfig()
             if (!TrustInfo.IsFullTrust)
             {
                 var document = new XmlDocument();
-                var xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                using (XmlReader xr = XmlReader.Create(configFile.ResolvedPath, xrs))
+                var xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+                FileStream fs = File.OpenRead(configFile.ResolvedPath);
+                using (XmlReader xr = XmlReader.Create(fs, xrs))
                 {
                     document.Load(xr);
                 }
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 828a2ba70a0..bd2716e8f49 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -193,8 +193,9 @@ public static AssemblyIdentity FromManifest(string path)
             var document = new XmlDocument();
             try
             {
-                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                using (XmlReader xmlReader = XmlReader.Create(path, readerSettings))
+                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+                FileStream fs = File.OpenRead(path);
+                using (XmlReader xmlReader = XmlReader.Create(fs, readerSettings))
                 {
                     document.Load(xmlReader);
                 }
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index 228f7edbeda..be7ce4a1d6c 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -213,8 +213,9 @@ private static string GetInstallableFramework(string redistListFilePath)
             try
             {
                 var doc = new XmlDocument();
-                var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                using (XmlReader xr = XmlReader.Create(redistListFilePath, xrSettings))
+                var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+                FileStream fs = File.OpenRead(redistListFilePath);
+                using (XmlReader xr = XmlReader.Create(fs, xrSettings))
                 {
                     doc.Load(xr);
                     XmlNode fileListNode = doc.DocumentElement;
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index 8f55d2f3540..0dd8e3bf679 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -376,8 +376,9 @@ internal bool TreatUnfoundNativeAssembliesAsPrerequisites
         internal static void UpdateEntryPoint(string inputPath, string outputPath, string updatedApplicationPath, string applicationManifestPath, string targetFrameworkVersion)
         {
             var document = new XmlDocument();
-            var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-            using (XmlReader xr = XmlReader.Create(inputPath, xrSettings))
+            var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+            FileStream fs = File.OpenRead(inputPath);
+            using (XmlReader xr = XmlReader.Create(fs, xrSettings))
             {
                 document.Load(xr);
             }
@@ -486,7 +487,7 @@ private void UpdateAssemblyReference(AssemblyReference a, string targetFramework
 
         private void UpdateFileReference(BaseReference f, string targetFrameworkVersion)
         {
-            if (String.IsNullOrEmpty(f.ResolvedPath))
+            if (string.IsNullOrEmpty(f.ResolvedPath))
             {
                 throw new FileNotFoundException(null, f.SourcePath);
             }
@@ -505,22 +506,33 @@ private void UpdateFileReference(BaseReference f, string targetFrameworkVersion)
             f.Size = size;
 
             //
-            // .NETCore Launcher.exe based Deployment: If the filereference is for apphost.exe, we need to change
-            // the ResolvedPath and TargetPath to {assemblyname}.exe before we write the manifest, so that the
-            // manifest does not have a file reference to apphost.exe
+            // .NET >= 5 ClickOnce: If the file reference is for apphost.exe, we need to change the filename
+            // in ResolvedPath to TargetPath so we don't end up publishing the file as apphost.exe.
+            // If the TargetPath is not present, we will fallback to AssemblyName.
             //
             string fileName = Path.GetFileName(f.ResolvedPath);
             if (LauncherBasedDeployment &&
-                fileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) &&
-                !String.IsNullOrEmpty(AssemblyName))
+                fileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase))
             {
-                f.ResolvedPath = Path.Combine(Path.GetDirectoryName(f.ResolvedPath), AssemblyName);
-                f.TargetPath = BaseReference.GetDefaultTargetPath(f.ResolvedPath);
+                if (!string.IsNullOrEmpty(f.TargetPath))
+                {
+                    f.ResolvedPath = Path.Combine(Path.GetDirectoryName(f.ResolvedPath), f.TargetPath);
+                }
+                else if (!string.IsNullOrEmpty(AssemblyName))
+                {
+                    f.ResolvedPath = Path.Combine(Path.GetDirectoryName(f.ResolvedPath), AssemblyName);
+                    f.TargetPath = BaseReference.GetDefaultTargetPath(f.ResolvedPath);
+                }
+                else
+                {
+                    Debug.Assert(false, "AssemblyName cannot be empty");
+                    OutputMessages.AddWarningMessage("GenerateManifest.InvalidValue", "AssemblyName");
+                }
             }
 
-            if (String.IsNullOrEmpty(f.TargetPath))
+            if (string.IsNullOrEmpty(f.TargetPath))
             {
-                if (!String.IsNullOrEmpty(f.SourcePath))
+                if (!string.IsNullOrEmpty(f.SourcePath))
                 {
                     f.TargetPath = BaseReference.GetDefaultTargetPath(f.SourcePath);
                 }
diff --git a/src/Tasks/ManifestUtil/ManifestReader.cs b/src/Tasks/ManifestUtil/ManifestReader.cs
index 7f3ccb4f721..fc4afee3919 100644
--- a/src/Tasks/ManifestUtil/ManifestReader.cs
+++ b/src/Tasks/ManifestUtil/ManifestReader.cs
@@ -61,15 +61,17 @@ private static XmlDocument GetXmlDocument(string path)
                 // if first two bytes are "MZ" then we're looking at an .exe or a .dll not a .manifest
                 if ((buffer[0] == 0x4D) && (buffer[1] == 0x5A))
                 {
-                    Stream m = EmbeddedManifestReader.Read(path);
-                    if (m == null)
+                    using (Stream m = EmbeddedManifestReader.Read(path))
                     {
-                        throw new BadImageFormatException(null, path);
-                    }
+                        if (m == null)
+                        {
+                            throw new BadImageFormatException(null, path);
+                        }
 
-                    using (XmlReader xr = XmlReader.Create(m, xrSettings))
-                    {
-                        document.Load(xr);
+                        using (XmlReader xr = XmlReader.Create(m, xrSettings))
+                        {
+                            document.Load(xr);
+                        }
                     }
                 }
                 else
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index 1428e5a01f8..de99413b6bc 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -45,6 +45,24 @@ public static string Format(string path)
 
             string resolvedPath = Resolve(path);
             Uri u = new Uri(resolvedPath);
+            //
+            // GB18030: Uri class does not correctly encode chars in the PUA range for implicit 
+            // file paths (paths without explicit scheme):
+            // https://github.com/dotnet/runtime/issues/89538
+            // Workaround is to use UriBuilder with the file scheme specified explicitly to 
+            // correctly encode the PUA chars.
+            //
+            if (Uri.UriSchemeFile.Equals(u.Scheme, StringComparison.OrdinalIgnoreCase) &&
+                !IsAsciiString(resolvedPath))
+            {
+                UriBuilder builder = new UriBuilder()
+                {
+                    Scheme = Uri.UriSchemeFile,
+                    Host = string.Empty,
+                    Path = resolvedPath,
+                };
+                u = builder.Uri;
+            }
             return u.AbsoluteUri;
         }
 
@@ -209,5 +227,15 @@ public static string Resolve(string path)
             // if not unc or url then it must be a local disk path...
             return Path.GetFullPath(path); // make sure it's a full path
         }
+
+        private static bool IsAsciiString(string str)
+        {
+            foreach (char c in str)
+            {
+                if (c > 127)
+                {  return false; }
+            }
+            return true;
+        }
     }
 }
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 01a5da96803..3ff93e72a18 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -694,8 +694,10 @@ private static void SignFileInternal(X509Certificate2 cert,
                     try
                     {
                         var doc = new XmlDocument { PreserveWhitespace = true };
-                        var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                        using (XmlReader xr = XmlReader.Create(path, xrSettings))
+                        var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+                        FileStream fs = File.OpenRead(path);
+
+                        using (XmlReader xr = XmlReader.Create(fs, xrSettings))
                         {
                             doc.Load(xr);
                         }
@@ -838,7 +840,7 @@ internal static string GetCommandLineParameters(string certThumbprint, Uri times
             {
                 commandLine.AppendFormat(CultureInfo.InvariantCulture,
                                             "{0} {1} ",
-                                            useRFC3161Timestamp ? "/tr" : "/t",
+                                            useRFC3161Timestamp ? "/td sha256 /tr" : "/t",
                                             timestampUrl.ToString());
             }
             commandLine.AppendFormat(CultureInfo.InvariantCulture, "\"{0}\"", path);
diff --git a/src/Tasks/ManifestUtil/XmlUtil.cs b/src/Tasks/ManifestUtil/XmlUtil.cs
index e2360d23b24..ca35d8090a0 100644
--- a/src/Tasks/ManifestUtil/XmlUtil.cs
+++ b/src/Tasks/ManifestUtil/XmlUtil.cs
@@ -97,36 +97,38 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
             Util.CopyStream(input, clonedInput);
 
             int t4 = Environment.TickCount;
-            XmlReader xml = XmlReader.Create(clonedInput);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "new XmlReader(2) t={0}", Environment.TickCount - t4));
-
-            XsltArgumentList args = null;
-            if (entries.Length > 0)
+            using (XmlReader reader = XmlReader.Create(clonedInput))
             {
-                args = new XsltArgumentList();
-                foreach (DictionaryEntry entry in entries)
+                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "new XmlReader(2) t={0}", Environment.TickCount - t4));
+
+                XsltArgumentList args = null;
+                if (entries.Length > 0)
                 {
-                    string key = entry.Key.ToString();
-                    object val = entry.Value.ToString();
-                    args.AddParam(key, "", val);
-                    Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "arg: key='{0}' value='{1}'", key, val.ToString()));
+                    args = new XsltArgumentList();
+                    foreach (DictionaryEntry entry in entries)
+                    {
+                        string key = entry.Key.ToString();
+                        object val = entry.Value.ToString();
+                        args.AddParam(key, "", val);
+                        Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "arg: key='{0}' value='{1}'", key, val.ToString()));
+                    }
                 }
-            }
 
-            var m = new MemoryStream();
-            var w = new XmlTextWriter(m, Encoding.UTF8);
-            w.WriteStartDocument();
+                var m = new MemoryStream();
+                var w = new XmlTextWriter(m, Encoding.UTF8);
+                w.WriteStartDocument();
 
-            int t5 = Environment.TickCount;
-            xslc.Transform(xml, args, w, s_resolver);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform.Transform t={0}", Environment.TickCount - t4));
+                int t5 = Environment.TickCount;
+                xslc.Transform(reader, args, w, s_resolver);
+                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform.Transform t={0}", Environment.TickCount - t4));
 
-            w.WriteEndDocument();
-            w.Flush();
-            m.Position = 0;
+                w.WriteEndDocument();
+                w.Flush();
+                m.Position = 0;
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform(\"{0}\") t={1}", resource, Environment.TickCount - t1));
-            return m;
+                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform(\"{0}\") t={1}", resource, Environment.TickCount - t1));
+                return m;
+            }
         }
 
         private class ResourceResolver : XmlUrlResolver
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 29c34e47730..3b19aee2b1e 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -612,8 +612,10 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
                 {
                     XmlReaderSettings settings = new XmlReaderSettings();
                     settings.DtdProcessing = DtdProcessing.Parse;
-                    XmlReader reader = XmlReader.Create(stringReader, settings, manifestDom.BaseURI);
-                    normalizedDom.Load(reader);
+                    using (XmlReader reader = XmlReader.Create(stringReader, settings, manifestDom.BaseURI))
+                    {
+                        normalizedDom.Load(reader);
+                    }
                 }
 
                 XmlDsigExcC14NTransform exc = new XmlDsigExcC14NTransform();
@@ -883,7 +885,7 @@ private static void TimestampSignedLicenseDom(XmlDocument licenseDom, string tim
                 // Try RFC3161 first
                 XmlElement signatureValueNode = licenseDom.SelectSingleNode("r:license/r:issuer/ds:Signature/ds:SignatureValue", nsm) as XmlElement;
                 string signatureValue = signatureValueNode.InnerText;
-                timestamp = ObtainRFC3161Timestamp(timeStampUrl, signatureValue, useSha256);
+                timestamp = ObtainRFC3161Timestamp(timeStampUrl, signatureValue, true);
             }
             // Catch CryptographicException to ensure fallback to old code (non-RFC3161)
             catch (CryptographicException)
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 98a5bcc42c7..e11a7698f31 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -30,9 +30,6 @@
   </ItemGroup>
   <ItemGroup>
     <!-- Binary serialization by ITranslatable -->
-    <Compile Include="..\Shared\ITranslatable.cs" />
-    <Compile Include="..\Shared\ITranslator.cs" />
-    <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
   </ItemGroup>
@@ -150,9 +147,6 @@
     <Compile Include="..\Shared\AssemblyNameExtension.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -975,7 +969,6 @@
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
-
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Resources.Extensions" />
   </ItemGroup>
@@ -995,26 +988,26 @@
     <PackageReference Include="Microsoft.Net.Compilers.Toolset" ExcludeAssets="all" Condition="'$(UsingToolMicrosoftNetCompilers)' == 'false'" />
   </ItemGroup>
 
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'">
+    <PackageReference Include="System.Threading.Tasks.Dataflow" />
+  </ItemGroup>
+
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildFromSource)' != 'true'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
-    <PackageReference Include="System.Threading.Tasks.Dataflow" />
-
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\net472\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="Microsoft.Win32.Registry" />
+    <PackageReference Include="System.Reflection.Metadata" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <PackageReference Include="System.CodeDom" />
-    <PackageReference Include="System.Reflection.Metadata" />
     <PackageReference Include="System.Security.Cryptography.Pkcs" />
     <PackageReference Include="System.Security.Cryptography.Xml" />
-    <PackageReference Include="System.Security.Permissions" />
-    <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\netcore\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index af1a6b18164..44bed1b25ba 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -76,6 +76,34 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <!--
+    Target that allows targets consuming source control confirmation to establish a dependency on targets producing this information.
+
+    Any target that reads SourceRevisionId, PrivateRepositoryUrl, SourceRoot, and other source control properties and items
+    should depend on this target and be conditioned on '$(SourceControlInformationFeatureSupported)' == 'true'.
+
+    SourceRevisionId property uniquely identifies the source control revision of the repository the project belongs to.
+    For Git repositories this id is a commit hash, for TFVC repositories it's the changeset number, etc.
+
+    PrivateRepositoryUrl property stores the URL of the repository supplied by the CI server or retrieved from source control manager.
+    Targets consuming this property shall not publish its value implicitly as it might inadvertently reveal an internal URL.
+    Instead, they shall only do so if the project sets PublishRepositoryUrl property to true. For example, the NuGet Pack target
+    may include the repository URL in the nuspec file generated for NuGet package produced by the project if PublishRepositoryUrl is true.
+
+    SourceRoot item group lists all source roots that the project source files reside under and their mapping to source control server URLs,
+    if available. This includes both source files under source control as well as source files in source packages. SourceRoot items are
+    used by compilers to determine path map in deterministic build and by SourceLink provider, which maps local paths to URLs of source files
+    stored on the source control server.
+
+    Source control information provider that sets these properties and items shall execute before this target (by including
+    InitializeSourceControlInformation in its BeforeTargets) and set source control properties and items that haven't been initialized yet.
+  -->
+  <Target Name="InitializeSourceControlInformation" />
+
+  <PropertyGroup>
+    <SourceControlInformationFeatureSupported>true</SourceControlInformationFeatureSupported>
+  </PropertyGroup>
+
   <!--
   ============================================================
                                        DispatchToInnerBuilds
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 67bcd918721..bcf0e99af18 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1,4 +1,4 @@
-Ôªø<!--
+<!--
 ***********************************************************************************************
 Microsoft.Common.CurrentVersion.targets
 
@@ -1027,6 +1027,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </MSBuild>
   </Target>
 
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'">
+    <ProjectReferenceTargets Include="BuildGenerateSources" Targets="BuildGenerateSources" />
+  </ItemGroup>
+
   <!--
     ============================================================
                                         BuildCompile
@@ -1052,6 +1056,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </MSBuild>
   </Target>
 
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'">
+    <ProjectReferenceTargets Include="BuildCompile" Targets="BuildCompile" />
+  </ItemGroup>
+
   <!--
     ============================================================
                                         BuildLink
@@ -1077,6 +1085,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </MSBuild>
   </Target>
 
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'">
+    <ProjectReferenceTargets Include="BuildLink" Targets="BuildLink" />
+  </ItemGroup>
+
   <!--
     ============================================================
                                         CopyRunEnvironmentFiles
@@ -1175,7 +1187,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Create the directories for intermediate and final build products, and any other arbitrary directories. -->
     <!-- We are going to continue on error here so that if the tree is read only we will still get intellisense -->
-    <MakeDir Directories="$(OutDir);$(IntermediateOutputPath);@(DocFileItem->'%(RelativeDir)');@(CreateDirectory)" ContinueOnError="True"/>
+    <MakeDir Directories="$(OutDir);$(IntermediateOutputPath);@(DocFileItem->'%(RelativeDir)');@(CreateDirectory)" ContinueOnError="true"/>
 
   </Target>
 
@@ -1232,7 +1244,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         RootPath="$(TargetFrameworkRootPath)"
         TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)"
         BypassFrameworkInstallChecks="$(BypassFrameworkInstallChecks)"
-        >
+        ContinueOnError="!$(BuildingProject)">
       <Output TaskParameter="ReferenceAssemblyPaths" PropertyName="_TargetFrameworkDirectories"/>
       <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths"/>
       <Output TaskParameter="TargetFrameworkMonikerDisplayName" PropertyName="TargetFrameworkMonikerDisplayName" Condition="'$(TargetFrameworkMonikerDisplayName)' == ''"/>
@@ -1288,7 +1300,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
                                         AssignLinkMetadata
 
-       For items of a certain set of whitelisted types, make sure that
+       For items of a certain set of allowlisted types, make sure that
        if they are defined in a file other than the project file, that
        they have "Link" metadata set to an appropriate default.
     ============================================================
@@ -1471,6 +1483,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       ResolveNativeReferences;
       ResolveAssemblyReferences;
       GenerateBindingRedirects;
+      GenerateBindingRedirectsUpdateAppConfig;
       ResolveComReferences;
       AfterResolveReferences
     </ResolveReferencesDependsOn>
@@ -1498,6 +1511,24 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <Target Name="AfterResolveReferences"/>
+  
+  <!--
+    ============================================================
+                                        IgnoreJavaScriptOutputAssembly
+
+    esproj are JavaScript or TypeScript Projects that never produce an assembly.
+    Set ReferenceOutputAssembly to false in any reference to an esproj.
+    ============================================================
+    -->
+  <Target Name="IgnoreJavaScriptOutputAssembly"
+    BeforeTargets="AssignProjectConfiguration"
+    Condition="$([MSBuild]::AreFeaturesEnabled('17.8'))">
+      <ItemGroup>
+        <ProjectReference Condition="'%(ProjectReference.Extension)' == '.esproj' and '%(ProjectReference.ReferenceOutputAssembly)' == ''">
+          <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+        </ProjectReference>
+      </ItemGroup>
+  </Target>
 
   <!--
     ============================================================
@@ -1635,7 +1666,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
        Configuration information. See AssignProjectConfiguration -->
   <Target Name="_GetProjectReferencePlatformProperties"
           Condition="'$(EnableDynamicPlatformResolution)' == 'true'
-                     and '$(CurrentSolutionConfigurationContents)' == ''
                      and '@(_MSBuildProjectReferenceExistent)' != ''">
 
     <!-- Allow preset SetPlatform to override this operation -->
@@ -2464,20 +2494,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ====================================================================================================
   -->
   <Target Name="GenerateBindingRedirects"
-    Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(ResolveAssemblyReferencesStateFile);$(SuggestedBindingRedirectsCacheFile)"
+    Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(SuggestedBindingRedirectsCacheFile)"
     Outputs="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'"
+    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and '@(SuggestedBindingRedirects)' != '' and '$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'"
     DependsOnTargets="_GenerateSuggestedBindingRedirectsCache">
 
     <GenerateBindingRedirects
       AppConfigFile="@(AppConfigWithTargetPath)"
       TargetName="$(TargetFileName).config"
       OutputAppConfigFile="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-      SuggestedRedirects="@(SuggestedBindingRedirects)"
-      >
-      <Output TaskParameter="OutputAppConfigFile" ItemName="FileWrites" />
-    </GenerateBindingRedirects>
+      SuggestedRedirects="@(SuggestedBindingRedirects)" />
 
+    <ItemGroup>
+      <FileWrites Include="$(_GenerateBindingRedirectsIntermediateAppConfig)" />
+    </ItemGroup>
   </Target>
 
   <!--
@@ -2489,20 +2519,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ====================================================================================================
   -->
   <Target Name="GenerateBindingRedirectsUpdateAppConfig"
-    AfterTargets="GenerateBindingRedirects"
-    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')">
+    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'">
 
     <PropertyGroup>
-      <AppConfig>$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
+      <_NewGenerateBindingRedirectsIntermediateAppConfig Condition="Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')">true</_NewGenerateBindingRedirectsIntermediateAppConfig>
+      <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
-
-    <ItemGroup>
+    
+    <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
         <TargetPath>$(TargetFileName).config</TargetPath>
       </AppConfigWithTargetPath>
     </ItemGroup>
-
   </Target>
 
   <!--
@@ -2698,6 +2727,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </MSBuild>
   </Target>
 
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(FindInvalidProjectReferences)' == 'true'">
+    <ProjectReferenceTargets Include="Build" Targets="GetTargetPathWithTargetPlatformMoniker" />
+  </ItemGroup>
+
    <!--
     ============================================================
 
@@ -3328,8 +3361,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         SdkToolsPath="$(ResgenToolPath)"
         ExecuteAsTool="$(ResGenExecuteAsTool)"
         EnvironmentVariables="$(ResGenEnvironment)"
+        WarnOnBinaryFormatterUse="$(GenerateResourceWarnOnBinaryFormatterUse)"
         MSBuildRuntime="$(GenerateResourceMSBuildRuntime)"
-        MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">
+        MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)"
+        >
 
       <Output TaskParameter="FilesWritten" ItemName="FileWrites"/>
       <Output TaskParameter="StronglyTypedFileName" ItemName="Compile"/>
@@ -3581,7 +3616,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths"
           Inputs="$(MSBuildToolsPath)\Microsoft.Common.targets"
           Outputs="$(TargetFrameworkMonikerAssemblyAttributesPath)"
-          Condition="'$(GenerateTargetFrameworkAttribute)' == 'true'">
+          Condition="'@(Compile)' != '' and '$(GenerateTargetFrameworkAttribute)' == 'true'">
 
     <!-- This is a file shared between projects so we have to take care to handle simultaneous writes (by ContinueOnError)
              and a race between clean from one project and build from another (by not adding to FilesWritten so it doesn't clean) -->
@@ -3719,7 +3754,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="HashResult" PropertyName="CoreCompileDependencyHash" />
     </Hash>
 
-    <WriteLinesToFile Lines="$(CoreCompileDependencyHash)" File="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" Overwrite="True" WriteOnlyWhenDifferent="True" />
+    <WriteLinesToFile Lines="$(CoreCompileDependencyHash)" File="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" Overwrite="true" WriteOnlyWhenDifferent="true" />
 
     <ItemGroup>
       <FileWrites Include="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" />
@@ -4339,14 +4374,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-  <PropertyGroup>
-    <DeploymentComputeClickOnceManifestInfoDependsOn>
-      CleanPublishFolder;
-      _DeploymentGenerateTrustInfo
-      $(DeploymentComputeClickOnceManifestInfoDependsOn)
-    </DeploymentComputeClickOnceManifestInfoDependsOn>
-  </PropertyGroup>
-
   <!--
     ============================================================
                                         _DeploymentComputeClickOnceManifestInfo
@@ -4405,7 +4432,29 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)"
                                       Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
       <_ClickOnceRuntimeCopyLocalItems Remove="@(_DeploymentReferencePaths)" />
-      <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems)"/>
+
+      <!--
+        For .NET>=5, we need to check if we need to publish any content items from transitive project references. For such items to be published, they
+        either have the .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
+        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
+      -->
+      <_ClickOnceTransitiveContentItemsTemp Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(TargetPath)')" Condition="'$(PublishProtocol)' == 'ClickOnce'" >
+        <SavedIdentity>%(Identity)</SavedIdentity>
+      </_ClickOnceTransitiveContentItemsTemp>
+      <_ClickOnceTransitiveContentItems Include="@(_ClickOnceTransitiveContentItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
+
+      <!--
+        For .NET>=5, we need to check if we need to publish any copylocal items from None group. For such items to be published, they either 
+        have .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection. 
+        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
+      -->
+      <!-- Include items from None group for publishing -->
+      <_ClickOnceNoneItemsTemp Include="@(_NoneWithTargetPath->'%(TargetPath)')" Condition="'$(PublishProtocol)'=='Clickonce' And ('%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest')">
+        <SavedIdentity>%(Identity)</SavedIdentity>
+      </_ClickOnceNoneItemsTemp>
+      <_ClickOnceNoneItems Include="@(_ClickOnceNoneItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
+
+      <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems);@(_ClickOnceNoneItems);@(_ClickOnceTransitiveContentItems)"/>
     </ItemGroup>
 
     <!-- For single file publish, we need to include the SF bundle EXE, application icon file and files excluded from the bundle EXE in the clickonce manifest -->
@@ -4961,7 +5010,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Target
     Name="_GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences"
     DependsOnTargets="_PopulateCommonStateForGetCopyToOutputDirectoryItems;_AddOutputPathToGlobalPropertiesToRemove"
-    Returns="@(_TransitiveItemsToCopyToOutputDirectory)">
+    Returns="@(_CopyToOutputDirectoryTransitiveItems)">
 
     <!-- Get items from child projects first. -->
     <MSBuild
@@ -4980,8 +5029,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Target outputs must be full paths because they will be consumed by a different project. -->
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
-      <_TransitiveItemsToCopyToOutputDirectory   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
+      <_CopyToOutputDirectoryTransitiveItems   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
+      <_CopyToOutputDirectoryTransitiveItems   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
     </ItemGroup>
 
     <!-- Remove items which we will never again use - they just sit around taking up memory otherwise -->
@@ -4991,13 +5040,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Copy paste _GetCopyToOutputDirectoryItemsFromThisProject but keep the items that came from other projects via ProjectReference's OutputItemType metadata -->
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
     </ItemGroup>
 
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
     </ItemGroup>
 
     <ItemGroup>
@@ -5009,13 +5058,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </AssignTargetPath>
 
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
     </ItemGroup>
 
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
     </ItemGroup>
 
   </Target>
@@ -5091,7 +5140,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <!-- Empty intermediate items to release memory -->
       <_TransitiveItemsToCopyToOutputDirectoryAlways               Remove="@(_TransitiveItemsToCopyToOutputDirectoryAlways)"/>
       <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest       Remove="@(_TransitiveItemsToCopyToOutputDirectoryPreserveNewest)"/>
-      <_TransitiveItemsToCopyToOutputDirectory                     Remove="@(_TransitiveItemsToCopyToOutputDirectory)"/>
 
       <_ThisProjectItemsToCopyToOutputDirectoryAlways              Remove="@(_ThisProjectItemsToCopyToOutputDirectoryAlways)"/>
       <_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest      Remove="@(_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest)"/>
@@ -5671,7 +5719,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <MakeDir Directories="$(IntermediateOutputPath)"/>
 
     <!-- Write new list of current files back to disk. -->
-    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWrites)" Overwrite="true" />
+    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWrites)" WriteOnlyWhenDifferent="true" Overwrite="true" />
 
   </Target>
 
@@ -5703,7 +5751,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <WriteLinesToFile
         File="$(IntermediateOutputPath)$(CleanFile)"
         Lines="@(_CleanUniqueFileWrites)"
-        Overwrite="true" />
+        Overwrite="true"
+        WriteOnlyWhenDifferent="true" />
 
   </Target>
 
@@ -5769,6 +5818,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ***********************************************************************************************
     -->
 
+  <PropertyGroup>
+    <DeploymentComputeClickOnceManifestInfoDependsOn>
+      CleanPublishFolder;
+      $(_RecursiveTargetForContentCopying);
+      _DeploymentGenerateTrustInfo
+      $(DeploymentComputeClickOnceManifestInfoDependsOn)
+    </DeploymentComputeClickOnceManifestInfoDependsOn>
+  </PropertyGroup>
+
   <!--
     ============================================================
                                         Publish
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index a14fea277c2..e3771628bdd 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -29,8 +29,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
   </PropertyGroup>
 
+  <Import Project="$(CustomBeforeDirectoryBuildProps)" Condition="'$(CustomBeforeDirectoryBuildProps)' != ''" />
+
   <Import Project="$(DirectoryBuildPropsPath)" Condition="'$(ImportDirectoryBuildProps)' == 'true' and exists('$(DirectoryBuildPropsPath)')"/>
 
+  <Import Project="$(CustomAfterDirectoryBuildProps)" Condition="'$(CustomAfterDirectoryBuildProps)' != ''" />
+
   <!--
       Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
         $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.props
diff --git a/src/Tasks/Microsoft.Common.targets b/src/Tasks/Microsoft.Common.targets
index e4f83cd7640..4e71065ca26 100644
--- a/src/Tasks/Microsoft.Common.targets
+++ b/src/Tasks/Microsoft.Common.targets
@@ -48,6 +48,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
   </PropertyGroup>
 
+  <Import Project="$(CustomBeforeDirectoryBuildTargets)" Condition="'$(CustomBeforeDirectoryBuildTargets)' != ''" />
+
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
 
+  <Import Project="$(CustomAfterDirectoryBuildTargets)" Condition="'$(CustomAfterDirectoryBuildTargets)' != ''" />
+
 </Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index d91e88e9861..beab1878e60 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -16,9 +16,9 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.AssignTargetPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.ConvertToAbsolutePath"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CombineXmlElements"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ConvertToAbsolutePath"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Copy"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -32,7 +32,6 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FindInList"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FindInvalidProjectReferences"          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-
   <UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FormatUrl"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FormatVersion"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -53,8 +52,9 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFileHash"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetInstalledSDKLocations"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.SetRidAgnosticValueForProjects"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetSDKReferenceFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Hash"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.LC"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -72,15 +72,13 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.RequiresFramework35SP1Assembly"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveAssemblyReference"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.GetInstalledSDKLocations"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.GetSDKReferenceFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveKeySource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveManifestFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveNativeReference"                AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.SetRidAgnosticValueForProjects"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.SGen"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.SignFile"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Telemetry"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -90,21 +88,21 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Unzip"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.VerifyFileHash"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Warning"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.WinMDExp"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.WriteCodeFragment"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.WriteLinesToFile"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.XmlPeek"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.XmlPoke"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.XslTransformation"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.WinMDExp"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ZipDirectory"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
   <!-- Roslyn tasks are now in an assembly owned and shipped by Roslyn -->
+  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
-  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
 
 </Project>
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index 68a7e8d274d..88d7d0b07df 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -36,17 +36,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       Properties for extension of ProjectReferenceTargets.
       Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
   -->
-  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
-    <!-- Empty case is for outer builds which do not import the target files that set BuildProjectReferences -->
+  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' != 'true'">
+    <!-- Empty case is for builds which do not import the target files that set BuildProjectReferences -->
     <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
     <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
 
     <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
 
-    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
-
-    <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
-
     <!-- Publish has the same logic as Build for the main reference target except it also takes $(NoBuild) into account. -->
     <_MainReferenceTargetForPublish Condition="'$(NoBuild)' == 'true'">GetTargetPath</_MainReferenceTargetForPublish>
     <_MainReferenceTargetForPublish Condition="'$(NoBuild)' != 'true'">$(_MainReferenceTargetForBuild)</_MainReferenceTargetForPublish>
@@ -58,23 +54,30 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' == 'true'">
+    <ProjectReferenceTargetsForBuild>.default;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
+    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
+    <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
+  </PropertyGroup>
 
   <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true" />
-    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" />
+    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
 
     <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true" />
-    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" />
+    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
     <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
 
     <!--
      Note: SkipNonexistentTargets="true" on the following three items means that an outer build node's call to its existent GetTargetFrameworks target will fail if its inner build nodes don't define GetTargetFrameworksWithPlatformForSingleTargetFrameworks.
      This is necessary since the P2P protocol cannot express the targets called from the outer build to the inner build.
      -->
-    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
-    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
-    <ProjectReferenceTargets Include="Rebuild" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
+    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
+    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
+    <ProjectReferenceTargets Include="Rebuild" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
 
     <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
 
@@ -83,4 +86,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ProjectReferenceTargets Include="GetCopyToPublishDirectoryItems" Targets="$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)" Condition=" '$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)' != '' " />
   </ItemGroup>
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/Move.cs b/src/Tasks/Move.cs
index 42f0e20b968..746ce275be7 100644
--- a/src/Tasks/Move.cs
+++ b/src/Tasks/Move.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.Tasks
     /// but this could restriction could be lifted as MoveFileEx,
     /// which is used here, supports it.
     /// </remarks>
-    public class Move : TaskExtension, ICancelableTask
+    public class Move : TaskExtension, ICancelableTask, IIncrementalTask
     {
         /// <summary>
         /// Flags for MoveFileEx.
@@ -62,11 +62,19 @@ public class Move : TaskExtension, ICancelableTask
         public ITaskItem[] DestinationFiles { get; set; }
 
         /// <summary>
-        /// Subset that were successfully moved 
+        /// Subset that were successfully moved.
         /// </summary>
         [Output]
         public ITaskItem[] MovedFiles { get; private set; }
 
+        /// <summary>
+        /// Set question parameter for Move task.
+        /// </summary>
+        /// <remarks>Move can be chained A->B->C with location C as the final location.
+        /// Incrementally, it is hard to question A->B if both files are gone.
+        /// In short, question will always return false and author should use target inputs/outputs.</remarks>
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// Stop and return (in an undefined state) as soon as possible.
         /// </summary>
@@ -149,7 +157,7 @@ public override bool Execute()
 
                 try
                 {
-                    if (MoveFileWithLogging(sourceFile, destinationFile))
+                    if (!FailIfNotIncremental && MoveFileWithLogging(sourceFile, destinationFile))
                     {
                         SourceFiles[i].CopyMetadataTo(DestinationFiles[i]);
                         destinationFilesSuccessfullyMoved.Add(DestinationFiles[i]);
@@ -175,7 +183,7 @@ public override bool Execute()
         }
 
         /// <summary>
-        /// Makes the provided file writeable if necessary
+        /// Makes the provided file writeable if necessary.
         /// </summary>
         private static void MakeWriteableIfReadOnly(string file)
         {
@@ -189,7 +197,7 @@ private static void MakeWriteableIfReadOnly(string file)
         /// <summary>
         /// Move one file from source to destination. Create the target directory if necessary.
         /// </summary>
-        /// <throws>IO related exceptions</throws>
+        /// <throws>IO related exceptions.</throws>
         private bool MoveFileWithLogging(
             string sourceFile,
             string destinationFile)
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index c173abab5b9..86faefd4fb7 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -537,6 +537,7 @@ internal static class NativeMethods
 
         internal const int HRESULT_E_CLASSNOTREGISTERED = -2147221164;
 
+        internal const int ERROR_INVALID_FILENAME = -2147024773; // Illegal characters in name
         internal const int ERROR_ACCESS_DENIED = -2147024891; // ACL'd or r/o
         internal const int ERROR_SHARING_VIOLATION = -2147024864; // File locked by another use
 
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 2337f450180..f439aa4939b 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -66,8 +66,8 @@ internal sealed class RedistList
         /// </summary>
         private readonly ConcurrentDictionary<AssemblyNameExtension, AssemblyNameExtension> _remappingCache = new ConcurrentDictionary<AssemblyNameExtension, AssemblyNameExtension>(AssemblyNameComparer.GenericComparerConsiderRetargetable);
 
-        // List of cached BlackList RedistList objects, the key is a semi-colon delimited list of data file paths
-        private readonly ConcurrentDictionary<string, Dictionary<string, string>> _cachedBlackList = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
+        // List of cached DenyList RedistList objects, the key is a semi-colon delimited list of data file paths
+        private readonly ConcurrentDictionary<string, Dictionary<string, string>> _cachedDenyList = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
 
         /***************Fields which are only set in the constructor and should not be modified by the class. **********************/
         // Array of errors encountered while reading files.
@@ -500,27 +500,27 @@ internal IEnumerable<AssemblyEntry> FindAssemblyNameFromSimpleName(string simple
         }
 
         /// <summary>
-        /// This method will take a list of AssemblyTableInfo and generate a black list by subtracting the
-        /// assemblies listed in the WhiteList from the RedistList.
+        /// This method will take a list of AssemblyTableInfo and generate a deny list by subtracting the
+        /// assemblies listed in the AllowList from the RedistList.
         ///
         /// 1) If there are assemblies in the redist list and one or more client subset files are read in with matching names then
-        ///    the subtraction will take place. If there were no matching redist lists read in the black list will be empty.
+        ///    the subtraction will take place. If there were no matching redist lists read in the deny list will be empty.
         ///
-        /// 2) If the subset has a matching name but there are no files inside of it then the black list will contain ALL files in the redist list.
+        /// 2) If the subset has a matching name but there are no files inside of it then the deny list will contain ALL files in the redist list.
         ///
-        /// 3) If the redist list assembly has a null or empty redist name or the subset list has a null or empty subset name they will not be used for black list generation.
+        /// 3) If the redist list assembly has a null or empty redist name or the subset list has a null or empty subset name they will not be used for deny list generation.
         ///
-        /// When generating the blacklist, we will first see if the black list is in the appdomain wide cache
-        /// so that we do not regenerate one for multiple calls using the same whiteListAssemblyTableInfo.
+        /// When generating the denylist, we will first see if the deny list is in the appdomain wide cache
+        /// so that we do not regenerate one for multiple calls using the same allowListAssemblyTableInfo.
         ///
         /// </summary>
-        /// <param name="whiteListAssemblyTableInfo">List of paths to white list xml files</param>
-        /// <param name="whiteListErrors">List of white listed errors</param>
-        /// <param name="whiteListErrorFileNames">List of white listed error file names</param>
-        /// <returns>A dictionary containing the full assembly names of black listed assemblies as the key, and null as the value.
+        /// <param name="allowListAssemblyTableInfo">List of paths to allow list xml files</param>
+        /// <param name="allowListErrors">List of allow listed errors</param>
+        /// <param name="allowListErrorFileNames">List of allow listed error file names</param>
+        /// <returns>A dictionary containing the full assembly names of deny listed assemblies as the key, and null as the value.
         ///          If there is no assemblies in the redist list null is returned.
         /// </returns>
-        internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableInfo, List<Exception> whiteListErrors, List<string> whiteListErrorFileNames)
+        internal Dictionary<string, string> GenerateDenyList(AssemblyTableInfo[] allowListAssemblyTableInfo, List<Exception> allowListErrors, List<string> allowListErrorFileNames)
         {
             // Return null if there are no assemblies in the redist list.
             if (_assemblyList.Count == 0)
@@ -528,44 +528,44 @@ internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteL
                 return null;
             }
 
-            // Sort so that the same set of whiteListAssemblyTableInfo will generate the same key for the cache
-            Array.Sort(whiteListAssemblyTableInfo);
+            // Sort so that the same set of allowListAssemblyTableInfo will generate the same key for the cache
+            Array.Sort(allowListAssemblyTableInfo);
 
-            var keyBuilder = whiteListAssemblyTableInfo.Length > 0 ? new StringBuilder(whiteListAssemblyTableInfo[0].Descriptor) : new StringBuilder();
+            var keyBuilder = allowListAssemblyTableInfo.Length > 0 ? new StringBuilder(allowListAssemblyTableInfo[0].Descriptor) : new StringBuilder();
 
-            // Concatenate the paths to the whitelist xml files together to get the key into the blacklist cache.
-            for (int i = 1; i < whiteListAssemblyTableInfo.Length; ++i)
+            // Concatenate the paths to the allowlist xml files together to get the key into the denylist cache.
+            for (int i = 1; i < allowListAssemblyTableInfo.Length; ++i)
             {
                 keyBuilder.Append(';');
-                keyBuilder.Append(whiteListAssemblyTableInfo[i].Descriptor);
+                keyBuilder.Append(allowListAssemblyTableInfo[i].Descriptor);
             }
 
             string key = keyBuilder.ToString();
 
-            if (!_cachedBlackList.TryGetValue(key, out Dictionary<string, string> returnTable))
+            if (!_cachedDenyList.TryGetValue(key, out Dictionary<string, string> returnTable))
             {
-                var whiteListAssemblies = new List<AssemblyEntry>();
+                var allowListAssemblies = new List<AssemblyEntry>();
 
                 // Unique list of redist names in the subset files read in. We use this to make sure we are subtracting from the correct framework list.
                 var uniqueClientListNames = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
-                // Get the assembly entries for the white list
-                foreach (AssemblyTableInfo info in whiteListAssemblyTableInfo)
+                // Get the assembly entries for the allow list
+                foreach (AssemblyTableInfo info in allowListAssemblyTableInfo)
                 {
-                    var whiteListAssembliesReadIn = new List<AssemblyEntry>();
+                    var allowListAssembliesReadIn = new List<AssemblyEntry>();
 
                     // Need to know how many errors are in the list before the read file call so that if the redist name is null due to an error
                     // we do not get a "redist name is null or empty" error when in actual fact it was a file not found error.
-                    int errorsBeforeReadCall = whiteListErrors.Count;
+                    int errorsBeforeReadCall = allowListErrors.Count;
 
                     // Read in the subset list file. 
-                    string redistName = ReadFile(info, whiteListAssembliesReadIn, whiteListErrors, whiteListErrorFileNames, null);
+                    string redistName = ReadFile(info, allowListAssembliesReadIn, allowListErrors, allowListErrorFileNames, null);
 
                     // Get the client subset name which has been read in.
                     if (!String.IsNullOrEmpty(redistName))
                     {
-                        // Populate the list of assemblies which are to be used as white list assemblies.
-                        whiteListAssemblies.AddRange(whiteListAssembliesReadIn);
+                        // Populate the list of assemblies which are to be used as allow list assemblies.
+                        allowListAssemblies.AddRange(allowListAssembliesReadIn);
 
                         // We may have the same redist name for multiple files, we only want to get the set of unique names.
                         if (!uniqueClientListNames.ContainsKey(redistName))
@@ -577,22 +577,22 @@ internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteL
                     {
                         // There are no extra errors reading in the subset list file which would have caused the redist list name to be null or empty.
                         // This means the redist name read in must be null or empty
-                        if (whiteListErrors.Count == errorsBeforeReadCall)
+                        if (allowListErrors.Count == errorsBeforeReadCall)
                         {
-                            // The whiteList errors passes back problems reading the redist file through the use of an array containing exceptions
-                            whiteListErrors.Add(new Exception(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.NoSubSetRedistListName", info.Path)));
-                            whiteListErrorFileNames.Add(info.Path);
+                            // The allowList errors passes back problems reading the redist file through the use of an array containing exceptions
+                            allowListErrors.Add(new Exception(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.NoSubSetRedistListName", info.Path)));
+                            allowListErrorFileNames.Add(info.Path);
                         }
                     }
                 }
 
                 // Dont care about the case of the assembly name
-                var blackList = new Hashtable(StringComparer.OrdinalIgnoreCase);
+                var denyList = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
                 // Do we have any subset names?
                 bool uniqueClientNamesExist = uniqueClientListNames.Count > 0;
 
-                // Fill the hashtable with the entries, if there are no white list assemblies the black list will contain all assemblies in the redist list
+                // Fill the hashtable with the entries, if there are no allow list assemblies the deny list will contain all assemblies in the redist list
                 foreach (AssemblyEntry entry in _assemblyList)
                 {
                     string entryFullName = entry.FullName;
@@ -605,32 +605,32 @@ internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteL
 
                     string hashKey = entryFullName + "," + redistName;
 
-                    // If there were no subset list names read in we cannot generate a black list. (warnings will be logged as part of the reading of the subset list).
+                    // If there were no subset list names read in we cannot generate a deny list. (warnings will be logged as part of the reading of the subset list).
                     if (uniqueClientNamesExist)
                     {
-                        if (!blackList.ContainsKey(hashKey) && uniqueClientListNames.ContainsKey(redistName))
+                        if (!denyList.ContainsKey(hashKey) && uniqueClientListNames.ContainsKey(redistName))
                         {
-                            blackList[hashKey] = entryFullName;
+                            denyList[hashKey] = entryFullName;
                         }
                     }
                 }
 
-                // Go through each of the white list assemblies and remove it from the black list. Do this based on the assembly name and the redist name
-                foreach (AssemblyEntry whiteListEntry in whiteListAssemblies)
+                // Go through each of the allow list assemblies and remove it from the deny list. Do this based on the assembly name and the redist name
+                foreach (AssemblyEntry allowListEntry in allowListAssemblies)
                 {
-                    blackList.Remove(whiteListEntry.FullName + "," + whiteListEntry.RedistName);
+                    denyList.Remove(allowListEntry.FullName + "," + allowListEntry.RedistName);
                 }
 
                 // The output dictionary needs to be just the full names and not the names + redist name
-                var blackListOfAssemblyNames = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                foreach (string name in blackList.Values)
+                var denyListOfAssemblyNames = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                foreach (string name in denyList.Values)
                 {
-                    blackListOfAssemblyNames[name] = null;
+                    denyListOfAssemblyNames[name] = null;
                 }
 
-                _cachedBlackList.TryAdd(key, blackListOfAssemblyNames);
+                _cachedDenyList.TryAdd(key, denyListOfAssemblyNames);
 
-                return blackListOfAssemblyNames;
+                return denyListOfAssemblyNames;
             }
 
             return returnTable;
@@ -659,8 +659,10 @@ internal static string ReadFile(AssemblyTableInfo assemblyTableInfo, List<Assemb
 
             try
             {
-                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                reader = XmlReader.Create(path, readerSettings);
+                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+                FileStream fs = File.OpenRead(path);
+
+                reader = XmlReader.Create(fs, readerSettings);
 
                 while (reader.Read())
                 {
@@ -929,7 +931,7 @@ public int Compare(AssemblyEntry firstEntry, AssemblyEntry secondEntry)
     }
 
     /// <summary>
-    /// Internal class representing a redist list or whitelist and its corresponding framework directory.
+    /// Internal class representing a redist list or allowlist and its corresponding framework directory.
     /// </summary>
     internal class AssemblyTableInfo : IComparable
     {
@@ -955,7 +957,7 @@ public int CompareTo(object obj)
     }
 
     /// <summary>
-    /// Provide a mechanism to determine where the subset white lists are located by searching the target framework folders
+    /// Provide a mechanism to determine where the subset allow lists are located by searching the target framework folders
     /// for a list of provided subset list names.
     /// </summary>
     internal class SubsetListFinder
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index 3ce50fcde06..0fb8e616bb3 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -76,7 +76,7 @@ public override bool Execute()
 
             if ((AssemblyListFile?.ItemSpec.Length > 0))
             {
-                cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache)) ??
+                cacheFile = StateFileBase.DeserializeCache<AssemblyRegistrationCache>(AssemblyListFile.ItemSpec, Log) ??
                             new AssemblyRegistrationCache();
             }
 
diff --git a/src/Tasks/RemoveDir.cs b/src/Tasks/RemoveDir.cs
index da78951a376..3e43ca69a80 100644
--- a/src/Tasks/RemoveDir.cs
+++ b/src/Tasks/RemoveDir.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Remove the specified directories.
     /// </summary>
-    public class RemoveDir : TaskExtension
+    public class RemoveDir : TaskExtension, IIncrementalTask
     {
         //-----------------------------------------------------------------------------------
         // Property:  directory to remove
@@ -41,6 +41,8 @@ public ITaskItem[] Directories
         [Output]
         public ITaskItem[] RemovedDirectories { get; set; }
 
+        public bool FailIfNotIncremental { get; set; }
+
         //-----------------------------------------------------------------------------------
         // Execute -- this runs the task
         //-----------------------------------------------------------------------------------
@@ -61,6 +63,12 @@ public override bool Execute()
 
                 if (FileSystems.Default.DirectoryExists(directory.ItemSpec))
                 {
+                    if (FailIfNotIncremental)
+                    {
+                        Log.LogErrorFromResources("RemoveDir.Removing", directory.ItemSpec);
+                        continue;
+                    }
+
                     // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
                     Log.LogMessageFromResources(MessageImportance.Normal, "RemoveDir.Removing", directory.ItemSpec);
 
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index ea0be01f3fa..706899188d7 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -23,11 +23,7 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// This class is a caching mechanism for the resgen task to keep track of linked
     /// files within processed .resx files.
-    /// 
-    /// This is an on-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-    [Serializable]
     internal sealed class ResGenDependencies : StateFileBase, ITranslatable
     {
         /// <summary>
@@ -125,13 +121,13 @@ public override void Translate(ITranslator translator)
             translator.Translate(ref baseLinkedFileDirectory);
         }
 
-        internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)
+        internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             // First, try to retrieve the resx information from our hashtable.
             if (!resXFiles.TryGetValue(resxFile, out ResXFile retVal))
             {
                 // Ok, the file wasn't there.  Add it to our cache and return it to the caller.  
-                retVal = AddResxFile(resxFile, useMSBuildResXReader);
+                retVal = AddResxFile(resxFile, useMSBuildResXReader, log, logWarningForBinaryFormatter);
             }
             else
             {
@@ -141,19 +137,19 @@ internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)
                 {
                     resXFiles.Remove(resxFile);
                     _isDirty = true;
-                    retVal = AddResxFile(resxFile, useMSBuildResXReader);
+                    retVal = AddResxFile(resxFile, useMSBuildResXReader, log, logWarningForBinaryFormatter);
                 }
             }
 
             return retVal;
         }
 
-        private ResXFile AddResxFile(string file, bool useMSBuildResXReader)
+        private ResXFile AddResxFile(string file, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             // This method adds a .resx file "file" to our .resx cache.  The method causes the file
             // to be cracked for contained files.
 
-            var resxFile = new ResXFile(file, BaseLinkedFileDirectory, useMSBuildResXReader);
+            var resxFile = new ResXFile(file, BaseLinkedFileDirectory, useMSBuildResXReader, log, logWarningForBinaryFormatter);
             resXFiles.Add(file, resxFile);
             _isDirty = true;
             return resxFile;
@@ -189,9 +185,9 @@ internal void UpdatePortableLibrary(PortableLibraryFile library)
         /// <summary>
         /// Writes the contents of this object out to the specified file.
         /// </summary>
-        internal override void SerializeCache(string stateFile, TaskLoggingHelper log)
+        internal override void SerializeCache(string stateFile, TaskLoggingHelper log, bool serializeEmptyState = false)
         {
-            base.SerializeCache(stateFile, log);
+            base.SerializeCache(stateFile, log, serializeEmptyState);
             _isDirty = false;
         }
 
@@ -200,7 +196,7 @@ internal override void SerializeCache(string stateFile, TaskLoggingHelper log)
         /// </summary>
         internal static ResGenDependencies DeserializeCache(string stateFile, bool useSourcePath, TaskLoggingHelper log)
         {
-            var retVal = (ResGenDependencies)DeserializeCache(stateFile, log, typeof(ResGenDependencies)) ?? new ResGenDependencies();
+            var retVal = DeserializeCache<ResGenDependencies>(stateFile, log) ?? new ResGenDependencies();
 
             // Ensure that the cache is properly initialized with respect to how resgen will 
             // resolve linked files within .resx files.  ResGen has two different
@@ -218,11 +214,7 @@ internal static ResGenDependencies DeserializeCache(string stateFile, bool useSo
 
         /// <remarks>
         /// Represents a single .resx file in the dependency cache.
-        /// 
-        /// This is an on-disk serialization format, don't change field names or types or use readonly.
         /// </remarks>
-        /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-        [Serializable]
         internal sealed class ResXFile : DependencyFile, ITranslatable
         {
             // Files contained within this resx file.
@@ -230,7 +222,7 @@ internal sealed class ResXFile : DependencyFile, ITranslatable
 
             internal string[] LinkedFiles => linkedFiles;
 
-            internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader) : base(filename)
+            internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter) : base(filename)
             {
                 // Creates a new ResXFile object and populates the class member variables
                 // by computing a list of linked files within the .resx that was passed in.
@@ -239,7 +231,7 @@ internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBui
 
                 if (FileSystems.Default.FileExists(FileName))
                 {
-                    linkedFiles = GetLinkedFiles(filename, baseLinkedFileDirectory, useMSBuildResXReader);
+                    linkedFiles = GetLinkedFiles(filename, baseLinkedFileDirectory, useMSBuildResXReader, log, logWarningForBinaryFormatter);
                 }
             }
 
@@ -260,7 +252,7 @@ public void Translate(ITranslator translator)
             /// </summary>
             /// <exception cref="ArgumentException">May be thrown if Resx is invalid. May contain XmlException.</exception>
             /// <exception cref="XmlException">May be thrown if Resx is invalid</exception>
-            private static string[] GetLinkedFiles(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader)
+            private static string[] GetLinkedFiles(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
             {
                 // This method finds all linked .resx files for the .resx file that is passed in.
                 // filename is the filename of the .resx file that is to be examined.
@@ -270,7 +262,7 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
 
                 if (useMSBuildResXReader)
                 {
-                    foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, pathsRelativeToBasePath: baseLinkedFileDirectory == null))
+                    foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, pathsRelativeToBasePath: baseLinkedFileDirectory == null, log, logWarningForBinaryFormatter))
                     {
                         if (resource is FileStreamResource linkedResource)
                         {
@@ -325,10 +317,11 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
         /// Represents a single assembly in the dependency cache, which may produce 
         /// 0 to many ResW files.
         /// 
-        /// This is an on-disk serialization format, don't change field names or types or use readonly.
+        /// Must be serializable because instances may be marshaled cross-AppDomain, see <see cref="ProcessResourceFiles.PortableLibraryCacheInfo"/>.
         /// </remarks>
-        /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
+#if FEATURE_APPDOMAIN
         [Serializable]
+#endif
         internal sealed class PortableLibraryFile : DependencyFile, ITranslatable
         {
             internal string[] outputFiles;
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 0c7348a73ac..0a3eb949eef 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -333,7 +333,7 @@ public override bool Execute()
             allProjectRefs = new List<ComReferenceInfo>();
             allDependencyRefs = new List<ComReferenceInfo>();
 
-            _timestampCache = (ResolveComReferenceCache)StateFileBase.DeserializeCache(StateFile, Log, typeof(ResolveComReferenceCache));
+            _timestampCache = StateFileBase.DeserializeCache<ResolveComReferenceCache>(StateFile, Log);
 
             if (_timestampCache?.ToolPathsMatchCachePaths(_tlbimpPath, _aximpPath) != true)
             {
diff --git a/src/Tasks/ResolveComReferenceCache.cs b/src/Tasks/ResolveComReferenceCache.cs
index b140ed58af7..2972c86df93 100644
--- a/src/Tasks/ResolveComReferenceCache.cs
+++ b/src/Tasks/ResolveComReferenceCache.cs
@@ -16,11 +16,7 @@ namespace Microsoft.Build.Tasks
     /// an earlier revision of a COM component, its timestamp can go back in time and we still need to regenerate its
     /// wrapper. So in ResolveComReference we compare the stored timestamp with the current component timestamp, and if 
     /// they are different, we regenerate the wrapper.
-    /// 
-    /// This is an on-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-    [Serializable]
     internal sealed class ResolveComReferenceCache : StateFileBase, ITranslatable
     {
         /// <summary>
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 9b98bcf97a8..9a78f010f16 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -285,14 +285,17 @@ private ITaskItem CreateFileItem(ITaskItem item, string group, string targetPath
             {
                 targetPath = Path.GetFileName(item.ItemSpec);
                 //
-                // .NETCore Launcher.exe based deployment: If the file is apphost.exe, we need to set 'TargetPath' metadata
-                // to {assemblyname}.exe so that the file gets published as {assemblyname}.exe and not apphost.exe.
+                // .NET >= 5 ClickOnce: If TargetPath metadata is not present in apphost.exe's metadata, we'll fallback to using AssemblyName
                 //
                 if (LauncherBasedDeployment &&
                     targetPath.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) &&
                     !String.IsNullOrEmpty(AssemblyName))
                 {
-                    targetPath = AssemblyName;
+                    targetPath = item.GetMetadata(ItemMetadataNames.targetPath);
+                    if (String.IsNullOrEmpty(targetPath))
+                    {
+                        targetPath = AssemblyName;
+                    }
                 }
                 else
                 {
diff --git a/src/Tasks/ResourceHandling/InputFormatNotSupportedException.cs b/src/Tasks/ResourceHandling/InputFormatNotSupportedException.cs
index a6b797a7d94..f82fb7c7758 100644
--- a/src/Tasks/ResourceHandling/InputFormatNotSupportedException.cs
+++ b/src/Tasks/ResourceHandling/InputFormatNotSupportedException.cs
@@ -23,6 +23,9 @@ public InputFormatNotSupportedException(string message, Exception innerException
         {
         }
 
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected InputFormatNotSupportedException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
         }
diff --git a/src/Tasks/ResourceHandling/MSBuildResXException.cs b/src/Tasks/ResourceHandling/MSBuildResXException.cs
index ce6d5b589c2..6ef3b33e88e 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXException.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXException.cs
@@ -23,6 +23,9 @@ public MSBuildResXException(string message, Exception innerException) : base(mes
         {
         }
 
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected MSBuildResXException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
         }
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 765a023a102..05c2e50efe6 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -9,6 +9,7 @@
 using System.Xml;
 using System.Xml.Linq;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -16,7 +17,7 @@ namespace Microsoft.Build.Tasks.ResourceHandling
 {
     internal class MSBuildResXReader
     {
-        public static IReadOnlyList<IResource> ReadResources(Stream s, string filename, bool pathsRelativeToBasePath)
+        public static IReadOnlyList<IResource> ReadResources(Stream s, string filename, bool pathsRelativeToBasePath, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             var resources = new List<IResource>();
             var aliases = new Dictionary<string, string>();
@@ -38,7 +39,7 @@ public static IReadOnlyList<IResource> ReadResources(Stream s, string filename,
                             case "resheader":
                                 break;
                             case "data":
-                                ParseData(filename, pathsRelativeToBasePath, resources, aliases, elem);
+                                ParseData(filename, pathsRelativeToBasePath, resources, aliases, elem, log, logWarningForBinaryFormatter);
                                 break;
                         }
                     }
@@ -101,7 +102,14 @@ private static string GetFullTypeNameFromAlias(string aliasedTypeName, Dictionar
             return aliasedTypeName;
         }
 
-        private static void ParseData(string resxFilename, bool pathsRelativeToBasePath, List<IResource> resources, Dictionary<string, string> aliases, XElement elem)
+        private static void ParseData(
+            string resxFilename,
+            bool pathsRelativeToBasePath,
+            List<IResource> resources,
+            Dictionary<string, string> aliases,
+            XElement elem,
+            TaskLoggingHelper log,
+            bool logWarningForBinaryFormatter)
         {
             string name = elem.Attribute("name").Value;
             string value;
@@ -186,13 +194,27 @@ private static void ParseData(string resxFilename, bool pathsRelativeToBasePath,
                     case BinSerializedObjectMimeType:
                     case Beta2CompatSerializedObjectMimeType:
                     case CompatBinSerializedObjectMimeType:
+                        // Warn of BinaryFormatter exposure (SDK should turn this on by default in .NET 8+)
+                        if (logWarningForBinaryFormatter)
+                        {
+                            log?.LogWarningWithCodeFromResources(null, resxFilename, ((IXmlLineInfo)elem).LineNumber, ((IXmlLineInfo)elem).LinePosition, 0, 0, "GenerateResource.BinaryFormatterUse", name, typename);
+                        }
+
                         // BinaryFormatter from byte array
                         byte[] binaryFormatterBytes = Convert.FromBase64String(value);
 
                         resources.Add(new BinaryFormatterByteArrayResource(name, binaryFormatterBytes, resxFilename));
                         return;
                     default:
-                        throw new NotSupportedException($"Resource \"{name}\" in \"{resxFilename}\"uses MIME type \"{mimetype}\", which is not supported by .NET Core MSBuild.");
+                        if (log is null)
+                        {
+                            throw new NotSupportedException(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("GenerateResource.MimeTypeNotSupportedOnCore", name, resxFilename, mimetype));
+                        }
+                        else
+                        {
+                            log.LogErrorFromResources("GenerateResource.MimeTypeNotSupportedOnCore", name, resxFilename, mimetype);
+                            return;
+                        }
                 }
             }
         }
@@ -284,19 +306,19 @@ internal static bool IsMemoryStream(string fileRefType)
         /// <summary>
         /// Extract <see cref="IResource"/>s from a given file on disk.
         /// </summary>
-        public static IReadOnlyList<IResource> GetResourcesFromFile(string filename, bool pathsRelativeToBasePath)
+        public static IReadOnlyList<IResource> GetResourcesFromFile(string filename, bool pathsRelativeToBasePath, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             using (var x = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
-                return ReadResources(x, filename, pathsRelativeToBasePath);
+                return ReadResources(x, filename, pathsRelativeToBasePath, log, logWarningForBinaryFormatter);
             }
         }
 
-        public static IReadOnlyList<IResource> GetResourcesFromString(string resxContent, string basePath = null, bool? useRelativePath = null)
+        public static IReadOnlyList<IResource> GetResourcesFromString(string resxContent, TaskLoggingHelper log, bool logWarningForBinaryFormatter, string basePath = null, bool? useRelativePath = null)
         {
             using (var x = new MemoryStream(Encoding.UTF8.GetBytes(resxContent)))
             {
-                return ReadResources(x, basePath, useRelativePath.GetValueOrDefault(basePath != null));
+                return ReadResources(x, basePath, useRelativePath.GetValueOrDefault(basePath != null), log, logWarningForBinaryFormatter);
             }
         }
 
diff --git a/src/Tasks/ResourceHandling/PreserializedResourceWriterRequiredException.cs b/src/Tasks/ResourceHandling/PreserializedResourceWriterRequiredException.cs
index d72a71f17b0..5cfea71ab5c 100644
--- a/src/Tasks/ResourceHandling/PreserializedResourceWriterRequiredException.cs
+++ b/src/Tasks/ResourceHandling/PreserializedResourceWriterRequiredException.cs
@@ -13,6 +13,9 @@ internal sealed class PreserializedResourceWriterRequiredException : Exception
     {
         public PreserializedResourceWriterRequiredException() { }
 
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private PreserializedResourceWriterRequiredException(SerializationInfo info, StreamingContext context)
             : base(info, context) { }
     }
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 1ba6e45bb05..eb1e5e3b341 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -625,6 +625,9 @@
   <data name="GenerateBindingRedirects.ProcessingSuggestedRedirect">
     <value>Processing suggested binding redirect on "{0}" with MaxVersion "{1}".</value>
   </data>
+  <data name="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+    <value>Creating binding redirection file "{0}".</value>
+  </data>
   <!--
         The GenerateBootstrapper message bucket is: MSB3141 - MSB3170
 
@@ -1161,7 +1164,16 @@
     <value>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</value>
     <comment>{StrBegin="MSB3824: "}</comment>
   </data>
+  <data name="GenerateResource.BinaryFormatterUse">
+    <value>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</value>
+    <comment>{StrBegin="MSB3825: "}</comment>
+  </data>
 
+  <data name="GenerateResource.MimeTypeNotSupportedOnCore">
+    <value>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</value>
+    <comment>{StrBegin="MSB3826: "}</comment>
+  </data>
 
   <!--
         The GetAssemblyIdentity message bucket is: MSB3441 - MSB3450
@@ -1736,7 +1748,7 @@
   <data name="ResolveAssemblyReference.TargetFrameworkSubsetLogHeader">
     <value>TargetFramework Profile List Information:</value>
   </data>
-  <data name="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+  <data name="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
     <value>TargetFramework Profile List Paths:</value>
   </data>
   <data name="ResolveAssemblyReference.TargetFrameworkRedistLogHeader">
@@ -1760,6 +1772,10 @@
     <value>Assembly file '{0}' could not be opened -- PE image doesn't contain managed metadata.</value>
     <comment></comment>
   </data>
+  <data name="ResolveAssemblyReference.WritingCacheFile">
+    <value>Updating assembly cache file "{0}".</value>
+    <comment></comment>
+  </data>
   <!--
         The ResolveComReference message bucket is: MSB3281 - MSB3320
 
@@ -2317,6 +2333,9 @@
   </data>
   <data name="XslTransform.UseTrustedSettings" xml:space="preserve">
     <value>The usage of the document() method and embedded scripts is prohibited by default, due to risks of foreign code execution.  If "{0}" is a trusted source that requires those constructs, please set the "UseTrustedSettings" parameter to "true" to allow their execution.</value>
+  </data>
+  <data name="XslTransform.SecuritySettingsViaUseTrustedSettings" xml:space="preserve">
+    <value>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</value>
   </data>
     <data name="XslTransform.PrecompiledXsltError" xml:space="preserve">
     <value>MSB3705: XslCompiledDllPath is not supported when building with .NET Core.</value>
@@ -2762,6 +2781,14 @@
     <value>MSB3893: Could not use a link to copy "{0}" to "{1}".</value>
     <comment>{StrBegin="MSB3893: "} LOCALIZATION: {0} and {1} are paths.</comment>
   </data>
+  <data name="Copy.IOException">
+    <value>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</value>
+    <comment>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</comment>
+  </data>
+  <data name="Copy.RetryingOnAccessDenied">
+    <value>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</value>
+    <comment>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</comment>
+  </data>
 
   <!--
         MSB3901 - MSB3910   Task: Telemetry
@@ -2966,6 +2993,18 @@
   <data name="ResolveKeySource.PfxUnsupported" xml:space="preserve">
     <value>PFX signing not supported on .NET Core.</value>
   </data>
+
+  <!--
+        MSB3991 - MSB3999   Task: CombineTargetFrameworkInfoProperties
+  -->
+  <data name="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+    <value>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</value>
+    <comment>{StrBegin="MSB3991: "}</comment>
+  </data>
+  <data name="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+    <value>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</value>
+    <comment>{StrBegin="MSB3992: "}</comment>
+  </data>
   <!--
         The tasks message bucket is: MSB3001 - MSB3999
 
@@ -3052,6 +3091,7 @@
             MSB3961 - MSB3970   Task: GenerateLauncher
             MSB3971 - MSB3980   Task: GetReferenceAssemblyPaths overflow
             MSB3981 - MSB3990   Task: GetCompatiblePlatform
+            MSB3991 - MSB3999   Task: CombineTargetFrameworkInfoProperties
 
             MSB4000 - MSB4200   Portable targets & tasks (vsproject\flavors\portable\msbuild)
             MSB9000 - MSB9900   MSBuild targets files (C++)
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 31d96300d30..55f6bb9b3ee 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: Pozdr≈æen√© podepisov√°n√≠ po≈æaduje, aby byl urƒçen alespo≈à ve≈ôejn√Ω kl√≠ƒç.  Zadejte ve≈ôejn√Ω kl√≠ƒç pomoc√≠ vlastnosti KeyFile nebo KeyContainer, nebo zaka≈æte pozdr≈æen√© podepisov√°n√≠.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: Hodnota {0} nen√≠ nastavena nebo je pr√°zdn√°. Pokud {1} m√° hodnotu false, nezapome≈àte pro hodnotu {0} nastavit nepr√°zdnou hodnotu.</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: Hodnota {0} nen√≠ nastaven. Pokud {1} m√° hodnotu true, nezapome≈àte nastavit hodnotu pro {0}.</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Z√°va≈æn√° chyba: v√≠c ne≈æ {0} argument≈Ø p≈ô√≠kazov√©ho ≈ô√°dku</target>
@@ -181,6 +191,11 @@
         <target state="translated">Vytv√°≈ô√≠ se pevn√Ω odkaz pro kop√≠rov√°n√≠ {0} do {1}.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: P≈ôi kop√≠rov√°n√≠ ‚Äû{1}‚Äú do ‚Äû{2}‚Äú do≈°lo k v√Ωjimce {0} a HR je {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Ned√° se pou≈æ√≠t odkaz pro kop√≠rov√°n√≠ {0} do {1}.</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Vol√°n√≠ knihovny {0} se nezda≈ôilo s n√°sleduj√≠c√≠m k√≥dem chyby: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Nepovedlo se pou≈æ√≠t pevn√Ω odkaz ke zkop√≠rov√°n√≠ ‚Äû{0}‚Äú do ‚Äû{1}‚Äú. M√≠sto toho se soubor kop√≠ruje pomoc√≠ symbolick√©ho odkazu. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Opakov√°n√≠ na ERROR_ACCESS_DENIED, proto≈æe promƒõnn√° prost≈ôed√≠ MSBUILDALWAYSRETRY = 1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Zdrojov√Ω soubor {0} je ve skuteƒçnosti adres√°≈ô.  √öloha kop√≠rov√°n√≠ nepodporuje kop√≠rov√°n√≠ adres√°≈ô≈Ø.</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} je neplatn√Ω poƒçet opakov√°n√≠. Hodnota nesm√≠ b√Ωt z√°porn√°.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} je neplatn√© zpo≈ædƒõn√≠ opakov√°n√≠. Hodnota nesm√≠ b√Ωt z√°porn√°.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: Nelze odstranit soubor ‚Äû{0}‚Äú. Zaƒç√°tek {1} opakov√°n√≠ za {2}ms {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: Polo≈æka {2} odkazuje na {0} polo≈æek a polo≈æka {3} odkazuje na {1} polo≈æek. Mus√≠ m√≠t stejn√Ω poƒçet polo≈æek.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Vytv√°≈ôen√≠ souboru p≈ôesmƒõrov√°n√≠ vazby ‚Äû{0}‚Äú.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Konfiguraƒçn√≠ soubor aplikace mus√≠ m√≠t ko≈ôenov√Ω element konfigurace.</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: Funkce ClickOnce nepodporuje po≈æadovanou √∫rove≈à proveden√≠ {0}.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: Prost≈ôedek ‚Äû{0}‚Äú typu ‚Äû{1}‚Äú je deserializov√°n prost≈ôednictv√≠m BinaryFormatter za bƒõhu. BinaryFormatter je zastaral√Ω kv≈Øli mo≈æn√Ωm bezpeƒçnostn√≠m rizik≈Øm a odebere se s .NET 9. Pokud ho chcete pou≈æ√≠vat d√°l, nastavte vlastnost GenerateResourceWarnOnBinaryFormatterUse na false. 
+           Dal≈°√≠ informace: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Aby bylo mo≈æn√© prov√©st sestaven√≠ pomoc√≠ .NET Core, mus√≠ b√Ωt vstupy prost≈ôedk≈Ø ve form√°tu .txt nebo .resx.</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: Ne≈°lo zpracovat soubor {0}, proto≈æe je v z√≥nƒõ Internet nebo Omezen√© nebo m√° na souboru znaƒçku webu. Pokud chcete tyto soubory zpracovat, odeberte znaƒçku webu.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: Prost≈ôedek \"{0}\" v \"{1}\" pou≈æ√≠v√° typ MIME \"{2}\", kter√Ω MSBuild p≈ôi spu≈°tƒõn√≠ v .NET nepodporuje.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">V√Ωstupn√≠ soubor {0} neexistuje.</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution je true, ale odkazovan√Ω projekt {0} nem√° nastaven√° metadata Platforms ani Platform. Sestav√≠ se bez zadan√© platformy.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">Vlastnost platformy odkazovan√©ho projektu {0} odpov√≠d√° platformƒõ aktu√°ln√≠ho projektu: {1}. Odkazovan√Ω projekt se sestav√≠ bez glob√°ln√≠ vlastnosti platformy.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Do adres√°≈ôe RemoveDir byl p≈ôed√°n pr√°zdn√Ω adres√°≈ô a byl ignorov√°n.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Tento odkaz nen√≠ CopyLocal, proto≈æe se jedn√° o chybn√Ω obr√°zek. M≈Ø≈æe se jednat o nativn√≠ bin√°rn√≠ soubor, nebo se nemus√≠ v≈Øbec jednat o sestaven√≠.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">Informace o seznamu profilu TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Cesty seznamu profilu TargetFramework:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">N√°zev redistribuƒçn√≠ho bal√≠ƒçku v elementu FileList v souboru seznamu redistribuƒçn√≠ho bal√≠ƒçku {0} je null nebo pr√°zdn√Ω. N√°zev redistribuƒçn√≠ho bal√≠ƒçku nesm√≠ b√Ωt null ani pr√°zdn√Ω.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Aktualizuje se soubor mezipamƒõti sestaven√≠ ‚Äû{0}‚Äú.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Odkaz modelu COM {0} je definiƒçn√≠ sestaven√≠ ovl√°dac√≠ho prvku ActiveX {1}, ale kompil√°tor ho oznaƒçil p≈ô√≠znakem /link. S t√≠mto odkazem modelu COM se bude zach√°zet jako s odkazem a nebude propojen.</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">Podepisov√°n√≠ PFX se v .NET Core nepodporuje.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Polo≈æka je mimo c√≠lov√Ω adres√°≈ô: ‚Äû{0}‚Äú</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">Atribut ‚ÄûWriteOnlyWhenDifferent‚Äú pro ‚Äû{0}‚Äú se projev√≠ jenom v p≈ô√≠padƒõ, ≈æe overwrite="true"</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath se p≈ôi sestavov√°n√≠ pomoc√≠ .NET Core nepodporuje.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Povolujete uvolnƒõn√° nastaven√≠ zabezpeƒçen√≠ XSLT prost≈ôednictv√≠m parametru UseTrustedSettings. Dal≈°√≠ podrobnosti o d≈Øsledc√≠ch zabezpeƒçen√≠ tohoto nastaven√≠ najdete v https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Nelze zpracovat argument XsltParameters pro √∫lohu XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index fa31ca5d10f..5584c9219b9 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: F√ºr verz√∂gertes Signieren muss mindestens ein √∂ffentlicher Schl√ºssel angegeben werden.  Geben Sie entweder einen √∂ffentlichen Schl√ºssel mithilfe der KeyFile- oder KeyContainer-Eigenschaft an, oder deaktivieren Sie verz√∂gertes Signieren.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: ‚Äû{0}‚Äú ist nicht festgelegt oder leer. Wenn {1} falsch ist, legen Sie f√ºr ‚Äû{0}‚Äú auf keinen Fall einen leeren Wert fest.</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: ‚Äû{0}‚Äú ist nicht festgelegt. Wenn {1} wahr ist, legen Sie auf jeden Fall einen Wert f√ºr ‚Äû{0}‚Äú fest.</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Schwerwiegender Fehler: mehr als {0} Befehlszeilenargumente.</target>
@@ -181,6 +191,11 @@
         <target state="translated">Es wird ein fester Link erstellt, um "{0}" in "{1}" zu kopieren.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Erhalt von {0} Kopieren von "{1}" zu "{2}" und HR ist {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Es konnte kein Link verwendet werden, um "{0}" in "{1}" zu kopieren.</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Fehler beim Aufruf der {0}-Bibliothek. Fehlercode: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Es konnte kein fester Link verwendet werden, um "{0}" in "{1}" zu kopieren. Stattdessen wird die Datei mit einer symbolischen Verkn√ºpfung kopiert. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Wiederholung bei ERROR_ACCESS_DENIED, da Umgebungsvariable MSBUILDALWAYSRETRY=1 festgelegt ist</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Die Quelldatei "{0}" ist keine Datei, sondern ein Verzeichnis.  Mit der Copy-Aufgabe k√∂nnen keine Verzeichnisse kopiert werden.</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} ist eine ung√ºltige Anzahl von Wiederholungen. Der Wert darf nicht negativ sein.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} ist eine ung√ºltige Wiederholungsverz√∂gerung. Der Wert darf nicht negativ sein.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: Die Datei "{0}" konnte nicht gel√∂scht werden. Wiederholungsversuch {1} wird in {2}ms gestartet. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: "{2}" verweist auf {0} Element(e), und "{3}" verweist auf {1} Element(e). Die Anzahl von Elementen muss identisch sein.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Bindungsumleitungsdatei "{0}" wird erstellt.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Die Anwendungskonfigurationsdatei muss √ºber ein Stammkonfigurationselement verf√ºgen.</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: Die Anforderungsausf√ºhrungsebene "{0}" wird von ClickOnce nicht unterst√ºtzt.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: Die Ressource "{0}" vom Typ "{1}" wird zur Laufzeit √ºber BinaryFormatter deserialisiert. BinaryFormatter ist aufgrund m√∂glicher Sicherheitsrisiken veraltet und wird mit .NET 9 entfernt. Wenn Sie sie weiterhin verwenden m√∂chten, legen Sie die Eigenschaft "GenerateResourceWarnOnBinaryFormatterUse" auf "false" fest.
+           Weitere Informationen: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: F√ºr die Kompilierung mit .NET Core m√ºssen Ressourceneingaben im TXT- oder RESX-Format vorliegen.</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: Die Datei "{0}" konnte nicht verarbeitet werden, weil sie sich im Internet oder in der Zone eingeschr√§nkter Websites befindet oder die Webmarkierung aufweist. Entfernen Sie die Webmarkierung, wenn Sie diese Dateien verarbeiten m√∂chten.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: Die Ressource \"{0}\" in \"{1}\" verwendet den MIME-Typ \"{2}\", der von MSBuild bei der Ausf√ºhrung unter .NET nicht unterst√ºtzt wird.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Die Ausgabedatei "{0}" ist nicht vorhanden.</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution ist \"true\", aber auf das Projekt \"{0}\" wird verwiesen, f√ºr das keine \"Plattformen\"- oder \"Plattform\"-Metadaten festgelegt sind. Er wird ohne eine angegebene Plattform erstellt.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">Die Plattformeigenschaft des Referenzprojekts \"{0}\" entspricht der Plattform des aktuellen Projekts: \"{1}\". Das Projekt, auf das verwiesen wird, wird ohne globale Plattformeigenschaft erstellt.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Ein leeres Verzeichnis wurde an RemoveDir √ºbergeben und ignoriert.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Dieser Verweis ist nicht "CopyLocal", da es sich um ein ung√ºltiges Bild handelt. M√∂glicherweise handelt es sich um eine native Bin√§rdatei, oder es handelt sich √ºberhaupt nicht um eine Assembly.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">Informationen zur TargetFramework-Profilliste:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Pfade der TargetFramework-Profilliste:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">Der Redist-Name im FileList-Element der Redistributable-Listendatei "{0}" ist NULL oder leer. Vergewissern Sie sich, dass der Redist-Name nicht NULL oder leer ist.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Aktualisiert Assemblycachedatei "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Der COM-Verweis "{0}" ist die Interopassembly f√ºr das ActiveX-Steuerelement "{1}". Entsprechend der Markierung ist der Verweis jedoch durch den Compiler mit dem /link-Flag verkn√ºpft. Der COM-Verweis wird als Verweis behandelt und nicht verkn√ºpft.</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">PFX-Signierung wird f√ºr .NET Core nicht unterst√ºtzt.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Der Eintrag befindet sich au√üerhalb des Zielverzeichnisses: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">Das Attribut "WriteOnlyWhenDifferent" f√ºr "{0}" wird nur bei "Overwrite="true"" wirksam.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath wird bei der Kompilierung mit .NET Core nicht unterst√ºtzt.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Sie aktivieren lockere XSLT-Sicherheitseinstellungen √ºber den Parameter "UseTrustedSettings". Weitere Informationen zu den Auswirkungen dieser Einstellung auf die Sicherheit finden Sie unter https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Das XsltParameters-Argument f√ºr die XslTransformation-Aufgabe kann nicht verarbeitet werden. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index bad4f2ee060..0a9aaa61894 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -118,9 +118,19 @@
       </trans-unit>
       <trans-unit id="AxTlbBaseTask.StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3654: Delay signing requires that at least a public key be specified.  Please either supply a public key using the KeyFile or KeyContainer properties, or disable delay signing.</source>
-        <target state="translated">MSB3654: La firma retardada requiere que se especifique al menos una clave p√∫blica.  Proporcione una clave p√∫blica mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retardada.</target>
+        <target state="translated">MSB3654: La firma retrasada requiere que se especifique al menos una clave p√∫blica.  Proporcione una clave p√∫blica mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retrasada.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: "{0}" no se ha establecido o est√° vac√≠o. Cuando {1} sea false, aseg√∫rese de establecer un valor que no est√© vac√≠o para "{0}".</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: "{0}" no se ha establecido. Cuando {1} sea true, aseg√∫rese de establecer un valor para "{0}".</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Error irrecuperable: m√°s de {0} argumentos de l√≠nea de comandos.</target>
@@ -181,6 +191,11 @@
         <target state="translated">Creando un v√≠nculo f√≠sico para copiar "{0}" en "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Se obtuvo {0} al copiar "{1}" en "{2}" y HR es {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: No se puede usar un v√≠nculo para copiar "{0}" en "{1}".</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Error en la llamada a la biblioteca {0} con el siguiente c√≥digo de error: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">No se puede usar un v√≠nculo f√≠sico para copiar "{0}" en "{1}". Se va a copiar el archivo en un v√≠nculo simb√≥lico su lugar. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Reintentando el ERROR_ACCESS_DENIED porque la variable de entorno MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: El archivo de origen "{0}" es un directorio.  La tarea "Copy" no permite copiar directorios.</target>
@@ -308,22 +328,22 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} no es un n√∫mero de reintentos v√°lido. El valor no puede ser negativo.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} no es un n√∫mero de reintentos v√°lido. El valor no puede ser negativo.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: No se pudo eliminar el archivo "{0}". Iniciando reintento {1} en {2}ms. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
-        <target state="translated">El archivo"{0}" no existe. Se omitir√°.</target>
+        <target state="translated">El archivo "{0}" no existe. Se omitir√°.</target>
         <note />
       </trans-unit>
       <trans-unit id="DownloadFile.DidNotDownloadBecauseOfFileMatch">
@@ -541,7 +561,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="translated">MSB3096: La tarea ‚Äú{0}‚Äù solo se admite cuando se compila en Windows.</target>
+        <target state="translated">MSB3096: La tarea "{0}" solo se admite cuando se compila en Windows.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: "{2}" hace referencia a {0} elementos y "{3}" hace referencia a {1} elementos. Deben tener el mismo n√∫mero de elementos.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Creando el archivo de redirecci√≥n de enlace "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: El archivo de configuraci√≥n de la aplicaci√≥n debe tener un elemento de configuraci√≥n ra√≠z.</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: ClickOnce no admite el nivel de ejecuci√≥n de solicitudes '{0}'.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: El recurso "{0}" de tipo "{1}" se deserializa a trav√©s de BinaryFormatter en tiempo de ejecuci√≥n. BinaryFormatter est√° en desuso debido a posibles riesgos de seguridad y se quitar√° con .NET 9. Si desea seguir us√°ndola, establezca la propiedad "GenerateResourceWarnOnBinaryFormatterUse" en falso.
+           M√°s informaci√≥n: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Para compilar con .NET Core, las entradas de recursos deben estar en formato .txt o .resx.</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: No se puede procesar el archivo {0} porque est√° en Internet o en una zona restringida, o bien tiene la marca de la Web. Quite esta marca si desea procesar los archivos.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: El recurso \"{0}\" de \"{1}\" usa el tipo MIME \"{2}\", que MSBuild no admite cuando se ejecuta en .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">El archivo de salida "{0}" no existe.</target>
@@ -1273,12 +1310,12 @@
       </trans-unit>
       <trans-unit id="GenerateResource.CannotWriteAssembly">
         <source>MSB3575: GenerateResource cannot write assemblies, only read from them. Cannot create assembly "{0}".</source>
-        <target state="translated">MSB3575: GenerateResource no puede escribir ensamblados, solo leerlos. No se puede crear el ensamblado"{0}".</target>
+        <target state="translated">MSB3575: GenerateResource no puede escribir ensamblados, solo leerlos. No se puede crear el ensamblado "{0}".</target>
         <note>{StrBegin="MSB3575: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CreatingCultureInfoFailed">
         <source>MSB3576: Creating the CultureInfo failed for assembly "{2}". Note the set of cultures supported is Operating System-dependent, and the Operating System has removed some cultures from time to time (ie, some Serbian cultures are split up in Windows 7).  The culture may be a user-defined custom culture that we can't currently load on this machine.  Exception info: {0}: {1}</source>
-        <target state="translated">MSB3576: Error al crear CultureInfo para el ensamblado"{2}". Tenga en cuenta que el conjunto de referencias culturales admitido depende del sistema operativo y este ha quitado algunas referencias culturales de vez en cuando (por ejemplo, en Windows 7, algunas referencias culturales de serbio est√°n divididas).  La referencia cultural puede ser una referencia cultural personalizada definida por el usuario que no se pueda cargar actualmente en este equipo.  Informaci√≥n de la excepci√≥n: {0}: {1}</target>
+        <target state="translated">MSB3576: Error al crear CultureInfo para el ensamblado "{2}". Tenga en cuenta que el conjunto de referencias culturales admitido depende del sistema operativo y este ha quitado algunas referencias culturales de vez en cuando (por ejemplo, en Windows 7, algunas referencias culturales de serbio est√°n divididas).  La referencia cultural puede ser una referencia cultural personalizada definida por el usuario que no se pueda cargar actualmente en este equipo.  Informaci√≥n de la excepci√≥n: {0}: {1}</target>
         <note>{StrBegin="MSB3576: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.DuplicateOutputFilenames">
@@ -1328,7 +1365,7 @@
       </trans-unit>
       <trans-unit id="GenerateResource.CannotLoadAssemblyLoadFromFailed">
         <source>MSB3816: Loading assembly "{0}" failed. {1}</source>
-        <target state="translated">MSB3816: Error al cargar el ensamblado"{0}". {1}</target>
+        <target state="translated">MSB3816: Error al cargar el ensamblado "{0}". {1}</target>
         <note>{StrBegin="MSB3816: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.MainAssemblyMissingNeutralResourcesLanguage">
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution es true, pero el proyecto al que se hace referencia, ‚Äú{0}‚Äù, no tiene establecido ning√∫n conjunto de metadatos ‚ÄúPlatforms‚Äù o ‚ÄúPlatform‚Äù. Se compilar√° sin una plataforma especificada.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">La propiedad ‚ÄúPlatform‚Äù del proyecto al que se hace referencia ‚Äú{0}‚Äù coincide con la plataforma del proyecto actual: ‚Äú{1}‚Äù. El proyecto al que se hace referencia se compilar√° sin una propiedad de plataforma global.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Se pas√≥ un directorio vac√≠o a RemoveDir y se omiti√≥.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Esta referencia no es "CopyLocal" porque es una imagen incorrecta. Puede ser un binario nativo o no ser un ensamblado.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">Informaci√≥n de listas de perfiles de TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Rutas de acceso de listas de perfiles de TargetFramework:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">El archivo de lista de paquetes redistribuibles "{0}" tiene un nombre Redist NULL o vac√≠o en el elemento FileList. Aseg√∫rese de que el nombre Redist no sea NULL ni est√© vac√≠o.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Actualizando el archivo de cach√© de ensamblado "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">La referencia COM '{0}' es el ensamblado de interoperabilidad del control ActiveX '{1}' pero estaba marcada para su vinculaci√≥n por el compilador con la marca /link. Esta referencia COM se tratar√° como una referencia y no se vincular√°.</target>
@@ -2255,7 +2297,7 @@
       </trans-unit>
       <trans-unit id="ResolveComReference.LoadingDelaySignedAssemblyWithStrongNameVerificationEnabled">
         <source>MSB3295: Failed to load an assembly. Please make sure you have disabled strong name verification for your public key if you want to generate delay signed wrappers. {0}</source>
-        <target state="translated">MSB3295: No se pudo cargar un ensamblado. Aseg√∫rese de que deshabilit√≥ la comprobaci√≥n de nombres seguros para su clave p√∫blica si desea generar contenedores de firma retardada. {0}</target>
+        <target state="translated">MSB3295: No se pudo cargar un ensamblado. Aseg√∫rese de que deshabilit√≥ la comprobaci√≥n de nombres seguros para su clave p√∫blica si desea generar contenedores de firma con retraso. {0}</target>
         <note>{StrBegin="MSB3295: "}</note>
       </trans-unit>
       <trans-unit id="ResolveComReference.MissingOrUnknownComReferenceAttribute">
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">No se admite la firma PFX en .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2464,7 +2506,7 @@
       </trans-unit>
       <trans-unit id="StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3353: Public key necessary for delay signing was not specified.</source>
-        <target state="translated">MSB3353: No se especific√≥ la clave p√∫blica necesaria para la firma retardada.</target>
+        <target state="translated">MSB3353: No se especific√≥ la clave p√∫blica necesaria para la firma con retraso.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
@@ -2559,12 +2601,12 @@
       </trans-unit>
       <trans-unit id="UnregisterAssembly.UnregisterTlbCantLoadFile">
         <source>MSB3397: Cannot unregister type library "{0}" - cannot load file, check to make sure it's a valid type library.</source>
-        <target state="translated">MSB3397: No se puede anular el registro de la biblioteca de tipos ""{0}"". No se puede cargar el archivo. Aseg√∫rese de que es una biblioteca de tipos v√°lida.</target>
+        <target state="translated">MSB3397: No se puede anular el registro de la biblioteca de tipos "{0}". No se puede cargar el archivo. Aseg√∫rese de que es una biblioteca de tipos v√°lida.</target>
         <note>{StrBegin="MSB3397: "}</note>
       </trans-unit>
       <trans-unit id="UnregisterAssembly.UnregisterTlbFileDoesNotExist">
         <source>Cannot unregister type library "{0}" - file doesn't exist.</source>
-        <target state="translated">No puede anularse el registro de la biblioteca de tipos ""{0}"". El archivo no existe.</target>
+        <target state="translated">No puede anularse el registro de la biblioteca de tipos "{0}". El archivo no existe.</target>
         <note />
       </trans-unit>
       <trans-unit id="UnregisterAssembly.UnregisterTlbFileNotRegistered">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">La entrada est√° fuera del directorio de destino: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">El atributo 'WriteOnlyWhenDifferent' de "{0}" solo surte efecto cuando 'Overwrite="true"'.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: No se admite XslCompiledDllPath cuando se compila con .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Est√° habilitando la configuraci√≥n de seguridad XSLT relajada mediante el par√°metro UseTrustedSettings. Para obtener m√°s informaci√≥n sobre las implicaciones de seguridad de esta configuraci√≥n, consulte https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: No se puede procesar el argumento XsltParameters para la tarea XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 6b83bd4f27c..d71ecab2118 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: La signature diff√©r√©e n√©cessite qu'au moins une cl√© publique soit sp√©cifi√©e.  Indiquez une cl√© publique √† l'aide des propri√©t√©s KeyFile ou KeyContainer, ou d√©sactivez la signature diff√©r√©e.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: ¬´¬†{0}¬†¬ª n‚Äôest pas d√©fini ou vide. Quand la valeur de {1} est false, veillez √† d√©finir une valeur non vide pour ¬´ {0}¬†¬ª.</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: ¬´ {{0}0} ¬ª n‚Äôest pas d√©fini. Lorsque {1} la valeur est true, veillez √† d√©finir une valeur pour ¬´{0}¬†¬ª.</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Erreur fatale¬†: plus de {0} arguments de ligne de commande.</target>
@@ -181,6 +191,11 @@
         <target state="translated">Cr√©ation d'un lien physique pour copier "{0}" vers "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Nous avons copi√© {0} ¬´{1}¬ª vers ¬´{2}¬ª et les ressources humaines sont {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: impossible d'utiliser un lien pour copier "{0}" vers "{1}".</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">L‚Äôappel de biblioth√®que {0} a √©chou√© avec le code d‚Äôerreur suivant¬†: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Impossible d‚Äôutiliser un lien physique pour copier ¬´{0}¬ª vers ¬´{1}¬ª. Copie du fichier avec un lien symbolique √† la place. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Nouvelle tentative sur ERROR_ACCESS_DENIED, car la variable d'environnement MSBUILDALWAYSRETRY = 1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Le fichier source "{0}" est en fait un r√©pertoire.  La t√¢che "Copy" ne prend pas en charge la copie des r√©pertoires.</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} n'est pas un nombre de nouvelles tentatives valide. La valeur ne doit pas √™tre n√©gative.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} n'est pas un d√©lai de nouvelle tentative valide. La valeur ne doit pas √™tre n√©gative.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: Impossible de supprimer le fichier "{0}¬´¬†. D√©but du {1} de nouvelles tentatives en {2}ms. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: "{2}" fait r√©f√©rence √† {0} √©l√©ment(s) et "{3}", √† {1} √©l√©ment(s). Ils doivent avoir le m√™me nombre d'√©l√©ments.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Cr√©ation du fichier de redirection de liaison ¬´{0}¬ª.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: le fichier de configuration d'application doit avoir un √©l√©ment de configuration racine.</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: ClickOnce ne prend pas en charge le niveau d'ex√©cution de la requ√™te '{0}'.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: La ressource ¬´{0}¬ª de type ¬´{1}¬ª est d√©s√©rialis√©e via BinaryFormatter au moment de l‚Äôex√©cution. BinaryFormatter est d√©conseill√© en raison de risques de s√©curit√© possibles et sera supprim√© avec .NET 9. Si vous souhaitez continuer √† l‚Äôutiliser, d√©finissez la propri√©t√© ¬´ GenerateResourceWarnOnBinaryFormatterUse ¬ª sur false.
+           Plus d‚Äôinformations¬†: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Pour pouvoir g√©n√©rer avec .NET Core, les entr√©es de ressource doivent √™tre au format .txt ou .resx.</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: Impossible de traiter le fichier {0} car il se trouve dans la zone Internet ou Restreinte ou il contient Mark of the Web. Pour traiter ces fichiers, supprimez Mark of the Web.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: La ressource \"{0}\" dans \"{1}\" utilise le type MIME \"{2}\", qui n‚Äôest pas pris en charge par MSBuild lors de l‚Äôex√©cution sur .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Le fichier de sortie "{0}" n'existe pas.</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution a la valeur true, mais le projet r√©f√©renc√© '{0}' n‚Äôa pas de m√©tadonn√©es 'Platforms' ou 'Platform' d√©finies. Il sera g√©n√©r√© sans plateforme sp√©cifi√©e.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">La propri√©t√© platform du '{0}' de projet r√©f√©renc√© correspond √† la plateforme du projet actuel : '{1}'. Le projet r√©f√©renc√© sera g√©n√©r√© sans propri√©t√© De plateforme globale.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Un r√©pertoire vide a √©t√© pass√© √† RemoveDir et a √©t√© ignor√©.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Cette r√©f√©rence n‚Äôest pas ¬´ CopyLocal ¬ª, car il s‚Äôagit d‚Äôune image incorrecte. Il peut s‚Äôagir d‚Äôun fichier binaire natif ou d‚Äôun assembly.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">Informations de listes de profil TargetFramework¬†:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Chemins d'acc√®s de listes de profil TargetFramework¬†:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">Le fichier de liste de packages redistribuables "{0}" a un nom Redist vide ou ayant une valeur null dans l'√©l√©ment FileList. V√©rifiez que le nom Redist n'est pas vide ou qu'il n'a pas une valeur null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Mise √† jour du fichier de cache d‚Äôassembly ¬´{0}¬ª.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">La r√©f√©rence COM '{0}' est l'assembly d'interop√©rabilit√© pour le contr√¥le ActiveX '{1}', mais elle a √©t√© marqu√©e comme √©tant li√©e au compilateur avec l'indicateur /link. Cette r√©f√©rence COM sera trait√©e comme une r√©f√©rence, mais ne sera pas li√©e.</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">La signature PFX n‚Äôest pas prise en charge sur .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">L‚Äôentr√©e se trouve en dehors du r√©pertoire cible : ¬´{0}¬ª</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">L‚Äôattribut 'WriteOnlyWhenDifferent' sur "{0}" prend effet uniquement quand 'Overwrite="true"'.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath n'est pas pris en charge lors de la g√©n√©ration avec .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Vous activez des param√®tres de s√©curit√© XSLT souples via le param√®tre UseTrustedSettings. Pour plus d‚Äôinformations sur les implications en mati√®re de s√©curit√© de ce param√®tre, consultez https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Impossible de traiter l'argument XsltParameters de la t√¢che XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index de3865e9312..2673e90665a 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: la firma ritardata richiede che sia specificata almeno una chiave pubblica. Fornire una chiave pubblica usando le propriet√† KeyFile o KeyContainer oppure disabilitare la firma ritardata.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: ‚Äú{0}‚Äù non √® impostato o √® vuoto. Quando {1} √® false, assicurarsi di impostare un valore non vuoto per "{0}".</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: "{0}" non impostato. Quando {1} √® true, assicurarsi di impostare un valore per "{0}".</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Errore irreversibile: pi√π di {0} argomenti della riga di comando.</target>
@@ -181,6 +191,11 @@
         <target state="translated">Creazione del collegamento reale per copiare "{0}" in "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Ottenuto {0} copiando "{1}" in "{2}" e HR √® {3}"</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: non √® stato possibile usare un collegamento per copiare "{0}" in "{1}".</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">La chiamata alla libreria {0} non √® riuscita con il codice di errore seguente: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Impossibile utilizzare un collegamento reale per copiare "{0}" in "{1}". Verr√† invece copiato il file con collegamento simbolico. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Nuovo tentativo in ERROR_ACCESS_DENIED perch√© la variabile d'ambiente MSBUILDALWAYSRETRY = 1".</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: il file di origine "{0}" √® in realt√† una directory. L'attivit√† "Copia" non supporta la copia di directory.</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} non corrisponde a un numero di tentativi valido. Il valore non deve essere negativo.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} non corrisponde a un ritardo del tentativo valido. Il valore non deve essere negativo.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: non √® stato possibile eliminare il file "{0}". Inizio dei tentativi {1} in {2}ms. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: "{2}" fa riferimento a {0} elemento/i, mentre "{3}" fa riferimento a {1} elemento/i. Devono avere lo stesso numero di elementi.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Creazione del file di reindirizzamento del binding "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: il file di configurazione dell'applicazione deve avere un elemento di configurazione radice.</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: ClickOnce non supporta il livello di esecuzione richieste '{0}'.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: la risorsa "{0}" di tipo "{1}" viene deserializzata tramite BinaryFormatter in fase di esecuzione. BinaryFormatter √® deprecato a causa di possibili rischi per la sicurezza e verr√† rimosso con .NET 9. Per continuare a utilizzarla, impostare la propriet√† "GenerateResourceWarnOnBinaryFormatterUse" su false.
+           Altre informazioni: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: per compilare con .NET Core, gli input delle risorse devono essere in formato. txt o. resx.</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: non √® stato possibile elaborare il file {0} perch√© si trova nell'area Internet o Siti con restrizioni o presenta il contrassegno del Web. Rimuovere il contrassegno del Web se si intende elaborare questi file.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: la risorsa \"{0}\" in \"{1}\" usa il tipo MIME \"{2}\", che non √® supportato da MSBuild durante l'esecuzione in .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Il file di output "{0}" non esiste.</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution √® true, ma il progetto di riferimento '{0}' non ha set di metadati 'Platforms' o 'Platform'. Verr√† compilato senza una piattaforma specificata.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">La propriet√† Platform del progetto di riferimento '{0}' corrisponde alla propriet√† Platform del progetto corrente: '{1}'. Il progetto a cui viene fatto riferimento verr√† compilato senza una propriet√† Platform globale.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: una directory vuota √® stata passata a RemoveDir ed √® stata ignorata.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Questo riferimento non √® "CopyLocal" perch√© √® un'immagine non valida. Potrebbe essere un file binario nativo o non essere affatto un assembly.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">Informazioni sull'elenco di profili TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Percorsi dell'elenco di profili TargetFramework:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">Il file di elenco di pacchetti ridistribuibili "{0}" include un nome di Redist Null o vuoto nell'elemento FileList. Verificare che il nome di Redist non sia Null o vuoto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Aggiornamento del file della cache di assembly "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Il riferimento COM '{0}' √® l'assembly di interoperabilit√† per il controllo ActiveX '{1}', tuttavia √® stato contrassegnato dal compilatore con il flag /link per il collegamento. Il riferimento COM verr√† trattato come riferimento e non verr√† collegato.</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">La firma PFX non √® supportata in .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Il valore immesso non √® compreso nella directory di destinazione: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">L'attributo 'WriteOnlyWhenDifferent' su "{0}" ha effetto solo quando 'Overwrite="true"'.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath non √® supportato quando si compila con .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Si stanno abilitando impostazioni di sicurezza XSLT flessibili tramite il parametro UseTrustedSettings. Per altri dettagli sulle implicazioni di sicurezza di questa impostazione, vedere https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: non √® possibile elaborare l'argomento XsltParameters per l'attivit√† XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 392084cb272..94eb60fe2fe 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: ÈÅÖÂª∂ÁΩ≤Âêç„Å´„ÅØ„ÄÅÊúÄ‰Ωé„Åß„ÇÇ 1 „Å§„ÅÆÂÖ¨Èñã„Ç≠„Éº„ÇíÊåáÂÆö„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇKeyFile „Åæ„Åü„ÅØ KeyContainer „Éó„É≠„Éë„ÉÜ„Ç£„Çí‰ΩøÁî®„Åó„Å¶ÂÖ¨Èñã„Ç≠„Éº„ÇíÊèê‰æõ„Åô„Çã„Åã„ÄÅÈÅÖÂª∂ÁΩ≤Âêç„ÇíÁÑ°Âäπ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: '{0}' „ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÄÅÁ©∫„Åß„Åô„ÄÇ{1} „Åå false „ÅÆÂ†¥Âêà„ÅØ„ÄÅ'{0}' „Å´Á©∫„Åß„Å™„ÅÑÂÄ§„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: '{0}' „ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ{1} „Åå true „ÅÆÂ†¥Âêà„ÅØ„ÄÅÂøÖ„Åö '{0}' „ÅÆÂÄ§„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Ëá¥ÂëΩÁöÑ„Å™„Ç®„É©„Éº: „Ç≥„Éû„É≥„Éâ „É©„Ç§„É≥ÂºïÊï∞„Åå {0} „ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
@@ -181,6 +191,11 @@
         <target state="translated">„Éè„Éº„Éâ „É™„É≥„ÇØ„Çí‰ΩúÊàê„Åó„Å¶ "{0}" „Çí "{1}" „Å´„Ç≥„Éî„Éº„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: "{1}" „Çí "{2}" „Å´„Ç≥„Éî„Éº‰∏≠„Å´ {0}„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇHR „ÅØ {3} „Åß„Åô</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: „É™„É≥„ÇØ„Çí‰ΩøÁî®„Åó„Å¶ "{0}" „Çí "{1}" „Å´„Ç≥„Éî„Éº„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">{0} „É©„Ç§„Éñ„É©„É™„ÅÆÂëº„Å≥Âá∫„Åó„ÅØÊ¨°„ÅÆ„Ç®„É©„Éº „Ç≥„Éº„Éâ„ÅßÂ§±Êïó„Åó„Åæ„Åó„Åü: {1}„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">„Éè„Éº„Éâ „É™„É≥„ÇØ„Çí‰ΩøÁî®„Åó„Å¶ "{0}" „Çí "{1}" „Å´„Ç≥„Éî„Éº„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ‰ª£„Çè„Çä„Å´„Ç∑„É≥„Éú„É™„ÉÉ„ÇØ „É™„É≥„ÇØ„Çí‰ΩøÁî®„Åó„Å¶„Éï„Ç°„Ç§„É´„Çí„Ç≥„Éî„Éº„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Áí∞Â¢ÉÂ§âÊï∞ MSBUILDALWAYSRETRY = 1 „ÅÆ„Åü„ÇÅ„ÄÅERROR_ACCESS_DENIED „ÅßÂÜçË©¶Ë°å„Åó„Å¶„ÅÑ„Åæ„Åô</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: „ÇΩ„Éº„Çπ „Éï„Ç°„Ç§„É´ "{0}" „ÅØ„Éá„Ç£„É¨„ÇØ„Éà„É™„Åß„Åô„ÄÇ"Copy" „Çø„Çπ„ÇØ„ÅØ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ„Ç≥„Éî„Éº„Çí„Çµ„Éù„Éº„Éà„Åó„Åæ„Åõ„Çì„ÄÇ</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} „ÅØÁÑ°Âäπ„Å™ÂÜçË©¶Ë°åÂõûÊï∞„Åß„Åô„ÄÇÂÄ§„ÇíË≤†„Å´„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} „ÅØÁÑ°Âäπ„Å™ÂÜçË©¶Ë°åÈÅÖÂª∂„Åß„Åô„ÄÇÂÄ§„ÇíË≤†„Å´„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: „Éï„Ç°„Ç§„É´ "{0}" „ÇíÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ{1} „ÅÆÂÜçË©¶Ë°å„Çí {2}„Éü„É™Áßí„ÅßÈñãÂßã„Åó„Åæ„Åô„ÄÇ{3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: "{2}" „ÅØ {0} È†ÖÁõÆ„ÇíÂèÇÁÖß„Åó„ÄÅ"{3}" „ÅØ {1} È†ÖÁõÆ„ÇíÂèÇÁÖß„Åó„Åæ„Åô„ÄÇ„Åì„Çå„Çâ„ÅØÂêå„ÅòÈ†ÖÁõÆÊï∞„ÇíÊåÅ„Åü„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">„Éê„Ç§„É≥„Éâ „É™„ÉÄ„Ç§„É¨„ÇØ„Éà „Éï„Ç°„Ç§„É´ "{0}" „Çí‰ΩúÊàê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÊßãÊàê„Éï„Ç°„Ç§„É´„Å´„ÅØ„É´„Éº„ÉàÊßãÊàêË¶ÅÁ¥†„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: ClickOnce „Åß„ÅØ„ÄÅË¶ÅÊ±Ç„ÅÆÂÆüË°å„É¨„Éô„É´ '{0}' „ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: "{0}" Âûã„ÅÆ„É™„ÇΩ„Éº„Çπ "{1}" „ÅØ„ÄÅÂÆüË°åÊôÇ„Å´ BinaryFormatter „Çí‰ªã„Åó„Å¶ÈÄÜ„Ç∑„É™„Ç¢„É´Âåñ„Åï„Çå„Åæ„Åô„ÄÇBinaryFormatter „ÅØ„ÄÅ„Çª„Ç≠„É•„É™„ÉÜ„Ç£‰∏ä„ÅÆ„É™„Çπ„ÇØ„ÅåÁô∫Áîü„Åô„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅÈùûÊé®Â•®„Åß„ÅÇ„Çä„ÄÅ.NET 9 „Çí‰ΩøÁî®„Åó„Å¶ÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇÂºï„ÅçÁ∂ö„Åç‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Éó„É≠„Éë„ÉÜ„Ç£ "GenerateResourceWarnOnBinaryFormatterUse" „Çí false „Å´Ë®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
+           Ë©≥Á¥∞ÊÉÖÂ†±: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: .NET Core „Çí‰ΩøÁî®„Åó„Å¶„Éì„É´„Éâ„Åô„Çã„Å´„ÅØ„ÄÅ„É™„ÇΩ„Éº„Çπ„ÅÆÂÖ•Âäõ„Çí .txt ÂΩ¢Âºè„Åæ„Åü„ÅØ .resx ÂΩ¢Âºè„Å´„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: „Éï„Ç°„Ç§„É´ {0} „ÇíÂá¶ÁêÜ„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Ç§„É≥„Çø„Éº„Éç„ÉÉ„Éà„Åæ„Åü„ÅØÂà∂Èôê‰ªò„Åç„Çæ„Éº„É≥ÂÜÖ„Å´„ÅÇ„Çã„Åã„ÄÅ„Éï„Ç°„Ç§„É´„Å´ Web „ÅÆ„Éû„Éº„ÇØ„Åå„ÅÇ„Çã„Åü„ÇÅ„Åß„Åô„ÄÇ„Åì„Çå„Çâ„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂá¶ÁêÜ„Åô„Çã„Å´„ÅØ„ÄÅWeb „ÅÆ„Éû„Éº„ÇØ„ÇíÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: \"{1}\" „ÅÆ„É™„ÇΩ„Éº„Çπ \"{0}\" „ÅØ MIME „ÅÆÁ®ÆÈ°û \"{2}\" „Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ„ÄÅ.NET „ÅßÂÆüË°å„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅMSBuild „Åß„ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Âá∫Âäõ„Éï„Ç°„Ç§„É´ "{0}" „ÅØÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution „ÅØ true „Åß„Åô„Åå„ÄÅÂèÇÁÖßÂØæË±°„Éó„É≠„Ç∏„Çß„ÇØ„Éà '{0}' „Å´ 'Platforms' „Åæ„Åü„ÅØ 'Platform' „É°„Çø„Éá„Éº„Çø„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Åì„Çå„ÅØ„ÄÅÊåáÂÆö„Åï„Çå„Åü„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†„Å™„Åó„Åß„Éì„É´„Éâ„Åï„Çå„Åæ„Åô„ÄÇ</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">ÂèÇÁÖß„Åï„Çå„Åü„Éó„É≠„Ç∏„Çß„ÇØ„Éà '{0}' „ÅÆ Platform „Éó„É≠„Éë„ÉÜ„Ç£„ÅØÁèæÂú®„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É† '{1}' „Å®‰∏ÄËá¥„Åó„Åæ„Åô„ÄÇÂèÇÁÖß„Åï„Çå„Åü„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅØ„ÄÅ„Ç∞„É≠„Éº„Éê„É´ Platform „Éó„É≠„Éë„ÉÜ„Ç£„Å™„Åó„Åß„Éì„É´„Éâ„Åï„Çå„Åæ„Åô„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Á©∫„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™„Åå RemoveDir „Å´Ê∏°„Åï„Çå„ÄÅÁÑ°Ë¶ñ„Åï„Çå„Åæ„Åó„Åü„ÄÇ</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">„Åì„ÅÆÂèÇÁÖß„ÅØÁÑ°Âäπ„Å™„Ç§„É°„Éº„Ç∏„Åß„ÅÇ„Çã„Åü„ÇÅ„ÄÅ"CopyLocal" „Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Éç„Ç§„ÉÜ„Ç£„Éñ „Éê„Ç§„Éä„É™„Åß„ÅÇ„Çã„Åã„ÄÅ„Ç¢„Çª„É≥„Éñ„É™„Åß„ÅØ„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">TargetFramework „Éó„É≠„Éï„Ç°„Ç§„É´„ÅÆ„É™„Çπ„ÉàÊÉÖÂ†±:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">TargetFramework „Éó„É≠„Éï„Ç°„Ç§„É´„ÅÆ„É™„Çπ„Éà„ÅÆ„Éë„Çπ:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">ÂÜçÈ†íÂ∏ÉÂèØËÉΩ„Éë„ÉÉ„Ç±„Éº„Ç∏ „É™„Çπ„Éà „Éï„Ç°„Ç§„É´ "{0}" „ÅÆ FileList Ë¶ÅÁ¥†„Å´ null „Åæ„Åü„ÅØÁ©∫„ÅÆÂÜçÈ†íÂ∏ÉÂèØËÉΩ„Éë„ÉÉ„Ç±„Éº„Ç∏Âêç„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÂÜçÈ†íÂ∏ÉÂèØËÉΩ„Éë„ÉÉ„Ç±„Éº„Ç∏Âêç„Åå null „Åæ„Åü„ÅØÁ©∫„Åß„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">„Ç¢„Çª„É≥„Éñ„É™ „Ç≠„É£„ÉÉ„Ç∑„É• „Éï„Ç°„Ç§„É´ "{0}" „ÇíÊõ¥Êñ∞„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM ÂèÇÁÖß '{0}' „ÅØ ActiveX „Ç≥„É≥„Éà„É≠„Éº„É´ '{1}' „ÅÆÁõ∏‰∫íÈÅãÁî®„Ç¢„Çª„É≥„Éñ„É™„Åß„Åô„Åå„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„Å´„Çà„Å£„Å¶ /link „Éï„É©„Ç∞„Åß„É™„É≥„ÇØ„Åï„Çå„Çã„Çà„ÅÜ„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆ COM ÂèÇÁÖß„ÅØÂèÇÁÖß„Å®„Åó„Å¶Âá¶ÁêÜ„Åï„Çå„ÄÅ„É™„É≥„ÇØ„Åï„Çå„Åæ„Åõ„Çì„ÄÇ</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">PFX ÁΩ≤Âêç„ÅØ .NET Core „Åß„ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">„Ç®„É≥„Éà„É™„Åå„Çø„Éº„Ç≤„ÉÉ„Éà „Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆÂ§ñÈÉ®„Å´„ÅÇ„Çä„Åæ„Åô: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">"{0}" „ÅÆ 'WriteOnlyWhenDifferent' Â±ûÊÄß„ÅØ„ÄÅ'Overwrite="true"' „ÅÆÂ†¥Âêà„Å´„ÅÆ„ÅøÊúâÂäπ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath „ÅØ„ÄÅ.NET Core „Çí‰ΩøÁî®„Åó„Å¶„Éì„É´„Éâ„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„Çµ„Éù„Éº„Éà„Åï„Çå„Åæ„Åõ„Çì„ÄÇ</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">UseTrustedSettings „Éë„É©„É°„Éº„Çø„Éº„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÁ∑©Âíå„Åï„Çå„Åü XSLT „Çª„Ç≠„É•„É™„ÉÜ„Ç£Ë®≠ÂÆö„ÇíÊúâÂäπ„Å´„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆË®≠ÂÆö„ÅÆ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„Å∏„ÅÆÂΩ±Èüø„ÅÆË©≥Á¥∞„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅhttps://aka.ms/msbuild/xsltransformation-task „ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: XslTransformation „Çø„Çπ„ÇØ„ÅÆ XsltParameters ÂºïÊï∞„ÇíÂá¶ÁêÜ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ{0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 89d0a1e1a73..688212308a9 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: ÏÑúÎ™ÖÏùÑ Ïó∞Í∏∞ÌïòÎ†§Î©¥ Ï†ÅÏñ¥ÎèÑ Í≥µÍ∞ú ÌÇ§Î•º ÏßÄÏ†ïÌï¥Ïïº Ìï©ÎãàÎã§.  KeyFile ÎòêÎäî KeyContainer ÏÜçÏÑ±ÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Í≥µÍ∞ú ÌÇ§Î•º Ï†úÍ≥µÌïòÍ±∞ÎÇò ÏÑúÎ™Ö Ïó∞Í∏∞Î•º ÎπÑÌôúÏÑ±ÌôîÌïòÏÑ∏Ïöî.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: '{0}'Ïù¥(Í∞Ä) ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÍ±∞ÎÇò ÎπÑÏñ¥ ÏûàÏäµÎãàÎã§. {1}Ïù¥(Í∞Ä) falseÏù∏ Í≤ΩÏö∞ '{0}'Ïóê ÎπÑÏñ¥ ÏûàÏßÄ ÏïäÏùÄ Í∞íÏùÑ ÏÑ§Ï†ïÌï¥Ïïº Ìï©ÎãàÎã§.</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: '{0}'Ïù¥(Í∞Ä) ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. {1}Ïù¥(Í∞Ä) trueÏù∏ Í≤ΩÏö∞ '{0}'Ïóê Í∞íÏùÑ ÏÑ§Ï†ïÌï¥Ïïº Ìï©ÎãàÎã§.</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Ïã¨Í∞ÅÌïú Ïò§Î•ò: Î™ÖÎ†πÏ§Ñ Ïù∏ÏàòÍ∞Ä {0}Í∞úÎ•º ÎÑòÏóàÏäµÎãàÎã§.</target>
@@ -181,6 +191,11 @@
         <target state="translated">"{0}"ÏùÑ(Î•º) "{1}"(Ïúº)Î°ú Î≥µÏÇ¨ÌïòÍ∏∞ ÏúÑÌï¥ ÌïòÎìú ÎßÅÌÅ¨Î•º ÎßåÎì≠ÎãàÎã§.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: {0}ÏùÑ(Î•º) ‚Äú{1}‚Äù(Ïúº)Î°ú Î≥µÏÇ¨ÌïòÎäî ‚Äú{2}‚ÄùÏù¥(Í∞Ä) ÏûàÍ≥† HRÏùÄ {3}ÏûÖÎãàÎã§.</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: ÎßÅÌÅ¨Î•º ÏÇ¨Ïö©ÌïòÏó¨ "{0}"ÏùÑ(Î•º) "{1}"Ïóê Î≥µÏÇ¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§.</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Ïò§Î•ò ÏΩîÎìú {1}(Ïúº)Î°ú Ïù∏Ìï¥ {0} ÎùºÏù¥Î∏åÎü¨Î¶¨ Ìò∏Ï∂úÏù¥ Ïã§Ìå®ÌñàÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">ÌïòÎìú ÎßÅÌÅ¨Î•º ÏÇ¨Ïö©ÌïòÏó¨ "{0}(Î•º) "{1}"Ïóê Î≥µÏÇ¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§. ÎåÄÏã† Î∞îÎ°ú Í∞ÄÍ∏∞ ÎßÅÌÅ¨Î°ú ÌååÏùºÏùÑ Î≥µÏÇ¨Ìï©ÎãàÎã§. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: ÌôòÍ≤Ω Î≥ÄÏàò MSBUILDALWAYSRETRY=1Ïù¥ÎØÄÎ°ú ERROR_ACCESS_DENIEDÏóêÏÑú Îã§Ïãú ÏãúÎèÑÌï©ÎãàÎã§.</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: ÏÜåÏä§ ÌååÏùº "{0}"ÏùÄ(Îäî) Ïã§Ï†úÎ°ú ÎîîÎ†âÌÑ∞Î¶¨ÏûÖÎãàÎã§.  "Copy" ÏûëÏóÖÏúºÎ°úÎäî ÎîîÎ†âÌÑ∞Î¶¨Î•º Î≥µÏÇ¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§.</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0}ÏùÄ(Îäî) ÏûòÎ™ªÎêú Ïû¨ÏãúÎèÑ ÌöüÏàòÏûÖÎãàÎã§. Í∞íÏùÄ ÏùåÏàòÏùº Ïàò ÏóÜÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0}ÏùÄ(Îäî) ÏûòÎ™ªÎêú Ïû¨ÏãúÎèÑ Í∞ÑÍ≤©ÏûÖÎãàÎã§. Í∞íÏùÄ ÏùåÏàòÏùº Ïàò ÏóÜÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: "{0}" ÌååÏùºÏùÑ ÏÇ≠Ï†úÌï† Ïàò ÏóÜÏäµÎãàÎã§. {2} msÏóêÏÑú Îã§Ïãú ÏãúÎèÑ {1}ÏùÑ(Î•º) ÏãúÏûëÌï©ÎãàÎã§. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: "{2}"ÏùÄ(Îäî) Ìï≠Î™©ÏùÑ {0}Í∞ú Ï∞∏Ï°∞ÌïòÍ≥† "{3}"ÏùÄ(Îäî) Ìï≠Î™©ÏùÑ {1}Í∞ú Ï∞∏Ï°∞Ìï©ÎãàÎã§. Ï∞∏Ï°∞ÌïòÎäî Ìï≠Î™© ÏàòÎäî Í∞ôÏïÑÏïº Ìï©ÎãàÎã§.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Î∞îÏù∏Îî© Î¶¨ÎîîÎ†âÏÖò ÌååÏùº "{0}"ÏùÑ(Î•º) ÎßåÎìúÎäî Ï§ëÏûÖÎãàÎã§.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Íµ¨ÏÑ± ÌååÏùºÏùÄ Î£®Ìä∏ Íµ¨ÏÑ± ÏöîÏÜåÎ•º Ìè¨Ìï®Ìï¥Ïïº Ìï©ÎãàÎã§.</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: ClickOnceÎäî ÏöîÏ≤≠ Ïã§Ìñâ ÏàòÏ§Ä '{0}'ÏùÑ(Î•º) ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: "{1}" Ïú†ÌòïÏùò "{0}" Î¶¨ÏÜåÏä§Í∞Ä Îü∞ÌÉÄÏûÑ Ïãú BinaryFormatterÎ•º ÌÜµÌï¥ Ïó≠ÏßÅÎ†¨ÌôîÎê©ÎãàÎã§. BinaryFormatterÎäî Í∞ÄÎä•Ìïú Î≥¥Ïïà ÏúÑÌóòÏúºÎ°ú Ïù∏Ìï¥ ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏúºÎ©∞ .NET 9ÏóêÏÑú Ï†úÍ±∞Îê©ÎãàÎã§. Í≥ÑÏÜç ÏÇ¨Ïö©ÌïòÎ†§Î©¥ "GenerateResourceWarnOnBinaryFormatterUse" ÏÜçÏÑ±ÏùÑ falseÎ°ú ÏÑ§Ï†ïÌïòÏÑ∏Ïöî.
+            Ï∂îÍ∞Ä Ï†ïÎ≥¥: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: .NET CoreÎ°ú ÎπåÎìúÌïòÎ†§Î©¥ Î¶¨ÏÜåÏä§ ÏûÖÎ†•Ïù¥ .txt ÎòêÎäî .resx ÌòïÏãùÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: {0} ÌååÏùºÏùÄ Ïù∏ÌÑ∞ÎÑ∑ ÎòêÎäî Ï†úÌïú ÏòÅÏó≠Ïóê ÏûàÍ±∞ÎÇò ÌååÏùºÏóê Ïõπ ÌëúÏãúÍ∞Ä ÏûàÏúºÎØÄÎ°ú Ï≤òÎ¶¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Ïù¥Îü¨Ìïú ÌååÏùºÏùÑ Ï≤òÎ¶¨ÌïòÎ†§Î©¥ Ïõπ ÌëúÏãúÎ•º Ï†úÍ±∞ÌïòÏÑ∏Ïöî.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: \"{1}\"Ïùò Î¶¨ÏÜåÏä§ \"{0}\"ÏùÄ(Îäî) .NETÏóêÏÑú Ïã§ÌñâÌï† Îïå MSBuildÏóêÏÑú ÏßÄÏõêÌïòÏßÄ ÏïäÎäî MIME ÌòïÏãù \"{2}\"ÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Ï∂úÎ†• ÌååÏùº "{0}"Ïù¥(Í∞Ä) ÏóÜÏäµÎãàÎã§.</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolutionÏù¥ trueÏù¥ÏßÄÎßå Ï∞∏Ï°∞Îêú ÌîÑÎ°úÏ†ùÌä∏ '{0}'Ïóê 'Platforms' ÎòêÎäî 'Platform' Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÑ∏Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§. ÏßÄÏ†ïÎêú ÌîåÎû´Ìèº ÏóÜÏù¥ Íµ¨Ï∂ïÎê©ÎãàÎã§.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">Ï∞∏Ï°∞Îêú ÌîÑÎ°úÏ†ùÌä∏ '{0}'Ïùò ÌîåÎû´Ìèº ÏÜçÏÑ±Ïù¥ ÌòÑÏû¨ ÌîÑÎ°úÏ†ùÌä∏Ïùò ÌîåÎû´Ìèº '{1}'Í≥º(ÏôÄ) ÏùºÏπòÌï©ÎãàÎã§. Ï∞∏Ï°∞Îêú ÌîÑÎ°úÏ†ùÌä∏Îäî Ï†ÑÏó≠ Platform ÏÜçÏÑ± ÏóÜÏù¥ ÎπåÎìúÎê©ÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Îπà ÎîîÎ†âÌÑ∞Î¶¨Í∞Ä RemoveDirÏóê Ï†ÑÎã¨ÎêòÏñ¥ Î¨¥ÏãúÎêòÏóàÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Ïù¥ Ï∞∏Ï°∞Îäî ÏûòÎ™ªÎêú Ïù¥ÎØ∏ÏßÄÏù¥ÎØÄÎ°ú "CopyLocal"Ïù¥ ÏïÑÎãôÎãàÎã§. ÎÑ§Ïù¥Ìã∞Î∏å Ïù¥ÏßÑÏù¥Í±∞ÎÇò Ïñ¥ÏÖàÎ∏îÎ¶¨Í∞Ä ÏïÑÎãê Ïàò ÏûàÏäµÎãàÎã§.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">TargetFramework ÌîÑÎ°úÌïÑ Î™©Î°ù Ï†ïÎ≥¥:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">TargetFramework ÌîÑÎ°úÌïÑ Î™©Î°ù Í≤ΩÎ°ú:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">Ïû¨Î∞∞Ìè¨ Í∞ÄÎä• Ìå®ÌÇ§ÏßÄ Î™©Î°ù ÌååÏùº "{0}"Ïùò FileList ÏöîÏÜåÏóê nullÏù¥Í±∞ÎÇò ÎπÑÏñ¥ ÏûàÎäî Ïû¨Î∞∞Ìè¨ Í∞ÄÎä• Ìå®ÌÇ§ÏßÄ Ïù¥Î¶ÑÏù¥ ÏûàÏäµÎãàÎã§. Ïû¨Î∞∞Ìè¨ Í∞ÄÎä• Ìå®ÌÇ§ÏßÄ Ïù¥Î¶ÑÏù¥ nullÏù¥Í±∞ÎÇò ÎπÑÏñ¥ ÏûàÏßÄ ÏïäÎèÑÎ°ù ÌïòÏÑ∏Ïöî.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Ïñ¥ÏÖàÎ∏îÎ¶¨ Ï∫êÏãú ÌååÏùº "{0}"ÏùÑ(Î•º) ÏóÖÎç∞Ïù¥Ìä∏ÌïòÎäî Ï§ëÏûÖÎãàÎã§.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM Ï∞∏Ï°∞ '{0}'ÏùÄ(Îäî) ActiveX Ïª®Ìä∏Î°§ '{1}'Ïóê ÎåÄÌïú interop Ïñ¥ÏÖàÎ∏îÎ¶¨Ïù¥ÏßÄÎßå /link ÌîåÎûòÍ∑∏Î°ú Ïª¥ÌååÏùºÎü¨Ïóê ÏùòÌï¥ ÎßÅÌÅ¨ÎêòÎèÑÎ°ù ÌëúÏãúÎêòÏñ¥ ÏûàÏäµÎãàÎã§. Ïù¥ COM Ï∞∏Ï°∞Îäî Ï∞∏Ï°∞Î°ú Í∞ÑÏ£ºÎêòÏßÄÎßå ÎßÅÌÅ¨ÎêòÏßÄ ÏïäÏäµÎãàÎã§.</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">PFX ÏÑúÎ™ÖÏùÄ .NET CoreÏóêÏÑú ÏßÄÏõêÎêòÏßÄ ÏïäÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Ìï≠Î™©Ïù¥ ÎåÄÏÉÅ ÎîîÎ†âÌÑ∞Î¶¨ "{0}" Ïô∏Î∂ÄÏóê ÏûàÏäµÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">"{0}"Ïùò 'WriteOnlyWhenDifferent' ÌäπÏÑ±ÏùÄ 'Overwrite="true"'Ïù∏ Í≤ΩÏö∞ÏóêÎßå Ï†ÅÏö©Îê©ÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: XslCompiledDllPathÎäî .NET CoreÎ°ú ÎπåÎìúÌï† Îïå ÏßÄÏõêÎêòÏßÄ ÏïäÏäµÎãàÎã§.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">UseTrustedSettings Îß§Í∞ú Î≥ÄÏàòÎ•º ÌÜµÌï¥ ÏôÑÌôîÎêú XSLT Î≥¥Ïïà ÏÑ§Ï†ïÏùÑ ÏÇ¨Ïö©ÌïòÎèÑÎ°ù ÏÑ§Ï†ïÌï©ÎãàÎã§. Ïù¥ ÏÑ§Ï†ïÏùò Î≥¥Ïïà ÏòÅÌñ•Ïóê ÎåÄÌïú ÏûêÏÑ∏Ìïú ÎÇ¥Ïö©ÏùÄ https://aka.ms/msbuild/xsltransformation-taskÎ•º Ï∞∏Ï°∞ÌïòÏÑ∏Ïöî.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: XslTransformation ÏûëÏóÖÏóê ÎåÄÌï¥ XsltParameters Ïù∏ÏàòÎ•º Ï≤òÎ¶¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 6eeba7cace8..68f193780d0 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: Podpisywanie op√≥≈∫nione wymaga okre≈õlenia przynajmniej klucza publicznego.  Podaj klucz publiczny przy u≈ºyciu w≈Ça≈õciwo≈õci KeyFile lub KeyContainer albo wy≈ÇƒÖcz podpisywanie op√≥≈∫nione.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: ‚Äû{0}‚Äù nie jest ustawiony ani pusty. Je≈õli {1} ma warto≈õƒá false, ustaw warto≈õƒá, kt√≥ra nie jest pusta dla ‚Äû{0}‚Äù.</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: nie ustawiono ‚Äû{0}‚Äù. Je≈õli {1} ma warto≈õƒá true, upewnij siƒô, ≈ºe ustawiono warto≈õƒá dla ‚Äû{0}‚Äù.</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: B≈ÇƒÖd krytyczny: liczba argument√≥w wiersza polecenia wiƒôksza ni≈º {0}.</target>
@@ -181,6 +191,11 @@
         <target state="translated">Tworzenie twardego ≈ÇƒÖcza w celu skopiowania ‚Äû{0}‚Äù do ‚Äû{1}‚Äù.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: ‚ÄûMam {0} kopiowane z ‚Äû{1}‚Äù do ‚Äû{2}‚Äù, a HR to {3}‚Äù</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Nie mo≈ºna u≈ºyƒá linku w celu skopiowania ≈õcie≈ºki ‚Äû{0}‚Äù do ≈õcie≈ºki ‚Äû{1}‚Äù.</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Wywo≈Çanie biblioteki {0} nie powiod≈Ço siƒô. Kod b≈Çƒôdu: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Nie mo≈ºna u≈ºyƒá twardego linku do skopiowania ‚Äû{0}‚Äù do ‚Äû{1}‚Äù. Zamiast tego kopiuje plik za pomocƒÖ linku symbolicznego. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: ponowienie pr√≥by w przypadku ERROR_ACCESS_DENIED, poniewa≈º zmiennƒÖ ≈õrodowiskowƒÖ jest MSBUILDALWAYSRETRY = 1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Plik ≈∫r√≥d≈Çowy ‚Äû{0}‚Äù jest w rzeczywisto≈õci katalogiem.  Zadanie ‚ÄûCopy‚Äù nie obs≈Çuguje kopiowania katalog√≥w.</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} jest nieprawid≈ÇowƒÖ liczbƒÖ ponownych pr√≥b. Warto≈õƒá nie mo≈ºe byƒá ujemna.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} jest nieprawid≈Çowym op√≥≈∫nieniem ponownych pr√≥b. Warto≈õƒá nie mo≈ºe byƒá ujemna.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: nie mo≈ºna usunƒÖƒá pliku ‚Äû{0}‚Äù. Rozpoczynanie ponawiania pr√≥by {1} za {2} ms. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: ‚Äû{2}‚Äù odwo≈Çuje siƒô do nastƒôpujƒÖcej liczby element√≥w: {0}, a ‚Äû{3}‚Äù odwo≈Çuje siƒô do nastƒôpujƒÖcej liczby element√≥w: {1}. Liczba tych element√≥w musi byƒá taka sama.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Tworzenie pliku przekierowania powiƒÖzania ‚Äû{0}‚Äù.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Plik konfiguracji aplikacji musi mieƒá g≈Ç√≥wny element konfiguracyjny.</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: Funkcja ClickOnce nie obs≈Çuguje poziomu wykonania ≈ºƒÖdania ‚Äû{0}‚Äù.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: zas√≥b ‚Äû{0}‚Äù typu ‚Äû{1}‚Äù jest deserializowany za po≈õrednictwem elementu BinaryFormatter w czasie wykonywania. Element BinaryFormatter jest przestarza≈Çy z powodu mo≈ºliwych zagro≈ºe≈Ñ bezpiecze≈Ñstwa i zostanie usuniƒôty z platformy .NET 9. Je≈õli chcesz nadal go u≈ºywaƒá, ustaw w≈Ça≈õciwo≈õƒá ‚ÄûGenerateResourceWarnOnBinaryFormatterUse‚Äù na warto≈õƒá false.
+           Wiƒôcej informacji: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Aby kompilowaƒá przy u≈ºyciu platformy .NET Core, dane wej≈õciowe zasob√≥w muszƒÖ byƒá w formacie txt lub resx.</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: Nie mo≈ºna przetworzyƒá pliku {0}, poniewa≈º znajduje siƒô on w strefie Internet lub Witryny z ograniczeniami albo zawiera znacznik strony internetowej. Je≈õli chcesz przetwarzaƒá te pliki, usu≈Ñ znacznik strony internetowej.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: zas√≥b ‚Äû{0}‚Äù w ‚Äû{1}‚Äù u≈ºywa typu MIME ‚Äû{2}‚Äù, kt√≥ry nie jest obs≈Çugiwany przez program MSBuild w przypadku uruchamiania na platformie .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Plik wyj≈õciowy ‚Äû{0}‚Äù nie istnieje.</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: element EnableDynamicPlatformResolution ma warto≈õƒá True, ale projekt ‚Äû{0}‚Äù, do kt√≥rego siƒô odnosi, nie ma ustawionych metadanych ‚ÄûPlatform‚Äù lub ‚ÄûPlatformy‚Äù. Zostanie on skompilowany bez okre≈õlonej platformy.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">W≈Ça≈õciwo≈õƒá platformy przywo≈Çywanego projektu ‚Äû{0}‚Äù jest zgodna z platformƒÖ bie≈ºƒÖcego projektu: ‚Äû{1}‚Äù. Przywo≈Çywany projekt zostanie utworzony bez globalnej w≈Ça≈õciwo≈õci platformy.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Pusty katalog zosta≈Ç przekazany do narzƒôdzia RemoveDir i zosta≈Ç zignorowany.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">To odwo≈Çanie nie jest ‚ÄûCopyLocal‚Äù, poniewa≈º jest to z≈Çy obraz. Mo≈ºe to byƒá natywny plik binarny lub w og√≥le nie jest on zestawem.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">Informacje o li≈õcie profil√≥w TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">≈öcie≈ºki listy profil√≥w TargetFramework:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">Plik z listƒÖ pakiet√≥w redystrybucyjnych ‚Äû{0}‚Äù ma nazwƒô Redist r√≥wnƒÖ null lub pustƒÖ w elemencie FileList. Upewnij siƒô, ≈ºe nazwa Redist nie ma warto≈õci null ani nie jest pusta.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Aktualizowanie pliku pamiƒôci podrƒôcznej zestawu ‚Äû{0}‚Äù.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Odwo≈Çanie COM ‚Äû{0}‚Äù jest zestawem miƒôdzyoperacyjnym dla kontrolki ActiveX ‚Äû{1}‚Äù, ale zosta≈Ço wybrane do po≈ÇƒÖczenia przez kompilator przy u≈ºyciu flagi /link. To odwo≈Çanie COM jest traktowane jako odwo≈Çanie i nie zostanie po≈ÇƒÖczone.</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">Podpisywanie PFX nie jest obs≈Çugiwane na platformie .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Wpis znajduje siƒô poza katalogiem docelowym: ‚Äû{0}‚Äù</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">Atrybut ‚ÄûWriteOnlyWhenDifferent‚Äù w elemencie ‚Äû{0}‚Äù obowiƒÖzuje tylko wtedy, gdy atrybut ‚ÄûOverwrite="true"‚Äù.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: Element XslCompiledDllPath nie jest obs≈Çugiwany podczas kompilowania przy u≈ºyciu platformy .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">W≈ÇƒÖczasz swobodne ustawienia zabezpiecze≈Ñ XSLT za po≈õrednictwem parametru UseTrustedSettings. Aby uzyskaƒá wiƒôcej informacji na temat wp≈Çywu tego ustawienia na zabezpieczenia, zobacz https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Nie mo≈ºna przetwarzaƒá argumentu XsltParameters dla zadania XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index f972bf8832d..55a5986a4c3 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: A assinatura atrasada requer que pelo menos uma chave p√∫blica seja especificada.  Forne√ßa uma chave p√∫blica usando as propriedades KeyFile ou KeyContainer ou desabilite a assinatura atrasada.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: '{0}' n√£o est√° definido ou est√° vazio. Quando {1} for falso, certifique-se de definir um valor n√£o vazio para '{0}'.</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: '{0}' n√£o est√° definido. Quando {1} for verdadeiro, certifique-se de definir um valor para '{0}'.</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Erro Fatal: mais de {0} argumentos de linha de comando.</target>
@@ -181,6 +191,11 @@
         <target state="translated">Criando link f√≠sico para copiar "{0}" em "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Recebi {0} copiando "{1}" para {2} e o RH √© {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: N√£o foi poss√≠vel usar um link para copiar "{0}" para "{1}".</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Falha na chamada √† biblioteca {0} com o seguinte c√≥digo de erro: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">N√£o foi poss√≠vel usar um link f√≠sico para copiar "{0}" para "{1}". Em vez disso, copiando o arquivo com link simb√≥lico. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Tentando novamente em ERROR_ACCESS_DENIED porque a vari√°vel de ambiente MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: O arquivo de origem "{0}" √©, na verdade, um diret√≥rio.  A tarefa "Copy" n√£o d√° suporte √† c√≥pia de diret√≥rios.</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} √© um n√∫mero de novas tentativas inv√°lido. O valor n√£o deve ser negativo.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} √© um atraso de nova tentativa inv√°lido. O valor n√£o deve ser negativo.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: N√£o foi poss√≠vel excluir o arquivo "{0}". Iniciando repeti√ß√£o {1} em {2} ms. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: "{2}" refere-se ao(s) item(ns) {0} e "{3}" refere-se ao(s) item(ns) {1}. Eles devem ter o mesmo n√∫mero de itens.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Criando arquivo de redirecionamento de associa√ß√£o "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: o arquivo de configura√ß√£o do aplicativo deve ter um elemento de configura√ß√£o raiz.</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: O ClickOnce n√£o d√° suporte ao n√≠vel de execu√ß√£o de solicita√ß√£o "{0}".</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: o recurso "{0}" do tipo "{1}" √© desserializado por meio de BinaryFormatter no runtime. O BinaryFormatter foi preterido devido a poss√≠veis riscos de seguran√ßa e ser√° removido com o .NET 9. Se voc√™ quiser continuar a us√°-lo, defina a propriedade "GenerateResourceWarnOnBinaryFormatterUse" como false.
+           Mais informa√ß√µes: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Para compilar com o .NET Core, as entradas de recurso devem estar em formato .txt ou .resx.</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: n√£o foi poss√≠vel processar o arquivo {0} porque ele est√° na Internet ou na zona restrita ou tem a marca da Web no arquivo. Remova a marca da Web se voc√™ quiser processar esses arquivos.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: O recurso \"{0}\" em \"{1}\" usa o tipo MIME \"{2}\", que n√£o tem suporte do MSBuild ao ser executado no .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">O arquivo de sa√≠da "{0}" n√£o existe.</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution √© true, mas o projeto referenciado '{0}' n√£o tem um conjunto de metadados 'Platforms' ou 'Platform'. Ele ser√° constru√≠do sem uma plataforma especificada.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">A propriedade de plataforma do projeto referenciado '{0}' corresponde √† plataforma do projeto atual: '{1}'. O projeto referenciado ser√° constru√≠do sem uma propriedade global Platform.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: um diret√≥rio vazio foi passado para RemoveDir e foi ignorado.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Essa refer√™ncia n√£o √© "CopyLocal" porque √© uma imagem inv√°lida. Ele pode ser um bin√°rio nativo ou pode n√£o ser um assembly.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">Informa√ß√µes da Lista de Perfis TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Caminhos da Lista de Perfis TargetFramework:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">O arquivo da lista de pacote redistribu√≠vel "{0}" tem um nome de Pacote Redistribu√≠vel nulo ou vazio no elemento FileList. Verifique se o Nome do Pacote Redistribu√≠vel n√£o √© nulo nem est√° vazio.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Atualizando o arquivo de cache do assembly "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">A Refer√™ncia COM "{0}" √© o assembly de interoperabilidade para o controle ActiveX "{1}", mas foi marcada para ser vinculada pelo compilador com o sinalizador /link. Essa refer√™ncia COM ser√° tratada como uma refer√™ncia e n√£o ser√° vinculada.</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">N√£o h√° suporte para a assinatura PFX no .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">A entrada est√° fora do diret√≥rio de destino: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">O atributo "WriteOnlyWhenDifferent" em "{0}" entra em vigor somente quando "Overwrite="true"'.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: N√£o h√° suporte para XslCompiledDllPath ao compilar com o .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Voc√™ est√° habilitando configura√ß√µes de seguran√ßa XSLT reduzidas por meio do par√¢metro UseTrustedSettings. Para obter mais detalhes sobre as implica√ß√µes de seguran√ßa dessa configura√ß√£o, consulte https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: N√£o √© poss√≠vel processar o argumento XsltParameters para a tarefa XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 16cdad35345..927c7e60f45 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: –¥–ª—è –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–≥–æ –ø–æ–¥–ø–∏—Å—ã–≤–∞–Ω–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –æ—Ç–∫—Ä—ã—Ç—ã–π –∫–ª—é—á.  –£–∫–∞–∂–∏—Ç–µ –æ—Ç–∫—Ä—ã—Ç—ã–π –∫–ª—é—á —Å –ø–æ–º–æ—â—å—é —Å–≤–æ–π—Å—Ç–≤–∞ KeyFile –∏–ª–∏ KeyContainer –ª–∏–±–æ –æ—Ç–∫–ª—é—á–∏—Ç–µ –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–µ –ø–æ–¥–ø–∏—Å—ã–≤–∞–Ω–∏–µ.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: "{0}" –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ –∏–ª–∏ –ø—É—Å—Ç–æ. –ï—Å–ª–∏ –¥–ª—è {1} –ø—Ä–∏—Å–≤–æ–µ–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ false, –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –Ω–µ–ø—É—Å—Ç–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è "{0}".</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: "{0}" –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ. –ï—Å–ª–∏ –¥–ª—è {1} –ø—Ä–∏—Å–≤–æ–µ–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ true, –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è "{0}".</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: –Ω–µ—É—Å—Ç—Ä–∞–Ω–∏–º–∞—è –æ—à–∏–±–∫–∞: —á–∏—Å–ª–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ –ø—Ä–µ–≤—ã—à–∞–µ—Ç {0}.</target>
@@ -181,6 +191,11 @@
         <target state="translated">–°–æ–∑–¥–∞–Ω–∏–µ –∂–µ—Å—Ç–∫–æ–π —Å–≤—è–∑–∏ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è "{0}" –≤ "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: –í—ã–ø–æ–ª–Ω–µ–Ω–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ {0} "{1}" –≤ "{2}" –∏ HR ‚Äî {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: –Ω–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–≤—è–∑—å –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è "{0}" –≤ "{1}".</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">–°–±–æ–π –≤—ã–∑–æ–≤–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ {0}. –ö–æ–¥ –æ—à–∏–±–∫–∏: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">–ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∂–µ—Å—Ç–∫—É—é —Å–≤—è–∑—å –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è "{0}" –≤ "{1}". –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ —Å —Å–∏–º–≤–æ–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–æ–π. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ ERROR_ACCESS_DENIED, –ø–æ—Å–∫–æ–ª—å–∫—É –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è —Å—Ä–µ–¥—ã MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: –∏—Å—Ö–æ–¥–Ω—ã–π —Ñ–∞–π–ª "{0}" –≤ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —è–≤–ª—è–µ—Ç—Å—è –∫–∞—Ç–∞–ª–æ–≥–æ–º.  –ó–∞–¥–∞—á–∞ Copy –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞—Ç–∞–ª–æ–≥–æ–≤.</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} ‚Äî –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ —á–∏—Å–ª–æ –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫. –ó–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} ‚Äî –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∑–∞–¥–µ—Ä–∂–∫–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏. –ó–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: –Ω–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª "{0}". –ó–∞–ø—É—Å–∫ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏ {1} —á–µ—Ä–µ–∑ {2} –º—Å. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: "{2}" —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–µ —á–∏—Å–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {0}, –∞ "{3}" ‚Äî –Ω–∞ {1}. –ß–∏—Å–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">–°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–∏–≤—è–∑–∫–∏ "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: –§–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∫–æ—Ä–Ω–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: ClickOnce –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —É—Ä–æ–≤–µ–Ω—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞ "{0}".</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: —Ä–µ—Å—É—Ä—Å "{0}" —Å —Ç–∏–ø–æ–º "{1}" –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑—É–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é BinaryFormatter –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è. BinaryFormatter —è–≤–ª—è–µ—Ç—Å—è —É—Å—Ç–∞—Ä–µ–≤—à–∏–º –≤ —Å–≤—è–∑–∏ —Å –≤–æ–∑–º–æ–∂–Ω—ã–º–∏ —É–≥—Ä–æ–∑–∞–º–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ –±—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω —Å .NET 9. –ß—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ, –∑–∞–¥–∞–π—Ç–µ —Å–≤–æ–π—Å—Ç–≤—É "GenerateResourceWarnOnBinaryFormatterUse" –∑–Ω–∞—á–µ–Ω–∏–µ "false".
+           –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–≤–µ–¥–µ–Ω–∏—è: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: –¥–ª—è —Å–±–æ—Ä–∫–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º .NET¬†Core –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Ä–µ—Å—É—Ä—Å–æ–≤ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ TXT –∏–ª–∏ RESX.</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ñ–∞–π–ª "{0}", —Ç–∞–∫ –∫–∞–∫ –æ–Ω –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –ò–Ω—Ç–µ—Ä–Ω–µ—Ç–µ –∏–ª–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–π –∑–æ–Ω–µ –ª–∏–±–æ –∏–º–µ–µ—Ç –≤–µ–±-–º–µ—Ç–∫—É. –ß—Ç–æ–±—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ç–∞–∫–∏–µ —Ñ–∞–π–ª—ã, —Å–ª–µ–¥—É–µ—Ç —É–¥–∞–ª–∏—Ç—å –≤–µ–±-–º–µ—Ç–∫—É.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: —Ä–µ—Å—É—Ä—Å \"{0}\" –≤ \"{1}\" –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç–∏–ø MIME \"{2}\", –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è MSBuild –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ –≤ .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">–í—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª "{0}" –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ true, –Ω–æ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø—Ä–æ–µ–∫—Ç ''{0}'' –Ω–µ –∏–º–µ–µ—Ç ''–ü–ª–∞—Ç—Ñ–æ—Ä–º—ã'' –∏–ª–∏ –Ω–∞–±–æ—Ä–∞ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö ''–ü–ª–∞—Ç—Ñ–æ—Ä–º—ã''. –û–Ω –±—É–¥–µ—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω –±–µ–∑ —É–∫–∞–∑–∞–Ω–Ω–æ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">–°–≤–æ–π—Å—Ç–≤–æ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ ''{0}'' —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ —Ç–µ–∫—É—â–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞: ''{1}''. –°—Å—ã–ª–æ—á–Ω—ã–π –ø—Ä–æ–µ–∫—Ç –±—É–¥–µ—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω –±–µ–∑ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å–≤–æ–π—Å—Ç–≤–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: –≤ RemoveDir –ø–µ—Ä–µ–¥–∞–Ω –ø—É—Å—Ç–æ–π –∫–∞—Ç–∞–ª–æ–≥, –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">–¢–∞–∫ –∫–∞–∫ —ç—Ç–∞ —Å—Å—ã–ª–∫–∞ ‚Äî –Ω–µ–≤–µ—Ä–Ω—ã–π –æ–±—Ä–∞–∑, –æ–Ω–∞ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è "CopyLocal". –û–Ω–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–∞—Ç–∏–≤–Ω—ã–º –¥–≤–æ–∏—á–Ω—ã–º –∫–æ–¥–æ–º –∏–ª–∏ –º–æ–∂–µ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–µ –æ—Ç–Ω–æ—Å–∏—Ç—å—Å—è –∫ —Å–±–æ—Ä–∫–µ.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">–î–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∞ –ø—Ä–æ—Ñ–∏–ª–µ–π TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">–ü—É—Ç–∏ –∫ —Å–ø–∏—Å–∫—É –ø—Ä–æ—Ñ–∏–ª–µ–π TargetFramework:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">–í —Ñ–∞–π–ª–µ —Å–ø–∏—Å–∫–∞ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è–µ–º—ã—Ö –ø–∞–∫–µ—Ç–æ–≤ "{0}" –∏–º—è —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è–µ–º–æ–≥–æ –ø–∞–∫–µ—Ç–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ FileList –∏–º–µ–µ—Ç –ø—É—Å—Ç–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ NULL. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –∏–º—è —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è–µ–º–æ–≥–æ –ø–∞–∫–µ—Ç–∞ (Redist Name) –Ω–µ –ø—É—Å—Ç–æ –∏ –Ω–µ —Ä–∞–≤–Ω–æ NULL.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –∫—ç—à–∞ —Å–±–æ—Ä–∫–∏ "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM-—Å—Å—ã–ª–∫–∞ "{0}" —è–≤–ª—è–µ—Ç—Å—è —Å–±–æ—Ä–∫–æ–π –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–∞ ActiveX "{1}", –Ω–æ –±—ã–ª–∞ –ø–æ–º–µ—á–µ–Ω–∞ –Ω–∞ –∫–æ–º–ø–æ–Ω–æ–≤–∫—É –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º —Ñ–ª–∞–≥–æ–º /link. –≠—Ç–∞ COM-—Å—Å—ã–ª–∫–∞ –±—É–¥–µ—Ç —Å—á–∏—Ç–∞—Ç—å—Å—è —Å—Å—ã–ª–∫–æ–π –∏ –Ω–µ –±—É–¥–µ—Ç —Å–∫–æ–º–ø–æ–Ω–æ–≤–∞–Ω–∞.</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">–ü–æ–¥–ø–∏—Å–∞–Ω–∏–µ PFX –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">–ó–∞–ø–∏—Å—å –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —Ü–µ–ª–µ–≤–æ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">–ê—Ç—Ä–∏–±—É—Ç "WriteOnlyWhenDifferent" –≤ "{0}" –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ "Overwrite="true"".</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —Å–±–æ—Ä–∫–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º .NET¬†Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">–í—ã –≤–∫–ª—é—á–∞–µ—Ç–µ –Ω–µ—Å—Ç—Ä–æ–≥–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ XSLT —Å –ø–æ–º–æ—â—å—é –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ "UseTrustedSettings". –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–≤–µ–¥–µ–Ω–∏—è –æ –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è—Ö –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —ç—Ç–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —Å–º. –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ: https://aka.ms/msbuild/xsltransformation-task.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∞—Ä–≥—É–º–µ–Ω—Ç XsltParameters –¥–ª—è –∑–∞–¥–∞—á–∏ XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 28f5be670d9..920318f9863 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: Gecikmeli imzalama, en azƒ±ndan bir ortak anahtar belirtilmesini gerektirir.  L√ºtfen KeyFile veya KeyContainer √∂zelliklerini kullanarak bir ortak anahtar saƒülayƒ±n veya gecikmeli imzalamayƒ± devre dƒ±≈üƒ± bƒ±rakƒ±n.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: '{0}' ayarlanmamƒ±≈ü veya bo≈ü. {1} yanlƒ±≈ü olduƒüunda, '{0}' i√ßin bo≈ü olmayan bir deƒüer ayarlandƒ±ƒüƒ±ndan emin olun.</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: '{0}' ayarlanmamƒ±≈ü. {1} doƒüru olduƒüunda, '{0}' i√ßin bir deƒüer ayarlandƒ±ƒüƒ±ndan emin olun.</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Kritik Hata: Komut satƒ±rƒ± baƒüƒ±msƒ±z deƒüi≈ükenleri ≈üu sayƒ±dan fazla: {0}.</target>
@@ -181,6 +191,11 @@
         <target state="translated">"{0}" yolunu "{1}" yoluna kopyalamak i√ßin sabit baƒülantƒ± olu≈üturuluyor.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: {0} i√ßin {1} yolu {2} yoluna kopyalandƒ± ve HR: {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: "{0}" dosyasƒ±nƒ± "{1}" yoluna kopyalama baƒülantƒ±sƒ± kullanƒ±lamadƒ±.</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Kitaplƒ±k √ßaƒürƒ±sƒ± {0} ≈üu hata koduyla ba≈üarƒ±sƒ±z oldu: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">"{0}" yolunu "{1}" yoluna kopyalamak i√ßin sabit baƒülantƒ± kullanƒ±lamadƒ±. Dosya bunun yerine sembolik baƒülantƒ± ile kopyalanƒ±yor. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: MSBUILDALWAYSRETRY ortam deƒüi≈ükeni = 1 olduƒüundan ERROR_ACCESS_DENIED √ºzerinde yeniden deneniyor</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: "{0}" kaynak dosyasƒ± aslƒ±nda bir dizindir.  "Kopyala" g√∂revi, dizinleri kopyalamayƒ± desteklemez.</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} ge√ßersiz bir yeniden deneme sayƒ±sƒ±. Deƒüer negatif olamaz.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} ge√ßersiz bir yeniden deneme gecikmesi. Deƒüer negatif olamaz.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: "{0}" dosyasƒ± silinemedi. {1}. yeniden deneme {2} ms i√ßinde ba≈ülƒ±yor. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: "{2}", {0} √∂ƒüeye; "{3}", {1} √∂ƒüeye ba≈üvuruyor. Aynƒ± sayƒ±da √∂ƒüeye sahip olmalarƒ± gerekir.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Baƒülama yeniden y√∂nlendirme dosyasƒ± "{0}" olu≈üturuluyor.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Uygulama yapƒ±landƒ±rma dosyasƒ±nƒ±n k√∂k yapƒ±landƒ±rma √∂ƒüesi olmalƒ±dƒ±r.</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: ClickOnce, '{0}' istek y√ºr√ºtme d√ºzeyini desteklemiyor.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: "{1}" t√ºr√ºndeki "{0}" kaynaƒüƒ±, √ßalƒ±≈üma zamanƒ±nda BinaryFormatter aracƒ±lƒ±ƒüƒ±yla seri durumdan √ßƒ±karƒ±lƒ±r. BinaryFormatter, olasƒ± g√ºvenlik riskleri nedeniyle kullanƒ±m dƒ±≈üƒ± bƒ±rakƒ±ldƒ± ve .NET 9 ile kaldƒ±rƒ±lacak. Kullanmaya devam etmek istiyorsanƒ±z, "GenerateResourceWarnOnBinaryFormatterUse" √∂zelliƒüini false olarak ayarlayƒ±n.
+           Daha fazla bilgi: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: .NET Core ile derlemek i√ßin kaynak giri≈üleri .txt veya .resx bi√ßiminde olmalƒ±dƒ±r.</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: {0} dosyasƒ± ƒ∞nternet‚Äôte veya Kƒ±sƒ±tlƒ± b√∂lgede olduƒüu ya da dosyada web i≈üaretine sahip olduƒüu i√ßin i≈ülenemedi. Bu dosyalarƒ± i≈ülemek istiyorsanƒ±z web i≈üaretlerini kaldƒ±rƒ±n.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: \"{1}\" √∂ƒüesindeki \"{0}\" kaynaƒüƒ± .NET √ºzerinde √ßalƒ±≈üƒ±rken MSBuild tarafƒ±ndan desteklenmeyen \"{2}\" MIME t√ºr√ºn√º kullanƒ±yor.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">"{0}" √ßƒ±kƒ±≈ü dosyasƒ± yok.</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution doƒüru ancak ba≈üvurulan proje '{0}', 'Platforms' veya 'Platform' meta veri k√ºmesine sahip deƒüil. Proje belirli bir platform olmadan olu≈üturulur.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">Ba≈üvurulan '{0}' projesinin platform √∂zelliƒüi mevcut projenin platformuyla e≈üle≈üiyor: '{1}'. Ba≈üvurulan proje, genel bir Platform √∂zelliƒüi olmadan olu≈üturulur.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Bo≈ü bir dizin RemoveDir‚Äôe aktarƒ±ldƒ± ve yoksayƒ±ldƒ±.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Hatalƒ± bir g√∂r√ºnt√º olduƒüundan bu ba≈üvuru "CopyLocal" deƒüil. Yerel bir ikili olabilir veya b√ºt√ºnle≈ütirilmi≈ü kod olmayabilir.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">TargetFramework Profil Listesi Bilgisi:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">TargetFramework Profil Listesi Yollarƒ±:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">"{0}" yeniden daƒüƒ±tƒ±m liste dosyasƒ±nƒ±n FileList √∂ƒüesindeki Redist adƒ± null veya bo≈ü. Redist adƒ±nƒ±n null veya bo≈ü olmadƒ±ƒüƒ±ndan emin olun.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Derleme √∂nbelleƒüi dosyasƒ± "{0}" g√ºncelle≈ütiriliyor.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">'{0}' COM Ba≈üvurusu, '{1}' ActiveX denetiminin birlikte √ßalƒ±≈üma b√ºt√ºnle≈ütirilmi≈ü kodu, ancak /link bayraƒüƒ±yla derleyici tarafƒ±ndan baƒülanmak √ºzere i≈üaretlenmi≈ü. Bu COM ba≈üvurusu, ba≈üvuru olarak deƒüerlendirilecek ve baƒülanmayacak.</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">PFX imzalama .NET Core √ºzerinde desteklenmiyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Girdi, hedef dizinin dƒ±≈üƒ±nda: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">"{0}" √ºzerindeki 'WriteOnlyWhenDifferent' √∂zniteliƒüi, yalnƒ±zca 'Overwrite="true"' olduƒüunda etkili olur.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: .NET Core ile derlenirken XslCompiledDllPath desteklenmez.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">UseTrustedSettings parametresi aracƒ±lƒ±ƒüƒ±yla esnek XSLT g√ºvenlik ayarlarƒ±nƒ± etkinle≈ütiriyorsunuz. Bu ayarƒ±n g√ºvenlik √ºzerindeki etkileri hakkƒ±nda daha fazla bilgi i√ßin l√ºtfen https://aka.ms/msbuild/xsltransformation-task adresine bakƒ±n.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: XslTransformation g√∂revi i√ßin XsltParameters baƒüƒ±msƒ±z deƒüi≈ükeni i≈ülenemiyor. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.xlf b/src/Tasks/Resources/xlf/Strings.xlf
index c4900cd99f9..d3e5dbba7d6 100644
--- a/src/Tasks/Resources/xlf/Strings.xlf
+++ b/src/Tasks/Resources/xlf/Strings.xlf
@@ -1511,7 +1511,7 @@
         <source>TargetFramework Profile List Information:</source>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <note />
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 1fe314e6f39..d0d20ba5c53 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: Âª∂ËøüÁ≠æÂêçË¶ÅÊ±ÇËá≥Â∞ëÊåáÂÆö‰∏Ä‰∏™ÂÖ¨Èí•„ÄÇËØ∑‰ΩøÁî® KeyFile Êàñ KeyContainer Â±ûÊÄßÊèê‰æõ‰∏Ä‰∏™ÂÖ¨Èí•ÔºåÊàñËÄÖÁ¶ÅÁî®Âª∂ËøüÁ≠æÂêç„ÄÇ</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: "{0}" Êú™ËÆæÁΩÆÊàñ‰∏∫Á©∫„ÄÇÂ¶ÇÊûú {1} ‰∏∫ falseÔºåËØ∑Á°Æ‰øù‰∏∫ "{0}" ËÆæÁΩÆÈùûÁ©∫ÂÄº„ÄÇ</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: Êú™ËÆæÁΩÆ "{0}"„ÄÇÂ¶ÇÊûú {1} ‰∏∫ trueÔºåËØ∑Á°Æ‰øù‰∏∫ "{0}" ËÆæÁΩÆÂÄº„ÄÇ</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: ‰∏•ÈáçÈîôËØØ: Ë∂ÖÂá∫ {0} ‰∏™ÂëΩ‰ª§Ë°åÂèÇÊï∞„ÄÇ</target>
@@ -181,6 +191,11 @@
         <target state="translated">ÂàõÂª∫Á°¨ÈìæÊé•‰ª•Â∞Ü‚Äú{0}‚ÄùÂ§çÂà∂Âà∞‚Äú{1}‚Äù„ÄÇ</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Â∞Ü "{1}" Â§çÂà∂Âà∞ "{2}" Êó∂Âá∫Áé∞ {0}ÔºåHR ‰∏∫ {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Êó†Ê≥ï‰ΩøÁî®ÈìæÊé•Â∞Ü‚Äú{0}‚ÄùÂ§çÂà∂Âà∞‚Äú{1}‚Äù„ÄÇ</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">{0} Â∫ìË∞ÉÁî®Â§±Ë¥•ÔºåÈîôËØØ‰ª£Á†ÅÂ¶Ç‰∏ã: {1}„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Êó†Ê≥ï‰ΩøÁî®Á°¨ÈìæÊé•Â∞Ü‚Äú{0}‚ÄùÂ§çÂà∂Âà∞‚Äú{1}‚Äù„ÄÇÊîπ‰∏∫‰ΩøÁî®Á¨¶Âè∑ÈìæÊé•Â§çÂà∂Êñá‰ª∂„ÄÇ {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: ÈáçËØï ERROR_ACCESS_DENIEDÔºåÂõ†‰∏∫ÁéØÂ¢ÉÂèòÈáè MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Ê∫êÊñá‰ª∂‚Äú{0}‚ÄùÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™ÁõÆÂΩï„ÄÇ‚ÄúCopy‚Äù‰ªªÂä°‰∏çÊîØÊåÅÂ§çÂà∂ÁõÆÂΩï„ÄÇ</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} ÊòØÊó†ÊïàÁöÑÈáçËØïËÆ°Êï∞„ÄÇÂÄº‰∏çËÉΩ‰∏∫Ë¥üÊï∞„ÄÇ</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} ÊòØÊó†ÊïàÁöÑÈáçËØïÂª∂ËøüÊó∂Èó¥„ÄÇÂÄº‰∏çËÉΩ‰∏∫Ë¥üÊï∞„ÄÇ</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: Êó†Ê≥ïÂà†Èô§Êñá‰ª∂‚Äú{0}‚Äù„ÄÇ {2} ÊØ´ÁßíÂêéÂºÄÂßãÈáçËØï {1}„ÄÇ{3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: ‚Äú{2}‚ÄùÂºïÁî® {0} ‰∏™È°πÔºåËÄå‚Äú{3}‚ÄùÂºïÁî® {1} ‰∏™È°π„ÄÇÂÆÉ‰ª¨ÂøÖÈ°ªÂÖ∑ÊúâÁõ∏ÂêåÁöÑÈ°πÊï∞„ÄÇ</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Ê≠£Âú®ÂàõÂª∫ÁªëÂÆöÈáçÂÆöÂêëÊñá‰ª∂‚Äú{0}‚Äù„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Â∫îÁî®Á®ãÂ∫èÈÖçÁΩÆÊñá‰ª∂ÂøÖÈ°ªÂÖ∑ÊúâÊ†πÈÖçÁΩÆÂÖÉÁ¥†„ÄÇ</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: ClickOnce ‰∏çÊîØÊåÅËØ∑Ê±ÇÊâßË°åÁ∫ßÂà´‚Äú{0}‚Äù„ÄÇ</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: ‚Äú{1}‚ÄùÁ±ªÂûãÁöÑËµÑÊ∫ê‚Äú{0}‚ÄùÂú®ËøêË°åÊó∂ÈÄöËøá BinaryFormatter ËøõË°åÂèçÂ∫èÂàóÂåñ„ÄÇÁî±‰∫éÂèØËÉΩÂ≠òÂú®ÂÆâÂÖ®È£éÈô©ÔºåBinaryFormatter Â∑≤Ë¢´ÂºÉÁî®ÔºåÂπ∂Â∞Ü‰ΩøÁî® .NET 9 ÁßªÈô§ÂÆÉ„ÄÇÂ¶ÇÊûúË¶ÅÁªßÁª≠‰ΩøÁî®ÂÆÉÔºåËØ∑Â∞ÜÂ±ûÊÄß "GenerateResourceWarnOnBinaryFormatterUse" ËÆæÁΩÆ‰∏∫ false„ÄÇ
+           ËØ¶ÁªÜ‰ø°ÊÅØ: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Ë¶Å‰ΩøÁî® .NET Core ËøõË°åÁîüÊàêÔºåËµÑÊ∫êËæìÂÖ•ÂøÖÈ°ª‰∏∫ .txt Êàñ .resx Ê†ºÂºè„ÄÇ</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: Êó†Ê≥ïÂ§ÑÁêÜÊñá‰ª∂ {0}ÔºåÂõ†‰∏∫ÂÆÉ‰Ωç‰∫é Internet ÊàñÂèóÈôêÂå∫Âüü‰∏≠ÔºåÊàñËÄÖÊñá‰ª∂‰∏äÂÖ∑Êúâ Web Ê†áËÆ∞„ÄÇË¶ÅÊÉ≥Â§ÑÁêÜËøô‰∫õÊñá‰ª∂ÔºåËØ∑Âà†Èô§ Web Ê†áËÆ∞„ÄÇ</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: \"{1}\" ‰∏≠ÁöÑËµÑÊ∫ê \"{0}\" ‰ΩøÁî® MIME Á±ªÂûã \"{2}\"ÔºåËøôÂú® .NET ‰∏äËøêË°åÊó∂‰∏çÂèó MSBuild ÊîØÊåÅ„ÄÇ</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">ËæìÂá∫Êñá‰ª∂‚Äú{0}‚Äù‰∏çÂ≠òÂú®„ÄÇ</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution ‰∏∫ trueÔºå‰ΩÜÂºïÁî®ÁöÑÈ°πÁõÆ \"{0}\" Ê≤°ÊúâËÆæÁΩÆ \"Platforms\" Êàñ \"Platform\" ÂÖÉÊï∞ÊçÆ„ÄÇÂÆÉÂ∞ÜÂú®Ê≤°ÊúâÊåáÂÆöÂπ≥Âè∞ÁöÑÊÉÖÂÜµ‰∏ãÁîüÊàê„ÄÇ</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">ÂºïÁî®È°πÁõÆ \"{0}\" ÁöÑÂπ≥Âè∞Â±ûÊÄß‰∏éÂΩìÂâçÈ°πÁõÆÁöÑÂπ≥Âè∞ \"{1}\" ÂåπÈÖç„ÄÇÂ∞ÜÂú®‰∏ç‰ΩøÁî®ÂÖ®Â±ÄÂπ≥Âè∞Â±ûÊÄßÁöÑÊÉÖÂÜµ‰∏ãÁîüÊàêÂºïÁî®ÁöÑÈ°πÁõÆ„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Â∑≤Âêë RemoveDir ‰º†ÈÄí‰∏Ä‰∏™Á©∫ÁõÆÂΩïÔºåÂπ∂‰∏îÂ∑≤Ë¢´ÂøΩÁï•„ÄÇ</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Ê≠§ÂºïÁî®‰∏çÊòØ‚ÄúCopyLocal‚ÄùÔºåÂõ†‰∏∫ÂÆÉÊòØÈîôËØØÁöÑÂõæÂÉè„ÄÇÂÆÉÂèØËÉΩÊòØÊú¨Êú∫‰∫åËøõÂà∂Êñá‰ª∂ÔºåÊàñËÄÖÊ†πÊú¨‰∏çÊòØÁ®ãÂ∫èÈõÜ„ÄÇ</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">TargetFramework ÈÖçÁΩÆÊñá‰ª∂ÂàóË°®‰ø°ÊÅØ:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">TargetFramework ÈÖçÁΩÆÊñá‰ª∂ÂàóË°®Ë∑ØÂæÑ:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">ÂèØÂÜçÂèëË°åÁ®ãÂ∫èÂåÖÂàóË°®Êñá‰ª∂‚Äú{0}‚ÄùÂú® FileList ÂÖÉÁ¥†‰∏≠ÂÖ∑Êúâ null ÊàñÁ©∫ÁöÑÂèØÂÜçÂèëË°åÁ®ãÂ∫èÂåÖÂêçÁß∞„ÄÇËØ∑Á°Æ‰øùÂèØÂÜçÂèëË°åÁ®ãÂ∫èÂåÖÂêçÁß∞‰∏ç‰∏∫ null ÊàñÁ©∫ÂÄº„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Ê≠£Âú®Êõ¥Êñ∞Á®ãÂ∫èÈõÜÁºìÂ≠òÊñá‰ª∂‚Äú{0}‚Äù„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM ÂºïÁî®‚Äú{0}‚ÄùÊòØ ActiveX Êéß‰ª∂‚Äú{1}‚ÄùÁöÑ‰∫íÊìç‰ΩúÁ®ãÂ∫èÈõÜÔºå‰ΩÜÂê´Êúâ /link Ê†áÂøóÁöÑÁºñËØëÂô®Â∑≤Â∞ÜÂÖ∂Ê†á‰∏∫Â∑≤ÈìæÊé•„ÄÇÁ≥ªÁªü‰ºöÂ∞ÜÊ≠§ COM ÂºïÁî®ËßÜ‰∏∫ÂºïÁî®ÔºåÂπ∂‰∏î‰∏ç‰ºöÈìæÊé•ËØ•ÂºïÁî®„ÄÇ</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">.NET Core ‰∏çÊîØÊåÅ PFX Á≠æÂêç„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Êù°ÁõÆÂú®ÁõÆÊ†áÁõÆÂΩï:‚Äú{0}‚Äù‰πãÂ§ñ</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">Âè™ÊúâÂΩì ‚Äú'Overwrite="true"‚ÄùÊó∂Ôºå‚Äú{0}‚Äù‰∏äÁöÑ ‚ÄúWriteOnlyWhenDifferent‚ÄùÁâπÊÄßÊâç‰ºöÁîüÊïà„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: ‰ΩøÁî® .NET Core ÁîüÊàêÊó∂‰∏çÊîØÊåÅ XslCompiledDllPath„ÄÇ</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Ê≠£Âú®ÈÄöËøá UseTrustedSettings ÂèÇÊï∞ÂêØÁî®ÂÆΩÊùæÁöÑ XSLT ÂÆâÂÖ®ËÆæÁΩÆ„ÄÇÊúâÂÖ≥Ê≠§ËÆæÁΩÆÁöÑÂÆâÂÖ®Âê´‰πâÁöÑËØ¶ÁªÜ‰ø°ÊÅØÔºåËØ∑ÂèÇÈòÖ https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Êó†Ê≥ïÂ§ÑÁêÜ XslTransformation ‰ªªÂä°ÁöÑ XsltParameters ÂèÇÊï∞„ÄÇ{0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index a06847b90c2..207fe11eebc 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -121,6 +121,16 @@
         <target state="translated">MSB3654: Âª∂ÈÅ≤Á∞ΩÁΩ≤ÈúÄË¶ÅËá≥Â∞ëÊåáÂÆö‰∏ÄÂÄãÂÖ¨ÈñãÈáëÈë∞„ÄÇË´ã‰ΩøÁî® KeyFile Êàñ KeyContainer Â±¨ÊÄßÊèê‰æõÂÖ¨ÈñãÈáëÈë∞ÔºåÊàñÂÅúÁî®Âª∂ÈÅ≤Á∞ΩÁΩ≤„ÄÇ</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
+        <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
+        <target state="translated">MSB3991: Êú™Ë®≠ÂÆö '{0}' ÊàñÁ©∫ÁôΩ„ÄÇÁï∂ {1} ÁÇ∫ false ÊôÇÔºåË´ãÂãôÂøÖÂ∞á '{0}' Ë®≠ÂÆöÈùûÁ©∫ÁôΩÂÄº„ÄÇ</target>
+        <note>{StrBegin="MSB3991: "}</note>
+      </trans-unit>
+      <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
+        <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
+        <target state="translated">MSB3992: Êú™Ë®≠ÂÆö '{0}'„ÄÇÁï∂ {1} ÁÇ∫ true ÊôÇÔºåË´ãÂãôÂøÖjÂ∞á '{0}' Ë®≠ÂÆö‰∏ÄÂÄãÂÄº„ÄÇ</target>
+        <note>{StrBegin="MSB3992: "}</note>
+      </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
         <source>MSB3881: Fatal Error: more than {0} command line arguments.</source>
         <target state="translated">MSB3881: Âö¥ÈáçÈåØË™§: ÂëΩ‰ª§ÂàóÂºïÊï∏ÁöÑÊï∏ÁõÆË∂ÖÈÅé {0} ÂÄã„ÄÇ</target>
@@ -181,6 +191,11 @@
         <target state="translated">Ê≠£Âú®Âª∫Á´ãÊ∞∏‰πÖÈÄ£ÁµêÂ∞á "{0}" Ë§áË£ΩÂà∞ "{1}"„ÄÇ</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: ÊìÅÊúâ {0} Â∞á "{1}" Ë§áË£ΩËá≥ "{2}"Ôºå‰∏î HR ÁÇ∫ {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: ÁÑ°Ê≥ï‰ΩøÁî®ÈÄ£ÁµêÂ∞á "{0}" Ë§áË£ΩÂà∞ "{1}"„ÄÇ</target>
@@ -188,7 +203,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">{0} Â™íÈ´îÂ∫´ÂëºÂè´Â§±ÊïóÔºåÁôºÁîü‰∏ãÂàóÈåØË™§Á¢º: {1}„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,9 +223,14 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">ÁÑ°Ê≥ï‰ΩøÁî®Ê∞∏‰πÖÈÄ£ÁµêÂ∞á "{0}" Ë§áË£ΩÂà∞ "{1}"„ÄÇË´ãÊîπÁÇ∫‰ΩøÁî®Á¨¶ËôüÈÄ£ÁµêË§áË£ΩÊ™îÊ°à„ÄÇ{2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Ê≠£Âú® ERROR_ACCESS_DENIED ‰∏äÈáçË©¶ÔºåÂõ†ÁÇ∫Áí∞Â¢ÉËÆäÊï∏ MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: ‰æÜÊ∫êÊ™îÊ°à "{0}" ÂÖ∂ÂØ¶ÊòØÁõÆÈåÑ„ÄÇ"Copy" Â∑•‰Ωú‰∏çÊîØÊè¥Ë§áË£ΩÁõÆÈåÑ„ÄÇ</target>
@@ -308,17 +328,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} ÊòØÁÑ°ÊïàÁöÑÈáçË©¶Ë®àÊï∏„ÄÇÂÄº‰∏çÂæóÁÇ∫Ë≤†Êï∏„ÄÇ</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} ÊòØÁÑ°ÊïàÁöÑÈáçË©¶Âª∂ÈÅ≤„ÄÇÂÄº‰∏çÂæóÁÇ∫Ë≤†Êï∏„ÄÇ</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: ÁÑ°Ê≥ïÂà™Èô§Ê™îÊ°à "{0}"„ÄÇÂ∞áÂú® {2} ÊØ´ÁßíÂÖßÈñãÂßãÈáçË©¶ {1}„ÄÇ{3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -624,6 +644,11 @@
         <target state="translated">MSB3094: "{2}" ÂèÉËÄÉ {0} ÂÄãÈ†ÖÁõÆÔºå"{3}" ÂâáÂèÉËÄÉ {1} ÂÄãÈ†ÖÁõÆ„ÄÇÂÖ©ËÄÖÂèÉËÄÉÁöÑÈ†ÖÁõÆÊï∏ÁõÆÂøÖÈ†àÁõ∏Âêå„ÄÇ</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="translated">Âª∫Á´ãÈÄ£ÁµêÈáçÊñ∞Â∞éÂêëÊ™îÊ°à "{0}"„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: ÊáâÁî®Á®ãÂºèÁµÑÊÖãÊ™îÂøÖÈ†àÊúâÊ†πÁµÑÊÖãÈ†ÖÁõÆ„ÄÇ</target>
@@ -1039,6 +1064,13 @@
         <target state="translated">MSB3190: ClickOnce ‰∏çÊîØÊè¥Ë¶ÅÊ±ÇÂü∑Ë°åÂ±§Á¥ö '{0}'„ÄÇ</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: È°ûÂûã "{1}" ÁöÑË≥áÊ∫ê "{0}" Âú®Âü∑Ë°åÈöéÊÆµÈÄèÈÅé BinaryFormatter ÈÇÑÂéüÂ∫èÂàóÂåñ„ÄÇBinaryFormatter Â∑≤Âõ†ÂèØËÉΩÁöÑÂÆâÂÖ®ÊÄßÈ¢®Èö™ËÄåË¢´Âèñ‰ª£Ôºå‰∏¶Â∞áÈö®Ëëó .NET 9 ÁßªÈô§„ÄÇÂ¶ÇÊûúÊÇ®Ë¶ÅÁπºÁ∫å‰ΩøÁî®ÂÆÉÔºåË´ãÂ∞áÂ±¨ÊÄß "GenerateResourceWarnOnBinaryFormatterUse" Ë®≠ÂÆöÁÇ∫ false„ÄÇ
+           Ë©≥Á¥∞Ë≥áË®ä: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Ëã•Ë¶Å‰ΩøÁî® .NET Core Âª∫ÁΩÆÔºåË≥áÊ∫êËº∏ÂÖ•ÂøÖÈ†àÊé°Áî® .txt Êàñ .resx Ê†ºÂºè„ÄÇ</target>
@@ -1069,6 +1101,11 @@
         <target state="translated">MSB3821: Âõ†ÁÇ∫Ê™îÊ°à {0} ‰ΩçÊñºÁ∂≤ÈöõÁ∂≤Ë∑ØÊàñÊòØÈôêÂà∂ÂçÄÂüü‰∏äÔºåÊàñÊòØÊ™îÊ°à‰∏äÊ®ôÊúâ Web Â≠óÊ®£ÔºåÊâÄ‰ª•ÁÑ°Ê≥ïËôïÁêÜË©≤Ê™îÊ°à„ÄÇËã•Â∏åÊúõËôïÁêÜÈÄô‰∫õÊ™îÊ°àÔºåË´ãÁßªÈô§ Web Â≠óÊ®£„ÄÇ</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: \"{1}\" ‰∏≠ÁöÑË≥áÊ∫ê \"{0}\" ‰ΩøÁî® MIME È°ûÂûã \"{2}\"ÔºåMSBuild Âú® .NET ‰∏äÂü∑Ë°åÊôÇ‰∏çÊîØÊè¥Ê≠§È°ûÂûã„ÄÇ</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Ëº∏Âá∫Ê™î "{0}" ‰∏çÂ≠òÂú®„ÄÇ</target>
@@ -1388,12 +1425,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution ÁÇ∫ trueÔºå‰ΩÜÂèÉËÄÉÁöÑÂ∞àÊ°à '{0}' Êú™Ë®≠ÂÆö 'Platforms' Êàñ 'Platform' ‰∏≠ÁπºË≥áÊñô„ÄÇÂÆÉÂ∞áÂú®Ê≤íÊúâÊåáÂÆöÂπ≥Âè∞ÁöÑÊÉÖÊ≥Å‰∏ãÂª∫ÁΩÆ„ÄÇ</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">ÂèÉËÄÉÂ∞àÊ°àÁöÑÂπ≥Âè∞Â±¨ÊÄß '{0}' Á¨¶ÂêàÁõÆÂâçÂ∞àÊ°àÁöÑÂπ≥Â§™: '{1}'„ÄÇÂ∞áÂª∫ÁΩÆÂèÉËÄÉÁöÑÂ∞àÊ°àÔºå‰ΩÜ‰∏ç‰ΩøÁî®ÂÖ®ÂüüÂπ≥Âè∞Â±¨ÊÄß„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1579,7 +1616,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Â∑≤ÂÇ≥ÈÅûÁ©∫ÁôΩÁõÆÈåÑËá≥ RemoveDir ‰∏¶Â∑≤Âä†‰ª•Áï•ÈÅé„ÄÇ</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1639,7 +1676,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Ê≠§ÂèÉËÄÉ‰∏çÊòØ "CopyLocal"ÔºåÂõ†ÁÇ∫ÂÆÉÊòØÈåØË™§ÁöÑÊò†ÂÉè„ÄÇÂÆÉÂèØËÉΩÊòØÂéüÁîü‰∫åÈÄ≤‰ΩçÊ™îÊ°àÔºåÊàñÂèØËÉΩÂÆåÂÖ®‰∏çÊòØÁµÑ‰ª∂„ÄÇ</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2108,7 +2145,7 @@
         <target state="translated">TargetFramework Ë®≠ÂÆöÊ™îÊ∏ÖÂñÆË≥áË®ä:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">TargetFramework Ë®≠ÂÆöÊ™îÊ∏ÖÂñÆË≥áË∑ØÂæë:</target>
         <note />
@@ -2133,6 +2170,11 @@
         <target state="translated">ÂèØËΩâÊï£ÁôºÂ•ó‰ª∂Ê∏ÖÂñÆÊ™î "{0}" Âú® FileList È†ÖÁõÆ‰∏≠ÁöÑ Redist ÂêçÁ®±ÁÇ∫ null ÊàñÁ©∫ÁôΩ„ÄÇË´ãÁ¢∫Ë™ç Redist ÂêçÁ®±‰∏çÁÇ∫ null ÊàñÁ©∫ÁôΩ„ÄÇ</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="translated">Êõ¥Êñ∞ÁµÑ‰ª∂Âø´ÂèñÊ™îÊ°à "{0}"„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM ÂèÉËÄÉ '{0}' ÊòØ ActiveX ÊéßÂà∂È†Ö '{1}' ÁöÑ Interop ÁµÑ‰ª∂Ôºå‰ΩÜÊòØÊ®ôË®òÁÇ∫Ë¶ÅÁî±Á∑®Ë≠ØÂô®‰ª• /link ÊóóÊ®ôÈÄ£Áµê„ÄÇÈÄôÂÄã COM ÂèÉËÄÉÂ∞áË¢´Ë¶ñÁÇ∫ÂèÉËÄÉÔºå‰∏çÊúÉÈÄ≤Ë°åÈÄ£Áµê„ÄÇ</target>
@@ -2355,7 +2397,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">.NET Core ‰∏ä‰∏çÊîØÊè¥ PFX Á∞ΩÁΩ≤„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2629,7 +2671,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">È†ÖÁõÆ‰ΩçÊñºÁõÆÊ®ôÁõÆÈåÑÂ§ñÈÉ®: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2709,7 +2751,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">"{0}" ‰∏äÁöÑ 'WriteOnlyWhenDifferent' Â±¨ÊÄßÂè™ÊúÉÂú® 'Overwrite="true" ÊôÇÁîüÊïà„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2787,6 +2829,11 @@
         <target state="translated">MSB3705: Âú®‰ΩøÁî® .NET Core Âª∫ÁΩÆÊôÇÔºå‰∏çÊîØÊè¥ XslCompiledDllPath„ÄÇ</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">ÊÇ®Ê≠£Âú®ÈÄèÈÅé UseTrustedSettings ÂèÉÊï∏ÂïüÁî®ÂØ¨È¨ÜÁöÑ XSLT ÂÆâÂÖ®ÊÄßË®≠ÂÆö„ÄÇÂ¶ÇÈúÄÊ≠§Ë®≠ÂÆöÂÆâÂÖ®ÊÄßÂê´ÊÑèÁöÑË©≥Á¥∞Ë≥áÊñôÔºåË´ãÂèÉÈñ± https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: ÁÑ°Ê≥ïËôïÁêÜ XslTransformation Â∑•‰ΩúÁöÑ XsltParameters ÂºïÊï∏„ÄÇ{0}</target>
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 43dd3c3ed10..374fa50852d 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -181,6 +181,12 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> pa
                 TaskType = exportedTypes.FirstOrDefault(type => type.Name.Equals(taskName, StringComparison.OrdinalIgnoreCase))
                            ?? exportedTypes.Where(i => i.FullName != null).FirstOrDefault(type => type.FullName.Equals(taskName, StringComparison.OrdinalIgnoreCase) || type.FullName.EndsWith(taskName, StringComparison.OrdinalIgnoreCase));
 
+                if (TaskType == null)
+                {
+                    _log.LogErrorWithCodeFromResources("CodeTaskFactory.CouldNotFindTaskInAssembly", taskName);
+                    return false;
+                }
+
                 if (taskInfo.CodeType == RoslynCodeTaskFactoryCodeType.Class && parameterGroup.Count == 0)
                 {
                     // If the user specified a whole class but nothing in <ParameterGroup />, automatically derive
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 6b18c794e8f..96a4e7d7ce8 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -15,8 +15,6 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// Base class for task state files.
     /// </remarks>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-    [Serializable]
     internal abstract class StateFileBase
     {
         // Current version for serialization. This should be changed when breaking changes
@@ -30,10 +28,15 @@ internal abstract class StateFileBase
         // Version this instance is serialized with.
         private byte _serializedVersion = CurrentSerializationVersion;
 
+        /// <summary>
+        /// True if <see cref="SerializeCache"/> should create the state file and serialize ourselves, false otherwise.
+        /// </summary>
+        internal virtual bool HasStateToSave => true;
+
         /// <summary>
         /// Writes the contents of this object out to the specified file.
         /// </summary>
-        internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
+        internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log, bool serializeEmptyState = false)
         {
             try
             {
@@ -44,11 +47,14 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
                         File.Delete(stateFile);
                     }
 
-                    using (var s = new FileStream(stateFile, FileMode.CreateNew))
+                    if (serializeEmptyState || HasStateToSave)
                     {
-                        var translator = BinaryTranslator.GetWriteTranslator(s);
-                        translator.Translate(ref _serializedVersion);
-                        Translate(translator);
+                        using (var s = new FileStream(stateFile, FileMode.CreateNew))
+                        {
+                            var translator = BinaryTranslator.GetWriteTranslator(s);
+                            translator.Translate(ref _serializedVersion);
+                            Translate(translator);
+                        }
                     }
                 }
             }
@@ -67,9 +73,9 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
         /// <summary>
         /// Reads the specified file from disk into a StateFileBase derived object.
         /// </summary>
-        internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelper log, Type requiredReturnType)
+        internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log) where T : StateFileBase
         {
-            StateFileBase retVal = null;
+            T retVal = null;
 
             // First, we read the cache from disk if one exists, or if one does not exist, we create one.
             try
@@ -78,7 +84,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                 {
                     using (FileStream s = File.OpenRead(stateFile))
                     {
-                        using var translator = BinaryTranslator.GetReadTranslator(s, buffer: null);
+                        using var translator = BinaryTranslator.GetReadTranslator(s, InterningBinaryReader.PoolingBuffer);
 
                         byte version = 0;
                         translator.Translate(ref version);
@@ -90,21 +96,20 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                             return null;
                         }
 
-                        var constructors = requiredReturnType.GetConstructors();
+                        var constructors = typeof(T).GetConstructors();
                         foreach (var constructor in constructors)
                         {
                             var parameters = constructor.GetParameters();
                             if (parameters.Length == 1 && parameters[0].ParameterType == typeof(ITranslator))
                             {
-                                retVal = constructor.Invoke(new object[] { translator }) as StateFileBase;
+                                retVal = constructor.Invoke(new object[] { translator }) as T;
                             }
                         }
 
-                        if (retVal == null || !requiredReturnType.IsInstanceOfType(retVal))
+                        if (retVal == null)
                         {
                             log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile,
                                 log.FormatResourceString("General.IncompatibleStateFileType"));
-                            retVal = null;
                         }
                     }
                 }
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 9e174d054ca..8774ba6773b 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -22,8 +22,6 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Class is used to cache system state.
     /// </summary>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-    [Serializable]
     internal sealed class SystemState : StateFileBase, ITranslatable
     {
         /// <summary>
@@ -33,10 +31,21 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         private Dictionary<string, FileState> upToDateLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
-        /// Cache at the SystemState instance level. It is serialized and reused between instances.
+        /// Cache at the SystemState instance level.
         /// </summary>
+        /// <remarks>
+        /// Before starting execution, RAR attempts to populate this field by deserializing a per-project cache file. During execution,
+        /// <see cref="FileState"/> objects that get actually used are inserted into <see cref="instanceLocalOutgoingFileStateCache"/>.
+        /// After execution, <see cref="instanceLocalOutgoingFileStateCache"/> is serialized and written to disk if it's different from
+        /// what we originally deserialized into this field.
+        /// </remarks>
         internal Dictionary<string, FileState> instanceLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
+        /// <summary>
+        /// Cache at the SystemState instance level. It is serialized to disk and reused between instances via <see cref="instanceLocalFileStateCache"/>.
+        /// </summary>
+        internal Dictionary<string, FileState> instanceLocalOutgoingFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
+
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
         /// cache this for long periods of time since there's no way (without actually 
@@ -106,7 +115,6 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         /// <summary>
         /// Class that holds the current file state.
         /// </summary>
-        [Serializable]
         internal sealed class FileState : ITranslatable
         {
             /// <summary>
@@ -210,6 +218,16 @@ internal FrameworkName FrameworkNameAttribute
                 get { return frameworkName; }
                 set { frameworkName = value; }
             }
+
+            /// <summary>
+            /// The last-modified value to use for immutable framework files which we don't do I/O on.
+            /// </summary>
+            internal static DateTime ImmutableFileLastModifiedMarker => DateTime.MaxValue;
+
+            /// <summary>
+            /// It is wasteful to persist entries for immutable framework files.
+            /// </summary>
+            internal bool IsWorthPersisting => lastModified != ImmutableFileLastModifiedMarker;
         }
 
         /// <summary>
@@ -248,7 +266,7 @@ public override void Translate(ITranslator translator)
             }
 
             translator.TranslateDictionary(
-                ref instanceLocalFileStateCache,
+                ref (translator.Mode == TranslationDirection.WriteToStream) ? ref instanceLocalOutgoingFileStateCache : ref instanceLocalFileStateCache,
                 StringComparer.OrdinalIgnoreCase,
                 (ITranslator t) => new FileState(t));
 
@@ -257,8 +275,11 @@ public override void Translate(ITranslator translator)
             IsDirty = false;
         }
 
+        /// <inheritdoc />
+        internal override bool HasStateToSave => instanceLocalOutgoingFileStateCache.Count > 0;
+
         /// <summary>
-        /// Flag that indicates
+        /// Flag that indicates that <see cref="instanceLocalFileStateCache"/> has been modified.
         /// </summary>
         /// <value></value>
         internal bool IsDirty
@@ -335,11 +356,11 @@ internal GetAssemblyRuntimeVersion CacheDelegate(GetAssemblyRuntimeVersion getAs
             return GetRuntimeVersion;
         }
 
-        private FileState GetFileState(string path)
+        internal FileState GetFileState(string path)
         {
             // Looking up an assembly to get its metadata can be expensive for projects that reference large amounts
             // of assemblies. To avoid that expense, we remember and serialize this information betweeen runs in
-            // XXXResolveAssemblyReferencesInput.cache files in the intermediate directory and also store it in an
+            // <ProjectFileName>.AssemblyReference.cache files in the intermediate directory and also store it in an
             // process-wide cache to share between successive builds.
             //
             // To determine if this information is up-to-date, we use the last modified date of the assembly, however,
@@ -365,19 +386,30 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
             bool isInstanceFileStateUpToDate = isCachedInInstance && lastModified == cachedInstanceFileState.LastModified;
             bool isProcessFileStateUpToDate = isCachedInProcess && lastModified == cachedProcessFileState.LastModified;
 
-            // If the process-wide cache contains an up-to-date FileState, always use it
+            // If the process-wide cache contains an up-to-date FileState, always use it.
             if (isProcessFileStateUpToDate)
             {
-                // For the next build, we may be using a different process. Update the file cache.
-                if (!isInstanceFileStateUpToDate)
+                // For the next build, we may be using a different process. Update the file cache if the entry is worth persisting.
+                if (cachedProcessFileState.IsWorthPersisting)
                 {
-                    instanceLocalFileStateCache[path] = cachedProcessFileState;
-                    isDirty = true;
+                    if (!isInstanceFileStateUpToDate)
+                    {
+                        instanceLocalFileStateCache[path] = cachedProcessFileState;
+                        isDirty = true;
+                    }
+
+                    // Remember that this FileState was actually used by adding it to the outgoing dictionary.
+                    instanceLocalOutgoingFileStateCache[path] = cachedProcessFileState;
                 }
                 return cachedProcessFileState;
             }
             if (isInstanceFileStateUpToDate)
             {
+                if (cachedInstanceFileState.IsWorthPersisting)
+                {
+                    // Remember that this FileState was actually used by adding it to the outgoing dictionary.
+                    instanceLocalOutgoingFileStateCache[path] = cachedInstanceFileState;
+                }
                 return s_processWideFileStateCache[path] = cachedInstanceFileState;
             }
 
@@ -399,9 +431,16 @@ private DateTime GetAndCacheLastModified(string path)
         private FileState InitializeFileState(string path, DateTime lastModified)
         {
             var fileState = new FileState(lastModified);
-            instanceLocalFileStateCache[path] = fileState;
+
+            // Dirty the instance-local cache only with entries that are worth persisting.
+            if (fileState.IsWorthPersisting)
+            {
+                instanceLocalFileStateCache[path] = fileState;
+                instanceLocalOutgoingFileStateCache[path] = fileState;
+                isDirty = true;
+            }
+
             s_processWideFileStateCache[path] = fileState;
-            isDirty = true;
 
             return fileState;
         }
@@ -450,7 +489,10 @@ private AssemblyNameExtension GetAssemblyName(string path)
                 {
                     fileState.Assembly = AssemblyNameExtension.UnnamedAssembly;
                 }
-                isDirty = true;
+                if (fileState.IsWorthPersisting)
+                {
+                    isDirty = true;
+                }
             }
 
             if (fileState.Assembly.IsUnnamedAssembly)
@@ -471,7 +513,10 @@ private string GetRuntimeVersion(string path)
             if (String.IsNullOrEmpty(fileState.RuntimeVersion))
             {
                 fileState.RuntimeVersion = getAssemblyRuntimeVersion(path);
-                isDirty = true;
+                if (fileState.IsWorthPersisting)
+                {
+                    isDirty = true;
+                }
             }
 
             return fileState.RuntimeVersion;
@@ -503,7 +548,10 @@ private void GetAssemblyMetadata(
                     out fileState.scatterFiles,
                     out fileState.frameworkName);
 
-                isDirty = true;
+                if (fileState.IsWorthPersisting)
+                {
+                    isDirty = true;
+                }
             }
 
             dependencies = fileState.dependencies;
@@ -527,7 +575,7 @@ internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles,
             foreach (ITaskItem stateFile in stateFiles)
             {
                 // Verify that it's a real stateFile. Log message but do not error if not.
-                SystemState sysState = DeserializeCache(stateFile.ToString(), log, typeof(SystemState)) as SystemState;
+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log);
                 if (sysState == null)
                 {
                     continue;
@@ -559,10 +607,10 @@ internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles,
         /// <param name="log">How to log</param>
         internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
         {
-            // Save a copy of instanceLocalFileStateCache so we can restore it later. SerializeCacheByTranslator serializes
-            // instanceLocalFileStateCache by default, so change that to the relativized form, then change it back.
-            Dictionary<string, FileState> oldFileStateCache = instanceLocalFileStateCache;
-            instanceLocalFileStateCache = instanceLocalFileStateCache.ToDictionary(kvp => FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key), kvp => kvp.Value);
+            // Save a copy of instanceLocalOutgoingFileStateCache so we can restore it later. SerializeCacheByTranslator serializes
+            // instanceLocalOutgoingFileStateCache by default, so change that to the relativized form, then change it back.
+            Dictionary<string, FileState> oldFileStateCache = instanceLocalOutgoingFileStateCache;
+            instanceLocalOutgoingFileStateCache = instanceLocalFileStateCache.ToDictionary(kvp => FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key), kvp => kvp.Value);
 
             try
             {
@@ -574,7 +622,7 @@ internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
             }
             finally
             {
-                instanceLocalFileStateCache = oldFileStateCache;
+                instanceLocalOutgoingFileStateCache = oldFileStateCache;
             }
         }
 
diff --git a/src/Tasks/Touch.cs b/src/Tasks/Touch.cs
index 08da8b86dc8..75d00478679 100644
--- a/src/Tasks/Touch.cs
+++ b/src/Tasks/Touch.cs
@@ -16,8 +16,10 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// This class defines the touch task.
     /// </summary>
-    public class Touch : TaskExtension
+    public class Touch : TaskExtension, IIncrementalTask
     {
+        private MessageImportance messageImportance;
+
         /// <summary>
         /// Forces a touch even if the file to be touched is read-only.
         /// </summary>
@@ -45,6 +47,18 @@ public class Touch : TaskExtension
         [Output]
         public ITaskItem[] TouchedFiles { get; set; }
 
+        /// <summary>
+        /// Importance: high, normal, low (default normal)
+        /// </summary>
+        public string Importance { get; set; }
+
+        /// <summary>
+        /// Question the incremental nature of this task.
+        /// </summary>
+        /// <remarks>When Question is true, skip touching the disk to avoid causing incremental issue.
+        /// Unless the file doesn't exists, in which case, error out.</remarks>
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// Implementation of the execute method.
         /// </summary>
@@ -120,6 +134,19 @@ internal bool ExecuteImpl(
         /// <returns></returns>
         public override bool Execute()
         {
+            if (string.IsNullOrEmpty(Importance))
+            {
+                messageImportance = MessageImportance.Normal;
+            }
+            else
+            {
+                if (!Enum.TryParse(Importance, ignoreCase: true, out messageImportance))
+                {
+                    Log.LogErrorWithCodeFromResources("Message.InvalidImportance", Importance);
+                    return false;
+                }
+            }
+
             return ExecuteImpl(
                 File.Exists,
                 File.Create,
@@ -173,7 +200,16 @@ private bool TouchFile(
                 // If the file does not exist then we check if we need to create it.
                 if (AlwaysCreate)
                 {
-                    Log.LogMessageFromResources(MessageImportance.Normal, "Touch.CreatingFile", file, "AlwaysCreate");
+                    if (FailIfNotIncremental)
+                    {
+                        Log.LogErrorFromResources("Touch.CreatingFile", file, "AlwaysCreate");
+                        return false;
+                    }
+                    else
+                    {
+                        Log.LogMessageFromResources(messageImportance, "Touch.CreatingFile", file, "AlwaysCreate");
+                    }
+
                     if (!CreateFile(file, fileCreate))
                     {
                         return false;
@@ -185,9 +221,16 @@ private bool TouchFile(
                     return false;
                 }
             }
+
+            // Ignore touching the disk when FailIfNotIncremental.
+            if (FailIfNotIncremental)
+            {
+                Log.LogErrorFromResources("Touch.Touching", file);
+                return false;
+            }
             else
             {
-                Log.LogMessageFromResources(MessageImportance.Normal, "Touch.Touching", file);
+                Log.LogMessageFromResources(messageImportance, "Touch.Touching", file);
             }
 
             // If the file is read only then we must either issue an error, or, if the user so 
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index fb74aec9202..4c297df27fd 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -53,7 +53,7 @@ public override bool Execute()
 
             if (AssemblyListFile != null)
             {
-                cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache));
+                cacheFile = StateFileBase.DeserializeCache<AssemblyRegistrationCache>(AssemblyListFile.ItemSpec, Log);
 
                 // no cache file, nothing to do. In case there was a problem reading the cache file, we can't do anything anyway.
                 if (cacheFile == null)
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index df5e28463e7..53ad3198125 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Represents a task that can extract a .zip archive.
     /// </summary>
-    public sealed class Unzip : TaskExtension, ICancelableTask
+    public sealed class Unzip : TaskExtension, ICancelableTask, IIncrementalTask
     {
         // We pick a value that is the largest multiple of 4096 that is still smaller than the large object heap threshold (85K).
         // The CopyTo/CopyToAsync buffer is short-lived and is likely to be collected at Gen0, and it offers a significant
@@ -73,6 +73,8 @@ public sealed class Unzip : TaskExtension, ICancelableTask
         /// </summary>
         public string Exclude { get; set; }
 
+        public bool FailIfNotIncremental { get; set; }
+
         /// <inheritdoc cref="ICancelableTask.Cancel"/>
         public void Cancel()
         {
@@ -193,6 +195,11 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
                     Log.LogMessageFromResources(MessageImportance.Low, "Unzip.DidNotUnzipBecauseOfFileMatch", zipArchiveEntry.FullName, destinationPath.FullName, nameof(SkipUnchangedFiles), "true");
                     continue;
                 }
+                else if (FailIfNotIncremental)
+                {
+                    Log.LogErrorFromResources("Unzip.FileComment", zipArchiveEntry.FullName, destinationPath.FullName);
+                    continue;
+                }
 
                 try
                 {
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index f9734a9720f..8ef3dee1bf3 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -6,6 +6,9 @@
 using System.IO;
 using System.Xml;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
+using Microsoft.IO;
+using File = System.IO.File;
 
 #nullable disable
 
@@ -174,17 +177,19 @@ internal class RelationsParser
         #endregion
 
         /// <summary>
-        /// The method that loads in an XML file
+        /// The method that loads in an XML file.
         /// </summary>
-        /// <param name="fileName">the xml file containing switches and properties</param>
-        private XmlDocument LoadFile(string fileName)
+        /// <param name="filePath">the xml file containing switches and properties.</param>
+        private XmlDocument LoadFile(string filePath)
         {
             try
             {
                 var xmlDocument = new XmlDocument();
-                XmlReaderSettings settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                XmlReader reader = XmlReader.Create(fileName, settings);
+                XmlReaderSettings settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+                FileStream fs = File.OpenRead(filePath);
+                using XmlReader reader = XmlReader.Create(fs, settings);
                 xmlDocument.Load(reader);
+
                 return xmlDocument;
             }
             catch (FileNotFoundException e)
@@ -209,9 +214,12 @@ internal XmlDocument LoadXml(string xml)
             {
                 var xmlDocument = new XmlDocument();
                 XmlReaderSettings settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                XmlReader reader = XmlReader.Create(new StringReader(xml), settings);
-                xmlDocument.Load(reader);
-                return xmlDocument;
+                using (XmlReader reader = XmlReader.Create(new StringReader(xml), settings))
+                {
+                    xmlDocument.Load(reader);
+
+                    return xmlDocument;
+                }
             }
             catch (XmlException e)
             {
@@ -221,7 +229,7 @@ internal XmlDocument LoadXml(string xml)
         }
 
         /// <summary>
-        /// Parses the xml file
+        /// Parses the xml file.
         /// </summary>
         public bool ParseXmlDocument(string fileName)
         {
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 33f00f1f19a..f5e09078922 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -114,14 +114,14 @@ public override bool Execute()
             // Check if OutputPath has same number of parameters as xmlInputPaths.
             if (XmlInputPaths != null && XmlInputPaths.Length != _outputPaths.Length)
             {
-                Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", _outputPaths.Length, XmlInputPaths.Length, "XmlContent", "XmlInputPaths");
+                Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", _outputPaths.Length, XmlInputPaths.Length, "OutputPaths", "XmlInputPaths");
                 return false;
             }
 
             // Check if OutputPath has 1 parameter if xmlString is specified.
             if (XmlContent != null && _outputPaths.Length != 1)
             {
-                Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", _outputPaths.Length, 1, "XmlContent", "OutputPaths");
+                Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", _outputPaths.Length, 1, "OutputPaths", "XmlContent");
                 return false;
             }
 
@@ -159,13 +159,18 @@ public override bool Execute()
             // Do the transformation.
             try
             {
+                if (UseTrustedSettings)
+                {
+                    Log.LogMessageFromResources(MessageImportance.High, "XslTransform.SecuritySettingsViaUseTrustedSettings");
+                }
+
                 for (int i = 0; i < xmlinput.Count; i++)
                 {
                     using (XmlWriter xmlWriter = XmlWriter.Create(_outputPaths[i].ItemSpec, xslct.OutputSettings))
                     {
                         using (XmlReader xr = xmlinput.CreateReader(i))
                         {
-                            xslct.Transform(xr, arguments, xmlWriter);
+                            xslct.Transform(xr, arguments, xmlWriter, new XmlUrlResolver());
                         }
 
                         xmlWriter.Close();
@@ -174,7 +179,9 @@ public override bool Execute()
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                Log.LogErrorWithCodeFromResources("XslTransform.TransformError", e.Message);
+                string flattenedMessage = TaskLoggingHelper.GetInnerExceptionMessageString(e);
+                Log.LogErrorWithCodeFromResources("XslTransform.TransformError", flattenedMessage);
+                Log.LogMessage(MessageImportance.Low, e.ToString());
                 return false;
             }
 
@@ -194,7 +201,7 @@ public override bool Execute()
         /// Takes the raw XML and loads XsltArgumentList
         /// </summary>
         /// <param name="xsltParametersXml">The raw XML that holds each parameter as <Parameter Name="" Value="" Namespace="" /> </param>
-        /// <returns>XsltArgumentList</returns>
+        /// <returns>XsltArgumentList.</returns>
         private static XsltArgumentList ProcessXsltArguments(string xsltParametersXml)
         {
             XsltArgumentList arguments = new XsltArgumentList();
@@ -207,8 +214,10 @@ private static XsltArgumentList ProcessXsltArguments(string xsltParametersXml)
             try
             {
                 XmlReaderSettings settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                XmlReader reader = XmlReader.Create(new StringReader("<XsltParameters>" + xsltParametersXml + "</XsltParameters>"), settings);
-                doc.Load(reader);
+                using (XmlReader reader = XmlReader.Create(new StringReader("<XsltParameters>" + xsltParametersXml + "</XsltParameters>"), settings))
+                {
+                    doc.Load(reader);
+                }
             }
             catch (XmlException xe)
             {
diff --git a/src/Tasks/ZipDirectory.cs b/src/Tasks/ZipDirectory.cs
index 89ea647e786..96544d528a9 100644
--- a/src/Tasks/ZipDirectory.cs
+++ b/src/Tasks/ZipDirectory.cs
@@ -10,7 +10,7 @@
 
 namespace Microsoft.Build.Tasks
 {
-    public sealed class ZipDirectory : TaskExtension
+    public sealed class ZipDirectory : TaskExtension, IIncrementalTask
     {
         /// <summary>
         /// Gets or sets a <see cref="ITaskItem"/> containing the full path to the destination file to create.
@@ -29,6 +29,12 @@ public sealed class ZipDirectory : TaskExtension
         [Required]
         public ITaskItem SourceDirectory { get; set; }
 
+        /// <summary>
+        /// Question the incremental nature of this task.
+        /// </summary>
+        /// <remarks>This task does not support incremental build and will error out instead.</remarks>
+        public bool FailIfNotIncremental { get; set; }
+
         public override bool Execute()
         {
             DirectoryInfo sourceDirectory = new DirectoryInfo(SourceDirectory.ItemSpec);
@@ -47,7 +53,7 @@ public override bool Execute()
             {
                 if (destinationFile.Exists)
                 {
-                    if (!Overwrite)
+                    if (!Overwrite || FailIfNotIncremental)
                     {
                         Log.LogErrorWithCodeFromResources("ZipDirectory.ErrorFileExists", destinationFile.FullName);
 
@@ -68,8 +74,15 @@ public override bool Execute()
 
                 try
                 {
-                    Log.LogMessageFromResources(MessageImportance.High, "ZipDirectory.Comment", sourceDirectory.FullName, destinationFile.FullName);
-                    ZipFile.CreateFromDirectory(sourceDirectory.FullName, destinationFile.FullName);
+                    if (FailIfNotIncremental)
+                    {
+                        Log.LogErrorFromResources("ZipDirectory.Comment", sourceDirectory.FullName, destinationFile.FullName);
+                    }
+                    else
+                    {
+                        Log.LogMessageFromResources(MessageImportance.High, "ZipDirectory.Comment", sourceDirectory.FullName, destinationFile.FullName);
+                        ZipFile.CreateFromDirectory(sourceDirectory.FullName, destinationFile.FullName);
+                    }
                 }
                 catch (Exception e)
                 {
diff --git a/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs b/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
index 4e53459f155..8f98ab38e0a 100644
--- a/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
+++ b/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
@@ -27,7 +27,7 @@ public RequiresSymbolicLinksFactAttribute()
             // In Windows, a process can create symlinks only if it has sufficient permissions.
             // We simply try to create one and if it fails we skip the test.
             string sourceFile = FileUtilities.GetTemporaryFile();
-            string destinationFile = FileUtilities.GetTemporaryFile();
+            string destinationFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.Create(sourceFile).Dispose();
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index 2c81395c138..ffd146c0d17 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -324,6 +324,25 @@ public void SetNullMetadataValue()
             item.GetMetadata("m").ShouldBe(string.Empty);
         }
 
+        [Fact]
+        public void ImplementsIMetadataContainer()
+        {
+            Dictionary<string, string> metadata = new()
+            {
+                { "a", "a1" },
+                { "b", "b1" },
+            };
+
+            TaskItem item = new TaskItem("foo");
+            IMetadataContainer metadataContainer = (IMetadataContainer)item;
+
+            metadataContainer.ImportMetadata(metadata);
+
+            var actualMetadata = metadataContainer.EnumerateMetadata().OrderBy(metadata => metadata.Key).ToList();
+            var expectedMetadata = metadata.OrderBy(metadata => metadata.Value).ToList();
+            Assert.True(actualMetadata.SequenceEqual(expectedMetadata));
+        }
+
 #if FEATURE_APPDOMAIN
         /// <summary>
         /// Test that task items can be successfully constructed based on a task item from another appdomain.  
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index f1d08123d54..308a4915321 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -117,7 +117,7 @@ protected override int ExecuteTool(string pathToTool, string responseFileCommand
                 StartInfo = GetProcessStartInfo(GenerateFullPathToTool(), NativeMethodsShared.IsWindows ? "/x" : string.Empty, null);
                 return result;
             }
-        };
+        }
 
         [Fact]
         public void Regress_Mutation_UserSuppliedToolPathIsLogged()
@@ -825,5 +825,213 @@ protected override string GenerateCommandLineCommands()
                 return $"echo ≈Ço≈Ç > {OutputPath}";
             }
         }
+
+        /// <summary>
+        /// Verifies the validation of the <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+        /// </summary>
+        /// <param name="timeout">New value for <see cref="ToolTask.TaskProcessTerminationTimeout" />.</param>
+        /// <param name="isInvalidValid">Is a task expected to be valid or not.</param>
+        [Theory]
+        [InlineData(int.MaxValue, false)]
+        [InlineData(97, false)]
+        [InlineData(0, false)]
+        [InlineData(-1, false)]
+        [InlineData(-2, true)]
+        [InlineData(-101, true)]
+        [InlineData(int.MinValue, true)]
+        public void SetsTerminationTimeoutCorrectly(int timeout, bool isInvalidValid)
+        {
+            using var env = TestEnvironment.Create(_output);
+
+            // Task under test:
+            var task = new ToolTaskSetsTerminationTimeout
+            {
+                BuildEngine = new MockEngine()
+            };
+
+            task.TerminationTimeout = timeout;
+            task.ValidateParameters().ShouldBe(!isInvalidValid);
+            task.TerminationTimeout.ShouldBe(timeout);
+        }
+		
+		/// <summary>
+        /// Verifies that a ToolTask instance can return correct results when executed multiple times with timeout.
+        /// </summary>
+        /// <param name="repeats">Specifies the number of repeats for external command execution.</param>
+        /// <param name="initialDelay">Delay to generate on the first execution in milliseconds.</param>
+        /// <param name="followupDelay">Delay to generate on follow-up execution in milliseconds.</param>
+        /// <param name="timeout">Task timeout in milliseconds.</param>
+        /// <remarks>
+        /// These tests execute the same task instance multiple times, which will in turn run a shell command to sleep
+        /// predefined amount of time. The first execution may time out, but all following ones won't. It is expected
+        /// that all following executions return success.
+        /// </remarks>
+        [Theory]
+        [InlineData(1, 1, 1, -1)] // Normal case, no repeat.
+        [InlineData(3, 1, 1, -1)] // Repeat without timeout.
+        [InlineData(3, 10000, 1, 1000)] // Repeat with timeout.
+        public void ToolTaskThatTimeoutAndRetry(int repeats, int initialDelay, int followupDelay, int timeout)
+        {
+            using var env = TestEnvironment.Create(_output);
+
+            MockEngine engine = new();
+
+            // Task under test:
+            var task = new ToolTaskThatSleeps
+            {
+                BuildEngine = engine,
+                InitialDelay = initialDelay,
+                FollowupDelay = followupDelay,
+                Timeout = timeout
+            };
+
+            // Execute the same task instance multiple times. The index is one-based.
+            bool result;
+            for (int i = 1; i <= repeats; i++)
+            {
+                // Execute the task:
+                result = task.Execute();
+
+                _output.WriteLine(engine.Log);
+
+                task.RepeatCount.ShouldBe(i);
+
+                // The first execution may fail (timeout), but all following ones should succeed:
+                if (i > 1)
+                {
+                    result.ShouldBeTrue();
+                    task.ExitCode.ShouldBe(0);
+                }
+            }
+        }
+
+        /// <summary>
+        /// A simple implementation of <see cref="ToolTask"/> to sleep for a while.
+        /// </summary>
+        /// <remarks>
+        /// This task runs shell command to sleep for predefined, variable amount of time based on how many times the
+        /// instance has been executed.
+        /// </remarks>
+        private sealed class ToolTaskThatSleeps : ToolTask
+        {
+            // Windows prompt command to sleep:
+            private readonly string _windowsSleep = "/c start /wait timeout {0}";
+
+            // UNIX command to sleep:
+            private readonly string _unixSleep = "-c \"sleep {0}\"";
+
+            // Full path to shell:
+            private readonly string _pathToShell;
+
+            public ToolTaskThatSleeps()
+                : base()
+            {
+                // Determines shell to use: cmd for Windows, sh for UNIX-like systems:
+                _pathToShell = NativeMethodsShared.IsUnixLike ? "/bin/sh" : "cmd.exe";
+            }
+
+            /// <summary>
+            /// Gets or sets the delay for the first execution.
+            /// </summary>
+            /// <remarks>
+            /// Defaults to 10 seconds.
+            /// </remarks>
+            public Int32 InitialDelay { get; set; } = 10000;
+
+            /// <summary>
+            /// Gets or sets the delay for the follow-up executions.
+            /// </summary>
+            /// <remarks>
+            /// Defaults to 1 milliseconds.
+            /// </remarks>
+            public Int32 FollowupDelay { get; set; } = 1;
+
+            /// <summary>
+            /// Int32 output parameter for the repeat counter for test purpose.
+            /// </summary>
+            [Output]
+            public Int32 RepeatCount { get; private set; } = 0;
+
+            /// <summary>
+            /// Gets the tool name (shell).
+            /// </summary>
+            protected override string ToolName => Path.GetFileName(_pathToShell);
+
+            /// <summary>
+            /// Gets the full path to shell.
+            /// </summary>
+            protected override string GenerateFullPathToTool() => _pathToShell;
+
+            /// <summary>
+            /// Generates a shell command to sleep different amount of time based on repeat counter.
+            /// </summary>
+            protected override string GenerateCommandLineCommands() =>
+                NativeMethodsShared.IsUnixLike ?
+                string.Format(_unixSleep, RepeatCount < 2 ? InitialDelay / 1000.0 : FollowupDelay / 1000.0) :
+                string.Format(_windowsSleep, RepeatCount < 2 ? InitialDelay / 1000.0 : FollowupDelay / 1000.0);
+
+            /// <summary>
+            /// Ensures that test parameters make sense.
+            /// </summary>
+            protected internal override bool ValidateParameters() =>
+                (InitialDelay > 0) && (FollowupDelay > 0) && base.ValidateParameters();
+
+            /// <summary>
+            /// Runs shell command to sleep for a while.
+            /// </summary>
+            /// <returns>
+            /// true if the task runs successfully; false otherwise.
+            /// </returns>
+            public override bool Execute()
+            {
+                RepeatCount++;
+                return base.Execute();
+            }
+        }
+
+        /// <summary>
+        /// A simple implementation of <see cref="ToolTask"/> to excercise <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+        /// </summary>
+        private sealed class ToolTaskSetsTerminationTimeout : ToolTask
+        {
+            public ToolTaskSetsTerminationTimeout()
+                : base()
+            {
+                base.TaskResources = AssemblyResources.PrimaryResources;
+            }
+
+            /// <summary>
+            /// Gets or sets <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+            /// </summary>
+            /// <remarks>
+            /// This is just a proxy property to access <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+            /// </remarks>
+            public int TerminationTimeout
+            {
+                get => TaskProcessTerminationTimeout;
+                set => TaskProcessTerminationTimeout = value;
+            }
+
+            /// <summary>
+            /// Gets the tool name (dummy).
+            /// </summary>
+            protected override string ToolName => string.Empty;
+
+            /// <summary>
+            /// Gets the full path to tool (dummy).
+            /// </summary>
+            protected override string GenerateFullPathToTool() => string.Empty;
+
+            /// <summary>
+            /// Does nothing.
+            /// </summary>
+            /// <returns>
+            /// Always returns true.
+            /// </returns>
+            /// <remarks>
+            /// This dummy tool task is not meant to run anything.
+            /// </remarks>
+            public override bool Execute() => true;
+        }
     }
 }
diff --git a/src/Utilities/CompatibilitySuppressions.xml b/src/Utilities/CompatibilitySuppressions.xml
index 993613f410e..bb15e1e6c3e 100644
--- a/src/Utilities/CompatibilitySuppressions.xml
+++ b/src/Utilities/CompatibilitySuppressions.xml
@@ -1,5 +1,14 @@
 Ôªø<?xml version="1.0" encoding="utf-8"?>
+<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- We don't have the net7 reference assemblies handy to pass in to compare against the net8 ones -->
+  <Suppression>
+    <DiagnosticId>CP1002</DiagnosticId>
+    <Target>System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Target>
+    <Left>ref/net7.0/Microsoft.Build.Utilities.Core.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
        This is intentional, because you can only use MSBuild in the context of a .NET SDK
        (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
@@ -53,4 +62,9 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
+<!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
+  <Suppression>
+    <DiagnosticId>PKV006</DiagnosticId>
+    <Target>net7.0</Target>
+  </Suppression>
 </Suppressions>
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 64fa68b16e5..5b9a22eba36 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -32,14 +32,8 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
-    <PackageReference Include="System.Security.Permissions" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
-
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
-    <!-- Need Win32 API on .NET Standard to ping registry for some methods in ToolLocationHelper -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
   
   <ItemGroup Label="Shared Code">
     <Compile Include="..\Shared\AssemblyFolders\AssemblyFoldersEx.cs">
@@ -72,9 +66,6 @@
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
       <Link>Shared\CopyOnWriteDictionary.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <Link>Shared\EncodingUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <Link>Shared\ErrorUtilities.cs</Link>
     </Compile>
diff --git a/src/Utilities/PlatformManifest.cs b/src/Utilities/PlatformManifest.cs
index 41b423f984b..fef6aa41a1b 100644
--- a/src/Utilities/PlatformManifest.cs
+++ b/src/Utilities/PlatformManifest.cs
@@ -96,9 +96,10 @@ private void LoadManifestFile()
                 if (FileSystems.Default.FileExists(platformManifestPath))
                 {
                     XmlDocument doc = new XmlDocument();
-                    XmlReaderSettings readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                    XmlReaderSettings readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
 
-                    using (XmlReader xmlReader = XmlReader.Create(platformManifestPath, readerSettings))
+                    FileStream fs = File.OpenRead(platformManifestPath);
+                    using (XmlReader xmlReader = XmlReader.Create(fs, readerSettings))
                     {
                         doc.Load(xmlReader);
                     }
diff --git a/src/Utilities/README.md b/src/Utilities/README.md
index 99a1651b52c..5bc8460e4c5 100644
--- a/src/Utilities/README.md
+++ b/src/Utilities/README.md
@@ -7,6 +7,6 @@ This package contains `Microsoft.Build.Utilities.Core.dll`, which defines helper
 * [`Logger`](https://docs.microsoft.com/dotnet/api/microsoft.build.utilities.logger), a base class for custom logging functionality.
 
 ### netstandard2.0 target
-The `netstandard2.0` target of this build is configured only to output reference assemblies; at runtime MSBuild will be `net7.0` or `net472`. Please use the `net7.0`-targeted assemblies for .NET Core 6+ scenarios.
+The `netstandard2.0` target of this build is configured only to output reference assemblies; at runtime MSBuild will be `net8.0` or `net472`. Please use the `net8.0`-targeted assemblies for .NET 8+ scenarios.
 
 For context, see https://github.com/dotnet/msbuild/pull/6148
\ No newline at end of file
diff --git a/src/Utilities/Resources/Strings.resx b/src/Utilities/Resources/Strings.resx
index 452897f1deb..1bbcf8ce260 100644
--- a/src/Utilities/Resources/Strings.resx
+++ b/src/Utilities/Resources/Strings.resx
@@ -120,10 +120,6 @@
     <data name="General.ToolCommandFailedNoErrorCode">
         <value>The command exited with code {0}.</value>
     </data>
-    <data name="LoggingBeforeTaskInitialization" UESanitized="false" Visibility="Public">
-        <value>MSB6005: Task attempted to log before it was initialized. Message was: {0}</value>
-        <comment>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</comment>
-    </data>
     <data name="PlatformManifest.MissingPlatformXml" UESanitized="false" Visibility="Private_OM">
         <value>MSB6010: Could not find platform manifest file at "{0}".</value>
         <comment>{StrBegin="MSB6010: "}</comment>
@@ -176,6 +172,9 @@
     <value>MSB6011: Invalid parameters passed to the {0} task.</value>
     <comment>{StrBegin="MSB6011: "}</comment>
   </data>
+  <data name="ToolTask.NotUpToDate">
+    <value>Unable to skip task because it is not up-to-date.</value>
+  </data>
   <!-- FileTracker strings -->
   <data name="Tracking_LogFilesNotAvailable">
     <value xml:space="preserve">Tracking logs are not available, minimal rebuild will be disabled.</value>
@@ -291,6 +290,9 @@
     <value>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</value>
     <comment>{StrBegin="MSB6012: "}</comment>
   </data>
+  <data name="ToolTask.InvalidTerminationTimeout" xml:space="preserve">
+    <value>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</value>
+  </data>
   <!--
         The Utilities message bucket is: MSB6001 - MSB6200
 
diff --git a/src/Utilities/Resources/xlf/Strings.cs.xlf b/src/Utilities/Resources/xlf/Strings.cs.xlf
index a8bfb9f8d72..472924ca574 100644
--- a/src/Utilities/Resources/xlf/Strings.cs.xlf
+++ b/src/Utilities/Resources/xlf/Strings.cs.xlf
@@ -27,11 +27,6 @@
         <target state="translated">P≈ô√≠kaz byl ukonƒçen s k√≥dem {0}.</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: √öloha se pokusila p≈ôihl√°sit p≈ôed t√≠m, ne≈æ byla inicializov√°na. Zpr√°va: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: Nepovedlo se naj√≠t soubor manifestu platformy v um√≠stƒõn√≠ {0}.</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: Nepoda≈ôilo se spustit spustiteln√Ω soubor zadan√© √∫lohy {0}. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Zadan√Ω ƒçasov√Ω limit ukonƒçen√≠ ({0}) je neplatn√Ω ‚Äì oƒçek√°v√° se hodnota vƒõt≈°√≠ nebo rovna -1.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">√ölohu nelze p≈ôeskoƒçit, proto≈æe nen√≠ aktu√°ln√≠.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: P≈ô√≠kaz {0} byl ukonƒçen s k√≥dem {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.de.xlf b/src/Utilities/Resources/xlf/Strings.de.xlf
index df6e3dfda00..ae6c7f1d318 100644
--- a/src/Utilities/Resources/xlf/Strings.de.xlf
+++ b/src/Utilities/Resources/xlf/Strings.de.xlf
@@ -27,11 +27,6 @@
         <target state="translated">Der Befehl wurde mit dem Code {0} beendet.</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: Die Aufgabe hat versucht, eine Protokollierung durchzuf√ºhren, bevor sie initialisiert wurde. Meldung: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: Plattform-Manifestdatei in "{0}" nicht gefunden.</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: Die angegebene ausf√ºhrbare Datei der Aufgabe "{0}" konnte nicht ausgef√ºhrt werden. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Das angegebene Beendigungstimeout ({0}) ist ung√ºltig. Es wird ein Wert gr√∂√üer oder gleich -1 erwartet.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">Die Aufgabe kann nicht √ºbersprungen werden, da sie nicht auf dem neuesten Stand ist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" wurde mit dem Code {1} beendet.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.es.xlf b/src/Utilities/Resources/xlf/Strings.es.xlf
index 71a0cc32f88..fb3fb6346d2 100644
--- a/src/Utilities/Resources/xlf/Strings.es.xlf
+++ b/src/Utilities/Resources/xlf/Strings.es.xlf
@@ -27,11 +27,6 @@
         <target state="translated">El comando sali√≥ con el c√≥digo {0}.</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: La tarea intent√≥ registrarse antes de inicializarse. El mensaje era: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: No se ha podido encontrar el archivo de manifiesto de plataforma en "{0}".</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: No se pudo ejecutar la tarea ejecutable especificada "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">El tiempo de espera de finalizaci√≥n especificado ({0}) no es v√°lido; se espera un valor mayor o igual que -1.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">No se puede omitir la tarea porque no est√° actualizada.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" sali√≥ con el c√≥digo {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.fr.xlf b/src/Utilities/Resources/xlf/Strings.fr.xlf
index 2924d87cb1a..b5081267c27 100644
--- a/src/Utilities/Resources/xlf/Strings.fr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.fr.xlf
@@ -27,11 +27,6 @@
         <target state="translated">La commande s'est arr√™t√©e avec le code {0}.</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: La t√¢che a tent√© d'ouvrir une session avant d'√™tre initialis√©e. Le message √©tait le suivant¬†: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: Impossible de trouver le fichier manifeste de la plateforme dans "{0}".</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: Impossible d'ex√©cuter la t√¢che ex√©cutable sp√©cifi√©e "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Le d√©lai d‚Äôarr√™t sp√©cifi√© ({0}) n‚Äôest pas valide . La valeur attendue est sup√©rieure ou √©gale √† -1.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">Nous n‚Äôavons pas pu ignorer la t√¢che, car elle n‚Äôest pas √† jour.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: Arr√™t de "{0}" avec le code {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.it.xlf b/src/Utilities/Resources/xlf/Strings.it.xlf
index ea4e723c61a..a6f2388b69c 100644
--- a/src/Utilities/Resources/xlf/Strings.it.xlf
+++ b/src/Utilities/Resources/xlf/Strings.it.xlf
@@ -27,11 +27,6 @@
         <target state="translated">Uscita dal comando con codice {0}.</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: tentativo di registrazione prima dell'inizializzazione dell'attivit√†. Messaggio: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: il file manifesto della piattaforma non √® stato trovato in "{0}".</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: non √® stato possibile eseguire il file eseguibile "{0}" dell'attivit√†. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Il timeout di terminazione specificato ({0}) non √® valido - √® previsto un valore maggiore o uguale a -1.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">Non √® possibile ignorare l'attivit√† perch√© non √® aggiornata.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" terminato con il codice {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ja.xlf b/src/Utilities/Resources/xlf/Strings.ja.xlf
index 77b2163cf7a..82696e9d9f3 100644
--- a/src/Utilities/Resources/xlf/Strings.ja.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ja.xlf
@@ -27,11 +27,6 @@
         <target state="translated">„Ç≥„Éû„É≥„Éâ„ÅØ„Ç≥„Éº„Éâ {0} „ÅßÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: „Çø„Çπ„ÇØ„ÅØ„ÄÅÂàùÊúüÂåñ„Åï„Çå„ÇãÂâç„Å´„É≠„Ç∞„ÇíË®òÈå≤„Åó„Çà„ÅÜ„Å®„Åó„Åæ„Åó„Åü„ÄÇ„É°„ÉÉ„Çª„Éº„Ç∏: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: "{0}" „Å´„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†„ÅÆ„Éû„Éã„Éï„Çß„Çπ„Éà „Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: ÊåáÂÆö„Åï„Çå„Åü„Çø„Çπ„ÇØÂÆüË°åÂèØËÉΩ„Éï„Ç°„Ç§„É´ "{0}" „ÇíÂÆüË°å„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">ÊåáÂÆö„Åï„Çå„ÅüÁµÇ‰∫Ü„Çø„Ç§„É†„Ç¢„Ç¶„Éà ({0}) „ÅØÁÑ°Âäπ„Åß„Åô„ÄÇ-1 ‰ª•‰∏ä„ÅÆÂÄ§„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">„Çø„Çπ„ÇØ„ÅØÊúÄÊñ∞„Åß„ÅØ„Å™„ÅÑ„Åü„ÇÅ„ÄÅ„Çπ„Ç≠„ÉÉ„Éó„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" „ÅØ„Ç≥„Éº„Éâ {1} „Çí‰º¥„Å£„Å¶ÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ko.xlf b/src/Utilities/Resources/xlf/Strings.ko.xlf
index 937d12bd39a..2de87f94e2b 100644
--- a/src/Utilities/Resources/xlf/Strings.ko.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ko.xlf
@@ -27,11 +27,6 @@
         <target state="translated">Î™ÖÎ†πÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§(ÏΩîÎìú: {0}).</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: ÏûëÏóÖÏùÑ Ï¥àÍ∏∞ÌôîÌïòÍ∏∞ Ï†ÑÏóê Î°úÍπÖÌïòÎ†§Í≥† ÌñàÏäµÎãàÎã§. Î©îÏãúÏßÄ: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: "{0}"ÏóêÏÑú ÌîåÎû´Ìèº Îß§ÎãàÌéòÏä§Ìä∏ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: ÏßÄÏ†ïÌïú ÏûëÏóÖ Ïã§Ìñâ ÌååÏùº "{0}"ÏùÑ(Î•º) Ïã§ÌñâÌï† Ïàò ÏóÜÏäµÎãàÎã§. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">ÏßÄÏ†ïÌïú Ï¢ÖÎ£å ÏãúÍ∞Ñ Ï†úÌïú({0})Ïù¥ ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§. -1Î≥¥Îã§ ÌÅ¨Í±∞ÎÇò Í∞ôÏùÄ Í∞íÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">ÏûëÏóÖÏù¥ ÏµúÏã† ÏÉÅÌÉúÍ∞Ä ÏïÑÎãàÎØÄÎ°ú Í±¥ÎÑàÎõ∏ Ïàò ÏóÜÏäµÎãàÎã§.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}"Ïù¥(Í∞Ä) Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§(ÏΩîÎìú: {1}).</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pl.xlf b/src/Utilities/Resources/xlf/Strings.pl.xlf
index 9cb15be1f03..0be09edd704 100644
--- a/src/Utilities/Resources/xlf/Strings.pl.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pl.xlf
@@ -27,11 +27,6 @@
         <target state="translated">Polecenie zosta≈Ço zako≈Ñczone z kodem {0}.</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: Zadanie podjƒô≈Ço pr√≥bƒô zarejestrowania przed zainicjowaniem. Pojawi≈Ç siƒô komunikat: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: nie mo≈ºna odnale≈∫ƒá pliku manifestu platformy w lokalizacji ‚Äû{0}‚Äù.</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: Nie mo≈ºna uruchomiƒá okre≈õlonego pliku wykonywalnego zadania ‚Äû{0}‚Äù. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Okre≈õlony limit czasu zako≈Ñczenia ({0}) jest nieprawid≈Çowy ‚Äî oczekiwano warto≈õci wiƒôkszej lub r√≥wnej -1.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">Nie mo≈ºna pominƒÖƒá zadania, poniewa≈º nie jest ono aktualne.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: Polecenie ‚Äû{0}‚Äù zako≈Ñczone przez kod {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
index 19e23f9ecdd..031011afb81 100644
--- a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
@@ -27,11 +27,6 @@
         <target state="translated">O comando foi encerrado com o c√≥digo {0}.</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: A tarefa tentou fazer o registro antes de ser inicializada. A mensagem era: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: n√£o foi poss√≠vel encontrar o arquivo de manifesto da plataforma em "{0}".</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: N√£o foi poss√≠vel executar a tarefa execut√°vel "{0}" especificada. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">O tempo limite de encerramento especificado ({0}) √© inv√°lido - esperando valor maior ou igual a -1.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">N√£o foi poss√≠vel ignorar a tarefa porque ela n√£o est√° atualizada.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" foi encerrado com o c√≥digo {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ru.xlf b/src/Utilities/Resources/xlf/Strings.ru.xlf
index c11d3a50afd..af05a69213a 100644
--- a/src/Utilities/Resources/xlf/Strings.ru.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ru.xlf
@@ -27,11 +27,6 @@
         <target state="translated">–í—ã—Ö–æ–¥ –∏–∑ –∫–æ–º–∞–Ω–¥—ã —Å –∫–æ–¥–æ–º "{0}".</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: –∑–∞–¥–∞—á–µ–π –ø—Ä–µ–¥–ø—Ä–∏–Ω—è—Ç–∞ –ø–æ–ø—ã—Ç–∫–∞ –≤–µ—Å—Ç–∏ –∂—É—Ä–Ω–∞–ª –¥–æ —Å–≤–æ–µ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏. –°–æ–æ–±—â–µ–Ω–∏–µ: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: –Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ñ–∞–π–ª –º–∞–Ω–∏—Ñ–µ—Å—Ç–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –ø–æ –∞–¥—Ä–µ—Å—É "{0}".</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å —É–∫–∞–∑–∞–Ω–Ω—ã–π –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª –∑–∞–¥–∞—á–∏ "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">–£–∫–∞–∑–∞–Ω–æ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è ({0}) ‚Äî –æ–∂–∏–¥–∞–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –±–æ–ª—å—à–µ –∏–ª–∏ —Ä–∞–≤–Ω–æ ‚Äì1.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –∑–∞–¥–∞—á—É, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω–∞ –Ω–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∞.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –∫–æ–¥–æ–º {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.tr.xlf b/src/Utilities/Resources/xlf/Strings.tr.xlf
index faf2fbb9512..a2d9744fdbc 100644
--- a/src/Utilities/Resources/xlf/Strings.tr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.tr.xlf
@@ -27,11 +27,6 @@
         <target state="translated">Komuttan {0} koduyla √ßƒ±kƒ±ldƒ±.</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: G√∂rev ba≈ülatƒ±lmadan √∂nce g√ºnl√ºƒüe yazmaya √ßalƒ±≈ütƒ±. ƒ∞leti: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: Platform bildirim dosyasƒ±, "{0}" konumunda bulunamadƒ±.</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: Belirtilen "{0}" g√∂rev y√ºr√ºt√ºlebilir dosyasƒ± √ßalƒ±≈ütƒ±rƒ±lamadƒ±. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Belirtilen sonlandƒ±rma zaman a≈üƒ±mƒ± ({0}) ge√ßersiz; -1'den b√ºy√ºk veya buna e≈üit bir deƒüer bekleniyor.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">G√ºncel olmadƒ±ƒüƒ± i√ßin g√∂rev atlanamƒ±yor.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" √∂ƒüesinden {1} koduyla √ßƒ±kƒ±ldƒ±.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
index 65e9de502ba..ae68e2fdab0 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
@@ -27,11 +27,6 @@
         <target state="translated">ÂëΩ‰ª§Â∑≤ÈÄÄÂá∫Ôºå‰ª£Á†Å‰∏∫ {0}„ÄÇ</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: ‰ªªÂä°Â∞öÊú™ÂàùÂßãÂåñÂ∞±Â∞ùËØïËøõË°åÊó•ÂøóËÆ∞ÂΩï„ÄÇÊ∂àÊÅØ‰∏∫: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: Êâæ‰∏çÂà∞‚Äú{0}‚Äù‰∏≠ÁöÑÂπ≥Âè∞Ê∏ÖÂçïÊñá‰ª∂„ÄÇ</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: ÊåáÂÆöÁöÑ‰ªªÂä°ÂèØÊâßË°åÊñá‰ª∂‚Äú{0}‚ÄùÊú™ËÉΩËøêË°å„ÄÇ{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">ÊåáÂÆöÁöÑÁªàÊ≠¢Ë∂ÖÊó∂({0})Êó†Êïà - ÂÄºÂ∫îÂ§ß‰∫éÊàñÁ≠â‰∫é -1„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">Êó†Ê≥ïË∑≥Ëøá‰ªªÂä°ÔºåÂõ†‰∏∫ÂÆÉ‰∏çÊòØÊúÄÊñ∞ÁöÑ„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: ‚Äú{0}‚ÄùÂ∑≤ÈÄÄÂá∫Ôºå‰ª£Á†Å‰∏∫ {1}„ÄÇ</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index 6d773c29ed9..347b5ed842b 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -27,11 +27,6 @@
         <target state="translated">ÂëΩ‰ª§‰ª•ËøîÂõûÁ¢º {0} ÁµêÊùü„ÄÇ</target>
         <note />
       </trans-unit>
-      <trans-unit id="LoggingBeforeTaskInitialization">
-        <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="translated">MSB6005: Â∑•‰ΩúÂú®ÂàùÂßãÂåñ‰πãÂâçÂ∞±ÂòóË©¶Ë®òÈåÑ„ÄÇË®äÊÅØÁÇ∫: {0}</target>
-        <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
-      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: Âú® "{0}" Êâæ‰∏çÂà∞Âπ≥Âè∞Ë≥áË®äÊ∏ÖÂñÆÊ™îÊ°à„ÄÇ</target>
@@ -62,6 +57,16 @@
         <target state="translated">MSB6003: ÁÑ°Ê≥ïÂü∑Ë°åÊåáÂÆöÁöÑÂ∑•‰ΩúÂèØÂü∑Ë°åÊ™î "{0}"„ÄÇ{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">ÊåáÂÆöÁöÑÁµÇÊ≠¢ÈÄæÊôÇ ({0}) ÁÑ°Êïà - ÂøÖÈ†àÊòØÂ§ßÊñºÊàñÁ≠âÊñº -1 ÁöÑÂÄº„ÄÇ</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="translated">ÁÑ°Ê≥ïÁï•ÈÅéÂ∑•‰ΩúÔºåÂõ†ÁÇ∫ÂÆÉ‰∏çÊòØÊúÄÊñ∞ÁöÑ„ÄÇ</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" ‰ª•ËøîÂõûÁ¢º {1} ÁµêÊùü„ÄÇ</target>
diff --git a/src/Utilities/SDKManifest.cs b/src/Utilities/SDKManifest.cs
index 84711d412b9..e4403e10a83 100644
--- a/src/Utilities/SDKManifest.cs
+++ b/src/Utilities/SDKManifest.cs
@@ -315,9 +315,10 @@ private void LoadManifestFile()
                 if (FileSystems.Default.FileExists(sdkManifestPath))
                 {
                     XmlDocument doc = new XmlDocument();
-                    XmlReaderSettings readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                    XmlReaderSettings readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
 
-                    using (XmlReader xmlReader = XmlReader.Create(sdkManifestPath, readerSettings))
+                    FileStream fs = File.OpenRead(sdkManifestPath);
+                    using (XmlReader xmlReader = XmlReader.Create(fs, readerSettings))
                     {
                         doc.Load(xmlReader);
                     }
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 34d7b498183..858b35eb892 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -480,6 +480,12 @@ IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata()
             return EnumerateMetadataLazy();
         }
 
+        void IMetadataContainer.ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
+        {
+            _metadata ??= new CopyOnWriteDictionary<string>(MSBuildNameIgnoreCaseComparer.Default);
+            _metadata.SetItems(metadata.Select(kvp => new KeyValuePair<string, string>(kvp.Key, kvp.Value ?? string.Empty)));
+        }
+
         private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
         {
             if (_metadata == null)
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 0f344499164..e419870cbe7 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -3116,10 +3116,10 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
 
             // Make sure we have a directory with a redist list folder and a FrameworkList.xml file in there as this is what we will use for chaining.
             string redistListFolder = Path.Combine(path, "RedistList");
-            string redistFile = Path.Combine(redistListFolder, "FrameworkList.xml");
+            string redistFilePath = Path.Combine(redistListFolder, "FrameworkList.xml");
 
             // If the redist list does not exist then the entire chain is incorrect.
-            if (!FileSystems.Default.FileExists(redistFile))
+            if (!FileSystems.Default.FileExists(redistFilePath))
             {
                 // Under MONO a directory may chain to one that has no redist list
                 var chainReference = NativeMethodsShared.IsMono ? string.Empty : null;
@@ -3139,10 +3139,9 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
             try
             {
                 // Read in the xml file looking for the includeFramework inorder to chain.
-                XmlReaderSettings readerSettings = new XmlReaderSettings();
-                readerSettings.DtdProcessing = DtdProcessing.Ignore;
-
-                using (XmlReader reader = XmlReader.Create(redistFile, readerSettings))
+                XmlReaderSettings readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+                FileStream fs = File.OpenRead(redistFilePath);
+                using (XmlReader reader = XmlReader.Create(fs, readerSettings))
                 {
                     while (reader.Read())
                     {
@@ -3182,11 +3181,11 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
             }
             catch (XmlException ex)
             {
-                ErrorUtilities.ThrowInvalidOperation("ToolsLocationHelper.InvalidRedistFile", redistFile, ex.Message);
+                ErrorUtilities.ThrowInvalidOperation("ToolsLocationHelper.InvalidRedistFile", redistFilePath, ex.Message);
             }
             catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
             {
-                ErrorUtilities.ThrowInvalidOperation("ToolsLocationHelper.InvalidRedistFile", redistFile, ex.Message);
+                ErrorUtilities.ThrowInvalidOperation("ToolsLocationHelper.InvalidRedistFile", redistFilePath, ex.Message);
             }
 
             // Cache the display name if we have one
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 2243faedfca..3a8ff43f237 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -1,4 +1,4 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -58,7 +58,7 @@ public enum HostObjectInitializationStatus
     /// </summary>
     // INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and
     // we want to use resources from Utilities. Use LogPrivate (for private Utilities resources) and LogShared (for shared MSBuild resources)
-    public abstract class ToolTask : Task, ICancelableTask
+    public abstract class ToolTask : Task, IIncrementalTask, ICancelableTask
     {
         private static readonly bool s_preserveTempFiles = string.Equals(Environment.GetEnvironmentVariable("MSBUILDPRESERVETOOLTEMPFILES"), "1", StringComparison.Ordinal);
 
@@ -345,13 +345,29 @@ protected virtual void ProcessStarted() { }
         /// Implemented in the derived class
         /// </summary>
         /// <returns>true, if successful</returns>
-        protected internal virtual bool ValidateParameters() => true; // Default is no validation (ie. parameters are always valid, hence the true return value). This is useful for tools that don't need validation.
+        protected internal virtual bool ValidateParameters()
+        {
+            if (TaskProcessTerminationTimeout < -1 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+            {
+                Log.LogWarningWithCodeFromResources("ToolTask.InvalidTerminationTimeout", TaskProcessTerminationTimeout);
+                return false;
+            }
+
+            return true;
+        }
 
         /// <summary>
         /// Returns true if task execution is not necessary. Executed after ValidateParameters
         /// </summary>
         /// <returns></returns>
-        protected virtual bool SkipTaskExecution() => false;
+        protected virtual bool SkipTaskExecution() { canBeIncremental = false; return false; }
+
+        /// <summary>
+        /// ToolTask is not incremental by default. When a derived class overrides SkipTaskExecution, then Question feature can take into effect.
+        /// </summary>
+        protected bool canBeIncremental { get; set; } = true;
+
+        public bool FailIfNotIncremental { get; set; }
 
         /// <summary>
         /// Returns a string with those switches and other information that can go into a response file.
@@ -670,6 +686,7 @@ protected virtual int ExecuteTool(
             _standardOutputDataAvailable = new ManualResetEvent(false);
 
             _toolExited = new ManualResetEvent(false);
+            _terminatedTool = false;
             _toolTimeoutExpired = new ManualResetEvent(false);
 
             _eventsDisposed = false;
@@ -937,7 +954,7 @@ private void KillToolProcessOnTimeout(Process proc, bool isBeingCancelled)
                     LogShared.LogWarningWithCodeFromResources("Shared.KillingProcessByCancellation", processName);
                 }
 
-                int timeout = 5000;
+                int timeout = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && TaskProcessTerminationTimeout >= -1 ? TaskProcessTerminationTimeout : 5000;
                 string timeoutFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDTOOLTASKCANCELPROCESSWAITTIMEOUT");
                 if (timeoutFromEnvironment != null)
                 {
@@ -1324,6 +1341,11 @@ public override bool Execute()
                     // doing any actual work).
                     return true;
                 }
+                else if (canBeIncremental && FailIfNotIncremental)
+                {
+                    LogPrivate.LogErrorWithCodeFromResources("ToolTask.NotUpToDate");
+                    return false;
+                }
 
                 string commandLineCommands = GenerateCommandLineCommands();
                 // If there are response file commands, then we need a response file later.
@@ -1385,7 +1407,7 @@ public override bool Execute()
 
                         string batchFileForCommandLine = _temporaryBatchFile;
 
-                        // If for some crazy reason the path has a & character and a space in it
+                        // If for some reason the path has a & character and a space in it
                         // then get the short path of the temp path, which should not have spaces in it
                         // and then escape the &
                         if (batchFileForCommandLine.Contains("&") && !batchFileForCommandLine.Contains("^&"))
diff --git a/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs
deleted file mode 100644
index b1b0fb8baa4..00000000000
--- a/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    ///  This test should be run only on .NET (or .NET Core).
-    /// </summary>
-    public class DotNetOnlyFactAttribute : FactAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="DotNetOnlyFactAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public DotNetOnlyFactAttribute(string? additionalMessage = null)
-        {
-            if (!CustomXunitAttributesUtilities.IsBuiltAgainstDotNet)
-            {
-                this.Skip = "This test only runs on .NET.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs
deleted file mode 100644
index b6ee768534b..00000000000
--- a/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    ///  This test should be run only on .NET (or .NET Core).
-    /// </summary>
-    public class DotNetOnlyTheoryAttribute : TheoryAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="DotNetOnlyTheoryAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public DotNetOnlyTheoryAttribute(string? additionalMessage = null)
-        {
-            if (!CustomXunitAttributesUtilities.IsBuiltAgainstDotNet)
-            {
-                this.Skip = "This test only runs on .NET.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs
deleted file mode 100644
index f3878ef0de3..00000000000
--- a/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This test should be run only on Unix (Linux, OSX platforms).
-    /// </summary>
-    public class UnixOnlyFactAttribute : FactAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="UnixOnlyFactAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public UnixOnlyFactAttribute(string? additionalMessage = null)
-        {
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test requires Unix to run.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs
deleted file mode 100644
index f0a1769882e..00000000000
--- a/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This test should be run only on Unix (Linux, OSX platforms).
-    /// </summary>
-    public class UnixOnlyTheoryAttribute : TheoryAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="UnixOnlyTheoryAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public UnixOnlyTheoryAttribute(string? additionalMessage = null)
-        {
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test requires Unix to run.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs
deleted file mode 100644
index 4caa40a3198..00000000000
--- a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs
+++ /dev/null
@@ -1,30 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    ///  This test should be run only on Windows on full .NET Framework.
-    /// </summary>
-    public class WindowsFullFrameworkOnlyFactAttribute : FactAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="WindowsFullFrameworkOnlyFactAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public WindowsFullFrameworkOnlyFactAttribute(string? additionalMessage = null)
-        {
-            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test only runs on Windows on full framework.".AppendAdditionalMessage(additionalMessage);
-                return;
-            }
-            if (!CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
-            {
-                this.Skip = "This test only runs on full framework.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs
deleted file mode 100644
index 952bf0d7250..00000000000
--- a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    ///  This test should be run only on Windows on full .NET Framework.
-    /// </summary>
-    public class WindowsFullFrameworkOnlyTheoryAttribute : TheoryAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="WindowsFullFrameworkOnlyTheoryAttribute"/> class.
-        /// Creates the attribute.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public WindowsFullFrameworkOnlyTheoryAttribute(string? additionalMessage = null)
-        {
-            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test only runs on Windows on full framework.".AppendAdditionalMessage(additionalMessage);
-                return;
-            }
-            if (!CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
-            {
-                this.Skip = "This test only runs on full framework.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs
deleted file mode 100644
index 72f2378ad02..00000000000
--- a/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This test should be run only on Windows.
-    /// </summary>
-    public class WindowsOnlyFactAttribute : FactAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="WindowsOnlyFactAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public WindowsOnlyFactAttribute(string? additionalMessage = null)
-        {
-            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test requires Windows to run.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs
deleted file mode 100644
index dfc2be0b220..00000000000
--- a/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This test should be run only on Windows.
-    /// </summary>
-    public class WindowsOnlyTheoryAttribute : TheoryAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="WindowsOnlyTheoryAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public WindowsOnlyTheoryAttribute(string? additionalMessage = null)
-        {
-            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test requires Windows to run.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Xunit.NetCore.Extensions.csproj b/src/Xunit.NetCore.Extensions/Xunit.NetCore.Extensions.csproj
index 6bc9b9cbc4d..01d47500a32 100644
--- a/src/Xunit.NetCore.Extensions/Xunit.NetCore.Extensions.csproj
+++ b/src/Xunit.NetCore.Extensions/Xunit.NetCore.Extensions.csproj
@@ -7,6 +7,8 @@
     <IsTestProject>false</IsTestProject><!-- while this project references xunit it isn't itself a test -->
   </PropertyGroup>
   <ItemGroup>
-    <PackageReference Include="xunit.core" />
+    <!-- Implicit references to xunit.core and xunit.assert in test projects by Arcade
+         cause restore failures if PackageVersion is in the normal .props file. -->
+    <PackageReference Include="xunit.core" VersionOverride="$(XUnitVersion)" />
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
