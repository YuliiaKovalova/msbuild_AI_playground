diff --git a/.github/fabricbot.json b/.github/fabricbot.json
index 805c4d1eeb1..61fca534d95 100644
--- a/.github/fabricbot.json
+++ b/.github/fabricbot.json
@@ -1,80 +1,11 @@
 {
   "version": "1.0",
   "tasks": [
-    {
-      "taskType": "trigger",
-      "capabilityId": "AutoMerge",
-      "subCapability": "AutoMerge",
-      "version": "1.0",
-      "id": "_eeVr2w4J",
-      "config": {
-        "taskName": "Automatically squash and  merge PR once CI passes",
-        "label": "auto-merge",
-        "minMinutesOpen": "12",
-        "mergeType": "squash",
-        "deleteBranches": true,
-        "requireAllStatuses": true,
-        "minimumNumberOfCheckRuns": 4,
-        "removeLabelOnPush": true
-      }
-    },
-    {
-      "taskType": "trigger",
-      "capabilityId": "IssueResponder",
-      "subCapability": "PullRequestResponder",
-      "version": "1.0",
-      "id": "0aePnH83s",
-      "config": {
-        "conditions": {
-          "operator": "and",
-          "operands": [
-            {
-              "name": "prTargetsBranch",
-              "parameters": {
-                "branchName": "master"
-              }
-            },
-            {
-              "name": "isAction",
-              "parameters": {
-                "action": "merged"
-              }
-            },
-            {
-              "operator": "not",
-              "operands": [
-                {
-                  "name": "isInMilestone",
-                  "parameters": {}
-                }
-              ]
-            }
-          ]
-        },
-        "eventType": "pull_request",
-        "eventNames": [
-          "pull_request",
-          "issues",
-          "project_card"
-        ],
-        "actions": [
-          {
-            "name": "addMilestone",
-            "parameters": {
-              "milestoneName": "current-release"
-            }
-          }
-        ],
-        "taskName": "\"Current\" milestone for merged master PRs"
-      },
-      "disabled": true
-    },
     {
       "taskType": "scheduled",
       "capabilityId": "ScheduledSearch",
       "subCapability": "ScheduledSearch",
       "version": "1.1",
-      "id": "Vs-iCm9G2_R4ZwMN511fw",
       "config": {
         "frequency": [
           {
@@ -138,12 +69,6 @@
               "label": "needs-more-info"
             }
           },
-          {
-            "name": "noLabel",
-            "parameters": {
-              "label": "needs-attention"
-            }
-          },
           {
             "name": "notPartOfMilestone",
             "parameters": {
@@ -207,7 +132,6 @@
       "capabilityId": "ScheduledSearch",
       "subCapability": "ScheduledSearch",
       "version": "1.1",
-      "id": "zyeSRvg_Epub_oXWwaxj3",
       "config": {
         "frequency": [
           {
@@ -298,7 +222,7 @@
           {
             "name": "noLabel",
             "parameters": {
-              "label": "needs-attention"
+              "label": "needs-triage"
             }
           }
         ],
@@ -329,7 +253,6 @@
       "capabilityId": "IssueResponder",
       "subCapability": "IssueCommentResponder",
       "version": "1.0",
-      "id": "WBzbPosGhniXQtQgm8oMm",
       "config": {
         "conditions": {
           "operator": "and",
@@ -372,7 +295,7 @@
           {
             "name": "addLabel",
             "parameters": {
-              "label": "needs-attention"
+              "label": "needs-triage"
             }
           }
         ]
@@ -384,7 +307,6 @@
       "capabilityId": "IssueResponder",
       "subCapability": "IssueCommentResponder",
       "version": "1.0",
-      "id": "GU-AG9bRpCo1aFfE07jUZ",
       "config": {
         "conditions": {
           "operator": "and",
@@ -421,12 +343,12 @@
         "eventNames": [
           "issue_comment"
         ],
-        "taskName": "Apply needs-attention to closed stale issues that get comments",
+        "taskName": "Apply needs-triage to closed stale issues that get comments",
         "actions": [
           {
             "name": "addLabel",
             "parameters": {
-              "label": "needs-attention"
+              "label": "needs-triage"
             }
           }
         ]
@@ -437,7 +359,6 @@
       "capabilityId": "IssueResponder",
       "subCapability": "IssuesOnlyResponder",
       "version": "1.0",
-      "id": "ny85tm-H4saOfDbOgErD3",
       "config": {
         "conditions": {
           "operator": "and",
@@ -472,144 +393,11 @@
         ]
       }
     },
-    {
-      "taskType": "trigger",
-      "capabilityId": "IssueResponder",
-      "subCapability": "IssuesOnlyResponder",
-      "version": "1.0",
-      "id": "hpVo319FrpinWBwXVnK8s",
-      "config": {
-        "conditions": {
-          "operator": "and",
-          "operands": [
-            {
-              "name": "addedToMilestone",
-              "parameters": {
-                "milestoneName": "Backlog"
-              }
-            }
-          ]
-        },
-        "eventType": "issue",
-        "eventNames": [
-          "issues",
-          "project_card"
-        ],
-        "taskName": "When added to backlog, remove `needs-triage`",
-        "actions": [
-          {
-            "name": "removeLabel",
-            "parameters": {
-              "label": "needs-triage"
-            }
-          }
-        ]
-      }
-    },
-    {
-      "taskType": "scheduled",
-      "capabilityId": "ScheduledSearch",
-      "subCapability": "ScheduledSearch",
-      "version": "1.1",
-      "id": "0JHwKtkOQj0mLYc7iUySl",
-      "config": {
-        "frequency": [
-          {
-            "weekDay": 0,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 1,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 2,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 3,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 4,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 5,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 6,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          }
-        ],
-        "searchTerms": [
-          {
-            "name": "hasLabel",
-            "parameters": {
-              "label": "bot-test"
-            }
-          },
-          {
-            "name": "created",
-            "parameters": {
-              "operator": "<",
-              "days": 1
-            }
-          }
-        ],
-        "taskName": "Post comment to bot-test",
-        "actions": [
-          {
-            "name": "removeLabel",
-            "parameters": {
-              "label": "bot-test"
-            }
-          }
-        ]
-      }
-    },
     {
       "taskType": "trigger",
       "capabilityId": "IssueResponder",
       "subCapability": "IssueCommentResponder",
       "version": "1.0",
-      "id": "4T-htFPPX7DIas5-BKvde",
       "config": {
         "conditions": {
           "operator": "and",
@@ -639,7 +427,7 @@
           {
             "name": "addLabel",
             "parameters": {
-              "label": "needs-attention"
+              "label": "needs-triage"
             }
           },
           {
@@ -649,7 +437,7 @@
             }
           },
           {
-            "name": "addLabel",
+            "name": "removeLabel",
             "parameters": {
               "label": "needs-more-info"
             }
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index ea69077a58b..1cfbcf182da 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22378.6">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22371.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>b9f4ee617d6976d0937dfbad71481c685052d256</Sha>
+      <Sha>42345a12e94b3933a3cf2c464043385b55ee94bf</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.2.0-rc.146">
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>b8a61266d9a6780cb7eb9c1942695cf813fdef0a</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.3.0-3.22329.30">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.4.0-1.22404.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>29e657c0582904529bae2a87c227220e03f509cf</Sha>
+      <Sha>83ae84b2a99a0bb1cb83525db21d467b99fd0159</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22378.6">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22371.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>b9f4ee617d6976d0937dfbad71481c685052d256</Sha>
+      <Sha>42345a12e94b3933a3cf2c464043385b55ee94bf</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 29c0e5a1cb2..e645f481da7 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -42,10 +42,10 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22378.6</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22371.4</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.3.0-3.22329.30</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.4.0-1.22404.1</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.2.0-rc.146</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>6.0.0</SystemTextJsonVersion>
diff --git a/global.json b/global.json
index 80f82656174..e5558a715f9 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22378.6"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22371.4"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
index ff47a190984..d17003e254e 100644
--- a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
@@ -129,7 +129,7 @@ void TransportDelegate(INodePacket packet)
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/282")]
         public void TestShutDown()
         {
-            SendDataDelegate transportDelegate = PacketProcessor;
+            SendDataDelegate transportDelegate = new(PacketProcessor);
             var weakTransportDelegateReference = new WeakReference(transportDelegate);
             var transportSink = new BuildEventArgTransportSink(transportDelegate);
 
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index ca6d7535564..07e0760970e 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -801,6 +801,18 @@ public void TreatWarningsAsErrorWhenAllSpecified(int loggerMode, int nodeId)
             logger.Errors.ShouldHaveSingleItem();
         }
 
+        [Fact]
+        public void VerifyWarningsPromotedToErrorsAreCounted()
+        {
+            ILoggingService ls = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+            ls.WarningsAsErrors = new HashSet<string>();
+            ls.WarningsAsErrors.Add("FOR123");
+            BuildWarningEventArgs warningArgs = new("abc", "FOR123", "", 0, 0, 0, 0, "warning message", "keyword", "sender");
+            warningArgs.BuildEventContext = new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidProjectContextId, 5, 6);
+            ls.LogBuildEvent(warningArgs);
+            ls.HasBuildSubmissionLoggedErrors(1).ShouldBeTrue();
+        }
+
         /// <summary>
         /// Verifies that a warning is logged as a low importance message when it's warning code is specified.
         /// </summary>
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index cb255f7ae9b..3ff983ec264 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -1,12 +1,14 @@
 ﻿using System;
 using System.Collections.Generic;
+using System.IO;
+using System.IO.Compression;
 using System.Text;
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
-
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -138,6 +140,73 @@ public void BinaryLoggerShouldSupportFilePathExplicitParameter()
             ObjectModelHelpers.BuildProjectExpectSuccess(s_testProject, binaryLogger);
         }
 
+        [Fact]
+        public void UnusedEnvironmentVariablesDoNotAppearInBinaryLog()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("EnvVar1", "itsValue");
+                env.SetEnvironmentVariable("EnvVar2", "value2");
+                env.SetEnvironmentVariable("EnvVar3", "value3");
+                string contents = @"
+<Project DefaultTargets=""PrintEnvVar"">
+
+<PropertyGroup>
+<MyProp1>value</MyProp1>
+<MyProp2>$(EnvVar2)</MyProp2>
+</PropertyGroup>
+
+<Target Name=""PrintEnvVar"">
+<Message Text=""Environment variable EnvVar3 has value $(EnvVar3)"" Importance=""High"" />
+</Target>
+
+</Project>";
+                TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
+                TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
+                BinaryLogger logger = new();
+                logger.Parameters = _logFile;
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -bl:{logger.Parameters}", out bool success);
+                success.ShouldBeTrue();
+                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
+                success.ShouldBeTrue();
+                string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
+                text.ShouldContain("EnvVar2");
+                text.ShouldContain("value2");
+                text.ShouldContain("EnvVar3");
+                text.ShouldContain("value3");
+                text.ShouldNotContain("EnvVar1");
+                text.ShouldNotContain("itsValue");
+            }
+        }
+
+        [Fact]
+        public void BinaryLoggerShouldEmbedFilesViaTaskOutput()
+        {
+            using var buildManager = new BuildManager();
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={_logFile}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+            var testProject = @"
+<Project>
+    <Target Name=""Build"">
+        <WriteLinesToFile File=""testtaskoutputfile.txt"" Lines=""abc;def;ghi""/>
+        <CreateItem Include=""testtaskoutputfile.txt"">
+            <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
+        </CreateItem>
+    </Target>
+</Project>";
+            ObjectModelHelpers.BuildProjectExpectSuccess(testProject, binaryLogger);
+            var projectImportsZipPath = Path.ChangeExtension(_logFile, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
+        }
+
         [Fact]
         public void BinaryLoggerShouldNotThrowWhenMetadataCannotBeExpanded()
         {
@@ -205,7 +274,6 @@ public void MessagesCanBeLoggedWhenProjectsAreCached()
                 .OverallResult.ShouldBe(BuildResultCode.Success);
         }
 
-
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 4ad1bb35cac..dd5d0c8a1fc 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -24,9 +24,12 @@ public BuildEventArgsSerializationTests()
             _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
-        [Fact]
-        public void RoundtripBuildStartedEventArgs()
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripBuildStartedEventArgs(bool serializeAllEnvironmentVariables)
         {
+            Traits.LogAllEnvironmentVariables = serializeAllEnvironmentVariables;
             var args = new BuildStartedEventArgs(
                 "Message",
                 "HelpKeyword",
@@ -41,13 +44,15 @@ public void RoundtripBuildStartedEventArgs()
                 null,
                 new Dictionary<string, string>
                 {
-                    { "SampleName", "SampleValue" }
+                { "SampleName", "SampleValue" }
                 });
             Roundtrip(args,
-                e => TranslationHelpers.ToString(e.BuildEnvironment),
+                e => serializeAllEnvironmentVariables ? TranslationHelpers.ToString(e.BuildEnvironment) : null,
                 e => e.HelpKeyword,
                 e => e.ThreadId.ToString(),
                 e => e.SenderName);
+
+            Traits.LogAllEnvironmentVariables = false;
         }
 
         [Fact]
@@ -173,6 +178,17 @@ public void RoundtripTaskStartedEventArgs()
                 e => e.ColumnNumber.ToString());
         }
 
+        [Fact]
+        public void RoundtripEnvironmentVariableReadEventArgs()
+        {
+            EnvironmentVariableReadEventArgs args = new("VarName", "VarValue");
+            args.BuildEventContext = new BuildEventContext(4, 5, 6, 7);
+            Roundtrip(args,
+                e => e.Message,
+                e => e.EnvironmentVariableName,
+                e => e.BuildEventContext.ToString());
+        }
+
         [Fact]
         public void RoundtripTaskFinishedEventArgs()
         {
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 997e40b8c83..51d649107b5 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4522,7 +4522,7 @@ public void VerifyMSBuildLogsAMessageWhenLocalPropertyCannotOverrideValueOfGloba
         [Fact]
         public void VerifyPropertyTrackingLoggingDefault()
         {
-            // Having nothing defined should default to nothing being logged.
+            // Having just environment variables defined should default to nothing being logged except one environment variable read.
             this.VerifyPropertyTrackingLoggingScenario(
                 null,
                 logger =>
@@ -4535,7 +4535,9 @@ public void VerifyPropertyTrackingLoggingDefault()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4564,7 +4566,9 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4593,7 +4597,9 @@ public void VerifyPropertyTrackingLoggingNone()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4622,7 +4628,9 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4706,7 +4714,9 @@ public void VerifyPropertyTrackingLoggingUninitializedPropertyRead()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 73732f6d3ba..56126bfbffa 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -33,8 +33,8 @@ public ProjectCacheTests(ITestOutputHelper output)
             _output = output;
             _env = TestEnvironment.Create(output);
 
-            BuildManager.ProjectCacheItems.ShouldBeEmpty();
-            _env.WithInvariant(new CustomConditionInvariant(() => BuildManager.ProjectCacheItems.IsEmpty));
+            BuildManager.ProjectCacheDescriptors.ShouldBeEmpty();
+            _env.WithInvariant(new CustomConditionInvariant(() => BuildManager.ProjectCacheDescriptors.IsEmpty));
         }
 
         public void Dispose()
@@ -461,10 +461,7 @@ public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse t
             // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
             buildParameters = new BuildParameters(buildParameters, resetEnvironment: true)
             {
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    mockCache,
-                    null,
-                    graph)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache)
             };
 
             MockLogger logger;
@@ -477,8 +474,6 @@ public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse t
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Static graph based");
-
             AssertCacheBuild(graph, testData, mockCache, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
@@ -489,10 +484,7 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
             var graph = testData.CreateGraph(_env);
             var mockCache = new InstanceMockCache(testData);
 
-            var projectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                mockCache,
-                null,
-                graph);
+            var projectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache);
 
             // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
             buildParameters = new BuildParameters(buildParameters, resetEnvironment: true)
@@ -516,7 +508,6 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
                 }
             }
 
-            logger.FullLog.ShouldContain("Static graph based");
 
             AssertCacheBuild(graph, testData, mockCache, logger, nodesToBuildResults, targets: null);
         }
@@ -549,28 +540,6 @@ public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
             logger.FullLog.ShouldContain($"EntryPoint: {graph.GraphRoots.First().ProjectReferences.First().ProjectInstance.FullPath}");
         }
 
-        [Fact]
-        public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
-        {
-            var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]?>
-                {
-                    {1, Array.Empty<int>()}
-                },
-                extraContentPerProjectNumber: new Dictionary<int, string>()
-                {
-                    {1, $"<PropertyGroup> <ProjectDependency>{Guid.NewGuid()}</ProjectDependency> </PropertyGroup>"}
-                });
-
-            (_, _, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) = BuildGraphVsScenario(testData, assertBuildResults: false);
-
-            nodesToBuildResults.ShouldHaveSingleItem();
-
-            var buildResult = nodesToBuildResults.First().Value;
-            buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
-            buildResult.Exception.Message.ShouldContain("Project cache service does not support solution only dependencies when running under Visual Studio.");
-        }
-
         private (MockLogger logger, ProjectGraph projectGraph, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) BuildGraphVsScenario(
             GraphCacheResponse testData,
             BuildParameters? buildParameters = null,
@@ -598,14 +567,14 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
                     ? new BuildParameters()
                     : new BuildParameters(buildParameters, resetEnvironment: true);
 
-                BuildManager.ProjectCacheItems.ShouldBeEmpty();
+                BuildManager.ProjectCacheDescriptors.ShouldBeEmpty();
 
                 graph = testData.CreateGraph(_env);
 
-                BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
+                BuildManager.ProjectCacheDescriptors.ShouldHaveSingleItem();
 
                 // VS sets this global property on every project it builds.
-                var solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
+                string solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
 
                 using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
                 {
@@ -613,15 +582,13 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
 
                     foreach (var node in graph.ProjectNodesTopologicallySorted)
                     {
-                        var buildResult = buildSession.BuildProjectFile(
+                        BuildResult buildResult = buildSession.BuildProjectFile(
                             node.ProjectInstance.FullPath,
                             globalProperties:
                                 new Dictionary<string, string>
                                 {
-                                { SolutionProjectGenerator.SolutionPathPropertyName, graph.GraphRoots.First().ProjectInstance.FullPath },
-                                { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty },
-                                { PropertyNames.InnerBuildProperty, "TheInnerBuildProperty"},
-                                { "TheInnerBuildProperty", "FooBar"},
+                                    { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty },
+                                    { "TargetFramework", "net472"},
                                 });
 
                         if (assertBuildResults)
@@ -635,8 +602,6 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
 
                 if (assertBuildResults)
                 {
-                    logger.FullLog.ShouldContain("Visual Studio Workaround based");
-
                     foreach (var node in graph.ProjectNodes)
                     {
                         var projectPath = node.ProjectInstance.FullPath;
@@ -647,16 +612,15 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
                         logger.FullLog.ShouldContain($"Configuration:{projectName}Debug");
                         logger.FullLog.ShouldContain($"Platform:{projectName}x64");
 
-                        // Ensure MSBuild removes the inner build property if present.
-                        logger.FullLog.ShouldContain($"{PropertyNames.InnerBuildProperty}:TheInnerBuildProperty");
-                        logger.FullLog.ShouldNotContain("TheInnerBuildProperty:FooBar");
+                        // Ensure MSBuild removes the target framework if present.
+                        logger.FullLog.ShouldNotContain("TargetFramework:net472");
                     }
                 }
             }
             finally
             {
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
-                BuildManager.ProjectCacheItems.Clear();
+                BuildManager.ProjectCacheDescriptors.Clear();
             }
 
             return (logger, graph, nodesToBuildResults);
@@ -696,8 +660,6 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
         {
             var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
 
-            var designTimeBuildProperty = $"<PropertyGroup> <{DesignTimeProperties.DesignTimeBuild}>true</{DesignTimeProperties.DesignTimeBuild}> </PropertyGroup>";
-
             // Use a few references to stress test the design time build workaround logic.
             var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount()).ToArray();
 
@@ -705,9 +667,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                 graphEdges: new Dictionary<int, int[]?>
                 {
                     {1, referenceNumbers}
-                },
-                nonCacheMissResults: null,
-                extraContentPerProjectNumber: referenceNumbers.ToDictionary(r => r, _ => designTimeBuildProperty));
+                });
 
             try
             {
@@ -722,7 +682,11 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                 var graph = testData.CreateGraph(_env);
 
                 var rootNode = graph.GraphRoots.First();
-                var globalProperties = new Dictionary<string, string> { { "SolutionPath", rootNode.ProjectInstance.FullPath } };
+
+                var globalProperties = new Dictionary<string, string>
+                {
+                    { DesignTimeProperties.DesignTimeBuild, "true" },
+                };
 
                 MockLogger logger;
                 using (var buildSession = new Helpers.BuildManagerSession(_env))
@@ -731,9 +695,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
 
                     // Build references in parallel.
                     var referenceBuildTasks = rootNode.ProjectReferences.Select(
-                        r => buildSession.BuildProjectFileAsync(
-                            r.ProjectInstance.FullPath,
-                            globalProperties: globalProperties));
+                        r => buildSession.BuildProjectFileAsync(r.ProjectInstance.FullPath, globalProperties: globalProperties));
 
                     foreach (var task in referenceBuildTasks)
                     {
@@ -746,23 +708,16 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                         .ShouldHaveSucceeded();
                 }
 
-                logger.FullLog.ShouldContain("Visual Studio Workaround based");
-
-                // Design time builds should not initialize the plugin.
-                logger.FullLog.ShouldNotContain("Running project cache with Visual Studio workaround");
-
-                // Cache doesn't get initialized and queried.
+                // Cache doesn't get initialized, queried, or disposed.
                 logger.FullLog.ShouldNotContain("BeginBuildAsync");
                 logger.FullLog.ShouldNotContain("GetCacheResultAsync for");
                 logger.FullLog.ShouldNotContain("Querying project cache for project");
-
-                // Cache does get disposed.
-                StringShouldContainSubstring(logger.FullLog, "EndBuildAsync", 1);
+                logger.FullLog.ShouldNotContain("EndBuildAsync");
             }
             finally
             {
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
-                BuildManager.ProjectCacheItems.Clear();
+                BuildManager.ProjectCacheDescriptors.Clear();
             }
         }
 
@@ -788,10 +743,7 @@ public void RunningProxyBuildsOnOutOfProcNodesShouldIssueWarning(bool disableInp
             var buildParameters = new BuildParameters
             {
                 MaxNodeCount = Environment.ProcessorCount,
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    mockCache,
-                    null,
-                    graph)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache)
             };
 
             if (disableInprocNodeViaEnvironmentVariable)
@@ -813,8 +765,6 @@ public void RunningProxyBuildsOnOutOfProcNodesShouldIssueWarning(bool disableInp
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Static graph based");
-
             logger.AssertMessageCount("MSB4274", 1);
         }
 
@@ -828,18 +778,12 @@ private void AssertCacheBuild(
         {
             if (instanceMockCache != null)
             {
-                mockLogger.FullLog.ShouldContain("Instance based");
-                mockLogger.FullLog.ShouldNotContain("Assembly path based");
-
                 instanceMockCache.BeginBuildCalled.ShouldBeTrue();
                 instanceMockCache.Requests.Count.ShouldBe(graph.ProjectNodes.Count);
                 instanceMockCache.EndBuildCalled.ShouldBeTrue();
             }
             else
             {
-                mockLogger.FullLog.ShouldContain("Assembly path based");
-                mockLogger.FullLog.ShouldNotContain("Instance based");
-
                 mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: BeginBuildAsync");
                 Regex.Matches(mockLogger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for").Count.ShouldBe(graph.ProjectNodes.Count);
                 mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: EndBuildAsync");
@@ -941,10 +885,7 @@ public void CacheShouldNotGetQueriedForNestedBuildRequests(BuildParameters build
                     </Project>".Cleanup());
 
             var mockCache = new InstanceMockCache();
-            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                mockCache,
-                new[] {new ProjectGraphEntryPoint(project1.Path)},
-                null);
+            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache);
 
             MockLogger logger;
             using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
@@ -976,10 +917,7 @@ public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
 
             var buildParameters = new BuildParameters
             {
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
-                    SamplePluginAssemblyPath.Value,
-                    graph.EntryPointNodes.Select(n => new ProjectGraphEntryPoint(n.ProjectInstance.FullPath)).ToArray(),
-                    null)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(SamplePluginAssemblyPath.Value)
             };
 
             MockLogger logger;
@@ -992,7 +930,7 @@ public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Explicit entry-point based");
+            logger.FullLog.ShouldContain($"Loading the following project cache plugin: {AssemblyMockCache}");
 
             AssertCacheBuild(graph, testData, null, logger, graphResult.ResultsByNode, targets: "Build");
         }
@@ -1019,8 +957,6 @@ public void GraphBuildCanDiscoverAndLoadPluginFromAssembly()
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Static graph based");
-
             AssertCacheBuild(graph, testData, null, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
@@ -1061,7 +997,7 @@ public void BuildFailsWhenCacheBuildResultIsWrong()
 
             var buildParameters = new BuildParameters
             {
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache, null, graph)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache)
             };
 
             MockLogger logger;
@@ -1083,8 +1019,9 @@ public void BuildFailsWhenCacheBuildResultIsWrong()
         }
 
         [Fact]
-        public void GraphBuildErrorsIfMultiplePluginsAreFound()
+        public void MultiplePlugins()
         {
+            // One from the project, one from BuildParameters.
             var graph = Helpers.CreateProjectGraph(
                 _env,
                 new Dictionary<int, int[]?>
@@ -1093,23 +1030,29 @@ public void GraphBuildErrorsIfMultiplePluginsAreFound()
                 },
                 extraContentForAllNodes: @$"
 <ItemGroup>
-   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
+   <{ItemTypeNames.ProjectCachePlugin} Include='{SamplePluginAssemblyPath.Value}' />
 </ItemGroup>
 ");
+            var mockCache = new InstanceMockCache();
+
+            var buildParameters =  new BuildParameters
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache),
+            };
 
             MockLogger logger;
             GraphBuildResult graphResult;
-            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
             {
                 logger = buildSession.Logger;
                 graphResult = buildSession.BuildGraph(graph);
             }
             
-            graphResult.ShouldHaveFailed("A single project cache plugin must be specified but multiple where found:");
+            graphResult.ShouldHaveSucceeded();
         }
 
         [Fact]
-        public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
+        public void NotAllNodesDefineAPlugin()
         {
             var graph = Helpers.CreateProjectGraph(
                 _env,
@@ -1123,7 +1066,7 @@ public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
                         2,
                         @$"
 <ItemGroup>
-   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
+   <{ItemTypeNames.ProjectCachePlugin} Include='{SamplePluginAssemblyPath.Value}' />
 </ItemGroup>
 "
                     }
@@ -1136,8 +1079,8 @@ public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
                 logger = buildSession.Logger;
                 graphResult = buildSession.BuildGraph(graph);
             }
-            
-            graphResult.ShouldHaveFailed("When any static graph node defines a project cache, all nodes must define the same project cache.");
+
+            graphResult.ShouldHaveSucceeded();
         }
 
         public static IEnumerable<object[]> CacheExceptionLocationsTestData
@@ -1185,10 +1128,7 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorL
                     new BuildParameters
                     {
                         UseSynchronousLogging = true,
-                        ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
-                            SamplePluginAssemblyPath.Value,
-                            new[] {new ProjectGraphEntryPoint(project.Path)},
-                            null)
+                        ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(SamplePluginAssemblyPath.Value)
                     });
 
                 logger = buildSession.Logger;
@@ -1285,6 +1225,8 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorL
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocations errorLocations, ErrorKind errorKind)
         {
+            const ErrorLocations exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync;
+
             SetEnvironmentForErrorLocations(errorLocations, errorKind);
 
             var graph = Helpers.CreateProjectGraph(
@@ -1320,36 +1262,51 @@ public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocati
             {
                 buildResult = buildSession.BuildGraph(graph);
 
-                logger.FullLog.ShouldContain("Loading the following project cache plugin:");
-
-                // Static graph build initializes and tears down the cache plugin so all cache plugin exceptions should end up in the GraphBuildResult
-                buildResult.ShouldHaveFailed();
-
-                buildResult.Exception.ShouldBeOfType<ProjectCacheException>();
+                if (!errorLocations.HasFlag(ErrorLocations.Constructor))
+                {
+                    logger.FullLog.ShouldContain("Loading the following project cache plugin:");
+                }
 
-                if (errorKind == ErrorKind.Exception)
+                // EndBuildAsync isn't until the build manager is shut down, so the build result itself is successful if that's the only error.
+                if (errorLocations == ErrorLocations.EndBuildAsync)
                 {
-                    buildResult.Exception.InnerException!.ShouldNotBeNull();
-                    buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from");
+                    buildResult.ShouldHaveSucceeded();
                 }
+                else
+                {
+                    buildResult.ShouldHaveFailed();
 
-                logger.FullLog.ShouldNotContain("Cache plugin exception from");
+                    buildResult.Exception.ShouldBeOfType<ProjectCacheException>();
 
-                if (errorKind == ErrorKind.LoggedError)
-                {
-                    logger.FullLog.ShouldContain("Cache plugin logged error from");
+                    if (errorKind == ErrorKind.Exception)
+                    {
+                        buildResult.Exception.InnerException!.ShouldNotBeNull();
+                        buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from");
+                    }
+
+                    logger.FullLog.ShouldNotContain("Cache plugin exception from");
+
+                    if (errorKind == ErrorKind.LoggedError)
+                    {
+                        logger.FullLog.ShouldContain("Cache plugin logged error from");
+                    }
                 }
             }
             finally
             {
-                // Since all plugin exceptions during a graph build end up in the GraphBuildResult, they should not get rethrown by BM.EndBuild
-                Should.NotThrow(() => buildSession.Dispose());
+                if (errorLocations.HasFlag(ErrorLocations.EndBuildAsync)
+                    && (exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & errorLocations) == 0)
+                {
+                    Should.Throw<ProjectCacheException>(() => buildSession.Dispose());
+                }
+                else
+                {
+                    Should.NotThrow(() => buildSession.Dispose());
+                }
             }
 
             logger.BuildFinishedEvents.First().Succeeded.ShouldBeFalse();
 
-            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync;
-
             if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & errorLocations) != 0)
             {
                 logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: GetCacheResultAsync for");
@@ -1390,19 +1347,12 @@ public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
                 UseSynchronousLogging = true
             };
 
-            MockLogger logger;
-            GraphBuildResult graphResult;
-            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
-            {
-                logger = buildSession.Logger;
-                graphResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
-            }
+            var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            GraphBuildResult graphResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
 
-            graphResult.ShouldHaveFailed();
-            graphResult.Exception.InnerException!.ShouldNotBeNull();
-            graphResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+            Should.Throw<ProjectCacheException>(() => buildSession.Dispose()).InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
 
-            StringShouldContainSubstring(logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync", expectedOccurrences: 1);
+            StringShouldContainSubstring(buildSession.Logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync", expectedOccurrences: 1);
         }
 
         [Theory]
@@ -1449,10 +1399,7 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
             var buildParameters = new BuildParameters()
             {
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    cache,
-                    entryPoints: null,
-                    graph),
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(cache),
                 UseSynchronousLogging = useSynchronousLogging,
                 DisableInProcNode = disableInprocNode
             };
@@ -1504,7 +1451,7 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
-                BuildManager.ProjectCacheItems.ShouldBeEmpty();
+                BuildManager.ProjectCacheDescriptors.ShouldBeEmpty();
 
                 var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount() * 2).ToArray();
 
@@ -1518,11 +1465,9 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
 
                 var graph = testData.CreateGraph(_env);
 
-                // Even though the assembly cache is discovered, we'll be overriding it with a descriptor based cache.
-                BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
+                BuildManager.ProjectCacheDescriptors.ShouldHaveSingleItem();
 
-                var solutionConfigurationGlobalProperty =
-                    CreateSolutionConfigurationProperty(graph.ProjectNodes);
+                var solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
 
                 var buildParameters = new BuildParameters
                 {
@@ -1539,13 +1484,12 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
 
                     foreach (var node in graph.ProjectNodes.Where(n => referenceNumbers.Contains(GetProjectNumber(n))))
                     {
-                        var buildResultTask = buildSession.BuildProjectFileAsync(
+                        Task<BuildResult> buildResultTask = buildSession.BuildProjectFileAsync(
                             node.ProjectInstance.FullPath,
                             globalProperties:
                             new Dictionary<string, string>
                             {
-                            { SolutionProjectGenerator.SolutionPathPropertyName, graph.GraphRoots.First().ProjectInstance.FullPath },
-                            { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty }
+                                { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty }
                             });
 
                         buildResultTasks.Add(buildResultTask);
@@ -1556,21 +1500,15 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                         buildResultTask.Result.ShouldHaveSucceeded();
                     }
 
-                    buildSession.BuildProjectFile(
-                            graph.GraphRoots.First().ProjectInstance.FullPath,
-                            globalProperties:
-                            new Dictionary<string, string> { { "SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath } })
-                        .ShouldHaveSucceeded();
+                    buildSession.BuildProjectFile(graph.GraphRoots.First().ProjectInstance.FullPath).ShouldHaveSucceeded();
                 }
 
                 StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", graph.ProjectNodes.Count);
-
-                logger.FullLog.ShouldContain("Visual Studio Workaround based");
             }
             finally
             {
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
-                BuildManager.ProjectCacheItems.Clear();
+                BuildManager.ProjectCacheDescriptors.Clear();
             }
         }
 
@@ -1595,10 +1533,7 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
             var buildParameters = new BuildParameters()
             {
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    cache,
-                    entryPoints: null,
-                    graph),
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(cache),
                 UseSynchronousLogging = useSynchronousLogging,
                 DisableInProcNode = disableInprocNode
             };
@@ -1676,9 +1611,7 @@ public void ProxyCacheHitsOnPreviousCacheMissesShouldWork()
                                         new ProxyTargets(new Dictionary<string, string> {{proxyTarget, cacheHitTarget}})));
                             }
                         }
-                    },
-                    projectPaths.Select(p => new ProjectGraphEntryPoint(p)).ToArray(),
-                    projectGraph: null),
+                    }),
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount()
             };
 
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index c6f7af84e57..6159f3af2c1 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -22,6 +22,7 @@
 using System.Collections.Generic;
 using System.IO;
 using Xunit.Abstractions;
+using Shouldly;
 
 #nullable disable
 
@@ -80,55 +81,41 @@ public UtilitiesTestReadOnlyLoad()
         [Fact]
         public void CommentsInPreprocessing()
         {
-            Microsoft.Build.Construction.XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
+            using TestEnvironment env = TestEnvironment.Create();
+            XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
 
-            string input = FileUtilities.GetTemporaryFile();
-            string output = FileUtilities.GetTemporaryFile();
+            TransientTestFile inputFile = env.CreateFile("tempInput.tmp", ObjectModelHelpers.CleanupFileContents(@"
+<Project DefaultTargets='Build'>
+<Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets'/>
+</Project>"));
+            TransientTestFile outputFile = env.CreateFile("tempOutput.tmp");
 
-            string _initialLoadFilesWriteable = Environment.GetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE");
-            try
-            {
-                Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-<Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
-  <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets'/>
-</Project>");
-                File.WriteAllText(input, content);
+            env.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
 
 #if FEATURE_GET_COMMANDLINE
-                Assert.Equal(MSBuildApp.ExitType.Success, MSBuildApp.Execute(@"c:\bin\msbuild.exe """ + input +
-                    (NativeMethodsShared.IsUnixLike ? @""" -pp:""" : @""" /pp:""") + output + @""""));
+            MSBuildApp.Execute(@"c:\bin\msbuild.exe """ + inputFile.Path +
+                (NativeMethodsShared.IsUnixLike ? @""" -pp:""" : @""" /pp:""") + outputFile.Path + @"""")
+                .ShouldBe(MSBuildApp.ExitType.Success);
 #else
-                Assert.Equal(
-                    MSBuildApp.ExitType.Success,
-                    MSBuildApp.Execute(
-                        new[] { @"c:\bin\msbuild.exe", '"' + input + '"',
-                    '"' + (NativeMethodsShared.IsUnixLike ? "-pp:" : "/pp:") + output + '"'}));
+            Assert.Equal(
+                MSBuildApp.ExitType.Success,
+                MSBuildApp.Execute(
+                    new[] { @"c:\bin\msbuild.exe", '"' + inputFile.Path + '"',
+                '"' + (NativeMethodsShared.IsUnixLike ? "-pp:" : "/pp:") + outputFile.Path + '"'}));
 #endif
 
-                bool foundDoNotModify = false;
-                foreach (string line in File.ReadLines(output))
+            bool foundDoNotModify = false;
+            foreach (string line in File.ReadLines(outputFile.Path))
+            {
+                line.ShouldNotContain("<!---->", "This is what it will look like if we're loading read/only");
+
+                if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
                 {
-                    if (line.Contains("<!---->")) // This is what it will look like if we're loading read/only
-                    {
-                        Assert.True(false);
-                    }
-
-                    if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
-                    {
-                        foundDoNotModify = true;
-                    }
+                    foundDoNotModify = true;
                 }
-
-                Assert.True(foundDoNotModify);
-            }
-            finally
-            {
-                File.Delete(input);
-                File.Delete(output);
-                Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", _initialLoadFilesWriteable);
             }
+
+            foundDoNotModify.ShouldBeTrue();
         }
 
         [Fact]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 606d1008930..cee9a2e7055 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -20,10 +20,10 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
@@ -46,8 +46,10 @@ namespace Microsoft.Build.Execution
     [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Refactoring at the end of Beta1 is not appropriate.")]
     public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
     {
-        // TODO: Remove this when VS gets updated to setup project cache plugins.
-        internal static ConcurrentDictionary<string, ProjectCacheItem> ProjectCacheItems { get; } = new ConcurrentDictionary<string, ProjectCacheItem>();
+        // TODO: Figure out a more elegant way to do this.
+        //       The rationale for this is that we can detect during design-time builds in the Evaluator (which populates this) that the project cache will be used so that we don't
+        //       need to evaluate the project at build time just to figure that out, which would regress perf for scenarios which don't use the project cache.
+        internal static ConcurrentDictionary<ProjectCacheDescriptor, ProjectCacheDescriptor> ProjectCacheDescriptors { get; } = new (ProjectCacheDescriptorEqualityComparer.Instance);
 
         /// <summary>
         /// The object used for thread-safe synchronization of static members.
@@ -131,6 +133,11 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private bool _shuttingDown;
 
+        /// <summary>
+        /// CancellationTokenSource to use for async operations. This will be cancelled when we are shutting down to cancel any async operations.
+        /// </summary>
+        private CancellationTokenSource _executionCancellationTokenSource;
+
         /// <summary>
         /// The current state of the BuildManager.
         /// </summary>
@@ -234,11 +241,6 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private ActionBlock<Action> _workQueue;
 
-        /// <summary>
-        /// A cancellation token source used to cancel graph build scheduling
-        /// </summary>
-        private CancellationTokenSource _graphSchedulingCancellationSource;
-
         /// <summary>
         /// Flag indicating we have disposed.
         /// </summary>
@@ -250,7 +252,10 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         private DateTime _instantiationTimeUtc;
 
         private IEnumerable<DeferredBuildMessage> _deferredBuildMessages;
-        private Task<ProjectCacheService> _projectCacheService;
+
+        private ProjectCacheService _projectCacheService;
+
+        private bool _hasProjectCacheServiceInitializedVsScenario;
 
 #if DEBUG
         /// <summary>
@@ -483,6 +488,8 @@ public void BeginBuild(BuildParameters parameters)
                     Strings.EnableDiagnostics();
                 }
 
+                _executionCancellationTokenSource = new CancellationTokenSource();
+
                 _overallBuildSuccess = true;
 
                 // Clone off the build parameters.
@@ -510,11 +517,10 @@ public void BeginBuild(BuildParameters parameters)
 
                 InitializeCaches();
 
-                if (_buildParameters.ProjectCacheDescriptor != null)
-                {
-                    // TODO: Implement cancellation.
-                    InitializeProjectCacheService(_buildParameters.ProjectCacheDescriptor, CancellationToken.None);
-                }
+                _projectCacheService = new ProjectCacheService(
+                    this,
+                    loggingService,
+                    _buildParameters.ProjectCacheDescriptor);
 
                 _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
                 _scheduler = ((IBuildComponentHost)this).GetComponent(BuildComponentType.Scheduler) as IScheduler;
@@ -666,26 +672,6 @@ private static void AttachDebugger()
             }
         }
 
-        private void InitializeProjectCacheService(
-            ProjectCacheDescriptor pluginDescriptor,
-            CancellationToken cancellationToken)
-        {
-            Debug.Assert(Monitor.IsEntered(_syncLock));
-
-            if (_projectCacheService != null)
-            {
-                ErrorUtilities.ThrowInternalError("Only one project cache plugin may be set on the BuildManager during a begin / end build session");
-            }
-
-            LogMessage(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("LoadingProjectCachePlugin", pluginDescriptor.GetDetailedDescription()));
-
-            _projectCacheService = ProjectCacheService.FromDescriptorAsync(
-                pluginDescriptor,
-                this,
-                ((IBuildComponentHost) this).LoggingService,
-                cancellationToken);
-        }
-
         /// <summary>
         /// Cancels all outstanding submissions asynchronously.
         /// </summary>
@@ -917,10 +903,7 @@ public void EndBuild()
                     _workQueue.Completion.Wait();
                 }
 
-                // Stop the graph scheduling thread(s)
-                _graphSchedulingCancellationSource?.Cancel();
-
-                var projectCacheShutdown = _projectCacheService?.Result.ShutDown();
+                Task projectCacheDispose = _projectCacheService.DisposeAsync().AsTask();
 
                 ErrorUtilities.VerifyThrow(_buildSubmissions.Count == 0 && _graphBuildSubmissions.Count == 0, "All submissions not yet complete.");
                 ErrorUtilities.VerifyThrow(_activeNodes.Count == 0, "All nodes not yet shut down.");
@@ -930,7 +913,7 @@ public void EndBuild()
                     SerializeCaches();
                 }
 
-                projectCacheShutdown?.Wait();
+                projectCacheDispose.Wait();
 
 #if DEBUG
                 if (_projectStartedEvents.Count != 0)
@@ -1109,11 +1092,9 @@ public GraphBuildResult Build(BuildParameters parameters, GraphBuildRequestData
         /// </summary>
         public void ShutdownAllNodes()
         {
-            if (_nodeManager == null)
-            {
-                _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;
-            }
+            MSBuildClient.ShutdownServer(CancellationToken.None);
 
+            _nodeManager ??= (INodeManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager);
             _nodeManager.ShutdownAllNodes();
         }
 
@@ -1246,7 +1227,20 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                     shuttingDown = _shuttingDown;
                     if (!shuttingDown)
                     {
-                        if (ProjectCacheIsPresent())
+                        if (!_hasProjectCacheServiceInitializedVsScenario
+                            && BuildEnvironmentHelper.Instance.RunningInVisualStudio
+                            && !ProjectCacheDescriptors.IsEmpty)
+                        {
+                            // Only initialize once as it should be the same for all projects.
+                            _hasProjectCacheServiceInitializedVsScenario = true;
+
+                            _projectCacheService.InitializePluginsForVsScenario(
+                                ProjectCacheDescriptors.Values,
+                                resolvedConfiguration,
+                                _executionCancellationTokenSource.Token);
+                        }
+
+                        if (_projectCacheService.ShouldUseCache(resolvedConfiguration))
                         {
                             IssueCacheRequestForBuildSubmission(new CacheRequest(submission, resolvedConfiguration));
                         }
@@ -1258,11 +1252,6 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                     }
                 }
             }
-            catch (ProjectCacheException ex)
-            {
-                ErrorUtilities.VerifyThrow(resolvedConfiguration is not null, "Cannot call project cache without having BuildRequestConfiguration");
-                CompleteSubmissionWithException(submission, resolvedConfiguration, ex);
-            }
             catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
             {
                 if (resolvedConfiguration is not null)
@@ -1286,28 +1275,6 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
             }
         }
 
-        bool ProjectCacheIsPresent()
-        {
-            // TODO: remove after we change VS to set the cache descriptor via build parameters.
-            // TODO: no need to access the service when there's no design time builds.
-            var projectCacheService = GetProjectCacheService();
-
-            if (projectCacheService != null && projectCacheService.DesignTimeBuildsDetected)
-            {
-                return false;
-            }
-
-            return
-                projectCacheService != null ||
-                _buildParameters.ProjectCacheDescriptor != null ||
-                ProjectCachePresentViaVisualStudioWorkaround();
-        }
-
-        private static bool ProjectCachePresentViaVisualStudioWorkaround()
-        {
-            return BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Any();
-        }
-
         // Cache requests on configuration N do not block future build submissions depending on configuration N.
         // It is assumed that the higher level build orchestrator (static graph scheduler, VS, quickbuild) submits a
         // project build request only when its references have finished building.
@@ -1319,17 +1286,7 @@ private void IssueCacheRequestForBuildSubmission(CacheRequest cacheRequest)
             {
                 try
                 {
-                    var projectCacheService = GetProjectCacheService();
-
-                    ErrorUtilities.VerifyThrow(
-                        projectCacheService != null,
-                        "This method should not get called if there's no project cache.");
-
-                    ErrorUtilities.VerifyThrow(
-                        !projectCacheService.DesignTimeBuildsDetected,
-                        "This method should not get called if design time builds are detected.");
-
-                    projectCacheService.PostCacheRequest(cacheRequest);
+                    _projectCacheService.PostCacheRequest(cacheRequest, _executionCancellationTokenSource.Token);
                 }
                 catch (Exception e)
                 {
@@ -1338,57 +1295,6 @@ private void IssueCacheRequestForBuildSubmission(CacheRequest cacheRequest)
             });
         }
 
-        private ProjectCacheService GetProjectCacheService()
-        {
-            // TODO: remove after we change VS to set the cache descriptor via build parameters.
-            AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio();
-
-            try
-            {
-                return _projectCacheService?.Result;
-            }
-            catch(Exception ex)
-            {
-                if (ex is AggregateException ae && ae.InnerExceptions.Count == 1)
-                {
-                    ex = ae.InnerExceptions.First();
-                }
-
-                // These are exceptions thrown during project cache startup (assembly load issues or cache BeginBuild exceptions).
-                // Set to null so that EndBuild does not try to shut it down and thus rethrow the exception.
-                Interlocked.Exchange(ref _projectCacheService, null);
-                throw ex;
-            }
-        }
-
-        private void AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio()
-        {
-            if (BuildEnvironmentHelper.Instance.RunningInVisualStudio &&
-                ProjectCacheItems.Any() &&
-                _projectCacheService == null &&
-                _buildParameters.ProjectCacheDescriptor == null)
-            {
-                lock (_syncLock)
-                {
-                    if (_projectCacheService != null)
-                    {
-                        return;
-                    }
-
-                    if (ProjectCacheItems.Count != 1)
-                    {
-                        ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
-                            "OnlyOneCachePluginMustBeSpecified",
-                            string.Join("; ", ProjectCacheItems.Values.Select(c => c.PluginPath)));
-                    }
-
-                    var projectCacheItem = ProjectCacheItems.First().Value;
-
-                    InitializeProjectCacheService(ProjectCacheDescriptor.FromVisualStudioWorkaround(projectCacheItem), CancellationToken.None);
-                }
-            }
-        }
-
         /// <summary>
         /// This method adds the graph build request in the specified submission to the set of requests being handled by the scheduler.
         /// </summary>
@@ -1411,12 +1317,6 @@ internal void ExecuteSubmission(GraphBuildSubmission submission)
                         return;
                     }
 
-                    // Lazily create a cancellation token source to be used for all graph scheduling tasks running from this build manager.
-                    if (_graphSchedulingCancellationSource == null)
-                    {
-                        _graphSchedulingCancellationSource = new CancellationTokenSource();
-                    }
-
                     // Do the scheduling in a separate thread to unblock the calling thread
                     Task.Factory.StartNew(
                         () =>
@@ -1430,7 +1330,7 @@ internal void ExecuteSubmission(GraphBuildSubmission submission)
                                 HandleSubmissionException(submission, ex);
                             }
                         },
-                        _graphSchedulingCancellationSource.Token,
+                        _executionCancellationTokenSource.Token,
                         TaskCreationOptions.LongRunning,
                         TaskScheduler.Default);
                 }
@@ -1957,13 +1857,13 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
 
             if (submission.BuildRequestData.GraphBuildOptions.Build)
             {
-                var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
+                // Kick off project cache initialization frontloading
+                Task.Run(() => _projectCacheService.InitializePluginsForGraph(projectGraph, _executionCancellationTokenSource.Token));
+
                 var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
 
                 DumpGraph(projectGraph, targetListTask);
 
-                using DisposablePluginService cacheService = cacheServiceTask.Result;
-
                 resultsPerNode = BuildGraph(projectGraph, targetListTask, submission.BuildRequestData);
             }
             else
@@ -2079,104 +1979,6 @@ GraphBuildRequestData graphBuildRequestData
             return resultsPerNode;
         }
 
-        private DisposablePluginService SearchAndInitializeProjectCachePluginFromGraph(ProjectGraph projectGraph)
-        {
-            // TODO: Consider allowing parallel graph submissions, each with its own separate cache plugin. Right now the second graph submission with a cache will fail.
-
-            if (_buildParameters.ProjectCacheDescriptor != null)
-            {
-                // Build parameter specified project cache takes precedence.
-                return new DisposablePluginService(null);
-            }
-
-            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(
-                n => n,
-                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)
-                    .Select(
-                        i =>
-                        {
-                            var metadataDictionary = i.Metadata.ToDictionary(
-                                m => ((IKeyed) m).Key,
-                                m => ((IValued) m).EscapedValue);
-
-                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);
-
-                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);
-
-                            return projectCacheItem;
-                        })
-                    .ToArray());
-
-            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();
-
-            if (cacheItems.Count == 0)
-            {
-                return new DisposablePluginService(null);
-            }
-
-            if (cacheItems.Count != 1)
-            {
-                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
-                    "OnlyOneCachePluginMustBeSpecified",
-                    string.Join("; ", cacheItems.Select(ci => ci.PluginPath)));
-            }
-
-            var nodesWithoutCacheItems = nodeToCacheItems.Where(kvp => kvp.Value.Length == 0).ToArray();
-
-            if (nodesWithoutCacheItems.Length > 0)
-            {
-                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
-                    "NotAllNodesDefineACacheItem",
-                    ItemTypeNames.ProjectCachePlugin,
-                    string.Join(", ", nodesWithoutCacheItems.Select(kvp => kvp.Key.ProjectInstance.FullPath)));
-            }
-
-            var cacheItem = cacheItems.First();
-
-            lock (_syncLock)
-            {
-                InitializeProjectCacheService(
-                    ProjectCacheDescriptor.FromAssemblyPath(
-                        cacheItem.PluginPath,
-                        entryPoints: null,
-                        projectGraph,
-                        cacheItem.PluginSettings),
-                    _graphSchedulingCancellationSource.Token);
-            }
-
-            return new DisposablePluginService(this);
-        }
-
-        private class DisposablePluginService : IDisposable
-        {
-            private readonly BuildManager _buildManager;
-
-            public DisposablePluginService(BuildManager buildManager)
-            {
-                _buildManager = buildManager;
-            }
-
-            public void Dispose()
-            {
-                if (_buildManager == null)
-                {
-                    return;
-                }
-
-                lock (_buildManager._syncLock)
-                {
-                    try
-                    {
-                        _buildManager._projectCacheService?.Result.ShutDown().GetAwaiter().GetResult();
-                    }
-                    finally
-                    {
-                        _buildManager._projectCacheService = null;
-                    }
-                }
-            }
-        }
-
         /// <summary>
         /// Asks the nodeManager to tell the currently connected nodes to shut down and sets a flag preventing all non-shutdown-related packets from
         /// being processed.
@@ -2186,6 +1988,7 @@ private void ShutdownConnectedNodes(bool abort)
             lock (_syncLock)
             {
                 _shuttingDown = true;
+                _executionCancellationTokenSource.Cancel();
 
                 // If we are aborting, we will NOT reuse the nodes because their state may be compromised by attempts to shut down while the build is in-progress.
                 _nodeManager.ShutdownConnectedNodes(!abort && _buildParameters.EnableNodeReuse);
@@ -2253,6 +2056,8 @@ private void Reset()
             _nodeManager = null;
 
             _shuttingDown = false;
+            _executionCancellationTokenSource.Dispose();
+            _executionCancellationTokenSource = null;
             _nodeConfiguration = null;
             _buildSubmissions.Clear();
             _graphBuildSubmissions.Clear();
@@ -2260,8 +2065,8 @@ private void Reset()
             _scheduler.Reset();
             _scheduler = null;
             _workQueue = null;
-            _graphSchedulingCancellationSource = null;
             _projectCacheService = null;
+            _hasProjectCacheServiceInitializedVsScenario = false;
             _acquiredProjectRootElementCacheFromProjectInstance = false;
 
             _unnamedProjectInstanceToNames.Clear();
@@ -2547,6 +2352,7 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
             _shuttingDown = true;
+            _executionCancellationTokenSource.Cancel();
             ErrorUtilities.VerifyThrow(_activeNodes.Contains(node), "Unexpected shutdown from node {0} which shouldn't exist.", node);
             _activeNodes.Remove(node);
 
@@ -3157,10 +2963,10 @@ private void Dispose(bool disposing)
                             _workQueue = null;
                         }
 
-                        if (_graphSchedulingCancellationSource != null)
+                        if (_executionCancellationTokenSource != null)
                         {
-                            _graphSchedulingCancellationSource.Cancel();
-                            _graphSchedulingCancellationSource = null;
+                            _executionCancellationTokenSource.Cancel();
+                            _executionCancellationTokenSource = null;
                         }
 
                         if (_noActiveSubmissionsEvent != null)
@@ -3276,6 +3082,7 @@ private void CancelAndMarkAsFailure()
             // CancelAllSubmissions also ends up setting _shuttingDown and _overallBuildSuccess but it does so in a separate thread to avoid deadlocks.
             // This might cause a race with the first builds which might miss the shutdown update and succeed instead of fail.
             _shuttingDown = true;
+            _executionCancellationTokenSource.Cancel();
             _overallBuildSuccess = false;
         }
 
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 1fec6f1c510..fca7476b2d5 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -791,10 +791,8 @@ public string OutputResultsCacheFile
         public bool LowPriority { get; set; }
 
         /// <summary>
-        /// If set, the BuildManager will query all
-        /// incoming <see cref="BuildSubmission"/> requests against the specified project cache.
-        /// Any <see cref="GraphBuildSubmission"/> requests will also use this project cache instead of
-        /// the potential project caches described in graph node's evaluations.
+        /// Gets or sets the project cache description to use for all <see cref="BuildSubmission"/> or <see cref="GraphBuildSubmission"/>
+        /// in addition to any potential project caches described in each project.
         /// </summary>
         public ProjectCacheDescriptor ProjectCacheDescriptor { get; set; }
 
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 4e88c67398a..be791e7ced8 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -8,6 +8,7 @@
 using System.Globalization;
 using System.IO;
 using System.IO.Pipes;
+using System.Linq;
 using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Client;
@@ -72,7 +73,7 @@ public sealed class MSBuildClient
         /// <summary>
         /// The named pipe stream for client-server communication.
         /// </summary>
-        private readonly NamedPipeClientStream _nodeStream;
+        private NamedPipeClientStream _nodeStream = null!;
 
         /// <summary>
         /// A way to cache a byte array when writing out packets
@@ -95,6 +96,11 @@ public sealed class MSBuildClient
         /// </summary>
         private TargetConsoleConfiguration? _consoleConfiguration;
 
+        /// <summary>
+        /// Incoming packet pump and redirection.
+        /// </summary>
+        private MSBuildClientPacketPump _packetPump = null!;
+
         /// <summary>
         /// Public constructor with parameters.
         /// </summary>
@@ -120,14 +126,20 @@ public MSBuildClient(
             // Client <-> Server communication stream
             _handshake = GetHandshake();
             _pipeName = OutOfProcServerNode.GetPipeName(_handshake);
+            _packetMemoryStream = new MemoryStream();
+            _binaryWriter = new BinaryWriter(_packetMemoryStream);
+
+            CreateNodePipeStream();
+        }
+
+        private void CreateNodePipeStream()
+        {
             _nodeStream = new NamedPipeClientStream(".", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
 #if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                                                                         | PipeOptions.CurrentUserOnly
+                | PipeOptions.CurrentUserOnly
 #endif
             );
-
-            _packetMemoryStream = new MemoryStream();
-            _binaryWriter = new BinaryWriter(_packetMemoryStream);
+            _packetPump = new MSBuildClientPacketPump(_nodeStream);
         }
 
         /// <summary>
@@ -148,11 +160,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
 #endif
 
             CommunicationsUtilities.Trace("Executing build with command line '{0}'", descriptiveCommandLine);
-            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);
-            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);
-
-            // Start server it if is not running.
-            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);
+            bool serverIsAlreadyRunning = ServerIsRunning();
             if (KnownTelemetry.BuildTelemetry != null)
             {
                 KnownTelemetry.BuildTelemetry.InitialServerState = serverIsAlreadyRunning ? "hot" : "cold";
@@ -168,7 +176,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
             }
 
             // Check that server is not busy.
-            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);
+            bool serverWasBusy = ServerWasBusy();
             if (serverWasBusy)
             {
                 CommunicationsUtilities.Trace("Server is busy, falling back to former behavior.");
@@ -195,10 +203,86 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
             _numConsoleWritePackets = 0;
             _sizeOfConsoleWritePackets = 0;
 
+            ReadPacketsLoop(cancellationToken);
+
+            MSBuildEventSource.Log.MSBuildServerBuildStop(descriptiveCommandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);
+            CommunicationsUtilities.Trace("Build finished.");
+            return _exitResult;
+        }
+
+        /// <summary>
+        /// Attempt to shutdown MSBuild Server node.
+        /// </summary>
+        /// <remarks>
+        /// It shutdown only server created by current user with current admin elevation.
+        /// </remarks>
+        /// <param name="cancellationToken"></param>
+        /// <returns>True if server is not running anymore.</returns>
+        public static bool ShutdownServer(CancellationToken cancellationToken)
+        {
+            // Neither commandLine nor msbuildlocation is involved in node shutdown
+            var client = new MSBuildClient(commandLine: null!, msbuildLocation: null!);
+
+            return client.TryShutdownServer(cancellationToken);
+        }
+
+        private bool TryShutdownServer(CancellationToken cancellationToken)
+        {
+            CommunicationsUtilities.Trace("Trying shutdown server node.");
+
+            bool serverIsAlreadyRunning = ServerIsRunning();
+            if (!serverIsAlreadyRunning)
+            {
+                CommunicationsUtilities.Trace("No need to shutdown server node for it is not running.");
+                return true;
+            }
+
+            // Check that server is not busy.
+            bool serverWasBusy = ServerWasBusy();
+            if (serverWasBusy)
+            {
+                CommunicationsUtilities.Trace("Server cannot be shut down for it is not idle.");
+                return false;
+            }
+
+            // Connect to server.
+            if (!TryConnectToServer(1_000))
+            {
+                CommunicationsUtilities.Trace("Client cannot connect to idle server to shut it down.");
+                return false;
+            }
+
+            if (!TrySendShutdownCommand())
+            {
+                CommunicationsUtilities.Trace("Failed to send shutdown command to the server.");
+                return false;
+            }
+
+            ReadPacketsLoop(cancellationToken);
+
+            return _exitResult.MSBuildClientExitType == MSBuildClientExitType.Success;
+        }
+
+        internal bool ServerIsRunning()
+        {
+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);
+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);
+            return serverIsAlreadyRunning;
+        }
+
+        private bool ServerWasBusy()
+        {
+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);
+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);
+            return serverWasBusy;
+        }
+
+        private void ReadPacketsLoop(CancellationToken cancellationToken)
+        {
             try
             {
                 // Start packet pump
-                using MSBuildClientPacketPump packetPump = new(_nodeStream);
+                using MSBuildClientPacketPump packetPump = _packetPump;
 
                 packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);
                 packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);
@@ -207,7 +291,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
                 WaitHandle[] waitHandles =
                 {
                     cancellationToken.WaitHandle,
-                    packetPump.PacketPumpErrorEvent,
+                    packetPump.PacketPumpCompleted,
                     packetPump.PacketReceivedEvent
                 };
 
@@ -224,7 +308,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
                             break;
 
                         case 1:
-                            HandlePacketPumpError(packetPump);
+                            HandlePacketPumpCompleted(packetPump);
                             break;
 
                         case 2:
@@ -246,10 +330,6 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
                 CommunicationsUtilities.Trace("MSBuild client error: problem during packet handling occurred: {0}.", ex);
                 _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;
             }
-
-            MSBuildEventSource.Log.MSBuildServerBuildStop(descriptiveCommandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);
-            CommunicationsUtilities.Trace("Build finished.");
-            return _exitResult;
         }
 
         private void ConfigureAndQueryConsoleProperties()
@@ -409,6 +489,12 @@ private bool TryLaunchServer()
 
         private bool TrySendCancelCommand() => TrySendPacket(() => new ServerNodeBuildCancel());
 
+        private bool TrySendShutdownCommand()
+        {
+            _packetPump.ServerWillDisconnect();
+            return  TrySendPacket(() => new NodeBuildComplete(false /* no node reuse */));
+        }
+
         private ServerNodeBuildCommand GetServerNodeBuildCommand()
         {
             Dictionary<string, string> envVars = new();
@@ -457,16 +543,21 @@ private void HandleCancellation()
         {
             TrySendCancelCommand();
 
-            CommunicationsUtilities.Trace("MSBuild client sent cancelation command.");
+            CommunicationsUtilities.Trace("MSBuild client sent cancellation command.");
         }
 
         /// <summary>
-        /// Handle packet pump error.
+        /// Handle when packet pump is completed both successfully or with error.
         /// </summary>
-        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)
+        private void HandlePacketPumpCompleted(MSBuildClientPacketPump packetPump)
         {
-            CommunicationsUtilities.Trace("MSBuild client error: packet pump unexpectedly shut down: {0}", packetPump.PacketPumpException);
-            throw packetPump.PacketPumpException ?? new InternalErrorException("Packet pump unexpectedly shut down");
+            if (packetPump.PacketPumpException != null)
+            {
+                CommunicationsUtilities.Trace("MSBuild client error: packet pump unexpectedly shut down: {0}", packetPump.PacketPumpException);
+                throw packetPump.PacketPumpException ?? new InternalErrorException("Packet pump unexpectedly shut down");
+            }
+
+            _buildFinished = true;
         }
 
         /// <summary>
@@ -517,17 +608,35 @@ private void HandleServerNodeBuildResult(ServerNodeBuildResult response)
         /// Connects to MSBuild server.
         /// </summary>
         /// <returns> Whether the client connected to MSBuild server successfully.</returns>
-        private bool TryConnectToServer(int timeout)
+        private bool TryConnectToServer(int timeoutMilliseconds)
         {
-            try
-            {
-                NodeProviderOutOfProcBase.ConnectToPipeStream(_nodeStream, _pipeName, _handshake, timeout);
-            }
-            catch (Exception ex)
+            bool tryAgain = true;
+            Stopwatch sw = Stopwatch.StartNew();
+
+            while (tryAgain && sw.ElapsedMilliseconds < timeoutMilliseconds)
             {
-                CommunicationsUtilities.Trace("Failed to connect to server: {0}", ex);
-                _exitResult.MSBuildClientExitType = MSBuildClientExitType.UnableToConnect;
-                return false;
+                tryAgain = false;
+                try
+                {
+                    NodeProviderOutOfProcBase.ConnectToPipeStream(_nodeStream, _pipeName, _handshake, Math.Max(1, timeoutMilliseconds - (int)sw.ElapsedMilliseconds));
+                }
+                catch (Exception ex)
+                {
+                    if (ex is not TimeoutException && sw.ElapsedMilliseconds < timeoutMilliseconds)
+                    {
+                        CommunicationsUtilities.Trace("Retrying to connect to server after {0} ms", sw.ElapsedMilliseconds);
+                        // This solves race condition for time in which server started but have not yet listen on pipe or
+                        // when it just finished build request and is recycling pipe.
+                        tryAgain = true;
+                        CreateNodePipeStream();
+                    }
+                    else
+                    {
+                        CommunicationsUtilities.Trace("Failed to connect to server: {0}", ex);
+                        _exitResult.MSBuildClientExitType = MSBuildClientExitType.UnableToConnect;
+                        return false;
+                    }
+                }
             }
 
             return true;
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 682fa1dfb94..351f922451c 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -27,12 +27,12 @@ internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketF
         public AutoResetEvent PacketReceivedEvent { get; }
 
         /// <summary>
-        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).
+        /// Set when the packet pump terminates.
         /// </summary>
-        public ManualResetEvent PacketPumpErrorEvent { get; }
+        public ManualResetEvent PacketPumpCompleted { get; }
 
         /// <summary>
-        /// Exception appeared when the packet pump unexpectedly terminates.
+        /// Exception appeared when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).
         /// </summary>
         public Exception? PacketPumpException { get; set; }
 
@@ -66,16 +66,24 @@ internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketF
         /// </summary>
         readonly ITranslator _binaryReadTranslator;
 
+        /// <summary>
+        /// True if this side is gracefully disconnecting.
+        /// In such case we have sent last packet to server side and we expect
+        /// it will soon broke pipe connection - unless client do it first.
+        /// </summary>
+        private bool _isServerDisconnecting;
+
         public MSBuildClientPacketPump(Stream stream)
         {
             ErrorUtilities.VerifyThrowArgumentNull(stream, nameof(stream));
 
             _stream = stream;
+            _isServerDisconnecting = false;
             _packetFactory = new NodePacketFactory();
 
             ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();
             PacketReceivedEvent = new AutoResetEvent(false);
-            PacketPumpErrorEvent = new ManualResetEvent(false);
+            PacketPumpCompleted = new ManualResetEvent(false);
             _packetPumpShutdownEvent = new ManualResetEvent(false);
 
             _readBufferMemoryStream = new MemoryStream();
@@ -170,7 +178,7 @@ public void Stop()
         /// set.
         /// </summary>
         /// <remarks>
-        /// Instead of throwing an exception, puts it in <see cref="PacketPumpException"/> and raises event <see cref="PacketPumpErrorEvent"/>.
+        /// Instead of throwing an exception, puts it in <see cref="PacketPumpException"/> and raises event <see cref="PacketPumpCompleted"/>.
         /// </remarks>
         private void PacketPumpProc()
         {
@@ -229,11 +237,17 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                                     // Incomplete read. Abort.
                                     if (headerBytesRead == 0)
                                     {
+                                        if (_isServerDisconnecting)
+                                        {
+                                            continueReading = false;
+                                            break;
+                                        }
+
                                         ErrorUtilities.ThrowInternalError("Server disconnected abruptly");
                                     }
                                     else
                                     {
-                                        ErrorUtilities.ThrowInternalError("Incomplete header read from server.  {0} of {1} bytes read", headerBytesRead, headerByte.Length);
+                                        ErrorUtilities.ThrowInternalError("Incomplete header read.  {0} of {1} bytes read", headerBytesRead, headerByte.Length);
                                     }
                                 }
 
@@ -246,14 +260,18 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                                 _readBufferMemoryStream.SetLength(packetLength);
                                 byte[] packetData = _readBufferMemoryStream.GetBuffer();
 
-                                packetBytesRead = localStream.Read(packetData, 0, packetLength);
-                                
-                                if (packetBytesRead != packetLength)
+                                while (packetBytesRead < packetLength)
                                 {
-                                    // Incomplete read.  Abort.
-                                    ErrorUtilities.ThrowInternalError("Incomplete header read from server. {0} of {1} bytes read", headerBytesRead, headerByte.Length);
-                                }
+                                    int bytesRead = localStream.Read(packetData, packetBytesRead, packetLength-packetBytesRead);
+                                    if (bytesRead == 0)
+                                    {
+                                        // Incomplete read.  Abort.
+                                        ErrorUtilities.ThrowInternalError("Incomplete packet read. {0} of {1} bytes read", packetBytesRead, packetLength);
+                                    }
 
+                                    packetBytesRead += bytesRead;
+                                }
+                                
                                 try
                                 {
                                     _packetFactory.DeserializeAndRoutePacket(0, packetType, _binaryReadTranslator);
@@ -292,13 +310,21 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
             {
                 CommunicationsUtilities.Trace("Exception occurred in the packet pump: {0}", ex);
                 PacketPumpException = ex;
-                PacketPumpErrorEvent.Set();
             }
 
             CommunicationsUtilities.Trace("Ending read loop.");
+            PacketPumpCompleted.Set();
         }
         #endregion
 
         public void Dispose() => Stop();
+
+        /// <summary>
+        /// Signalize that from now on we expect server will break connected named pipe.
+        /// </summary>
+        public void ServerWillDisconnect()
+        {
+            _isServerDisconnecting = true;
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 2f08099b333..b10bd378e32 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -8,7 +8,6 @@
 using System.Linq;
 using System.Reflection;
 using System.Threading;
-using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
@@ -1432,17 +1431,8 @@ private void LoggingEventProcessor(object loggingEvent)
         /// </summary>
         private void RouteBuildEvent(object loggingEvent)
         {
-            BuildEventArgs buildEventArgs = null;
-
-            if (loggingEvent is BuildEventArgs bea)
-            {
-                buildEventArgs = bea;
-            }
-            else if (loggingEvent is KeyValuePair<int, BuildEventArgs> kvp)
-            {
-                buildEventArgs = kvp.Value;
-            }
-            else
+            BuildEventArgs buildEventArgs = loggingEvent as BuildEventArgs ?? (loggingEvent as KeyValuePair<int, BuildEventArgs>?)?.Value;
+            if (buildEventArgs is null)
             {
                 ErrorUtilities.ThrowInternalError("Unknown logging item in queue:" + loggingEvent.GetType().FullName);
             }
@@ -1541,7 +1531,7 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
             TryRaiseProjectStartedEvent(eventArg);
 
             // The event has not been through a filter yet. All events must go through a filter before they make it to a logger
-            if (_filterEventSource != null)   // Loggers may not be registered
+            if (_filterEventSource != null) // Loggers may not be registered
             {
                 // Send the event to the filter, the Consume will not return until all of the loggers which have registered to the event have process
                 // them.
@@ -1562,7 +1552,7 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
                         {
                             if (!sink.HaveLoggedBuildStartedEvent)
                             {
-                                sink.Consume(eventArg, (int)pair.Key);
+                                sink.Consume(eventArg, pair.Key);
                             }
 
                             // Reset the HaveLoggedBuildStarted event because no one else will be sending a build started event to any loggers at this time.
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 214a5118c2c..5a4d694f427 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -388,14 +388,9 @@ public void LogBuildStarted()
                 message = ResourceUtilities.GetResourceString("BuildStarted");
             }
 
-            IDictionary<string, string> environmentProperties = null;
+            IDictionary<string, string> environmentProperties = _componentHost?.BuildParameters?.BuildProcessEnvironment;
 
-            if (_componentHost?.BuildParameters != null)
-            {
-                environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
-            }
-
-            BuildStartedEventArgs buildEvent = new BuildStartedEventArgs(message, null /* no help keyword */, environmentProperties);
+            BuildStartedEventArgs buildEvent = new(message, helpKeyword: null, environmentProperties);
 
             // Raise the event with the filters
             ProcessLoggingEvent(buildEvent);
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index bc39a5ccd32..6c7bb192575 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using static Microsoft.Build.Execution.ProjectPropertyInstance;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 #nullable disable
@@ -100,7 +101,19 @@ private ProjectLoggingContext(
                 !LoggingService.IncludeEvaluationPropertiesAndItems &&
                 (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
             {
-                properties = projectProperties?.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue)) ?? Enumerable.Empty<DictionaryEntry>();
+                if (projectProperties is null)
+                {
+                    properties = Enumerable.Empty<DictionaryEntry>();
+                }
+                else if (Traits.LogAllEnvironmentVariables)
+                {
+                    properties = projectProperties.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue));
+                }
+                else
+                {
+                    properties = projectProperties.Filter(p => p is not EnvironmentDerivedProjectPropertyInstance, p => new DictionaryEntry(p.Name, p.EvaluatedValue));
+                }
+
                 items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? Enumerable.Empty<DictionaryEntry>();
             }
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
index 6ac1b6b6b2a..c5751c5875e 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
@@ -2,130 +2,34 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections.Generic;
-using System.Linq;
-using Microsoft.Build.Graph;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
     public class ProjectCacheDescriptor
     {
-        /// <summary>
-        ///     The path to the assembly containing the project cache plugin.
-        /// </summary>
-        public string? PluginAssemblyPath { get; }
-
-        /// <summary>
-        ///     The entry points with which the plugin will be initialized.
-        /// </summary>
-        public IReadOnlyCollection<ProjectGraphEntryPoint>? EntryPoints { get; }
-
-        /// <summary>
-        ///     The graph with which the plugin will be initialized.
-        /// </summary>
-        public ProjectGraph? ProjectGraph { get; }
-
-        public IReadOnlyDictionary<string, string> PluginSettings { get; }
-
-        public ProjectCachePluginBase? PluginInstance { get; }
-
-        internal bool VsWorkaround { get; }
-
         private ProjectCacheDescriptor(
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings)
-        {
-            ErrorUtilities.VerifyThrowArgument(
-                (entryPoints == null) ^ (projectGraph == null),
-                "EitherEntryPointsOrTheProjectGraphIsSet");
-
-            EntryPoints = entryPoints;
-            ProjectGraph = projectGraph;
-            PluginSettings = pluginSettings ?? new Dictionary<string, string>();
-        }
-
-        private ProjectCacheDescriptor(
-            string pluginAssemblyPath,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)
+            string? pluginAssemblyPath,
+            IReadOnlyDictionary<string, string>? pluginSettings,
+            ProjectCachePluginBase? pluginInstance)
         {
             PluginAssemblyPath = pluginAssemblyPath;
-        }
-
-        private ProjectCacheDescriptor(
-            ProjectCachePluginBase pluginInstance,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)
-        {
+            PluginSettings = pluginSettings ?? new Dictionary<string, string>(0);
             PluginInstance = pluginInstance;
         }
 
-        private ProjectCacheDescriptor(ProjectCacheItem projectCacheItem)
-        {
-            VsWorkaround = true;
-            PluginAssemblyPath = projectCacheItem.PluginPath;
-            PluginSettings = projectCacheItem.PluginSettings;
-        }
-
-        // TODO: remove after we change VS to set the cache descriptor via build parameters.
-        internal static ProjectCacheDescriptor FromVisualStudioWorkaround(ProjectCacheItem projectCacheItem)
-        {
-            return new ProjectCacheDescriptor(projectCacheItem);
-        }
-
-        public static ProjectCacheDescriptor FromAssemblyPath(
-            string pluginAssemblyPath,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings = null)
-        {
-            return new ProjectCacheDescriptor(pluginAssemblyPath, entryPoints, projectGraph, pluginSettings);
-        }
-
-        public static ProjectCacheDescriptor FromInstance(
-            ProjectCachePluginBase pluginInstance,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings = null)
-        {
-            return new ProjectCacheDescriptor(pluginInstance, entryPoints, projectGraph, pluginSettings);
-        }
-
-        public string GetDetailedDescription()
-        {
-            var loadStyle = PluginInstance != null
-                ? $"Instance based: {PluginInstance.GetType().AssemblyQualifiedName}"
-                : $"Assembly path based: {PluginAssemblyPath}";
+        /// <summary>
+        /// Gets the path to the assembly containing the project cache plugin.
+        /// </summary>
+        public string? PluginAssemblyPath { get; }
 
-            var entryPointStyle = EntryPoints != null
-                ? "Explicit entry-point based"
-                : ProjectGraph != null
-                    ? "Static graph based"
-                    : "Visual Studio Workaround based";
+        public IReadOnlyDictionary<string, string> PluginSettings { get; }
 
-            var entryPoints = EntryPoints != null
-                ? string.Join(
-                    "\n",
-                    EntryPoints.Select(e => $"{e.ProjectFile} {{{FormatGlobalProperties(e.GlobalProperties)}}}"))
-                : ProjectGraph != null
-                    ? string.Join(
-                        "\n",
-                        ProjectGraph!.EntryPointNodes.Select(
-                            n =>
-                                $"{n.ProjectInstance.FullPath} {{{FormatGlobalProperties(n.ProjectInstance.GlobalProperties)}}}"))
-                    : "Solution file";
+        public ProjectCachePluginBase? PluginInstance { get; }
 
-            return $"{loadStyle}\nEntry-point style: {entryPointStyle}\nEntry-points:\n{entryPoints}";
+        public static ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, IReadOnlyDictionary<string, string>? pluginSettings = null)
+            => new ProjectCacheDescriptor(pluginAssemblyPath, pluginSettings, pluginInstance: null);
 
-            static string FormatGlobalProperties(IDictionary<string, string>? globalProperties)
-            {
-                return globalProperties == null
-                    ? string.Empty
-                    : string.Join(", ", globalProperties.Select(gp => $"{gp.Key}={gp.Value}"));
-            }
-        }
+        public static ProjectCacheDescriptor FromInstance(ProjectCachePluginBase pluginInstance, IReadOnlyDictionary<string, string>? pluginSettings = null)
+            => new ProjectCacheDescriptor(pluginAssemblyPath: null, pluginSettings, pluginInstance);
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
new file mode 100644
index 00000000000..cb85cae4558
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
@@ -0,0 +1,65 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    internal sealed class ProjectCacheDescriptorEqualityComparer : IEqualityComparer<ProjectCacheDescriptor>
+    {
+        private ProjectCacheDescriptorEqualityComparer()
+        {
+        }
+
+        public static ProjectCacheDescriptorEqualityComparer Instance { get; } = new ProjectCacheDescriptorEqualityComparer();
+
+        public bool Equals(ProjectCacheDescriptor? x, ProjectCacheDescriptor? y)
+        {
+            if (ReferenceEquals(x, y))
+            {
+                return true;
+            }
+
+            if (x is null || y is null)
+            {
+                return false;
+            }
+
+            return string.Equals(x.PluginAssemblyPath, y.PluginAssemblyPath, StringComparison.OrdinalIgnoreCase)
+                && ReferenceEquals(x.PluginInstance, y.PluginInstance)
+                && CollectionHelpers.DictionaryEquals(x.PluginSettings, y.PluginSettings);
+        }
+
+        public int GetHashCode(ProjectCacheDescriptor obj)
+        {
+            int hashCode = -1043047289;
+
+            if (obj.PluginAssemblyPath != null)
+            {
+                hashCode = (hashCode * -1521134295) + StringComparer.OrdinalIgnoreCase.GetHashCode(obj.PluginAssemblyPath);
+            }
+
+            if (obj.PluginInstance != null)
+            {
+                hashCode = (hashCode * -1521134295) + obj.PluginInstance.GetHashCode();
+            }
+
+            if (obj.PluginSettings.Count > 0)
+            {
+                int dictHash = 0;
+                foreach (KeyValuePair<string, string> pluginSetting in obj.PluginSettings)
+                {
+                    // XOR is commutative, so this accounts for arbitrary ordering for dictionaries
+                    dictHash ^= (pluginSetting.Key.GetHashCode() * -1521134295) + pluginSetting.Value.GetHashCode();
+                }
+
+                hashCode = (hashCode * -1521134295) + dictHash;
+            }
+
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs
deleted file mode 100644
index 2982c7508d9..00000000000
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.Experimental.ProjectCache
-{
-    internal class ProjectCacheItem : IEquatable<ProjectCacheItem>
-    {
-        private readonly IReadOnlyCollection<KeyValuePair<string, string>> _pluginSettingsSorted;
-
-        public ProjectCacheItem(string pluginPath, IReadOnlyDictionary<string, string> pluginSettings)
-        {
-            PluginPath = pluginPath;
-
-            PluginSettings = pluginSettings;
-
-            // Sort by key to avoid doing it during hashcode computation.
-            _pluginSettingsSorted = pluginSettings.OrderBy(_ => _.Key).ToArray();
-        }
-
-        public string PluginPath { get; }
-        public IReadOnlyDictionary<string, string> PluginSettings { get; }
-
-        public bool Equals(ProjectCacheItem? other)
-        {
-            if (ReferenceEquals(this, other))
-            {
-                return true;
-            }
-
-            return PluginPath == other?.PluginPath &&
-                   CollectionHelpers.DictionaryEquals(PluginSettings, other.PluginSettings);
-        }
-
-        public override bool Equals(object? obj)
-        {
-            if (ReferenceEquals(this, obj))
-            {
-                return true;
-            }
-
-            if (obj?.GetType() != GetType())
-            {
-                return false;
-            }
-
-            return Equals((ProjectCacheItem) obj);
-        }
-
-        public override int GetHashCode()
-        {
-            int hashCode = -1043047289;
-
-            hashCode = (hashCode * -1521134295) + PluginPath.GetHashCode();
-
-            foreach (var pluginSetting in _pluginSettingsSorted)
-            {
-                hashCode = (hashCode * -1521134295) + pluginSetting.Key.GetHashCode();
-                hashCode = (hashCode * -1521134295) + pluginSetting.Value.GetHashCode();
-            }
-
-            return hashCode;
-        }
-    }
-}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 8c3cdb46bb8..d33176bb73f 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -2,9 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
+using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Runtime.ExceptionServices;
 using System.Threading;
 using System.Threading.Tasks;
 using System.Xml;
@@ -18,90 +21,139 @@
 using Microsoft.Build.Graph;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
     internal record CacheRequest(BuildSubmission Submission, BuildRequestConfiguration Configuration);
 
-    internal record NullableBool(bool Value)
+    internal sealed class ProjectCacheService : IAsyncDisposable
     {
-        public static implicit operator bool(NullableBool? d) => d is not null && d.Value;
-    }
+        private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };
 
-    internal enum ProjectCacheServiceState
-    {
-        NotInitialized,
-        BeginBuildStarted,
-        BeginBuildFinished,
-        ShutdownStarted,
-        ShutdownFinished
-    }
+        private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { "TargetFramework", "Configuration", "Platform", "TargetPlatform", "OutputType" };
 
-    internal class ProjectCacheService
-    {
         private readonly BuildManager _buildManager;
         private readonly ILoggingService _loggingService;
-        private readonly ProjectCacheDescriptor _projectCacheDescriptor;
-        private readonly CancellationToken _cancellationToken;
-        private readonly ProjectCachePluginBase _projectCachePlugin;
-        private readonly string _projectCachePluginTypeName;
-        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;
+
+        private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;
+
+        private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);
+
+        private bool _isVsScenario;
+
+        private bool _isDisposed;
+
+        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);
 
         /// <summary>
         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,
         /// i.e. falling back to FileSystem.Default.
         /// </summary>
-        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }
-
-        // Use NullableBool to make it work with Interlock.CompareExchange (doesn't accept bool?).
-        // Assume that if one request is a design time build, all of them are.
-        // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.
-        // TODO: remove after we change VS to set the cache descriptor via build parameters.
-        public volatile NullableBool? DesignTimeBuildsDetected;
-        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;
-
-        private ProjectCacheService(
-            ProjectCachePluginBase projectCachePlugin,
-            string pluginTypeName,
+        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase
+        {
+            private DefaultMSBuildFileSystem()
+            {
+            }
+
+            public static DefaultMSBuildFileSystem Instance { get; } = new();
+        }
+
+        public ProjectCacheService(
             BuildManager buildManager,
             ILoggingService loggingService,
-            ProjectCacheDescriptor projectCacheDescriptor,
-            CancellationToken cancellationToken
-        )
+            ProjectCacheDescriptor? globalProjectCacheDescriptor)
         {
-            _projectCachePlugin = projectCachePlugin;
-            _projectCachePluginTypeName = pluginTypeName;
             _buildManager = buildManager;
             _loggingService = loggingService;
-            _projectCacheDescriptor = projectCacheDescriptor;
-            _cancellationToken = cancellationToken;
+            _globalProjectCacheDescriptor = globalProjectCacheDescriptor;
         }
 
-        public static async Task<ProjectCacheService> FromDescriptorAsync(
-            ProjectCacheDescriptor pluginDescriptor,
-            BuildManager buildManager,
-            ILoggingService loggingService,
+        /// <summary>
+        /// Optimization which frontloads plugin initialization since we have an entire graph.
+        /// </summary>
+        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)
+        {
+            EnsureNotDisposed();
+
+            Parallel.ForEach(
+                projectGraph.ProjectNodes,
+                s_parallelOptions,
+                node =>
+                {
+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
+                    {
+                        // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
+                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                    }
+                });
+        }
+
+        public void InitializePluginsForVsScenario(
+            IEnumerable<ProjectCacheDescriptor> projectCacheDescriptors,
+            BuildRequestConfiguration buildRequestConfiguration,
             CancellationToken cancellationToken)
         {
-            (ProjectCachePluginBase plugin, string pluginTypeName) = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)
-                .ConfigureAwait(false);
+            EnsureNotDisposed();
+
+            _isVsScenario = true;
 
-            var service = new ProjectCacheService(plugin, pluginTypeName, buildManager, loggingService, pluginDescriptor, cancellationToken);
+            // Bail out for design-time builds
+            if (IsDesignTimeBuild(buildRequestConfiguration))
+            {
+                return;
+            }
+
+            Parallel.ForEach(
+                projectCacheDescriptors,
+                s_parallelOptions,
+                projectCacheDescriptor =>
+                {
+                    // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
+                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                });
+        }
 
-            // TODO: remove the if after we change VS to set the cache descriptor via build parameters and always call BeginBuildAsync in FromDescriptorAsync.
-            // When running under VS we can't initialize the plugin until we evaluate a project (any project) and extract
-            // further information (set by VS) from it required by the plugin.
-            if (!pluginDescriptor.VsWorkaround)
+        private Task<ProjectCachePlugin> GetProjectCachePluginAsync(
+            ProjectCacheDescriptor projectCacheDescriptor,
+            ProjectGraph? projectGraph,
+            BuildRequestConfiguration? buildRequestConfiguration,
+            CancellationToken cancellationToken)
+            => _projectCachePlugins.GetOrAdd(
+                projectCacheDescriptor,
+                // The use of Lazy is because ConcurrentDictionary doesn't guarantee the value factory executes only once if there are multiple simultaneous callers,
+                // so this ensures that CreateAndInitializePluginAsync is only called exactly once.
+                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, cancellationToken)))
+               .Value;
+
+        private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectInstance projectInstance)
+        {
+            if (_globalProjectCacheDescriptor != null)
             {
-                await service.BeginBuildAsync();
+                yield return _globalProjectCacheDescriptor;
             }
 
-            return service;
+            ICollection<ProjectItemInstance> items = projectInstance.GetItems(ItemTypeNames.ProjectCachePlugin);
+            foreach (ProjectItemInstance item in items)
+            {
+                string pluginPath = FileUtilities.NormalizePath(Path.Combine(item.Project.Directory, item.EvaluatedInclude));
+
+                var pluginSettings = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                foreach (ProjectMetadataInstance metadatum in item.Metadata)
+                {
+                    pluginSettings.Add(metadatum.Name, metadatum.EvaluatedValue);
+                }
+
+                yield return ProjectCacheDescriptor.FromAssemblyPath(pluginPath, pluginSettings);
+            }
         }
 
-        // TODO: remove vsWorkaroundOverrideDescriptor after we change VS to set the cache descriptor via build parameters.
-        private async Task BeginBuildAsync(ProjectCacheDescriptor? vsWorkaroundOverrideDescriptor = null)
+        private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
+            ProjectCacheDescriptor projectCacheDescriptor,
+            ProjectGraph? projectGraph,
+            BuildRequestConfiguration? buildRequestConfiguration,
+            CancellationToken cancellationToken)
         {
             BuildEventContext buildEventContext = BuildEventContext.Invalid;
             BuildEventFileInfo buildEventFileInfo = BuildEventFileInfo.Empty;
@@ -109,57 +161,73 @@ private async Task BeginBuildAsync(ProjectCacheDescriptor? vsWorkaroundOverrideD
                 _loggingService,
                 buildEventContext,
                 buildEventFileInfo);
-            ProjectCacheDescriptor projectDescriptor = vsWorkaroundOverrideDescriptor ?? _projectCacheDescriptor;
 
-            try
-            {
-                SetState(ProjectCacheServiceState.BeginBuildStarted);
-                _loggingService.LogComment(buildEventContext, MessageImportance.Low, "ProjectCacheBeginBuild");
-                MSBuildEventSource.Log.ProjectCacheBeginBuildStart(_projectCachePluginTypeName);
+            ProjectCachePluginBase pluginInstance;
+            string pluginTypeName;
 
-                await _projectCachePlugin.BeginBuildAsync(
-                    new CacheContext(
-                        projectDescriptor.PluginSettings,
-                        new DefaultMSBuildFileSystem(),
-                        projectDescriptor.ProjectGraph,
-                        projectDescriptor.EntryPoints),
-                    pluginLogger,
-                    _cancellationToken);
-            }
-            catch (Exception e)
+            if (projectCacheDescriptor.PluginInstance != null)
             {
-                HandlePluginException(e, nameof(ProjectCachePluginBase.BeginBuildAsync));
+                pluginInstance = projectCacheDescriptor.PluginInstance;
+                pluginTypeName = projectCacheDescriptor.PluginInstance.GetType().Name;
             }
-            finally
+            else
             {
-                MSBuildEventSource.Log.ProjectCacheBeginBuildStop(_projectCachePluginTypeName);
-                SetState(ProjectCacheServiceState.BeginBuildFinished);
+                ErrorUtilities.VerifyThrowArgumentNull(projectCacheDescriptor.PluginAssemblyPath, nameof(projectCacheDescriptor.PluginAssemblyPath));
+
+                string pluginAssemblyPath = projectCacheDescriptor.PluginAssemblyPath!;
+                pluginTypeName = pluginAssemblyPath; // Just in case the assembly can't be loaded, the path would be helpful to help identify the problem.
+                try
+                {
+                    MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStart(pluginAssemblyPath);
+
+                    Type pluginType = GetTypeFromAssemblyPath(pluginAssemblyPath);
+                    pluginTypeName = pluginType.Name;
+
+                    pluginInstance = GetPluginInstanceFromType(pluginType);
+                }
+                catch (Exception e)
+                {
+                    return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                }
+                finally
+                {
+                    MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStop(pluginAssemblyPath, pluginTypeName);
+                }
             }
 
-            if (pluginLogger.HasLoggedErrors)
+            IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = buildRequestConfiguration != null
+                ? GetGraphEntryPoints(buildRequestConfiguration)
+                : null;
+
+            _loggingService.LogComment(buildEventContext, MessageImportance.High, "LoadingProjectCachePlugin", pluginTypeName);
+            MSBuildEventSource.Log.ProjectCacheBeginBuildStart(pluginTypeName);
+
+            try
             {
-                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
-            }
-        }
+                await pluginInstance.BeginBuildAsync(
+                    new CacheContext(
+                        projectCacheDescriptor.PluginSettings,
+                        DefaultMSBuildFileSystem.Instance,
+                        projectGraph,
+                        graphEntryPoints),
+                    pluginLogger,
+                    cancellationToken);
 
-        private static (ProjectCachePluginBase PluginInstance, string PluginTypeName) GetPluginInstance(ProjectCacheDescriptor pluginDescriptor)
-        {
-            if (pluginDescriptor.PluginInstance != null)
+                if (pluginLogger.HasLoggedErrors)
+                {
+                    ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
+                }
+
+                return new ProjectCachePlugin(pluginTypeName, pluginInstance);
+            }
+            catch (Exception e)
             {
-                return (pluginDescriptor.PluginInstance, pluginDescriptor.PluginInstance.GetType().Name);
+                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
             }
-
-            if (pluginDescriptor.PluginAssemblyPath != null)
+            finally
             {
-                MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStart(pluginDescriptor.PluginAssemblyPath);
-                Type pluginType = GetTypeFromAssemblyPath(pluginDescriptor.PluginAssemblyPath);
-                ProjectCachePluginBase pluginInstance = GetPluginInstanceFromType(pluginType);
-                MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStop(pluginDescriptor.PluginAssemblyPath, pluginType.Name);
-                return (pluginInstance, pluginType.Name);
+                MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);
             }
-
-            ErrorUtilities.ThrowInternalErrorUnreachable();
-            return (null!, null!); // Unreachable
         }
 
         private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
@@ -214,78 +282,64 @@ IEnumerable<Type> GetTypes<T>(Assembly assembly)
         private static readonly CoreClrAssemblyLoader s_loader = new CoreClrAssemblyLoader();
 #endif
 
-        public void PostCacheRequest(CacheRequest cacheRequest)
+        public bool ShouldUseCache(BuildRequestConfiguration buildRequestConfiguration)
         {
-            Task.Run(async () =>
+            if (IsDesignTimeBuild(buildRequestConfiguration))
             {
-                try
-                {
-                    (CacheResult cacheResult, int projectContextId) = await ProcessCacheRequest(cacheRequest);
-                    _buildManager.PostCacheResult(cacheRequest, cacheResult, projectContextId);
-                }
-                catch (Exception e)
-                {
-                    _buildManager.PostCacheResult(cacheRequest, CacheResult.IndicateException(e), BuildEventContext.InvalidProjectContextId);
-                }
-            }, _cancellationToken);
+                return false;
+            }
 
-            async Task<(CacheResult Result, int ProjectContextId)> ProcessCacheRequest(CacheRequest request)
+            if (_globalProjectCacheDescriptor != null)
             {
-                // Prevent needless evaluation if design time builds detected.
-                if (_projectCacheDescriptor.VsWorkaround && DesignTimeBuildsDetected)
-                {
-                    // The BuildManager should disable the cache when it finds its servicing design time builds.
-                    return (CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss), BuildEventContext.InvalidProjectContextId);
-                }
+                return true;
+            }
 
-                EvaluateProjectIfNecessary(request);
+            // We've determined it's the VS scenario and know that there are project cache plugins.
+            if (_isVsScenario)
+            {
+                return true;
+            }
 
-                // Detect design time builds.
-                if (_projectCacheDescriptor.VsWorkaround)
-                {
-                    var isDesignTimeBuild = IsDesignTimeBuild(request.Configuration.Project);
+            // If the project isn't loaded, don't force it to be just to check if it's cacheable as this may not be very performant.
+            if (!buildRequestConfiguration.IsLoaded)
+            {
+                return false;
+            }
 
-                    var previousValue = Interlocked.CompareExchange(
-                        ref DesignTimeBuildsDetected,
-                        new NullableBool(isDesignTimeBuild),
-                        null);
+            // Check if there are any project cache items defined in the project
+            return GetProjectCacheDescriptors(buildRequestConfiguration.Project).Any();
+        }
 
-                    ErrorUtilities.VerifyThrowInternalError(
-                        previousValue is null || previousValue == false || isDesignTimeBuild,
-                        "Either all builds in a build session or design time builds, or none");
+        private bool IsDesignTimeBuild(BuildRequestConfiguration buildRequestConfiguration)
+        {
+            string? designTimeBuild = buildRequestConfiguration.GlobalProperties[DesignTimeProperties.DesignTimeBuild]?.EvaluatedValue;
+            string? buildingProject = buildRequestConfiguration.GlobalProperties[DesignTimeProperties.BuildingProject]?.EvaluatedValue;
+            return ConversionUtilities.ConvertStringToBool(designTimeBuild, nullOrWhitespaceIsFalse: true)
+                || (buildingProject != null && !ConversionUtilities.ConvertStringToBool(designTimeBuild, nullOrWhitespaceIsFalse: true));
+        }
 
-                    // No point progressing with expensive plugin initialization or cache query if design time build detected.
-                    if (DesignTimeBuildsDetected)
-                    {
-                        // The BuildManager should disable the cache when it finds its servicing design time builds.
-                        return (CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss), BuildEventContext.InvalidProjectContextId);
-                    }
-                }
+        public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancellationToken)
+        {
+            EnsureNotDisposed();
 
-                // TODO: remove after we change VS to set the cache descriptor via build parameters.
-                // VS workaround needs to wait until the first project is evaluated to extract enough information to initialize the plugin.
-                // No cache request can progress until late initialization is complete.
-                if (_projectCacheDescriptor.VsWorkaround)
+            Task.Run(
+                async () =>
                 {
-                    if (Interlocked.CompareExchange(
-                            ref LateInitializationForVSWorkaroundCompleted,
-                            new TaskCompletionSource<bool>(),
-                            null) is null)
+                    try
                     {
-                        await LateInitializePluginForVsWorkaround(request);
-                        LateInitializationForVSWorkaroundCompleted.SetResult(true);
+                        (CacheResult cacheResult, int projectContextId) = await ProcessCacheRequestAsync();
+                        _buildManager.PostCacheResult(cacheRequest, cacheResult, projectContextId);
                     }
-                    else
+                    catch (Exception e)
                     {
-                        // Can't be null. If the thread got here it means another thread initialized the completion source.
-                        await LateInitializationForVSWorkaroundCompleted!.Task;
+                        _buildManager.PostCacheResult(cacheRequest, CacheResult.IndicateException(e), BuildEventContext.InvalidProjectContextId);
                     }
-                }
+                },
+                cancellationToken);
 
-                ErrorUtilities.VerifyThrowInternalError(
-                    LateInitializationForVSWorkaroundCompleted is null ||
-                    (_projectCacheDescriptor.VsWorkaround && LateInitializationForVSWorkaroundCompleted.Task.IsCompleted),
-                    "Completion source should be null when this is not the VS workaround");
+            async Task<(CacheResult Result, int ProjectContextId)> ProcessCacheRequestAsync()
+            {
+                EvaluateProjectIfNecessary(cacheRequest.Submission, cacheRequest.Configuration);
 
                 BuildRequestData buildRequest = new BuildRequestData(
                     cacheRequest.Configuration.Project,
@@ -299,7 +353,7 @@ LateInitializationForVSWorkaroundCompleted is null ||
                 CacheResult cacheResult;
                 try
                 {
-                    cacheResult = await GetCacheResultAsync(buildRequest, cacheRequest.Configuration, buildEventContext);
+                    cacheResult = await GetCacheResultAsync(buildRequest, cacheRequest.Configuration, buildEventContext, cancellationToken);
                 }
                 catch (Exception ex)
                 {
@@ -310,166 +364,29 @@ LateInitializationForVSWorkaroundCompleted is null ||
                 return (cacheResult, buildEventContext.ProjectContextId);
             }
 
-            static bool IsDesignTimeBuild(ProjectInstance project)
-            {
-                var designTimeBuild = project.GetPropertyValue(DesignTimeProperties.DesignTimeBuild);
-                var buildingProject = project.GlobalPropertiesDictionary[DesignTimeProperties.BuildingProject]?.EvaluatedValue;
-
-                return MSBuildStringIsTrue(designTimeBuild) ||
-                       (buildingProject != null && !MSBuildStringIsTrue(buildingProject));
-            }
-
-            void EvaluateProjectIfNecessary(CacheRequest request)
+            void EvaluateProjectIfNecessary(BuildSubmission submission, BuildRequestConfiguration configuration)
             {
-                // TODO: only do this if the project cache requests evaluation. QB needs evaluations, but the Anybuild implementation
-                // TODO: might not need them, so no point evaluating if it's not necessary. As a caveat, evaluations would still be optimal
-                // TODO: when proxy builds are issued by the plugin ( scheduled on the inproc node, no point re-evaluating on out-of-proc nodes).
-                lock (request.Configuration)
+                lock (configuration)
                 {
-                    if (!request.Configuration.IsLoaded)
+                    if (!configuration.IsLoaded)
                     {
-                        request.Configuration.LoadProjectIntoConfiguration(
+                        configuration.LoadProjectIntoConfiguration(
                             _buildManager,
-                            request.Submission.BuildRequestData.Flags,
-                            request.Submission.SubmissionId,
+                            submission.BuildRequestData.Flags,
+                            submission.SubmissionId,
                             Scheduler.InProcNodeId
                         );
 
                         // If we're taking the time to evaluate, avoid having other nodes to repeat the same evaluation.
                         // Based on the assumption that ProjectInstance serialization is faster than evaluating from scratch.
-                        request.Configuration.Project.TranslateEntireState = true;
-                    }
-                }
-            }
-
-            async Task LateInitializePluginForVsWorkaround(CacheRequest request)
-            {
-                var (_, configuration) = request;
-                var solutionConfigurationXml = configuration.Project.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
-
-                ErrorUtilities.VerifyThrow(
-                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,
-                    "Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.");
-
-                // A solution supports multiple solution configurations (different values for Configuration and Platform).
-                // Each solution configuration generates a different static graph.
-                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the
-                // currently solution configuration used by VS.
-                //
-                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property
-                // named "CurrentSolutionConfigurationContents" that VS sets on each built project. It does not contain the solution configuration itself, but
-                // instead it contains information on how the solution configuration maps to each project's configuration.
-                //
-                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project
-                // mentioned in the "CurrentSolutionConfigurationContents" global property.
-                //
-                // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as
-                // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.
-                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(
-                    solutionConfigurationXml,
-                    configuration.Project);
-
-                await BeginBuildAsync(
-                    ProjectCacheDescriptor.FromAssemblyPath(
-                        _projectCacheDescriptor.PluginAssemblyPath!,
-                        graphEntryPointsFromSolutionConfig,
-                        projectGraph: null,
-                        _projectCacheDescriptor.PluginSettings));
-            }
-
-            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(
-                string solutionConfigurationXml,
-                ProjectInstance project
-            )
-            {
-                // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751
-                var doc = new XmlDocument();
-                doc.LoadXml(solutionConfigurationXml);
-
-                var root = doc.DocumentElement!;
-                var projectConfigurationNodes = root.GetElementsByTagName("ProjectConfiguration");
-
-                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, "Expected at least one project in solution");
-
-                var definingProjectPath = project.FullPath;
-                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);
-
-                var templateGlobalProperties = new Dictionary<string, string>(project.GlobalProperties, StringComparer.OrdinalIgnoreCase);
-                RemoveProjectSpecificGlobalProperties(templateGlobalProperties, project);
-
-                foreach (XmlNode node in projectConfigurationNodes)
-                {
-                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));
-
-                    var buildProjectInSolution = node.Attributes!["BuildProjectInSolution"];
-                    if (buildProjectInSolution is not null &&
-                        string.IsNullOrWhiteSpace(buildProjectInSolution.Value) is false &&
-                        bool.TryParse(buildProjectInSolution.Value, out var buildProject) &&
-                        buildProject is false)
-                    {
-                        continue;
-                    }
-
-                    ErrorUtilities.VerifyThrow(
-                        node.ChildNodes.OfType<XmlElement>().FirstOrDefault(e => e.Name == "ProjectDependency") is null,
-                        "Project cache service does not support solution only dependencies when running under Visual Studio.");
-
-                    var projectPathAttribute = node.Attributes!["AbsolutePath"];
-                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, "Expected VS to set the project path on each ProjectConfiguration element.");
-
-                    var projectPath = projectPathAttribute!.Value;
-
-                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);
-
-                    // Take the defining project global properties and override the configuration and platform.
-                    // It's sufficient to only set Configuration and Platform.
-                    // But we send everything to maximize the plugins' potential to quickly workaround potential MSBuild issues while the MSBuild fixes flow into VS.
-                    var globalProperties = new Dictionary<string, string>(templateGlobalProperties, StringComparer.OrdinalIgnoreCase)
-                    {
-                        ["Configuration"] = configuration,
-                        ["Platform"] = platform
-                    };
-
-                    graphEntryPoints.Add(new ProjectGraphEntryPoint(projectPath, globalProperties));
-                }
-
-                return graphEntryPoints;
-
-                // If any project specific property is set, it will propagate down the project graph and force all nodes to that property's specific side effects, which is incorrect.
-                void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)
-                {
-                    // InnerBuildPropertyName is TargetFramework for the managed sdk.
-                    var innerBuildPropertyName = ProjectInterpretation.GetInnerBuildPropertyName(project);
-
-                    IEnumerable<string> projectSpecificPropertyNames = new []{innerBuildPropertyName, "Configuration", "Platform", "TargetPlatform", "OutputType"};
-
-                    foreach (var propertyName in projectSpecificPropertyNames)
-                    {
-                        if (!string.IsNullOrWhiteSpace(propertyName) && globalProperties.ContainsKey(propertyName))
-                        {
-                            globalProperties.Remove(propertyName);
-                        }
+                        configuration.Project.TranslateEntireState = true;
                     }
                 }
             }
-
-            static bool MSBuildStringIsTrue(string msbuildString) =>
-                ConversionUtilities.ConvertStringToBool(msbuildString, nullOrWhitespaceIsFalse: true);
         }
 
-        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext)
+        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext, CancellationToken cancellationToken)
         {
-            lock (this)
-            {
-                CheckNotInState(ProjectCacheServiceState.NotInitialized);
-                CheckNotInState(ProjectCacheServiceState.BeginBuildStarted);
-
-                if (_serviceState is ProjectCacheServiceState.ShutdownStarted or ProjectCacheServiceState.ShutdownFinished)
-                {
-                    return CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable);
-                }
-            }
-
             ErrorUtilities.VerifyThrowInternalNull(buildRequest.ProjectInstance, nameof(buildRequest.ProjectInstance));
 
             var buildEventFileInfo = new BuildEventFileInfo(buildRequest.ProjectFullPath);
@@ -490,31 +407,55 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
                 _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheQueryStartedWithTargetNames", buildRequest.ProjectFullPath, targetNames);
             }
 
+            HashSet<ProjectCacheDescriptor> queriedCaches = new(ProjectCacheDescriptorEqualityComparer.Instance);
             CacheResult? cacheResult = null;
-            try
-            {
-                MSBuildEventSource.Log.ProjectCacheGetCacheResultStart(_projectCachePluginTypeName, buildRequest.ProjectFullPath, targetNames);
-                cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, pluginLogger, _cancellationToken);
-            }
-            catch (Exception e)
+            foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(buildRequest.ProjectInstance))
             {
-                HandlePluginException(e, nameof(ProjectCachePluginBase.GetCacheResultAsync));
-                return null!; // Unreachable
-            }
-            finally
-            {
-                if (MSBuildEventSource.Log.IsEnabled())
+                // Ensure each unique plugin is only queried once
+                if (!queriedCaches.Add(projectCacheDescriptor))
                 {
-                    string cacheResultType = cacheResult?.ResultType.ToString() ?? nameof(CacheResultType.None);
-                    MSBuildEventSource.Log.ProjectCacheGetCacheResultStop(_projectCachePluginTypeName, buildRequest.ProjectFullPath, targetNames, cacheResultType);
+                    continue;
                 }
-            }
 
-            if (pluginLogger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
-            {
-                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheQueryFailed", buildRequest.ProjectFullPath);
+                ProjectCachePlugin plugin = await GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken);
+                try
+                {
+                    // Rethrow any initialization exception.
+                    plugin.InitializationException?.Throw();
+
+                    ErrorUtilities.VerifyThrow(plugin.Instance != null, "Plugin '{0}' instance is null", plugin.Name);
+
+                    MSBuildEventSource.Log.ProjectCacheGetCacheResultStart(plugin.Name, buildRequest.ProjectFullPath, targetNames);
+                    cacheResult = await plugin.Instance!.GetCacheResultAsync(buildRequest, pluginLogger, cancellationToken);
+
+                    if (pluginLogger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
+                    {
+                        ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheQueryFailed", buildRequest.ProjectFullPath);
+                    }
+
+                    if (cacheResult.ResultType == CacheResultType.CacheHit)
+                    {
+                        break;
+                    }
+                }
+                catch (Exception e) when (e is not ProjectCacheException)
+                {
+                    HandlePluginException(e, nameof(ProjectCachePluginBase.GetCacheResultAsync));
+                    return null!; // Unreachable
+                }
+                finally
+                {
+                    if (MSBuildEventSource.Log.IsEnabled())
+                    {
+                        string cacheResultType = cacheResult?.ResultType.ToString() ?? nameof(CacheResultType.None);
+                        MSBuildEventSource.Log.ProjectCacheGetCacheResultStop(plugin.Name, buildRequest.ProjectFullPath, targetNames, cacheResultType);
+                    }
+                }
             }
 
+            // Handle the case of no configured plugins.
+            cacheResult ??= CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable);
+
             switch (cacheResult.ResultType)
             {
                 case CacheResultType.CacheHit:
@@ -565,103 +506,172 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
             return cacheResult;
         }
 
-        public async Task ShutDown()
+        private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildRequestConfiguration configuration)
         {
-            bool shouldInitiateShutdownState = _serviceState != ProjectCacheServiceState.ShutdownStarted && _serviceState != ProjectCacheServiceState.ShutdownFinished;
+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);
+            foreach (ProjectPropertyInstance property in configuration.GlobalProperties)
+            {
+                // If any project specific property is set, it will propagate down the project graph and force all nodes to that property's specific side effects, which is incorrect.
+                if (!s_projectSpecificPropertyNames.Contains(property.Name))
+                {
+                    globalProperties.Add(property.Name, property.EvaluatedValue);
+                }
+            }
 
-            if (!shouldInitiateShutdownState)
+            if (globalProperties.TryGetValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents, out string? solutionConfigurationXml)
+                && !string.IsNullOrWhiteSpace(solutionConfigurationXml))
             {
-                return;
+                // A solution supports multiple solution configurations (different values for Configuration and Platform).
+                // Each solution configuration generates a different static graph.
+                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the
+                // currently solution configuration used by VS.
+                //
+                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property
+                // named "CurrentSolutionConfigurationContents" that VS sets on each built project. It does not contain the solution configuration itself, but
+                // instead it contains information on how the solution configuration maps to each project's configuration.
+                //
+                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project
+                // mentioned in the "CurrentSolutionConfigurationContents" global property.
+                return GenerateGraphEntryPointsFromSolutionConfigurationXml(solutionConfigurationXml!, configuration.ProjectFullPath, globalProperties);
+            }
+            else
+            {
+                return new[] { new ProjectGraphEntryPoint(configuration.ProjectFullPath, globalProperties) };
             }
 
-            BuildEventContext buildEventContext = BuildEventContext.Invalid;
-            BuildEventFileInfo buildEventFileInfo = BuildEventFileInfo.Empty;
-            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
-                _loggingService,
-                BuildEventContext.Invalid,
-                BuildEventFileInfo.Empty);
-            
-            try
+            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(
+                string solutionConfigurationXml,
+                string definingProjectPath,
+                Dictionary<string, string> templateGlobalProperties
+            )
             {
-                SetState(ProjectCacheServiceState.ShutdownStarted);
-                _loggingService.LogComment(buildEventContext, MessageImportance.Low, "ProjectCacheEndBuild");
-                MSBuildEventSource.Log.ProjectCacheEndBuildStart(_projectCachePluginTypeName);
+                // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751
+                var doc = new XmlDocument();
+                doc.LoadXml(solutionConfigurationXml);
 
-                await _projectCachePlugin.EndBuildAsync(pluginLogger, _cancellationToken);
+                var root = doc.DocumentElement!;
+                var projectConfigurationNodes = root.GetElementsByTagName("ProjectConfiguration");
 
-                if (pluginLogger.HasLoggedErrors)
+                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, "Expected at least one project in solution");
+
+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);
+
+                foreach (XmlNode node in projectConfigurationNodes)
                 {
-                    ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
+                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));
+
+                    var buildProjectInSolution = node.Attributes!["BuildProjectInSolution"];
+                    if (buildProjectInSolution is not null &&
+                        string.IsNullOrWhiteSpace(buildProjectInSolution.Value) is false &&
+                        bool.TryParse(buildProjectInSolution.Value, out var buildProject) &&
+                        buildProject is false)
+                    {
+                        continue;
+                    }
+
+                    var projectPathAttribute = node.Attributes!["AbsolutePath"];
+                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, "Expected VS to set the project path on each ProjectConfiguration element.");
+
+                    var projectPath = projectPathAttribute!.Value;
+
+                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);
+
+                    // Take the defining project global properties and override the configuration and platform.
+                    // It's sufficient to only set Configuration and Platform.
+                    // But we send everything to maximize the plugins' potential to quickly workaround potential MSBuild issues while the MSBuild fixes flow into VS.
+                    var globalProperties = new Dictionary<string, string>(templateGlobalProperties, StringComparer.OrdinalIgnoreCase)
+                    {
+                        ["Configuration"] = configuration,
+                        ["Platform"] = platform
+                    };
+
+                    graphEntryPoints.Add(new ProjectGraphEntryPoint(projectPath, globalProperties));
                 }
-            }
-            catch (Exception e) when (e is not ProjectCacheException)
-            {
-                HandlePluginException(e, nameof(ProjectCachePluginBase.EndBuildAsync));
-            }
-            finally
-            {
-                MSBuildEventSource.Log.ProjectCacheEndBuildStop(_projectCachePluginTypeName);
-                SetState(ProjectCacheServiceState.ShutdownFinished);
+
+                return graphEntryPoints;
             }
         }
 
-        private static void HandlePluginException(Exception e, string apiExceptionWasThrownFrom)
+        public async ValueTask DisposeAsync()
         {
-            if (ExceptionHandling.IsCriticalException(e))
+            if (_isDisposed)
             {
-                throw e;
+                return;
             }
 
-            ProjectCacheException.ThrowAsUnhandledException(
-                e,
-                "ProjectCacheException",
-                apiExceptionWasThrownFrom);
-        }
+            _isDisposed = true;
 
-        private void SetState(ProjectCacheServiceState newState)
-        {
-            lock (this)
+            if (_projectCachePlugins.IsEmpty)
+            {
+                return;
+            }
+
+            BuildEventContext buildEventContext = BuildEventContext.Invalid;
+            BuildEventFileInfo buildEventFileInfo = BuildEventFileInfo.Empty;
+            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
+                _loggingService,
+                buildEventContext,
+                buildEventFileInfo);
+
+            _loggingService.LogComment(buildEventContext, MessageImportance.Low, "ProjectCacheEndBuild");
+
+            Task[] cleanupTasks = new Task[_projectCachePlugins.Count];
+            int idx = 0;
+            foreach (KeyValuePair<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> kvp in _projectCachePlugins)
             {
-                switch (newState)
+                cleanupTasks[idx++] = Task.Run(async () =>
                 {
-                    case ProjectCacheServiceState.NotInitialized:
-                        ErrorUtilities.ThrowInternalError($"Cannot transition to {ProjectCacheServiceState.NotInitialized}");
-                        break;
-                    case ProjectCacheServiceState.BeginBuildStarted:
-                        CheckInState(ProjectCacheServiceState.NotInitialized);
-                        break;
-                    case ProjectCacheServiceState.BeginBuildFinished:
-                        CheckInState(ProjectCacheServiceState.BeginBuildStarted);
-                        break;
-                    case ProjectCacheServiceState.ShutdownStarted:
-                        CheckNotInState(ProjectCacheServiceState.ShutdownStarted);
-                        CheckNotInState(ProjectCacheServiceState.ShutdownFinished);
-                        break;
-                    case ProjectCacheServiceState.ShutdownFinished:
-                        CheckInState(ProjectCacheServiceState.ShutdownStarted);
-                        break;
-                    default:
-                        throw new ArgumentOutOfRangeException(nameof(newState), newState, null);
-                }
+                    ProjectCachePlugin plugin = await kvp.Value.Value;
 
-                _serviceState = newState;
+                    // If there is no instance, the exceptions would have bubbled up already, so skip cleanup for this one.
+                    if (plugin.Instance == null)
+                    {
+                        return;
+                    }
+
+                    MSBuildEventSource.Log.ProjectCacheEndBuildStart(plugin.Name);
+                    try
+                    {
+                        await plugin.Instance.EndBuildAsync(pluginLogger, CancellationToken.None);
+                    }
+                    catch (Exception e) when (e is not ProjectCacheException)
+                    {
+                        HandlePluginException(e, nameof(ProjectCachePluginBase.EndBuildAsync));
+                    }
+                    finally
+                    {
+                        MSBuildEventSource.Log.ProjectCacheEndBuildStop(plugin.Name);
+                    }
+                });
+            }
+
+            await Task.WhenAll(cleanupTasks);
+
+            if (pluginLogger.HasLoggedErrors)
+            {
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
             }
         }
 
-        private void CheckInState(ProjectCacheServiceState expectedState)
+        private void EnsureNotDisposed()
         {
-            lock (this)
+            if (_isDisposed)
             {
-                ErrorUtilities.VerifyThrowInternalError(_serviceState == expectedState, $"Expected state {expectedState}, actual state {_serviceState}");
+                throw new ObjectDisposedException(nameof(ProjectCacheService));
             }
         }
 
-        private void CheckNotInState(ProjectCacheServiceState unexpectedState)
+        private static void HandlePluginException(Exception e, string apiExceptionWasThrownFrom)
         {
-            lock (this)
+            if (ExceptionHandling.IsCriticalException(e))
             {
-                ErrorUtilities.VerifyThrowInternalError(_serviceState != unexpectedState, $"Unexpected state {_serviceState}");
+                throw e;
             }
+
+            ProjectCacheException.ThrowAsUnhandledException(
+                e,
+                "ProjectCacheException",
+                apiExceptionWasThrownFrom);
         }
 
         private class LoggingServiceToPluginLoggerAdapter : PluginLoggerBase
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 505bc1d2df1..32b7c6b1b1a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -15,6 +15,7 @@
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -83,7 +84,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.KeepMetadata))
                             {
-                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation).ToList();
+                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation, LoggingContext).ToList();
                                 if (keepMetadataEvaluated.Count > 0)
                                 {
                                     keepMetadata = new HashSet<string>(keepMetadataEvaluated);
@@ -92,7 +93,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.RemoveMetadata))
                             {
-                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation).ToList();
+                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation, LoggingContext).ToList();
                                 if (removeMetadataEvaluated.Count > 0)
                                 {
                                     removeMetadata = new HashSet<string>(removeMetadataEvaluated);
@@ -101,7 +102,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.MatchOnMetadata))
                             {
-                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation).ToList();
+                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation, LoggingContext).ToList();
                                 if (matchOnMetadataEvaluated.Count > 0)
                                 {
                                     matchOnMetadata = new HashSet<string>(matchOnMetadataEvaluated);
@@ -114,7 +115,7 @@ internal override void ExecuteTask(Lookup lookup)
                                 (child.Exclude.Length != 0))
                             {
                                 // It's an item -- we're "adding" items to the world
-                                ExecuteAdd(child, bucket, keepMetadata, removeMetadata);
+                                ExecuteAdd(child, bucket, keepMetadata, removeMetadata, LoggingContext);
                             }
                             else if (child.Remove.Length != 0)
                             {
@@ -124,7 +125,7 @@ internal override void ExecuteTask(Lookup lookup)
                             else
                             {
                                 // It's a modify -- changing existing items
-                                ExecuteModify(child, bucket, keepMetadata, removeMetadata);
+                                ExecuteModify(child, bucket, keepMetadata, removeMetadata, LoggingContext);
                             }
                         }
                     }
@@ -150,7 +151,8 @@ internal override void ExecuteTask(Lookup lookup)
         /// <param name="bucket">The batching bucket.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata)
+        /// <param name="loggingContext">Context for logging</param>
+        private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata, LoggingContext loggingContext = null)
         {
             // First, collect up the appropriate metadata collections.  We need the one from the item definition, if any, and
             // the one we are using for this batching bucket.
@@ -164,7 +166,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
             bucket.Expander.Metadata = metadataTable;
 
             // Second, expand the item include and exclude, and filter existing metadata as appropriate.
-            List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata);
+            List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata, loggingContext);
 
             // Third, expand the metadata.           
             foreach (ProjectItemGroupTaskMetadataInstance metadataInstance in child.Metadata)
@@ -179,11 +181,12 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     metadataInstance.Location,
                     LoggingContext.LoggingService,
                     LoggingContext.BuildEventContext,
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    loggingContext: loggingContext);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and 
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -245,7 +248,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             List<ProjectItemInstance> itemsToRemove;
             if (matchOnMetadata == null)
             {
-                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander);
+                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander, LoggingContext);
             }
             else
             {
@@ -277,7 +280,8 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
         /// <param name="bucket">The batching bucket.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata)
+        /// <param name="loggingContext">Context for this operation.</param>
+        private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata, LoggingContext loggingContext = null)
         {
             ICollection<ProjectItemInstance> group = bucket.Lookup.GetItems(child.ItemType);
             if (group == null || group.Count == 0)
@@ -317,11 +321,12 @@ private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     metadataInstance.ConditionLocation,
                     LoggingContext.LoggingService,
                     LoggingContext.BuildEventContext,
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    loggingContext: loggingContext);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
                     metadataToSet[metadataInstance.Name] = Lookup.MetadataModification.CreateFromNewValue(evaluatedValue);
                 }
             }
@@ -357,6 +362,7 @@ private void GetBatchableValuesFromBuildItemGroupChild(List<string> parameterVal
         /// <param name="expander">The expander to use.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
+        /// <param name="loggingContext">Context for logging</param>
         /// <remarks>
         /// This code is very close to that which exists in the Evaluator.EvaluateItemXml method.  However, because
         /// it invokes type constructors, and those constructors take arguments of fundamentally different types, it has not
@@ -368,7 +374,8 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             ProjectItemGroupTaskItemInstance originalItem,
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
             ISet<string> keepMetadata,
-            ISet<string> removeMetadata
+            ISet<string> removeMetadata,
+            LoggingContext loggingContext = null
         )
         {
             // todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
@@ -376,7 +383,7 @@ ISet<string> removeMetadata
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
             // Expand properties and metadata in Include
-            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation);
+            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation, loggingContext);
 
             if (evaluatedInclude.Length == 0)
             {
@@ -387,7 +394,7 @@ ISet<string> removeMetadata
             var excludes = ImmutableList<string>.Empty.ToBuilder();
             if (originalItem.Exclude.Length > 0)
             {
-                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation);
+                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation, loggingContext);
 
                 if (evaluatedExclude.Length > 0)
                 {
@@ -516,13 +523,15 @@ ISet<string> removeMetadata
         /// <param name="specification">The specification to match against the items.</param>
         /// <param name="specificationLocation">The specification to match against the provided items</param>
         /// <param name="expander">The expander to use</param>
+        /// <param name="loggingContext">Context for logging</param>
         /// <returns>A list of matching items</returns>
         private List<ProjectItemInstance> FindItemsMatchingSpecification
             (
             ICollection<ProjectItemInstance> items,
             string specification,
             ElementLocation specificationLocation,
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
+            LoggingContext loggingContext = null
             )
         {
             if (items.Count == 0 || specification.Length == 0)
@@ -535,7 +544,7 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
             HashSet<string> specificationsToFind = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             // Split by semicolons
-            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation);
+            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation, loggingContext);
 
             foreach (string piece in specificationPieces)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 49a849c4313..e1479768ff2 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -353,7 +353,8 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 _target.ConditionLocation,
                 projectLoggingContext.LoggingService,
                 projectLoggingContext.BuildEventContext,
-                FileSystems.Default);
+                FileSystems.Default,
+                loggingContext: projectLoggingContext);
 
             if (!condition)
             {
@@ -392,7 +393,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 return new List<TargetSpecification>();
             }
 
-            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation);
+            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation, projectLoggingContext);
             List<TargetSpecification> dependencyTargets = new List<TargetSpecification>();
             foreach (string escapedDependency in dependencies)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index ec05dfd174f..4835778b4c1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -381,7 +381,8 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 _targetChildInstance.ConditionLocation,
                 _targetLoggingContext.LoggingService,
                 _targetLoggingContext.BuildEventContext,
-                FileSystems.Default);
+                FileSystems.Default,
+                loggingContext: _targetLoggingContext);
 
             if (!condition)
             {
@@ -623,7 +624,7 @@ private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTas
                     if (!_targetLoggingContext.LoggingService.OnlyLogCriticalEvents)
                     {
                         // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation);
+                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation, loggingContext: _targetLoggingContext);
 
                         // Whilst we are within the processing of the task, we haven't actually started executing it, so
                         // our skip task message needs to be in the context of the target. However any errors should be reported
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 55e08dc13bd..3ef2120b037 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -84,9 +84,9 @@ public OutOfProcServerNode(BuildCallback buildFunction)
         }
 
         #region INode Members
-        
+
         /// <summary>
-        /// Starts up the node and processes messages until the node is requested to shut down.
+        /// Starts up the server node and processes all build requests until the server is requested to shut down.
         /// </summary>
         /// <param name="shutdownException">The exception which caused shutdown, if any.</param> 
         /// <returns>The reason for shutting down.</returns>
@@ -107,12 +107,32 @@ public NodeEngineShutdownReason Run(out Exception? shutdownException)
                 return NodeEngineShutdownReason.Error;
             }
 
+            while(true)
+            {
+                NodeEngineShutdownReason shutdownReason = RunInternal(out shutdownException, handshake);
+                if (shutdownReason != NodeEngineShutdownReason.BuildCompleteReuse)
+                {
+                    return shutdownReason;
+                }
+
+                // We need to clear cache for two reasons:
+                // - cache file names can collide cross build requests, which would cause stale caching
+                // - we might need to avoid cache builds-up in files system during lifetime of server
+                FileUtilities.ClearCacheDirectory();
+                _shutdownEvent.Reset();
+            }
+
+            // UNREACHABLE
+        }
+
+        private NodeEngineShutdownReason RunInternal(out Exception? shutdownException, ServerNodeHandshake handshake)
+        {
             _nodeEndpoint = new ServerNodeEndpointOutOfProc(GetPipeName(handshake), handshake);
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
             var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
-            
+
             // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
             while (true)
             {
@@ -272,12 +292,28 @@ private void HandlePacket(INodePacket packet)
                 case NodePacketType.ServerNodeBuildCommand:
                     HandleServerNodeBuildCommandAsync((ServerNodeBuildCommand)packet);
                     break;
+                case NodePacketType.NodeBuildComplete:
+                    HandleServerShutdownCommand((NodeBuildComplete)packet);
+                    break;
                 case NodePacketType.ServerNodeBuildCancel:
-                    BuildManager.DefaultBuildManager.CancelAllSubmissions();
+                    HandleBuildCancel();
                     break;
             }
         }
 
+        /// <summary>
+        /// NodeBuildComplete is used to signalize that node work is done (including server node)
+        /// and shall recycle or shutdown if PrepareForReuse is false.
+        /// </summary>
+        /// <param name="buildComplete"></param>
+        private void HandleServerShutdownCommand(NodeBuildComplete buildComplete)
+        {
+            _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
+            _shutdownEvent.Set();
+        }
+
+        private static void HandleBuildCancel() => BuildManager.DefaultBuildManager.CancelAllSubmissions();
+
         private void HandleServerNodeBuildCommandAsync(ServerNodeBuildCommand command)
         {
             Task.Run(() =>
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 6bbeea098dc..fb7c35ad18e 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1198,7 +1198,7 @@ out bool taskParameterSet
                 else
                 {
                     // Expand out all the metadata, properties, and item vectors in the string.
-                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
+                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation, _targetLoggingContext);
 
                     if (expandedParameterValue.Length == 0)
                     {
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 875be364ea0..649880df456 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -521,5 +521,22 @@ internal void Enumerate(Action<string, string> keyValueCallback)
                 }
             }
         }
+
+        internal IEnumerable<TResult> Filter<TResult>(Func<T, bool> filter, Func<T, TResult> selector)
+        {
+            List<TResult> result = new();
+            lock (_properties)
+            {
+                foreach (T property in _properties)
+                {
+                    if (filter(property))
+                    {
+                        result.Add(selector(property));
+                    }
+                }
+            }
+
+            return result;
+        }
     }
 }
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 221c938e941..7bfceeffa27 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -1013,6 +1013,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
                 traversalProject,
                 _globalProperties,
                 explicitToolsVersionSpecified ? wrapperProjectToolsVersion : null,
+                _loggingService,
                 _solutionFile.VisualStudioVersion,
                 new ProjectCollection(),
                 _sdkResolverService,
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 6fb05e271d0..294b523e07e 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2924,7 +2924,7 @@ public override bool SetGlobalProperty(string name, string escapedValue)
                     string originalValue = (existing == null) ? String.Empty : ((IProperty)existing).EvaluatedValueEscaped;
 
                     _data.GlobalPropertiesDictionary.Set(ProjectPropertyInstance.Create(name, escapedValue));
-                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, true /* is global */, false /* may not be reserved name */));
+                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, isGlobalProperty: true, mayBeReserved: false, loggingContext: null));
 
                     ProjectCollection.AfterUpdateLoadedProjectGlobalProperties(Owner);
                     MarkDirty();
@@ -4394,9 +4394,9 @@ public IItemDefinition<ProjectMetadata> GetItemDefinition(string itemType)
             /// <summary>
             /// Sets a property which is not derived from Xml.
             /// </summary>
-            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
+            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
             {
-                ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+                ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext);
                 Properties.Set(property);
 
                 AddToAllEvaluatedPropertiesList(property);
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index b3e808c3c9a..157fc4366ec 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -3,8 +3,10 @@
 
 using System;
 using System.Diagnostics;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
@@ -94,7 +96,18 @@ public string EvaluatedValue
         string IProperty.EvaluatedValueEscaped
         {
             [DebuggerStepThrough]
-            get => EvaluatedValueEscapedInternal;
+            get
+            {
+                if (this is EnvironmentDerivedProjectProperty environmentProperty && environmentProperty.loggingContext is { IsValid: true } loggingContext && !environmentProperty._loggedEnvProperty)
+                {
+                    EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal);
+                    args.BuildEventContext = loggingContext.BuildEventContext;
+                    loggingContext.LogBuildEvent(args);
+                    environmentProperty._loggedEnvProperty = true;
+                }
+
+                return EvaluatedValueEscapedInternal;
+            }
         }
 
         /// <summary>
@@ -237,9 +250,10 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
         /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
         /// All other properties originate in XML, and should have a backing XML object.
         /// </summary>
-        internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
+        internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext = null)
         {
-            return new ProjectPropertyNotXmlBacked(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+            return !isGlobalProperty && !mayBeReserved ? new EnvironmentDerivedProjectProperty(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext) :
+                new ProjectPropertyNotXmlBacked(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
         }
 
         /// <summary>
@@ -628,5 +642,18 @@ public override bool IsImported
                 get { return false; }
             }
         }
+
+        private class EnvironmentDerivedProjectProperty : ProjectPropertyNotXmlBacked
+        {
+            internal bool _loggedEnvProperty = false;
+            internal LoggingContext loggingContext;
+
+            internal EnvironmentDerivedProjectProperty(
+                Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext)
+                : base(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved)
+            {
+                this.loggingContext = loggingContext;
+            }
+        }
     }
 }
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 31dd956ed2e..183ce5117d6 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -17,6 +17,7 @@ namespace Microsoft.Build.Evaluation
     using ElementLocation = Microsoft.Build.Construction.ElementLocation;
     using Microsoft.Build.Shared;
     using Microsoft.Build.Shared.FileSystem;
+    using Microsoft.Build.BackEnd.Logging;
 
     internal static class ConditionEvaluator
     {
@@ -181,7 +182,8 @@ internal static bool EvaluateCondition<P, I>
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null)
+            ProjectRootElementCacheBase projectRootElementCache = null,
+            LoggingContext loggingContext = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -196,7 +198,8 @@ internal static bool EvaluateCondition<P, I>
                 loggingServices,
                 buildEventContext,
                 fileSystem,
-                projectRootElementCache);
+                projectRootElementCache,
+                loggingContext);
         }
 
         /// <summary>
@@ -218,7 +221,8 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null
+            ProjectRootElementCacheBase projectRootElementCache = null,
+            LoggingContext loggingContext = null
         )
             where P : class, IProperty
             where I : class, IItem
@@ -279,7 +283,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             {
                 try
                 {
-                    result = parsedExpression.Evaluate(state);
+                    result = parsedExpression.Evaluate(state, loggingContext);
                 }
                 finally
                 {
@@ -353,7 +357,7 @@ internal interface IConditionEvaluationState
             ///     May return null if the expression would expand to non-empty and it broke out early.
             ///     Otherwise, returns the correctly expanded expression.
             /// </summary>
-            string ExpandIntoStringBreakEarly(string expression);
+            string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null);
 
             /// <summary>
             ///     Expands the specified expression into a list of TaskItem's.
@@ -363,7 +367,7 @@ internal interface IConditionEvaluationState
             /// <summary>
             ///     Expands the specified expression into a string.
             /// </summary>
-            string ExpandIntoString(string expression);
+            string ExpandIntoString(string expression, LoggingContext loggingContext = null);
 
             /// <summary>
             ///     PRE cache
@@ -440,11 +444,11 @@ internal ConditionEvaluationState
             /// May return null if the expression would expand to non-empty and it broke out early.
             /// Otherwise, returns the correctly expanded expression.
             /// </summary>
-            public string ExpandIntoStringBreakEarly(string expression)
+            public string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation);
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation, loggingContext);
 
                 _expander.WarnForUninitializedProperties = originalValue;
 
@@ -471,12 +475,13 @@ public IList<TaskItem> ExpandIntoTaskItems(string expression)
             /// Expands the specified expression into a string.
             /// </summary>
             /// <param name="expression">The expression to expand.</param>
+            /// <param name="loggingContext"></param>
             /// <returns>The expanded string.</returns>
-            public string ExpandIntoString(string expression)
+            public string ExpandIntoString(string expression, LoggingContext loggingContext = null)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation);
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation, loggingContext);
 
                 _expander.WarnForUninitializedProperties = originalValue;
 
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index 94513436e9c..47481c625c3 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -18,9 +19,9 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
@@ -37,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                          state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index e0b57181361..4ec222243fd 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -29,7 +30,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// <summary>
         /// Evaluate node as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index d6007133404..50efb172cf7 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -14,9 +14,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
-        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
-        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -25,7 +25,7 @@ internal abstract class GenericExpressionNode
         /// to empty than to fully evaluate it.)
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
+        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             return false;
         }
@@ -34,7 +34,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state);
+        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
 
         /// <summary>
         /// Value before any item and property expressions are expanded
@@ -52,16 +52,17 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// The main evaluate entry point for expression trees
         /// </summary>
         /// <param name="state"></param>
+        /// <param name="loggingContext"></param>
         /// <returns></returns>
-        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!TryBoolEvaluate(state, out bool boolValue))
+            if (!TryBoolEvaluate(state, out bool boolValue, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ConditionNotBooleanDetail",
                     state.Condition,
-                    GetExpandedValue(state));
+                    GetExpandedValue(state, loggingContext));
             }
 
             return boolValue;
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 65e23c7718f..1ef13748bdc 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -36,7 +37,7 @@ internal abstract class MultipleComparisonNode : OperatorExpressionNode
         /// Order in which comparisons are attempted is numeric, boolean, then string.
         /// Updates conditioned properties table.
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext)
         {
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (LeftChild != null && RightChild != null,
@@ -50,8 +51,8 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' " 
             // which is a performance advantage if @(X) is a huge item list.
-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
-            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);
             if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
@@ -68,13 +69,13 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 // is 17.0).
                 return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue, loggingContext) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue, loggingContext))
             {
                 return Compare(leftBoolValue, rightBoolValue);
             }
 
-            string leftExpandedValue = LeftChild.GetExpandedValue(state);
-            string rightExpandedValue = RightChild.GetExpandedValue(state);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state, loggingContext);
+            string rightExpandedValue = RightChild.GetExpandedValue(state, loggingContext);
 
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (leftExpandedValue != null && rightExpandedValue != null,
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index e5b00ac781a..1d2e1d6311e 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -18,9 +19,9 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
@@ -44,9 +45,9 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Returns expanded value with '!' prepended. Useful for error messages.
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            return "!" + LeftChild.GetExpandedValue(state);
+            return "!" + LeftChild.GetExpandedValue(state, loggingContext);
         }
 
         internal override string DebuggerDisplay => $"(not {LeftChild.DebuggerDisplay})";
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index 02c242ceef5..f161ad5d18b 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -38,7 +38,7 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
             bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
@@ -53,7 +53,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     state.Condition,
                     /* helpfully display unexpanded token and expanded result in error message */
                     isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
+                    isLeftNum ? RightChild.GetExpandedValue(state, loggingContext) : LeftChild.GetExpandedValue(state, loggingContext));
             }
 
             return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index 66fa552443d..7725d9962dc 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -3,7 +3,7 @@
 
 using System;
 using System.Diagnostics;
-
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -23,18 +23,18 @@ internal NumericExpressionNode(string value)
             _value = value;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
         {
             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
         {
             return Version.TryParse(_value, out result);
         }
@@ -50,7 +50,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Get the expanded value
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             return _value;
         }
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index c6e4b4c349c..a3f76ff20ff 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -12,21 +13,21 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
         {
-            result = BoolEvaluate(state);
+            result = BoolEvaluate(state, loggingContext);
             return true;
         }
 
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
         {
             result = default;
             return false;
@@ -36,7 +37,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             return null;
         }
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index 250e8c9602c..fa1816c2e1d 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -18,15 +19,15 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ExpressionDoesNotEvaluateToBoolean",
                     LeftChild.GetUnexpandedValue(state),
-                    LeftChild.GetExpandedValue(state),
+                    LeftChild.GetExpandedValue(state, loggingContext),
                     state.Condition);
             }
 
@@ -37,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                         state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 7017b0b5023..43dd324e7a8 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Diagnostics;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -30,34 +31,34 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
         {
-            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state, loggingContext), out result);
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
             {
                 result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state, loggingContext), out result);
             }
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
             {
                 result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return Version.TryParse(GetExpandedValue(state), out result);
+                return Version.TryParse(GetExpandedValue(state, loggingContext), out result);
             }
         }
 
@@ -68,7 +69,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// to empty than to fully evaluate it.
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (_cachedExpandedValue == null)
             {
@@ -93,7 +94,7 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
                             break;
                     }
 
-                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
+                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value, loggingContext);
 
                     if (expandBreakEarly == null)
                     {
@@ -129,13 +130,13 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (_cachedExpandedValue == null)
             {
                 if (_expandable)
                 {
-                    _cachedExpandedValue = state.ExpandIntoString(_value);
+                    _cachedExpandedValue = state.ExpandIntoString(_value, loggingContext);
                 }
                 else
                 {
@@ -168,7 +169,7 @@ internal override void ResetState()
         /// but now cause the project to throw InvalidProjectException when
         /// ToolsVersion is "Current". https://github.com/dotnet/msbuild/issues/4150
         /// </remarks>
-        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state)
+        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (!_shouldBeTreatedAsVisualStudioVersion.HasValue)
             {
@@ -176,7 +177,7 @@ private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionE
 
                 // Do this check first, because if it's not (common) we can early-out and the next
                 // expansion will be cheap because this will populate the cached expanded value.
-                if (string.Equals(GetExpandedValue(state), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
+                if (string.Equals(GetExpandedValue(state, loggingContext), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
                 {
                     // and it is just an expansion of MSBuildToolsVersion
                     _shouldBeTreatedAsVisualStudioVersion = string.Equals(_value, "$(MSBuildToolsVersion)", StringComparison.OrdinalIgnoreCase);
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index b3154221e9f..900060c0a48 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
@@ -25,13 +24,15 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
-using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
-using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
+using static Microsoft.Build.Execution.ProjectPropertyInstance;
 using Constants = Microsoft.Build.Internal.Constants;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
+using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
+using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
+using ObjectModel = System.Collections.ObjectModel;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using SdkReferencePropertyExpansionMode = Microsoft.Build.Framework.EscapeHatches.SdkReferencePropertyExpansionMode;
+using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 
 #nullable disable
 
@@ -767,7 +768,7 @@ private void Evaluate()
 
                     if (BuildEnvironmentHelper.Instance.RunningInVisualStudio)
                     {
-                        // TODO: Remove this when VS gets updated to setup project cache plugins.
+                        // TODO: Figure out a more elegant way to do this. See the comment on BuildManager.ProjectCacheDescriptors for explanation.
                         CollectProjectCachePlugins();
                     }
 
@@ -811,24 +812,38 @@ private void Evaluate()
             if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
             {
                 globalProperties = _data.GlobalPropertiesDictionary;
-                properties = _data.Properties;
+                properties = Traits.LogAllEnvironmentVariables ? _data.Properties : FilterOutEnvironmentDerivedProperties(_data.Properties);
                 items = _data.Items;
             }
 
             _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);
         }
 
-        private void CollectProjectCachePlugins()
+        private IEnumerable FilterOutEnvironmentDerivedProperties(PropertyDictionary<P> dictionary)
         {
-            foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))
+            List<P> list = new(dictionary.Count);
+            foreach (P p in dictionary)
             {
-                var metadataDictionary = item.Metadata.ToDictionary(m => m.Key, m => m.EscapedValue);
+                if (p is EnvironmentDerivedProjectPropertyInstance ||
+                    (p is ProjectProperty pp && pp.IsEnvironmentProperty))
+                {
+                    continue;
+                }
 
-                var pluginPath = Path.Combine(_data.Directory, item.EvaluatedInclude);
+                list.Add(p);
+            }
 
-                var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);
+            return list;
+        }
 
-                BuildManager.ProjectCacheItems[pluginPath] = projectCacheItem;
+        private void CollectProjectCachePlugins()
+        {
+            foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))
+            {
+                string pluginPath = FileUtilities.NormalizePath(_data.Directory, item.EvaluatedInclude);
+                var pluginSettings = item.Metadata.ToDictionary(m => m.Key, m => m.EscapedValue);
+                var projectCacheItem = ProjectCacheDescriptor.FromAssemblyPath(pluginPath, pluginSettings);
+                BuildManager.ProjectCacheDescriptors.TryAdd(projectCacheItem, projectCacheItem);
             }
         }
 
@@ -842,12 +857,12 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
             using (_evaluationProfiler.TrackFile(currentProjectOrImport.FullPath))
             {
                 // We accumulate InitialTargets from the project and each import
-                var initialTargets = _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.InitialTargets, ExpanderOptions.ExpandProperties, currentProjectOrImport.InitialTargetsLocation);
+                var initialTargets = _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.InitialTargets, ExpanderOptions.ExpandProperties, currentProjectOrImport.InitialTargetsLocation, _evaluationLoggingContext);
                 _initialTargetsList.AddRange(initialTargets);
 
                 if (!Traits.Instance.EscapeHatches.IgnoreTreatAsLocalProperty)
                 {
-                    foreach (string propertyName in _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.TreatAsLocalProperty, ExpanderOptions.ExpandProperties, currentProjectOrImport.TreatAsLocalPropertyLocation))
+                    foreach (string propertyName in _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.TreatAsLocalProperty, ExpanderOptions.ExpandProperties, currentProjectOrImport.TreatAsLocalPropertyLocation, _evaluationLoggingContext))
                     {
                         XmlUtilities.VerifyThrowProjectValidElementName(propertyName, currentProjectOrImport.Location);
                         _data.GlobalPropertiesToTreatAsLocal.Add(propertyName);
@@ -1051,8 +1066,8 @@ private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<Pr
         /// </summary>
         private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets, Dictionary<string, List<TargetSpecification>> targetsWhichRunBeforeByTarget, Dictionary<string, List<TargetSpecification>> targetsWhichRunAfterByTarget)
         {
-            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation);
-            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation);
+            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation, _evaluationLoggingContext);
+            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation, _evaluationLoggingContext);
 
             foreach (string beforeTarget in beforeTargets)
             {
@@ -1197,7 +1212,7 @@ private void AddEnvironmentProperties()
         {
             foreach (ProjectPropertyInstance environmentProperty in _environmentProperties)
             {
-                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true);
+                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true, loggingContext: _evaluationLoggingContext);
             }
         }
 
@@ -1298,7 +1313,7 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                 // it is the same as what we are setting the value on. Note: This needs to be set before we expand the property we are currently setting.
                 _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
 
-                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location);
+                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location, _evaluationLoggingContext);
 
                 // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
                 // during evaluation.
@@ -2003,7 +2018,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
         {
             imports = null;
 
-            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
+            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation, _evaluationLoggingContext);
             ElementLocation importLocationInProject = importElement.Location;
 
             if (String.IsNullOrWhiteSpace(importExpressionEscaped))
@@ -2428,7 +2443,8 @@ private bool EvaluateCondition(ProjectElement element, string condition, Expande
                     element.ConditionLocation,
                     _evaluationLoggingContext.LoggingService,
                     _evaluationLoggingContext.BuildEventContext,
-                    _evaluationContext.FileSystem
+                    _evaluationContext.FileSystem,
+                    loggingContext: _evaluationLoggingContext
                     );
 
                 return result;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 9bc57cab1ed..88e5fea6c1b 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -26,6 +26,7 @@
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
 
 using Microsoft.NET.StringTools;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -418,9 +419,9 @@ internal static bool ExpressionContainsItemVector(string expression)
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation)
+        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
         {
-            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation);
+            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext);
 
             return (result == null) ? null : EscapingUtilities.UnescapeAll(result);
         }
@@ -432,7 +433,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
+        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
         {
             if (expression.Length == 0)
             {
@@ -442,7 +443,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
+            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
 
@@ -472,11 +473,11 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
+        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
         {
             ErrorUtilities.VerifyThrow((options & ExpanderOptions.BreakOnNotEmpty) == 0, "not supported");
 
-            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation));
+            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext));
         }
 
         /// <summary>
@@ -1076,7 +1077,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem)
+                IFileSystem fileSystem,
+                LoggingContext loggingContext = null)
             {
                 return
                     ConvertToString(
@@ -1086,7 +1088,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                             options,
                             elementLocation,
                             usedUninitializedProperties,
-                            fileSystem));
+                            fileSystem,
+                            loggingContext));
             }
 
             /// <summary>
@@ -1112,7 +1115,8 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem)
+                IFileSystem fileSystem,
+                LoggingContext loggingContext = null)
             {
                 if (((options & ExpanderOptions.ExpandProperties) == 0) || String.IsNullOrEmpty(expression))
                 {
@@ -1226,7 +1230,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         }
                         else // This is a regular property
                         {
-                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties);
+                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties, loggingContext);
                         }
 
                         if (propertyValue != null)
@@ -1464,7 +1468,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)
             {
                 T property = properties.GetProperty(propertyName, startIndex, endIndex);
 
@@ -1509,6 +1513,11 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 }
                 else
                 {
+                    if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)
+                    {
+                        environmentDerivedProperty.loggingContext = loggingContext;
+                    }
+
                     propertyValue = property.EvaluatedValueEscaped;
                 }
 
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index cf0b17d457f..497207e7024 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -267,7 +267,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false);
+        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null);
 
         /// <summary>
         /// Sets a property which comes from the Xml.
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 65c1fd8b486..d7f58c8088a 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -156,21 +157,23 @@ private bool InitReferencedItemsIfNecessary()
         /// <param name="itemSpecLocation">The xml location the itemspec comes from</param>
         /// <param name="projectDirectory">The directory that the project is in.</param>
         /// <param name="expandProperties">Expand properties before breaking down fragments. Defaults to true</param>
+        /// <param name="loggingContext">Context in which to log</param>
         public ItemSpec(
             string itemSpec,
             Expander<P, I> expander,
             IElementLocation itemSpecLocation,
             string projectDirectory,
-            bool expandProperties = true)
+            bool expandProperties = true,
+            LoggingContext loggingContext = null)
         {
             ItemSpecString = itemSpec;
             Expander = expander;
             ItemSpecLocation = itemSpecLocation;
 
-            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties);
+            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties, loggingContext);
         }
 
-        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
+        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties, LoggingContext loggingContext)
         {
             // Code corresponds to Evaluator.CreateItemsFromInclude
             var evaluatedItemspecEscaped = ItemSpecString;
@@ -186,7 +189,8 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                 evaluatedItemspecEscaped = Expander.ExpandIntoStringLeaveEscaped(
                     ItemSpecString,
                     ExpanderOptions.ExpandProperties,
-                    itemSpecLocation);
+                    itemSpecLocation,
+                    loggingContext);
             }
 
             var semicolonCount = 0;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 0255a8fbf2d..ecae588cd20 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -307,9 +308,9 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
                 return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped);
             }
 
-            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
+            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, LoggingContext loggingContext = null)
             {
-                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext: loggingContext);
             }
         }
     }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index f78cc28be71..f0c19a5c681 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -262,7 +262,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                                 continue;
                             }
 
-                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location);
+                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location, _lazyEvaluator._loggingContext);
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 28fe97350da..871ad820e6a 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -99,7 +99,8 @@ LazyItemEvaluator<P, I, M, D> lazyEvaluator
                     element.ConditionLocation,
                     lazyEvaluator._loggingContext.LoggingService,
                     lazyEvaluator._loggingContext.BuildEventContext,
-                    lazyEvaluator.FileSystem
+                    lazyEvaluator.FileSystem,
+                    loggingContext: lazyEvaluator._loggingContext
                     );
                 MSBuildEventSource.Log.EvaluateConditionStop(condition, result);
 
@@ -624,7 +625,7 @@ private RemoveOperation BuildRemoveOperation(string rootDirectory, ProjectItemEl
 
         private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLocation itemSpecLocation, OperationBuilder builder)
         {
-            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory);
+            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory, loggingContext: _loggingContext);
 
             foreach (ItemSpecFragment fragment in builder.ItemSpec.Fragments)
             {
@@ -635,7 +636,7 @@ private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLoca
             }
         }
 
-        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander)
+        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander, LoggingContext loggingContext = null)
         {
             // Since we're just attempting to expand properties in order to find referenced items and not expanding metadata,
             // unexpected errors may occur when evaluating property functions on unexpanded metadata. Just ignore them if that happens.
@@ -649,7 +650,8 @@ private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(IColle
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Value,
                     expanderOptions,
-                    metadatumElement.Location);
+                    metadatumElement.Location,
+                    loggingContext);
 
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Condition,
@@ -664,7 +666,7 @@ private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBu
             {
                 operationBuilder.Metadata.AddRange(itemElement.Metadata);
 
-                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander));
+                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander, _loggingContext));
                 if (itemsAndMetadataFound.Items != null)
                 {
                     foreach (var itemType in itemsAndMetadataFound.Items)
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index da81aaf21b5..b113e73a6ec 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -79,10 +79,10 @@ public P GetProperty(string name, int startIndex, int endIndex)
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
+        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
         {
             P originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, loggingContext);
 
             this.TrackPropertyWrite(
                 originalProperty,
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 94344843b96..3a253dbc5a8 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -470,6 +470,21 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
             Initialize(xml, globalProperties, toolsVersion, null, visualStudioVersionFromSolution, new BuildParameters(projectCollection), projectCollection.LoggingService, buildEventContext, sdkResolverService, submissionId);
         }
 
+        /// <summary>
+        /// Initializes a new instance of the <see cref="ProjectInstance"/> class directly.
+        /// No intermediate Project object is created.
+        /// This is ideal if the project is simply going to be built, and not displayed or edited.
+        /// Global properties may be null.
+        /// Tools version may be null.
+        /// Used by SolutionProjectGenerator so that it can explicitly pass the vsVersionFromSolution in for use in
+        /// determining the sub-toolset version.
+        /// </summary>
+        internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, ILoggingService loggingService, int visualStudioVersionFromSolution, ProjectCollection projectCollection, ISdkResolverService sdkResolverService, int submissionId)
+        {
+            BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+            Initialize(xml, globalProperties, toolsVersion, null, visualStudioVersionFromSolution, new BuildParameters(projectCollection), loggingService, buildEventContext, sdkResolverService, submissionId);
+        }
+
         /// <summary>
         /// Creates a mutable ProjectInstance directly, using the specified logging service.
         /// Assumes the project path is already normalized.
@@ -1475,10 +1490,10 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// immutable if we are immutable.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, LoggingContext loggingContext)
         {
             // Mutability not verified as this is being populated during evaluation
-            ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable);
+            ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable, isEnvironmentVariable, loggingContext);
             _properties.Set(property);
             return property;
         }
@@ -2966,7 +2981,7 @@ private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, b
             {
                 // Allow reserved property names, since this is how they are added to the project instance. 
                 // The caller has prevented users setting them themselves.
-                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable);
+                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable, property.IsEnvironmentProperty);
                 _properties.Set(instance);
             }
         }
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index e935b611067..c6fd6293e5d 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -10,6 +10,8 @@
 using Microsoft.Build.BackEnd;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -84,8 +86,21 @@ public string EvaluatedValue
         /// Setter assumes caller has protected global properties, if necessary.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        string IProperty.EvaluatedValueEscaped => _escapedValue;
-
+        string IProperty.EvaluatedValueEscaped
+        {
+            get
+            {
+                if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty)
+                {
+                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);
+                    args.BuildEventContext = envProperty.loggingContext.BuildEventContext;
+                    envProperty.loggingContext.LogBuildEvent(args);
+                    envProperty._loggedEnvProperty = true;
+                }
+
+                return _escapedValue;
+            }
+        }
         /// <summary>
         /// Implementation of IKeyed exposing the property name
         /// </summary>
@@ -182,9 +197,9 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue,
         /// This flags should ONLY be set by the evaluator or by cloning; after the ProjectInstance is created, they must be illegal.
         /// If name is invalid or reserved, throws ArgumentException.
         /// </summary>
-        internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable)
+        internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable, bool isEnvironmentProperty = false, LoggingContext loggingContext = null)
         {
-            return Create(name, escapedValue, mayBeReserved, null, isImmutable);
+            return Create(name, escapedValue, mayBeReserved, null, isImmutable, isEnvironmentProperty, loggingContext);
         }
 
         /// <summary>
@@ -212,7 +227,7 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue,
         /// </summary>
         internal static ProjectPropertyInstance Create(ProjectPropertyInstance that)
         {
-            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: that.IsImmutable);
+            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: that.IsImmutable, that is EnvironmentDerivedProjectPropertyInstance);
         }
 
         /// <summary>
@@ -221,7 +236,7 @@ internal static ProjectPropertyInstance Create(ProjectPropertyInstance that)
         /// </summary>
         internal static ProjectPropertyInstance Create(ProjectPropertyInstance that, bool isImmutable)
         {
-            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: isImmutable);
+            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: isImmutable, that is EnvironmentDerivedProjectPropertyInstance);
         }
 
         /// <summary>
@@ -278,7 +293,7 @@ internal ProjectPropertyElement ToProjectPropertyElement(ProjectElementContainer
         /// as it should never be needed for any subsequent messages, and is just extra bulk.
         /// Inherits mutability from project if any.
         /// </summary>
-        private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable)
+        private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable, bool isEnvironmentProperty = false, LoggingContext loggingContext = null)
         {
             // Does not check immutability as this is only called during build (which is already protected) or evaluation
             ErrorUtilities.VerifyThrowArgumentNull(escapedValue, nameof(escapedValue));
@@ -295,11 +310,10 @@ private static ProjectPropertyInstance Create(string name, string escapedValue,
                 XmlUtilities.VerifyThrowProjectValidElementName(name, location);
             }
 
-            if (isImmutable)
-            {
-                return new ProjectPropertyInstanceImmutable(name, escapedValue);
-            }
-            return new ProjectPropertyInstance(name, escapedValue);
+            ProjectPropertyInstance instance = isEnvironmentProperty ? new EnvironmentDerivedProjectPropertyInstance(name, escapedValue, loggingContext) :
+                isImmutable ? new ProjectPropertyInstanceImmutable(name, escapedValue) :
+                new ProjectPropertyInstance(name, escapedValue);
+            return instance;
         }
 
         /// <summary>
@@ -327,5 +341,27 @@ internal ProjectPropertyInstanceImmutable(string name, string escapedValue)
             /// </remarks>
             public override bool IsImmutable => true;
         }
+
+        internal class EnvironmentDerivedProjectPropertyInstance : ProjectPropertyInstance
+        {
+            internal EnvironmentDerivedProjectPropertyInstance(string name, string escapedValue, LoggingContext loggingContext)
+                : base(name, escapedValue)
+            {
+                this.loggingContext = loggingContext;
+            }
+
+            /// <summary>
+            /// Whether this object can be changed. An immutable object cannot be made mutable.
+            /// </summary>
+            /// <remarks>
+            /// The environment is captured at the start of the build, so environment-derived
+            /// properties can't change.
+            /// </remarks>
+            public override bool IsImmutable => true;
+
+            internal bool _loggedEnvProperty = false;
+
+            internal LoggingContext loggingContext;
+        }
     }
 }
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index b17d74baa50..5d5c32727de 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -905,7 +905,7 @@ public int Compare(object o1, object o2)
 
         public virtual void Shutdown()
         {
-            // do nothing
+            Traits.LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES")) && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4);
         }
 
         internal abstract void ResetConsoleLoggerState();
@@ -1015,6 +1015,7 @@ internal virtual bool ApplyParameter(string parameterName, string parameterValue
                     return true;
                 case "SHOWENVIRONMENT":
                     showEnvironment = true;
+                    Traits.LogAllEnvironmentVariables = true;
                     return true;
                 case "SHOWPROJECTFILE":
                     if (parameterValue == null)
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 7c0fe5bfc58..941cfccfc06 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -4,18 +4,14 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
 using System.IO;
-using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -251,7 +247,14 @@ private void Write(BuildStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.BuildStarted);
             WriteBuildEventArgsFields(e);
-            Write(e.BuildEnvironment);
+            if (Traits.LogAllEnvironmentVariables)
+            {
+                Write(e.BuildEnvironment);
+            }
+            else
+            {
+                Write(0);
+            }
         }
 
         private void Write(BuildFinishedEventArgs e)
@@ -518,7 +521,8 @@ private void Write(TaskParameterEventArgs e)
             Write((int)e.Kind);
             WriteDeduplicatedString(e.ItemType);
             WriteTaskItemList(e.Items, e.LogItemMetadata);
-            if (e.Kind == TaskParameterMessageKind.AddItem)
+            if (e.Kind == TaskParameterMessageKind.AddItem
+               || e.Kind == TaskParameterMessageKind.TaskOutput)
             {
                 CheckForFilesToEmbed(e.ItemType, e.Items);
             }
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 1833201110c..6e16da044d7 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -231,7 +231,10 @@ public override void BuildStartedHandler(object sender, BuildStartedEventArgs e)
                 WriteLinePrettyFromResource("BuildStartedWithTime", e.Timestamp);
             }
 
-            WriteEnvironment(e.BuildEnvironment);
+            if (Traits.LogAllEnvironmentVariables)
+            {
+                WriteEnvironment(e.BuildEnvironment);
+            }
         }
 
         /// <summary>
@@ -1204,16 +1207,21 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
         /// </summary>
         private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
         {
-            string nonNullMessage;
+            string nonNullMessage = null;
+
+            if (e is EnvironmentVariableReadEventArgs environmentPropertyReadEventArgs)
+            {
+                nonNullMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentPropertyReadEventArgs.EnvironmentVariableName, e.Message);
+            }
 
             // Include file information if present.
             if (e.File != null)
             {
-                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e));
+                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e), nonNullMessage);
             }
             else
             {
-                nonNullMessage = e.Message ?? string.Empty;
+                nonNullMessage ??= e.Message ?? string.Empty;
             }
 
             int prefixAdjustment = 0;
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index e677526406b..bbfc1978a44 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -108,7 +108,10 @@ public override void BuildStartedHandler(object sender, BuildStartedEventArgs e)
                 WriteLinePrettyFromResource("BuildStartedWithTime", e.Timestamp);
             }
 
-            WriteEnvironment(e.BuildEnvironment);
+            if (Traits.LogAllEnvironmentVariables)
+            {
+                WriteEnvironment(e.BuildEnvironment);
+            }
         }
 
         /// <summary>
@@ -511,18 +514,15 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                     setColor(ConsoleColor.DarkGray);
                 }
 
-                string nonNullMessage;
+                string nonNullMessage = e is EnvironmentVariableReadEventArgs environmentDerivedProperty ?
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentDerivedProperty.EnvironmentVariableName, e.Message)
+                    : e.Message ?? String.Empty;
 
                 // Include file information if present.
                 if (e.File != null)
                 {
                     nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile);
                 }
-                else
-                {
-                    // null messages are ok -- treat as blank line
-                    nonNullMessage = e.Message ?? String.Empty;
-                }
 
                 WriteLinePretty(nonNullMessage);
 
diff --git a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
index a4ec0aaf92d..b006f76520c 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
@@ -1335,12 +1335,9 @@ Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> M
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.EntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.GetDetailedDescription() -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
@@ -1786,8 +1783,8 @@ static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Mi
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
 static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
 static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
 static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
@@ -1836,4 +1833,4 @@ virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
\ No newline at end of file
+virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
index a8ca12cca99..47780d37b51 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -18,3 +18,4 @@ Microsoft.Build.Experimental.OutOfProcServerNode
 Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback
 Microsoft.Build.Experimental.OutOfProcServerNode.OutOfProcServerNode(Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback buildFunction) -> void
 Microsoft.Build.Experimental.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+static Microsoft.Build.Experimental.MSBuildClient.ShutdownServer(System.Threading.CancellationToken cancellationToken) -> bool
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
index 93740b15de2..38f8853c43d 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -1335,12 +1335,9 @@ Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> M
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.EntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.GetDetailedDescription() -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
@@ -1786,8 +1783,8 @@ static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Mi
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
 static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
 static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
 static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
@@ -1836,4 +1833,4 @@ virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
\ No newline at end of file
+virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index aa42c2c0ede..42acd772719 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -18,4 +18,5 @@ Microsoft.Build.Experimental.OutOfProcServerNode
 Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback
 Microsoft.Build.Experimental.OutOfProcServerNode.OutOfProcServerNode(Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback buildFunction) -> void
 Microsoft.Build.Experimental.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+static Microsoft.Build.Experimental.MSBuildClient.ShutdownServer(System.Threading.CancellationToken cancellationToken) -> bool
 
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 10018e5f8f1..55995f61c7e 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -142,6 +142,9 @@
   <data name="WaitingForEndOfBuild" xml:space="preserve">
     <value>The operation cannot be completed because EndBuild has already been called but existing submissions have not yet completed.</value>
   </data>
+  <data name="EnvironmentDerivedPropertyRead">
+    <value>Property '{0}' with value '{1}' expanded from the environment.</value>
+  </data>
   <data name="SubmissionAlreadyComplete" xml:space="preserve">
     <value>The operation cannot be completed because the submission has already been executed.</value>
   </data>
@@ -1877,15 +1880,11 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</value>
   </data>
   <data name="LoadingProjectCachePlugin" xml:space="preserve">
-    <value>Loading the following project cache plugin:
-    {0}</value>
+    <value>Loading the following project cache plugin: {0}</value>
   </data>
   <data name="SolutionPathPropertyMustBeSetOnVSSubmissions" xml:space="preserve">
     <value>"MSB4264: Invalid $(SolutionPath) property: {0}"</value>
   </data>
-  <data name="OnlyOneCachePluginMustBeSpecified" xml:space="preserve">
-    <value>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</value>
-  </data>
   <data name="ProjectCacheInitializationFailed" xml:space="preserve">
     <value>MSB4266: Failed to initialize the project cache.</value>
   </data>
@@ -1895,9 +1894,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProjectCacheShutdownFailed" xml:space="preserve">
     <value>MSB4268: The project cache failed to shut down properly.</value>
   </data>
-  <data name="NotAllNodesDefineACacheItem" xml:space="preserve">
-    <value>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</value>
-  </data>
   <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
     <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
@@ -1910,9 +1906,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProxyRequestNotScheduledOnInprocNode" xml:space="preserve">
     <value>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</value>
   </data>
-  <data name="ProjectCacheBeginBuild" xml:space="preserve">
-    <value>Initializing project cache plugin.</value>
-  </data>
   <data name="ProjectCacheEndBuild" xml:space="preserve">
     <value>Shutting down project cache plugin.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index bc4f28a26e1..2481e430a40 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Zadaný výstupní soubor mezipaměti pro výsledky je prázdný.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Číst proměnnou prostředí {0}</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Načítá se následující modul plug-in mezipaměti projektu:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Načítá se následující modul plug-in mezipaměti projektu:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: V sestavení {0} se nenašly žádné moduly plug-in mezipaměti projektu. Modul plug-in se očekával.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Pokud jakýkoli uzel statického grafu definuje mezipaměť projektu, musí všechny uzly definovat stejnou mezipaměť projektu. Následující projekty neobsahují deklaraci položky {0}: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Požadované sestavení NuGet se nenašlo. Očekávaná cesta: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Metoda {0} se nedá zavolat s kolekcí, která obsahuje prázdné cílové názvy nebo názvy null.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Musí se zadat jeden modul plug-in mezipaměti projektu, ale našlo se jich více: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Vytvořilo se přepsání pomocí úlohy: {0} v {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicializuje se modul plug-in mezipaměti projektu.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Vypíná se modul plug-in mezipaměti projektu.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 2d5371cd4e4..2cedb2c72a9 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Die angegebene Cachedatei für Ausgabeergebnisse ist leer.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Umgebungsvariable "{0}" lesen</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Folgendes Projektcache-Plug-In wird geladen:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Folgendes Projektcache-Plug-In wird geladen:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: In der Assembly "{0}" wurde ein Projektcache-Plug-In erwartet, aber keines gefunden.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Wenn ein statischer Graphknoten einen Projektcache definiert, müssen alle Knoten denselben Projektcache definieren. Die folgenden Projekte enthalten keine Deklaration des Elements "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Die Methode "{0}" kann nicht mit einer Sammlung aufgerufen werden, die NULL oder leere Zielnamen enthält.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Ein einzelnes Projektcache-Plug-In muss angegeben werden, es wurden jedoch mehrere gefunden: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Außerkraftsetzung mit Task erstellt: {0} bei {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Das Projektcache-Plug-in wird initialisiert.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Das Projektcache-Plug-in wird heruntergefahren.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ae8a6a1e189..8eb98128194 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: El archivo de caché de resultados de salida especificado está vacío.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Leer la variable de entorno "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Cargando el complemento de caché de proyectos siguiente:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Cargando el complemento de caché de proyectos siguiente:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: No se encontró ningún complemento de caché de proyectos en el ensamblado "{0}". Se esperaba uno.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Cuando un nodo de gráfico estático define una memoria caché de proyectos, todos los nodos deben definir la misma caché de proyectos. Los proyectos siguientes no contienen ninguna declaración de elemento "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">No se encontró un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">No se puede llamar al método {0} con una colección que contiene nombres de destino nulos o vacíos.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Debe especificarse un solo complemento de caché de proyectos, pero se encontraron varios: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Se creó una invalidación mediante la tarea: {0} en {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicializando complemento de caché de proyecto.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Cerrando complemento de caché de proyecto.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 0ffddfbe011..3bfabec8c49 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Le fichier cache des résultats de sortie spécifié est vide.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Lire la variable d'environnement "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Chargement du plug-in de cache de projet suivant:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Chargement du plug-in de cache de projet suivant:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: plug-ins de cache de projet introuvables dans l'assembly "{0}". Un plug-in est attendu.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: quand un nœud de graphe statique définit un cache de projet, tous les nœuds doivent définir le même cache de projet. Le ou les projets suivants ne contiennent pas de déclaration d'élément "{0}" : {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attendu : {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Impossible d'appeler la méthode {0} avec une collection contenant des noms de cibles qui ont une valeur null ou qui sont vides.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: un seul plug-in de cache de projet doit être spécifié, mais plusieurs plug-ins ont été trouvés : {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Remplacement créé à l’aide de la tâche : {0} au {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Initialisation du plug-in du cache de projet.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Arrêt du plug-in du cache de projet.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 11aec49efc6..a51e335202d 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: il file della cache dei risultati di output specificato è vuoto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Legge la variabile di ambiente "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Caricamento del plug-in seguente della cache del progetto:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Caricamento del plug-in seguente della cache del progetto:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: non sono stati trovati plug-in della cache del progetto nell'assembly "{0}". Ne è previsto uno.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: quando un nodo di grafo statico definisce una cache del progetto, tutti i nodi devono definire la stessa cache del progetto. Il progetto o i progetti seguenti non contengono una dichiarazione di elemento "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obbligatorio non è stato trovato. Percorso previsto: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Non è possibile chiamare il metodo {0} con una raccolta contenente nomi di destinazione Null o vuoti.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: è necessario specificare un singolo plug-in della cache del progetto, ma ne sono trovati più di uno: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">È stata creata una sostituzione con l'attività: {0} in {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inizializzazione del plug-in della cache del progetto.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Arresto del plug-in della cache del progetto.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 1bf7a2f0d24..4b494b30cc9 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: 指定された出力結果キャッシュ ファイルは空です。</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">環境変数 "{0}" の読み取り</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">次のプロジェクト キャッシュ プラグインを読み込んでいます。
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">次のプロジェクト キャッシュ プラグインを読み込んでいます。
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: プロジェクト キャッシュのプラグインがアセンブリ "{0}" に見つかりませんでした。プラグインが 1 つ必要です。</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: 静的グラフ ノードでプロジェクト キャッシュが定義されている場合、すべてのノードで同じプロジェクト キャッシュを定義する必要があります。プロジェクト {1} には、"{0}" 項目宣言が含まれていません</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">必要な NuGet アセンブリが見つかりませんでした。想定されるパス: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Null または空のターゲット名を含むコレクションを指定してメソッド {0} を呼び出すことはできません。</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: 単一のプロジェクト キャッシュ プラグインを指定する必要がありますが、複数指定されています。{0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">タスクを使用してオーバーライドを作成しました: {1} の {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">プロジェクト キャッシュ プラグインを初期化しています。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">プロジェクト キャッシュ プラグインをシャットダウンしています。</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 8f5d34f5cce..a278ca0942b 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: 지정한 출력 결과 캐시 파일이 비어 있습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">환경 변수 "{0}" 읽기</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">다음 프로젝트 캐시 플러그 인을 로드하는 중:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">다음 프로젝트 캐시 플러그 인을 로드하는 중:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: "{0}" 어셈블리에서 프로젝트 캐시 플러그 인을 찾을 수 없습니다. 1개가 필요합니다.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: 정적 그래프 노드에서 프로젝트 캐시를 정의할 때 모든 노드는 같은 프로젝트 캐시를 정의해야 합니다. {1} 프로젝트에는 "{0}" 항목 선언이 포함되어 있지 않습니다.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">필요한 NuGet 어셈블리를 찾을 수 없습니다. 예상 경로: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">null 또는 빈 대상 이름을 포함하는 컬렉션을 사용하여 {0} 메서드를 호출할 수 없습니다.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: 단일 프로젝트 캐시 플러그 인이 지정되어야 하지만, {0}에서 여러 개를 찾았습니다.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">다음 작업을 사용하여 재정의를 만들었습니다. {1}의 {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">프로젝트 캐시 플러그인을 초기화 중입니다.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">프로젝트 캐시 플러그인을 종료합니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b893482a44e..6ce4dabadb8 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Określony plik wyjściowej pamięci podręcznej wyników jest pusty.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Odczytaj zmienną środowiskową „{0}”</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Ładowanie następującej wtyczki pamięci podręcznej projektu: 
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Ładowanie następującej wtyczki pamięci podręcznej projektu: 
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: nie znaleziono wtyczek pamięci podręcznej projektu w zestawie „{0}”. Oczekiwano jednej.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: gdy dowolny węzeł wykresu statycznego definiuje pamięć podręczną projektu, wszystkie węzły muszą definiować tę samą pamięć podręczną projektu. Następujące projekty nie zawierają deklaracji elementu „{0}”: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ścieżki {0}.</target>
@@ -219,21 +218,11 @@
         <target state="translated">Metody {0} nie można wywołać przy użyciu kolekcji zawierającej nazwy docelowe o wartości null lub puste.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: należy określić jedną wtyczkę pamięci podręcznej projektu, ale znaleziono ich wiele: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Utworzono zastąpienie przy użyciu zadania: {0} o {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicjowanie wtyczki pamięci podręcznej projektu.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Zamykanie wtyczki pamięci podręcznej projektu.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index ad14ba37ca1..410c7bf87ea 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: o arquivo de cache do resultado de saída especificado está vazio.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Ler a variável de ambiente "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Carregando o seguinte plug-in do projeto:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Carregando o seguinte plug-in do projeto:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: não foi encontrado nenhum plug-in de cache do projeto no assembly "{0}". Era esperado um plug-in.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: quando algum nó de grafo estático define um cache do projeto, todos os nós precisam definir o mesmo cache do projeto. Os seguintes projetos não contêm uma declaração de item "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Um assembly NuGet necessário não foi encontrado. Caminho Esperado: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">O método {0} não pode ser chamado com uma coleção que contém nomes de destino nulos ou vazios.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: é necessário especificar só um plug-in de cache do projeto, mas foram encontrados vários: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Criou uma substituição usando a tarefa: {0} em {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicializando o plugin de cache do projeto.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Desligando o plug-in de cache do projeto.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 04004fbdfe1..94d4a55fc6a 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: указанный выходной файл кэша результатов пустой.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Чтение переменной среды "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Идет загрузка следующего подключаемого модуля кэша проектов:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Идет загрузка следующего подключаемого модуля кэша проектов:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: не найдены подключаемые модули кэша проектов в сборке "{0}". Должен быть указан один модуль.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: если для какого-либо узла статического графа определен кэш проектов, этот кэш должен быть указан для всех узлов. Следующие проекты не содержат объявление элемента "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Не найдена обязательная сборка NuGet. Ожидаемый путь: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Метод {0} не может быть вызван с коллекцией, содержащей целевые имена, которые пусты или равны NULL.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: должен быть указан один подключаемый модуль кэша проектов, но найдено несколько: {0}.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Создано переопределение с помощью задачи {0} в {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Инициализация подключаемого модуля кэша проекта.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Завершение работы подключаемого модуля кэша проекта.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 5fc8f54ba4e..6269d912df1 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Belirtilen çıkış sonucu önbellek dosyası boş.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">"{0}" ortam değişkenini oku</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Şu proje önbelleği eklentisi yükleniyor:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Şu proje önbelleği eklentisi yükleniyor:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: "{0}" bütünleştirilmiş kodunda proje önbelleği eklentisi bulunamadı. Bir eklenti bekleniyordu.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Herhangi bir statik graf düğümünde proje önbelleği tanımlandığında tüm düğümler aynı proje önbelleğini tanımlamalıdır. Şu projeler "{0}" öğe bildirimini içermiyor: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Gereken NuGet derlemesi bulunamadı. Beklenen Yol: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">{0} metosu null veya boş hedef adları içeren bir koleksiyonla çağrılamaz.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Tek bir proje önbellek eklentisi belirtilmelidir ancak birden çok eklenti bulundu: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">{0} görevi kullanılarak geçersiz kılma işlemi oluşturuldu, saat: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Proje önbellek eklentisi başlatılıyor.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Proje önbellek eklentisi kapatılıyor.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 4a9d18a374e..16534ffea57 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: 指定的输出结果缓存文件为空。</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">读取环境变量“{0}”</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">正在加载以下项目缓存插件: 
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">正在加载以下项目缓存插件: 
     {0}”</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: 在程序集 "{0}" 中未找到项目缓存插件。应有一个插件。</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: 当任何静态关系图节点定义项目缓存时，所有节点必须定义相同的项目缓存。以下项目不包含 "{0}" 项声明: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">未找到所需的 NuGet 程序集。所需路径: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">无法使用包含 null 或空目标名称的集合调用方法 {0}。</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: 必须指定单个项目缓存插件，但找到多个位置: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">已使用任务创建替代: {0} 位于 {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">正在初始化项目缓存插件。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">正在关闭项目缓存插件。</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 214240db01c..8556c522ddf 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: 指定的輸出結果快取檔案是空的。</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">讀取環境變數 "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">正在載入下列專案快取外掛程式:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">正在載入下列專案快取外掛程式:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: 在組件 "{0}" 中找不到任何專案快取外掛程式，但應該要有一個外掛程式。</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: 當任何靜態圖表節點定義了專案快取時，所有節點都必須定義相同的專案快取。下列專案不包含 "{0}" 項目宣告: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">找不到必要的 NuGet 元件。預期的路徑: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">無法使用內含 null 或空白目標名稱的集合呼叫方法 {0}。</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: 只可指定單一專案快取外掛程式，但發現多個指定項目: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">已使用下列工作建立覆寫: 於 {1} 的 {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">正在初始化專案快取外掛程式。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">正在關閉專案快取外掛程式。</target>
diff --git a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
index 2bf43e98406..eca867cd1cc 100644
--- a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
@@ -27,7 +27,7 @@ public void EventArgsCtors()
             buildFinishedEvent = new BuildFinishedEventArgs("{0}", "HelpKeyword", true, new DateTime(), "Message");
             buildFinishedEvent = new BuildFinishedEventArgs(null, null, true);
             buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime());
-            buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime(), null);
+            buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime(), messageArgs: null);
         }
 
         /// <summary>
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 72091def7ac..d1f49d3e19a 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -102,6 +101,14 @@ public Traits()
         /// </summary>
         public readonly bool LogPropertyFunctionsRequiringReflection = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection"));
 
+        /// <summary>
+        /// Log all environment variables whether or not they are used in a build in the binary log.
+        /// </summary>
+        public static bool LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"))
+#if !TASKHOST
+            && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4)
+#endif
+            ;
         /// <summary>
         /// Log property tracking information.
         /// </summary>
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index f521f0949f0..a58e3d035f2 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -7,6 +7,8 @@
 using System.Text.RegularExpressions;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
@@ -19,6 +21,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Path = System.IO.Path;
 
 namespace Microsoft.Build.Engine.UnitTests
 {
@@ -210,6 +213,47 @@ public void BuildsWhileBuildIsRunningOnServer()
             t.Wait();
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void CanShutdownServerProcess(bool byBuildManager)
+        {
+            _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+
+            TransientTestFile project = _env.CreateFile("testProject.proj", printPidContents);
+
+            // Start a server node and find its PID.
+            string output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out bool success, false, _output);
+            success.ShouldBeTrue();
+            int pidOfServerProcess = ParseNumber(output, "Server ID is ");
+            _env.WithTransientProcess(pidOfServerProcess);
+
+            var serverProcess = Process.GetProcessById(pidOfServerProcess);
+
+            serverProcess.HasExited.ShouldBeFalse();
+
+            if (byBuildManager)
+            {
+                BuildManager.DefaultBuildManager.ShutdownAllNodes();
+            }
+            else
+            {
+                bool serverIsDown = MSBuildClient.ShutdownServer(CancellationToken.None);
+                serverIsDown.ShouldBeTrue();
+            }
+
+            serverProcess.WaitForExit(10_000);
+
+            serverProcess.HasExited.ShouldBeTrue();
+        }
+
+        [Fact]
+        public void CanShutdownServerProcessWhenNotRunning()
+        {
+            bool serverIsDown = MSBuildClient.ShutdownServer(CancellationToken.None);
+            serverIsDown.ShouldBeTrue();
+        }
+
         [Fact]
         public void ServerShouldNotRunWhenNodeReuseEqualsFalse()
         {
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index c0bb91a4e56..15a96bb74dc 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -690,21 +690,21 @@ elementFormDefault="qualified">
                             <xs:element name="IncludeAssets">
                               <xs:annotation>
                                 <xs:documentation>
-                                  <!-- _locID_text="ProjectReference_IncludeAssets" _locComment="" -->Assets to include from this reference
+                                  <!-- _locID_text="ProjectReference_IncludeAssets" _locComment="" -->Assets to include from this reference. Applies to packages referenced transitively by the reference as well.
                                 </xs:documentation>
                               </xs:annotation>
                             </xs:element>
                             <xs:element name="ExcludeAssets">
                               <xs:annotation>
                                 <xs:documentation>
-                                  <!-- _locID_text="ProjectReference_ExcludeAssets" _locComment="" -->Assets to exclude from this reference
+                                  <!-- _locID_text="ProjectReference_ExcludeAssets" _locComment="" -->Assets to exclude from this reference. Applies to packages referenced transitively by the reference as well.
                                 </xs:documentation>
                               </xs:annotation>
                             </xs:element>
                             <xs:element name="PrivateAssets">
                               <xs:annotation>
                                 <xs:documentation>
-                                  <!-- _locID_text="ProjectReference_PrivateAssets" _locComment="" -->Assets that are private in this reference
+                                  <!-- _locID_text="ProjectReference_PrivateAssets" _locComment="" -->Assets that are private in this reference. Applies to packages referenced transitively by the reference as well.
                                 </xs:documentation>
                               </xs:annotation>
                             </xs:element>
@@ -1733,6 +1733,11 @@ elementFormDefault="qualified">
       </xs:annotation>
     </xs:element>
     <xs:element name="DisableXbfGeneration" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="DisableTransitiveProjectReferences" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="DisableTransitiveProjectReferences" _locComment="" -->When true, do not discover ProjectReference items representing projects referenced by this project's ProjectReferences. Applies only to projects using the .NET SDK.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="SuppressXamlWarnings" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="XamlRootsLog" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="XamlSavedStateFilePath" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index af1472b56d1..c144de69fd8 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -669,7 +669,6 @@ string[] commandLine
                 string outputResultsCache = null;
 
                 GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile, out _);
-
                 bool buildCanBeInvoked = ProcessCommandLineSwitches(
                                             switchesFromAutoResponseFile,
                                             switchesNotFromAutoResponseFile,
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index beca5404f56..ec7f04055ae 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -39,6 +39,10 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
+    <!-- EnvironmentVariableReadEventArgs shouldn't be used in TaskHosts, but it means we need fewer ifdefs. -->
+    <Compile Include="..\Framework\EnvironmentVariableReadEventArgs.cs">
+      <Link>EnvironmentVariableReadEventArgs.cs</Link>
+    </Compile>
     <Compile Include="..\Framework\BuildEnvironmentState.cs">
       <Link>BuildEnvironmentState.cs</Link>
     </Compile>
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index b2579ae8610..6d5d9ebfd74 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -550,9 +550,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
             {
                 // In the .NET SDK, there's one copy of MSBuild.dll and it's in the root folder.
                 MSBuildToolsDirectoryRoot = CurrentMSBuildToolsDirectory;
+
+                // If we're standalone, we might not be in the SDK. Rely on folder paths at this point.
+                if (string.Equals(currentToolsDirectory.Name, "amd64", StringComparison.OrdinalIgnoreCase) ||
+                    string.Equals(currentToolsDirectory.Name, "arm64", StringComparison.OrdinalIgnoreCase))
+                {
+                    MSBuildToolsDirectoryRoot = currentToolsDirectory.Parent?.FullName;
+                }
             }
 
-            if (mode == BuildEnvironmentMode.VisualStudio && MSBuildToolsDirectoryRoot != null)
+            if (MSBuildToolsDirectoryRoot != null)
             {
                 // Calculate potential paths to other architecture MSBuild.exe
                 var potentialAmd64FromX86 = FileUtilities.CombinePaths(MSBuildToolsDirectoryRoot, "amd64", msBuildExeName);
@@ -563,8 +570,8 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
                 var existsCheck = mode == BuildEnvironmentMode.VisualStudio ? new Func<string, bool>(_ => true) : File.Exists;
 
                 MSBuildToolsDirectory32 = MSBuildToolsDirectoryRoot;
-                MSBuildToolsDirectory64 = Path.Combine(MSBuildToolsDirectoryRoot, "amd64");
-                MSBuildToolsDirectoryArm64 = File.Exists(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : null;
+                MSBuildToolsDirectory64 = existsCheck(potentialAmd64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "amd64") : CurrentMSBuildToolsDirectory;
+                MSBuildToolsDirectoryArm64 = existsCheck(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : null;
             }
 
             MSBuildExtensionsPath = mode == BuildEnvironmentMode.VisualStudio
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 4489d33a43b..af794b51281 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -108,7 +108,7 @@ internal static bool ValidBooleanTrue(string parameterValue)
         /// Returns true if the string represents a valid MSBuild boolean false value,
         /// such as "!on" "off" "no" "!true"
         /// </summary>
-        private static bool ValidBooleanFalse(string parameterValue)
+        internal static bool ValidBooleanFalse(string parameterValue)
         {
             return String.Equals(parameterValue, "false", StringComparison.OrdinalIgnoreCase) ||
                    String.Equals(parameterValue, "off", StringComparison.OrdinalIgnoreCase) ||
diff --git a/src/Shared/EnvironmentUtilities.cs b/src/Shared/EnvironmentUtilities.cs
index e9e0482619f..01cf349f2f8 100644
--- a/src/Shared/EnvironmentUtilities.cs
+++ b/src/Shared/EnvironmentUtilities.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Runtime.InteropServices;
 
-#nullable disable
-
 namespace Microsoft.Build.Shared
 {
     internal static partial class EnvironmentUtilities
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index e3bcdf9fcba..7c0db803f70 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -53,10 +53,11 @@ internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProj
         /// <param name="e">Message to format</param>
         /// <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
         /// <param name="projectConfigurationDescription">Properties to Print along with message</param>
+        /// <param name="nonNullMessage">The complete message (including property name) for an environment-derived property</param>
         /// <returns>The formatted message string.</returns>
-        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription)
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription, string nonNullMessage = null)
         {
-            return FormatEventMessage("message", e.Subcategory, e.Message,
+            return FormatEventMessage("message", e.Subcategory, nonNullMessage ?? e.Message,
                             e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber,
                             e.ColumnNumber, e.EndColumnNumber, e.ThreadId, projectConfigurationDescription);
         }
@@ -144,13 +145,14 @@ internal static string FormatEventMessage(BuildMessageEventArgs e)
         /// </summary>
         /// <param name="e">Message to format</param>
         /// <param name="showProjectFile">Show project file or not</param>
+        /// <param name="nonNullMessage">For an EnvironmentVariableReadEventArgs, adds an explanatory note and the name of the variable.</param>
         /// <returns>The formatted message string.</returns>
-        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile)
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string nonNullMessage = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             // "message" should not be localized
-            return FormatEventMessage("message", e.Subcategory, e.Message,
+            return FormatEventMessage("message", e.Subcategory, nonNullMessage ?? e.Message,
                 e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber, e.ColumnNumber, e.EndColumnNumber, e.ThreadId, null);
         }
 
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index ffbf64c1033..2d91a466fbf 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -323,12 +323,9 @@ internal static void DumpExceptionToFile(Exception ex)
 
                     // For some reason we get Watson buckets because GetTempPath gives us a folder here that doesn't exist.
                     // Either because %TMP% is misdefined, or because they deleted the temp folder during the build.
-                    if (!FileSystems.Default.DirectoryExists(DebugDumpPath))
-                    {
-                        // If this throws, no sense catching it, we can't log it now, and we're here
-                        // because we're a child node with no console to log to, so die
-                        Directory.CreateDirectory(DebugDumpPath);
-                    }
+                    // If this throws, no sense catching it, we can't log it now, and we're here
+                    // because we're a child node with no console to log to, so die
+                    Directory.CreateDirectory(DebugDumpPath);
 
                     var pid = Process.GetCurrentProcess().Id;
                     // This naming pattern is assumed in ReadAnyExceptionFromFile
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index b1d737942b5..9f625373ed9 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -130,6 +130,11 @@ internal enum LoggingEventType : int
         /// Event is a TelemetryEventArgs
         /// </summary>
         Telemetry = 18,
+
+        /// <summary>
+        /// Event is an EnvironmentVariableReadEventArgs
+        /// </summary>
+        EnvironmentVariableReadEvent = 19,
     }
     #endregion
 
@@ -323,7 +328,8 @@ internal void WriteToStream(ITranslator translator)
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs ||
-                    _buildEvent is ProjectEvaluationFinishedEventArgs)
+                    _buildEvent is ProjectEvaluationFinishedEventArgs ||
+                    _buildEvent is EnvironmentVariableReadEventArgs)
                 {
                     // switch to serialization methods that we provide in this file
                     // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
@@ -403,6 +409,7 @@ internal void ReadFromStream(ITranslator translator)
                 else
                 {
                     _buildEvent = ReadEventFromStream(_eventType, translator);
+                    ErrorUtilities.VerifyThrow(_buildEvent is not null, "Not Supported LoggingEventType {0}", _eventType.ToString());
                 }
             }
             else
@@ -509,6 +516,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskStartedEvent => new TaskStartedEventArgs(null, null, null, null, null),
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
+                LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
                 LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
@@ -607,6 +615,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildErrorEvent;
             }
+            else if (eventType == typeof(EnvironmentVariableReadEventArgs))
+            {
+                return LoggingEventType.EnvironmentVariableReadEvent;
+            }
             else
             {
                 return LoggingEventType.CustomEvent;
@@ -661,12 +673,29 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.ProjectFinishedEvent:
                     WriteExternalProjectFinishedEventToStream((ExternalProjectFinishedEventArgs)buildEvent, translator);
                     break;
+                case LoggingEventType.EnvironmentVariableReadEvent:
+                    WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);
+                    break;
                 default:
                     ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
                     break;
             }
         }
 
+        /// <summary>
+        /// Serializes EnvironmentVariableRead Event argument to the stream. Does not work properly on TaskHosts due to BuildEventContext serialization not being
+        /// enabled on TaskHosts, but that shouldn't matter, as this should never be called from a TaskHost anyway.
+        /// </summary>
+        private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)
+        {
+            string name = environmentVariableReadEventArgs.EnvironmentVariableName;
+            translator.Translate(ref name);
+            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
+#if !CLR2COMPATIBILITY
+            translator.Translate(ref context);
+#endif
+        }
+
         /// <summary>
         /// Serialize ExternalProjectFinished Event Argument to the stream
         /// </summary>
@@ -1001,33 +1030,33 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
             translator.Translate(ref helpKeyword);
             translator.Translate(ref senderName);
 
-            BuildEventArgs buildEvent = null;
-            switch (eventType)
+            return eventType switch
             {
-                case LoggingEventType.TaskCommandLineEvent:
-                    buildEvent = ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.BuildErrorEvent:
-                    buildEvent = ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.ProjectStartedEvent:
-                    buildEvent = ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.ProjectFinishedEvent:
-                    buildEvent = ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.BuildMessageEvent:
-                    buildEvent = ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.BuildWarningEvent:
-                    buildEvent = ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                default:
-                    ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
-                    break;
-            }
+                LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),
+                _ => null,
+            };
+        }
 
-            return buildEvent;
+        /// <summary>
+        /// Read and reconstruct an EnvironmentVariableReadEventArgs from the stream. This message should never be called from a TaskHost, so although the context translation does not work, that's ok.
+        /// </summary>
+        private EnvironmentVariableReadEventArgs ReadEnvironmentVariableReadEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
+        {
+            string environmentVariableName = null;
+            translator.Translate(ref environmentVariableName);
+            BuildEventContext context = null;
+#if !CLR2COMPATIBILITY
+            translator.Translate(ref context);
+#endif
+            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message);
+            args.BuildEventContext = context;
+            return args;
         }
 
         /// <summary>
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 3cb530afca4..1f65afed8cd 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -2064,15 +2064,20 @@ public async Task<BuildResult> BuildProjectFileAsync(
                 string[] entryTargets = null,
                 Dictionary<string, string> globalProperties = null)
             {
-                var buildRequestData = new BuildRequestData(projectFile,
+                var buildRequestData = new BuildRequestData(
+                    projectFile,
                     globalProperties ?? new Dictionary<string, string>(),
                     MSBuildConstants.CurrentToolsVersion,
                     entryTargets ?? Array.Empty<string>(),
                     null);
+                return await BuildAsync(buildRequestData);
+            }
 
+            public async Task<BuildResult> BuildAsync(BuildRequestData requestData)
+            {
                 var completion = new TaskCompletionSource<BuildResult>();
 
-                _buildManager.PendBuildRequest(buildRequestData).ExecuteAsync(submission =>
+                _buildManager.PendBuildRequest(requestData).ExecuteAsync(submission =>
                 {
                     completion.SetResult(submission.BuildResult);
                 }, null);
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 2db94fa9e83..c97b575d88c 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -259,17 +259,6 @@ public TransientTestFile ExpectFile(string extension = ".tmp")
             return WithTransientTestState(new TransientTestFile(extension, createFile: false, expectedAsOutput: true));
         }
 
-        /// <summary>
-        /// Create a temp file name under a specific temporary folder. The file is expected to exist when the test completes.
-        /// </summary>
-        /// <param name="transientTestFolder">Temp folder</param>
-        /// <param name="extension">Extension of the file (defaults to '.tmp')</param>
-        /// <returns></returns>
-        public TransientTestFile ExpectFile(TransientTestFolder transientTestFolder, string extension = ".tmp")
-        {
-            return WithTransientTestState(new TransientTestFile(transientTestFolder.Path, extension, createFile: false, expectedAsOutput: true));
-        }
-
         /// <summary>
         ///     Creates a test variant used to add a unique temporary folder during a test. Will be deleted when the test
         ///     completes.
@@ -583,7 +572,14 @@ public override void Revert()
         {
             if (_processId > -1)
             {
-                Process.GetProcessById(_processId).KillTree(1000);
+                try
+                {
+                    Process.GetProcessById(_processId).KillTree(1000);
+                }
+                catch
+                {
+                    // ignore if process is already dead
+                }
             }
         }
     }
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index c4c89013a1e..33cdf7e7ad1 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -218,5 +218,46 @@ public void PseudoLocalization(string culture)
             Assert.Equal($"MyResource.{culture}.resx", t.AssignedFiles[0].ItemSpec);
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
+
+        /// <summary>
+        /// Testing that certain aliases are considered valid cultures. Regression test for https://github.com/dotnet/msbuild/issues/3897.
+        /// </summary>
+        /// <param name="culture"></param>
+        [Theory]
+        [InlineData("zh-TW")]
+        [InlineData("zh-MO")]
+        public void SupportAliasedCultures(string culture)
+        {
+            AssignCulture t = new AssignCulture();
+            t.BuildEngine = new MockEngine();
+            ITaskItem i = new TaskItem($"MyResource.{culture}.resx");
+            t.Files = new ITaskItem[] { i };
+            t.Execute();
+
+            Assert.Single(t.AssignedFiles);
+            Assert.Single(t.CultureNeutralAssignedFiles);
+            Assert.Equal(culture, t.AssignedFiles[0].GetMetadata("Culture"));
+            Assert.Equal($"MyResource.{culture}.resx", t.AssignedFiles[0].ItemSpec);
+            Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
+        }
+
+        [Theory]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework, "These cultures are not returned via Culture api on net472.")]
+        [InlineData("sh-BA")]
+        [InlineData("shi-MA")]
+        public void AliasedCultures_SupportedOnNetCore(string culture)
+        {
+            AssignCulture t = new AssignCulture();
+            t.BuildEngine = new MockEngine();
+            ITaskItem i = new TaskItem($"MyResource.{culture}.resx");
+            t.Files = new ITaskItem[] { i };
+            t.Execute();
+
+            Assert.Single(t.AssignedFiles);
+            Assert.Single(t.CultureNeutralAssignedFiles);
+            Assert.Equal(culture, t.AssignedFiles[0].GetMetadata("Culture"));
+            Assert.Equal($"MyResource.{culture}.resx", t.AssignedFiles[0].ItemSpec);
+            Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 7dbf9e846f2..c55eca63dda 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -464,7 +464,13 @@ public void CodeTypeFromTaskBody()
             {
                 TransientTestFile file = testEnvironment.CreateFile(fileName: "236D48CE30064161B31B55DBF088C8B2", contents: "6159BD98607A460AA4F11D2FA92E5436");
 
+                // When Source is provided and Type is not provided, Type is expected to default to Type="Class".
                 TryLoadTaskBodyAndExpectSuccess($"<Code Source=\"{file.Path}\"/>", expectedCodeType: RoslynCodeTaskFactoryCodeType.Class);
+
+                foreach (RoslynCodeTaskFactoryCodeType codeType in Enum.GetValues(typeof(RoslynCodeTaskFactoryCodeType)).Cast<RoslynCodeTaskFactoryCodeType>())
+                {
+                    TryLoadTaskBodyAndExpectSuccess($"<Code Source=\"{file.Path}\" Type=\"{codeType}\">code</Code>", expectedCodeType: codeType);
+                }
             }
         }
 
@@ -684,6 +690,112 @@ public class MyInlineTask : Microsoft.Build.Utilities.Task {{
                 expectedCodeType: RoslynCodeTaskFactoryCodeType.Method);
         }
 
+        [Fact]
+        public void CSharpFragmentSourceCodeFromFile()
+        {
+            const string sourceCodeFileContents = "int x = 0;";
+            const string expectedSourceCode = @"//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+" +
+#if NETFRAMEWORK
+@"//     Runtime Version:4.0.30319.42000
+" +
+#endif
+                                              $@"//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace InlineCode {{
+    using Microsoft.Build.Framework;
+    using Microsoft.Build.Utilities;
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.IO;
+    using System.Linq;
+    using System.Text;
+    
+    
+    public class {TaskName} : Microsoft.Build.Utilities.Task {{
+        
+        private bool _Success = true;
+        
+        public virtual bool Success {{
+            get {{
+                return _Success;
+            }}
+            set {{
+                _Success = value;
+            }}
+        }}
+        
+        public override bool Execute() {{
+{sourceCodeFileContents}
+            return Success;
+        }}
+    }}
+}}
+";
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFile file = testEnvironment.CreateFile(fileName: "CSharpFragmentSourceCodeFromFile.tmp", contents: sourceCodeFileContents);
+
+                TryLoadTaskBodyAndExpectSuccess(
+                    $"<Code Source=\"{file.Path}\" Type=\"Fragment\"/>",
+                    expectedSourceCode: expectedSourceCode,
+                    expectedCodeType: RoslynCodeTaskFactoryCodeType.Fragment);
+            }
+        }
+
+        [Fact]
+        public void CSharpMethodSourceCodeFromFile()
+        {
+            const string sourceCodeFileContents = @"public override bool Execute() { int x = 0; return true; }";
+            const string expectedSourceCode = @"//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+" +
+#if NETFRAMEWORK
+@"//     Runtime Version:4.0.30319.42000
+" +
+#endif
+                                              @$"//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace InlineCode {{
+    using Microsoft.Build.Framework;
+    using Microsoft.Build.Utilities;
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.IO;
+    using System.Linq;
+    using System.Text;
+    
+    
+    public class MyInlineTask : Microsoft.Build.Utilities.Task {{
+        
+{sourceCodeFileContents}
+    }}
+}}
+";
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFile file = testEnvironment.CreateFile(fileName: "CSharpMethodSourceCodeFromFile.tmp", contents: sourceCodeFileContents);
+
+                TryLoadTaskBodyAndExpectSuccess(
+                    $"<Code Source=\"{file.Path}\" Type=\"Method\"/>",
+                    expectedSourceCode: expectedSourceCode,
+                    expectedCodeType: RoslynCodeTaskFactoryCodeType.Method);
+            }
+        }
+
         [Fact]
         public void EmptyCodeElement()
         {
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index 61733113873..dca043b7d3c 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -4,6 +4,8 @@
 using System;
 using System.Collections.Generic;
 using System.Globalization;
+using System.Linq;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -19,7 +21,13 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal static class CultureInfoCache
     {
-        private static readonly HashSet<string> ValidCultureNames = InitializeValidCultureNames();
+        private static readonly Lazy<HashSet<string>> ValidCultureNames = new Lazy<HashSet<string>>(() => InitializeValidCultureNames());
+
+        // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing
+        // These pseudo-locales are available in versions of Windows from Vista and later.
+        // However, from Windows 10, version 1803, they are not returned when enumerating the
+        // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.
+        static readonly string[] pseudoLocales = new[] { "qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh" };
 
         static HashSet<string> InitializeValidCultureNames()
         {
@@ -35,12 +43,7 @@ static HashSet<string> InitializeValidCultureNames()
                 validCultureNames.Add(cultureName.Name);
             }
 
-            // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing
-            // These pseudo-locales are available in versions of Windows from Vista and later.
-            // However, from Windows 10, version 1803, they are not returned when enumerating the
-            // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.
-            string[] pseudoLocales = new[] { "qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh" };
-
+            // Account for pseudo-locales (see above)
             foreach (string pseudoLocale in pseudoLocales)
             {
                 validCultureNames.Add(pseudoLocale);
@@ -56,7 +59,23 @@ static HashSet<string> InitializeValidCultureNames()
         /// <returns>True if the culture is determined to be valid.</returns>
         internal static bool IsValidCultureString(string name)
         {
-            return ValidCultureNames.Contains(name);
+#if NET5_0_OR_GREATER
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                try
+                {
+                    // GetCultureInfo throws if the culture doesn't exist
+                    CultureInfo.GetCultureInfo(name, predefinedOnly: true);
+                    return true;
+                }
+                catch
+                {
+                    // Second attempt: try pseudolocales (see above)
+                    return pseudoLocales.Contains(name);
+                }
+            }
+#endif
+            return ValidCultureNames.Value.Contains(name);
         }
 
 #if !FEATURE_CULTUREINFO_GETCULTURES
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 5bd98bfbe0c..6421d98c638 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -329,6 +329,7 @@
     </Compile>
     <Compile Include="ResourceHandling\*.cs" />
     <Compile Include="GetCompatiblePlatform.cs" />
+    <Compile Include="SetRidAgnosticValueForProjects.cs" />
     <Compile Include="ResolveComReference.cs" />
     <Compile Include="BuildCacheDisposeWrapper.cs" />
     <Compile Include="DownloadFile.cs" />
@@ -966,8 +967,8 @@
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" SetTargetFramework="TargetFramework=netstandard2.0" OutputItemType="NetstandardRefAssemblies" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" SetTargetFramework="TargetFramework=netstandard2.0" OutputItemType="NetstandardRefAssemblies" />
-    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj"/>
-    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj"/>
+    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
+    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
   <ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 5096427a963..af1a6b18164 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -42,9 +42,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
         <HasSingleTargetFramework>false</HasSingleTargetFramework>
-        <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
-        <IsRidAgnostic>false</IsRidAgnostic>
-        <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>
         <!-- Extract necessary information for SetPlatform negotiation -->
         <!-- This target does not run for cpp projects. -->
         <IsVcxOrNativeProj>false</IsVcxOrNativeProj>
@@ -220,4 +218,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index fc7bfd9a865..bb900b2b147 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1,4 +1,4 @@
-<!--
+﻿<!--
 ***********************************************************************************************
 Microsoft.Common.CurrentVersion.targets
 
@@ -1788,7 +1788,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         BuildInParallel="$(BuildInParallel)"
         Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)"
         ContinueOnError="!$(BuildingProject)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)"
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;$(_GlobalPropertiesToRemoveFromProjectReferences)"
         Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' != 'true'"
         SkipNonexistentTargets="true">
       <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
@@ -1804,7 +1804,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Targets="GetTargetFrameworks"
         BuildInParallel="$(BuildInParallel)"
         ContinueOnError="!$(BuildingProject)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;Platform;Configuration$(_GlobalPropertiesToRemoveFromProjectReferences)"
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;Platform;Configuration;$(_GlobalPropertiesToRemoveFromProjectReferences)"
         Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' == 'true'"
         SkipNonexistentTargets="true">
       <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
@@ -1859,6 +1859,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                          Condition="'$(ReferringTargetFrameworkForProjectReferences)' == '' or
                                     ('$(EnableDynamicPlatformResolution)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' == 'true')" />
 
+    </ItemGroup>
+
+    <!-- IsRidAgnostic metadata is used to determine whether global properties such as RuntimeIdentifier and SelfContained flow to a referenced project.
+         However, for multi-targeted projects there may be a different IsRidAgnostic value for each TargetFramework.  In that case, this task selects
+         the IsRidAgnostic value for the NearestTargetFramework for the project. -->
+    <SetRidAgnosticValueForProjects Projects="@(AnnotatedProjects)">
+      <Output ItemName="UpdatedAnnotatedProjects" TaskParameter="UpdatedProjects" />
+    </SetRidAgnosticValueForProjects>
+    
+    <ItemGroup>
+      <AnnotatedProjects Remove="@(AnnotatedProjects)" />
+      <AnnotatedProjects Include="@(UpdatedAnnotatedProjects)" />
+      <UpdatedAnnotatedProjects Remove="@(UpdatedAnnotatedProjects)" />
+
       <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->
       <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.NearestTargetFramework)' != '' and '%(AnnotatedProjects.HasSingleTargetFramework)' != 'true'">
         <SetTargetFramework>TargetFramework=%(AnnotatedProjects.NearestTargetFramework)</SetTargetFramework>
@@ -1872,9 +1886,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <UndefineProperties>%(AnnotatedProjects.UndefineProperties);TargetFramework</UndefineProperties>
       </AnnotatedProjects>
 
-      <!-- If the project is RID agnostic, undefine the RuntimeIdentifier property to avoid another evaluation. -->
-      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' == 'true'">
-        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier</UndefineProperties>
+      <!-- Add RuntimeIdentifier and SelfContained to the list of global properties that should not flow to the referenced project,
+           unless the project is expecting those properties to flow. -->
+      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' != 'false'">
+        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier;SelfContained</UndefineProperties>
       </AnnotatedProjects>
 
       <!--
@@ -1907,9 +1922,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
         <HasSingleTargetFramework>true</HasSingleTargetFramework>
-        <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
-        <IsRidAgnostic>false</IsRidAgnostic>
-        <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>
         <!-- Extract necessary information for SetPlatform negotiation -->
         <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
         <Platform Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">$(Platform)</Platform>
@@ -1950,6 +1963,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>
         <TargetPlatformMonikers Condition="'$(TargetPlatformMoniker)' == ''">None</TargetPlatformMonikers>
         <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>
+
+        <!-- Determine whether a project is "RID agnostic" for each TargetFramework.  "RID agnostic" means that global properties such as SelfContained and RuntimeIdentifier should
+             not flow across project references.
+
+             Generally this value will come from the IsRidAgnostic property set by the .NET SDK.  If that's not set, then the fallback logic here will be that the project
+             is RID agnostic if it doesn't have RuntimeIdentifier or RuntimeIdentifiers properties set. -->
+        <IsRidAgnostic>$(IsRidAgnostic)</IsRidAgnostic>
+        <IsRidAgnostic Condition=" '$(IsRidAgnostic)' == '' and '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <IsRidAgnostic Condition=" '$(IsRidAgnostic)' == ''">false</IsRidAgnostic>
+
       </_TargetFrameworkInfo>
     </ItemGroup>
 
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 8bcaa32b507..d91e88e9861 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -54,6 +54,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.SetRidAgnosticValueForProjects"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Hash"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.LC"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -106,4 +107,4 @@
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index a10bf7c0784..48264892122 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -38,33 +38,36 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   -->
   <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
     <!-- Empty case is for outer builds which do not import the target files that set BuildProjectReferences -->
-    <_MainReferenceTarget Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTarget>
-    <_MainReferenceTarget Condition="'$(_MainReferenceTarget)' == ''">GetTargetPath</_MainReferenceTarget>
+    <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
+    <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
 
     <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>
-    <ProjectReferenceTargetsForBuild>$(_MainReferenceTarget);GetNativeManifest;$(_RecursiveTargetForContentCopying);GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+    <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
 
     <ProjectReferenceTargetsForCleanInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForCleanInOuterBuild)</ProjectReferenceTargetsForCleanInOuterBuild>
     <ProjectReferenceTargetsForClean>Clean;GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
 
-    <ProjectReferenceTargetsForRebuildInOuterBuild>$(ProjectReferenceTargetsForCleanInOuterBuild);$(ProjectReferenceTargetsForBuildInOuterBuild);$(ProjectReferenceTargetsForRebuildInOuterBuild)</ProjectReferenceTargetsForRebuildInOuterBuild>
     <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
 
-    <ProjectReferenceTargetsForPublish>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForPublish>
+    <!-- Publish has the same logic as Build for the main reference target except it also takes $(NoBuild) into account. -->
+    <_MainReferenceTargetForPublish Condition="'$(NoBuild)' == 'true'">GetTargetPath</_MainReferenceTargetForPublish>
+    <_MainReferenceTargetForPublish Condition="'$(NoBuild)' != 'true'">$(_MainReferenceTargetForBuild)</_MainReferenceTargetForPublish>
+    <ProjectReferenceTargetsForPublish>GetTargetFrameworks;$(_MainReferenceTargetForPublish);GetNativeManifest;GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForPublish>
+
     <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
   </PropertyGroup>
 
   <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
-    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true"/>
+    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true" />
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
 
-    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true"/>
+    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true" />
     <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
 
-    <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForRebuildInOuterBuild)' != '' " />
     <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
 
     <ProjectReferenceTargets Include="Publish" Targets="$(ProjectReferenceTargetsForPublish)" Condition=" '$(ProjectReferenceTargetsForPublish)' != '' " />
+
     <ProjectReferenceTargets Include="GetCopyToPublishDirectoryItems" Targets="$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)" Condition=" '$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)' != '' " />
   </ItemGroup>
 
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
index 68779602973..e2378ba70a3 100644
--- a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,2 +1,9 @@
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.set -> void
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.SetRidAgnosticValueForProjects() -> void
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.set -> void
+override Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Execute() -> bool
 Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.get -> bool
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
\ No newline at end of file
+Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 68779602973..176cca35d60 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,2 +1,9 @@
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.set -> void
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.SetRidAgnosticValueForProjects() -> void
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.set -> void
 Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.get -> bool
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
\ No newline at end of file
+Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
+override Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Execute() -> bool
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index e04d5d27e05..6695d3196f9 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -396,7 +396,8 @@ private void GetOutputAssemblies(List<PublishInfo> publishInfos, List<ITaskItem>
                         AssemblyIdentity identity = AssemblyIdentity.FromManagedAssembly(item.ItemSpec);
                         if (identity != null && !String.Equals(identity.Culture, "neutral", StringComparison.Ordinal))
                         {
-                            CultureInfo satelliteCulture = GetItemCulture(item);
+                            CultureInfo satelliteCulture = new CultureInfo(identity.Culture);
+                            item.SetMetadata("Culture", identity.Culture);
                             if (PublishFlags.IsSatelliteIncludedByDefault(satelliteCulture, _targetCulture, _includeAllSatellites))
                             {
                                 _satelliteAssembliesPassedAsReferences.Add(item);
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 004d2f8067d..f9fbcadfcae 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -442,7 +442,8 @@ internal static bool TryLoadTaskBody(TaskLoggingHelper log, string taskName, str
                 taskInfo.CodeType = RoslynCodeTaskFactoryCodeType.Class;
                 taskInfo.SourceCode = File.ReadAllText(sourceAttribute.Value.Trim());
             }
-            else if (typeAttribute != null)
+
+            if (typeAttribute != null)
             {
                 if (String.IsNullOrWhiteSpace(typeAttribute.Value))
                 {
@@ -747,6 +748,12 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
 
                         return false;
                     }
+
+                    if (!deleteSourceCodeFile)
+                    {
+                        // Log the location of the code file because MSBUILDLOGCODETASKFACTORYOUTPUT was set.
+                        _log.LogMessageFromResources(MessageImportance.Low, "CodeTaskFactory.FindSourceFileAt", sourceCodePath);
+                    }
                 }
 
                 // Return the assembly which is loaded into memory
diff --git a/src/Tasks/SetRidAgnosticValueForProjects.cs b/src/Tasks/SetRidAgnosticValueForProjects.cs
new file mode 100644
index 00000000000..7e45e76f163
--- /dev/null
+++ b/src/Tasks/SetRidAgnosticValueForProjects.cs
@@ -0,0 +1,65 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
+
+namespace Microsoft.Build.Tasks
+{
+    public sealed class SetRidAgnosticValueForProjects : TaskExtension
+    {
+        public ITaskItem[] Projects { get; set; } = Array.Empty<ITaskItem>();
+
+        [Output]
+        public ITaskItem[] UpdatedProjects { get; set; } = Array.Empty<ITaskItem>();
+
+        public override bool Execute()
+        {
+            UpdatedProjects = Projects
+                .Select(p =>
+                {
+                    var hasSingleTargetFrameworkString = p.GetMetadata("HasSingleTargetFramework");
+                    if (!ConversionUtilities.ValidBooleanFalse(hasSingleTargetFrameworkString))
+                    {
+                        // No change to item, it should already have a single-valued IsRidAgnostic value
+                        return p;
+                    }
+                    var updatedItem = new TaskItem(p);
+
+                    var nearestTargetFramework = p.GetMetadata("NearestTargetFramework");
+                    if (string.IsNullOrEmpty(nearestTargetFramework))
+                    {
+                        return p;
+                    }
+
+                    var targetFrameworksArray = p.GetMetadata("TargetFrameworks").Split(';');
+
+                    int targetFrameworkIndex = Array.IndexOf(targetFrameworksArray, nearestTargetFramework);
+                    if (targetFrameworkIndex < 0)
+                    {
+                        return p;
+                    }
+
+                    var isRidAgnosticArray = p.GetMetadata("IsRidAgnostic").Split(';');
+                    if (isRidAgnosticArray.Length != targetFrameworksArray.Length)
+                    {
+                        return p;
+                    }
+
+                    updatedItem.SetMetadata("IsRidAgnostic", isRidAgnosticArray[targetFrameworkIndex]);
+                    
+                    return updatedItem;
+                })
+                .ToArray();
+
+            return true;
+        }
+    }
+}
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 366b1bc4280..53d2512e201 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -71,15 +71,12 @@ private static string ResolveRuntimeExecutableName()
         /// </summary>
         public static string RunProcessAndGetOutput(string process, string parameters, out bool successfulExit, bool shellExecute = false, ITestOutputHelper outputHelper = null)
         {
-            outputHelper?.WriteLine($"{DateTime.Now.ToString("hh:mm:ss tt")}:RunProcessAndGetOutput:1");
-
             if (shellExecute)
             {
                 // we adjust the psi data manually because on net core using ProcessStartInfo.UseShellExecute throws NotImplementedException
                 AdjustForShellExecution(ref process, ref parameters);
             }
 
-            outputHelper?.WriteLine($"{DateTime.Now.ToString("hh:mm:ss tt")}:RunProcessAndGetOutput:2");
             var psi = new ProcessStartInfo(process)
             {
                 CreateNoWindow = true,
@@ -92,7 +89,6 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
             string output = string.Empty;
             int pid = -1;
 
-            outputHelper?.WriteLine($"{DateTime.Now.ToString("hh:mm:ss tt")}:RunProcessAndGetOutput:3");
             using (var p = new Process { EnableRaisingEvents = true, StartInfo = psi })
             {
                 DataReceivedEventHandler handler = delegate (object sender, DataReceivedEventArgs args)
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 2629634f436..b58f7f10881 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -862,7 +862,7 @@ private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs bui
                         _firstProjectStartedEventContext = buildEvent.BuildEventContext;
 
                         // We've never seen a project started event, so raise the build started event and save this project started event.
-                        BuildStartedEventArgs startedEvent = new BuildStartedEventArgs(_buildStartedEvent.Message, _buildStartedEvent.HelpKeyword, _buildStartedEvent.BuildEnvironment);
+                        BuildStartedEventArgs startedEvent = new BuildStartedEventArgs(_buildStartedEvent.Message, _buildStartedEvent.HelpKeyword, Traits.LogAllEnvironmentVariables ? _buildStartedEvent.BuildEnvironment : null);
                         RaiseBuildStartedEvent(sender, startedEvent);
                     }
 
