diff --git a/.github/fabricbot.json b/.github/fabricbot.json
index 805c4d1eeb1..61fca534d95 100644
--- a/.github/fabricbot.json
+++ b/.github/fabricbot.json
@@ -1,80 +1,11 @@
 {
   "version": "1.0",
   "tasks": [
-    {
-      "taskType": "trigger",
-      "capabilityId": "AutoMerge",
-      "subCapability": "AutoMerge",
-      "version": "1.0",
-      "id": "_eeVr2w4J",
-      "config": {
-        "taskName": "Automatically squash and  merge PR once CI passes",
-        "label": "auto-merge",
-        "minMinutesOpen": "12",
-        "mergeType": "squash",
-        "deleteBranches": true,
-        "requireAllStatuses": true,
-        "minimumNumberOfCheckRuns": 4,
-        "removeLabelOnPush": true
-      }
-    },
-    {
-      "taskType": "trigger",
-      "capabilityId": "IssueResponder",
-      "subCapability": "PullRequestResponder",
-      "version": "1.0",
-      "id": "0aePnH83s",
-      "config": {
-        "conditions": {
-          "operator": "and",
-          "operands": [
-            {
-              "name": "prTargetsBranch",
-              "parameters": {
-                "branchName": "master"
-              }
-            },
-            {
-              "name": "isAction",
-              "parameters": {
-                "action": "merged"
-              }
-            },
-            {
-              "operator": "not",
-              "operands": [
-                {
-                  "name": "isInMilestone",
-                  "parameters": {}
-                }
-              ]
-            }
-          ]
-        },
-        "eventType": "pull_request",
-        "eventNames": [
-          "pull_request",
-          "issues",
-          "project_card"
-        ],
-        "actions": [
-          {
-            "name": "addMilestone",
-            "parameters": {
-              "milestoneName": "current-release"
-            }
-          }
-        ],
-        "taskName": "\"Current\" milestone for merged master PRs"
-      },
-      "disabled": true
-    },
     {
       "taskType": "scheduled",
       "capabilityId": "ScheduledSearch",
       "subCapability": "ScheduledSearch",
       "version": "1.1",
-      "id": "Vs-iCm9G2_R4ZwMN511fw",
       "config": {
         "frequency": [
           {
@@ -138,12 +69,6 @@
               "label": "needs-more-info"
             }
           },
-          {
-            "name": "noLabel",
-            "parameters": {
-              "label": "needs-attention"
-            }
-          },
           {
             "name": "notPartOfMilestone",
             "parameters": {
@@ -207,7 +132,6 @@
       "capabilityId": "ScheduledSearch",
       "subCapability": "ScheduledSearch",
       "version": "1.1",
-      "id": "zyeSRvg_Epub_oXWwaxj3",
       "config": {
         "frequency": [
           {
@@ -298,7 +222,7 @@
           {
             "name": "noLabel",
             "parameters": {
-              "label": "needs-attention"
+              "label": "needs-triage"
             }
           }
         ],
@@ -329,7 +253,6 @@
       "capabilityId": "IssueResponder",
       "subCapability": "IssueCommentResponder",
       "version": "1.0",
-      "id": "WBzbPosGhniXQtQgm8oMm",
       "config": {
         "conditions": {
           "operator": "and",
@@ -372,7 +295,7 @@
           {
             "name": "addLabel",
             "parameters": {
-              "label": "needs-attention"
+              "label": "needs-triage"
             }
           }
         ]
@@ -384,7 +307,6 @@
       "capabilityId": "IssueResponder",
       "subCapability": "IssueCommentResponder",
       "version": "1.0",
-      "id": "GU-AG9bRpCo1aFfE07jUZ",
       "config": {
         "conditions": {
           "operator": "and",
@@ -421,12 +343,12 @@
         "eventNames": [
           "issue_comment"
         ],
-        "taskName": "Apply needs-attention to closed stale issues that get comments",
+        "taskName": "Apply needs-triage to closed stale issues that get comments",
         "actions": [
           {
             "name": "addLabel",
             "parameters": {
-              "label": "needs-attention"
+              "label": "needs-triage"
             }
           }
         ]
@@ -437,7 +359,6 @@
       "capabilityId": "IssueResponder",
       "subCapability": "IssuesOnlyResponder",
       "version": "1.0",
-      "id": "ny85tm-H4saOfDbOgErD3",
       "config": {
         "conditions": {
           "operator": "and",
@@ -472,144 +393,11 @@
         ]
       }
     },
-    {
-      "taskType": "trigger",
-      "capabilityId": "IssueResponder",
-      "subCapability": "IssuesOnlyResponder",
-      "version": "1.0",
-      "id": "hpVo319FrpinWBwXVnK8s",
-      "config": {
-        "conditions": {
-          "operator": "and",
-          "operands": [
-            {
-              "name": "addedToMilestone",
-              "parameters": {
-                "milestoneName": "Backlog"
-              }
-            }
-          ]
-        },
-        "eventType": "issue",
-        "eventNames": [
-          "issues",
-          "project_card"
-        ],
-        "taskName": "When added to backlog, remove `needs-triage`",
-        "actions": [
-          {
-            "name": "removeLabel",
-            "parameters": {
-              "label": "needs-triage"
-            }
-          }
-        ]
-      }
-    },
-    {
-      "taskType": "scheduled",
-      "capabilityId": "ScheduledSearch",
-      "subCapability": "ScheduledSearch",
-      "version": "1.1",
-      "id": "0JHwKtkOQj0mLYc7iUySl",
-      "config": {
-        "frequency": [
-          {
-            "weekDay": 0,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 1,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 2,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 3,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 4,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 5,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          },
-          {
-            "weekDay": 6,
-            "hours": [
-              11,
-              12,
-              13
-            ],
-            "timezoneOffset": -7
-          }
-        ],
-        "searchTerms": [
-          {
-            "name": "hasLabel",
-            "parameters": {
-              "label": "bot-test"
-            }
-          },
-          {
-            "name": "created",
-            "parameters": {
-              "operator": "<",
-              "days": 1
-            }
-          }
-        ],
-        "taskName": "Post comment to bot-test",
-        "actions": [
-          {
-            "name": "removeLabel",
-            "parameters": {
-              "label": "bot-test"
-            }
-          }
-        ]
-      }
-    },
     {
       "taskType": "trigger",
       "capabilityId": "IssueResponder",
       "subCapability": "IssueCommentResponder",
       "version": "1.0",
-      "id": "4T-htFPPX7DIas5-BKvde",
       "config": {
         "conditions": {
           "operator": "and",
@@ -639,7 +427,7 @@
           {
             "name": "addLabel",
             "parameters": {
-              "label": "needs-attention"
+              "label": "needs-triage"
             }
           },
           {
@@ -649,7 +437,7 @@
             }
           },
           {
-            "name": "addLabel",
+            "name": "removeLabel",
             "parameters": {
               "label": "needs-more-info"
             }
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index ea69077a58b..1cfbcf182da 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22378.6">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22371.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>b9f4ee617d6976d0937dfbad71481c685052d256</Sha>
+      <Sha>42345a12e94b3933a3cf2c464043385b55ee94bf</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.2.0-rc.146">
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>b8a61266d9a6780cb7eb9c1942695cf813fdef0a</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.3.0-3.22329.30">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.4.0-1.22404.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>29e657c0582904529bae2a87c227220e03f509cf</Sha>
+      <Sha>83ae84b2a99a0bb1cb83525db21d467b99fd0159</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22378.6">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22371.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>b9f4ee617d6976d0937dfbad71481c685052d256</Sha>
+      <Sha>42345a12e94b3933a3cf2c464043385b55ee94bf</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 29c0e5a1cb2..e645f481da7 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -42,10 +42,10 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22378.6</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22371.4</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.3.0-3.22329.30</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.4.0-1.22404.1</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.2.0-rc.146</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>6.0.0</SystemTextJsonVersion>
diff --git a/global.json b/global.json
index 80f82656174..e5558a715f9 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22378.6"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22371.4"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
index ff47a190984..d17003e254e 100644
--- a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
@@ -129,7 +129,7 @@ void TransportDelegate(INodePacket packet)
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/282")]
         public void TestShutDown()
         {
-            SendDataDelegate transportDelegate = PacketProcessor;
+            SendDataDelegate transportDelegate = new(PacketProcessor);
             var weakTransportDelegateReference = new WeakReference(transportDelegate);
             var transportSink = new BuildEventArgTransportSink(transportDelegate);
 
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index ca6d7535564..07e0760970e 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -801,6 +801,18 @@ public void TreatWarningsAsErrorWhenAllSpecified(int loggerMode, int nodeId)
             logger.Errors.ShouldHaveSingleItem();
         }
 
+        [Fact]
+        public void VerifyWarningsPromotedToErrorsAreCounted()
+        {
+            ILoggingService ls = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+            ls.WarningsAsErrors = new HashSet<string>();
+            ls.WarningsAsErrors.Add("FOR123");
+            BuildWarningEventArgs warningArgs = new("abc", "FOR123", "", 0, 0, 0, 0, "warning message", "keyword", "sender");
+            warningArgs.BuildEventContext = new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidProjectContextId, 5, 6);
+            ls.LogBuildEvent(warningArgs);
+            ls.HasBuildSubmissionLoggedErrors(1).ShouldBeTrue();
+        }
+
         /// <summary>
         /// Verifies that a warning is logged as a low importance message when it's warning code is specified.
         /// </summary>
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index cb255f7ae9b..3ff983ec264 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -1,12 +1,14 @@
 ï»¿using System;
 using System.Collections.Generic;
+using System.IO;
+using System.IO.Compression;
 using System.Text;
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
-
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -138,6 +140,73 @@ public void BinaryLoggerShouldSupportFilePathExplicitParameter()
             ObjectModelHelpers.BuildProjectExpectSuccess(s_testProject, binaryLogger);
         }
 
+        [Fact]
+        public void UnusedEnvironmentVariablesDoNotAppearInBinaryLog()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("EnvVar1", "itsValue");
+                env.SetEnvironmentVariable("EnvVar2", "value2");
+                env.SetEnvironmentVariable("EnvVar3", "value3");
+                string contents = @"
+<Project DefaultTargets=""PrintEnvVar"">
+
+<PropertyGroup>
+<MyProp1>value</MyProp1>
+<MyProp2>$(EnvVar2)</MyProp2>
+</PropertyGroup>
+
+<Target Name=""PrintEnvVar"">
+<Message Text=""Environment variable EnvVar3 has value $(EnvVar3)"" Importance=""High"" />
+</Target>
+
+</Project>";
+                TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
+                TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
+                BinaryLogger logger = new();
+                logger.Parameters = _logFile;
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -bl:{logger.Parameters}", out bool success);
+                success.ShouldBeTrue();
+                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
+                success.ShouldBeTrue();
+                string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
+                text.ShouldContain("EnvVar2");
+                text.ShouldContain("value2");
+                text.ShouldContain("EnvVar3");
+                text.ShouldContain("value3");
+                text.ShouldNotContain("EnvVar1");
+                text.ShouldNotContain("itsValue");
+            }
+        }
+
+        [Fact]
+        public void BinaryLoggerShouldEmbedFilesViaTaskOutput()
+        {
+            using var buildManager = new BuildManager();
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={_logFile}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+            var testProject = @"
+<Project>
+    <Target Name=""Build"">
+        <WriteLinesToFile File=""testtaskoutputfile.txt"" Lines=""abc;def;ghi""/>
+        <CreateItem Include=""testtaskoutputfile.txt"">
+            <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
+        </CreateItem>
+    </Target>
+</Project>";
+            ObjectModelHelpers.BuildProjectExpectSuccess(testProject, binaryLogger);
+            var projectImportsZipPath = Path.ChangeExtension(_logFile, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
+        }
+
         [Fact]
         public void BinaryLoggerShouldNotThrowWhenMetadataCannotBeExpanded()
         {
@@ -205,7 +274,6 @@ public void MessagesCanBeLoggedWhenProjectsAreCached()
                 .OverallResult.ShouldBe(BuildResultCode.Success);
         }
 
-
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 4ad1bb35cac..dd5d0c8a1fc 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -24,9 +24,12 @@ public BuildEventArgsSerializationTests()
             _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
-        [Fact]
-        public void RoundtripBuildStartedEventArgs()
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripBuildStartedEventArgs(bool serializeAllEnvironmentVariables)
         {
+            Traits.LogAllEnvironmentVariables = serializeAllEnvironmentVariables;
             var args = new BuildStartedEventArgs(
                 "Message",
                 "HelpKeyword",
@@ -41,13 +44,15 @@ public void RoundtripBuildStartedEventArgs()
                 null,
                 new Dictionary<string, string>
                 {
-                    { "SampleName", "SampleValue" }
+                { "SampleName", "SampleValue" }
                 });
             Roundtrip(args,
-                e => TranslationHelpers.ToString(e.BuildEnvironment),
+                e => serializeAllEnvironmentVariables ? TranslationHelpers.ToString(e.BuildEnvironment) : null,
                 e => e.HelpKeyword,
                 e => e.ThreadId.ToString(),
                 e => e.SenderName);
+
+            Traits.LogAllEnvironmentVariables = false;
         }
 
         [Fact]
@@ -173,6 +178,17 @@ public void RoundtripTaskStartedEventArgs()
                 e => e.ColumnNumber.ToString());
         }
 
+        [Fact]
+        public void RoundtripEnvironmentVariableReadEventArgs()
+        {
+            EnvironmentVariableReadEventArgs args = new("VarName", "VarValue");
+            args.BuildEventContext = new BuildEventContext(4, 5, 6, 7);
+            Roundtrip(args,
+                e => e.Message,
+                e => e.EnvironmentVariableName,
+                e => e.BuildEventContext.ToString());
+        }
+
         [Fact]
         public void RoundtripTaskFinishedEventArgs()
         {
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 997e40b8c83..51d649107b5 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4522,7 +4522,7 @@ public void VerifyMSBuildLogsAMessageWhenLocalPropertyCannotOverrideValueOfGloba
         [Fact]
         public void VerifyPropertyTrackingLoggingDefault()
         {
-            // Having nothing defined should default to nothing being logged.
+            // Having just environment variables defined should default to nothing being logged except one environment variable read.
             this.VerifyPropertyTrackingLoggingScenario(
                 null,
                 logger =>
@@ -4535,7 +4535,9 @@ public void VerifyPropertyTrackingLoggingDefault()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4564,7 +4566,9 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4593,7 +4597,9 @@ public void VerifyPropertyTrackingLoggingNone()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4622,7 +4628,9 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4706,7 +4714,9 @@ public void VerifyPropertyTrackingLoggingUninitializedPropertyRead()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 73732f6d3ba..56126bfbffa 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -33,8 +33,8 @@ public ProjectCacheTests(ITestOutputHelper output)
             _output = output;
             _env = TestEnvironment.Create(output);
 
-            BuildManager.ProjectCacheItems.ShouldBeEmpty();
-            _env.WithInvariant(new CustomConditionInvariant(() => BuildManager.ProjectCacheItems.IsEmpty));
+            BuildManager.ProjectCacheDescriptors.ShouldBeEmpty();
+            _env.WithInvariant(new CustomConditionInvariant(() => BuildManager.ProjectCacheDescriptors.IsEmpty));
         }
 
         public void Dispose()
@@ -461,10 +461,7 @@ public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse t
             // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
             buildParameters = new BuildParameters(buildParameters, resetEnvironment: true)
             {
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    mockCache,
-                    null,
-                    graph)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache)
             };
 
             MockLogger logger;
@@ -477,8 +474,6 @@ public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse t
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Static graph based");
-
             AssertCacheBuild(graph, testData, mockCache, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
@@ -489,10 +484,7 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
             var graph = testData.CreateGraph(_env);
             var mockCache = new InstanceMockCache(testData);
 
-            var projectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                mockCache,
-                null,
-                graph);
+            var projectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache);
 
             // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
             buildParameters = new BuildParameters(buildParameters, resetEnvironment: true)
@@ -516,7 +508,6 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
                 }
             }
 
-            logger.FullLog.ShouldContain("Static graph based");
 
             AssertCacheBuild(graph, testData, mockCache, logger, nodesToBuildResults, targets: null);
         }
@@ -549,28 +540,6 @@ public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
             logger.FullLog.ShouldContain($"EntryPoint: {graph.GraphRoots.First().ProjectReferences.First().ProjectInstance.FullPath}");
         }
 
-        [Fact]
-        public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
-        {
-            var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]?>
-                {
-                    {1, Array.Empty<int>()}
-                },
-                extraContentPerProjectNumber: new Dictionary<int, string>()
-                {
-                    {1, $"<PropertyGroup> <ProjectDependency>{Guid.NewGuid()}</ProjectDependency> </PropertyGroup>"}
-                });
-
-            (_, _, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) = BuildGraphVsScenario(testData, assertBuildResults: false);
-
-            nodesToBuildResults.ShouldHaveSingleItem();
-
-            var buildResult = nodesToBuildResults.First().Value;
-            buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
-            buildResult.Exception.Message.ShouldContain("Project cache service does not support solution only dependencies when running under Visual Studio.");
-        }
-
         private (MockLogger logger, ProjectGraph projectGraph, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) BuildGraphVsScenario(
             GraphCacheResponse testData,
             BuildParameters? buildParameters = null,
@@ -598,14 +567,14 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
                     ? new BuildParameters()
                     : new BuildParameters(buildParameters, resetEnvironment: true);
 
-                BuildManager.ProjectCacheItems.ShouldBeEmpty();
+                BuildManager.ProjectCacheDescriptors.ShouldBeEmpty();
 
                 graph = testData.CreateGraph(_env);
 
-                BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
+                BuildManager.ProjectCacheDescriptors.ShouldHaveSingleItem();
 
                 // VS sets this global property on every project it builds.
-                var solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
+                string solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
 
                 using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
                 {
@@ -613,15 +582,13 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
 
                     foreach (var node in graph.ProjectNodesTopologicallySorted)
                     {
-                        var buildResult = buildSession.BuildProjectFile(
+                        BuildResult buildResult = buildSession.BuildProjectFile(
                             node.ProjectInstance.FullPath,
                             globalProperties:
                                 new Dictionary<string, string>
                                 {
-                                { SolutionProjectGenerator.SolutionPathPropertyName, graph.GraphRoots.First().ProjectInstance.FullPath },
-                                { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty },
-                                { PropertyNames.InnerBuildProperty, "TheInnerBuildProperty"},
-                                { "TheInnerBuildProperty", "FooBar"},
+                                    { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty },
+                                    { "TargetFramework", "net472"},
                                 });
 
                         if (assertBuildResults)
@@ -635,8 +602,6 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
 
                 if (assertBuildResults)
                 {
-                    logger.FullLog.ShouldContain("Visual Studio Workaround based");
-
                     foreach (var node in graph.ProjectNodes)
                     {
                         var projectPath = node.ProjectInstance.FullPath;
@@ -647,16 +612,15 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
                         logger.FullLog.ShouldContain($"Configuration:{projectName}Debug");
                         logger.FullLog.ShouldContain($"Platform:{projectName}x64");
 
-                        // Ensure MSBuild removes the inner build property if present.
-                        logger.FullLog.ShouldContain($"{PropertyNames.InnerBuildProperty}:TheInnerBuildProperty");
-                        logger.FullLog.ShouldNotContain("TheInnerBuildProperty:FooBar");
+                        // Ensure MSBuild removes the target framework if present.
+                        logger.FullLog.ShouldNotContain("TargetFramework:net472");
                     }
                 }
             }
             finally
             {
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
-                BuildManager.ProjectCacheItems.Clear();
+                BuildManager.ProjectCacheDescriptors.Clear();
             }
 
             return (logger, graph, nodesToBuildResults);
@@ -696,8 +660,6 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
         {
             var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
 
-            var designTimeBuildProperty = $"<PropertyGroup> <{DesignTimeProperties.DesignTimeBuild}>true</{DesignTimeProperties.DesignTimeBuild}> </PropertyGroup>";
-
             // Use a few references to stress test the design time build workaround logic.
             var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount()).ToArray();
 
@@ -705,9 +667,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                 graphEdges: new Dictionary<int, int[]?>
                 {
                     {1, referenceNumbers}
-                },
-                nonCacheMissResults: null,
-                extraContentPerProjectNumber: referenceNumbers.ToDictionary(r => r, _ => designTimeBuildProperty));
+                });
 
             try
             {
@@ -722,7 +682,11 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                 var graph = testData.CreateGraph(_env);
 
                 var rootNode = graph.GraphRoots.First();
-                var globalProperties = new Dictionary<string, string> { { "SolutionPath", rootNode.ProjectInstance.FullPath } };
+
+                var globalProperties = new Dictionary<string, string>
+                {
+                    { DesignTimeProperties.DesignTimeBuild, "true" },
+                };
 
                 MockLogger logger;
                 using (var buildSession = new Helpers.BuildManagerSession(_env))
@@ -731,9 +695,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
 
                     // Build references in parallel.
                     var referenceBuildTasks = rootNode.ProjectReferences.Select(
-                        r => buildSession.BuildProjectFileAsync(
-                            r.ProjectInstance.FullPath,
-                            globalProperties: globalProperties));
+                        r => buildSession.BuildProjectFileAsync(r.ProjectInstance.FullPath, globalProperties: globalProperties));
 
                     foreach (var task in referenceBuildTasks)
                     {
@@ -746,23 +708,16 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                         .ShouldHaveSucceeded();
                 }
 
-                logger.FullLog.ShouldContain("Visual Studio Workaround based");
-
-                // Design time builds should not initialize the plugin.
-                logger.FullLog.ShouldNotContain("Running project cache with Visual Studio workaround");
-
-                // Cache doesn't get initialized and queried.
+                // Cache doesn't get initialized, queried, or disposed.
                 logger.FullLog.ShouldNotContain("BeginBuildAsync");
                 logger.FullLog.ShouldNotContain("GetCacheResultAsync for");
                 logger.FullLog.ShouldNotContain("Querying project cache for project");
-
-                // Cache does get disposed.
-                StringShouldContainSubstring(logger.FullLog, "EndBuildAsync", 1);
+                logger.FullLog.ShouldNotContain("EndBuildAsync");
             }
             finally
             {
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
-                BuildManager.ProjectCacheItems.Clear();
+                BuildManager.ProjectCacheDescriptors.Clear();
             }
         }
 
@@ -788,10 +743,7 @@ public void RunningProxyBuildsOnOutOfProcNodesShouldIssueWarning(bool disableInp
             var buildParameters = new BuildParameters
             {
                 MaxNodeCount = Environment.ProcessorCount,
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    mockCache,
-                    null,
-                    graph)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache)
             };
 
             if (disableInprocNodeViaEnvironmentVariable)
@@ -813,8 +765,6 @@ public void RunningProxyBuildsOnOutOfProcNodesShouldIssueWarning(bool disableInp
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Static graph based");
-
             logger.AssertMessageCount("MSB4274", 1);
         }
 
@@ -828,18 +778,12 @@ private void AssertCacheBuild(
         {
             if (instanceMockCache != null)
             {
-                mockLogger.FullLog.ShouldContain("Instance based");
-                mockLogger.FullLog.ShouldNotContain("Assembly path based");
-
                 instanceMockCache.BeginBuildCalled.ShouldBeTrue();
                 instanceMockCache.Requests.Count.ShouldBe(graph.ProjectNodes.Count);
                 instanceMockCache.EndBuildCalled.ShouldBeTrue();
             }
             else
             {
-                mockLogger.FullLog.ShouldContain("Assembly path based");
-                mockLogger.FullLog.ShouldNotContain("Instance based");
-
                 mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: BeginBuildAsync");
                 Regex.Matches(mockLogger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for").Count.ShouldBe(graph.ProjectNodes.Count);
                 mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: EndBuildAsync");
@@ -941,10 +885,7 @@ public void CacheShouldNotGetQueriedForNestedBuildRequests(BuildParameters build
                     </Project>".Cleanup());
 
             var mockCache = new InstanceMockCache();
-            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                mockCache,
-                new[] {new ProjectGraphEntryPoint(project1.Path)},
-                null);
+            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache);
 
             MockLogger logger;
             using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
@@ -976,10 +917,7 @@ public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
 
             var buildParameters = new BuildParameters
             {
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
-                    SamplePluginAssemblyPath.Value,
-                    graph.EntryPointNodes.Select(n => new ProjectGraphEntryPoint(n.ProjectInstance.FullPath)).ToArray(),
-                    null)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(SamplePluginAssemblyPath.Value)
             };
 
             MockLogger logger;
@@ -992,7 +930,7 @@ public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Explicit entry-point based");
+            logger.FullLog.ShouldContain($"Loading the following project cache plugin: {AssemblyMockCache}");
 
             AssertCacheBuild(graph, testData, null, logger, graphResult.ResultsByNode, targets: "Build");
         }
@@ -1019,8 +957,6 @@ public void GraphBuildCanDiscoverAndLoadPluginFromAssembly()
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Static graph based");
-
             AssertCacheBuild(graph, testData, null, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
@@ -1061,7 +997,7 @@ public void BuildFailsWhenCacheBuildResultIsWrong()
 
             var buildParameters = new BuildParameters
             {
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache, null, graph)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache)
             };
 
             MockLogger logger;
@@ -1083,8 +1019,9 @@ public void BuildFailsWhenCacheBuildResultIsWrong()
         }
 
         [Fact]
-        public void GraphBuildErrorsIfMultiplePluginsAreFound()
+        public void MultiplePlugins()
         {
+            // One from the project, one from BuildParameters.
             var graph = Helpers.CreateProjectGraph(
                 _env,
                 new Dictionary<int, int[]?>
@@ -1093,23 +1030,29 @@ public void GraphBuildErrorsIfMultiplePluginsAreFound()
                 },
                 extraContentForAllNodes: @$"
 <ItemGroup>
-   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
+   <{ItemTypeNames.ProjectCachePlugin} Include='{SamplePluginAssemblyPath.Value}' />
 </ItemGroup>
 ");
+            var mockCache = new InstanceMockCache();
+
+            var buildParameters =  new BuildParameters
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache),
+            };
 
             MockLogger logger;
             GraphBuildResult graphResult;
-            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
             {
                 logger = buildSession.Logger;
                 graphResult = buildSession.BuildGraph(graph);
             }
             
-            graphResult.ShouldHaveFailed("A single project cache plugin must be specified but multiple where found:");
+            graphResult.ShouldHaveSucceeded();
         }
 
         [Fact]
-        public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
+        public void NotAllNodesDefineAPlugin()
         {
             var graph = Helpers.CreateProjectGraph(
                 _env,
@@ -1123,7 +1066,7 @@ public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
                         2,
                         @$"
 <ItemGroup>
-   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
+   <{ItemTypeNames.ProjectCachePlugin} Include='{SamplePluginAssemblyPath.Value}' />
 </ItemGroup>
 "
                     }
@@ -1136,8 +1079,8 @@ public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
                 logger = buildSession.Logger;
                 graphResult = buildSession.BuildGraph(graph);
             }
-            
-            graphResult.ShouldHaveFailed("When any static graph node defines a project cache, all nodes must define the same project cache.");
+
+            graphResult.ShouldHaveSucceeded();
         }
 
         public static IEnumerable<object[]> CacheExceptionLocationsTestData
@@ -1185,10 +1128,7 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorL
                     new BuildParameters
                     {
                         UseSynchronousLogging = true,
-                        ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
-                            SamplePluginAssemblyPath.Value,
-                            new[] {new ProjectGraphEntryPoint(project.Path)},
-                            null)
+                        ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(SamplePluginAssemblyPath.Value)
                     });
 
                 logger = buildSession.Logger;
@@ -1285,6 +1225,8 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorL
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocations errorLocations, ErrorKind errorKind)
         {
+            const ErrorLocations exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync;
+
             SetEnvironmentForErrorLocations(errorLocations, errorKind);
 
             var graph = Helpers.CreateProjectGraph(
@@ -1320,36 +1262,51 @@ public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocati
             {
                 buildResult = buildSession.BuildGraph(graph);
 
-                logger.FullLog.ShouldContain("Loading the following project cache plugin:");
-
-                // Static graph build initializes and tears down the cache plugin so all cache plugin exceptions should end up in the GraphBuildResult
-                buildResult.ShouldHaveFailed();
-
-                buildResult.Exception.ShouldBeOfType<ProjectCacheException>();
+                if (!errorLocations.HasFlag(ErrorLocations.Constructor))
+                {
+                    logger.FullLog.ShouldContain("Loading the following project cache plugin:");
+                }
 
-                if (errorKind == ErrorKind.Exception)
+                // EndBuildAsync isn't until the build manager is shut down, so the build result itself is successful if that's the only error.
+                if (errorLocations == ErrorLocations.EndBuildAsync)
                 {
-                    buildResult.Exception.InnerException!.ShouldNotBeNull();
-                    buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from");
+                    buildResult.ShouldHaveSucceeded();
                 }
+                else
+                {
+                    buildResult.ShouldHaveFailed();
 
-                logger.FullLog.ShouldNotContain("Cache plugin exception from");
+                    buildResult.Exception.ShouldBeOfType<ProjectCacheException>();
 
-                if (errorKind == ErrorKind.LoggedError)
-                {
-                    logger.FullLog.ShouldContain("Cache plugin logged error from");
+                    if (errorKind == ErrorKind.Exception)
+                    {
+                        buildResult.Exception.InnerException!.ShouldNotBeNull();
+                        buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from");
+                    }
+
+                    logger.FullLog.ShouldNotContain("Cache plugin exception from");
+
+                    if (errorKind == ErrorKind.LoggedError)
+                    {
+                        logger.FullLog.ShouldContain("Cache plugin logged error from");
+                    }
                 }
             }
             finally
             {
-                // Since all plugin exceptions during a graph build end up in the GraphBuildResult, they should not get rethrown by BM.EndBuild
-                Should.NotThrow(() => buildSession.Dispose());
+                if (errorLocations.HasFlag(ErrorLocations.EndBuildAsync)
+                    && (exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & errorLocations) == 0)
+                {
+                    Should.Throw<ProjectCacheException>(() => buildSession.Dispose());
+                }
+                else
+                {
+                    Should.NotThrow(() => buildSession.Dispose());
+                }
             }
 
             logger.BuildFinishedEvents.First().Succeeded.ShouldBeFalse();
 
-            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync;
-
             if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & errorLocations) != 0)
             {
                 logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: GetCacheResultAsync for");
@@ -1390,19 +1347,12 @@ public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
                 UseSynchronousLogging = true
             };
 
-            MockLogger logger;
-            GraphBuildResult graphResult;
-            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
-            {
-                logger = buildSession.Logger;
-                graphResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
-            }
+            var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            GraphBuildResult graphResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
 
-            graphResult.ShouldHaveFailed();
-            graphResult.Exception.InnerException!.ShouldNotBeNull();
-            graphResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+            Should.Throw<ProjectCacheException>(() => buildSession.Dispose()).InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
 
-            StringShouldContainSubstring(logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync", expectedOccurrences: 1);
+            StringShouldContainSubstring(buildSession.Logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync", expectedOccurrences: 1);
         }
 
         [Theory]
@@ -1449,10 +1399,7 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
             var buildParameters = new BuildParameters()
             {
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    cache,
-                    entryPoints: null,
-                    graph),
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(cache),
                 UseSynchronousLogging = useSynchronousLogging,
                 DisableInProcNode = disableInprocNode
             };
@@ -1504,7 +1451,7 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
-                BuildManager.ProjectCacheItems.ShouldBeEmpty();
+                BuildManager.ProjectCacheDescriptors.ShouldBeEmpty();
 
                 var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount() * 2).ToArray();
 
@@ -1518,11 +1465,9 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
 
                 var graph = testData.CreateGraph(_env);
 
-                // Even though the assembly cache is discovered, we'll be overriding it with a descriptor based cache.
-                BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
+                BuildManager.ProjectCacheDescriptors.ShouldHaveSingleItem();
 
-                var solutionConfigurationGlobalProperty =
-                    CreateSolutionConfigurationProperty(graph.ProjectNodes);
+                var solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
 
                 var buildParameters = new BuildParameters
                 {
@@ -1539,13 +1484,12 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
 
                     foreach (var node in graph.ProjectNodes.Where(n => referenceNumbers.Contains(GetProjectNumber(n))))
                     {
-                        var buildResultTask = buildSession.BuildProjectFileAsync(
+                        Task<BuildResult> buildResultTask = buildSession.BuildProjectFileAsync(
                             node.ProjectInstance.FullPath,
                             globalProperties:
                             new Dictionary<string, string>
                             {
-                            { SolutionProjectGenerator.SolutionPathPropertyName, graph.GraphRoots.First().ProjectInstance.FullPath },
-                            { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty }
+                                { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty }
                             });
 
                         buildResultTasks.Add(buildResultTask);
@@ -1556,21 +1500,15 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                         buildResultTask.Result.ShouldHaveSucceeded();
                     }
 
-                    buildSession.BuildProjectFile(
-                            graph.GraphRoots.First().ProjectInstance.FullPath,
-                            globalProperties:
-                            new Dictionary<string, string> { { "SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath } })
-                        .ShouldHaveSucceeded();
+                    buildSession.BuildProjectFile(graph.GraphRoots.First().ProjectInstance.FullPath).ShouldHaveSucceeded();
                 }
 
                 StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", graph.ProjectNodes.Count);
-
-                logger.FullLog.ShouldContain("Visual Studio Workaround based");
             }
             finally
             {
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
-                BuildManager.ProjectCacheItems.Clear();
+                BuildManager.ProjectCacheDescriptors.Clear();
             }
         }
 
@@ -1595,10 +1533,7 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
             var buildParameters = new BuildParameters()
             {
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    cache,
-                    entryPoints: null,
-                    graph),
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(cache),
                 UseSynchronousLogging = useSynchronousLogging,
                 DisableInProcNode = disableInprocNode
             };
@@ -1676,9 +1611,7 @@ public void ProxyCacheHitsOnPreviousCacheMissesShouldWork()
                                         new ProxyTargets(new Dictionary<string, string> {{proxyTarget, cacheHitTarget}})));
                             }
                         }
-                    },
-                    projectPaths.Select(p => new ProjectGraphEntryPoint(p)).ToArray(),
-                    projectGraph: null),
+                    }),
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount()
             };
 
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index c6f7af84e57..6159f3af2c1 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -22,6 +22,7 @@
 using System.Collections.Generic;
 using System.IO;
 using Xunit.Abstractions;
+using Shouldly;
 
 #nullable disable
 
@@ -80,55 +81,41 @@ public UtilitiesTestReadOnlyLoad()
         [Fact]
         public void CommentsInPreprocessing()
         {
-            Microsoft.Build.Construction.XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
+            using TestEnvironment env = TestEnvironment.Create();
+            XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
 
-            string input = FileUtilities.GetTemporaryFile();
-            string output = FileUtilities.GetTemporaryFile();
+            TransientTestFile inputFile = env.CreateFile("tempInput.tmp", ObjectModelHelpers.CleanupFileContents(@"
+<Project DefaultTargets='Build'>
+<Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets'/>
+</Project>"));
+            TransientTestFile outputFile = env.CreateFile("tempOutput.tmp");
 
-            string _initialLoadFilesWriteable = Environment.GetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE");
-            try
-            {
-                Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-<Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
-  <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets'/>
-</Project>");
-                File.WriteAllText(input, content);
+            env.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
 
 #if FEATURE_GET_COMMANDLINE
-                Assert.Equal(MSBuildApp.ExitType.Success, MSBuildApp.Execute(@"c:\bin\msbuild.exe """ + input +
-                    (NativeMethodsShared.IsUnixLike ? @""" -pp:""" : @""" /pp:""") + output + @""""));
+            MSBuildApp.Execute(@"c:\bin\msbuild.exe """ + inputFile.Path +
+                (NativeMethodsShared.IsUnixLike ? @""" -pp:""" : @""" /pp:""") + outputFile.Path + @"""")
+                .ShouldBe(MSBuildApp.ExitType.Success);
 #else
-                Assert.Equal(
-                    MSBuildApp.ExitType.Success,
-                    MSBuildApp.Execute(
-                        new[] { @"c:\bin\msbuild.exe", '"' + input + '"',
-                    '"' + (NativeMethodsShared.IsUnixLike ? "-pp:" : "/pp:") + output + '"'}));
+            Assert.Equal(
+                MSBuildApp.ExitType.Success,
+                MSBuildApp.Execute(
+                    new[] { @"c:\bin\msbuild.exe", '"' + inputFile.Path + '"',
+                '"' + (NativeMethodsShared.IsUnixLike ? "-pp:" : "/pp:") + outputFile.Path + '"'}));
 #endif
 
-                bool foundDoNotModify = false;
-                foreach (string line in File.ReadLines(output))
+            bool foundDoNotModify = false;
+            foreach (string line in File.ReadLines(outputFile.Path))
+            {
+                line.ShouldNotContain("<!---->", "This is what it will look like if we're loading read/only");
+
+                if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
                 {
-                    if (line.Contains("<!---->")) // This is what it will look like if we're loading read/only
-                    {
-                        Assert.True(false);
-                    }
-
-                    if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
-                    {
-                        foundDoNotModify = true;
-                    }
+                    foundDoNotModify = true;
                 }
-
-                Assert.True(foundDoNotModify);
-            }
-            finally
-            {
-                File.Delete(input);
-                File.Delete(output);
-                Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", _initialLoadFilesWriteable);
             }
+
+            foundDoNotModify.ShouldBeTrue();
         }
 
         [Fact]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 606d1008930..cee9a2e7055 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -20,10 +20,10 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
@@ -46,8 +46,10 @@ namespace Microsoft.Build.Execution
     [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Refactoring at the end of Beta1 is not appropriate.")]
     public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
     {
-        // TODO: Remove this when VS gets updated to setup project cache plugins.
-        internal static ConcurrentDictionary<string, ProjectCacheItem> ProjectCacheItems { get; } = new ConcurrentDictionary<string, ProjectCacheItem>();
+        // TODO: Figure out a more elegant way to do this.
+        //       The rationale for this is that we can detect during design-time builds in the Evaluator (which populates this) that the project cache will be used so that we don't
+        //       need to evaluate the project at build time just to figure that out, which would regress perf for scenarios which don't use the project cache.
+        internal static ConcurrentDictionary<ProjectCacheDescriptor, ProjectCacheDescriptor> ProjectCacheDescriptors { get; } = new (ProjectCacheDescriptorEqualityComparer.Instance);
 
         /// <summary>
         /// The object used for thread-safe synchronization of static members.
@@ -131,6 +133,11 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private bool _shuttingDown;
 
+        /// <summary>
+        /// CancellationTokenSource to use for async operations. This will be cancelled when we are shutting down to cancel any async operations.
+        /// </summary>
+        private CancellationTokenSource _executionCancellationTokenSource;
+
         /// <summary>
         /// The current state of the BuildManager.
         /// </summary>
@@ -234,11 +241,6 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private ActionBlock<Action> _workQueue;
 
-        /// <summary>
-        /// A cancellation token source used to cancel graph build scheduling
-        /// </summary>
-        private CancellationTokenSource _graphSchedulingCancellationSource;
-
         /// <summary>
         /// Flag indicating we have disposed.
         /// </summary>
@@ -250,7 +252,10 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         private DateTime _instantiationTimeUtc;
 
         private IEnumerable<DeferredBuildMessage> _deferredBuildMessages;
-        private Task<ProjectCacheService> _projectCacheService;
+
+        private ProjectCacheService _projectCacheService;
+
+        private bool _hasProjectCacheServiceInitializedVsScenario;
 
 #if DEBUG
         /// <summary>
@@ -483,6 +488,8 @@ public void BeginBuild(BuildParameters parameters)
                     Strings.EnableDiagnostics();
                 }
 
+                _executionCancellationTokenSource = new CancellationTokenSource();
+
                 _overallBuildSuccess = true;
 
                 // Clone off the build parameters.
@@ -510,11 +517,10 @@ public void BeginBuild(BuildParameters parameters)
 
                 InitializeCaches();
 
-                if (_buildParameters.ProjectCacheDescriptor != null)
-                {
-                    // TODO: Implement cancellation.
-                    InitializeProjectCacheService(_buildParameters.ProjectCacheDescriptor, CancellationToken.None);
-                }
+                _projectCacheService = new ProjectCacheService(
+                    this,
+                    loggingService,
+                    _buildParameters.ProjectCacheDescriptor);
 
                 _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
                 _scheduler = ((IBuildComponentHost)this).GetComponent(BuildComponentType.Scheduler) as IScheduler;
@@ -666,26 +672,6 @@ private static void AttachDebugger()
             }
         }
 
-        private void InitializeProjectCacheService(
-            ProjectCacheDescriptor pluginDescriptor,
-            CancellationToken cancellationToken)
-        {
-            Debug.Assert(Monitor.IsEntered(_syncLock));
-
-            if (_projectCacheService != null)
-            {
-                ErrorUtilities.ThrowInternalError("Only one project cache plugin may be set on the BuildManager during a begin / end build session");
-            }
-
-            LogMessage(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("LoadingProjectCachePlugin", pluginDescriptor.GetDetailedDescription()));
-
-            _projectCacheService = ProjectCacheService.FromDescriptorAsync(
-                pluginDescriptor,
-                this,
-                ((IBuildComponentHost) this).LoggingService,
-                cancellationToken);
-        }
-
         /// <summary>
         /// Cancels all outstanding submissions asynchronously.
         /// </summary>
@@ -917,10 +903,7 @@ public void EndBuild()
                     _workQueue.Completion.Wait();
                 }
 
-                // Stop the graph scheduling thread(s)
-                _graphSchedulingCancellationSource?.Cancel();
-
-                var projectCacheShutdown = _projectCacheService?.Result.ShutDown();
+                Task projectCacheDispose = _projectCacheService.DisposeAsync().AsTask();
 
                 ErrorUtilities.VerifyThrow(_buildSubmissions.Count == 0 && _graphBuildSubmissions.Count == 0, "All submissions not yet complete.");
                 ErrorUtilities.VerifyThrow(_activeNodes.Count == 0, "All nodes not yet shut down.");
@@ -930,7 +913,7 @@ public void EndBuild()
                     SerializeCaches();
                 }
 
-                projectCacheShutdown?.Wait();
+                projectCacheDispose.Wait();
 
 #if DEBUG
                 if (_projectStartedEvents.Count != 0)
@@ -1109,11 +1092,9 @@ public GraphBuildResult Build(BuildParameters parameters, GraphBuildRequestData
         /// </summary>
         public void ShutdownAllNodes()
         {
-            if (_nodeManager == null)
-            {
-                _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;
-            }
+            MSBuildClient.ShutdownServer(CancellationToken.None);
 
+            _nodeManager ??= (INodeManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager);
             _nodeManager.ShutdownAllNodes();
         }
 
@@ -1246,7 +1227,20 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                     shuttingDown = _shuttingDown;
                     if (!shuttingDown)
                     {
-                        if (ProjectCacheIsPresent())
+                        if (!_hasProjectCacheServiceInitializedVsScenario
+                            && BuildEnvironmentHelper.Instance.RunningInVisualStudio
+                            && !ProjectCacheDescriptors.IsEmpty)
+                        {
+                            // Only initialize once as it should be the same for all projects.
+                            _hasProjectCacheServiceInitializedVsScenario = true;
+
+                            _projectCacheService.InitializePluginsForVsScenario(
+                                ProjectCacheDescriptors.Values,
+                                resolvedConfiguration,
+                                _executionCancellationTokenSource.Token);
+                        }
+
+                        if (_projectCacheService.ShouldUseCache(resolvedConfiguration))
                         {
                             IssueCacheRequestForBuildSubmission(new CacheRequest(submission, resolvedConfiguration));
                         }
@@ -1258,11 +1252,6 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                     }
                 }
             }
-            catch (ProjectCacheException ex)
-            {
-                ErrorUtilities.VerifyThrow(resolvedConfiguration is not null, "Cannot call project cache without having BuildRequestConfiguration");
-                CompleteSubmissionWithException(submission, resolvedConfiguration, ex);
-            }
             catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
             {
                 if (resolvedConfiguration is not null)
@@ -1286,28 +1275,6 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
             }
         }
 
-        bool ProjectCacheIsPresent()
-        {
-            // TODO: remove after we change VS to set the cache descriptor via build parameters.
-            // TODO: no need to access the service when there's no design time builds.
-            var projectCacheService = GetProjectCacheService();
-
-            if (projectCacheService != null && projectCacheService.DesignTimeBuildsDetected)
-            {
-                return false;
-            }
-
-            return
-                projectCacheService != null ||
-                _buildParameters.ProjectCacheDescriptor != null ||
-                ProjectCachePresentViaVisualStudioWorkaround();
-        }
-
-        private static bool ProjectCachePresentViaVisualStudioWorkaround()
-        {
-            return BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Any();
-        }
-
         // Cache requests on configuration N do not block future build submissions depending on configuration N.
         // It is assumed that the higher level build orchestrator (static graph scheduler, VS, quickbuild) submits a
         // project build request only when its references have finished building.
@@ -1319,17 +1286,7 @@ private void IssueCacheRequestForBuildSubmission(CacheRequest cacheRequest)
             {
                 try
                 {
-                    var projectCacheService = GetProjectCacheService();
-
-                    ErrorUtilities.VerifyThrow(
-                        projectCacheService != null,
-                        "This method should not get called if there's no project cache.");
-
-                    ErrorUtilities.VerifyThrow(
-                        !projectCacheService.DesignTimeBuildsDetected,
-                        "This method should not get called if design time builds are detected.");
-
-                    projectCacheService.PostCacheRequest(cacheRequest);
+                    _projectCacheService.PostCacheRequest(cacheRequest, _executionCancellationTokenSource.Token);
                 }
                 catch (Exception e)
                 {
@@ -1338,57 +1295,6 @@ private void IssueCacheRequestForBuildSubmission(CacheRequest cacheRequest)
             });
         }
 
-        private ProjectCacheService GetProjectCacheService()
-        {
-            // TODO: remove after we change VS to set the cache descriptor via build parameters.
-            AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio();
-
-            try
-            {
-                return _projectCacheService?.Result;
-            }
-            catch(Exception ex)
-            {
-                if (ex is AggregateException ae && ae.InnerExceptions.Count == 1)
-                {
-                    ex = ae.InnerExceptions.First();
-                }
-
-                // These are exceptions thrown during project cache startup (assembly load issues or cache BeginBuild exceptions).
-                // Set to null so that EndBuild does not try to shut it down and thus rethrow the exception.
-                Interlocked.Exchange(ref _projectCacheService, null);
-                throw ex;
-            }
-        }
-
-        private void AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio()
-        {
-            if (BuildEnvironmentHelper.Instance.RunningInVisualStudio &&
-                ProjectCacheItems.Any() &&
-                _projectCacheService == null &&
-                _buildParameters.ProjectCacheDescriptor == null)
-            {
-                lock (_syncLock)
-                {
-                    if (_projectCacheService != null)
-                    {
-                        return;
-                    }
-
-                    if (ProjectCacheItems.Count != 1)
-                    {
-                        ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
-                            "OnlyOneCachePluginMustBeSpecified",
-                            string.Join("; ", ProjectCacheItems.Values.Select(c => c.PluginPath)));
-                    }
-
-                    var projectCacheItem = ProjectCacheItems.First().Value;
-
-                    InitializeProjectCacheService(ProjectCacheDescriptor.FromVisualStudioWorkaround(projectCacheItem), CancellationToken.None);
-                }
-            }
-        }
-
         /// <summary>
         /// This method adds the graph build request in the specified submission to the set of requests being handled by the scheduler.
         /// </summary>
@@ -1411,12 +1317,6 @@ internal void ExecuteSubmission(GraphBuildSubmission submission)
                         return;
                     }
 
-                    // Lazily create a cancellation token source to be used for all graph scheduling tasks running from this build manager.
-                    if (_graphSchedulingCancellationSource == null)
-                    {
-                        _graphSchedulingCancellationSource = new CancellationTokenSource();
-                    }
-
                     // Do the scheduling in a separate thread to unblock the calling thread
                     Task.Factory.StartNew(
                         () =>
@@ -1430,7 +1330,7 @@ internal void ExecuteSubmission(GraphBuildSubmission submission)
                                 HandleSubmissionException(submission, ex);
                             }
                         },
-                        _graphSchedulingCancellationSource.Token,
+                        _executionCancellationTokenSource.Token,
                         TaskCreationOptions.LongRunning,
                         TaskScheduler.Default);
                 }
@@ -1957,13 +1857,13 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
 
             if (submission.BuildRequestData.GraphBuildOptions.Build)
             {
-                var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
+                // Kick off project cache initialization frontloading
+                Task.Run(() => _projectCacheService.InitializePluginsForGraph(projectGraph, _executionCancellationTokenSource.Token));
+
                 var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
 
                 DumpGraph(projectGraph, targetListTask);
 
-                using DisposablePluginService cacheService = cacheServiceTask.Result;
-
                 resultsPerNode = BuildGraph(projectGraph, targetListTask, submission.BuildRequestData);
             }
             else
@@ -2079,104 +1979,6 @@ GraphBuildRequestData graphBuildRequestData
             return resultsPerNode;
         }
 
-        private DisposablePluginService SearchAndInitializeProjectCachePluginFromGraph(ProjectGraph projectGraph)
-        {
-            // TODO: Consider allowing parallel graph submissions, each with its own separate cache plugin. Right now the second graph submission with a cache will fail.
-
-            if (_buildParameters.ProjectCacheDescriptor != null)
-            {
-                // Build parameter specified project cache takes precedence.
-                return new DisposablePluginService(null);
-            }
-
-            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(
-                n => n,
-                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)
-                    .Select(
-                        i =>
-                        {
-                            var metadataDictionary = i.Metadata.ToDictionary(
-                                m => ((IKeyed) m).Key,
-                                m => ((IValued) m).EscapedValue);
-
-                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);
-
-                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);
-
-                            return projectCacheItem;
-                        })
-                    .ToArray());
-
-            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();
-
-            if (cacheItems.Count == 0)
-            {
-                return new DisposablePluginService(null);
-            }
-
-            if (cacheItems.Count != 1)
-            {
-                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
-                    "OnlyOneCachePluginMustBeSpecified",
-                    string.Join("; ", cacheItems.Select(ci => ci.PluginPath)));
-            }
-
-            var nodesWithoutCacheItems = nodeToCacheItems.Where(kvp => kvp.Value.Length == 0).ToArray();
-
-            if (nodesWithoutCacheItems.Length > 0)
-            {
-                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
-                    "NotAllNodesDefineACacheItem",
-                    ItemTypeNames.ProjectCachePlugin,
-                    string.Join(", ", nodesWithoutCacheItems.Select(kvp => kvp.Key.ProjectInstance.FullPath)));
-            }
-
-            var cacheItem = cacheItems.First();
-
-            lock (_syncLock)
-            {
-                InitializeProjectCacheService(
-                    ProjectCacheDescriptor.FromAssemblyPath(
-                        cacheItem.PluginPath,
-                        entryPoints: null,
-                        projectGraph,
-                        cacheItem.PluginSettings),
-                    _graphSchedulingCancellationSource.Token);
-            }
-
-            return new DisposablePluginService(this);
-        }
-
-        private class DisposablePluginService : IDisposable
-        {
-            private readonly BuildManager _buildManager;
-
-            public DisposablePluginService(BuildManager buildManager)
-            {
-                _buildManager = buildManager;
-            }
-
-            public void Dispose()
-            {
-                if (_buildManager == null)
-                {
-                    return;
-                }
-
-                lock (_buildManager._syncLock)
-                {
-                    try
-                    {
-                        _buildManager._projectCacheService?.Result.ShutDown().GetAwaiter().GetResult();
-                    }
-                    finally
-                    {
-                        _buildManager._projectCacheService = null;
-                    }
-                }
-            }
-        }
-
         /// <summary>
         /// Asks the nodeManager to tell the currently connected nodes to shut down and sets a flag preventing all non-shutdown-related packets from
         /// being processed.
@@ -2186,6 +1988,7 @@ private void ShutdownConnectedNodes(bool abort)
             lock (_syncLock)
             {
                 _shuttingDown = true;
+                _executionCancellationTokenSource.Cancel();
 
                 // If we are aborting, we will NOT reuse the nodes because their state may be compromised by attempts to shut down while the build is in-progress.
                 _nodeManager.ShutdownConnectedNodes(!abort && _buildParameters.EnableNodeReuse);
@@ -2253,6 +2056,8 @@ private void Reset()
             _nodeManager = null;
 
             _shuttingDown = false;
+            _executionCancellationTokenSource.Dispose();
+            _executionCancellationTokenSource = null;
             _nodeConfiguration = null;
             _buildSubmissions.Clear();
             _graphBuildSubmissions.Clear();
@@ -2260,8 +2065,8 @@ private void Reset()
             _scheduler.Reset();
             _scheduler = null;
             _workQueue = null;
-            _graphSchedulingCancellationSource = null;
             _projectCacheService = null;
+            _hasProjectCacheServiceInitializedVsScenario = false;
             _acquiredProjectRootElementCacheFromProjectInstance = false;
 
             _unnamedProjectInstanceToNames.Clear();
@@ -2547,6 +2352,7 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
             _shuttingDown = true;
+            _executionCancellationTokenSource.Cancel();
             ErrorUtilities.VerifyThrow(_activeNodes.Contains(node), "Unexpected shutdown from node {0} which shouldn't exist.", node);
             _activeNodes.Remove(node);
 
@@ -3157,10 +2963,10 @@ private void Dispose(bool disposing)
                             _workQueue = null;
                         }
 
-                        if (_graphSchedulingCancellationSource != null)
+                        if (_executionCancellationTokenSource != null)
                         {
-                            _graphSchedulingCancellationSource.Cancel();
-                            _graphSchedulingCancellationSource = null;
+                            _executionCancellationTokenSource.Cancel();
+                            _executionCancellationTokenSource = null;
                         }
 
                         if (_noActiveSubmissionsEvent != null)
@@ -3276,6 +3082,7 @@ private void CancelAndMarkAsFailure()
             // CancelAllSubmissions also ends up setting _shuttingDown and _overallBuildSuccess but it does so in a separate thread to avoid deadlocks.
             // This might cause a race with the first builds which might miss the shutdown update and succeed instead of fail.
             _shuttingDown = true;
+            _executionCancellationTokenSource.Cancel();
             _overallBuildSuccess = false;
         }
 
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 1fec6f1c510..fca7476b2d5 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -791,10 +791,8 @@ public string OutputResultsCacheFile
         public bool LowPriority { get; set; }
 
         /// <summary>
-        /// If set, the BuildManager will query all
-        /// incoming <see cref="BuildSubmission"/> requests against the specified project cache.
-        /// Any <see cref="GraphBuildSubmission"/> requests will also use this project cache instead of
-        /// the potential project caches described in graph node's evaluations.
+        /// Gets or sets the project cache description to use for all <see cref="BuildSubmission"/> or <see cref="GraphBuildSubmission"/>
+        /// in addition to any potential project caches described in each project.
         /// </summary>
         public ProjectCacheDescriptor ProjectCacheDescriptor { get; set; }
 
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 4e88c67398a..be791e7ced8 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -8,6 +8,7 @@
 using System.Globalization;
 using System.IO;
 using System.IO.Pipes;
+using System.Linq;
 using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Client;
@@ -72,7 +73,7 @@ public sealed class MSBuildClient
         /// <summary>
         /// The named pipe stream for client-server communication.
         /// </summary>
-        private readonly NamedPipeClientStream _nodeStream;
+        private NamedPipeClientStream _nodeStream = null!;
 
         /// <summary>
         /// A way to cache a byte array when writing out packets
@@ -95,6 +96,11 @@ public sealed class MSBuildClient
         /// </summary>
         private TargetConsoleConfiguration? _consoleConfiguration;
 
+        /// <summary>
+        /// Incoming packet pump and redirection.
+        /// </summary>
+        private MSBuildClientPacketPump _packetPump = null!;
+
         /// <summary>
         /// Public constructor with parameters.
         /// </summary>
@@ -120,14 +126,20 @@ public MSBuildClient(
             // Client <-> Server communication stream
             _handshake = GetHandshake();
             _pipeName = OutOfProcServerNode.GetPipeName(_handshake);
+            _packetMemoryStream = new MemoryStream();
+            _binaryWriter = new BinaryWriter(_packetMemoryStream);
+
+            CreateNodePipeStream();
+        }
+
+        private void CreateNodePipeStream()
+        {
             _nodeStream = new NamedPipeClientStream(".", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
 #if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                                                                         | PipeOptions.CurrentUserOnly
+                | PipeOptions.CurrentUserOnly
 #endif
             );
-
-            _packetMemoryStream = new MemoryStream();
-            _binaryWriter = new BinaryWriter(_packetMemoryStream);
+            _packetPump = new MSBuildClientPacketPump(_nodeStream);
         }
 
         /// <summary>
@@ -148,11 +160,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
 #endif
 
             CommunicationsUtilities.Trace("Executing build with command line '{0}'", descriptiveCommandLine);
-            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);
-            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);
-
-            // Start server it if is not running.
-            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);
+            bool serverIsAlreadyRunning = ServerIsRunning();
             if (KnownTelemetry.BuildTelemetry != null)
             {
                 KnownTelemetry.BuildTelemetry.InitialServerState = serverIsAlreadyRunning ? "hot" : "cold";
@@ -168,7 +176,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
             }
 
             // Check that server is not busy.
-            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);
+            bool serverWasBusy = ServerWasBusy();
             if (serverWasBusy)
             {
                 CommunicationsUtilities.Trace("Server is busy, falling back to former behavior.");
@@ -195,10 +203,86 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
             _numConsoleWritePackets = 0;
             _sizeOfConsoleWritePackets = 0;
 
+            ReadPacketsLoop(cancellationToken);
+
+            MSBuildEventSource.Log.MSBuildServerBuildStop(descriptiveCommandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);
+            CommunicationsUtilities.Trace("Build finished.");
+            return _exitResult;
+        }
+
+        /// <summary>
+        /// Attempt to shutdown MSBuild Server node.
+        /// </summary>
+        /// <remarks>
+        /// It shutdown only server created by current user with current admin elevation.
+        /// </remarks>
+        /// <param name="cancellationToken"></param>
+        /// <returns>True if server is not running anymore.</returns>
+        public static bool ShutdownServer(CancellationToken cancellationToken)
+        {
+            // Neither commandLine nor msbuildlocation is involved in node shutdown
+            var client = new MSBuildClient(commandLine: null!, msbuildLocation: null!);
+
+            return client.TryShutdownServer(cancellationToken);
+        }
+
+        private bool TryShutdownServer(CancellationToken cancellationToken)
+        {
+            CommunicationsUtilities.Trace("Trying shutdown server node.");
+
+            bool serverIsAlreadyRunning = ServerIsRunning();
+            if (!serverIsAlreadyRunning)
+            {
+                CommunicationsUtilities.Trace("No need to shutdown server node for it is not running.");
+                return true;
+            }
+
+            // Check that server is not busy.
+            bool serverWasBusy = ServerWasBusy();
+            if (serverWasBusy)
+            {
+                CommunicationsUtilities.Trace("Server cannot be shut down for it is not idle.");
+                return false;
+            }
+
+            // Connect to server.
+            if (!TryConnectToServer(1_000))
+            {
+                CommunicationsUtilities.Trace("Client cannot connect to idle server to shut it down.");
+                return false;
+            }
+
+            if (!TrySendShutdownCommand())
+            {
+                CommunicationsUtilities.Trace("Failed to send shutdown command to the server.");
+                return false;
+            }
+
+            ReadPacketsLoop(cancellationToken);
+
+            return _exitResult.MSBuildClientExitType == MSBuildClientExitType.Success;
+        }
+
+        internal bool ServerIsRunning()
+        {
+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);
+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);
+            return serverIsAlreadyRunning;
+        }
+
+        private bool ServerWasBusy()
+        {
+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);
+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);
+            return serverWasBusy;
+        }
+
+        private void ReadPacketsLoop(CancellationToken cancellationToken)
+        {
             try
             {
                 // Start packet pump
-                using MSBuildClientPacketPump packetPump = new(_nodeStream);
+                using MSBuildClientPacketPump packetPump = _packetPump;
 
                 packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);
                 packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);
@@ -207,7 +291,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
                 WaitHandle[] waitHandles =
                 {
                     cancellationToken.WaitHandle,
-                    packetPump.PacketPumpErrorEvent,
+                    packetPump.PacketPumpCompleted,
                     packetPump.PacketReceivedEvent
                 };
 
@@ -224,7 +308,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
                             break;
 
                         case 1:
-                            HandlePacketPumpError(packetPump);
+                            HandlePacketPumpCompleted(packetPump);
                             break;
 
                         case 2:
@@ -246,10 +330,6 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
                 CommunicationsUtilities.Trace("MSBuild client error: problem during packet handling occurred: {0}.", ex);
                 _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;
             }
-
-            MSBuildEventSource.Log.MSBuildServerBuildStop(descriptiveCommandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);
-            CommunicationsUtilities.Trace("Build finished.");
-            return _exitResult;
         }
 
         private void ConfigureAndQueryConsoleProperties()
@@ -409,6 +489,12 @@ private bool TryLaunchServer()
 
         private bool TrySendCancelCommand() => TrySendPacket(() => new ServerNodeBuildCancel());
 
+        private bool TrySendShutdownCommand()
+        {
+            _packetPump.ServerWillDisconnect();
+            return  TrySendPacket(() => new NodeBuildComplete(false /* no node reuse */));
+        }
+
         private ServerNodeBuildCommand GetServerNodeBuildCommand()
         {
             Dictionary<string, string> envVars = new();
@@ -457,16 +543,21 @@ private void HandleCancellation()
         {
             TrySendCancelCommand();
 
-            CommunicationsUtilities.Trace("MSBuild client sent cancelation command.");
+            CommunicationsUtilities.Trace("MSBuild client sent cancellation command.");
         }
 
         /// <summary>
-        /// Handle packet pump error.
+        /// Handle when packet pump is completed both successfully or with error.
         /// </summary>
-        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)
+        private void HandlePacketPumpCompleted(MSBuildClientPacketPump packetPump)
         {
-            CommunicationsUtilities.Trace("MSBuild client error: packet pump unexpectedly shut down: {0}", packetPump.PacketPumpException);
-            throw packetPump.PacketPumpException ?? new InternalErrorException("Packet pump unexpectedly shut down");
+            if (packetPump.PacketPumpException != null)
+            {
+                CommunicationsUtilities.Trace("MSBuild client error: packet pump unexpectedly shut down: {0}", packetPump.PacketPumpException);
+                throw packetPump.PacketPumpException ?? new InternalErrorException("Packet pump unexpectedly shut down");
+            }
+
+            _buildFinished = true;
         }
 
         /// <summary>
@@ -517,17 +608,35 @@ private void HandleServerNodeBuildResult(ServerNodeBuildResult response)
         /// Connects to MSBuild server.
         /// </summary>
         /// <returns> Whether the client connected to MSBuild server successfully.</returns>
-        private bool TryConnectToServer(int timeout)
+        private bool TryConnectToServer(int timeoutMilliseconds)
         {
-            try
-            {
-                NodeProviderOutOfProcBase.ConnectToPipeStream(_nodeStream, _pipeName, _handshake, timeout);
-            }
-            catch (Exception ex)
+            bool tryAgain = true;
+            Stopwatch sw = Stopwatch.StartNew();
+
+            while (tryAgain && sw.ElapsedMilliseconds < timeoutMilliseconds)
             {
-                CommunicationsUtilities.Trace("Failed to connect to server: {0}", ex);
-                _exitResult.MSBuildClientExitType = MSBuildClientExitType.UnableToConnect;
-                return false;
+                tryAgain = false;
+                try
+                {
+                    NodeProviderOutOfProcBase.ConnectToPipeStream(_nodeStream, _pipeName, _handshake, Math.Max(1, timeoutMilliseconds - (int)sw.ElapsedMilliseconds));
+                }
+                catch (Exception ex)
+                {
+                    if (ex is not TimeoutException && sw.ElapsedMilliseconds < timeoutMilliseconds)
+                    {
+                        CommunicationsUtilities.Trace("Retrying to connect to server after {0} ms", sw.ElapsedMilliseconds);
+                        // This solves race condition for time in which server started but have not yet listen on pipe or
+                        // when it just finished build request and is recycling pipe.
+                        tryAgain = true;
+                        CreateNodePipeStream();
+                    }
+                    else
+                    {
+                        CommunicationsUtilities.Trace("Failed to connect to server: {0}", ex);
+                        _exitResult.MSBuildClientExitType = MSBuildClientExitType.UnableToConnect;
+                        return false;
+                    }
+                }
             }
 
             return true;
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 682fa1dfb94..351f922451c 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -27,12 +27,12 @@ internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketF
         public AutoResetEvent PacketReceivedEvent { get; }
 
         /// <summary>
-        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).
+        /// Set when the packet pump terminates.
         /// </summary>
-        public ManualResetEvent PacketPumpErrorEvent { get; }
+        public ManualResetEvent PacketPumpCompleted { get; }
 
         /// <summary>
-        /// Exception appeared when the packet pump unexpectedly terminates.
+        /// Exception appeared when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).
         /// </summary>
         public Exception? PacketPumpException { get; set; }
 
@@ -66,16 +66,24 @@ internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketF
         /// </summary>
         readonly ITranslator _binaryReadTranslator;
 
+        /// <summary>
+        /// True if this side is gracefully disconnecting.
+        /// In such case we have sent last packet to server side and we expect
+        /// it will soon broke pipe connection - unless client do it first.
+        /// </summary>
+        private bool _isServerDisconnecting;
+
         public MSBuildClientPacketPump(Stream stream)
         {
             ErrorUtilities.VerifyThrowArgumentNull(stream, nameof(stream));
 
             _stream = stream;
+            _isServerDisconnecting = false;
             _packetFactory = new NodePacketFactory();
 
             ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();
             PacketReceivedEvent = new AutoResetEvent(false);
-            PacketPumpErrorEvent = new ManualResetEvent(false);
+            PacketPumpCompleted = new ManualResetEvent(false);
             _packetPumpShutdownEvent = new ManualResetEvent(false);
 
             _readBufferMemoryStream = new MemoryStream();
@@ -170,7 +178,7 @@ public void Stop()
         /// set.
         /// </summary>
         /// <remarks>
-        /// Instead of throwing an exception, puts it in <see cref="PacketPumpException"/> and raises event <see cref="PacketPumpErrorEvent"/>.
+        /// Instead of throwing an exception, puts it in <see cref="PacketPumpException"/> and raises event <see cref="PacketPumpCompleted"/>.
         /// </remarks>
         private void PacketPumpProc()
         {
@@ -229,11 +237,17 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                                     // Incomplete read. Abort.
                                     if (headerBytesRead == 0)
                                     {
+                                        if (_isServerDisconnecting)
+                                        {
+                                            continueReading = false;
+                                            break;
+                                        }
+
                                         ErrorUtilities.ThrowInternalError("Server disconnected abruptly");
                                     }
                                     else
                                     {
-                                        ErrorUtilities.ThrowInternalError("Incomplete header read from server.  {0} of {1} bytes read", headerBytesRead, headerByte.Length);
+                                        ErrorUtilities.ThrowInternalError("Incomplete header read.  {0} of {1} bytes read", headerBytesRead, headerByte.Length);
                                     }
                                 }
 
@@ -246,14 +260,18 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                                 _readBufferMemoryStream.SetLength(packetLength);
                                 byte[] packetData = _readBufferMemoryStream.GetBuffer();
 
-                                packetBytesRead = localStream.Read(packetData, 0, packetLength);
-                                
-                                if (packetBytesRead != packetLength)
+                                while (packetBytesRead < packetLength)
                                 {
-                                    // Incomplete read.  Abort.
-                                    ErrorUtilities.ThrowInternalError("Incomplete header read from server. {0} of {1} bytes read", headerBytesRead, headerByte.Length);
-                                }
+                                    int bytesRead = localStream.Read(packetData, packetBytesRead, packetLength-packetBytesRead);
+                                    if (bytesRead == 0)
+                                    {
+                                        // Incomplete read.  Abort.
+                                        ErrorUtilities.ThrowInternalError("Incomplete packet read. {0} of {1} bytes read", packetBytesRead, packetLength);
+                                    }
 
+                                    packetBytesRead += bytesRead;
+                                }
+                                
                                 try
                                 {
                                     _packetFactory.DeserializeAndRoutePacket(0, packetType, _binaryReadTranslator);
@@ -292,13 +310,21 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
             {
                 CommunicationsUtilities.Trace("Exception occurred in the packet pump: {0}", ex);
                 PacketPumpException = ex;
-                PacketPumpErrorEvent.Set();
             }
 
             CommunicationsUtilities.Trace("Ending read loop.");
+            PacketPumpCompleted.Set();
         }
         #endregion
 
         public void Dispose() => Stop();
+
+        /// <summary>
+        /// Signalize that from now on we expect server will break connected named pipe.
+        /// </summary>
+        public void ServerWillDisconnect()
+        {
+            _isServerDisconnecting = true;
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 2f08099b333..b10bd378e32 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -8,7 +8,6 @@
 using System.Linq;
 using System.Reflection;
 using System.Threading;
-using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
@@ -1432,17 +1431,8 @@ private void LoggingEventProcessor(object loggingEvent)
         /// </summary>
         private void RouteBuildEvent(object loggingEvent)
         {
-            BuildEventArgs buildEventArgs = null;
-
-            if (loggingEvent is BuildEventArgs bea)
-            {
-                buildEventArgs = bea;
-            }
-            else if (loggingEvent is KeyValuePair<int, BuildEventArgs> kvp)
-            {
-                buildEventArgs = kvp.Value;
-            }
-            else
+            BuildEventArgs buildEventArgs = loggingEvent as BuildEventArgs ?? (loggingEvent as KeyValuePair<int, BuildEventArgs>?)?.Value;
+            if (buildEventArgs is null)
             {
                 ErrorUtilities.ThrowInternalError("Unknown logging item in queue:" + loggingEvent.GetType().FullName);
             }
@@ -1541,7 +1531,7 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
             TryRaiseProjectStartedEvent(eventArg);
 
             // The event has not been through a filter yet. All events must go through a filter before they make it to a logger
-            if (_filterEventSource != null)   // Loggers may not be registered
+            if (_filterEventSource != null) // Loggers may not be registered
             {
                 // Send the event to the filter, the Consume will not return until all of the loggers which have registered to the event have process
                 // them.
@@ -1562,7 +1552,7 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
                         {
                             if (!sink.HaveLoggedBuildStartedEvent)
                             {
-                                sink.Consume(eventArg, (int)pair.Key);
+                                sink.Consume(eventArg, pair.Key);
                             }
 
                             // Reset the HaveLoggedBuildStarted event because no one else will be sending a build started event to any loggers at this time.
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 214a5118c2c..5a4d694f427 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -388,14 +388,9 @@ public void LogBuildStarted()
                 message = ResourceUtilities.GetResourceString("BuildStarted");
             }
 
-            IDictionary<string, string> environmentProperties = null;
+            IDictionary<string, string> environmentProperties = _componentHost?.BuildParameters?.BuildProcessEnvironment;
 
-            if (_componentHost?.BuildParameters != null)
-            {
-                environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
-            }
-
-            BuildStartedEventArgs buildEvent = new BuildStartedEventArgs(message, null /* no help keyword */, environmentProperties);
+            BuildStartedEventArgs buildEvent = new(message, helpKeyword: null, environmentProperties);
 
             // Raise the event with the filters
             ProcessLoggingEvent(buildEvent);
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index bc39a5ccd32..6c7bb192575 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using static Microsoft.Build.Execution.ProjectPropertyInstance;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 #nullable disable
@@ -100,7 +101,19 @@ private ProjectLoggingContext(
                 !LoggingService.IncludeEvaluationPropertiesAndItems &&
                 (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
             {
-                properties = projectProperties?.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue)) ?? Enumerable.Empty<DictionaryEntry>();
+                if (projectProperties is null)
+                {
+                    properties = Enumerable.Empty<DictionaryEntry>();
+                }
+                else if (Traits.LogAllEnvironmentVariables)
+                {
+                    properties = projectProperties.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue));
+                }
+                else
+                {
+                    properties = projectProperties.Filter(p => p is not EnvironmentDerivedProjectPropertyInstance, p => new DictionaryEntry(p.Name, p.EvaluatedValue));
+                }
+
                 items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? Enumerable.Empty<DictionaryEntry>();
             }
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
index 6ac1b6b6b2a..c5751c5875e 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
@@ -2,130 +2,34 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections.Generic;
-using System.Linq;
-using Microsoft.Build.Graph;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
     public class ProjectCacheDescriptor
     {
-        /// <summary>
-        ///     The path to the assembly containing the project cache plugin.
-        /// </summary>
-        public string? PluginAssemblyPath { get; }
-
-        /// <summary>
-        ///     The entry points with which the plugin will be initialized.
-        /// </summary>
-        public IReadOnlyCollection<ProjectGraphEntryPoint>? EntryPoints { get; }
-
-        /// <summary>
-        ///     The graph with which the plugin will be initialized.
-        /// </summary>
-        public ProjectGraph? ProjectGraph { get; }
-
-        public IReadOnlyDictionary<string, string> PluginSettings { get; }
-
-        public ProjectCachePluginBase? PluginInstance { get; }
-
-        internal bool VsWorkaround { get; }
-
         private ProjectCacheDescriptor(
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings)
-        {
-            ErrorUtilities.VerifyThrowArgument(
-                (entryPoints == null) ^ (projectGraph == null),
-                "EitherEntryPointsOrTheProjectGraphIsSet");
-
-            EntryPoints = entryPoints;
-            ProjectGraph = projectGraph;
-            PluginSettings = pluginSettings ?? new Dictionary<string, string>();
-        }
-
-        private ProjectCacheDescriptor(
-            string pluginAssemblyPath,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)
+            string? pluginAssemblyPath,
+            IReadOnlyDictionary<string, string>? pluginSettings,
+            ProjectCachePluginBase? pluginInstance)
         {
             PluginAssemblyPath = pluginAssemblyPath;
-        }
-
-        private ProjectCacheDescriptor(
-            ProjectCachePluginBase pluginInstance,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)
-        {
+            PluginSettings = pluginSettings ?? new Dictionary<string, string>(0);
             PluginInstance = pluginInstance;
         }
 
-        private ProjectCacheDescriptor(ProjectCacheItem projectCacheItem)
-        {
-            VsWorkaround = true;
-            PluginAssemblyPath = projectCacheItem.PluginPath;
-            PluginSettings = projectCacheItem.PluginSettings;
-        }
-
-        // TODO: remove after we change VS to set the cache descriptor via build parameters.
-        internal static ProjectCacheDescriptor FromVisualStudioWorkaround(ProjectCacheItem projectCacheItem)
-        {
-            return new ProjectCacheDescriptor(projectCacheItem);
-        }
-
-        public static ProjectCacheDescriptor FromAssemblyPath(
-            string pluginAssemblyPath,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings = null)
-        {
-            return new ProjectCacheDescriptor(pluginAssemblyPath, entryPoints, projectGraph, pluginSettings);
-        }
-
-        public static ProjectCacheDescriptor FromInstance(
-            ProjectCachePluginBase pluginInstance,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings = null)
-        {
-            return new ProjectCacheDescriptor(pluginInstance, entryPoints, projectGraph, pluginSettings);
-        }
-
-        public string GetDetailedDescription()
-        {
-            var loadStyle = PluginInstance != null
-                ? $"Instance based: {PluginInstance.GetType().AssemblyQualifiedName}"
-                : $"Assembly path based: {PluginAssemblyPath}";
+        /// <summary>
+        /// Gets the path to the assembly containing the project cache plugin.
+        /// </summary>
+        public string? PluginAssemblyPath { get; }
 
-            var entryPointStyle = EntryPoints != null
-                ? "Explicit entry-point based"
-                : ProjectGraph != null
-                    ? "Static graph based"
-                    : "Visual Studio Workaround based";
+        public IReadOnlyDictionary<string, string> PluginSettings { get; }
 
-            var entryPoints = EntryPoints != null
-                ? string.Join(
-                    "\n",
-                    EntryPoints.Select(e => $"{e.ProjectFile} {{{FormatGlobalProperties(e.GlobalProperties)}}}"))
-                : ProjectGraph != null
-                    ? string.Join(
-                        "\n",
-                        ProjectGraph!.EntryPointNodes.Select(
-                            n =>
-                                $"{n.ProjectInstance.FullPath} {{{FormatGlobalProperties(n.ProjectInstance.GlobalProperties)}}}"))
-                    : "Solution file";
+        public ProjectCachePluginBase? PluginInstance { get; }
 
-            return $"{loadStyle}\nEntry-point style: {entryPointStyle}\nEntry-points:\n{entryPoints}";
+        public static ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, IReadOnlyDictionary<string, string>? pluginSettings = null)
+            => new ProjectCacheDescriptor(pluginAssemblyPath, pluginSettings, pluginInstance: null);
 
-            static string FormatGlobalProperties(IDictionary<string, string>? globalProperties)
-            {
-                return globalProperties == null
-                    ? string.Empty
-                    : string.Join(", ", globalProperties.Select(gp => $"{gp.Key}={gp.Value}"));
-            }
-        }
+        public static ProjectCacheDescriptor FromInstance(ProjectCachePluginBase pluginInstance, IReadOnlyDictionary<string, string>? pluginSettings = null)
+            => new ProjectCacheDescriptor(pluginAssemblyPath: null, pluginSettings, pluginInstance);
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
new file mode 100644
index 00000000000..cb85cae4558
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
@@ -0,0 +1,65 @@
+ï»¿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    internal sealed class ProjectCacheDescriptorEqualityComparer : IEqualityComparer<ProjectCacheDescriptor>
+    {
+        private ProjectCacheDescriptorEqualityComparer()
+        {
+        }
+
+        public static ProjectCacheDescriptorEqualityComparer Instance { get; } = new ProjectCacheDescriptorEqualityComparer();
+
+        public bool Equals(ProjectCacheDescriptor? x, ProjectCacheDescriptor? y)
+        {
+            if (ReferenceEquals(x, y))
+            {
+                return true;
+            }
+
+            if (x is null || y is null)
+            {
+                return false;
+            }
+
+            return string.Equals(x.PluginAssemblyPath, y.PluginAssemblyPath, StringComparison.OrdinalIgnoreCase)
+                && ReferenceEquals(x.PluginInstance, y.PluginInstance)
+                && CollectionHelpers.DictionaryEquals(x.PluginSettings, y.PluginSettings);
+        }
+
+        public int GetHashCode(ProjectCacheDescriptor obj)
+        {
+            int hashCode = -1043047289;
+
+            if (obj.PluginAssemblyPath != null)
+            {
+                hashCode = (hashCode * -1521134295) + StringComparer.OrdinalIgnoreCase.GetHashCode(obj.PluginAssemblyPath);
+            }
+
+            if (obj.PluginInstance != null)
+            {
+                hashCode = (hashCode * -1521134295) + obj.PluginInstance.GetHashCode();
+            }
+
+            if (obj.PluginSettings.Count > 0)
+            {
+                int dictHash = 0;
+                foreach (KeyValuePair<string, string> pluginSetting in obj.PluginSettings)
+                {
+                    // XOR is commutative, so this accounts for arbitrary ordering for dictionaries
+                    dictHash ^= (pluginSetting.Key.GetHashCode() * -1521134295) + pluginSetting.Value.GetHashCode();
+                }
+
+                hashCode = (hashCode * -1521134295) + dictHash;
+            }
+
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs
deleted file mode 100644
index 2982c7508d9..00000000000
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-ï»¿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.Experimental.ProjectCache
-{
-    internal class ProjectCacheItem : IEquatable<ProjectCacheItem>
-    {
-        private readonly IReadOnlyCollection<KeyValuePair<string, string>> _pluginSettingsSorted;
-
-        public ProjectCacheItem(string pluginPath, IReadOnlyDictionary<string, string> pluginSettings)
-        {
-            PluginPath = pluginPath;
-
-            PluginSettings = pluginSettings;
-
-            // Sort by key to avoid doing it during hashcode computation.
-            _pluginSettingsSorted = pluginSettings.OrderBy(_ => _.Key).ToArray();
-        }
-
-        public string PluginPath { get; }
-        public IReadOnlyDictionary<string, string> PluginSettings { get; }
-
-        public bool Equals(ProjectCacheItem? other)
-        {
-            if (ReferenceEquals(this, other))
-            {
-                return true;
-            }
-
-            return PluginPath == other?.PluginPath &&
-                   CollectionHelpers.DictionaryEquals(PluginSettings, other.PluginSettings);
-        }
-
-        public override bool Equals(object? obj)
-        {
-            if (ReferenceEquals(this, obj))
-            {
-                return true;
-            }
-
-            if (obj?.GetType() != GetType())
-            {
-                return false;
-            }
-
-            return Equals((ProjectCacheItem) obj);
-        }
-
-        public override int GetHashCode()
-        {
-            int hashCode = -1043047289;
-
-            hashCode = (hashCode * -1521134295) + PluginPath.GetHashCode();
-
-            foreach (var pluginSetting in _pluginSettingsSorted)
-            {
-                hashCode = (hashCode * -1521134295) + pluginSetting.Key.GetHashCode();
-                hashCode = (hashCode * -1521134295) + pluginSetting.Value.GetHashCode();
-            }
-
-            return hashCode;
-        }
-    }
-}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 8c3cdb46bb8..d33176bb73f 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -2,9 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
+using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Runtime.ExceptionServices;
 using System.Threading;
 using System.Threading.Tasks;
 using System.Xml;
@@ -18,90 +21,139 @@
 using Microsoft.Build.Graph;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
     internal record CacheRequest(BuildSubmission Submission, BuildRequestConfiguration Configuration);
 
-    internal record NullableBool(bool Value)
+    internal sealed class ProjectCacheService : IAsyncDisposable
     {
-        public static implicit operator bool(NullableBool? d) => d is not null && d.Value;
-    }
+        private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };
 
-    internal enum ProjectCacheServiceState
-    {
-        NotInitialized,
-        BeginBuildStarted,
-        BeginBuildFinished,
-        ShutdownStarted,
-        ShutdownFinished
-    }
+        private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { "TargetFramework", "Configuration", "Platform", "TargetPlatform", "OutputType" };
 
-    internal class ProjectCacheService
-    {
         private readonly BuildManager _buildManager;
         private readonly ILoggingService _loggingService;
-        private readonly ProjectCacheDescriptor _projectCacheDescriptor;
-        private readonly CancellationToken _cancellationToken;
-        private readonly ProjectCachePluginBase _projectCachePlugin;
-        private readonly string _projectCachePluginTypeName;
-        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;
+
+        private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;
+
+        private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);
+
+        private bool _isVsScenario;
+
+        private bool _isDisposed;
+
+        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);
 
         /// <summary>
         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,
         /// i.e. falling back to FileSystem.Default.
         /// </summary>
-        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }
-
-        // Use NullableBool to make it work with Interlock.CompareExchange (doesn't accept bool?).
-        // Assume that if one request is a design time build, all of them are.
-        // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.
-        // TODO: remove after we change VS to set the cache descriptor via build parameters.
-        public volatile NullableBool? DesignTimeBuildsDetected;
-        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;
-
-        private ProjectCacheService(
-            ProjectCachePluginBase projectCachePlugin,
-            string pluginTypeName,
+        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase
+        {
+            private DefaultMSBuildFileSystem()
+            {
+            }
+
+            public static DefaultMSBuildFileSystem Instance { get; } = new();
+        }
+
+        public ProjectCacheService(
             BuildManager buildManager,
             ILoggingService loggingService,
-            ProjectCacheDescriptor projectCacheDescriptor,
-            CancellationToken cancellationToken
-        )
+            ProjectCacheDescriptor? globalProjectCacheDescriptor)
         {
-            _projectCachePlugin = projectCachePlugin;
-            _projectCachePluginTypeName = pluginTypeName;
             _buildManager = buildManager;
             _loggingService = loggingService;
-            _projectCacheDescriptor = projectCacheDescriptor;
-            _cancellationToken = cancellationToken;
+            _globalProjectCacheDescriptor = globalProjectCacheDescriptor;
         }
 
-        public static async Task<ProjectCacheService> FromDescriptorAsync(
-            ProjectCacheDescriptor pluginDescriptor,
-            BuildManager buildManager,
-            ILoggingService loggingService,
+        /// <summary>
+        /// Optimization which frontloads plugin initialization since we have an entire graph.
+        /// </summary>
+        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)
+        {
+            EnsureNotDisposed();
+
+            Parallel.ForEach(
+                projectGraph.ProjectNodes,
+                s_parallelOptions,
+                node =>
+                {
+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
+                    {
+                        // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
+                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                    }
+                });
+        }
+
+        public void InitializePluginsForVsScenario(
+            IEnumerable<ProjectCacheDescriptor> projectCacheDescriptors,
+            BuildRequestConfiguration buildRequestConfiguration,
             CancellationToken cancellationToken)
         {
-            (ProjectCachePluginBase plugin, string pluginTypeName) = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)
-                .ConfigureAwait(false);
+            EnsureNotDisposed();
+
+            _isVsScenario = true;
 
-            var service = new ProjectCacheService(plugin, pluginTypeName, buildManager, loggingService, pluginDescriptor, cancellationToken);
+            // Bail out for design-time builds
+            if (IsDesignTimeBuild(buildRequestConfiguration))
+            {
+                return;
+            }
+
+            Parallel.ForEach(
+                projectCacheDescriptors,
+                s_parallelOptions,
+                projectCacheDescriptor =>
+                {
+                    // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
+                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                });
+        }
 
-            // TODO: remove the if after we change VS to set the cache descriptor via build parameters and always call BeginBuildAsync in FromDescriptorAsync.
-            // When running under VS we can't initialize the plugin until we evaluate a project (any project) and extract
-            // further information (set by VS) from it required by the plugin.
-            if (!pluginDescriptor.VsWorkaround)
+        private Task<ProjectCachePlugin> GetProjectCachePluginAsync(
+            ProjectCacheDescriptor projectCacheDescriptor,
+            ProjectGraph? projectGraph,
+            BuildRequestConfiguration? buildRequestConfiguration,
+            CancellationToken cancellationToken)
+            => _projectCachePlugins.GetOrAdd(
+                projectCacheDescriptor,
+                // The use of Lazy is because ConcurrentDictionary doesn't guarantee the value factory executes only once if there are multiple simultaneous callers,
+                // so this ensures that CreateAndInitializePluginAsync is only called exactly once.
+                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, cancellationToken)))
+               .Value;
+
+        private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectInstance projectInstance)
+        {
+            if (_globalProjectCacheDescriptor != null)
             {
-                await service.BeginBuildAsync();
+                yield return _globalProjectCacheDescriptor;
             }
 
-            return service;
+            ICollection<ProjectItemInstance> items = projectInstance.GetItems(ItemTypeNames.ProjectCachePlugin);
+            foreach (ProjectItemInstance item in items)
+            {
+                string pluginPath = FileUtilities.NormalizePath(Path.Combine(item.Project.Directory, item.EvaluatedInclude));
+
+                var pluginSettings = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                foreach (ProjectMetadataInstance metadatum in item.Metadata)
+                {
+                    pluginSettings.Add(metadatum.Name, metadatum.EvaluatedValue);
+                }
+
+                yield return ProjectCacheDescriptor.FromAssemblyPath(pluginPath, pluginSettings);
+            }
         }
 
-        // TODO: remove vsWorkaroundOverrideDescriptor after we change VS to set the cache descriptor via build parameters.
-        private async Task BeginBuildAsync(ProjectCacheDescriptor? vsWorkaroundOverrideDescriptor = null)
+        private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
+            ProjectCacheDescriptor projectCacheDescriptor,
+            ProjectGraph? projectGraph,
+            BuildRequestConfiguration? buildRequestConfiguration,
+            CancellationToken cancellationToken)
         {
             BuildEventContext buildEventContext = BuildEventContext.Invalid;
             BuildEventFileInfo buildEventFileInfo = BuildEventFileInfo.Empty;
@@ -109,57 +161,73 @@ private async Task BeginBuildAsync(ProjectCacheDescriptor? vsWorkaroundOverrideD
                 _loggingService,
                 buildEventContext,
                 buildEventFileInfo);
-            ProjectCacheDescriptor projectDescriptor = vsWorkaroundOverrideDescriptor ?? _projectCacheDescriptor;
 
-            try
-            {
-                SetState(ProjectCacheServiceState.BeginBuildStarted);
-                _loggingService.LogComment(buildEventContext, MessageImportance.Low, "ProjectCacheBeginBuild");
-                MSBuildEventSource.Log.ProjectCacheBeginBuildStart(_projectCachePluginTypeName);
+            ProjectCachePluginBase pluginInstance;
+            string pluginTypeName;
 
-                await _projectCachePlugin.BeginBuildAsync(
-                    new CacheContext(
-                        projectDescriptor.PluginSettings,
-                        new DefaultMSBuildFileSystem(),
-                        projectDescriptor.ProjectGraph,
-                        projectDescriptor.EntryPoints),
-                    pluginLogger,
-                    _cancellationToken);
-            }
-            catch (Exception e)
+            if (projectCacheDescriptor.PluginInstance != null)
             {
-                HandlePluginException(e, nameof(ProjectCachePluginBase.BeginBuildAsync));
+                pluginInstance = projectCacheDescriptor.PluginInstance;
+                pluginTypeName = projectCacheDescriptor.PluginInstance.GetType().Name;
             }
-            finally
+            else
             {
-                MSBuildEventSource.Log.ProjectCacheBeginBuildStop(_projectCachePluginTypeName);
-                SetState(ProjectCacheServiceState.BeginBuildFinished);
+                ErrorUtilities.VerifyThrowArgumentNull(projectCacheDescriptor.PluginAssemblyPath, nameof(projectCacheDescriptor.PluginAssemblyPath));
+
+                string pluginAssemblyPath = projectCacheDescriptor.PluginAssemblyPath!;
+                pluginTypeName = pluginAssemblyPath; // Just in case the assembly can't be loaded, the path would be helpful to help identify the problem.
+                try
+                {
+                    MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStart(pluginAssemblyPath);
+
+                    Type pluginType = GetTypeFromAssemblyPath(pluginAssemblyPath);
+                    pluginTypeName = pluginType.Name;
+
+                    pluginInstance = GetPluginInstanceFromType(pluginType);
+                }
+                catch (Exception e)
+                {
+                    return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                }
+                finally
+                {
+                    MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStop(pluginAssemblyPath, pluginTypeName);
+                }
             }
 
-            if (pluginLogger.HasLoggedErrors)
+            IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = buildRequestConfiguration != null
+                ? GetGraphEntryPoints(buildRequestConfiguration)
+                : null;
+
+            _loggingService.LogComment(buildEventContext, MessageImportance.High, "LoadingProjectCachePlugin", pluginTypeName);
+            MSBuildEventSource.Log.ProjectCacheBeginBuildStart(pluginTypeName);
+
+            try
             {
-                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
-            }
-        }
+                await pluginInstance.BeginBuildAsync(
+                    new CacheContext(
+                        projectCacheDescriptor.PluginSettings,
+                        DefaultMSBuildFileSystem.Instance,
+                        projectGraph,
+                        graphEntryPoints),
+                    pluginLogger,
+                    cancellationToken);
 
-        private static (ProjectCachePluginBase PluginInstance, string PluginTypeName) GetPluginInstance(ProjectCacheDescriptor pluginDescriptor)
-        {
-            if (pluginDescriptor.PluginInstance != null)
+                if (pluginLogger.HasLoggedErrors)
+                {
+                    ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
+                }
+
+                return new ProjectCachePlugin(pluginTypeName, pluginInstance);
+            }
+            catch (Exception e)
             {
-                return (pluginDescriptor.PluginInstance, pluginDescriptor.PluginInstance.GetType().Name);
+                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
             }
-
-            if (pluginDescriptor.PluginAssemblyPath != null)
+            finally
             {
-                MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStart(pluginDescriptor.PluginAssemblyPath);
-                Type pluginType = GetTypeFromAssemblyPath(pluginDescriptor.PluginAssemblyPath);
-                ProjectCachePluginBase pluginInstance = GetPluginInstanceFromType(pluginType);
-                MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStop(pluginDescriptor.PluginAssemblyPath, pluginType.Name);
-                return (pluginInstance, pluginType.Name);
+                MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);
             }
-
-            ErrorUtilities.ThrowInternalErrorUnreachable();
-            return (null!, null!); // Unreachable
         }
 
         private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
@@ -214,78 +282,64 @@ IEnumerable<Type> GetTypes<T>(Assembly assembly)
         private static readonly CoreClrAssemblyLoader s_loader = new CoreClrAssemblyLoader();
 #endif
 
-        public void PostCacheRequest(CacheRequest cacheRequest)
+        public bool ShouldUseCache(BuildRequestConfiguration buildRequestConfiguration)
         {
-            Task.Run(async () =>
+            if (IsDesignTimeBuild(buildRequestConfiguration))
             {
-                try
-                {
-                    (CacheResult cacheResult, int projectContextId) = await ProcessCacheRequest(cacheRequest);
-                    _buildManager.PostCacheResult(cacheRequest, cacheResult, projectContextId);
-                }
-                catch (Exception e)
-                {
-                    _buildManager.PostCacheResult(cacheRequest, CacheResult.IndicateException(e), BuildEventContext.InvalidProjectContextId);
-                }
-            }, _cancellationToken);
+                return false;
+            }
 
-            async Task<(CacheResult Result, int ProjectContextId)> ProcessCacheRequest(CacheRequest request)
+            if (_globalProjectCacheDescriptor != null)
             {
-                // Prevent needless evaluation if design time builds detected.
-                if (_projectCacheDescriptor.VsWorkaround && DesignTimeBuildsDetected)
-                {
-                    // The BuildManager should disable the cache when it finds its servicing design time builds.
-                    return (CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss), BuildEventContext.InvalidProjectContextId);
-                }
+                return true;
+            }
 
-                EvaluateProjectIfNecessary(request);
+            // We've determined it's the VS scenario and know that there are project cache plugins.
+            if (_isVsScenario)
+            {
+                return true;
+            }
 
-                // Detect design time builds.
-                if (_projectCacheDescriptor.VsWorkaround)
-                {
-                    var isDesignTimeBuild = IsDesignTimeBuild(request.Configuration.Project);
+            // If the project isn't loaded, don't force it to be just to check if it's cacheable as this may not be very performant.
+            if (!buildRequestConfiguration.IsLoaded)
+            {
+                return false;
+            }
 
-                    var previousValue = Interlocked.CompareExchange(
-                        ref DesignTimeBuildsDetected,
-                        new NullableBool(isDesignTimeBuild),
-                        null);
+            // Check if there are any project cache items defined in the project
+            return GetProjectCacheDescriptors(buildRequestConfiguration.Project).Any();
+        }
 
-                    ErrorUtilities.VerifyThrowInternalError(
-                        previousValue is null || previousValue == false || isDesignTimeBuild,
-                        "Either all builds in a build session or design time builds, or none");
+        private bool IsDesignTimeBuild(BuildRequestConfiguration buildRequestConfiguration)
+        {
+            string? designTimeBuild = buildRequestConfiguration.GlobalProperties[DesignTimeProperties.DesignTimeBuild]?.EvaluatedValue;
+            string? buildingProject = buildRequestConfiguration.GlobalProperties[DesignTimeProperties.BuildingProject]?.EvaluatedValue;
+            return ConversionUtilities.ConvertStringToBool(designTimeBuild, nullOrWhitespaceIsFalse: true)
+                || (buildingProject != null && !ConversionUtilities.ConvertStringToBool(designTimeBuild, nullOrWhitespaceIsFalse: true));
+        }
 
-                    // No point progressing with expensive plugin initialization or cache query if design time build detected.
-                    if (DesignTimeBuildsDetected)
-                    {
-                        // The BuildManager should disable the cache when it finds its servicing design time builds.
-                        return (CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss), BuildEventContext.InvalidProjectContextId);
-                    }
-                }
+        public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancellationToken)
+        {
+            EnsureNotDisposed();
 
-                // TODO: remove after we change VS to set the cache descriptor via build parameters.
-                // VS workaround needs to wait until the first project is evaluated to extract enough information to initialize the plugin.
-                // No cache request can progress until late initialization is complete.
-                if (_projectCacheDescriptor.VsWorkaround)
+            Task.Run(
+                async () =>
                 {
-                    if (Interlocked.CompareExchange(
-                            ref LateInitializationForVSWorkaroundCompleted,
-                            new TaskCompletionSource<bool>(),
-                            null) is null)
+                    try
                     {
-                        await LateInitializePluginForVsWorkaround(request);
-                        LateInitializationForVSWorkaroundCompleted.SetResult(true);
+                        (CacheResult cacheResult, int projectContextId) = await ProcessCacheRequestAsync();
+                        _buildManager.PostCacheResult(cacheRequest, cacheResult, projectContextId);
                     }
-                    else
+                    catch (Exception e)
                     {
-                        // Can't be null. If the thread got here it means another thread initialized the completion source.
-                        await LateInitializationForVSWorkaroundCompleted!.Task;
+                        _buildManager.PostCacheResult(cacheRequest, CacheResult.IndicateException(e), BuildEventContext.InvalidProjectContextId);
                     }
-                }
+                },
+                cancellationToken);
 
-                ErrorUtilities.VerifyThrowInternalError(
-                    LateInitializationForVSWorkaroundCompleted is null ||
-                    (_projectCacheDescriptor.VsWorkaround && LateInitializationForVSWorkaroundCompleted.Task.IsCompleted),
-                    "Completion source should be null when this is not the VS workaround");
+            async Task<(CacheResult Result, int ProjectContextId)> ProcessCacheRequestAsync()
+            {
+                EvaluateProjectIfNecessary(cacheRequest.Submission, cacheRequest.Configuration);
 
                 BuildRequestData buildRequest = new BuildRequestData(
                     cacheRequest.Configuration.Project,
@@ -299,7 +353,7 @@ LateInitializationForVSWorkaroundCompleted is null ||
                 CacheResult cacheResult;
                 try
                 {
-                    cacheResult = await GetCacheResultAsync(buildRequest, cacheRequest.Configuration, buildEventContext);
+                    cacheResult = await GetCacheResultAsync(buildRequest, cacheRequest.Configuration, buildEventContext, cancellationToken);
                 }
                 catch (Exception ex)
                 {
@@ -310,166 +364,29 @@ LateInitializationForVSWorkaroundCompleted is null ||
                 return (cacheResult, buildEventContext.ProjectContextId);
             }
 
-            static bool IsDesignTimeBuild(ProjectInstance project)
-            {
-                var designTimeBuild = project.GetPropertyValue(DesignTimeProperties.DesignTimeBuild);
-                var buildingProject = project.GlobalPropertiesDictionary[DesignTimeProperties.BuildingProject]?.EvaluatedValue;
-
-                return MSBuildStringIsTrue(designTimeBuild) ||
-                       (buildingProject != null && !MSBuildStringIsTrue(buildingProject));
-            }
-
-            void EvaluateProjectIfNecessary(CacheRequest request)
+            void EvaluateProjectIfNecessary(BuildSubmission submission, BuildRequestConfiguration configuration)
             {
-                // TODO: only do this if the project cache requests evaluation. QB needs evaluations, but the Anybuild implementation
-                // TODO: might not need them, so no point evaluating if it's not necessary. As a caveat, evaluations would still be optimal
-                // TODO: when proxy builds are issued by the plugin ( scheduled on the inproc node, no point re-evaluating on out-of-proc nodes).
-                lock (request.Configuration)
+                lock (configuration)
                 {
-                    if (!request.Configuration.IsLoaded)
+                    if (!configuration.IsLoaded)
                     {
-                        request.Configuration.LoadProjectIntoConfiguration(
+                        configuration.LoadProjectIntoConfiguration(
                             _buildManager,
-                            request.Submission.BuildRequestData.Flags,
-                            request.Submission.SubmissionId,
+                            submission.BuildRequestData.Flags,
+                            submission.SubmissionId,
                             Scheduler.InProcNodeId
                         );
 
                         // If we're taking the time to evaluate, avoid having other nodes to repeat the same evaluation.
                         // Based on the assumption that ProjectInstance serialization is faster than evaluating from scratch.
-                        request.Configuration.Project.TranslateEntireState = true;
-                    }
-                }
-            }
-
-            async Task LateInitializePluginForVsWorkaround(CacheRequest request)
-            {
-                var (_, configuration) = request;
-                var solutionConfigurationXml = configuration.Project.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
-
-                ErrorUtilities.VerifyThrow(
-                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,
-                    "Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.");
-
-                // A solution supports multiple solution configurations (different values for Configuration and Platform).
-                // Each solution configuration generates a different static graph.
-                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the
-                // currently solution configuration used by VS.
-                //
-                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property
-                // named "CurrentSolutionConfigurationContents" that VS sets on each built project. It does not contain the solution configuration itself, but
-                // instead it contains information on how the solution configuration maps to each project's configuration.
-                //
-                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project
-                // mentioned in the "CurrentSolutionConfigurationContents" global property.
-                //
-                // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as
-                // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.
-                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(
-                    solutionConfigurationXml,
-                    configuration.Project);
-
-                await BeginBuildAsync(
-                    ProjectCacheDescriptor.FromAssemblyPath(
-                        _projectCacheDescriptor.PluginAssemblyPath!,
-                        graphEntryPointsFromSolutionConfig,
-                        projectGraph: null,
-                        _projectCacheDescriptor.PluginSettings));
-            }
-
-            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(
-                string solutionConfigurationXml,
-                ProjectInstance project
-            )
-            {
-                // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751
-                var doc = new XmlDocument();
-                doc.LoadXml(solutionConfigurationXml);
-
-                var root = doc.DocumentElement!;
-                var projectConfigurationNodes = root.GetElementsByTagName("ProjectConfiguration");
-
-                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, "Expected at least one project in solution");
-
-                var definingProjectPath = project.FullPath;
-                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);
-
-                var templateGlobalProperties = new Dictionary<string, string>(project.GlobalProperties, StringComparer.OrdinalIgnoreCase);
-                RemoveProjectSpecificGlobalProperties(templateGlobalProperties, project);
-
-                foreach (XmlNode node in projectConfigurationNodes)
-                {
-                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));
-
-                    var buildProjectInSolution = node.Attributes!["BuildProjectInSolution"];
-                    if (buildProjectInSolution is not null &&
-                        string.IsNullOrWhiteSpace(buildProjectInSolution.Value) is false &&
-                        bool.TryParse(buildProjectInSolution.Value, out var buildProject) &&
-                        buildProject is false)
-                    {
-                        continue;
-                    }
-
-                    ErrorUtilities.VerifyThrow(
-                        node.ChildNodes.OfType<XmlElement>().FirstOrDefault(e => e.Name == "ProjectDependency") is null,
-                        "Project cache service does not support solution only dependencies when running under Visual Studio.");
-
-                    var projectPathAttribute = node.Attributes!["AbsolutePath"];
-                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, "Expected VS to set the project path on each ProjectConfiguration element.");
-
-                    var projectPath = projectPathAttribute!.Value;
-
-                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);
-
-                    // Take the defining project global properties and override the configuration and platform.
-                    // It's sufficient to only set Configuration and Platform.
-                    // But we send everything to maximize the plugins' potential to quickly workaround potential MSBuild issues while the MSBuild fixes flow into VS.
-                    var globalProperties = new Dictionary<string, string>(templateGlobalProperties, StringComparer.OrdinalIgnoreCase)
-                    {
-                        ["Configuration"] = configuration,
-                        ["Platform"] = platform
-                    };
-
-                    graphEntryPoints.Add(new ProjectGraphEntryPoint(projectPath, globalProperties));
-                }
-
-                return graphEntryPoints;
-
-                // If any project specific property is set, it will propagate down the project graph and force all nodes to that property's specific side effects, which is incorrect.
-                void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)
-                {
-                    // InnerBuildPropertyName is TargetFramework for the managed sdk.
-                    var innerBuildPropertyName = ProjectInterpretation.GetInnerBuildPropertyName(project);
-
-                    IEnumerable<string> projectSpecificPropertyNames = new []{innerBuildPropertyName, "Configuration", "Platform", "TargetPlatform", "OutputType"};
-
-                    foreach (var propertyName in projectSpecificPropertyNames)
-                    {
-                        if (!string.IsNullOrWhiteSpace(propertyName) && globalProperties.ContainsKey(propertyName))
-                        {
-                            globalProperties.Remove(propertyName);
-                        }
+                        configuration.Project.TranslateEntireState = true;
                     }
                 }
             }
-
-            static bool MSBuildStringIsTrue(string msbuildString) =>
-                ConversionUtilities.ConvertStringToBool(msbuildString, nullOrWhitespaceIsFalse: true);
         }
 
-        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext)
+        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext, CancellationToken cancellationToken)
         {
-            lock (this)
-            {
-                CheckNotInState(ProjectCacheServiceState.NotInitialized);
-                CheckNotInState(ProjectCacheServiceState.BeginBuildStarted);
-
-                if (_serviceState is ProjectCacheServiceState.ShutdownStarted or ProjectCacheServiceState.ShutdownFinished)
-                {
-                    return CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable);
-                }
-            }
-
             ErrorUtilities.VerifyThrowInternalNull(buildRequest.ProjectInstance, nameof(buildRequest.ProjectInstance));
 
             var buildEventFileInfo = new BuildEventFileInfo(buildRequest.ProjectFullPath);
@@ -490,31 +407,55 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
                 _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheQueryStartedWithTargetNames", buildRequest.ProjectFullPath, targetNames);
             }
 
+            HashSet<ProjectCacheDescriptor> queriedCaches = new(ProjectCacheDescriptorEqualityComparer.Instance);
             CacheResult? cacheResult = null;
-            try
-            {
-                MSBuildEventSource.Log.ProjectCacheGetCacheResultStart(_projectCachePluginTypeName, buildRequest.ProjectFullPath, targetNames);
-                cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, pluginLogger, _cancellationToken);
-            }
-            catch (Exception e)
+            foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(buildRequest.ProjectInstance))
             {
-                HandlePluginException(e, nameof(ProjectCachePluginBase.GetCacheResultAsync));
-                return null!; // Unreachable
-            }
-            finally
-            {
-                if (MSBuildEventSource.Log.IsEnabled())
+                // Ensure each unique plugin is only queried once
+                if (!queriedCaches.Add(projectCacheDescriptor))
                 {
-                    string cacheResultType = cacheResult?.ResultType.ToString() ?? nameof(CacheResultType.None);
-                    MSBuildEventSource.Log.ProjectCacheGetCacheResultStop(_projectCachePluginTypeName, buildRequest.ProjectFullPath, targetNames, cacheResultType);
+                    continue;
                 }
-            }
 
-            if (pluginLogger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
-            {
-                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheQueryFailed", buildRequest.ProjectFullPath);
+                ProjectCachePlugin plugin = await GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken);
+                try
+                {
+                    // Rethrow any initialization exception.
+                    plugin.InitializationException?.Throw();
+
+                    ErrorUtilities.VerifyThrow(plugin.Instance != null, "Plugin '{0}' instance is null", plugin.Name);
+
+                    MSBuildEventSource.Log.ProjectCacheGetCacheResultStart(plugin.Name, buildRequest.ProjectFullPath, targetNames);
+                    cacheResult = await plugin.Instance!.GetCacheResultAsync(buildRequest, pluginLogger, cancellationToken);
+
+                    if (pluginLogger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
+                    {
+                        ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheQueryFailed", buildRequest.ProjectFullPath);
+                    }
+
+                    if (cacheResult.ResultType == CacheResultType.CacheHit)
+                    {
+                        break;
+                    }
+                }
+                catch (Exception e) when (e is not ProjectCacheException)
+                {
+                    HandlePluginException(e, nameof(ProjectCachePluginBase.GetCacheResultAsync));
+                    return null!; // Unreachable
+                }
+                finally
+                {
+                    if (MSBuildEventSource.Log.IsEnabled())
+                    {
+                        string cacheResultType = cacheResult?.ResultType.ToString() ?? nameof(CacheResultType.None);
+                        MSBuildEventSource.Log.ProjectCacheGetCacheResultStop(plugin.Name, buildRequest.ProjectFullPath, targetNames, cacheResultType);
+                    }
+                }
             }
 
+            // Handle the case of no configured plugins.
+            cacheResult ??= CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable);
+
             switch (cacheResult.ResultType)
             {
                 case CacheResultType.CacheHit:
@@ -565,103 +506,172 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
             return cacheResult;
         }
 
-        public async Task ShutDown()
+        private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildRequestConfiguration configuration)
         {
-            bool shouldInitiateShutdownState = _serviceState != ProjectCacheServiceState.ShutdownStarted && _serviceState != ProjectCacheServiceState.ShutdownFinished;
+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);
+            foreach (ProjectPropertyInstance property in configuration.GlobalProperties)
+            {
+                // If any project specific property is set, it will propagate down the project graph and force all nodes to that property's specific side effects, which is incorrect.
+                if (!s_projectSpecificPropertyNames.Contains(property.Name))
+                {
+                    globalProperties.Add(property.Name, property.EvaluatedValue);
+                }
+            }
 
-            if (!shouldInitiateShutdownState)
+            if (globalProperties.TryGetValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents, out string? solutionConfigurationXml)
+                && !string.IsNullOrWhiteSpace(solutionConfigurationXml))
             {
-                return;
+                // A solution supports multiple solution configurations (different values for Configuration and Platform).
+                // Each solution configuration generates a different static graph.
+                // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the
+                // currently solution configuration used by VS.
+                //
+                // In this VS workaround, however, we do not have access to VS' solution configuration. The only information we have is a global property
+                // named "CurrentSolutionConfigurationContents" that VS sets on each built project. It does not contain the solution configuration itself, but
+                // instead it contains information on how the solution configuration maps to each project's configuration.
+                //
+                // So instead of using the solution file as the entry point, we parse this VS property and extract graph entry points from it, for every project
+                // mentioned in the "CurrentSolutionConfigurationContents" global property.
+                return GenerateGraphEntryPointsFromSolutionConfigurationXml(solutionConfigurationXml!, configuration.ProjectFullPath, globalProperties);
+            }
+            else
+            {
+                return new[] { new ProjectGraphEntryPoint(configuration.ProjectFullPath, globalProperties) };
             }
 
-            BuildEventContext buildEventContext = BuildEventContext.Invalid;
-            BuildEventFileInfo buildEventFileInfo = BuildEventFileInfo.Empty;
-            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
-                _loggingService,
-                BuildEventContext.Invalid,
-                BuildEventFileInfo.Empty);
-            
-            try
+            static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(
+                string solutionConfigurationXml,
+                string definingProjectPath,
+                Dictionary<string, string> templateGlobalProperties
+            )
             {
-                SetState(ProjectCacheServiceState.ShutdownStarted);
-                _loggingService.LogComment(buildEventContext, MessageImportance.Low, "ProjectCacheEndBuild");
-                MSBuildEventSource.Log.ProjectCacheEndBuildStart(_projectCachePluginTypeName);
+                // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751
+                var doc = new XmlDocument();
+                doc.LoadXml(solutionConfigurationXml);
 
-                await _projectCachePlugin.EndBuildAsync(pluginLogger, _cancellationToken);
+                var root = doc.DocumentElement!;
+                var projectConfigurationNodes = root.GetElementsByTagName("ProjectConfiguration");
 
-                if (pluginLogger.HasLoggedErrors)
+                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, "Expected at least one project in solution");
+
+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);
+
+                foreach (XmlNode node in projectConfigurationNodes)
                 {
-                    ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
+                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));
+
+                    var buildProjectInSolution = node.Attributes!["BuildProjectInSolution"];
+                    if (buildProjectInSolution is not null &&
+                        string.IsNullOrWhiteSpace(buildProjectInSolution.Value) is false &&
+                        bool.TryParse(buildProjectInSolution.Value, out var buildProject) &&
+                        buildProject is false)
+                    {
+                        continue;
+                    }
+
+                    var projectPathAttribute = node.Attributes!["AbsolutePath"];
+                    ErrorUtilities.VerifyThrow(projectPathAttribute is not null, "Expected VS to set the project path on each ProjectConfiguration element.");
+
+                    var projectPath = projectPathAttribute!.Value;
+
+                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);
+
+                    // Take the defining project global properties and override the configuration and platform.
+                    // It's sufficient to only set Configuration and Platform.
+                    // But we send everything to maximize the plugins' potential to quickly workaround potential MSBuild issues while the MSBuild fixes flow into VS.
+                    var globalProperties = new Dictionary<string, string>(templateGlobalProperties, StringComparer.OrdinalIgnoreCase)
+                    {
+                        ["Configuration"] = configuration,
+                        ["Platform"] = platform
+                    };
+
+                    graphEntryPoints.Add(new ProjectGraphEntryPoint(projectPath, globalProperties));
                 }
-            }
-            catch (Exception e) when (e is not ProjectCacheException)
-            {
-                HandlePluginException(e, nameof(ProjectCachePluginBase.EndBuildAsync));
-            }
-            finally
-            {
-                MSBuildEventSource.Log.ProjectCacheEndBuildStop(_projectCachePluginTypeName);
-                SetState(ProjectCacheServiceState.ShutdownFinished);
+
+                return graphEntryPoints;
             }
         }
 
-        private static void HandlePluginException(Exception e, string apiExceptionWasThrownFrom)
+        public async ValueTask DisposeAsync()
         {
-            if (ExceptionHandling.IsCriticalException(e))
+            if (_isDisposed)
             {
-                throw e;
+                return;
             }
 
-            ProjectCacheException.ThrowAsUnhandledException(
-                e,
-                "ProjectCacheException",
-                apiExceptionWasThrownFrom);
-        }
+            _isDisposed = true;
 
-        private void SetState(ProjectCacheServiceState newState)
-        {
-            lock (this)
+            if (_projectCachePlugins.IsEmpty)
+            {
+                return;
+            }
+
+            BuildEventContext buildEventContext = BuildEventContext.Invalid;
+            BuildEventFileInfo buildEventFileInfo = BuildEventFileInfo.Empty;
+            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
+                _loggingService,
+                buildEventContext,
+                buildEventFileInfo);
+
+            _loggingService.LogComment(buildEventContext, MessageImportance.Low, "ProjectCacheEndBuild");
+
+            Task[] cleanupTasks = new Task[_projectCachePlugins.Count];
+            int idx = 0;
+            foreach (KeyValuePair<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> kvp in _projectCachePlugins)
             {
-                switch (newState)
+                cleanupTasks[idx++] = Task.Run(async () =>
                 {
-                    case ProjectCacheServiceState.NotInitialized:
-                        ErrorUtilities.ThrowInternalError($"Cannot transition to {ProjectCacheServiceState.NotInitialized}");
-                        break;
-                    case ProjectCacheServiceState.BeginBuildStarted:
-                        CheckInState(ProjectCacheServiceState.NotInitialized);
-                        break;
-                    case ProjectCacheServiceState.BeginBuildFinished:
-                        CheckInState(ProjectCacheServiceState.BeginBuildStarted);
-                        break;
-                    case ProjectCacheServiceState.ShutdownStarted:
-                        CheckNotInState(ProjectCacheServiceState.ShutdownStarted);
-                        CheckNotInState(ProjectCacheServiceState.ShutdownFinished);
-                        break;
-                    case ProjectCacheServiceState.ShutdownFinished:
-                        CheckInState(ProjectCacheServiceState.ShutdownStarted);
-                        break;
-                    default:
-                        throw new ArgumentOutOfRangeException(nameof(newState), newState, null);
-                }
+                    ProjectCachePlugin plugin = await kvp.Value.Value;
 
-                _serviceState = newState;
+                    // If there is no instance, the exceptions would have bubbled up already, so skip cleanup for this one.
+                    if (plugin.Instance == null)
+                    {
+                        return;
+                    }
+
+                    MSBuildEventSource.Log.ProjectCacheEndBuildStart(plugin.Name);
+                    try
+                    {
+                        await plugin.Instance.EndBuildAsync(pluginLogger, CancellationToken.None);
+                    }
+                    catch (Exception e) when (e is not ProjectCacheException)
+                    {
+                        HandlePluginException(e, nameof(ProjectCachePluginBase.EndBuildAsync));
+                    }
+                    finally
+                    {
+                        MSBuildEventSource.Log.ProjectCacheEndBuildStop(plugin.Name);
+                    }
+                });
+            }
+
+            await Task.WhenAll(cleanupTasks);
+
+            if (pluginLogger.HasLoggedErrors)
+            {
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
             }
         }
 
-        private void CheckInState(ProjectCacheServiceState expectedState)
+        private void EnsureNotDisposed()
         {
-            lock (this)
+            if (_isDisposed)
             {
-                ErrorUtilities.VerifyThrowInternalError(_serviceState == expectedState, $"Expected state {expectedState}, actual state {_serviceState}");
+                throw new ObjectDisposedException(nameof(ProjectCacheService));
             }
         }
 
-        private void CheckNotInState(ProjectCacheServiceState unexpectedState)
+        private static void HandlePluginException(Exception e, string apiExceptionWasThrownFrom)
         {
-            lock (this)
+            if (ExceptionHandling.IsCriticalException(e))
             {
-                ErrorUtilities.VerifyThrowInternalError(_serviceState != unexpectedState, $"Unexpected state {_serviceState}");
+                throw e;
             }
+
+            ProjectCacheException.ThrowAsUnhandledException(
+                e,
+                "ProjectCacheException",
+                apiExceptionWasThrownFrom);
         }
 
         private class LoggingServiceToPluginLoggerAdapter : PluginLoggerBase
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 505bc1d2df1..32b7c6b1b1a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -15,6 +15,7 @@
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -83,7 +84,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.KeepMetadata))
                             {
-                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation).ToList();
+                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation, LoggingContext).ToList();
                                 if (keepMetadataEvaluated.Count > 0)
                                 {
                                     keepMetadata = new HashSet<string>(keepMetadataEvaluated);
@@ -92,7 +93,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.RemoveMetadata))
                             {
-                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation).ToList();
+                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation, LoggingContext).ToList();
                                 if (removeMetadataEvaluated.Count > 0)
                                 {
                                     removeMetadata = new HashSet<string>(removeMetadataEvaluated);
@@ -101,7 +102,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.MatchOnMetadata))
                             {
-                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation).ToList();
+                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation, LoggingContext).ToList();
                                 if (matchOnMetadataEvaluated.Count > 0)
                                 {
                                     matchOnMetadata = new HashSet<string>(matchOnMetadataEvaluated);
@@ -114,7 +115,7 @@ internal override void ExecuteTask(Lookup lookup)
                                 (child.Exclude.Length != 0))
                             {
                                 // It's an item -- we're "adding" items to the world
-                                ExecuteAdd(child, bucket, keepMetadata, removeMetadata);
+                                ExecuteAdd(child, bucket, keepMetadata, removeMetadata, LoggingContext);
                             }
                             else if (child.Remove.Length != 0)
                             {
@@ -124,7 +125,7 @@ internal override void ExecuteTask(Lookup lookup)
                             else
                             {
                                 // It's a modify -- changing existing items
-                                ExecuteModify(child, bucket, keepMetadata, removeMetadata);
+                                ExecuteModify(child, bucket, keepMetadata, removeMetadata, LoggingContext);
                             }
                         }
                     }
@@ -150,7 +151,8 @@ internal override void ExecuteTask(Lookup lookup)
         /// <param name="bucket">The batching bucket.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata)
+        /// <param name="loggingContext">Context for logging</param>
+        private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata, LoggingContext loggingContext = null)
         {
             // First, collect up the appropriate metadata collections.  We need the one from the item definition, if any, and
             // the one we are using for this batching bucket.
@@ -164,7 +166,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
             bucket.Expander.Metadata = metadataTable;
 
             // Second, expand the item include and exclude, and filter existing metadata as appropriate.
-            List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata);
+            List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata, loggingContext);
 
             // Third, expand the metadata.           
             foreach (ProjectItemGroupTaskMetadataInstance metadataInstance in child.Metadata)
@@ -179,11 +181,12 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     metadataInstance.Location,
                     LoggingContext.LoggingService,
                     LoggingContext.BuildEventContext,
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    loggingContext: loggingContext);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and 
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -245,7 +248,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             List<ProjectItemInstance> itemsToRemove;
             if (matchOnMetadata == null)
             {
-                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander);
+                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander, LoggingContext);
             }
             else
             {
@@ -277,7 +280,8 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
         /// <param name="bucket">The batching bucket.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata)
+        /// <param name="loggingContext">Context for this operation.</param>
+        private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata, LoggingContext loggingContext = null)
         {
             ICollection<ProjectItemInstance> group = bucket.Lookup.GetItems(child.ItemType);
             if (group == null || group.Count == 0)
@@ -317,11 +321,12 @@ private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     metadataInstance.ConditionLocation,
                     LoggingContext.LoggingService,
                     LoggingContext.BuildEventContext,
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    loggingContext: loggingContext);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
                     metadataToSet[metadataInstance.Name] = Lookup.MetadataModification.CreateFromNewValue(evaluatedValue);
                 }
             }
@@ -357,6 +362,7 @@ private void GetBatchableValuesFromBuildItemGroupChild(List<string> parameterVal
         /// <param name="expander">The expander to use.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
+        /// <param name="loggingContext">Context for logging</param>
         /// <remarks>
         /// This code is very close to that which exists in the Evaluator.EvaluateItemXml method.  However, because
         /// it invokes type constructors, and those constructors take arguments of fundamentally different types, it has not
@@ -368,7 +374,8 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             ProjectItemGroupTaskItemInstance originalItem,
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
             ISet<string> keepMetadata,
-            ISet<string> removeMetadata
+            ISet<string> removeMetadata,
+            LoggingContext loggingContext = null
         )
         {
             // todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
@@ -376,7 +383,7 @@ ISet<string> removeMetadata
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
             // Expand properties and metadata in Include
-            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation);
+            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation, loggingContext);
 
             if (evaluatedInclude.Length == 0)
             {
@@ -387,7 +394,7 @@ ISet<string> removeMetadata
             var excludes = ImmutableList<string>.Empty.ToBuilder();
             if (originalItem.Exclude.Length > 0)
             {
-                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation);
+                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation, loggingContext);
 
                 if (evaluatedExclude.Length > 0)
                 {
@@ -516,13 +523,15 @@ ISet<string> removeMetadata
         /// <param name="specification">The specification to match against the items.</param>
         /// <param name="specificationLocation">The specification to match against the provided items</param>
         /// <param name="expander">The expander to use</param>
+        /// <param name="loggingContext">Context for logging</param>
         /// <returns>A list of matching items</returns>
         private List<ProjectItemInstance> FindItemsMatchingSpecification
             (
             ICollection<ProjectItemInstance> items,
             string specification,
             ElementLocation specificationLocation,
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
+            LoggingContext loggingContext = null
             )
         {
             if (items.Count == 0 || specification.Length == 0)
@@ -535,7 +544,7 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
             HashSet<string> specificationsToFind = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             // Split by semicolons
-            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation);
+            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation, loggingContext);
 
             foreach (string piece in specificationPieces)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 49a849c4313..e1479768ff2 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -353,7 +353,8 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 _target.ConditionLocation,
                 projectLoggingContext.LoggingService,
                 projectLoggingContext.BuildEventContext,
-                FileSystems.Default);
+                FileSystems.Default,
+                loggingContext: projectLoggingContext);
 
             if (!condition)
             {
@@ -392,7 +393,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 return new List<TargetSpecification>();
             }
 
-            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation);
+            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation, projectLoggingContext);
             List<TargetSpecification> dependencyTargets = new List<TargetSpecification>();
             foreach (string escapedDependency in dependencies)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index ec05dfd174f..4835778b4c1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -381,7 +381,8 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 _targetChildInstance.ConditionLocation,
                 _targetLoggingContext.LoggingService,
                 _targetLoggingContext.BuildEventContext,
-                FileSystems.Default);
+                FileSystems.Default,
+                loggingContext: _targetLoggingContext);
 
             if (!condition)
             {
@@ -623,7 +624,7 @@ private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTas
                     if (!_targetLoggingContext.LoggingService.OnlyLogCriticalEvents)
                     {
                         // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation);
+                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation, loggingContext: _targetLoggingContext);
 
                         // Whilst we are within the processing of the task, we haven't actually started executing it, so
                         // our skip task message needs to be in the context of the target. However any errors should be reported
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 55e08dc13bd..3ef2120b037 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -84,9 +84,9 @@ public OutOfProcServerNode(BuildCallback buildFunction)
         }
 
         #region INode Members
-        
+
         /// <summary>
-        /// Starts up the node and processes messages until the node is requested to shut down.
+        /// Starts up the server node and processes all build requests until the server is requested to shut down.
         /// </summary>
         /// <param name="shutdownException">The exception which caused shutdown, if any.</param> 
         /// <returns>The reason for shutting down.</returns>
@@ -107,12 +107,32 @@ public NodeEngineShutdownReason Run(out Exception? shutdownException)
                 return NodeEngineShutdownReason.Error;
             }
 
+            while(true)
+            {
+                NodeEngineShutdownReason shutdownReason = RunInternal(out shutdownException, handshake);
+                if (shutdownReason != NodeEngineShutdownReason.BuildCompleteReuse)
+                {
+                    return shutdownReason;
+                }
+
+                // We need to clear cache for two reasons:
+                // - cache file names can collide cross build requests, which would cause stale caching
+                // - we might need to avoid cache builds-up in files system during lifetime of server
+                FileUtilities.ClearCacheDirectory();
+                _shutdownEvent.Reset();
+            }
+
+            // UNREACHABLE
+        }
+
+        private NodeEngineShutdownReason RunInternal(out Exception? shutdownException, ServerNodeHandshake handshake)
+        {
             _nodeEndpoint = new ServerNodeEndpointOutOfProc(GetPipeName(handshake), handshake);
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
             var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
-            
+
             // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
             while (true)
             {
@@ -272,12 +292,28 @@ private void HandlePacket(INodePacket packet)
                 case NodePacketType.ServerNodeBuildCommand:
                     HandleServerNodeBuildCommandAsync((ServerNodeBuildCommand)packet);
                     break;
+                case NodePacketType.NodeBuildComplete:
+                    HandleServerShutdownCommand((NodeBuildComplete)packet);
+                    break;
                 case NodePacketType.ServerNodeBuildCancel:
-                    BuildManager.DefaultBuildManager.CancelAllSubmissions();
+                    HandleBuildCancel();
                     break;
             }
         }
 
+        /// <summary>
+        /// NodeBuildComplete is used to signalize that node work is done (including server node)
+        /// and shall recycle or shutdown if PrepareForReuse is false.
+        /// </summary>
+        /// <param name="buildComplete"></param>
+        private void HandleServerShutdownCommand(NodeBuildComplete buildComplete)
+        {
+            _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
+            _shutdownEvent.Set();
+        }
+
+        private static void HandleBuildCancel() => BuildManager.DefaultBuildManager.CancelAllSubmissions();
+
         private void HandleServerNodeBuildCommandAsync(ServerNodeBuildCommand command)
         {
             Task.Run(() =>
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 6bbeea098dc..fb7c35ad18e 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1198,7 +1198,7 @@ out bool taskParameterSet
                 else
                 {
                     // Expand out all the metadata, properties, and item vectors in the string.
-                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
+                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation, _targetLoggingContext);
 
                     if (expandedParameterValue.Length == 0)
                     {
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 875be364ea0..649880df456 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -521,5 +521,22 @@ internal void Enumerate(Action<string, string> keyValueCallback)
                 }
             }
         }
+
+        internal IEnumerable<TResult> Filter<TResult>(Func<T, bool> filter, Func<T, TResult> selector)
+        {
+            List<TResult> result = new();
+            lock (_properties)
+            {
+                foreach (T property in _properties)
+                {
+                    if (filter(property))
+                    {
+                        result.Add(selector(property));
+                    }
+                }
+            }
+
+            return result;
+        }
     }
 }
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 221c938e941..7bfceeffa27 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -1013,6 +1013,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
                 traversalProject,
                 _globalProperties,
                 explicitToolsVersionSpecified ? wrapperProjectToolsVersion : null,
+                _loggingService,
                 _solutionFile.VisualStudioVersion,
                 new ProjectCollection(),
                 _sdkResolverService,
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 6fb05e271d0..294b523e07e 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2924,7 +2924,7 @@ public override bool SetGlobalProperty(string name, string escapedValue)
                     string originalValue = (existing == null) ? String.Empty : ((IProperty)existing).EvaluatedValueEscaped;
 
                     _data.GlobalPropertiesDictionary.Set(ProjectPropertyInstance.Create(name, escapedValue));
-                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, true /* is global */, false /* may not be reserved name */));
+                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, isGlobalProperty: true, mayBeReserved: false, loggingContext: null));
 
                     ProjectCollection.AfterUpdateLoadedProjectGlobalProperties(Owner);
                     MarkDirty();
@@ -4394,9 +4394,9 @@ public IItemDefinition<ProjectMetadata> GetItemDefinition(string itemType)
             /// <summary>
             /// Sets a property which is not derived from Xml.
             /// </summary>
-            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
+            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
             {
-                ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+                ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext);
                 Properties.Set(property);
 
                 AddToAllEvaluatedPropertiesList(property);
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index b3e808c3c9a..157fc4366ec 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -3,8 +3,10 @@
 
 using System;
 using System.Diagnostics;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
@@ -94,7 +96,18 @@ public string EvaluatedValue
         string IProperty.EvaluatedValueEscaped
         {
             [DebuggerStepThrough]
-            get => EvaluatedValueEscapedInternal;
+            get
+            {
+                if (this is EnvironmentDerivedProjectProperty environmentProperty && environmentProperty.loggingContext is { IsValid: true } loggingContext && !environmentProperty._loggedEnvProperty)
+                {
+                    EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal);
+                    args.BuildEventContext = loggingContext.BuildEventContext;
+                    loggingContext.LogBuildEvent(args);
+                    environmentProperty._loggedEnvProperty = true;
+                }
+
+                return EvaluatedValueEscapedInternal;
+            }
         }
 
         /// <summary>
@@ -237,9 +250,10 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
         /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
         /// All other properties originate in XML, and should have a backing XML object.
         /// </summary>
-        internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
+        internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext = null)
         {
-            return new ProjectPropertyNotXmlBacked(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+            return !isGlobalProperty && !mayBeReserved ? new EnvironmentDerivedProjectProperty(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext) :
+                new ProjectPropertyNotXmlBacked(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
         }
 
         /// <summary>
@@ -628,5 +642,18 @@ public override bool IsImported
                 get { return false; }
             }
         }
+
+        private class EnvironmentDerivedProjectProperty : ProjectPropertyNotXmlBacked
+        {
+            internal bool _loggedEnvProperty = false;
+            internal LoggingContext loggingContext;
+
+            internal EnvironmentDerivedProjectProperty(
+                Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext)
+                : base(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved)
+            {
+                this.loggingContext = loggingContext;
+            }
+        }
     }
 }
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 31dd956ed2e..183ce5117d6 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -17,6 +17,7 @@ namespace Microsoft.Build.Evaluation
     using ElementLocation = Microsoft.Build.Construction.ElementLocation;
     using Microsoft.Build.Shared;
     using Microsoft.Build.Shared.FileSystem;
+    using Microsoft.Build.BackEnd.Logging;
 
     internal static class ConditionEvaluator
     {
@@ -181,7 +182,8 @@ internal static bool EvaluateCondition<P, I>
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null)
+            ProjectRootElementCacheBase projectRootElementCache = null,
+            LoggingContext loggingContext = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -196,7 +198,8 @@ internal static bool EvaluateCondition<P, I>
                 loggingServices,
                 buildEventContext,
                 fileSystem,
-                projectRootElementCache);
+                projectRootElementCache,
+                loggingContext);
         }
 
         /// <summary>
@@ -218,7 +221,8 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null
+            ProjectRootElementCacheBase projectRootElementCache = null,
+            LoggingContext loggingContext = null
         )
             where P : class, IProperty
             where I : class, IItem
@@ -279,7 +283,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             {
                 try
                 {
-                    result = parsedExpression.Evaluate(state);
+                    result = parsedExpression.Evaluate(state, loggingContext);
                 }
                 finally
                 {
@@ -353,7 +357,7 @@ internal interface IConditionEvaluationState
             ///     May return null if the expression would expand to non-empty and it broke out early.
             ///     Otherwise, returns the correctly expanded expression.
             /// </summary>
-            string ExpandIntoStringBreakEarly(string expression);
+            string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null);
 
             /// <summary>
             ///     Expands the specified expression into a list of TaskItem's.
@@ -363,7 +367,7 @@ internal interface IConditionEvaluationState
             /// <summary>
             ///     Expands the specified expression into a string.
             /// </summary>
-            string ExpandIntoString(string expression);
+            string ExpandIntoString(string expression, LoggingContext loggingContext = null);
 
             /// <summary>
             ///     PRE cache
@@ -440,11 +444,11 @@ internal ConditionEvaluationState
             /// May return null if the expression would expand to non-empty and it broke out early.
             /// Otherwise, returns the correctly expanded expression.
             /// </summary>
-            public string ExpandIntoStringBreakEarly(string expression)
+            public string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation);
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation, loggingContext);
 
                 _expander.WarnForUninitializedProperties = originalValue;
 
@@ -471,12 +475,13 @@ public IList<TaskItem> ExpandIntoTaskItems(string expression)
             /// Expands the specified expression into a string.
             /// </summary>
             /// <param name="expression">The expression to expand.</param>
+            /// <param name="loggingContext"></param>
             /// <returns>The expanded string.</returns>
-            public string ExpandIntoString(string expression)
+            public string ExpandIntoString(string expression, LoggingContext loggingContext = null)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation);
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation, loggingContext);
 
                 _expander.WarnForUninitializedProperties = originalValue;
 
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index 94513436e9c..47481c625c3 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -1,6 +1,7 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -18,9 +19,9 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
@@ -37,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                          state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index e0b57181361..4ec222243fd 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -29,7 +30,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// <summary>
         /// Evaluate node as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index d6007133404..50efb172cf7 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -14,9 +14,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
-        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
-        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -25,7 +25,7 @@ internal abstract class GenericExpressionNode
         /// to empty than to fully evaluate it.)
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
+        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             return false;
         }
@@ -34,7 +34,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state);
+        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
 
         /// <summary>
         /// Value before any item and property expressions are expanded
@@ -52,16 +52,17 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// The main evaluate entry point for expression trees
         /// </summary>
         /// <param name="state"></param>
+        /// <param name="loggingContext"></param>
         /// <returns></returns>
-        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!TryBoolEvaluate(state, out bool boolValue))
+            if (!TryBoolEvaluate(state, out bool boolValue, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ConditionNotBooleanDetail",
                     state.Condition,
-                    GetExpandedValue(state));
+                    GetExpandedValue(state, loggingContext));
             }
 
             return boolValue;
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 65e23c7718f..1ef13748bdc 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -1,6 +1,7 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -36,7 +37,7 @@ internal abstract class MultipleComparisonNode : OperatorExpressionNode
         /// Order in which comparisons are attempted is numeric, boolean, then string.
         /// Updates conditioned properties table.
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext)
         {
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (LeftChild != null && RightChild != null,
@@ -50,8 +51,8 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' " 
             // which is a performance advantage if @(X) is a huge item list.
-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
-            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);
             if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
@@ -68,13 +69,13 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 // is 17.0).
                 return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue, loggingContext) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue, loggingContext))
             {
                 return Compare(leftBoolValue, rightBoolValue);
             }
 
-            string leftExpandedValue = LeftChild.GetExpandedValue(state);
-            string rightExpandedValue = RightChild.GetExpandedValue(state);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state, loggingContext);
+            string rightExpandedValue = RightChild.GetExpandedValue(state, loggingContext);
 
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (leftExpandedValue != null && rightExpandedValue != null,
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index e5b00ac781a..1d2e1d6311e 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -1,6 +1,7 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -18,9 +19,9 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
@@ -44,9 +45,9 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Returns expanded value with '!' prepended. Useful for error messages.
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            return "!" + LeftChild.GetExpandedValue(state);
+            return "!" + LeftChild.GetExpandedValue(state, loggingContext);
         }
 
         internal override string DebuggerDisplay => $"(not {LeftChild.DebuggerDisplay})";
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index 02c242ceef5..f161ad5d18b 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -38,7 +38,7 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
             bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
@@ -53,7 +53,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     state.Condition,
                     /* helpfully display unexpanded token and expanded result in error message */
                     isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
+                    isLeftNum ? RightChild.GetExpandedValue(state, loggingContext) : LeftChild.GetExpandedValue(state, loggingContext));
             }
 
             return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index 66fa552443d..7725d9962dc 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -3,7 +3,7 @@
 
 using System;
 using System.Diagnostics;
-
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -23,18 +23,18 @@ internal NumericExpressionNode(string value)
             _value = value;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
         {
             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
         {
             return Version.TryParse(_value, out result);
         }
@@ -50,7 +50,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Get the expanded value
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             return _value;
         }
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index c6e4b4c349c..a3f76ff20ff 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -12,21 +13,21 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
         {
-            result = BoolEvaluate(state);
+            result = BoolEvaluate(state, loggingContext);
             return true;
         }
 
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
         {
             result = default;
             return false;
@@ -36,7 +37,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             return null;
         }
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index 250e8c9602c..fa1816c2e1d 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -1,6 +1,7 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -18,15 +19,15 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ExpressionDoesNotEvaluateToBoolean",
                     LeftChild.GetUnexpandedValue(state),
-                    LeftChild.GetExpandedValue(state),
+                    LeftChild.GetExpandedValue(state, loggingContext),
                     state.Condition);
             }
 
@@ -37,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                         state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 7017b0b5023..43dd324e7a8 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Diagnostics;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -30,34 +31,34 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
         {
-            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state, loggingContext), out result);
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
             {
                 result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state, loggingContext), out result);
             }
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
             {
                 result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return Version.TryParse(GetExpandedValue(state), out result);
+                return Version.TryParse(GetExpandedValue(state, loggingContext), out result);
             }
         }
 
@@ -68,7 +69,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// to empty than to fully evaluate it.
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (_cachedExpandedValue == null)
             {
@@ -93,7 +94,7 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
                             break;
                     }
 
-                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
+                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value, loggingContext);
 
                     if (expandBreakEarly == null)
                     {
@@ -129,13 +130,13 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (_cachedExpandedValue == null)
             {
                 if (_expandable)
                 {
-                    _cachedExpandedValue = state.ExpandIntoString(_value);
+                    _cachedExpandedValue = state.ExpandIntoString(_value, loggingContext);
                 }
                 else
                 {
@@ -168,7 +169,7 @@ internal override void ResetState()
         /// but now cause the project to throw InvalidProjectException when
         /// ToolsVersion is "Current". https://github.com/dotnet/msbuild/issues/4150
         /// </remarks>
-        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state)
+        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (!_shouldBeTreatedAsVisualStudioVersion.HasValue)
             {
@@ -176,7 +177,7 @@ private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionE
 
                 // Do this check first, because if it's not (common) we can early-out and the next
                 // expansion will be cheap because this will populate the cached expanded value.
-                if (string.Equals(GetExpandedValue(state), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
+                if (string.Equals(GetExpandedValue(state, loggingContext), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
                 {
                     // and it is just an expansion of MSBuildToolsVersion
                     _shouldBeTreatedAsVisualStudioVersion = string.Equals(_value, "$(MSBuildToolsVersion)", StringComparison.OrdinalIgnoreCase);
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index b3154221e9f..900060c0a48 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
@@ -25,13 +24,15 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
-using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
-using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
+using static Microsoft.Build.Execution.ProjectPropertyInstance;
 using Constants = Microsoft.Build.Internal.Constants;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
+using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
+using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
+using ObjectModel = System.Collections.ObjectModel;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using SdkReferencePropertyExpansionMode = Microsoft.Build.Framework.EscapeHatches.SdkReferencePropertyExpansionMode;
+using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 
 #nullable disable
 
@@ -767,7 +768,7 @@ private void Evaluate()
 
                     if (BuildEnvironmentHelper.Instance.RunningInVisualStudio)
                     {
-                        // TODO: Remove this when VS gets updated to setup project cache plugins.
+                        // TODO: Figure out a more elegant way to do this. See the comment on BuildManager.ProjectCacheDescriptors for explanation.
                         CollectProjectCachePlugins();
                     }
 
@@ -811,24 +812,38 @@ private void Evaluate()
             if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
             {
                 globalProperties = _data.GlobalPropertiesDictionary;
-                properties = _data.Properties;
+                properties = Traits.LogAllEnvironmentVariables ? _data.Properties : FilterOutEnvironmentDerivedProperties(_data.Properties);
                 items = _data.Items;
             }
 
             _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);
         }
 
-        private void CollectProjectCachePlugins()
+        private IEnumerable FilterOutEnvironmentDerivedProperties(PropertyDictionary<P> dictionary)
         {
-            foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))
+            List<P> list = new(dictionary.Count);
+            foreach (P p in dictionary)
             {
-                var metadataDictionary = item.Metadata.ToDictionary(m => m.Key, m => m.EscapedValue);
+                if (p is EnvironmentDerivedProjectPropertyInstance ||
+                    (p is ProjectProperty pp && pp.IsEnvironmentProperty))
+                {
+                    continue;
+                }
 
-                var pluginPath = Path.Combine(_data.Directory, item.EvaluatedInclude);
+                list.Add(p);
+            }
 
-                var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);
+            return list;
+        }
 
-                BuildManager.ProjectCacheItems[pluginPath] = projectCacheItem;
+        private void CollectProjectCachePlugins()
+        {
+            foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))
+            {
+                string pluginPath = FileUtilities.NormalizePath(_data.Directory, item.EvaluatedInclude);
+                var pluginSettings = item.Metadata.ToDictionary(m => m.Key, m => m.EscapedValue);
+                var projectCacheItem = ProjectCacheDescriptor.FromAssemblyPath(pluginPath, pluginSettings);
+                BuildManager.ProjectCacheDescriptors.TryAdd(projectCacheItem, projectCacheItem);
             }
         }
 
@@ -842,12 +857,12 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
             using (_evaluationProfiler.TrackFile(currentProjectOrImport.FullPath))
             {
                 // We accumulate InitialTargets from the project and each import
-                var initialTargets = _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.InitialTargets, ExpanderOptions.ExpandProperties, currentProjectOrImport.InitialTargetsLocation);
+                var initialTargets = _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.InitialTargets, ExpanderOptions.ExpandProperties, currentProjectOrImport.InitialTargetsLocation, _evaluationLoggingContext);
                 _initialTargetsList.AddRange(initialTargets);
 
                 if (!Traits.Instance.EscapeHatches.IgnoreTreatAsLocalProperty)
                 {
-                    foreach (string propertyName in _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.TreatAsLocalProperty, ExpanderOptions.ExpandProperties, currentProjectOrImport.TreatAsLocalPropertyLocation))
+                    foreach (string propertyName in _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.TreatAsLocalProperty, ExpanderOptions.ExpandProperties, currentProjectOrImport.TreatAsLocalPropertyLocation, _evaluationLoggingContext))
                     {
                         XmlUtilities.VerifyThrowProjectValidElementName(propertyName, currentProjectOrImport.Location);
                         _data.GlobalPropertiesToTreatAsLocal.Add(propertyName);
@@ -1051,8 +1066,8 @@ private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<Pr
         /// </summary>
         private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets, Dictionary<string, List<TargetSpecification>> targetsWhichRunBeforeByTarget, Dictionary<string, List<TargetSpecification>> targetsWhichRunAfterByTarget)
         {
-            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation);
-            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation);
+            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation, _evaluationLoggingContext);
+            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation, _evaluationLoggingContext);
 
             foreach (string beforeTarget in beforeTargets)
             {
@@ -1197,7 +1212,7 @@ private void AddEnvironmentProperties()
         {
             foreach (ProjectPropertyInstance environmentProperty in _environmentProperties)
             {
-                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true);
+                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true, loggingContext: _evaluationLoggingContext);
             }
         }
 
@@ -1298,7 +1313,7 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                 // it is the same as what we are setting the value on. Note: This needs to be set before we expand the property we are currently setting.
                 _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
 
-                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location);
+                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location, _evaluationLoggingContext);
 
                 // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
                 // during evaluation.
@@ -2003,7 +2018,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
         {
             imports = null;
 
-            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
+            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation, _evaluationLoggingContext);
             ElementLocation importLocationInProject = importElement.Location;
 
             if (String.IsNullOrWhiteSpace(importExpressionEscaped))
@@ -2428,7 +2443,8 @@ private bool EvaluateCondition(ProjectElement element, string condition, Expande
                     element.ConditionLocation,
                     _evaluationLoggingContext.LoggingService,
                     _evaluationLoggingContext.BuildEventContext,
-                    _evaluationContext.FileSystem
+                    _evaluationContext.FileSystem,
+                    loggingContext: _evaluationLoggingContext
                     );
 
                 return result;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 9bc57cab1ed..88e5fea6c1b 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -26,6 +26,7 @@
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
 
 using Microsoft.NET.StringTools;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -418,9 +419,9 @@ internal static bool ExpressionContainsItemVector(string expression)
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation)
+        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
         {
-            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation);
+            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext);
 
             return (result == null) ? null : EscapingUtilities.UnescapeAll(result);
         }
@@ -432,7 +433,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
+        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
         {
             if (expression.Length == 0)
             {
@@ -442,7 +443,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
+            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
 
@@ -472,11 +473,11 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
+        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
         {
             ErrorUtilities.VerifyThrow((options & ExpanderOptions.BreakOnNotEmpty) == 0, "not supported");
 
-            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation));
+            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext));
         }
 
         /// <summary>
@@ -1076,7 +1077,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem)
+                IFileSystem fileSystem,
+                LoggingContext loggingContext = null)
             {
                 return
                     ConvertToString(
@@ -1086,7 +1088,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                             options,
                             elementLocation,
                             usedUninitializedProperties,
-                            fileSystem));
+                            fileSystem,
+                            loggingContext));
             }
 
             /// <summary>
@@ -1112,7 +1115,8 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem)
+                IFileSystem fileSystem,
+                LoggingContext loggingContext = null)
             {
                 if (((options & ExpanderOptions.ExpandProperties) == 0) || String.IsNullOrEmpty(expression))
                 {
@@ -1226,7 +1230,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         }
                         else // This is a regular property
                         {
-                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties);
+                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties, loggingContext);
                         }
 
                         if (propertyValue != null)
@@ -1464,7 +1468,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)
             {
                 T property = properties.GetProperty(propertyName, startIndex, endIndex);
 
@@ -1509,6 +1513,11 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 }
                 else
                 {
+                    if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)
+                    {
+                        environmentDerivedProperty.loggingContext = loggingContext;
+                    }
+
                     propertyValue = property.EvaluatedValueEscaped;
                 }
 
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index cf0b17d457f..497207e7024 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -267,7 +267,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false);
+        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null);
 
         /// <summary>
         /// Sets a property which comes from the Xml.
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 65c1fd8b486..d7f58c8088a 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -156,21 +157,23 @@ private bool InitReferencedItemsIfNecessary()
         /// <param name="itemSpecLocation">The xml location the itemspec comes from</param>
         /// <param name="projectDirectory">The directory that the project is in.</param>
         /// <param name="expandProperties">Expand properties before breaking down fragments. Defaults to true</param>
+        /// <param name="loggingContext">Context in which to log</param>
         public ItemSpec(
             string itemSpec,
             Expander<P, I> expander,
             IElementLocation itemSpecLocation,
             string projectDirectory,
-            bool expandProperties = true)
+            bool expandProperties = true,
+            LoggingContext loggingContext = null)
         {
             ItemSpecString = itemSpec;
             Expander = expander;
             ItemSpecLocation = itemSpecLocation;
 
-            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties);
+            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties, loggingContext);
         }
 
-        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
+        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties, LoggingContext loggingContext)
         {
             // Code corresponds to Evaluator.CreateItemsFromInclude
             var evaluatedItemspecEscaped = ItemSpecString;
@@ -186,7 +189,8 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                 evaluatedItemspecEscaped = Expander.ExpandIntoStringLeaveEscaped(
                     ItemSpecString,
                     ExpanderOptions.ExpandProperties,
-                    itemSpecLocation);
+                    itemSpecLocation,
+                    loggingContext);
             }
 
             var semicolonCount = 0;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 0255a8fbf2d..ecae588cd20 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -307,9 +308,9 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
                 return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped);
             }
 
-            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
+            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, LoggingContext loggingContext = null)
             {
-                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext: loggingContext);
             }
         }
     }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index f78cc28be71..f0c19a5c681 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -262,7 +262,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                                 continue;
                             }
 
-                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location);
+                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location, _lazyEvaluator._loggingContext);
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 28fe97350da..871ad820e6a 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -99,7 +99,8 @@ LazyItemEvaluator<P, I, M, D> lazyEvaluator
                     element.ConditionLocation,
                     lazyEvaluator._loggingContext.LoggingService,
                     lazyEvaluator._loggingContext.BuildEventContext,
-                    lazyEvaluator.FileSystem
+                    lazyEvaluator.FileSystem,
+                    loggingContext: lazyEvaluator._loggingContext
                     );
                 MSBuildEventSource.Log.EvaluateConditionStop(condition, result);
 
@@ -624,7 +625,7 @@ private RemoveOperation BuildRemoveOperation(string rootDirectory, ProjectItemEl
 
         private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLocation itemSpecLocation, OperationBuilder builder)
         {
-            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory);
+            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory, loggingContext: _loggingContext);
 
             foreach (ItemSpecFragment fragment in builder.ItemSpec.Fragments)
             {
@@ -635,7 +636,7 @@ private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLoca
             }
         }
 
-        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander)
+        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander, LoggingContext loggingContext = null)
         {
             // Since we're just attempting to expand properties in order to find referenced items and not expanding metadata,
             // unexpected errors may occur when evaluating property functions on unexpanded metadata. Just ignore them if that happens.
@@ -649,7 +650,8 @@ private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(IColle
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Value,
                     expanderOptions,
-                    metadatumElement.Location);
+                    metadatumElement.Location,
+                    loggingContext);
 
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Condition,
@@ -664,7 +666,7 @@ private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBu
             {
                 operationBuilder.Metadata.AddRange(itemElement.Metadata);
 
-                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander));
+                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander, _loggingContext));
                 if (itemsAndMetadataFound.Items != null)
                 {
                     foreach (var itemType in itemsAndMetadataFound.Items)
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index da81aaf21b5..b113e73a6ec 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -79,10 +79,10 @@ public P GetProperty(string name, int startIndex, int endIndex)
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
+        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
         {
             P originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, loggingContext);
 
             this.TrackPropertyWrite(
                 originalProperty,
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 94344843b96..3a253dbc5a8 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -470,6 +470,21 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
             Initialize(xml, globalProperties, toolsVersion, null, visualStudioVersionFromSolution, new BuildParameters(projectCollection), projectCollection.LoggingService, buildEventContext, sdkResolverService, submissionId);
         }
 
+        /// <summary>
+        /// Initializes a new instance of the <see cref="ProjectInstance"/> class directly.
+        /// No intermediate Project object is created.
+        /// This is ideal if the project is simply going to be built, and not displayed or edited.
+        /// Global properties may be null.
+        /// Tools version may be null.
+        /// Used by SolutionProjectGenerator so that it can explicitly pass the vsVersionFromSolution in for use in
+        /// determining the sub-toolset version.
+        /// </summary>
+        internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, ILoggingService loggingService, int visualStudioVersionFromSolution, ProjectCollection projectCollection, ISdkResolverService sdkResolverService, int submissionId)
+        {
+            BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+            Initialize(xml, globalProperties, toolsVersion, null, visualStudioVersionFromSolution, new BuildParameters(projectCollection), loggingService, buildEventContext, sdkResolverService, submissionId);
+        }
+
         /// <summary>
         /// Creates a mutable ProjectInstance directly, using the specified logging service.
         /// Assumes the project path is already normalized.
@@ -1475,10 +1490,10 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// immutable if we are immutable.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, LoggingContext loggingContext)
         {
             // Mutability not verified as this is being populated during evaluation
-            ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable);
+            ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable, isEnvironmentVariable, loggingContext);
             _properties.Set(property);
             return property;
         }
@@ -2966,7 +2981,7 @@ private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, b
             {
                 // Allow reserved property names, since this is how they are added to the project instance. 
                 // The caller has prevented users setting them themselves.
-                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable);
+                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable, property.IsEnvironmentProperty);
                 _properties.Set(instance);
             }
         }
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index e935b611067..c6fd6293e5d 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -10,6 +10,8 @@
 using Microsoft.Build.BackEnd;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -84,8 +86,21 @@ public string EvaluatedValue
         /// Setter assumes caller has protected global properties, if necessary.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        string IProperty.EvaluatedValueEscaped => _escapedValue;
-
+        string IProperty.EvaluatedValueEscaped
+        {
+            get
+            {
+                if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty)
+                {
+                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);
+                    args.BuildEventContext = envProperty.loggingContext.BuildEventContext;
+                    envProperty.loggingContext.LogBuildEvent(args);
+                    envProperty._loggedEnvProperty = true;
+                }
+
+                return _escapedValue;
+            }
+        }
         /// <summary>
         /// Implementation of IKeyed exposing the property name
         /// </summary>
@@ -182,9 +197,9 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue,
         /// This flags should ONLY be set by the evaluator or by cloning; after the ProjectInstance is created, they must be illegal.
         /// If name is invalid or reserved, throws ArgumentException.
         /// </summary>
-        internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable)
+        internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable, bool isEnvironmentProperty = false, LoggingContext loggingContext = null)
         {
-            return Create(name, escapedValue, mayBeReserved, null, isImmutable);
+            return Create(name, escapedValue, mayBeReserved, null, isImmutable, isEnvironmentProperty, loggingContext);
         }
 
         /// <summary>
@@ -212,7 +227,7 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue,
         /// </summary>
         internal static ProjectPropertyInstance Create(ProjectPropertyInstance that)
         {
-            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: that.IsImmutable);
+            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: that.IsImmutable, that is EnvironmentDerivedProjectPropertyInstance);
         }
 
         /// <summary>
@@ -221,7 +236,7 @@ internal static ProjectPropertyInstance Create(ProjectPropertyInstance that)
         /// </summary>
         internal static ProjectPropertyInstance Create(ProjectPropertyInstance that, bool isImmutable)
         {
-            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: isImmutable);
+            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: isImmutable, that is EnvironmentDerivedProjectPropertyInstance);
         }
 
         /// <summary>
@@ -278,7 +293,7 @@ internal ProjectPropertyElement ToProjectPropertyElement(ProjectElementContainer
         /// as it should never be needed for any subsequent messages, and is just extra bulk.
         /// Inherits mutability from project if any.
         /// </summary>
-        private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable)
+        private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable, bool isEnvironmentProperty = false, LoggingContext loggingContext = null)
         {
             // Does not check immutability as this is only called during build (which is already protected) or evaluation
             ErrorUtilities.VerifyThrowArgumentNull(escapedValue, nameof(escapedValue));
@@ -295,11 +310,10 @@ private static ProjectPropertyInstance Create(string name, string escapedValue,
                 XmlUtilities.VerifyThrowProjectValidElementName(name, location);
             }
 
-            if (isImmutable)
-            {
-                return new ProjectPropertyInstanceImmutable(name, escapedValue);
-            }
-            return new ProjectPropertyInstance(name, escapedValue);
+            ProjectPropertyInstance instance = isEnvironmentProperty ? new EnvironmentDerivedProjectPropertyInstance(name, escapedValue, loggingContext) :
+                isImmutable ? new ProjectPropertyInstanceImmutable(name, escapedValue) :
+                new ProjectPropertyInstance(name, escapedValue);
+            return instance;
         }
 
         /// <summary>
@@ -327,5 +341,27 @@ internal ProjectPropertyInstanceImmutable(string name, string escapedValue)
             /// </remarks>
             public override bool IsImmutable => true;
         }
+
+        internal class EnvironmentDerivedProjectPropertyInstance : ProjectPropertyInstance
+        {
+            internal EnvironmentDerivedProjectPropertyInstance(string name, string escapedValue, LoggingContext loggingContext)
+                : base(name, escapedValue)
+            {
+                this.loggingContext = loggingContext;
+            }
+
+            /// <summary>
+            /// Whether this object can be changed. An immutable object cannot be made mutable.
+            /// </summary>
+            /// <remarks>
+            /// The environment is captured at the start of the build, so environment-derived
+            /// properties can't change.
+            /// </remarks>
+            public override bool IsImmutable => true;
+
+            internal bool _loggedEnvProperty = false;
+
+            internal LoggingContext loggingContext;
+        }
     }
 }
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index b17d74baa50..5d5c32727de 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -905,7 +905,7 @@ public int Compare(object o1, object o2)
 
         public virtual void Shutdown()
         {
-            // do nothing
+            Traits.LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES")) && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4);
         }
 
         internal abstract void ResetConsoleLoggerState();
@@ -1015,6 +1015,7 @@ internal virtual bool ApplyParameter(string parameterName, string parameterValue
                     return true;
                 case "SHOWENVIRONMENT":
                     showEnvironment = true;
+                    Traits.LogAllEnvironmentVariables = true;
                     return true;
                 case "SHOWPROJECTFILE":
                     if (parameterValue == null)
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 7c0fe5bfc58..941cfccfc06 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -4,18 +4,14 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
 using System.IO;
-using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -251,7 +247,14 @@ private void Write(BuildStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.BuildStarted);
             WriteBuildEventArgsFields(e);
-            Write(e.BuildEnvironment);
+            if (Traits.LogAllEnvironmentVariables)
+            {
+                Write(e.BuildEnvironment);
+            }
+            else
+            {
+                Write(0);
+            }
         }
 
         private void Write(BuildFinishedEventArgs e)
@@ -518,7 +521,8 @@ private void Write(TaskParameterEventArgs e)
             Write((int)e.Kind);
             WriteDeduplicatedString(e.ItemType);
             WriteTaskItemList(e.Items, e.LogItemMetadata);
-            if (e.Kind == TaskParameterMessageKind.AddItem)
+            if (e.Kind == TaskParameterMessageKind.AddItem
+               || e.Kind == TaskParameterMessageKind.TaskOutput)
             {
                 CheckForFilesToEmbed(e.ItemType, e.Items);
             }
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 1833201110c..6e16da044d7 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -231,7 +231,10 @@ public override void BuildStartedHandler(object sender, BuildStartedEventArgs e)
                 WriteLinePrettyFromResource("BuildStartedWithTime", e.Timestamp);
             }
 
-            WriteEnvironment(e.BuildEnvironment);
+            if (Traits.LogAllEnvironmentVariables)
+            {
+                WriteEnvironment(e.BuildEnvironment);
+            }
         }
 
         /// <summary>
@@ -1204,16 +1207,21 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
         /// </summary>
         private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
         {
-            string nonNullMessage;
+            string nonNullMessage = null;
+
+            if (e is EnvironmentVariableReadEventArgs environmentPropertyReadEventArgs)
+            {
+                nonNullMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentPropertyReadEventArgs.EnvironmentVariableName, e.Message);
+            }
 
             // Include file information if present.
             if (e.File != null)
             {
-                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e));
+                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e), nonNullMessage);
             }
             else
             {
-                nonNullMessage = e.Message ?? string.Empty;
+                nonNullMessage ??= e.Message ?? string.Empty;
             }
 
             int prefixAdjustment = 0;
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index e677526406b..bbfc1978a44 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -108,7 +108,10 @@ public override void BuildStartedHandler(object sender, BuildStartedEventArgs e)
                 WriteLinePrettyFromResource("BuildStartedWithTime", e.Timestamp);
             }
 
-            WriteEnvironment(e.BuildEnvironment);
+            if (Traits.LogAllEnvironmentVariables)
+            {
+                WriteEnvironment(e.BuildEnvironment);
+            }
         }
 
         /// <summary>
@@ -511,18 +514,15 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                     setColor(ConsoleColor.DarkGray);
                 }
 
-                string nonNullMessage;
+                string nonNullMessage = e is EnvironmentVariableReadEventArgs environmentDerivedProperty ?
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentDerivedProperty.EnvironmentVariableName, e.Message)
+                    : e.Message ?? String.Empty;
 
                 // Include file information if present.
                 if (e.File != null)
                 {
                     nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile);
                 }
-                else
-                {
-                    // null messages are ok -- treat as blank line
-                    nonNullMessage = e.Message ?? String.Empty;
-                }
 
                 WriteLinePretty(nonNullMessage);
 
diff --git a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
index a4ec0aaf92d..b006f76520c 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
@@ -1335,12 +1335,9 @@ Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> M
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.EntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.GetDetailedDescription() -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
@@ -1786,8 +1783,8 @@ static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Mi
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
 static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
 static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
 static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
@@ -1836,4 +1833,4 @@ virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
\ No newline at end of file
+virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
index a8ca12cca99..47780d37b51 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -18,3 +18,4 @@ Microsoft.Build.Experimental.OutOfProcServerNode
 Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback
 Microsoft.Build.Experimental.OutOfProcServerNode.OutOfProcServerNode(Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback buildFunction) -> void
 Microsoft.Build.Experimental.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+static Microsoft.Build.Experimental.MSBuildClient.ShutdownServer(System.Threading.CancellationToken cancellationToken) -> bool
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
index 93740b15de2..38f8853c43d 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -1335,12 +1335,9 @@ Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> M
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.EntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.GetDetailedDescription() -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
@@ -1786,8 +1783,8 @@ static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Mi
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
 static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
 static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
 static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
@@ -1836,4 +1833,4 @@ virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
\ No newline at end of file
+virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index aa42c2c0ede..42acd772719 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -18,4 +18,5 @@ Microsoft.Build.Experimental.OutOfProcServerNode
 Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback
 Microsoft.Build.Experimental.OutOfProcServerNode.OutOfProcServerNode(Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback buildFunction) -> void
 Microsoft.Build.Experimental.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+static Microsoft.Build.Experimental.MSBuildClient.ShutdownServer(System.Threading.CancellationToken cancellationToken) -> bool
 
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 10018e5f8f1..55995f61c7e 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -142,6 +142,9 @@
   <data name="WaitingForEndOfBuild" xml:space="preserve">
     <value>The operation cannot be completed because EndBuild has already been called but existing submissions have not yet completed.</value>
   </data>
+  <data name="EnvironmentDerivedPropertyRead">
+    <value>Property '{0}' with value '{1}' expanded from the environment.</value>
+  </data>
   <data name="SubmissionAlreadyComplete" xml:space="preserve">
     <value>The operation cannot be completed because the submission has already been executed.</value>
   </data>
@@ -1877,15 +1880,11 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</value>
   </data>
   <data name="LoadingProjectCachePlugin" xml:space="preserve">
-    <value>Loading the following project cache plugin:
-    {0}</value>
+    <value>Loading the following project cache plugin: {0}</value>
   </data>
   <data name="SolutionPathPropertyMustBeSetOnVSSubmissions" xml:space="preserve">
     <value>"MSB4264: Invalid $(SolutionPath) property: {0}"</value>
   </data>
-  <data name="OnlyOneCachePluginMustBeSpecified" xml:space="preserve">
-    <value>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</value>
-  </data>
   <data name="ProjectCacheInitializationFailed" xml:space="preserve">
     <value>MSB4266: Failed to initialize the project cache.</value>
   </data>
@@ -1895,9 +1894,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProjectCacheShutdownFailed" xml:space="preserve">
     <value>MSB4268: The project cache failed to shut down properly.</value>
   </data>
-  <data name="NotAllNodesDefineACacheItem" xml:space="preserve">
-    <value>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</value>
-  </data>
   <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
     <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
@@ -1910,9 +1906,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProxyRequestNotScheduledOnInprocNode" xml:space="preserve">
     <value>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</value>
   </data>
-  <data name="ProjectCacheBeginBuild" xml:space="preserve">
-    <value>Initializing project cache plugin.</value>
-  </data>
   <data name="ProjectCacheEndBuild" xml:space="preserve">
     <value>Shutting down project cache plugin.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index bc4f28a26e1..2481e430a40 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: ZadanÃ½ vÃ½stupnÃ­ soubor mezipamÄti pro vÃ½sledky je prÃ¡zdnÃ½.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">ÄÃ­st promÄnnou prostÅedÃ­ {0}</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">NaÄÃ­tÃ¡ se nÃ¡sledujÃ­cÃ­ modul plug-in mezipamÄti projektu:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">NaÄÃ­tÃ¡ se nÃ¡sledujÃ­cÃ­ modul plug-in mezipamÄti projektu:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: V sestavenÃ­ {0} se nenaÅ¡ly Å¾Ã¡dnÃ© moduly plug-in mezipamÄti projektu. Modul plug-in se oÄekÃ¡val.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Pokud jakÃ½koli uzel statickÃ©ho grafu definuje mezipamÄÅ¥ projektu, musÃ­ vÅ¡echny uzly definovat stejnou mezipamÄÅ¥ projektu. NÃ¡sledujÃ­cÃ­ projekty neobsahujÃ­ deklaraci poloÅ¾ky {0}: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">PoÅ¾adovanÃ© sestavenÃ­ NuGet se nenaÅ¡lo. OÄekÃ¡vanÃ¡ cesta: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Metoda {0} se nedÃ¡ zavolat s kolekcÃ­, kterÃ¡ obsahuje prÃ¡zdnÃ© cÃ­lovÃ© nÃ¡zvy nebo nÃ¡zvy null.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: MusÃ­ se zadat jeden modul plug-in mezipamÄti projektu, ale naÅ¡lo se jich vÃ­ce: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">VytvoÅilo se pÅepsÃ¡nÃ­ pomocÃ­ Ãºlohy: {0} v {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicializuje se modul plug-in mezipamÄti projektu.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">VypÃ­nÃ¡ se modul plug-in mezipamÄti projektu.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 2d5371cd4e4..2cedb2c72a9 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Die angegebene Cachedatei fÃ¼r Ausgabeergebnisse ist leer.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Umgebungsvariable "{0}" lesen</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Folgendes Projektcache-Plug-In wird geladen:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Folgendes Projektcache-Plug-In wird geladen:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: In der Assembly "{0}" wurde ein Projektcache-Plug-In erwartet, aber keines gefunden.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Wenn ein statischer Graphknoten einen Projektcache definiert, mÃ¼ssen alle Knoten denselben Projektcache definieren. Die folgenden Projekte enthalten keine Deklaration des Elements "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Die Methode "{0}" kann nicht mit einer Sammlung aufgerufen werden, die NULL oder leere Zielnamen enthÃ¤lt.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Ein einzelnes Projektcache-Plug-In muss angegeben werden, es wurden jedoch mehrere gefunden: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">AuÃerkraftsetzung mit Task erstellt: {0} bei {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Das Projektcache-Plug-in wird initialisiert.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Das Projektcache-Plug-in wird heruntergefahren.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ae8a6a1e189..8eb98128194 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: El archivo de cachÃ© de resultados de salida especificado estÃ¡ vacÃ­o.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Leer la variable de entorno "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Cargando el complemento de cachÃ© de proyectos siguiente:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Cargando el complemento de cachÃ© de proyectos siguiente:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: No se encontrÃ³ ningÃºn complemento de cachÃ© de proyectos en el ensamblado "{0}". Se esperaba uno.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Cuando un nodo de grÃ¡fico estÃ¡tico define una memoria cachÃ© de proyectos, todos los nodos deben definir la misma cachÃ© de proyectos. Los proyectos siguientes no contienen ninguna declaraciÃ³n de elemento "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">No se encontrÃ³ un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">No se puede llamar al mÃ©todo {0} con una colecciÃ³n que contiene nombres de destino nulos o vacÃ­os.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Debe especificarse un solo complemento de cachÃ© de proyectos, pero se encontraron varios: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Se creÃ³ una invalidaciÃ³n mediante la tarea: {0} en {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicializando complemento de cachÃ© de proyecto.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Cerrando complemento de cachÃ© de proyecto.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 0ffddfbe011..3bfabec8c49 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Le fichier cache des rÃ©sultats de sortie spÃ©cifiÃ© est vide.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Lire la variable d'environnement "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Chargement du plug-in de cache de projet suivant:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Chargement du plug-in de cache de projet suivant:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: plug-ins de cache de projet introuvables dans l'assembly "{0}". Un plug-in est attendu.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: quand un nÅud de graphe statique dÃ©finit un cache de projet, tous les nÅuds doivent dÃ©finir le mÃªme cache de projet. Le ou les projets suivants ne contiennent pas de dÃ©claration d'Ã©lÃ©ment "{0}"Â : {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attenduÂ : {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Impossible d'appeler la mÃ©thode {0} avec une collection contenant des noms de cibles qui ont une valeur null ou qui sont vides.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: un seul plug-in de cache de projet doit Ãªtre spÃ©cifiÃ©, mais plusieurs plug-ins ont Ã©tÃ© trouvÃ©sÂ : {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Remplacement crÃ©Ã© Ã  lâaide de la tÃ¢che : {0} au {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Initialisation du plug-in du cache de projet.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">ArrÃªt du plug-in du cache de projet.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 11aec49efc6..a51e335202d 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: il file della cache dei risultati di output specificato Ã¨ vuoto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Legge la variabile di ambiente "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Caricamento del plug-in seguente della cache del progetto:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Caricamento del plug-in seguente della cache del progetto:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: non sono stati trovati plug-in della cache del progetto nell'assembly "{0}". Ne Ã¨ previsto uno.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: quando un nodo di grafo statico definisce una cache del progetto, tutti i nodi devono definire la stessa cache del progetto. Il progetto o i progetti seguenti non contengono una dichiarazione di elemento "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obbligatorio non Ã¨ stato trovato. Percorso previsto: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Non Ã¨ possibile chiamare il metodo {0} con una raccolta contenente nomi di destinazione Null o vuoti.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Ã¨ necessario specificare un singolo plug-in della cache del progetto, ma ne sono trovati piÃ¹ di uno: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Ã stata creata una sostituzione con l'attivitÃ : {0} in {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inizializzazione del plug-in della cache del progetto.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Arresto del plug-in della cache del progetto.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 1bf7a2f0d24..4b494b30cc9 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: æå®ãããåºåçµæã­ã£ãã·ã¥ ãã¡ã¤ã«ã¯ç©ºã§ãã</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">ç°å¢å¤æ° "{0}" ã®èª­ã¿åã</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">æ¬¡ã®ãã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ ãã©ã°ã¤ã³ãèª­ã¿è¾¼ãã§ãã¾ãã
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">æ¬¡ã®ãã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ ãã©ã°ã¤ã³ãèª­ã¿è¾¼ãã§ãã¾ãã
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: ãã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ã®ãã©ã°ã¤ã³ãã¢ã»ã³ããª "{0}" ã«è¦ã¤ããã¾ããã§ããããã©ã°ã¤ã³ã 1 ã¤å¿è¦ã§ãã</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: éçã°ã©ã ãã¼ãã§ãã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ãå®ç¾©ããã¦ããå ´åããã¹ã¦ã®ãã¼ãã§åããã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ãå®ç¾©ããå¿è¦ãããã¾ãããã­ã¸ã§ã¯ã {1} ã«ã¯ã"{0}" é ç®å®£è¨ãå«ã¾ãã¦ãã¾ãã</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">å¿è¦ãª NuGet ã¢ã»ã³ããªãè¦ã¤ããã¾ããã§ãããæ³å®ããããã¹: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">Null ã¾ãã¯ç©ºã®ã¿ã¼ã²ããåãå«ãã³ã¬ã¯ã·ã§ã³ãæå®ãã¦ã¡ã½ãã {0} ãå¼ã³åºããã¨ã¯ã§ãã¾ããã</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: åä¸ã®ãã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ ãã©ã°ã¤ã³ãæå®ããå¿è¦ãããã¾ãããè¤æ°æå®ããã¦ãã¾ãã{0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">ã¿ã¹ã¯ãä½¿ç¨ãã¦ãªã¼ãã¼ã©ã¤ããä½æãã¾ãã: {1} ã® {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">ãã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ ãã©ã°ã¤ã³ãåæåãã¦ãã¾ãã</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">ãã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ ãã©ã°ã¤ã³ãã·ã£ãããã¦ã³ãã¦ãã¾ãã</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 8f5d34f5cce..a278ca0942b 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: ì§ì í ì¶ë ¥ ê²°ê³¼ ìºì íì¼ì´ ë¹ì´ ììµëë¤.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">íê²½ ë³ì "{0}" ì½ê¸°</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">ë¤ì íë¡ì í¸ ìºì íë¬ê·¸ ì¸ì ë¡ëíë ì¤:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">ë¤ì íë¡ì í¸ ìºì íë¬ê·¸ ì¸ì ë¡ëíë ì¤:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: "{0}" ì´ìë¸ë¦¬ìì íë¡ì í¸ ìºì íë¬ê·¸ ì¸ì ì°¾ì ì ììµëë¤. 1ê°ê° íìí©ëë¤.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: ì ì  ê·¸ëí ë¸ëìì íë¡ì í¸ ìºìë¥¼ ì ìí  ë ëª¨ë  ë¸ëë ê°ì íë¡ì í¸ ìºìë¥¼ ì ìí´ì¼ í©ëë¤. {1} íë¡ì í¸ìë "{0}" í­ëª© ì ì¸ì´ í¬í¨ëì´ ìì§ ììµëë¤.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">íìí NuGet ì´ìë¸ë¦¬ë¥¼ ì°¾ì ì ììµëë¤. ìì ê²½ë¡: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">null ëë ë¹ ëì ì´ë¦ì í¬í¨íë ì»¬ë ìì ì¬ì©íì¬ {0} ë©ìëë¥¼ í¸ì¶í  ì ììµëë¤.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: ë¨ì¼ íë¡ì í¸ ìºì íë¬ê·¸ ì¸ì´ ì§ì ëì´ì¼ íì§ë§, {0}ìì ì¬ë¬ ê°ë¥¼ ì°¾ììµëë¤.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">ë¤ì ììì ì¬ì©íì¬ ì¬ì ìë¥¼ ë§ë¤ììµëë¤. {1}ì {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">íë¡ì í¸ ìºì íë¬ê·¸ì¸ì ì´ê¸°í ì¤ìëë¤.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">íë¡ì í¸ ìºì íë¬ê·¸ì¸ì ì¢ë£í©ëë¤.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b893482a44e..6ce4dabadb8 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: OkreÅlony plik wyjÅciowej pamiÄci podrÄcznej wynikÃ³w jest pusty.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Odczytaj zmiennÄ ÅrodowiskowÄ â{0}â</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Åadowanie nastÄpujÄcej wtyczki pamiÄci podrÄcznej projektu: 
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Åadowanie nastÄpujÄcej wtyczki pamiÄci podrÄcznej projektu: 
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: nie znaleziono wtyczek pamiÄci podrÄcznej projektu w zestawie â{0}â. Oczekiwano jednej.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: gdy dowolny wÄzeÅ wykresu statycznego definiuje pamiÄÄ podrÄcznÄ projektu, wszystkie wÄzÅy muszÄ definiowaÄ tÄ samÄ pamiÄÄ podrÄcznÄ projektu. NastÄpujÄce projekty nie zawierajÄ deklaracji elementu â{0}â: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ÅcieÅ¼ki {0}.</target>
@@ -219,21 +218,11 @@
         <target state="translated">Metody {0} nie moÅ¼na wywoÅaÄ przy uÅ¼yciu kolekcji zawierajÄcej nazwy docelowe o wartoÅci null lub puste.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: naleÅ¼y okreÅliÄ jednÄ wtyczkÄ pamiÄci podrÄcznej projektu, ale znaleziono ich wiele: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Utworzono zastÄpienie przy uÅ¼yciu zadania: {0} o {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicjowanie wtyczki pamiÄci podrÄcznej projektu.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Zamykanie wtyczki pamiÄci podrÄcznej projektu.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index ad14ba37ca1..410c7bf87ea 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: o arquivo de cache do resultado de saÃ­da especificado estÃ¡ vazio.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Ler a variÃ¡vel de ambiente "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Carregando o seguinte plug-in do projeto:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Carregando o seguinte plug-in do projeto:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: nÃ£o foi encontrado nenhum plug-in de cache do projeto no assembly "{0}". Era esperado um plug-in.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: quando algum nÃ³ de grafo estÃ¡tico define um cache do projeto, todos os nÃ³s precisam definir o mesmo cache do projeto. Os seguintes projetos nÃ£o contÃªm uma declaraÃ§Ã£o de item "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Um assembly NuGet necessÃ¡rio nÃ£o foi encontrado. Caminho Esperado: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">O mÃ©todo {0} nÃ£o pode ser chamado com uma coleÃ§Ã£o que contÃ©m nomes de destino nulos ou vazios.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Ã© necessÃ¡rio especificar sÃ³ um plug-in de cache do projeto, mas foram encontrados vÃ¡rios: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Criou uma substituiÃ§Ã£o usando a tarefa: {0} em {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicializando o plugin de cache do projeto.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Desligando o plug-in de cache do projeto.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 04004fbdfe1..94d4a55fc6a 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ Ð²ÑÑÐ¾Ð´Ð½Ð¾Ð¹ ÑÐ°Ð¹Ð» ÐºÑÑÐ° ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ¾Ð² Ð¿ÑÑÑÐ¾Ð¹.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Ð§ÑÐµÐ½Ð¸Ðµ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ ÑÑÐµÐ´Ñ "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">ÐÐ´ÐµÑ Ð·Ð°Ð³ÑÑÐ·ÐºÐ° ÑÐ»ÐµÐ´ÑÑÑÐµÐ³Ð¾ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ°ÐµÐ¼Ð¾Ð³Ð¾ Ð¼Ð¾Ð´ÑÐ»Ñ ÐºÑÑÐ° Ð¿ÑÐ¾ÐµÐºÑÐ¾Ð²:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">ÐÐ´ÐµÑ Ð·Ð°Ð³ÑÑÐ·ÐºÐ° ÑÐ»ÐµÐ´ÑÑÑÐµÐ³Ð¾ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ°ÐµÐ¼Ð¾Ð³Ð¾ Ð¼Ð¾Ð´ÑÐ»Ñ ÐºÑÑÐ° Ð¿ÑÐ¾ÐµÐºÑÐ¾Ð²:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ°ÐµÐ¼ÑÐµ Ð¼Ð¾Ð´ÑÐ»Ð¸ ÐºÑÑÐ° Ð¿ÑÐ¾ÐµÐºÑÐ¾Ð² Ð² ÑÐ±Ð¾ÑÐºÐµ "{0}". ÐÐ¾Ð»Ð¶ÐµÐ½ Ð±ÑÑÑ ÑÐºÐ°Ð·Ð°Ð½ Ð¾Ð´Ð¸Ð½ Ð¼Ð¾Ð´ÑÐ»Ñ.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: ÐµÑÐ»Ð¸ Ð´Ð»Ñ ÐºÐ°ÐºÐ¾Ð³Ð¾-Ð»Ð¸Ð±Ð¾ ÑÐ·Ð»Ð° ÑÑÐ°ÑÐ¸ÑÐµÑÐºÐ¾Ð³Ð¾ Ð³ÑÐ°ÑÐ° Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½ ÐºÑÑ Ð¿ÑÐ¾ÐµÐºÑÐ¾Ð², ÑÑÐ¾Ñ ÐºÑÑ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð±ÑÑÑ ÑÐºÐ°Ð·Ð°Ð½ Ð´Ð»Ñ Ð²ÑÐµÑ ÑÐ·Ð»Ð¾Ð². Ð¡Ð»ÐµÐ´ÑÑÑÐ¸Ðµ Ð¿ÑÐ¾ÐµÐºÑÑ Ð½Ðµ ÑÐ¾Ð´ÐµÑÐ¶Ð°Ñ Ð¾Ð±ÑÑÐ²Ð»ÐµÐ½Ð¸Ðµ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ° "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð° Ð¾Ð±ÑÐ·Ð°ÑÐµÐ»ÑÐ½Ð°Ñ ÑÐ±Ð¾ÑÐºÐ° NuGet. ÐÐ¶Ð¸Ð´Ð°ÐµÐ¼ÑÐ¹ Ð¿ÑÑÑ: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">ÐÐµÑÐ¾Ð´ {0} Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð²ÑÐ·Ð²Ð°Ð½ Ñ ÐºÐ¾Ð»Ð»ÐµÐºÑÐ¸ÐµÐ¹, ÑÐ¾Ð´ÐµÑÐ¶Ð°ÑÐµÐ¹ ÑÐµÐ»ÐµÐ²ÑÐµ Ð¸Ð¼ÐµÐ½Ð°, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð¿ÑÑÑÑ Ð¸Ð»Ð¸ ÑÐ°Ð²Ð½Ñ NULL.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð±ÑÑÑ ÑÐºÐ°Ð·Ð°Ð½ Ð¾Ð´Ð¸Ð½ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ°ÐµÐ¼ÑÐ¹ Ð¼Ð¾Ð´ÑÐ»Ñ ÐºÑÑÐ° Ð¿ÑÐ¾ÐµÐºÑÐ¾Ð², Ð½Ð¾ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾: {0}.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¾ Ð¿ÐµÑÐµÐ¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ Ð·Ð°Ð´Ð°ÑÐ¸ {0} Ð² {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">ÐÐ½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ°ÐµÐ¼Ð¾Ð³Ð¾ Ð¼Ð¾Ð´ÑÐ»Ñ ÐºÑÑÐ° Ð¿ÑÐ¾ÐµÐºÑÐ°.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">ÐÐ°Ð²ÐµÑÑÐµÐ½Ð¸Ðµ ÑÐ°Ð±Ð¾ÑÑ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ°ÐµÐ¼Ð¾Ð³Ð¾ Ð¼Ð¾Ð´ÑÐ»Ñ ÐºÑÑÐ° Ð¿ÑÐ¾ÐµÐºÑÐ°.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 5fc8f54ba4e..6269d912df1 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Belirtilen Ã§Ä±kÄ±Å sonucu Ã¶nbellek dosyasÄ± boÅ.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">"{0}" ortam deÄiÅkenini oku</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Åu proje Ã¶nbelleÄi eklentisi yÃ¼kleniyor:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Åu proje Ã¶nbelleÄi eklentisi yÃ¼kleniyor:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: "{0}" bÃ¼tÃ¼nleÅtirilmiÅ kodunda proje Ã¶nbelleÄi eklentisi bulunamadÄ±. Bir eklenti bekleniyordu.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Herhangi bir statik graf dÃ¼ÄÃ¼mÃ¼nde proje Ã¶nbelleÄi tanÄ±mlandÄ±ÄÄ±nda tÃ¼m dÃ¼ÄÃ¼mler aynÄ± proje Ã¶nbelleÄini tanÄ±mlamalÄ±dÄ±r. Åu projeler "{0}" Ã¶Äe bildirimini iÃ§ermiyor: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Gereken NuGet derlemesi bulunamadÄ±. Beklenen Yol: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">{0} metosu null veya boÅ hedef adlarÄ± iÃ§eren bir koleksiyonla Ã§aÄrÄ±lamaz.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Tek bir proje Ã¶nbellek eklentisi belirtilmelidir ancak birden Ã§ok eklenti bulundu: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">{0} gÃ¶revi kullanÄ±larak geÃ§ersiz kÄ±lma iÅlemi oluÅturuldu, saat: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Proje Ã¶nbellek eklentisi baÅlatÄ±lÄ±yor.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Proje Ã¶nbellek eklentisi kapatÄ±lÄ±yor.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 4a9d18a374e..16534ffea57 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: æå®çè¾åºç»æç¼å­æä»¶ä¸ºç©ºã</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">è¯»åç¯å¢åéâ{0}â</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">æ­£å¨å è½½ä»¥ä¸é¡¹ç®ç¼å­æä»¶: 
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">æ­£å¨å è½½ä»¥ä¸é¡¹ç®ç¼å­æä»¶: 
     {0}â</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: å¨ç¨åºé "{0}" ä¸­æªæ¾å°é¡¹ç®ç¼å­æä»¶ãåºæä¸ä¸ªæä»¶ã</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: å½ä»»ä½éæå³ç³»å¾èç¹å®ä¹é¡¹ç®ç¼å­æ¶ï¼ææèç¹å¿é¡»å®ä¹ç¸åçé¡¹ç®ç¼å­ãä»¥ä¸é¡¹ç®ä¸åå« "{0}" é¡¹å£°æ: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">æªæ¾å°æéç NuGet ç¨åºéãæéè·¯å¾: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">æ æ³ä½¿ç¨åå« null æç©ºç®æ åç§°çéåè°ç¨æ¹æ³ {0}ã</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: å¿é¡»æå®åä¸ªé¡¹ç®ç¼å­æä»¶ï¼ä½æ¾å°å¤ä¸ªä½ç½®: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">å·²ä½¿ç¨ä»»å¡åå»ºæ¿ä»£: {0} ä½äº {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">æ­£å¨åå§åé¡¹ç®ç¼å­æä»¶ã</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">æ­£å¨å³é­é¡¹ç®ç¼å­æä»¶ã</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 214240db01c..8556c522ddf 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: æå®çè¼¸åºçµæå¿«åæªæ¡æ¯ç©ºçã</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">è®åç°å¢è®æ¸ "{0}"</target>
@@ -143,9 +148,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">æ­£å¨è¼å¥ä¸åå°æ¡å¿«åå¤æç¨å¼:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">æ­£å¨è¼å¥ä¸åå°æ¡å¿«åå¤æç¨å¼:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +180,6 @@
         <target state="translated">MSB4270: å¨çµä»¶ "{0}" ä¸­æ¾ä¸å°ä»»ä½å°æ¡å¿«åå¤æç¨å¼ï¼ä½æè©²è¦æä¸åå¤æç¨å¼ã</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: ç¶ä»»ä½éæåè¡¨ç¯é»å®ç¾©äºå°æ¡å¿«åæï¼ææç¯é»é½å¿é å®ç¾©ç¸åçå°æ¡å¿«åãä¸åå°æ¡ä¸åå« "{0}" é ç®å®£å: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">æ¾ä¸å°å¿è¦ç NuGet åä»¶ãé æçè·¯å¾: {0}</target>
@@ -219,21 +218,11 @@
         <target state="translated">ç¡æ³ä½¿ç¨å§å« null æç©ºç½ç®æ¨åç¨±çéåå¼å«æ¹æ³ {0}ã</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: åªå¯æå®å®ä¸å°æ¡å¿«åå¤æç¨å¼ï¼ä½ç¼ç¾å¤åæå®é ç®: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">å·²ä½¿ç¨ä¸åå·¥ä½å»ºç«è¦å¯«: æ¼ {1} ç {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">æ­£å¨åå§åå°æ¡å¿«åå¤æç¨å¼ã</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">æ­£å¨ééå°æ¡å¿«åå¤æç¨å¼ã</target>
diff --git a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
index 2bf43e98406..eca867cd1cc 100644
--- a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
@@ -27,7 +27,7 @@ public void EventArgsCtors()
             buildFinishedEvent = new BuildFinishedEventArgs("{0}", "HelpKeyword", true, new DateTime(), "Message");
             buildFinishedEvent = new BuildFinishedEventArgs(null, null, true);
             buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime());
-            buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime(), null);
+            buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime(), messageArgs: null);
         }
 
         /// <summary>
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 72091def7ac..d1f49d3e19a 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -102,6 +101,14 @@ public Traits()
         /// </summary>
         public readonly bool LogPropertyFunctionsRequiringReflection = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection"));
 
+        /// <summary>
+        /// Log all environment variables whether or not they are used in a build in the binary log.
+        /// </summary>
+        public static bool LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"))
+#if !TASKHOST
+            && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4)
+#endif
+            ;
         /// <summary>
         /// Log property tracking information.
         /// </summary>
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index f521f0949f0..a58e3d035f2 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -7,6 +7,8 @@
 using System.Text.RegularExpressions;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
@@ -19,6 +21,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Path = System.IO.Path;
 
 namespace Microsoft.Build.Engine.UnitTests
 {
@@ -210,6 +213,47 @@ public void BuildsWhileBuildIsRunningOnServer()
             t.Wait();
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void CanShutdownServerProcess(bool byBuildManager)
+        {
+            _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+
+            TransientTestFile project = _env.CreateFile("testProject.proj", printPidContents);
+
+            // Start a server node and find its PID.
+            string output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out bool success, false, _output);
+            success.ShouldBeTrue();
+            int pidOfServerProcess = ParseNumber(output, "Server ID is ");
+            _env.WithTransientProcess(pidOfServerProcess);
+
+            var serverProcess = Process.GetProcessById(pidOfServerProcess);
+
+            serverProcess.HasExited.ShouldBeFalse();
+
+            if (byBuildManager)
+            {
+                BuildManager.DefaultBuildManager.ShutdownAllNodes();
+            }
+            else
+            {
+                bool serverIsDown = MSBuildClient.ShutdownServer(CancellationToken.None);
+                serverIsDown.ShouldBeTrue();
+            }
+
+            serverProcess.WaitForExit(10_000);
+
+            serverProcess.HasExited.ShouldBeTrue();
+        }
+
+        [Fact]
+        public void CanShutdownServerProcessWhenNotRunning()
+        {
+            bool serverIsDown = MSBuildClient.ShutdownServer(CancellationToken.None);
+            serverIsDown.ShouldBeTrue();
+        }
+
         [Fact]
         public void ServerShouldNotRunWhenNodeReuseEqualsFalse()
         {
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index c0bb91a4e56..15a96bb74dc 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -690,21 +690,21 @@ elementFormDefault="qualified">
                             <xs:element name="IncludeAssets">
                               <xs:annotation>
                                 <xs:documentation>
-                                  <!-- _locID_text="ProjectReference_IncludeAssets" _locComment="" -->Assets to include from this reference
+                                  <!-- _locID_text="ProjectReference_IncludeAssets" _locComment="" -->Assets to include from this reference. Applies to packages referenced transitively by the reference as well.
                                 </xs:documentation>
                               </xs:annotation>
                             </xs:element>
                             <xs:element name="ExcludeAssets">
                               <xs:annotation>
                                 <xs:documentation>
-                                  <!-- _locID_text="ProjectReference_ExcludeAssets" _locComment="" -->Assets to exclude from this reference
+                                  <!-- _locID_text="ProjectReference_ExcludeAssets" _locComment="" -->Assets to exclude from this reference. Applies to packages referenced transitively by the reference as well.
                                 </xs:documentation>
                               </xs:annotation>
                             </xs:element>
                             <xs:element name="PrivateAssets">
                               <xs:annotation>
                                 <xs:documentation>
-                                  <!-- _locID_text="ProjectReference_PrivateAssets" _locComment="" -->Assets that are private in this reference
+                                  <!-- _locID_text="ProjectReference_PrivateAssets" _locComment="" -->Assets that are private in this reference. Applies to packages referenced transitively by the reference as well.
                                 </xs:documentation>
                               </xs:annotation>
                             </xs:element>
@@ -1733,6 +1733,11 @@ elementFormDefault="qualified">
       </xs:annotation>
     </xs:element>
     <xs:element name="DisableXbfGeneration" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="DisableTransitiveProjectReferences" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="DisableTransitiveProjectReferences" _locComment="" -->When true, do not discover ProjectReference items representing projects referenced by this project's ProjectReferences. Applies only to projects using the .NET SDK.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="SuppressXamlWarnings" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="XamlRootsLog" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="XamlSavedStateFilePath" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index af1472b56d1..c144de69fd8 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -669,7 +669,6 @@ string[] commandLine
                 string outputResultsCache = null;
 
                 GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile, out _);
-
                 bool buildCanBeInvoked = ProcessCommandLineSwitches(
                                             switchesFromAutoResponseFile,
                                             switchesNotFromAutoResponseFile,
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index beca5404f56..ec7f04055ae 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-ï»¿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -39,6 +39,10 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
+    <!-- EnvironmentVariableReadEventArgs shouldn't be used in TaskHosts, but it means we need fewer ifdefs. -->
+    <Compile Include="..\Framework\EnvironmentVariableReadEventArgs.cs">
+      <Link>EnvironmentVariableReadEventArgs.cs</Link>
+    </Compile>
     <Compile Include="..\Framework\BuildEnvironmentState.cs">
       <Link>BuildEnvironmentState.cs</Link>
     </Compile>
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index b2579ae8610..6d5d9ebfd74 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -550,9 +550,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
             {
                 // In the .NET SDK, there's one copy of MSBuild.dll and it's in the root folder.
                 MSBuildToolsDirectoryRoot = CurrentMSBuildToolsDirectory;
+
+                // If we're standalone, we might not be in the SDK. Rely on folder paths at this point.
+                if (string.Equals(currentToolsDirectory.Name, "amd64", StringComparison.OrdinalIgnoreCase) ||
+                    string.Equals(currentToolsDirectory.Name, "arm64", StringComparison.OrdinalIgnoreCase))
+                {
+                    MSBuildToolsDirectoryRoot = currentToolsDirectory.Parent?.FullName;
+                }
             }
 
-            if (mode == BuildEnvironmentMode.VisualStudio && MSBuildToolsDirectoryRoot != null)
+            if (MSBuildToolsDirectoryRoot != null)
             {
                 // Calculate potential paths to other architecture MSBuild.exe
                 var potentialAmd64FromX86 = FileUtilities.CombinePaths(MSBuildToolsDirectoryRoot, "amd64", msBuildExeName);
@@ -563,8 +570,8 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
                 var existsCheck = mode == BuildEnvironmentMode.VisualStudio ? new Func<string, bool>(_ => true) : File.Exists;
 
                 MSBuildToolsDirectory32 = MSBuildToolsDirectoryRoot;
-                MSBuildToolsDirectory64 = Path.Combine(MSBuildToolsDirectoryRoot, "amd64");
-                MSBuildToolsDirectoryArm64 = File.Exists(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : null;
+                MSBuildToolsDirectory64 = existsCheck(potentialAmd64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "amd64") : CurrentMSBuildToolsDirectory;
+                MSBuildToolsDirectoryArm64 = existsCheck(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : null;
             }
 
             MSBuildExtensionsPath = mode == BuildEnvironmentMode.VisualStudio
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 4489d33a43b..af794b51281 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -108,7 +108,7 @@ internal static bool ValidBooleanTrue(string parameterValue)
         /// Returns true if the string represents a valid MSBuild boolean false value,
         /// such as "!on" "off" "no" "!true"
         /// </summary>
-        private static bool ValidBooleanFalse(string parameterValue)
+        internal static bool ValidBooleanFalse(string parameterValue)
         {
             return String.Equals(parameterValue, "false", StringComparison.OrdinalIgnoreCase) ||
                    String.Equals(parameterValue, "off", StringComparison.OrdinalIgnoreCase) ||
diff --git a/src/Shared/EnvironmentUtilities.cs b/src/Shared/EnvironmentUtilities.cs
index e9e0482619f..01cf349f2f8 100644
--- a/src/Shared/EnvironmentUtilities.cs
+++ b/src/Shared/EnvironmentUtilities.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Runtime.InteropServices;
 
-#nullable disable
-
 namespace Microsoft.Build.Shared
 {
     internal static partial class EnvironmentUtilities
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index e3bcdf9fcba..7c0db803f70 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -53,10 +53,11 @@ internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProj
         /// <param name="e">Message to format</param>
         /// <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
         /// <param name="projectConfigurationDescription">Properties to Print along with message</param>
+        /// <param name="nonNullMessage">The complete message (including property name) for an environment-derived property</param>
         /// <returns>The formatted message string.</returns>
-        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription)
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription, string nonNullMessage = null)
         {
-            return FormatEventMessage("message", e.Subcategory, e.Message,
+            return FormatEventMessage("message", e.Subcategory, nonNullMessage ?? e.Message,
                             e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber,
                             e.ColumnNumber, e.EndColumnNumber, e.ThreadId, projectConfigurationDescription);
         }
@@ -144,13 +145,14 @@ internal static string FormatEventMessage(BuildMessageEventArgs e)
         /// </summary>
         /// <param name="e">Message to format</param>
         /// <param name="showProjectFile">Show project file or not</param>
+        /// <param name="nonNullMessage">For an EnvironmentVariableReadEventArgs, adds an explanatory note and the name of the variable.</param>
         /// <returns>The formatted message string.</returns>
-        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile)
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string nonNullMessage = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             // "message" should not be localized
-            return FormatEventMessage("message", e.Subcategory, e.Message,
+            return FormatEventMessage("message", e.Subcategory, nonNullMessage ?? e.Message,
                 e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber, e.ColumnNumber, e.EndColumnNumber, e.ThreadId, null);
         }
 
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index ffbf64c1033..2d91a466fbf 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -323,12 +323,9 @@ internal static void DumpExceptionToFile(Exception ex)
 
                     // For some reason we get Watson buckets because GetTempPath gives us a folder here that doesn't exist.
                     // Either because %TMP% is misdefined, or because they deleted the temp folder during the build.
-                    if (!FileSystems.Default.DirectoryExists(DebugDumpPath))
-                    {
-                        // If this throws, no sense catching it, we can't log it now, and we're here
-                        // because we're a child node with no console to log to, so die
-                        Directory.CreateDirectory(DebugDumpPath);
-                    }
+                    // If this throws, no sense catching it, we can't log it now, and we're here
+                    // because we're a child node with no console to log to, so die
+                    Directory.CreateDirectory(DebugDumpPath);
 
                     var pid = Process.GetCurrentProcess().Id;
                     // This naming pattern is assumed in ReadAnyExceptionFromFile
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index b1d737942b5..9f625373ed9 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -130,6 +130,11 @@ internal enum LoggingEventType : int
         /// Event is a TelemetryEventArgs
         /// </summary>
         Telemetry = 18,
+
+        /// <summary>
+        /// Event is an EnvironmentVariableReadEventArgs
+        /// </summary>
+        EnvironmentVariableReadEvent = 19,
     }
     #endregion
 
@@ -323,7 +328,8 @@ internal void WriteToStream(ITranslator translator)
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs ||
-                    _buildEvent is ProjectEvaluationFinishedEventArgs)
+                    _buildEvent is ProjectEvaluationFinishedEventArgs ||
+                    _buildEvent is EnvironmentVariableReadEventArgs)
                 {
                     // switch to serialization methods that we provide in this file
                     // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
@@ -403,6 +409,7 @@ internal void ReadFromStream(ITranslator translator)
                 else
                 {
                     _buildEvent = ReadEventFromStream(_eventType, translator);
+                    ErrorUtilities.VerifyThrow(_buildEvent is not null, "Not Supported LoggingEventType {0}", _eventType.ToString());
                 }
             }
             else
@@ -509,6 +516,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskStartedEvent => new TaskStartedEventArgs(null, null, null, null, null),
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
+                LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
                 LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
@@ -607,6 +615,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildErrorEvent;
             }
+            else if (eventType == typeof(EnvironmentVariableReadEventArgs))
+            {
+                return LoggingEventType.EnvironmentVariableReadEvent;
+            }
             else
             {
                 return LoggingEventType.CustomEvent;
@@ -661,12 +673,29 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.ProjectFinishedEvent:
                     WriteExternalProjectFinishedEventToStream((ExternalProjectFinishedEventArgs)buildEvent, translator);
                     break;
+                case LoggingEventType.EnvironmentVariableReadEvent:
+                    WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);
+                    break;
                 default:
                     ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
                     break;
             }
         }
 
+        /// <summary>
+        /// Serializes EnvironmentVariableRead Event argument to the stream. Does not work properly on TaskHosts due to BuildEventContext serialization not being
+        /// enabled on TaskHosts, but that shouldn't matter, as this should never be called from a TaskHost anyway.
+        /// </summary>
+        private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)
+        {
+            string name = environmentVariableReadEventArgs.EnvironmentVariableName;
+            translator.Translate(ref name);
+            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
+#if !CLR2COMPATIBILITY
+            translator.Translate(ref context);
+#endif
+        }
+
         /// <summary>
         /// Serialize ExternalProjectFinished Event Argument to the stream
         /// </summary>
@@ -1001,33 +1030,33 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
             translator.Translate(ref helpKeyword);
             translator.Translate(ref senderName);
 
-            BuildEventArgs buildEvent = null;
-            switch (eventType)
+            return eventType switch
             {
-                case LoggingEventType.TaskCommandLineEvent:
-                    buildEvent = ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.BuildErrorEvent:
-                    buildEvent = ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.ProjectStartedEvent:
-                    buildEvent = ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.ProjectFinishedEvent:
-                    buildEvent = ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.BuildMessageEvent:
-                    buildEvent = ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.BuildWarningEvent:
-                    buildEvent = ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                default:
-                    ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
-                    break;
-            }
+                LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),
+                _ => null,
+            };
+        }
 
-            return buildEvent;
+        /// <summary>
+        /// Read and reconstruct an EnvironmentVariableReadEventArgs from the stream. This message should never be called from a TaskHost, so although the context translation does not work, that's ok.
+        /// </summary>
+        private EnvironmentVariableReadEventArgs ReadEnvironmentVariableReadEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
+        {
+            string environmentVariableName = null;
+            translator.Translate(ref environmentVariableName);
+            BuildEventContext context = null;
+#if !CLR2COMPATIBILITY
+            translator.Translate(ref context);
+#endif
+            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message);
+            args.BuildEventContext = context;
+            return args;
         }
 
         /// <summary>
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 3cb530afca4..1f65afed8cd 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -2064,15 +2064,20 @@ public async Task<BuildResult> BuildProjectFileAsync(
                 string[] entryTargets = null,
                 Dictionary<string, string> globalProperties = null)
             {
-                var buildRequestData = new BuildRequestData(projectFile,
+                var buildRequestData = new BuildRequestData(
+                    projectFile,
                     globalProperties ?? new Dictionary<string, string>(),
                     MSBuildConstants.CurrentToolsVersion,
                     entryTargets ?? Array.Empty<string>(),
                     null);
+                return await BuildAsync(buildRequestData);
+            }
 
+            public async Task<BuildResult> BuildAsync(BuildRequestData requestData)
+            {
                 var completion = new TaskCompletionSource<BuildResult>();
 
-                _buildManager.PendBuildRequest(buildRequestData).ExecuteAsync(submission =>
+                _buildManager.PendBuildRequest(requestData).ExecuteAsync(submission =>
                 {
                     completion.SetResult(submission.BuildResult);
                 }, null);
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 2db94fa9e83..c97b575d88c 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -259,17 +259,6 @@ public TransientTestFile ExpectFile(string extension = ".tmp")
             return WithTransientTestState(new TransientTestFile(extension, createFile: false, expectedAsOutput: true));
         }
 
-        /// <summary>
-        /// Create a temp file name under a specific temporary folder. The file is expected to exist when the test completes.
-        /// </summary>
-        /// <param name="transientTestFolder">Temp folder</param>
-        /// <param name="extension">Extension of the file (defaults to '.tmp')</param>
-        /// <returns></returns>
-        public TransientTestFile ExpectFile(TransientTestFolder transientTestFolder, string extension = ".tmp")
-        {
-            return WithTransientTestState(new TransientTestFile(transientTestFolder.Path, extension, createFile: false, expectedAsOutput: true));
-        }
-
         /// <summary>
         ///     Creates a test variant used to add a unique temporary folder during a test. Will be deleted when the test
         ///     completes.
@@ -583,7 +572,14 @@ public override void Revert()
         {
             if (_processId > -1)
             {
-                Process.GetProcessById(_processId).KillTree(1000);
+                try
+                {
+                    Process.GetProcessById(_processId).KillTree(1000);
+                }
+                catch
+                {
+                    // ignore if process is already dead
+                }
             }
         }
     }
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index c4c89013a1e..33cdf7e7ad1 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -218,5 +218,46 @@ public void PseudoLocalization(string culture)
             Assert.Equal($"MyResource.{culture}.resx", t.AssignedFiles[0].ItemSpec);
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
+
+        /// <summary>
+        /// Testing that certain aliases are considered valid cultures. Regression test for https://github.com/dotnet/msbuild/issues/3897.
+        /// </summary>
+        /// <param name="culture"></param>
+        [Theory]
+        [InlineData("zh-TW")]
+        [InlineData("zh-MO")]
+        public void SupportAliasedCultures(string culture)
+        {
+            AssignCulture t = new AssignCulture();
+            t.BuildEngine = new MockEngine();
+            ITaskItem i = new TaskItem($"MyResource.{culture}.resx");
+            t.Files = new ITaskItem[] { i };
+            t.Execute();
+
+            Assert.Single(t.AssignedFiles);
+            Assert.Single(t.CultureNeutralAssignedFiles);
+            Assert.Equal(culture, t.AssignedFiles[0].GetMetadata("Culture"));
+            Assert.Equal($"MyResource.{culture}.resx", t.AssignedFiles[0].ItemSpec);
+            Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
+        }
+
+        [Theory]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework, "These cultures are not returned via Culture api on net472.")]
+        [InlineData("sh-BA")]
+        [InlineData("shi-MA")]
+        public void AliasedCultures_SupportedOnNetCore(string culture)
+        {
+            AssignCulture t = new AssignCulture();
+            t.BuildEngine = new MockEngine();
+            ITaskItem i = new TaskItem($"MyResource.{culture}.resx");
+            t.Files = new ITaskItem[] { i };
+            t.Execute();
+
+            Assert.Single(t.AssignedFiles);
+            Assert.Single(t.CultureNeutralAssignedFiles);
+            Assert.Equal(culture, t.AssignedFiles[0].GetMetadata("Culture"));
+            Assert.Equal($"MyResource.{culture}.resx", t.AssignedFiles[0].ItemSpec);
+            Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 7dbf9e846f2..c55eca63dda 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -464,7 +464,13 @@ public void CodeTypeFromTaskBody()
             {
                 TransientTestFile file = testEnvironment.CreateFile(fileName: "236D48CE30064161B31B55DBF088C8B2", contents: "6159BD98607A460AA4F11D2FA92E5436");
 
+                // When Source is provided and Type is not provided, Type is expected to default to Type="Class".
                 TryLoadTaskBodyAndExpectSuccess($"<Code Source=\"{file.Path}\"/>", expectedCodeType: RoslynCodeTaskFactoryCodeType.Class);
+
+                foreach (RoslynCodeTaskFactoryCodeType codeType in Enum.GetValues(typeof(RoslynCodeTaskFactoryCodeType)).Cast<RoslynCodeTaskFactoryCodeType>())
+                {
+                    TryLoadTaskBodyAndExpectSuccess($"<Code Source=\"{file.Path}\" Type=\"{codeType}\">code</Code>", expectedCodeType: codeType);
+                }
             }
         }
 
@@ -684,6 +690,112 @@ public class MyInlineTask : Microsoft.Build.Utilities.Task {{
                 expectedCodeType: RoslynCodeTaskFactoryCodeType.Method);
         }
 
+        [Fact]
+        public void CSharpFragmentSourceCodeFromFile()
+        {
+            const string sourceCodeFileContents = "int x = 0;";
+            const string expectedSourceCode = @"//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+" +
+#if NETFRAMEWORK
+@"//     Runtime Version:4.0.30319.42000
+" +
+#endif
+                                              $@"//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace InlineCode {{
+    using Microsoft.Build.Framework;
+    using Microsoft.Build.Utilities;
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.IO;
+    using System.Linq;
+    using System.Text;
+    
+    
+    public class {TaskName} : Microsoft.Build.Utilities.Task {{
+        
+        private bool _Success = true;
+        
+        public virtual bool Success {{
+            get {{
+                return _Success;
+            }}
+            set {{
+                _Success = value;
+            }}
+        }}
+        
+        public override bool Execute() {{
+{sourceCodeFileContents}
+            return Success;
+        }}
+    }}
+}}
+";
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFile file = testEnvironment.CreateFile(fileName: "CSharpFragmentSourceCodeFromFile.tmp", contents: sourceCodeFileContents);
+
+                TryLoadTaskBodyAndExpectSuccess(
+                    $"<Code Source=\"{file.Path}\" Type=\"Fragment\"/>",
+                    expectedSourceCode: expectedSourceCode,
+                    expectedCodeType: RoslynCodeTaskFactoryCodeType.Fragment);
+            }
+        }
+
+        [Fact]
+        public void CSharpMethodSourceCodeFromFile()
+        {
+            const string sourceCodeFileContents = @"public override bool Execute() { int x = 0; return true; }";
+            const string expectedSourceCode = @"//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+" +
+#if NETFRAMEWORK
+@"//     Runtime Version:4.0.30319.42000
+" +
+#endif
+                                              @$"//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace InlineCode {{
+    using Microsoft.Build.Framework;
+    using Microsoft.Build.Utilities;
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.IO;
+    using System.Linq;
+    using System.Text;
+    
+    
+    public class MyInlineTask : Microsoft.Build.Utilities.Task {{
+        
+{sourceCodeFileContents}
+    }}
+}}
+";
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFile file = testEnvironment.CreateFile(fileName: "CSharpMethodSourceCodeFromFile.tmp", contents: sourceCodeFileContents);
+
+                TryLoadTaskBodyAndExpectSuccess(
+                    $"<Code Source=\"{file.Path}\" Type=\"Method\"/>",
+                    expectedSourceCode: expectedSourceCode,
+                    expectedCodeType: RoslynCodeTaskFactoryCodeType.Method);
+            }
+        }
+
         [Fact]
         public void EmptyCodeElement()
         {
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index 61733113873..dca043b7d3c 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -4,6 +4,8 @@
 using System;
 using System.Collections.Generic;
 using System.Globalization;
+using System.Linq;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -19,7 +21,13 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal static class CultureInfoCache
     {
-        private static readonly HashSet<string> ValidCultureNames = InitializeValidCultureNames();
+        private static readonly Lazy<HashSet<string>> ValidCultureNames = new Lazy<HashSet<string>>(() => InitializeValidCultureNames());
+
+        // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing
+        // These pseudo-locales are available in versions of Windows from Vista and later.
+        // However, from Windows 10, version 1803, they are not returned when enumerating the
+        // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.
+        static readonly string[] pseudoLocales = new[] { "qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh" };
 
         static HashSet<string> InitializeValidCultureNames()
         {
@@ -35,12 +43,7 @@ static HashSet<string> InitializeValidCultureNames()
                 validCultureNames.Add(cultureName.Name);
             }
 
-            // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing
-            // These pseudo-locales are available in versions of Windows from Vista and later.
-            // However, from Windows 10, version 1803, they are not returned when enumerating the
-            // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.
-            string[] pseudoLocales = new[] { "qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh" };
-
+            // Account for pseudo-locales (see above)
             foreach (string pseudoLocale in pseudoLocales)
             {
                 validCultureNames.Add(pseudoLocale);
@@ -56,7 +59,23 @@ static HashSet<string> InitializeValidCultureNames()
         /// <returns>True if the culture is determined to be valid.</returns>
         internal static bool IsValidCultureString(string name)
         {
-            return ValidCultureNames.Contains(name);
+#if NET5_0_OR_GREATER
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                try
+                {
+                    // GetCultureInfo throws if the culture doesn't exist
+                    CultureInfo.GetCultureInfo(name, predefinedOnly: true);
+                    return true;
+                }
+                catch
+                {
+                    // Second attempt: try pseudolocales (see above)
+                    return pseudoLocales.Contains(name);
+                }
+            }
+#endif
+            return ValidCultureNames.Value.Contains(name);
         }
 
 #if !FEATURE_CULTUREINFO_GETCULTURES
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 5bd98bfbe0c..6421d98c638 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -1,4 +1,4 @@
-ï»¿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -329,6 +329,7 @@
     </Compile>
     <Compile Include="ResourceHandling\*.cs" />
     <Compile Include="GetCompatiblePlatform.cs" />
+    <Compile Include="SetRidAgnosticValueForProjects.cs" />
     <Compile Include="ResolveComReference.cs" />
     <Compile Include="BuildCacheDisposeWrapper.cs" />
     <Compile Include="DownloadFile.cs" />
@@ -966,8 +967,8 @@
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" SetTargetFramework="TargetFramework=netstandard2.0" OutputItemType="NetstandardRefAssemblies" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" SetTargetFramework="TargetFramework=netstandard2.0" OutputItemType="NetstandardRefAssemblies" />
-    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj"/>
-    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj"/>
+    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
+    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
   <ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 5096427a963..af1a6b18164 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -42,9 +42,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
         <HasSingleTargetFramework>false</HasSingleTargetFramework>
-        <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
-        <IsRidAgnostic>false</IsRidAgnostic>
-        <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>
         <!-- Extract necessary information for SetPlatform negotiation -->
         <!-- This target does not run for cpp projects. -->
         <IsVcxOrNativeProj>false</IsVcxOrNativeProj>
@@ -220,4 +218,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index fc7bfd9a865..bb900b2b147 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1,4 +1,4 @@
-<!--
+ï»¿<!--
 ***********************************************************************************************
 Microsoft.Common.CurrentVersion.targets
 
@@ -1788,7 +1788,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         BuildInParallel="$(BuildInParallel)"
         Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)"
         ContinueOnError="!$(BuildingProject)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)"
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;$(_GlobalPropertiesToRemoveFromProjectReferences)"
         Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' != 'true'"
         SkipNonexistentTargets="true">
       <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
@@ -1804,7 +1804,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Targets="GetTargetFrameworks"
         BuildInParallel="$(BuildInParallel)"
         ContinueOnError="!$(BuildingProject)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;Platform;Configuration$(_GlobalPropertiesToRemoveFromProjectReferences)"
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;Platform;Configuration;$(_GlobalPropertiesToRemoveFromProjectReferences)"
         Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' == 'true'"
         SkipNonexistentTargets="true">
       <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
@@ -1859,6 +1859,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                          Condition="'$(ReferringTargetFrameworkForProjectReferences)' == '' or
                                     ('$(EnableDynamicPlatformResolution)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' == 'true')" />
 
+    </ItemGroup>
+
+    <!-- IsRidAgnostic metadata is used to determine whether global properties such as RuntimeIdentifier and SelfContained flow to a referenced project.
+         However, for multi-targeted projects there may be a different IsRidAgnostic value for each TargetFramework.  In that case, this task selects
+         the IsRidAgnostic value for the NearestTargetFramework for the project. -->
+    <SetRidAgnosticValueForProjects Projects="@(AnnotatedProjects)">
+      <Output ItemName="UpdatedAnnotatedProjects" TaskParameter="UpdatedProjects" />
+    </SetRidAgnosticValueForProjects>
+    
+    <ItemGroup>
+      <AnnotatedProjects Remove="@(AnnotatedProjects)" />
+      <AnnotatedProjects Include="@(UpdatedAnnotatedProjects)" />
+      <UpdatedAnnotatedProjects Remove="@(UpdatedAnnotatedProjects)" />
+
       <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->
       <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.NearestTargetFramework)' != '' and '%(AnnotatedProjects.HasSingleTargetFramework)' != 'true'">
         <SetTargetFramework>TargetFramework=%(AnnotatedProjects.NearestTargetFramework)</SetTargetFramework>
@@ -1872,9 +1886,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <UndefineProperties>%(AnnotatedProjects.UndefineProperties);TargetFramework</UndefineProperties>
       </AnnotatedProjects>
 
-      <!-- If the project is RID agnostic, undefine the RuntimeIdentifier property to avoid another evaluation. -->
-      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' == 'true'">
-        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier</UndefineProperties>
+      <!-- Add RuntimeIdentifier and SelfContained to the list of global properties that should not flow to the referenced project,
+           unless the project is expecting those properties to flow. -->
+      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' != 'false'">
+        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier;SelfContained</UndefineProperties>
       </AnnotatedProjects>
 
       <!--
@@ -1907,9 +1922,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
         <HasSingleTargetFramework>true</HasSingleTargetFramework>
-        <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
-        <IsRidAgnostic>false</IsRidAgnostic>
-        <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>
         <!-- Extract necessary information for SetPlatform negotiation -->
         <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
         <Platform Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">$(Platform)</Platform>
@@ -1950,6 +1963,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>
         <TargetPlatformMonikers Condition="'$(TargetPlatformMoniker)' == ''">None</TargetPlatformMonikers>
         <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>
+
+        <!-- Determine whether a project is "RID agnostic" for each TargetFramework.  "RID agnostic" means that global properties such as SelfContained and RuntimeIdentifier should
+             not flow across project references.
+
+             Generally this value will come from the IsRidAgnostic property set by the .NET SDK.  If that's not set, then the fallback logic here will be that the project
+             is RID agnostic if it doesn't have RuntimeIdentifier or RuntimeIdentifiers properties set. -->
+        <IsRidAgnostic>$(IsRidAgnostic)</IsRidAgnostic>
+        <IsRidAgnostic Condition=" '$(IsRidAgnostic)' == '' and '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <IsRidAgnostic Condition=" '$(IsRidAgnostic)' == ''">false</IsRidAgnostic>
+
       </_TargetFrameworkInfo>
     </ItemGroup>
 
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 8bcaa32b507..d91e88e9861 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -54,6 +54,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.SetRidAgnosticValueForProjects"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Hash"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.LC"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -106,4 +107,4 @@
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index a10bf7c0784..48264892122 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -38,33 +38,36 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   -->
   <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
     <!-- Empty case is for outer builds which do not import the target files that set BuildProjectReferences -->
-    <_MainReferenceTarget Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTarget>
-    <_MainReferenceTarget Condition="'$(_MainReferenceTarget)' == ''">GetTargetPath</_MainReferenceTarget>
+    <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
+    <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
 
     <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>
-    <ProjectReferenceTargetsForBuild>$(_MainReferenceTarget);GetNativeManifest;$(_RecursiveTargetForContentCopying);GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+    <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
 
     <ProjectReferenceTargetsForCleanInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForCleanInOuterBuild)</ProjectReferenceTargetsForCleanInOuterBuild>
     <ProjectReferenceTargetsForClean>Clean;GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
 
-    <ProjectReferenceTargetsForRebuildInOuterBuild>$(ProjectReferenceTargetsForCleanInOuterBuild);$(ProjectReferenceTargetsForBuildInOuterBuild);$(ProjectReferenceTargetsForRebuildInOuterBuild)</ProjectReferenceTargetsForRebuildInOuterBuild>
     <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
 
-    <ProjectReferenceTargetsForPublish>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForPublish>
+    <!-- Publish has the same logic as Build for the main reference target except it also takes $(NoBuild) into account. -->
+    <_MainReferenceTargetForPublish Condition="'$(NoBuild)' == 'true'">GetTargetPath</_MainReferenceTargetForPublish>
+    <_MainReferenceTargetForPublish Condition="'$(NoBuild)' != 'true'">$(_MainReferenceTargetForBuild)</_MainReferenceTargetForPublish>
+    <ProjectReferenceTargetsForPublish>GetTargetFrameworks;$(_MainReferenceTargetForPublish);GetNativeManifest;GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForPublish>
+
     <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
   </PropertyGroup>
 
   <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
-    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true"/>
+    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true" />
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
 
-    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true"/>
+    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true" />
     <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
 
-    <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForRebuildInOuterBuild)' != '' " />
     <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
 
     <ProjectReferenceTargets Include="Publish" Targets="$(ProjectReferenceTargetsForPublish)" Condition=" '$(ProjectReferenceTargetsForPublish)' != '' " />
+
     <ProjectReferenceTargets Include="GetCopyToPublishDirectoryItems" Targets="$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)" Condition=" '$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)' != '' " />
   </ItemGroup>
 
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
index 68779602973..e2378ba70a3 100644
--- a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,2 +1,9 @@
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.set -> void
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.SetRidAgnosticValueForProjects() -> void
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.set -> void
+override Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Execute() -> bool
 Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.get -> bool
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
\ No newline at end of file
+Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 68779602973..176cca35d60 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,2 +1,9 @@
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.set -> void
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.SetRidAgnosticValueForProjects() -> void
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.set -> void
 Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.get -> bool
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
\ No newline at end of file
+Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
+override Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Execute() -> bool
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index e04d5d27e05..6695d3196f9 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -396,7 +396,8 @@ private void GetOutputAssemblies(List<PublishInfo> publishInfos, List<ITaskItem>
                         AssemblyIdentity identity = AssemblyIdentity.FromManagedAssembly(item.ItemSpec);
                         if (identity != null && !String.Equals(identity.Culture, "neutral", StringComparison.Ordinal))
                         {
-                            CultureInfo satelliteCulture = GetItemCulture(item);
+                            CultureInfo satelliteCulture = new CultureInfo(identity.Culture);
+                            item.SetMetadata("Culture", identity.Culture);
                             if (PublishFlags.IsSatelliteIncludedByDefault(satelliteCulture, _targetCulture, _includeAllSatellites))
                             {
                                 _satelliteAssembliesPassedAsReferences.Add(item);
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 004d2f8067d..f9fbcadfcae 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -442,7 +442,8 @@ internal static bool TryLoadTaskBody(TaskLoggingHelper log, string taskName, str
                 taskInfo.CodeType = RoslynCodeTaskFactoryCodeType.Class;
                 taskInfo.SourceCode = File.ReadAllText(sourceAttribute.Value.Trim());
             }
-            else if (typeAttribute != null)
+
+            if (typeAttribute != null)
             {
                 if (String.IsNullOrWhiteSpace(typeAttribute.Value))
                 {
@@ -747,6 +748,12 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
 
                         return false;
                     }
+
+                    if (!deleteSourceCodeFile)
+                    {
+                        // Log the location of the code file because MSBUILDLOGCODETASKFACTORYOUTPUT was set.
+                        _log.LogMessageFromResources(MessageImportance.Low, "CodeTaskFactory.FindSourceFileAt", sourceCodePath);
+                    }
                 }
 
                 // Return the assembly which is loaded into memory
diff --git a/src/Tasks/SetRidAgnosticValueForProjects.cs b/src/Tasks/SetRidAgnosticValueForProjects.cs
new file mode 100644
index 00000000000..7e45e76f163
--- /dev/null
+++ b/src/Tasks/SetRidAgnosticValueForProjects.cs
@@ -0,0 +1,65 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
+
+namespace Microsoft.Build.Tasks
+{
+    public sealed class SetRidAgnosticValueForProjects : TaskExtension
+    {
+        public ITaskItem[] Projects { get; set; } = Array.Empty<ITaskItem>();
+
+        [Output]
+        public ITaskItem[] UpdatedProjects { get; set; } = Array.Empty<ITaskItem>();
+
+        public override bool Execute()
+        {
+            UpdatedProjects = Projects
+                .Select(p =>
+                {
+                    var hasSingleTargetFrameworkString = p.GetMetadata("HasSingleTargetFramework");
+                    if (!ConversionUtilities.ValidBooleanFalse(hasSingleTargetFrameworkString))
+                    {
+                        // No change to item, it should already have a single-valued IsRidAgnostic value
+                        return p;
+                    }
+                    var updatedItem = new TaskItem(p);
+
+                    var nearestTargetFramework = p.GetMetadata("NearestTargetFramework");
+                    if (string.IsNullOrEmpty(nearestTargetFramework))
+                    {
+                        return p;
+                    }
+
+                    var targetFrameworksArray = p.GetMetadata("TargetFrameworks").Split(';');
+
+                    int targetFrameworkIndex = Array.IndexOf(targetFrameworksArray, nearestTargetFramework);
+                    if (targetFrameworkIndex < 0)
+                    {
+                        return p;
+                    }
+
+                    var isRidAgnosticArray = p.GetMetadata("IsRidAgnostic").Split(';');
+                    if (isRidAgnosticArray.Length != targetFrameworksArray.Length)
+                    {
+                        return p;
+                    }
+
+                    updatedItem.SetMetadata("IsRidAgnostic", isRidAgnosticArray[targetFrameworkIndex]);
+                    
+                    return updatedItem;
+                })
+                .ToArray();
+
+            return true;
+        }
+    }
+}
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 366b1bc4280..53d2512e201 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -71,15 +71,12 @@ private static string ResolveRuntimeExecutableName()
         /// </summary>
         public static string RunProcessAndGetOutput(string process, string parameters, out bool successfulExit, bool shellExecute = false, ITestOutputHelper outputHelper = null)
         {
-            outputHelper?.WriteLine($"{DateTime.Now.ToString("hh:mm:ss tt")}:RunProcessAndGetOutput:1");
-
             if (shellExecute)
             {
                 // we adjust the psi data manually because on net core using ProcessStartInfo.UseShellExecute throws NotImplementedException
                 AdjustForShellExecution(ref process, ref parameters);
             }
 
-            outputHelper?.WriteLine($"{DateTime.Now.ToString("hh:mm:ss tt")}:RunProcessAndGetOutput:2");
             var psi = new ProcessStartInfo(process)
             {
                 CreateNoWindow = true,
@@ -92,7 +89,6 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
             string output = string.Empty;
             int pid = -1;
 
-            outputHelper?.WriteLine($"{DateTime.Now.ToString("hh:mm:ss tt")}:RunProcessAndGetOutput:3");
             using (var p = new Process { EnableRaisingEvents = true, StartInfo = psi })
             {
                 DataReceivedEventHandler handler = delegate (object sender, DataReceivedEventArgs args)
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 2629634f436..b58f7f10881 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -862,7 +862,7 @@ private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs bui
                         _firstProjectStartedEventContext = buildEvent.BuildEventContext;
 
                         // We've never seen a project started event, so raise the build started event and save this project started event.
-                        BuildStartedEventArgs startedEvent = new BuildStartedEventArgs(_buildStartedEvent.Message, _buildStartedEvent.HelpKeyword, _buildStartedEvent.BuildEnvironment);
+                        BuildStartedEventArgs startedEvent = new BuildStartedEventArgs(_buildStartedEvent.Message, _buildStartedEvent.HelpKeyword, Traits.LogAllEnvironmentVariables ? _buildStartedEvent.BuildEnvironment : null);
                         RaiseBuildStartedEvent(sender, startedEvent);
                     }
 
