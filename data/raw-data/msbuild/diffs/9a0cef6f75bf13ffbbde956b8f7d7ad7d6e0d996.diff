diff --git a/eng/AfterSigning.targets b/eng/AfterSigning.targets
index 0bc6b1db9cd..52f5eabf4c7 100644
--- a/eng/AfterSigning.targets
+++ b/eng/AfterSigning.targets
@@ -1,12 +1,12 @@
 <Project>
     <Target Name="CopyAMD64Symbols" Condition="'$(OfficialBuild)' == 'true' AND '$(ArcadeBuildFromSource)' != 'true'" BeforeTargets="Build">
-        <Copy 
+        <Copy
             SourceFiles="$(ArtifactsBinDir)MSBuild\x64\Release\net472\MSBuild.pdb"
             DestinationFolder="$(ArtifactsSymStoreDirectory)\MSBuild\net472\amd64"
             />
-        <Copy 
+        <Copy
             SourceFiles="$(ArtifactsBinDir)MSBuildTaskHost\x64\Release\net35\MSBuildTaskHost.pdb"
             DestinationFolder="$(ArtifactsSymStoreDirectory)\MSBuildTaskHost\net35\amd64"
             />
     </Target>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
index 57441a1ae20..317fb32847a 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
@@ -77,7 +77,7 @@ public void ProjectWhitespaceFormatting()
             // Note that there are two spaces after the <ItemGroup> tag on the second line
             string content = ObjectModelHelpers.CleanupFileContents(@"
 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
-  <ItemGroup>  
+  <ItemGroup>
     <ProjectReference Include=`..\CLREXE\CLREXE.vcxproj`>
 <Project>{3699f81b-2d03-46c5-abd7-e88a4c946f28}</Project>
     </ProjectReference>
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index a67068c7fe8..7c4ea152dea 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -56,8 +56,8 @@ public void ParseSolution_VC()
             });
         }
         /// <summary>
-        /// Test that a project with the C++ project guid and an arbitrary extension is seen as valid -- 
-        /// we assume that all C++ projects except .vcproj are MSBuild format. 
+        /// Test that a project with the C++ project guid and an arbitrary extension is seen as valid --
+        /// we assume that all C++ projects except .vcproj are MSBuild format.
         /// </summary>
         [Fact]
         public void ParseSolution_VC2()
@@ -238,7 +238,7 @@ public void VersionTooLow()
             });
         }
         /// <summary>
-        /// Test to parse a very basic .sln file to validate that description property in a solution file 
+        /// Test to parse a very basic .sln file to validate that description property in a solution file
         /// is properly handled.
         /// </summary>
         [Fact]
@@ -496,8 +496,8 @@ public void SharedProjects()
         }
 
         /// <summary>
-        /// Tests situation where there's a nonexistent project listed in the solution folders.  We should 
-        /// error with a useful message. 
+        /// Tests situation where there's a nonexistent project listed in the solution folders.  We should
+        /// error with a useful message.
         /// </summary>
         [Fact]
         public void MissingNestedProject()
@@ -840,7 +840,7 @@ public void ParseInvalidSolutionConfigurations3()
             });
         }
         /// <summary>
-        /// Make sure the project configurations in solution configurations get parsed correctly 
+        /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a simple mixed C#/VC solution
         /// </summary>
         [Fact]
@@ -938,7 +938,7 @@ public void ParseProjectConfigurationsInSolutionConfigurations1()
         }
 
         /// <summary>
-        /// Make sure the project configurations in solution configurations get parsed correctly 
+        /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a more tricky solution
         /// </summary>
         [Fact]
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
index a3e8c701e6f..37537057d34 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
@@ -456,7 +456,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_UseInBatching()
 
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionMetadataCondition()
@@ -478,7 +478,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionM
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_UnquotedBuiltInProhibitedOnItemDefinitionMetadataCondition()
@@ -500,7 +500,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_UnquotedBuiltInProhibitedOnItemDef
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionCondition()
@@ -522,7 +522,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionC
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionGroupCondition()
@@ -544,7 +544,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionG
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDefinitionMetadataCondition()
@@ -566,7 +566,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDe
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDefinitionCondition()
@@ -588,7 +588,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDe
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDefinitionGroupCondition()
@@ -610,7 +610,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDe
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_UnquotedQualifiedBuiltInProhibitedOnItemDefinitionCondition()
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
index e8662ee46ec..690150d1df6 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
@@ -120,22 +120,22 @@ public class TestCollectionGroup : IDisposable
                             <When Condition=""'$(Configuration)'=='Foo'"">
                               <PropertyGroup>
                                 <p>vFoo</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                             </When>
                             <When Condition='false'>
                               <PropertyGroup>
                                 <p>vFalse</p>
-                              </PropertyGroup> 
-                            </When>      
+                              </PropertyGroup>
+                            </When>
                             <When Condition='true'>
                               <PropertyGroup>
                                 <p>vTrue</p>
-                              </PropertyGroup> 
-                            </When>      
+                              </PropertyGroup>
+                            </When>
                             <Otherwise>
                               <PropertyGroup>
                                 <p>vOtherwise</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                             </Otherwise>
                         </Choose>
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
index 075a0af11ec..6cd6b26cf96 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
     /// <summary>
     /// The C# does not really provide a easy way to efficiently implement inheritance in cases like this
     /// for abstract classes or interface, when there is a hierarchy, it is not way to share the implementation.
-    /// Like if one have IFoo and IBar : IFoo (or as we do abstractFoo, abstractBar:abstractFoo) 
+    /// Like if one have IFoo and IBar : IFoo (or as we do abstractFoo, abstractBar:abstractFoo)
     /// we can provide implementation for IFoo, but we can not use that for implementations for IBar.
     /// Since no multiple inheritance or other suitable mechanism for code share across classes is supported by C#,
     /// Instead IBar implementation should fully implement both IFoo and IBar interfaces.
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
index c6378a0ece2..11c0b2b2ff0 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
@@ -33,7 +33,7 @@ public override Project CreateLinkedObject(IImportHolder holder)
 
         // all bellow are very inefficient,
         // in reality we do cache these collections  until invalidated and use lazy access for dictionaries.
-        // TODO: Might bring that infrastructure here as well ... 
+        // TODO: Might bring that infrastructure here as well ...
         public IDictionary<string, string> GlobalProperties => this.Source.GlobalProperties;
         public ICollection<string> ItemTypes => this.Source.ItemTypes;
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
index 607e9ba8586..c15ef79fb8f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
@@ -21,12 +21,12 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
     For the ExternalProjectsProvider mock infrastructure we'll try to use very similar model as in the actual implementation in VS.
 
     Typical flow for "linked object" of type "Foo"
-    [ ---  Client Collection                                    ]                           [ Server collection (can be different process) ] 
+    [ ---  Client Collection                                    ]                           [ Server collection (can be different process) ]
     (Foo) localView <=> (FooLink) link <=> FooLinkRemoter (Proxy) <=~connection mechanism~=> FooLinkRemoter(stub) <=> (Real object)
-    
+
     FooLinkRemoter would be whatever ExternalProviders see useful to provide FooLink implementation and is compatable with connection mechanism
     it might be completely different interface since some link types would be either inefficient or impossible to serialize for example and pass cross process.
-    
+
     Here we can cheat a little bit, since we run both Client and Server collection in the same process so we can ignore connection mechanism (typically some
     form of serialization/deserialization) and just give the "client" link implementation the same Remoter object we create on the "server"
 
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index 8bf9bf686bb..a2d52c2df63 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -97,7 +97,7 @@ public void GoodTaskNameButNotInInfo()
         }
         /// <summary>
         /// Make sure we get an internal error when we call the initialize factory on the public method.
-        /// This is done because we cannot properly initialize the task factory using the public interface and keep 
+        /// This is done because we cannot properly initialize the task factory using the public interface and keep
         /// backwards compatibility with orcas and whidbey.
         /// </summary>
         [Fact]
@@ -111,7 +111,7 @@ public void CallPublicInitializeFactory()
         }
         /// <summary>
         /// Make sure we get an internal error when we call the ITaskFactory2 version of initialize factory.
-        /// This is done because we cannot properly initialize the task factory using the public interface and keep 
+        /// This is done because we cannot properly initialize the task factory using the public interface and keep
         /// backwards compatibility with orcas and whidbey.
         /// </summary>
         [Fact]
@@ -166,8 +166,8 @@ public void CreatableByTaskFactoryNullTaskName()
             });
         }
         /// <summary>
-        /// Make sure that when an explicitly matching identity is specified (e.g. the identity is non-empty), 
-        /// it still counts as correct.  
+        /// Make sure that when an explicitly matching identity is specified (e.g. the identity is non-empty),
+        /// it still counts as correct.
         /// </summary>
         [Fact]
         public void CreatableByTaskFactoryMatchingIdentity()
@@ -186,7 +186,7 @@ public void CreatableByTaskFactoryMatchingIdentity()
         }
 
         /// <summary>
-        /// Verify that if the task identity parameters don't match the factory identity, TaskNameCreatableByFactory 
+        /// Verify that if the task identity parameters don't match the factory identity, TaskNameCreatableByFactory
         /// returns false.
         /// </summary>
         [Fact]
@@ -263,7 +263,7 @@ public void VerifyGoodTaskInstantiation()
         }
 
         /// <summary>
-        /// Verify a good task that does not use the task host can be created when passed "don't care" 
+        /// Verify a good task that does not use the task host can be created when passed "don't care"
         /// for the task invocation task host parameters.
         /// </summary>
         [Fact]
@@ -294,8 +294,8 @@ public void VerifyMatchingTaskParametersDontLaunchTaskHost1()
         }
 
         /// <summary>
-        /// Verify a good task that does not use the task host can be created when passed task host 
-        /// parameters that explicitly match the current process. 
+        /// Verify a good task that does not use the task host can be created when passed task host
+        /// parameters that explicitly match the current process.
         /// </summary>
         [Fact]
         public void VerifyMatchingTaskParametersDontLaunchTaskHost2()
@@ -325,7 +325,7 @@ public void VerifyMatchingTaskParametersDontLaunchTaskHost2()
         }
 
         /// <summary>
-        /// Verify a good task that does not use the task host can be created when passed "don't care" 
+        /// Verify a good task that does not use the task host can be created when passed "don't care"
         /// for the task invocation task host parameters.
         /// </summary>
         [Fact]
@@ -358,8 +358,8 @@ public void VerifyMatchingUsingTaskParametersDontLaunchTaskHost1()
         }
 
         /// <summary>
-        /// Verify a good task that does not use the task host can be created when passed task host 
-        /// parameters that explicitly match the current process. 
+        /// Verify a good task that does not use the task host can be created when passed task host
+        /// parameters that explicitly match the current process.
         /// </summary>
         [Fact]
         public void VerifyMatchingUsingTaskParametersDontLaunchTaskHost2()
@@ -391,8 +391,8 @@ public void VerifyMatchingUsingTaskParametersDontLaunchTaskHost2()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when passed task host 
-        /// parameters that explicitly do not match the current process. 
+        /// Verify a good task that uses the task host can be created when passed task host
+        /// parameters that explicitly do not match the current process.
         /// </summary>
         [Fact]
         public void VerifyMatchingParametersDontLaunchTaskHost()
@@ -426,8 +426,8 @@ public void VerifyMatchingParametersDontLaunchTaskHost()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when passed task host 
-        /// parameters that explicitly do not match the current process. 
+        /// Verify a good task that uses the task host can be created when passed task host
+        /// parameters that explicitly do not match the current process.
         /// </summary>
         [Fact]
         public void VerifyNonmatchingUsingTaskParametersLaunchTaskHost()
@@ -459,8 +459,8 @@ public void VerifyNonmatchingUsingTaskParametersLaunchTaskHost()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when passed task host 
-        /// parameters that explicitly do not match the current process. 
+        /// Verify a good task that uses the task host can be created when passed task host
+        /// parameters that explicitly do not match the current process.
         /// </summary>
         [Fact]
         public void VerifyNonmatchingTaskParametersLaunchTaskHost()
@@ -490,8 +490,8 @@ public void VerifyNonmatchingTaskParametersLaunchTaskHost()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when passed task host 
-        /// parameters that explicitly do not match the current process. 
+        /// Verify a good task that uses the task host can be created when passed task host
+        /// parameters that explicitly do not match the current process.
         /// </summary>
         [Fact]
         public void VerifyNonmatchingParametersLaunchTaskHost()
@@ -525,8 +525,8 @@ public void VerifyNonmatchingParametersLaunchTaskHost()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when the task factory is 
-        /// explicitly instructed to launch the task host. 
+        /// Verify a good task that uses the task host can be created when the task factory is
+        /// explicitly instructed to launch the task host.
         /// </summary>
         [Fact]
         public void VerifyExplicitlyLaunchTaskHost()
@@ -554,8 +554,8 @@ public void VerifyExplicitlyLaunchTaskHost()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when the task factory is 
-        /// explicitly instructed to launch the task host. 
+        /// Verify a good task that uses the task host can be created when the task factory is
+        /// explicitly instructed to launch the task host.
         /// </summary>
         [Fact]
         public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch1()
@@ -587,8 +587,8 @@ public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch1()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when the task factory is 
-        /// explicitly instructed to launch the task host. 
+        /// Verify a good task that uses the task host can be created when the task factory is
+        /// explicitly instructed to launch the task host.
         /// </summary>
         [Fact]
         public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch2()
@@ -620,8 +620,8 @@ public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch2()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when the task factory is 
-        /// explicitly instructed to launch the task host. 
+        /// Verify a good task that uses the task host can be created when the task factory is
+        /// explicitly instructed to launch the task host.
         /// </summary>
         [Fact]
         public void VerifySameFactoryCanGenerateDifferentTaskInstances()
@@ -677,7 +677,7 @@ public void VerifySameFactoryCanGenerateDifferentTaskInstances()
         }
 
         /// <summary>
-        /// Abstract out the creation of the new AssemblyTaskFactory with default task, and 
+        /// Abstract out the creation of the new AssemblyTaskFactory with default task, and
         /// with some basic validation.
         /// </summary>
         private void SetupTaskFactory(IDictionary<string, string> factoryParameters, bool explicitlyLaunchTaskHost)
diff --git a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
index 170ab5deb73..2a2e8822ba1 100644
--- a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
@@ -56,7 +56,7 @@ public void TestConsumeNullBuildEvent()
             });
         }
         /// <summary>
-        /// Verify consume properly packages up the message event into a packet and send it to the 
+        /// Verify consume properly packages up the message event into a packet and send it to the
         /// transport delegate
         /// </summary>
         [Fact]
@@ -145,7 +145,7 @@ public void TestShutDown()
 
         /// <summary>
         /// Create a method which will be a fake method to process a packet.
-        /// This needs to be done because using an anonymous method does not work. 
+        /// This needs to be done because using an anonymous method does not work.
         /// Using an anonymous method does not work because when the delegate is created
         /// it seems that a field is created which creates a strong reference
         /// between the delegate and the class it was created in. This means the delegate is not
diff --git a/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs b/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
index 7ac75e98903..da450fb9228 100644
--- a/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
@@ -46,7 +46,7 @@ public void GetandSetLoggerParameters()
         }
 
         /// <summary>
-        /// Verify the correct exception is thrown when the logger is initialized with a null 
+        /// Verify the correct exception is thrown when the logger is initialized with a null
         /// event source.
         /// </summary>
         [Fact]
@@ -59,7 +59,7 @@ public void InitializeWithNullEventSourceILogger()
             });
         }
         /// <summary>
-        /// Verify the correct exception is thrown when the logger is initialized with a null 
+        /// Verify the correct exception is thrown when the logger is initialized with a null
         /// event source.
         /// </summary>
         [Fact]
@@ -123,7 +123,7 @@ public void RaiseEventWithNoBuildEventRedirector()
 
         /// <summary>
         /// Create a new forwarding logger, event redirector, and event source.
-        /// The returned event source can then have and event raised on it and it can 
+        /// The returned event source can then have and event raised on it and it can
         /// check to see if the event raised matches the one we were expecting.
         /// </summary>
         /// <param name="buildEventToCheck">A build event we are expecting to be forwarded by the forwarding logger</param>
@@ -139,8 +139,8 @@ private static EventSourceSink AttachForwardingLoggerAndRedirector(BuildEventArg
         }
 
         /// <summary>
-        /// An event redirector which takes in an expected event 
-        /// and when the forwarding logger forwards and event 
+        /// An event redirector which takes in an expected event
+        /// and when the forwarding logger forwards and event
         /// we check to see if the events match. This allows
         /// us to check to see if the forwarding logger is
         /// sending us the events we send in.
@@ -150,8 +150,8 @@ private sealed class TestEventRedirector : IEventRedirector
             #region Data
 
             /// <summary>
-            /// Event we expect to see in the ForwardEvent method. 
-            /// This helps us verify that a logger is correctly forwarding 
+            /// Event we expect to see in the ForwardEvent method.
+            /// This helps us verify that a logger is correctly forwarding
             /// an event.
             /// </summary>
             private BuildEventArgs _expectedEvent;
diff --git a/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
index 62f2cef2033..d36c7ee0667 100644
--- a/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
@@ -28,7 +28,7 @@ public void TestConstructorNegativeLoggerId()
             });
         }
         /// <summary>
-        /// Verify the correct exception is thrown when the logger is initialized with a null 
+        /// Verify the correct exception is thrown when the logger is initialized with a null
         /// event source.
         /// </summary>
         [Fact]
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index 9c1ef800dc6..2d1a262034a 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -31,7 +31,7 @@ public void PropertyGroup()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -179,7 +179,7 @@ public void PropertyGroupWithConditionOnGroup()
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup Condition='false'> 
+                <PropertyGroup Condition='false'>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -194,7 +194,7 @@ public void PropertyGroupWithConditionOnGroup()
             p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup Condition='true'> 
+                <PropertyGroup Condition='true'>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -230,7 +230,7 @@ public void ItemGroup()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -274,7 +274,7 @@ public void ItemKeepDuplicatesEmptySameAsTrue()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i1 Include='a1' KeepDuplicates='' />
                 </ItemGroup>
@@ -294,7 +294,7 @@ public void ItemKeepDuplicatesFalse()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i1 Include='a1' KeepDuplicates='false' />
                 </ItemGroup>
@@ -314,7 +314,7 @@ public void ItemKeepDuplicatesAsCondition()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i1 Include='a1' KeepDuplicates="" '$(Keep)' == 'true' "" />
                 </ItemGroup>
@@ -334,9 +334,9 @@ public void ItemKeepDuplicatesFalseKeepsExistingDuplicates()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
+                    <i1 Include='a1'/>
                     <i1 Include='a1'/>
-                    <i1 Include='a1'/>              
                     <i1 Include='a1' KeepDuplicates='false' />
                 </ItemGroup>
             </Target>
@@ -355,9 +355,9 @@ public void ItemKeepDuplicatesFalseDuringCopyEliminatesDuplicates()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
+                    <i1 Include='a1'/>
                     <i1 Include='a1'/>
-                    <i1 Include='a1'/>              
                     <i2 Include='@(i1)' KeepDuplicates='false' />
                 </ItemGroup>
             </Target>
@@ -379,8 +379,8 @@ public void ItemKeepDuplicatesFalseWithMetadata()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                     </i1>
                     <i1 Include='a2' KeepDuplicates='false' />
@@ -404,8 +404,8 @@ public void ItemKeepMetadataEmptySameAsKeepAll()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                     </i1>
                     <i2 Include='@(i1)' KeepMetadata='' />
@@ -426,8 +426,8 @@ public void ItemKeepMetadata()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -453,8 +453,8 @@ public void ItemKeepMetadataNotExistent()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -479,8 +479,8 @@ public void ItemKeepMetadataList()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -505,8 +505,8 @@ public void ItemKeepMetadataListExpansion()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -534,8 +534,8 @@ public void ItemRemoveMetadataEmptySameAsKeepAll()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                     </i1>
                     <i2 Include='@(i1)' RemoveMetadata='' />
@@ -556,8 +556,8 @@ public void ItemRemoveMetadata()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -582,8 +582,8 @@ public void ItemRemoveMetadataList()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -608,8 +608,8 @@ public void ItemRemoveMetadataListExpansion()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -639,8 +639,8 @@ public void ItemKeepMetadataAndRemoveMetadataMutuallyExclusive()
                 string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -663,7 +663,7 @@ public void ItemGroupWithPropertyExpandingToNothing()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='$(xxx)'/>
                 </ItemGroup>
             </Target>
@@ -709,7 +709,7 @@ public void ItemGroupTrims()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='  $(p0)  '/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -782,7 +782,7 @@ public void ItemGroupWithTransform()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a.cpp'/>
                     <i2 Include=""@(i1->'%(filename).obj')""/>
                 </ItemGroup>
@@ -804,7 +804,7 @@ public void ItemGroupWithTransformInMetadataValue()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a.cpp'/>
                     <i2 Include='@(i1)'>
                        <m>@(i1->'%(filename).obj')</m>
@@ -827,7 +827,7 @@ public void ItemGroupWithExclude()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i2 Include='a1;@(i1);b1;b2' Exclude='@(i1);b1'/>
                 </ItemGroup>
@@ -849,7 +849,7 @@ public void ItemGroupWithMetadataInExclude()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>a1</m>
                     </i1>
@@ -876,7 +876,7 @@ public void ItemGroupWithConditionOnGroup()
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup Condition='false'> 
+                <ItemGroup Condition='false'>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -891,7 +891,7 @@ public void ItemGroupWithConditionOnGroup()
             p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup Condition='true'> 
+                <ItemGroup Condition='true'>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -932,7 +932,7 @@ public void PropertyGroupWithExternalPropertyReferences()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>$(p0)</p1>
                 </PropertyGroup>
             </Target>
@@ -955,7 +955,7 @@ public void ItemGroupWithPropertyReferences()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='$(p0)'/>
                     <i2 Include='a2'/>
                 </ItemGroup>
@@ -978,7 +978,7 @@ public void ItemGroupWithMetadataReferences()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>m1</m>
                     </i1>
@@ -1011,7 +1011,7 @@ public void ItemGroupWithMetadataReferencesOnMetadataConditions()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>m1</m>
                     </i1>
@@ -1070,7 +1070,7 @@ public void ItemGroupWithExternalMetadataReferences()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='b1'>
                         <m>%(i0.m)</m>
                     </i1>
@@ -1103,7 +1103,7 @@ public void PropertyGroupWithCumulativePropertyReferences()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>v1</p1>
                     <p2>#$(p1)#</p2>
                     <p1>v2</p1>
@@ -1155,7 +1155,7 @@ public void PropertyGroupWithMetadataReferencesOnProperty()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1 Condition=""'%(i0.n)' != n3"">%(i0.n)</p1>
                 </PropertyGroup>
             </Target></Project>");
@@ -1199,7 +1199,7 @@ public void ItemsCanReferencePropertiesInSameTarget()
                     <PropertyGroup>
                         <p0>v0</p0>
                     </PropertyGroup>
-                    <ItemGroup> 
+                    <ItemGroup>
                         <i1 Include='$(p0)'/>
                     </ItemGroup>
                     <Message Text='[@(i1)]'/>
@@ -1306,7 +1306,7 @@ public void PropertiesVisibleToSubsequentTarget()
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                   <Target Name='t2' DependsOnTargets='t'>
-                    <Message Text='[$(p)]'/>                    
+                    <Message Text='[$(p)]'/>
                   </Target>
                   <Target Name='t'>
                     <PropertyGroup>
@@ -1346,7 +1346,7 @@ public void ItemsVisibleToSubsequentTarget()
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                   <Target Name='t2' DependsOnTargets='t'>
-                    <Message Text='[@(i)]'/>                    
+                    <Message Text='[@(i)]'/>
                   </Target>
                   <Target Name='t'>
                     <ItemGroup>
@@ -1369,13 +1369,13 @@ public void ItemsNotVisibleToParallelTargetBatches()
                   <ItemGroup>
                     <i Include='1.in'><output>1.out</output></i>
                     <i Include='2.in'><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name='t' Inputs='%(i.Identity)' Outputs='%(i.output)'>
                     <Message Text='start:[@(i)]'/>
                     <ItemGroup>
                       <j Include='%(i.identity)'/>
                     </ItemGroup>
-                    <Message Text='end:[@(j)]'/>                    
+                    <Message Text='end:[@(j)]'/>
                 </Target>
                 </Project>
             "))));
@@ -1556,7 +1556,7 @@ public void IncludeNoOp()
                 string content = ObjectModelHelpers.CleanupFileContents(
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include=''/>
                 </ItemGroup>
             </Target></Project>");
@@ -1570,7 +1570,7 @@ public void RemoveNoOp()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Remove='a1'/>
                 </ItemGroup>
             </Target></Project>");
@@ -1588,7 +1588,7 @@ public void RemoveItemInTarget()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
+                    <i1 Include='a1'/>
                     <i1 Remove='a1'/>
                 </ItemGroup>
             </Target></Project>");
@@ -1613,7 +1613,7 @@ public void RemoveOfItemAddedInTargetByParallelTargetBatchDoesNothing()
                     <!-- just to cause two target batches -->
                     <i Include='1.in'><output>1.out</output></i>
                     <i Include='2.in'><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name='t' Inputs='%(i.Identity)' Outputs='%(i.output)'>
                     <ItemGroup>
                       <j Include='a' Condition=""'%(i.Identity)'=='1.in'""/>
@@ -1650,7 +1650,7 @@ public void RemoveItemInTargetWithTransform()
             <Target Name='t'>
                 <ItemGroup>
                     <i0 Include='a.cpp;b.cpp'/>
-                    <i1 Include='a.obj;b.obj'/> 
+                    <i1 Include='a.obj;b.obj'/>
                     <i1 Remove=""@(i0->'%(filename).obj')""/>
                 </ItemGroup>
             </Target></Project>");
@@ -1668,8 +1668,8 @@ public void RemoveWithMultipleIncludes()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
-                    <i1 Include='a2'/> 
+                    <i1 Include='a1'/>
+                    <i1 Include='a2'/>
                     <i1 Remove='a1;a2'/>
                 </ItemGroup>
             </Target></Project>");
@@ -1687,8 +1687,8 @@ public void RemoveAllItemsInList()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
-                    <i1 Include='a2'/> 
+                    <i1 Include='a1'/>
+                    <i1 Include='a2'/>
                     <i1 Remove='@(i1)'/>
                 </ItemGroup>
             </Target></Project>");
@@ -2204,7 +2204,7 @@ public void RegressPCHBug()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                   <!-- squint and pretend i0 is 'CppCompile' and 'm' is 'ObjectFile' -->
                   <Link Include=""A_PCH""/>
                   <Link Include=""@(i0->'%(m).obj')"" Condition=""'%(i0.m)' == 'm1'""/>
@@ -2336,13 +2336,13 @@ public void RemovesOfPersistedItemsAreReversed3()
                   <ItemGroup>
                     <i0 Include='a1'>
                       <m>m1</m>
-                    </i0> 
+                    </i0>
                   </ItemGroup>
                   <Target Name='t'>
                     <ItemGroup>
                       <i0 Include='a1'>
                         <m>m2</m>
-                      </i0> 
+                      </i0>
                       <i0 Remove='a1'/>
                     </ItemGroup>
                     <Message Text='[%(i0.m)]'/>
@@ -2409,13 +2409,13 @@ public void RemovesOfItemsOnlyWithMetadataValue()
                   <ItemGroup>
                     <i0 Include='a1'>
                       <m>m1</m>
-                    </i0> 
+                    </i0>
                   </ItemGroup>
                   <Target Name='t'>
                     <ItemGroup>
                       <i0 Include='a1'>
                         <m>m2</m>
-                      </i0> 
+                      </i0>
                       <i0 Remove='a1' Condition=""'%(i0.m)' == 'm1'""/>
                     </ItemGroup>
                     <Message Text='[%(i0.m)]'/>
@@ -2497,13 +2497,13 @@ public void RemovesNotVisibleToParallelTargetBatches()
                   <ItemGroup>
                     <i Include='1.in'><output>1.out</output></i>
                     <i Include='2.in'><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name='t' Inputs='%(i.Identity)' Outputs='%(i.output)'>
                     <Message Text='start:[@(i)]'/>
                     <ItemGroup>
                       <i Remove='1.in;2.in'/>
                     </ItemGroup>
-                    <Message Text='end:[@(i)]'/>                    
+                    <Message Text='end:[@(i)]'/>
                 </Target>
                 </Project>
             "))));
@@ -2522,13 +2522,13 @@ public void RemovesNotVisibleToParallelTargetBatches2()
                     <i Include='1.in'><output>1.out</output></i>
                     <i Include='2.in'><output>2.out</output></i>
                     <j Include='j1'/>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name='t' Inputs='%(i.Identity)' Outputs='%(i.output)'>
                     <Message Text='start:[@(j)]'/>
                     <ItemGroup>
                       <j Remove='@(j)'/>
                     </ItemGroup>
-                    <Message Text='end:[@(j)]'/>                    
+                    <Message Text='end:[@(j)]'/>
                 </Target>
                 </Project>
             "))));
@@ -2758,7 +2758,7 @@ public void ModifyNoOp()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1/>
                 </ItemGroup>
             </Target></Project>");
@@ -2776,7 +2776,7 @@ public void ModifyItemInTarget()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
                     <i1>
@@ -2831,7 +2831,7 @@ public void ModifyItemInTargetLastMetadataWins()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
                     <i1>
@@ -2880,10 +2880,10 @@ public void ModifyItemInTargetWithCondition()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1 Condition=""'%(i1.m)'=='m2'"">
@@ -2910,10 +2910,10 @@ public void ModifyItemInTargetWithConditionOnMetadata()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1>
@@ -2959,10 +2959,10 @@ public void ModifyItemInTargetWithConditionWithoutItemTypeOnMetadataInCondition(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1 Condition=""'%(m)'=='m2'"">
@@ -2990,10 +2990,10 @@ public void ModifyItemInTargetWithConditionOnMetadataWithoutItemTypeOnMetadataIn
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1>
@@ -3119,7 +3119,7 @@ public void ModifiesOfPersistedItemsAreReversed1()
                     <ItemGroup>
                       <i0>
                         <m>m1</m>
-                      </i0> 
+                      </i0>
                     </ItemGroup>
                   </Target>
                   <Target Name='t2'>
@@ -3163,7 +3163,7 @@ public void ModifiesOfPersistedItemsAreReversed2()
                       </i1>
                       <i1>
                         <n>n1</n>
-                      </i1> 
+                      </i1>
                     </ItemGroup>
                   </Target>
                   <Target Name='t2'>
@@ -3391,7 +3391,7 @@ public void OutputPropertiesInTargetBatchesCreateItem()
                     <!-- just to cause two target batches -->
                     <i Include='1.in'><output>1.out</output></i>
                     <i Include='2.in'><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name='t' Inputs='%(i.Identity)' Outputs='%(i.output)'>
                     <Message Text='start:[$(p)]'/>
                     <CreateProperty Value='$(p)--%(i.Identity)'>
@@ -3448,7 +3448,7 @@ public void PhoenixBatchingIssue()
                         <ObjectFile>def.obj</ObjectFile>
                     </CppCompile>
                 </ItemGroup>
-                
+
                 <Target Name='t'>
                     <ItemGroup>
                         <CppCompile>
@@ -3524,7 +3524,7 @@ public void ModifyItemPreviouslyModified()
                       </x>
                       <x>
                         <m1>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text='[%(x.m1)]'/>
                   </Target>
@@ -3554,7 +3554,7 @@ public void ModifyItemPreviouslyModified2()
                     <ItemGroup>
                       <x>
                         <m1>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text='[%(x.m1)]'/>
                   </Target>
diff --git a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
index becd57ad8dc..9ee0264517d 100644
--- a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
@@ -95,7 +95,7 @@ public void AddsAreCombinedWithPopulates()
             // Start a target
             Lookup.Scope enteredScope = lookup.EnterScope("x");
 
-            // We see the one item 
+            // We see the one item
             Assert.Equal("a1", lookup.GetItems("i1").First().EvaluatedInclude);
             Assert.Single(lookup.GetItems("i1"));
 
@@ -163,7 +163,7 @@ public void AddsWithDuplicateRemovalItemSpecsOnly()
             ProjectItemInstance[] newItems = new ProjectItemInstance[]
             {
                 new ProjectItemInstance(project, "i1", "a1", project.FullPath), // Should not get added
-                new ProjectItemInstance(project, "i1", "a2", project.FullPath), // Should get added               
+                new ProjectItemInstance(project, "i1", "a2", project.FullPath), // Should get added
             };
 
             // Perform the addition
@@ -213,9 +213,9 @@ public void AddsWithDuplicateRemovalWithMetadata()
             ProjectItemInstance[] newItems = new ProjectItemInstance[]
             {
                 new ProjectItemInstance(project, "i1", "a1", project.FullPath), // Should get added
-                new ProjectItemInstance(project, "i1", "a2", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m1") }, project.FullPath), // Should get added               
-                new ProjectItemInstance(project, "i1", "a1", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m1") }, project.FullPath), // Should not get added               
-                new ProjectItemInstance(project, "i1", "a1", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m3") }, project.FullPath), // Should get added               
+                new ProjectItemInstance(project, "i1", "a2", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m1") }, project.FullPath), // Should get added
+                new ProjectItemInstance(project, "i1", "a1", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m1") }, project.FullPath), // Should not get added
+                new ProjectItemInstance(project, "i1", "a1", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m3") }, project.FullPath), // Should get added
             };
 
             // Perform the addition
@@ -822,7 +822,7 @@ public void ModifyItemModifiedInPreviousScope()
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -863,7 +863,7 @@ public void ModifyItemTwiceInSameScope1()
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -929,7 +929,7 @@ public void ModifyItemTwiceInSameScope2()
             Assert.Equal("n2", foundGroup.First().GetMetadataValue("n"));
             Assert.Equal("o1", foundGroup.First().GetMetadataValue("o"));
 
-            // Make a modification to the item to be n=n3 
+            // Make a modification to the item to be n=n3
             newMetadata = new Lookup.MetadataModifications(keepOnlySpecified: false);
             newMetadata.Add("n", "n3");
             lookup.ModifyItems("i1", group, newMetadata);
@@ -1026,7 +1026,7 @@ public void ModifyItemPreviouslyModifiedAndGottenThroughGetItem()
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -1074,7 +1074,7 @@ public void ModifyItemPreviouslyModifiedAndGottenThroughGetItem()
         public void ModifyItemInProjectPreviouslyModifiedAndGottenThroughGetItem()
         {
             ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
-            // Create some project state with an item with m=m1 and n=n1 
+            // Create some project state with an item with m=m1 and n=n1
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
@@ -1130,7 +1130,7 @@ public void RemoveItemPreviouslyModifiedAndGottenThroughGetItem()
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -1164,7 +1164,7 @@ public void RemoveItemPreviouslyModifiedAndGottenThroughGetItem()
         public void RemoveItemFromProjectPreviouslyModifiedAndGottenThroughGetItem()
         {
             ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
-            // Create some project state with an item with m=m1 and n=n1 
+            // Create some project state with an item with m=m1 and n=n1
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
@@ -1257,7 +1257,7 @@ public void ModifiedProperty()
 
             Lookup.Scope enteredScope2 = lookup.EnterScope("x");
 
-            // Change the value again in the new scope 
+            // Change the value again in the new scope
             lookup.SetProperty(ProjectPropertyInstance.Create("p1", "v3"));
 
             // Lookup is updated, but not the original item group
@@ -1266,7 +1266,7 @@ public void ModifiedProperty()
 
             Lookup.Scope enteredScope3 = lookup.EnterScope("x");
 
-            // Change the value again in the new scope 
+            // Change the value again in the new scope
             lookup.SetProperty(ProjectPropertyInstance.Create("p1", "v4"));
 
             Assert.Equal("v4", lookup.GetProperty("p1").EvaluatedValue);
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index 9b0a1eae9bb..003bf735988 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -171,7 +171,7 @@ public void OutputItemsAreTaggedWithProjectFileAndTargetName()
         }
 
         /// <summary>
-        /// Ensures that it is possible to call the MSBuild task with an empty Projects parameter, and it 
+        /// Ensures that it is possible to call the MSBuild task with an empty Projects parameter, and it
         /// shouldn't error, and it shouldn't try to build itself.
         /// </summary>
         [Fact]
@@ -481,7 +481,7 @@ static void Main(string[] args)
             // -------------------------------------------------------
             // TeamBuild.proj
             // -------------------------------------------------------
-            // Attempts to build the above ConsoleApplication1.csproj by calling the MSBuild task, 
+            // Attempts to build the above ConsoleApplication1.csproj by calling the MSBuild task,
             // and overriding the OutDir property.  However, the value being passed into OutDir
             // is coming from another property which is produced by CreateProperty and has
             // some special characters in it.
@@ -490,16 +490,16 @@ static void Main(string[] args)
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <Target Name=`Build`>
-                    
+
                         <CreateProperty Value=`$(MSBuildProjectDirectory)\binaries\`>
                             <Output PropertyName=`MasterOutDir` TaskParameter=`Value`/>
                         </CreateProperty>
-                        
+
                         <MSBuild Projects=`ConsoleApplication1\ConsoleApplication1.csproj`
                                  Properties=`OutDir=$(MasterOutDir)`
                                  Targets=`Rebuild`/>
                     </Target>
-                    
+
                 </Project>
                 ");
 
@@ -521,7 +521,7 @@ public void DifferentGlobalPropertiesWithDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -590,7 +590,7 @@ public void DifferentGlobalPropertiesWithoutDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -665,7 +665,7 @@ public void VariousPropertiesToMSBuildTask()
                           <UndefineProperties>g;h;</UndefineProperties>
                         </PR>
                       </ItemGroup>
-                      <Target Name='a'> 
+                      <Target Name='a'>
                         <MSBuild Projects='@(PR)' Properties='c=c;d=d;' RemoveProperties='i;c;' Targets='b'/>
                       </Target>
                       <Target Name='b'>
@@ -897,7 +897,7 @@ public void DifferentGlobalPropertiesWithBlanks()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -964,7 +964,7 @@ public void DifferentGlobalPropertiesInvalid()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -1019,7 +1019,7 @@ public void DifferentAdditionalPropertiesWithDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyPropG)'=='1'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyPropA)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -1086,7 +1086,7 @@ public void DifferentAdditionalPropertiesWithGlobalProperties()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyPropG)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyPropA)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -1155,7 +1155,7 @@ public void DifferentAdditionalPropertiesWithoutDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyPropG)'=='1'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyPropA)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -1232,7 +1232,7 @@ public void TargetsWithSeparationChars()
                     <ItemGroup>
                         <ProjectFile Include=`" + projectFile1 + @"` />
                     </ItemGroup>
-                   
+
                     <Target Name=`Build` Outputs=`$(SomeOutputs)`>
                         <MSBuild Projects=`@(ProjectFile)` Targets=`$(Targets)` TargetAndPropertyListSeparators=`%3B;%3C` />
                     </Target>
@@ -1297,14 +1297,14 @@ public void StopOnFirstFailureandBuildInParallelSingleNode()
                     new TaskItem(project1), new TaskItem(project2)
                 };
 
-                // Test the various combinations of BuildInParallel and StopOnFirstFailure when the msbuild task is told there are not multiple nodes 
+                // Test the various combinations of BuildInParallel and StopOnFirstFailure when the msbuild task is told there are not multiple nodes
                 // running in the system
                 for (int i = 0; i < 4; i++)
                 {
                     bool buildInParallel = false;
                     bool stopOnFirstFailure = false;
 
-                    // first set up the project being built. 
+                    // first set up the project being built.
                     switch (i)
                     {
                         case 0:
@@ -1345,7 +1345,7 @@ public void StopOnFirstFailureandBuildInParallelSingleNode()
                     switch (i)
                     {
                         case 0:
-                            // Verify setting BuildInParallel and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel and StopOnFirstFailure to
                             // true will cause the msbuild task to set BuildInParallel to false during the execute
                             // Verify build did not build second project which has the message SecondProject
                             logger.AssertLogDoesntContain("SecondProject");
@@ -1355,7 +1355,7 @@ public void StopOnFirstFailureandBuildInParallelSingleNode()
                             logger.AssertLogContains(AssemblyResources.GetString("MSBuild.NotBuildingInParallel"));
                             break;
                         case 1:
-                            // Verify setting BuildInParallel to true and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel to true and StopOnFirstFailure to
                             // false will cause no change in BuildInParallel
                             // Verify build did  build second project which has the message SecondProject
                             logger.AssertLogContains("SecondProject");
@@ -1374,7 +1374,7 @@ public void StopOnFirstFailureandBuildInParallelSingleNode()
                             break;
 
                         case 3:
-                            // Verify setting BuildInParallel to false and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel to false and StopOnFirstFailure to
                             // false will cause no change in BuildInParallel
                             // Verify build did build second project which has the message SecondProject
                             logger.AssertLogContains("SecondProject");
@@ -1420,14 +1420,14 @@ public void StopOnFirstFailureandBuildInParallelMultipleNode()
 
             try
             {
-                // Test the various combinations of BuildInParallel and StopOnFirstFailure when the msbuild task is told there are multiple nodes 
+                // Test the various combinations of BuildInParallel and StopOnFirstFailure when the msbuild task is told there are multiple nodes
                 // running in the system
                 for (int i = 0; i < 4; i++)
                 {
                     bool buildInParallel = false;
                     bool stopOnFirstFailure = false;
 
-                    // first set up the project being built. 
+                    // first set up the project being built.
                     switch (i)
                     {
                         case 0:
@@ -1477,7 +1477,7 @@ public void StopOnFirstFailureandBuildInParallelMultipleNode()
                             logger.AssertLogDoesntContain(AssemblyResources.GetString("MSBuild.NotBuildingInParallel"));
                             break;
                         case 1:
-                            // Verify setting BuildInParallel to true and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel to true and StopOnFirstFailure to
                             // false will cause no change in BuildInParallel
                             // Verify build did build second project which has the message SecondProject
                             logger.AssertLogContains("SecondProject");
@@ -1487,7 +1487,7 @@ public void StopOnFirstFailureandBuildInParallelMultipleNode()
                             logger.AssertLogDoesntContain(AssemblyResources.GetString("MSBuild.NotBuildingInParallel"));
                             break;
                         case 2:
-                            // Verify setting BuildInParallel to false and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel to false and StopOnFirstFailure to
                             // true will cause no change in BuildInParallel
                             // Verify build did not build second project which has the message SecondProject
                             logger.AssertLogDoesntContain("SecondProject");
@@ -1498,7 +1498,7 @@ public void StopOnFirstFailureandBuildInParallelMultipleNode()
                             break;
 
                         case 3:
-                            // Verify setting BuildInParallel to false and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel to false and StopOnFirstFailure to
                             // false will cause no change in BuildInParallel
                             // Verify build did build second project which has the message SecondProject
                             logger.AssertLogContains("SecondProject");
@@ -1772,12 +1772,12 @@ public void PropertiesWithSeparationChars()
                             <AdditionalProperties>C=$(CValues)%3BD=$(DValues)</AdditionalProperties>
                         </ProjectFile>
                     </ItemGroup>
-                   
+
                     <Target Name=`Build` Outputs=`$(SomeOutputs)`>
                         <MSBuild Projects=`@(ProjectFile)` Targets=`Build` Properties=`a=$(AValues)%3Bb=$(BValues)` TargetAndPropertyListSeparators=`%3B`>
                             <Output TaskParameter=`TargetOutputs` PropertyName=`SomeOutputs`/>
                         </MSBuild>
-                    </Target>	
+                    </Target>
                 </Project>
                 ");
 
@@ -1837,13 +1837,13 @@ public void TargetNameIsCaseInsensitive()
                 ");
 
             string projectFile2 = ObjectModelHelpers.CreateTempFileOnDisk(@"
-                <Project DefaultTargets=`t` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>                  
+                <Project DefaultTargets=`t` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <Target Name=`t`>
                         <MSBuild Projects=`" + projectFile1 + @"` Targets=`BUILD`>
                             <Output TaskParameter=`TargetOutputs` ItemName=`out`/>
                         </MSBuild>
                         <Message Text=`[@(out)]`/>
-                    </Target>	
+                    </Target>
                 </Project>
                 ");
 
@@ -1873,13 +1873,13 @@ public void ProjectFileWithoutNamespaceBuilds()
                 ");
 
             string projectFile2 = ObjectModelHelpers.CreateTempFileOnDisk(@"
-                <Project>                  
+                <Project>
                     <Target Name=`t`>
                         <MSBuild Projects=`" + projectFile1 + @"` Targets=`Build`>
                             <Output TaskParameter=`TargetOutputs` ItemName=`out`/>
                         </MSBuild>
                         <Message Text=`[@(out)]`/>
-                    </Target>	
+                    </Target>
                 </Project>
                 ");
 
diff --git a/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
index dc1d7e8f4b9..aeddc3281eb 100644
--- a/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
@@ -19,7 +19,7 @@ public class NodeConfiguration_Tests
     {
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// Test serialization / deserialization of the AppDomainSetup instance. 
+        /// Test serialization / deserialization of the AppDomainSetup instance.
         /// </summary>
         [Theory]
         [InlineData(new byte[] { 1, 2, 3 })]
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 6b401f38f42..0649b96b566 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -17,7 +17,7 @@
 namespace Microsoft.Build.UnitTests.BackEnd
 {
     /// <summary>
-    /// Each packet is split up into a region, the region contains the tests for 
+    /// Each packet is split up into a region, the region contains the tests for
     /// a given packet type.
     /// </summary>
     public class NodePackets_Tests
@@ -326,7 +326,7 @@ public void TestTranslation()
                         .RespectingRuntimeTypes()
                         // Since we use struct DictionaryEntry of class TaskItemData, generated DictionaryEntry.Equals compare TaskItemData by references.
                         // Bellow will instruct equivalency test to not use DictionaryEntry.Equals but its public members for equivalency tests.
-                        .ComparingByMembers<DictionaryEntry>() 
+                        .ComparingByMembers<DictionaryEntry>()
                         .WithTracing(), "Roundtrip deserialization of message type {0} should be equivalent", args.GetType().Name);
                 }
             }
@@ -337,7 +337,7 @@ public void TestTranslation()
         }
 
         /// <summary>
-        /// Verify the LoggingMessagePacket is properly created from a build event. 
+        /// Verify the LoggingMessagePacket is properly created from a build event.
         /// This includes the packet type and the event type depending on which build event arg is passed in.
         /// </summary>
         /// <param name="buildEvent">Build event to put into a packet, and verify after packet creation</param>
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index c82578b6e61..ac1f69f2f60 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -35,7 +35,7 @@ public void Basic()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -89,9 +89,9 @@ public void FailingTaskStillPublishesOutputs()
                     </root>");
 
                 Project project = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
-                    <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                    <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                         <Target Name='Build'>
-                            
+
                             <GenerateResource
                                 ExecuteAsTool='false'
                                 Sources='" + resx + @"'
@@ -99,11 +99,11 @@ public void FailingTaskStillPublishesOutputs()
                                     <Output TaskParameter='FilesWritten' ItemName='FilesWrittenItem'/>
                                     <Output TaskParameter='FilesWritten' PropertyName='FilesWrittenProperty'/>
                             </GenerateResource>
-                                               
+
                             <OnError ExecuteTargets='ErrorTarget'/>
                         </Target>
 
-                        <Target Name='ErrorTarget'>    
+                        <Target Name='ErrorTarget'>
                             <Message Text='[@(fileswrittenitem)]'/>
                             <Message Text='[$(fileswrittenproperty)]'/>
                         </Target>
@@ -144,16 +144,16 @@ public void OnErrorSeesPropertiesAndItemsFromFirstTarget()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
 
                    <Target Name='Build'>
                       <!-- Create a bunch of items and properties -->
                       <CreateItem Include='a1'>
                         <Output ItemName='i1' TaskParameter='Include'/>
-                      </CreateItem> 
+                      </CreateItem>
                       <ItemGroup>
                         <i1 Include='a2'/>
-                      </ItemGroup> 
+                      </ItemGroup>
                       <CreateProperty Value='v1'>
                         <Output PropertyName='p1' TaskParameter='Value'/>
                       </CreateProperty>
@@ -188,7 +188,7 @@ public void TwoExecuteTargets()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -219,7 +219,7 @@ public void TwoOnErrorClauses()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -252,7 +252,7 @@ public void DependentTarget()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp' DependsOnTargets='CleanUp2'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -284,7 +284,7 @@ public void ErrorInChildIsHandledInParent()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -315,7 +315,7 @@ public void NonExistentExecuteTarget()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='Build'>
                       <Error Text='This is an error.'/>
                       <OnError ExecuteTargets='CleanUp'/>
@@ -339,7 +339,7 @@ public void TrueCondition()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -366,7 +366,7 @@ public void FalseCondition()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -394,7 +394,7 @@ public void PropertiesInExecuteTargets()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <PropertyGroup>
                      <Part1>Clean</Part1>
                      <Part2>Up</Part2>
@@ -426,7 +426,7 @@ public void ErrorTargetsContinueAfterErrorsInErrorHandler()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp1'>
                       <Message Text='CleanUp1-was-called.'/>
                       <Error Text='Error in CleanUp1.'/>
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index 7bcca24e739..0dfff488ff0 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -166,7 +166,7 @@ public void TestRetrieveSubsetResults()
         }
 
         /// <summary>
-        /// If a result had multiple targets associated with it and we only requested some of their 
+        /// If a result had multiple targets associated with it and we only requested some of their
         /// results, the returned result should only contain the targets we asked for, and the overall
         /// status of the result should reflect the targets we asked for as well.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index f263f41844d..bb2cf8e7019 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -131,7 +131,7 @@ public void AssertSecondResolverWithPatternCanResolve()
 
         [Fact]
         // Scenario: MockSdkResolverWithResolvableSdkPattern1 is a specific resolver, it is loaded but did not resolve sdk.
-        // MockSdkResolver1 is a general resolver (i.e. resolver without pattern), it resolves sdk on a fallback. 
+        // MockSdkResolver1 is a general resolver (i.e. resolver without pattern), it resolves sdk on a fallback.
         public void AssertFirstResolverCanResolve()
         {
             SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 065958278e0..cd2a93acc25 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -123,11 +123,11 @@ public void EmptyItemSpecInTargetOutputs()
 
         /// <summary>
         /// Tests this case:
-        /// 
+        ///
         /// <Target Name="x"
         ///         Inputs="@(Items);c.cs"
         ///         Outputs="@(Items->'%(Filename).dll')" />
-        /// 
+        ///
         /// If Items = [a.cs;b.cs], and only b.cs is out of date w/r/t its
         /// correlated output b.dll, then we should only build "b" incrementally.
         /// </summary>
@@ -160,11 +160,11 @@ public void MetaInputAndInputItemThatCorrelatesWithOutputItem()
 
         /// <summary>
         /// Tests this case:
-        /// 
+        ///
         /// <Target Name="x"
         ///         Inputs="@(Items)"
         ///         Outputs="@(Items->'%(Filename).dll');@(Items->'%(Filename).xml')" />
-        /// 
+        ///
         /// If Items = [a.cs;b.cs;c.cs], and only b.cs is out of date w/r/t its
         /// correlated outputs (dll or xml), then we should only build "b" incrementally.
         /// </summary>
@@ -203,11 +203,11 @@ public void InputItemThatCorrelatesWithMultipleTransformOutputItems()
 
         /// <summary>
         /// Tests this case:
-        /// 
+        ///
         /// <Target Name="x"
         ///         Inputs="@(Items);@(MoreItems)"
         ///         Outputs="@(Items->'%(Filename).dll');@(MoreItems->'%(Filename).xml')" />
-        /// 
+        ///
         /// If Items = [a.cs;b.cs;c.cs], and only b.cs is out of date w/r/t its
         /// correlated outputs (dll or xml), then we should only build "b" incrementally.
         /// </summary>
@@ -443,24 +443,24 @@ public void MultiInputItemsThatCorrelatesWithMultipleTransformOutputItems2()
   </Target>
 
   <Target Name='Setup'>
-        <WriteLinesToFile 
+        <WriteLinesToFile
             File='A'
             Lines='A'
             Overwrite='true'/>
-            
-        <WriteLinesToFile 
+
+        <WriteLinesToFile
             File='B.out'
             Lines='B.out'
             Overwrite='true'/>
 
         <Exec Command='sleep.exe 1' />
 
-        <WriteLinesToFile 
+        <WriteLinesToFile
             File='B'
             Lines='B'
             Overwrite='true'/>
-            
-        <WriteLinesToFile 
+
+        <WriteLinesToFile
             File='A.out'
             Lines='A.out'
             Overwrite='true'/>
diff --git a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
index 5ee9b497a9b..b956eaa4c6e 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
@@ -32,7 +32,7 @@ public class TaskHostConfiguration_Tests
         private bool _continueOnErrorDefault = true;
 
         /// <summary>
-        /// Test that an exception is thrown when the task name is null. 
+        /// Test that an exception is thrown when the task name is null.
         /// </summary>
         [Fact]
         public void ConstructorWithNullName()
@@ -67,7 +67,7 @@ public void ConstructorWithNullName()
             });
         }
         /// <summary>
-        /// Test that an exception is thrown when the task name is empty. 
+        /// Test that an exception is thrown when the task name is empty.
         /// </summary>
         [Fact]
         public void ConstructorWithEmptyName()
@@ -176,7 +176,7 @@ public void ConstructorWithEmptyLocation()
 #endif
 
         /// <summary>
-        /// Test the valid constructors.  
+        /// Test the valid constructors.
         /// </summary>
         [Fact]
         public void TestValidConstructors()
@@ -326,7 +326,7 @@ public void TestValidConstructors()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary is null. 
+        /// Test serialization / deserialization when the parameter dictionary is null.
         /// </summary>
         [Fact]
         public void TestTranslationWithNullDictionary()
@@ -379,7 +379,7 @@ public void TestTranslationWithNullDictionary()
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// Test serialization / deserialization of the AppDomainSetup instance. 
+        /// Test serialization / deserialization of the AppDomainSetup instance.
         /// </summary>
         [Theory]
         [InlineData(new byte[] { 1, 2, 3 })]
@@ -429,7 +429,7 @@ public void TestTranslationWithAppDomainSetup(byte[] configBytes)
 #endif
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary is empty. 
+        /// Test serialization / deserialization when the parameter dictionary is empty.
         /// </summary>
         [Fact]
         public void TestTranslationWithEmptyDictionary()
@@ -477,7 +477,7 @@ public void TestTranslationWithEmptyDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains just value types. 
+        /// Test serialization / deserialization when the parameter dictionary contains just value types.
         /// </summary>
         [Fact]
         public void TestTranslationWithValueTypesInDictionary()
@@ -527,7 +527,7 @@ public void TestTranslationWithValueTypesInDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem. 
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem.
         /// </summary>
         [Fact]
         public void TestTranslationWithITaskItemInDictionary()
@@ -575,7 +575,7 @@ public void TestTranslationWithITaskItemInDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array. 
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array.
         /// </summary>
         [Fact]
         public void TestTranslationWithITaskItemArrayInDictionary()
@@ -627,7 +627,7 @@ public void TestTranslationWithITaskItemArrayInDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array. 
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array.
         /// </summary>
         [Fact]
         public void TestTranslationWithWarningsAsErrors()
@@ -723,7 +723,7 @@ public void TestTranslationWithWarningsAsMessages()
         }
 
         /// <summary>
-        /// Helper methods for testing the task host-related packets. 
+        /// Helper methods for testing the task host-related packets.
         /// </summary>
         internal static class TaskHostPacketHelpers
         {
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
index c85e00e0f9c..835cb83e7bf 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.UnitTests.BackEnd
     public class TaskHostTaskCancelled_Tests
     {
         /// <summary>
-        /// Basic test of the constructor. 
+        /// Basic test of the constructor.
         /// </summary>
         [Fact]
         public void TestConstructor()
@@ -24,7 +24,7 @@ public void TestConstructor()
         }
 
         /// <summary>
-        /// Basic test of serialization / deserialization. 
+        /// Basic test of serialization / deserialization.
         /// </summary>
         [Fact]
         public void TestTranslation()
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
index 7504cd8bb3d..23cf234576d 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
@@ -21,7 +21,7 @@ namespace Microsoft.Build.UnitTests.BackEnd
     public class TaskHostTaskComplete_Tests
     {
         /// <summary>
-        /// Tests various valid ways to construct this packet.  
+        /// Tests various valid ways to construct this packet.
         /// </summary>
         [Fact]
         public void TestConstructors()
@@ -90,7 +90,7 @@ public void TestConstructors()
         }
 
         /// <summary>
-        /// Test invalid constructor permutations. 
+        /// Test invalid constructor permutations.
         /// </summary>
         [Fact]
         public void TestInvalidConstructors()
@@ -176,7 +176,7 @@ public void TestTranslationWithValueTypesInDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem. 
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem.
         /// </summary>
         [Fact]
         public void TestTranslationWithITaskItemInDictionary()
@@ -202,7 +202,7 @@ public void TestTranslationWithITaskItemInDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array. 
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array.
         /// </summary>
         [Fact]
         public void TestTranslationWithITaskItemArrayInDictionary()
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 4712e89e73d..faacc88379f 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -422,7 +422,7 @@ public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool with
                 "Subcategory",
                 "Code",
                 "File",
-                1, 
+                1,
                 2,
                 3,
                 4,
diff --git a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
index 1f167556b98..be97777e5e3 100644
--- a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
+++ b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
@@ -57,7 +57,7 @@ public void MatchProperty()
         }
 
         /// <summary>
-        /// Null 
+        /// Null
         /// </summary>
         [Fact]
         public void Null1()
@@ -66,7 +66,7 @@ public void Null1()
         }
 
         /// <summary>
-        /// Null 
+        /// Null
         /// </summary>
         [Fact]
         public void Null2()
@@ -75,7 +75,7 @@ public void Null2()
         }
 
         /// <summary>
-        /// Invalid start 
+        /// Invalid start
         /// </summary>
         [Fact]
         public void InvalidValue2()
@@ -86,7 +86,7 @@ public void InvalidValue2()
             });
         }
         /// <summary>
-        /// Invalid small end 
+        /// Invalid small end
         /// </summary>
         [Fact]
         public void InvalidValue4()
@@ -97,7 +97,7 @@ public void InvalidValue4()
             });
         }
         /// <summary>
-        /// Invalid large end 
+        /// Invalid large end
         /// </summary>
         [Fact]
         public void InvalidValue5()
@@ -160,7 +160,7 @@ public void DefaultGetHashcode()
         {
             Assert.True(0 == MSBuildNameIgnoreCaseComparer.Default.GetHashCode((string)null));
 
-            MSBuildNameIgnoreCaseComparer.Default.GetHashCode(""); // doesn't throw            
+            MSBuildNameIgnoreCaseComparer.Default.GetHashCode(""); // doesn't throw
             Assert.Equal(MSBuildNameIgnoreCaseComparer.Default.GetHashCode("aBc"), MSBuildNameIgnoreCaseComparer.Default.GetHashCode("AbC"));
         }
 
diff --git a/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
index f1c67899aea..7b98b820a4f 100644
--- a/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -60,7 +60,7 @@ public void ProjectLoadedPreservingCommentsAndWhiteSpaceIsNotReadOnly()
             var projectContents =
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
                   <!--Initial Comment-->
-                       
+
                   <!--Ending Comment-->
                 </Project>
                 ";
@@ -91,7 +91,7 @@ public void ProjectLoadedStrippingCommentsAndWhiteSpaceIsReadOnly()
             var projectContents =
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
                   <!--Initial Comment-->
-                       
+
                   <!--Ending Comment-->
                 </Project>
                 ";
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index 278c11f36ed..79bb93a4703 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -421,7 +421,7 @@ public void TestVSAndSolutionVersionParsing()
             string solutionFileContentsDev12Corrupted2 =
                @"
                     Microsoft Visual Studio Solution File, Format Version 11.00
-                        VisualStudioVersion = 
+                        VisualStudioVersion =
                         MinimumVisualStudioVersion = 10.0.40219.1
                         Project('{FE3BBBB6-72D5-11D2-9ACE-00C04F79A2A4}') = 'someproj', 'someproj.etp', '{AD0F3D02-9925-4D57-9DAF-E0A9D936ABDB}'
                             ProjectSection(ProjectDependencies) = postProject
@@ -1050,20 +1050,20 @@ public void ParseSolutionConfigurationWithEmptyLines()
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
 
                         Debug|Any CPU = Debug|Any CPU
-                        
+
                         Release|Any CPU = Release|Any CPU
- 
-    
+
+
                     EndGlobalSection
                     GlobalSection(ProjectConfigurationPlatforms) = postSolution
 
                         {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
                         {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        
+
                         {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.ActiveCfg = Release|Any CPU
                         {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.Build.0 = Release|Any CPU
- 
-  
+
+
                         {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
                         {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.Build.0 = Debug|Any CPU
                         {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.ActiveCfg = Release|Any CPU
@@ -1072,17 +1072,17 @@ public void ParseSolutionConfigurationWithEmptyLines()
                         {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
                         {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
                         {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.Build.0 = Release|Any CPU
-    
+
                     EndGlobalSection
                     GlobalSection(SolutionProperties) = preSolution
                         HideSolutionNode = FALSE
                     EndGlobalSection
                     GlobalSection(NestedProjects) = preSolution
-                        
+
                         {A5EE8128-B08E-4533-86C5-E46714981680} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
                         {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
                         {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4} = {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}
-                        
+
 
                     EndGlobalSection
                 EndGlobal
diff --git a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
index fa09e0d0cd5..7e81e9ec729 100644
--- a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
@@ -62,7 +62,7 @@ private static IList<ProjectItem> GetItemsFromFragment(string fragment)
 
         /// <summary>
         /// Get the item of type "i" using the item Xml fragment provided.
-        /// If there is more than one, fail. 
+        /// If there is more than one, fail.
         /// </summary>
         private static ProjectItem GetOneItemFromFragment(string fragment)
         {
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
index 4b1c8457c93..57afc8fd889 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
@@ -115,7 +115,7 @@ public void MSBuildToolsetsTest_Basic2()
         }
 
         /// <summary>
-        ///  Tests if ToolsetConfigurationReaderTests is successfully initialized from the config file and that msbuildOVerrideTasksPath 
+        ///  Tests if ToolsetConfigurationReaderTests is successfully initialized from the config file and that msbuildOVerrideTasksPath
         ///  is correctly read in when the value is empty.
         /// </summary>
         [Fact]
@@ -194,7 +194,7 @@ public void MSBuildToolsetsTest_BasicWithOtherConfigEntries()
         #region "Invalid cases (exception is expected to be thrown)"
 
         /// <summary>
-        /// name attribute is missing from toolset element 
+        /// name attribute is missing from toolset element
         /// </summary>
         [Fact]
         public void ToolsVersionTest_NameNotSpecified()
@@ -250,7 +250,7 @@ public void ToolsVersionTest_MultipleElementsWithSameName()
             });
         }
         /// <summary>
-        /// empty toolset element 
+        /// empty toolset element
         /// </summary>
         [Fact]
         public void ToolsVersionTest_EmptyElement()
diff --git a/src/Build.UnitTests/Definition/Toolset_Tests.cs b/src/Build.UnitTests/Definition/Toolset_Tests.cs
index 2bf6e660b37..cb63a9d574b 100644
--- a/src/Build.UnitTests/Definition/Toolset_Tests.cs
+++ b/src/Build.UnitTests/Definition/Toolset_Tests.cs
@@ -188,8 +188,8 @@ public void TestDefaultSubToolsetFor40()
                 }
                 else
                 {
-                    // Otherwise, it's the highest one numerically.  Since by definition if Dev10 isn't 
-                    // installed and subtoolsets exists we must be at least Dev11, it should be "11.0" 
+                    // Otherwise, it's the highest one numerically.  Since by definition if Dev10 isn't
+                    // installed and subtoolsets exists we must be at least Dev11, it should be "11.0"
                     Assert.Equal("11.0", t.DefaultSubToolsetVersion);
                 }
             }
@@ -438,8 +438,8 @@ public void TestGenerateSubToolsetVersion_SolutionVersionOverrides()
                 Assert.Equal("12.0", t.GenerateSubToolsetVersion(null, 13));
                 Assert.Equal("v13.0", t.GenerateSubToolsetVersion(null, 14));
 
-                // however, if there is no matching solution version, we just fall back to the 
-                // default sub-toolset. 
+                // however, if there is no matching solution version, we just fall back to the
+                // default sub-toolset.
                 Assert.Equal(t.DefaultSubToolsetVersion, t.GenerateSubToolsetVersion(null, 55));
             }
             finally
@@ -488,27 +488,27 @@ public void TestGetPropertyFromSubToolset()
         }
 
         /// <summary>
-        /// Creates a standard ProjectCollection and adds a fake toolset with the following contents to it:  
-        /// 
+        /// Creates a standard ProjectCollection and adds a fake toolset with the following contents to it:
+        ///
         /// ToolsVersion = Fake
-        /// Base Properties: 
+        /// Base Properties:
         /// a = a1
         /// b = b1
-        /// 
-        /// SubToolset "12.0": 
+        ///
+        /// SubToolset "12.0":
         /// d = d4
         /// e = e5
-        /// 
-        /// SubToolset "v11.0": 
+        ///
+        /// SubToolset "v11.0":
         /// b = b2
         /// c = c2
-        /// 
+        ///
         /// SubToolset "FakeSubToolset":
         /// a = a3
         /// c = c3
-        /// 
+        ///
         /// SubToolset "v13.0":
-        /// f = f6 
+        /// f = f6
         /// g = g7
         /// </summary>
         private Toolset GetFakeToolset(IDictionary<string, string> globalPropertiesForProjectCollection)
diff --git a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
index 1d768794e9f..5e451ce45c5 100644
--- a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
@@ -1134,14 +1134,14 @@ private static HashSet<string> GetConsumedItemReferences_OriginalImplementation(
         /// <summary>
         /// Looks through the parameters of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Returns a Hashtable containing a bunch of MetadataReference
-        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <returns>Hashtable containing the metadata references.</returns>
         private static Dictionary<string, MetadataReference> GetConsumedMetadataReferences_OriginalImplementation(string expression)
         {
             // The keys in the hash table are the qualified metadata names (e.g. "EmbeddedResource.Culture"
-            // or just "Culture").  The values are MetadataReference structs, which simply split out the item 
+            // or just "Culture").  The values are MetadataReference structs, which simply split out the item
             // name (possibly null) and the actual metadata name.
             Dictionary<string, MetadataReference> consumedMetadataReferences = new Dictionary<string, MetadataReference>(StringComparer.OrdinalIgnoreCase);
 
@@ -1153,7 +1153,7 @@ private static Dictionary<string, MetadataReference> GetConsumedMetadataReferenc
         /// <summary>
         /// Looks through a single parameter of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Populates a Hashtable containing a bunch of MetadataReference
-        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <param name="batchableObjectParameter"></param>
@@ -1241,7 +1241,7 @@ private static void FindEmbeddedMetadataReferences_OriginalImplementation(
         /// <summary>
         /// Looks through a single parameter of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Populates a MatchCollection object with any regex matches
-        /// found in the input.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// found in the input.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <param name="batchableObjectParameter"></param>
diff --git a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
index 3f17110a7d0..84656861b31 100644
--- a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
@@ -1211,7 +1211,7 @@ This import was added implicitly because the Project element's Sdk attribute spe
 
 
         /// <summary>
-        /// Verifies that the Preprocessor works when the import graph contains unevaluated duplicates.  This can occur if two projects in 
+        /// Verifies that the Preprocessor works when the import graph contains unevaluated duplicates.  This can occur if two projects in
         /// two different folders both import "..\dir.props" or "$(Property)".  Those values will evaluate to different paths at run time
         /// but the preprocessor builds a map of the imports.
         /// </summary>
diff --git a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
index 6268fee61ea..2f0b81f8ddd 100644
--- a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
@@ -273,7 +273,7 @@ public void AddReturnsSameInstanceForSameDocument()
 
                 string return2 = cache.Add(builder.ToString(), document);
 
-                // Content of string should be the same.            
+                // Content of string should be the same.
                 Assert.Equal(builder.ToString(), return2);
 
                 // Returned references should be the same
@@ -285,7 +285,7 @@ public void AddReturnsSameInstanceForSameDocument()
         }
 
         /// <summary>
-        /// Adding a string equivalent to an existing instance but under a different document 
+        /// Adding a string equivalent to an existing instance but under a different document
         /// should return the existing instance.
         /// </summary>
         [Fact]
@@ -334,7 +334,7 @@ public void AddReturnsSameInstanceForDifferentDocument()
         /// WHITEBOX ASSUMPTION:
         /// The following method assumes knowledge of the ProjectStringCache internal implementation
         /// details, and may become invalid if those details change.
-        /// </remarks>        
+        /// </remarks>
         [Fact]
         public void RemoveLastInstanceDeallocatesEntry()
         {
@@ -370,7 +370,7 @@ public void RemoveLastInstanceDeallocatesEntry()
         }
 
         /// <summary>
-        /// Removing one document containing a string which already existed in the collection 
+        /// Removing one document containing a string which already existed in the collection
         /// should still leave a reference in the collection, so that a subsequent add will
         /// return the existing reference.
         /// </summary>
diff --git a/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs b/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
index 30f95c0e0bb..4266e36105b 100644
--- a/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
@@ -49,7 +49,7 @@ IDictionary<string, string> toolsetProperties
         }
 
         [Fact]
-        // With ToolsetDefintionLocations set to ConfigurationFile (Which would only happen in net5.0 if the user decides to set it). 
+        // With ToolsetDefintionLocations set to ConfigurationFile (Which would only happen in net5.0 if the user decides to set it).
         // Most toolsets are available and the MsBuildTools and SDK paths are all in the net5.0 runtime.
         public void ToolsetDefinitionLocationsIsConfiguration()
         {
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 72abe497317..d3f01d757fb 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -58,7 +58,7 @@ public class IsolateProjectsTests : IDisposable
                     </Target>
 
                     <Target Name='CallTarget'>
-                        <CallTarget Targets='SelfTarget'/>  
+                        <CallTarget Targets='SelfTarget'/>
                     </Target>
 
                     <Target Name='SelfTarget'>
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index 65ab4706791..c2f62879a4e 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -408,7 +408,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
         /// This method runs in two modes.
         /// When <param name="generateCacheFiles"></param> is true, the method will fill in the empty <param name="outputCaches"/> and <param name="expectedNodeBuildOutput"/>, simulating a build from scratch.
         /// When it is false, it uses the filled in <param name="outputCaches"/> and <param name="expectedNodeBuildOutput"/> to simulate a fully cached build.
-        /// 
+        ///
         /// </summary>
         /// <param name="env">The test environment under which to run.</param>
         /// <param name="topoSortedNodes"></param>
@@ -533,7 +533,7 @@ internal static TransientTestFile CreateProjectFileWithBuildTargetAndItems(
                                 ? $"Targets='{explicitTargets}'"
                                 : string.Empty)}
                             >
-                            <Output TaskParameter='TargetOutputs' ItemName='i' />  
+                            <Output TaskParameter='TargetOutputs' ItemName='i' />
                         </MSBuild>
                     </Target>");
 
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index c20134ea1dc..2c81f94f2cc 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -143,8 +143,8 @@ public void TestSpecificAffinityRegistration()
         }
 
         /// <summary>
-        /// Make sure we get the default affinity when the affinity map exists, but the specific 
-        /// project we're requesting is not set. 
+        /// Make sure we get the default affinity when the affinity map exists, but the specific
+        /// project we're requesting is not set.
         /// </summary>
         [Fact]
         public void TestDefaultAffinityWhenProjectNotRegistered()
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index da4fd47acd2..7c9a8b14f6c 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -235,7 +235,7 @@ static TaskItem BuildItem(
         }
 
         /// <summary>
-        /// Flushing an item through a task should not mess up special characters on the metadata. 
+        /// Flushing an item through a task should not mess up special characters on the metadata.
         /// </summary>
         [Fact]
         public void Escaping1()
@@ -287,7 +287,7 @@ public void Escaping1()
         }
 
         /// <summary>
-        /// Flushing an item through a task run in the task host also should not mess up special characters on the metadata. 
+        /// Flushing an item through a task run in the task host also should not mess up special characters on the metadata.
         /// </summary>
 #if RUNTIME_TYPE_NETCORE || MONO
         [Fact(Skip = "FEATURE: TASKHOST")]
@@ -344,7 +344,7 @@ public void Escaping2()
         }
 
         /// <summary>
-        /// Flushing an item through a task run in the task host also should not mess up the escaping of the itemspec either. 
+        /// Flushing an item through a task run in the task host also should not mess up the escaping of the itemspec either.
         /// </summary>
 #if RUNTIME_TYPE_NETCORE || MONO
         [Fact(Skip = "FEATURE: TASKHOST")]
diff --git a/src/Build.UnitTests/Parser_Tests.cs b/src/Build.UnitTests/Parser_Tests.cs
index 60dd1139123..81d505f3c2d 100644
--- a/src/Build.UnitTests/Parser_Tests.cs
+++ b/src/Build.UnitTests/Parser_Tests.cs
@@ -582,7 +582,7 @@ public void SupportItemDefinationGroupInWhenOtherwise(bool context)
             var metadatam = projectItem.GetMetadata("m");
             if (context)
             {
-                // Go to when 
+                // Go to when
                 Assert.Equal("m1", metadatam.EvaluatedValue);
             }
             else
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 6debe82528e..758c98729ac 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -1547,7 +1547,7 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
         // This test ensures that scheduling proxy builds on the inproc node works nicely within the Scheduler
         // if the BuildRequestConfigurations for those proxy builds have built before (or are still building) on
         // the out of proc node.
-        // More details: https://github.com/dotnet/msbuild/pull/6635 
+        // More details: https://github.com/dotnet/msbuild/pull/6635
         public void ProxyCacheHitsOnPreviousCacheMissesShouldWork()
         {
             var cacheNotApplicableTarget = "NATarget";
diff --git a/src/Build.UnitTests/SolutionFileBuilder.cs b/src/Build.UnitTests/SolutionFileBuilder.cs
index 73774529835..aafe08827d9 100644
--- a/src/Build.UnitTests/SolutionFileBuilder.cs
+++ b/src/Build.UnitTests/SolutionFileBuilder.cs
@@ -2,9 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 // --------------------------------------------------------------------
-// 
+//
 // Copyright (c) Microsoft Corporation.  All rights reserved.
-// 
+//
 // --------------------------------------------------------------------
 
 using System;
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 36094ff2bec..55716f80a51 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -69,8 +69,8 @@ public void TargetARM()
         #region 32bit preferred
 
         /// <summary>
-        /// Check that with an empty platformtarget (equivalent to anycpu), library type assemblies do not 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an empty platformtarget (equivalent to anycpu), library type assemblies do not
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void AnyCPULibraryProjectIsNot32BitPreferred()
@@ -118,8 +118,8 @@ public void AnyCPULibraryProjectIsNot32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an explicit platform of anycpu, library type assemblies do not 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an explicit platform of anycpu, library type assemblies do not
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void ExplicitAnyCPULibraryProjectIsNot32BitPreferred()
@@ -168,8 +168,8 @@ public void ExplicitAnyCPULibraryProjectIsNot32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an empty platformtarget (equivalent to anycpu), winmdobj type assemblies do not 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an empty platformtarget (equivalent to anycpu), winmdobj type assemblies do not
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void AnyCPUWinMDObjProjectIsNot32BitPreferred()
@@ -223,8 +223,8 @@ we need to be .NET 4.5 or greater -->
         }
 
         /// <summary>
-        /// Check that with an explicit platformtarget of anycpu, winmdobj type assemblies do not 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an explicit platformtarget of anycpu, winmdobj type assemblies do not
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void ExplicitAnyCPUWinMDObjProjectIsNot32BitPreferred()
@@ -279,8 +279,8 @@ we need to be .NET 4.5 or greater -->
         }
 
         /// <summary>
-        /// Check that with an empty platformtarget (equivalent to anycpu), exe type assemblies 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an empty platformtarget (equivalent to anycpu), exe type assemblies
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void AnyCPUExeProjectIs32BitPreferred()
@@ -328,8 +328,8 @@ public void AnyCPUExeProjectIs32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an explicit platformtarget of anycpu, exe type assemblies 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an explicit platformtarget of anycpu, exe type assemblies
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void ExplicitAnyCPUExeProjectIs32BitPreferred()
@@ -378,8 +378,8 @@ public void ExplicitAnyCPUExeProjectIs32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an empty platformtarget (equivalent to anycpu), exe type assemblies 
-        /// that are targeting .NET 4.0 do not get forced to anycpu32bitpreferred by default. 
+        /// Check that with an empty platformtarget (equivalent to anycpu), exe type assemblies
+        /// that are targeting .NET 4.0 do not get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void AnyCPU40ExeProjectIsNot32BitPreferred()
@@ -427,8 +427,8 @@ public void AnyCPU40ExeProjectIsNot32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an explicit platformtarget of anycpu, exe type assemblies that are 
-        /// targeting .NET 4.0+ do not get forced to anycpu32bitpreferred by default. 
+        /// Check that with an explicit platformtarget of anycpu, exe type assemblies that are
+        /// targeting .NET 4.0+ do not get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void ExplicitAnyCPUExeProjectIsNot32BitPreferred()
@@ -477,8 +477,8 @@ public void ExplicitAnyCPUExeProjectIsNot32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an empty platformtarget (equivalent to anycpu), appcontainerexe type assemblies 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an empty platformtarget (equivalent to anycpu), appcontainerexe type assemblies
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void AnyCPUAppContainerExeProjectIs32BitPreferred()
@@ -532,8 +532,8 @@ public void AnyCPUAppContainerExeProjectIs32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an explicit platformtarget of anycpu, appcontainerexe type assemblies 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an explicit platformtarget of anycpu, appcontainerexe type assemblies
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void ExplicitAnyCPUAppContainerExeProjectIs32BitPreferred()
@@ -588,8 +588,8 @@ we need to be .NET 4.5 or greater -->
         }
 
         /// <summary>
-        /// Although AnyCPU library projects should not default to AnyCPU32BitPreferred, because that platform is 
-        /// not supported for library projects, if Prefer32Bit is explicitly set, we should still respect that. 
+        /// Although AnyCPU library projects should not default to AnyCPU32BitPreferred, because that platform is
+        /// not supported for library projects, if Prefer32Bit is explicitly set, we should still respect that.
         /// </summary>
         [Fact]
         public void AnyCPULibraryProjectIs32BitPreferredIfPrefer32BitSet()
@@ -639,8 +639,8 @@ public void AnyCPULibraryProjectIs32BitPreferredIfPrefer32BitSet()
         }
 
         /// <summary>
-        /// A project with no explicit OutputType will end up defaulting its OutputType to exe, 
-        /// so it should also default to Prefer32Bit = true. 
+        /// A project with no explicit OutputType will end up defaulting its OutputType to exe,
+        /// so it should also default to Prefer32Bit = true.
         /// </summary>
         [Fact]
         public void AnyCPUProjectWithNoExplicitOutputTypeIs32BitPreferred()
@@ -688,8 +688,8 @@ public void AnyCPUProjectWithNoExplicitOutputTypeIs32BitPreferred()
         }
 
         /// <summary>
-        /// A project with no explicit OutputType will end up defaulting its OutputType to exe, 
-        /// so it should also default to Prefer32Bit = true. 
+        /// A project with no explicit OutputType will end up defaulting its OutputType to exe,
+        /// so it should also default to Prefer32Bit = true.
         /// </summary>
         [Fact]
         public void AnyCPUJupiterProjectWithNoExplicitOutputTypeIs32BitPreferred()
@@ -740,7 +740,7 @@ public void AnyCPUJupiterProjectWithNoExplicitOutputTypeIs32BitPreferred()
         #endregion 32bit preferred
 
         /// <summary>
-        /// Validate that the GetFrameworkPaths target 
+        /// Validate that the GetFrameworkPaths target
         /// </summary>
         [Fact]
         public void TestGetFrameworkPaths()
@@ -774,7 +774,7 @@ public void TestGetFrameworkPaths()
         }
 
         /// <summary>
-        /// Validate that the GetFrameworkPaths target 
+        /// Validate that the GetFrameworkPaths target
         /// </summary>
         [Fact]
         public void TestTargetFrameworkPaths()
@@ -837,7 +837,7 @@ public void TestTargetFrameworkPaths()
         #region AssignLinkMetadata targets tests
 
         /// <summary>
-        /// Doesn't synthesize Link metadata if the items are defined in the project  
+        /// Doesn't synthesize Link metadata if the items are defined in the project
         /// </summary>
         [Fact]
         public void NoLinkMetadataSynthesisWhenDefinedInProject()
@@ -1057,8 +1057,8 @@ public void DontSynthesizeLinkMetadataIfPropertyNotSet()
 #if _NOT_YET_FULLY_CONVERTED_
         /// <summary>
         /// Tests that exercise the SplitResourcesByCulture Target in Microsoft.Common.targets.
-        /// This target's job is to separate the items that need to run through resgen from 
-        /// those that need to go directly into CSC. Also, Culture and non-Culture resources 
+        /// This target's job is to separate the items that need to run through resgen from
+        /// those that need to go directly into CSC. Also, Culture and non-Culture resources
         /// are split.
         /// </summary>
         [Test]
@@ -1080,11 +1080,11 @@ public void SplitResourcesByCultureTarget()
                       </ItemGroup>
                       <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                     </Project>
-                "); 
+                ");
 
             p.Build(new string [] {"SplitResourcesByCulture"}, null);
 
-            ProjectItem[] items = p.GetItems("EmbeddedResource").ToArray();                        
+            ProjectItem[] items = p.GetItems("EmbeddedResource").ToArray();
 
             Assert.AreEqual("Resource2.resx", items[0].EvaluatedInclude);
             Assert.AreEqual("false", items[0].GetMetadataValue("WithCulture"));
@@ -1202,10 +1202,10 @@ static int Main(string[] args)
                             try
                             {
 			                    ResourceManager rm;
-                    			
+
 			                    rm = new ResourceManager(`ConsoleApplication37.Strings1`, Assembly.GetExecutingAssembly());
 			                    Console.WriteLine(rm.GetString(`Usage`));
-                    			
+
 			                    rm = new ResourceManager(`MyStrings2`, Assembly.GetExecutingAssembly());
 			                    Console.WriteLine(String.Format(rm.GetString(`InvalidChildElement`), `Foo`));
 
@@ -1228,32 +1228,32 @@ static int Main(string[] args)
             // ----------------------------------------------------------------------------
             // Strings1.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings1.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings1.restext",
                 @"Usage=Hello world!  Isn't it a beautiful day?");
 
             // ----------------------------------------------------------------------------
             // Strings2.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings2.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings2.restext",
                 @"InvalidChildElement=The element {0} is not allowed here.");
 
             // ----------------------------------------------------------------------------
             // Subfolder\Strings3.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Subfolder\Strings3.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Subfolder\Strings3.restext",
                 @"CopyrightMessage=Copyright (C) 2005, The MSBuild Team");
 
             MockLogger logger = ObjectModelHelpers.BuildTempProjectFileExpectSuccess(@"ConsoleApplication37.csproj");
 
             string stdout = ObjectModelHelpers.RunTempProjectBuiltApplication(@"bin\debug\ConsoleApplication37.exe");
 
-            Assert.IsTrue(@"ConsoleApplication37.exe did not emit Usage string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication37.exe did not emit Usage string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("Hello world!  Isn't it a beautiful day?"));
 
-            Assert.IsTrue(@"ConsoleApplication37.exe did not emit InvalidChildElement string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication37.exe did not emit InvalidChildElement string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("The element Foo is not allowed here."));
 
-            Assert.IsTrue(@"ConsoleApplication37.exe did not emit CopyrightMessage string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication37.exe did not emit CopyrightMessage string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("Copyright (C) 2005, The MSBuild Team"));
         }
 
@@ -1362,32 +1362,32 @@ End Module
             // ----------------------------------------------------------------------------
             // Strings1.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings1.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings1.restext",
                 @"Usage=Hello world!  Isn't it a beautiful day?");
 
             // ----------------------------------------------------------------------------
             // Strings2.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings2.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings2.restext",
                 @"InvalidChildElement=The element {0} is not allowed here.");
 
             // ----------------------------------------------------------------------------
             // Subfolder\Strings3.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Subfolder\Strings3.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Subfolder\Strings3.restext",
                 @"CopyrightMessage=Copyright (C) 2005, The MSBuild Team");
 
             MockLogger logger = ObjectModelHelpers.BuildTempProjectFileExpectSuccess(@"ConsoleApplication38.vbproj");
 
             string stdout = ObjectModelHelpers.RunTempProjectBuiltApplication(@"bin\debug\ConsoleApplication38.exe");
 
-            Assert.IsTrue(@"ConsoleApplication38.exe did not emit Usage string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication38.exe did not emit Usage string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("Hello world!  Isn't it a beautiful day?"));
 
-            Assert.IsTrue(@"ConsoleApplication38.exe did not emit InvalidChildElement string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication38.exe did not emit InvalidChildElement string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("The element Foo is not allowed here."));
 
-            Assert.IsTrue(@"ConsoleApplication38.exe did not emit CopyrightMessage string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication38.exe did not emit CopyrightMessage string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("Copyright (C) 2005, The MSBuild Team"));
         }
     }
@@ -1411,16 +1411,16 @@ public void Regress381480()
             try
             {
                 Project p0 = ObjectModelHelpers.CreateInMemoryProject(@"
-    
-                        <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+
+                        <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                             <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                         </Project>
 
                     ");
 
                 Project p1 = ObjectModelHelpers.CreateInMemoryProject(@"
-    
-                        <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+
+                        <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                            <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                         </Project>
 
@@ -1451,7 +1451,7 @@ public void Regress381480()
     /// building) returning the name of the EXE or DLL that would be built.
     /// </summary>
     [TestFixture]
-    sealed public class GetTargetPath        
+    sealed public class GetTargetPath
     {
         /// <summary>
         /// Try a basic workings.
@@ -1461,7 +1461,7 @@ public void Basic()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>bin\Debug\</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -1473,23 +1473,23 @@ public void Basic()
                       </ItemGroup>
                       <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                    </Project>
-                ");            
-            
+                ");
+
             Hashtable h = new Hashtable();
             p.Build(new string[] {"GetTargetPath" }, h);
             ObjectModelHelpers.AssertSingleItemInDictionary(h, "<|proj|>bin\\Debug\\MyAssembly.exe");
         }
-    }    
+    }
 
     /// <summary>
-    /// Tests that exercise the PrepareResourceNames Target in 
+    /// Tests that exercise the PrepareResourceNames Target in
     /// Microsoft.VisualBasic.targets.
-    /// 
+    ///
     /// This target's job is to create manifest resource names for each of
     /// the resource files.
     /// </summary>
     [TestFixture]
-    sealed public class PrepareResourceNamesTarget        
+    sealed public class PrepareResourceNamesTarget
     {
         /// <summary>
         /// Basic test.
@@ -1499,7 +1499,7 @@ public void BasicVbResourceNames()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>bin\Debug\</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -1516,11 +1516,11 @@ public void BasicVbResourceNames()
                       </ItemGroup>
                       <Import Project=`$(MSBuildBinPath)\Microsoft.VisualBasic.targets` />
                     </Project>
-                ");            
+                ");
 
             p.Build(new string [] {"PrepareResourceNames"}, null);
 
-            ProjectItem[] items = p.GetItems("EmbeddedResource").ToArray();            
+            ProjectItem[] items = p.GetItems("EmbeddedResource").ToArray();
 
             Assert.AreEqual("Resource2.resx", items[0].EvaluatedInclude);
             Assert.AreEqual("false", items[0].GetMetadataValue("WithCulture"));
@@ -1530,7 +1530,7 @@ public void BasicVbResourceNames()
             Assert.AreEqual("Resource2.fr.resx", items[1].EvaluatedInclude);
             Assert.AreEqual("true", items[1].GetMetadataValue("WithCulture"));
             Assert.AreEqual("Resx", items[1].GetMetadataValue("Type"));
-            Assert.AreEqual("MyNamespace.Resource2.fr", items[1].GetMetadataValue("ManifestResourceName"));            
+            Assert.AreEqual("MyNamespace.Resource2.fr", items[1].GetMetadataValue("ManifestResourceName"));
 
             Assert.AreEqual("Resource1.txt", items[2].EvaluatedInclude);
             Assert.AreEqual("false", items[2].GetMetadataValue("WithCulture"));
@@ -1597,7 +1597,7 @@ public void CopyAppConfigFileEvenForDllProjects()
                     <Folder Include=`Properties\` />
                 </ItemGroup>
                 <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
-                <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                     Other similar extension points exist, see Microsoft.Common.targets.
                 <Target Name=`BeforeBuild`>
                 </Target>
@@ -1606,7 +1606,7 @@ public void CopyAppConfigFileEvenForDllProjects()
                 -->
                 </Project>
             ");
-            
+
             // ---------------------
             // Class1.cs
             // ---------------------
@@ -1618,7 +1618,7 @@ public void CopyAppConfigFileEvenForDllProjects()
                 using System.Runtime.CompilerServices;
                 using System.Runtime.InteropServices;
 
-                // General Information about an assembly is controlled through the following 
+                // General Information about an assembly is controlled through the following
                 // set of attributes. Change these attribute values to modify the information
                 // associated with an assembly.
                 [assembly: AssemblyTitle(`ClassLibrary16`)]
@@ -1630,8 +1630,8 @@ public void CopyAppConfigFileEvenForDllProjects()
                 [assembly: AssemblyTrademark(``)]
                 [assembly: AssemblyCulture(``)]
 
-                // Setting ComVisible to false makes the types in this assembly not visible 
-                // to COM components.  If you need to access a type in this assembly from 
+                // Setting ComVisible to false makes the types in this assembly not visible
+                // to COM components.  If you need to access a type in this assembly from
                 // COM, set the ComVisible attribute to true on that type.
                 [assembly: ComVisible(false)]
 
@@ -1641,11 +1641,11 @@ public void CopyAppConfigFileEvenForDllProjects()
                 // Version information for an assembly consists of the following four values:
                 //
                 //      Major Version
-                //      Minor Version 
+                //      Minor Version
                 //      Build Number
                 //      Revision
                 //
-                // You can specify all the values or you can default the Revision and Build Numbers 
+                // You can specify all the values or you can default the Revision and Build Numbers
                 // by using the '*' as shown below:
                 [assembly: AssemblyVersion(`1.0.0.0`)]
                 [assembly: AssemblyFileVersion(`1.0.0.0`)]
@@ -1695,7 +1695,7 @@ public void AppConfigLocation()
             e.SetGlobalProperty("case", "0"); // Make project loadable
             Project p = ObjectModelHelpers.CreateInMemoryProject(e, @"
 
-                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputType>Library</OutputType>
                         <AssemblyName>foo</AssemblyName>
@@ -1728,7 +1728,7 @@ public void AppConfigLocation()
             p.Build(new string[] { "PrepareForBuild" });
             item = ObjectModelHelpers.AssertSingleItem(p, "AppConfigWithTargetPath", "app.config");
             Assert.AreEqual("foo.dll.config", item.GetMetadataValue("TargetPath"));
-            
+
             ///    (4) Choose @(None) App.Config in any subfolder in the project.
             p.SetGlobalProperty("case", "4");
             p.Build(new string[] { "PrepareForBuild" });
@@ -1758,7 +1758,7 @@ public void AppConfigLocationRelativeDir()
             ProjectCollection e = new ProjectCollection();
             Project p = ObjectModelHelpers.CreateInMemoryProject(e, @"
 
-                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputType>Library</OutputType>
                         <AssemblyName>foo</AssemblyName>
@@ -1786,7 +1786,7 @@ public void AppConfigLocationNoneWinsOverContent()
             ProjectCollection e = new ProjectCollection();
             Project p = ObjectModelHelpers.CreateInMemoryProject(e, @"
 
-                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputType>Library</OutputType>
                         <AssemblyName>foo</AssemblyName>
@@ -1853,7 +1853,7 @@ public void ConfigurationsReferencedInCSharpProject()
                     </ItemGroup>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
-                ");            
+                ");
 
             string[] configurations = p.GetConditionedProperties("Configuration");
 
@@ -1944,7 +1944,7 @@ public void ConfigurationsReferencedInVBProject()
                     <Import Project=`$(MSBuildBinPath)\Microsoft.VisualBasic.targets` />
                 </Project>
 
-                ");            
+                ");
 
             string[] configurations = p.GetConditionedProperties("Configuration");
 
@@ -1954,10 +1954,10 @@ public void ConfigurationsReferencedInVBProject()
         }
 
         /// <summary>
-        /// This is the infamous path-too-long problem.  All absolute paths in question are within 
-        /// the 260 character limit that the filesystem imposes.  However, when paths are accessed 
+        /// This is the infamous path-too-long problem.  All absolute paths in question are within
+        /// the 260 character limit that the filesystem imposes.  However, when paths are accessed
         /// using relative paths, sometimes the simple concatenation of the current directory with the
-        /// relative path can exceed 260 characters.  MSBuild should solve this scenario by doing 
+        /// relative path can exceed 260 characters.  MSBuild should solve this scenario by doing
         /// smarter path manipulation.
         /// </summary>
         [Test]
@@ -1972,7 +1972,7 @@ public void ProjectToProjectReferenceWithLongRelativePath()
             // minus 55 to leave room for ConsoleApp\obj\debug\ResolveAssemblyReference.cache
             // div 4 because that's how much each subdir costs.
             int MAX_PATH = 260;
-            int numberOfSubDirectoriesToCreate = (MAX_PATH - tempProjectRoot.Length - 55) / 4;  
+            int numberOfSubDirectoriesToCreate = (MAX_PATH - tempProjectRoot.Length - 55) / 4;
             StringBuilder deepRelativePath = new StringBuilder();
             for (int i = 0 ; i < numberOfSubDirectoriesToCreate ; i++)
             {
@@ -2087,7 +2087,7 @@ static void Main(string[] args)
                     </ItemGroup>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                     <!-- The old OM, which is what this solution is being built under, doesn't understand
-                         BeforeTargets, so this test was failing, because _AssignManagedMetadata was set 
+                         BeforeTargets, so this test was failing, because _AssignManagedMetadata was set
                          up as a BeforeTarget for Build.  Copied here so that build will return the correct
                          information again. -->
                     <Target Name=`BeforeBuild`>
@@ -2133,7 +2133,7 @@ public void SolutionConfigurationWithDifferentProjectConfigurations()
             // ==================================================================
             // SOLUTION1.SLN
             // ==================================================================
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("Solution1.sln", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("Solution1.sln",
                 @"Microsoft Visual Studio Solution File, Format Version 9.00
                  Visual Studio 2005
                 Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `CSharpClassLib`, `CSharpClassLib\CSharpClassLib.csproj`, `{9FB32A10-FA44-4DD3-ABA8-5215CF599BD6}`
@@ -2228,7 +2228,7 @@ Visual Studio 2005
                     <Folder Include=`Properties\` />
                   </ItemGroup>
                   <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=`BeforeBuild`>
                   </Target>
@@ -2296,7 +2296,7 @@ public class Class1
                     <Folder Include=`Properties\` />
                   </ItemGroup>
                   <Import Project=`$(MSBuildBinPath)\Microsoft.VisualJSharp.targets` />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=`BeforeBuild`>
                   </Target>
@@ -2417,7 +2417,7 @@ public void SkipProducingPdbCsharp()
             l = ObjectModelHelpers.BuildTempProjectFileWithTargetsExpectSuccess(@"ConsoleApplication\ConsoleApplication.csproj", null, additionalProperties, true);
             l.AssertLogContains("/debug+");
             l.AssertLogContains("/debug:pdbonly");
-            ObjectModelHelpers.AssertFileExistsInTempProjectDirectory(@"ConsoleApplication\bin\release\ConsoleApplication.pdb");        
+            ObjectModelHelpers.AssertFileExistsInTempProjectDirectory(@"ConsoleApplication\bin\release\ConsoleApplication.pdb");
         }
 
         /// <summary>
@@ -2670,7 +2670,7 @@ internal static void CreateTempVBProject()
                     <Compile Include=""Module1.vb"" />
                   </ItemGroup>
                   <Import Project=""$(MSBuildBinPath)\Microsoft.VisualBasic.targets"" />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
diff --git a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
index 84e458f6a54..0363d017928 100644
--- a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
+++ b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
@@ -218,7 +218,7 @@ public void TerminalLoggerDefaultOff(string defaultValue)
             TerminalLoggerUserIntentSource = null,
             ConsoleLogger = true,
             ConsoleLoggerVerbosity = "minimal",
-            ConsoleLoggerType = "parallel", 
+            ConsoleLoggerType = "parallel",
             FileLogger = false,
         };
 
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index dc353692197..db2d9eab3ad 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -358,7 +358,7 @@ public void TaskLogsWarningAsError_BatchedBuild()
                 logger.WarningCount.ShouldBe(2);
                 logger.ErrorCount.ShouldBe(1);
 
-                // The build should STOP when a task logs an error, make sure ReturnFailureWithoutLoggingErrorTask doesn't run. 
+                // The build should STOP when a task logs an error, make sure ReturnFailureWithoutLoggingErrorTask doesn't run.
                 logger.AssertLogDoesntContain("MSB1237");
             }
         }
diff --git a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
index cb4464c8460..5670a61e3f1 100644
--- a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
+++ b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
@@ -19,10 +19,10 @@ internal class LegacyThreadingData
     {
         #region Fields
         /// <summary>
-        /// Store the pair of start/end events used by a particular submission to track their ownership 
-        /// of the legacy thread. 
-        /// Item1: Start event, tracks when the submission has permission to start building. 
-        /// Item2: End event, signalled when that submission is no longer using the legacy thread. 
+        /// Store the pair of start/end events used by a particular submission to track their ownership
+        /// of the legacy thread.
+        /// Item1: Start event, tracks when the submission has permission to start building.
+        /// Item2: End event, signalled when that submission is no longer using the legacy thread.
         /// </summary>
         private readonly IDictionary<int, Tuple<AutoResetEvent, ManualResetEvent>> _legacyThreadingEventsById = new Dictionary<int, Tuple<AutoResetEvent, ManualResetEvent>>();
 
@@ -37,8 +37,8 @@ internal class LegacyThreadingData
         private RequestBuilder _instanceForMainThread;
 
         /// <summary>
-        /// Lock object for startNewRequestBuilderMainThreadEventsById, since it's possible for multiple submissions to be 
-        /// submitted at the same time. 
+        /// Lock object for startNewRequestBuilderMainThreadEventsById, since it's possible for multiple submissions to be
+        /// submitted at the same time.
         /// </summary>
         private readonly Object _legacyThreadingEventsLock = new Object();
         #endregion
@@ -79,7 +79,7 @@ internal int MainThreadSubmissionId
         #endregion
 
         /// <summary>
-        /// Given a submission ID, assign it "start" and "finish" events to track its use of 
+        /// Given a submission ID, assign it "start" and "finish" events to track its use of
         /// the legacy thread.
         /// </summary>
         internal void RegisterSubmissionForLegacyThread(int submissionId)
@@ -95,8 +95,8 @@ internal void RegisterSubmissionForLegacyThread(int submissionId)
         }
 
         /// <summary>
-        /// This submission is completely done with the legacy thread, so unregister it 
-        /// from the dictionary so that we don't leave random events lying around. 
+        /// This submission is completely done with the legacy thread, so unregister it
+        /// from the dictionary so that we don't leave random events lying around.
         /// </summary>
         internal void UnregisterSubmissionForLegacyThread(int submissionId)
         {
@@ -109,8 +109,8 @@ internal void UnregisterSubmissionForLegacyThread(int submissionId)
         }
 
         /// <summary>
-        /// Given a submission ID, return the event being used to track when that submission is ready 
-        /// to be executed on the legacy thread. 
+        /// Given a submission ID, return the event being used to track when that submission is ready
+        /// to be executed on the legacy thread.
         /// </summary>
         internal WaitHandle GetStartRequestBuilderMainThreadEventForSubmission(int submissionId)
         {
@@ -127,8 +127,8 @@ internal WaitHandle GetStartRequestBuilderMainThreadEventForSubmission(int submi
         }
 
         /// <summary>
-        /// Given a submission ID, return the event being used to track when that submission is ready 
-        /// to be executed on the legacy thread. 
+        /// Given a submission ID, return the event being used to track when that submission is ready
+        /// to be executed on the legacy thread.
         /// </summary>
         internal Task GetLegacyThreadInactiveTask(int submissionId)
         {
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index e0782c3fbf3..a7cfa92743e 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -437,7 +437,7 @@ private bool TrySendPacket(Func<INodePacket> packetResolver)
         }
 
         /// <summary>
-        /// Launches MSBuild server. 
+        /// Launches MSBuild server.
         /// </summary>
         /// <returns> Whether MSBuild server was started successfully.</returns>
         private bool TryLaunchServer()
@@ -511,7 +511,7 @@ private ServerNodeBuildCommand GetServerNodeBuildCommand()
                 envVars[pair.Key] = pair.Value;
             }
 
-            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. 
+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here.
             envVars.Remove(Traits.UseMSBuildServerEnvVarName);
 
             Debug.Assert(KnownTelemetry.PartialBuildTelemetry == null || KnownTelemetry.PartialBuildTelemetry.StartAt.HasValue, "BuildTelemetry.StartAt was not initialized!");
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 784116cf854..4c2be1f5a97 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -201,7 +201,7 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                 bool continueReading = true;
                 do
                 {
-                    // Ordering of the wait handles is important. The first signalled wait handle in the array 
+                    // Ordering of the wait handles is important. The first signalled wait handle in the array
                     // will be returned by WaitAny if multiple wait handles are signalled. We prefer to have the
                     // terminate event triggered so that we cannot get into a situation where packets are being
                     // spammed to the client and it never gets an opportunity to shutdown.
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index c4d543c87da..70a4bf0aeef 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -89,7 +89,7 @@ public void RegisterDefaultFactories()
         }
 
         /// <summary>
-        /// Shuts down all factories registered to this component factory collection. 
+        /// Shuts down all factories registered to this component factory collection.
         /// </summary>
         public void ShutdownComponents()
         {
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 1ded6e6fc8a..e7eb3675469 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -31,8 +31,8 @@ internal enum BuildRequestEntryState
         /// being actively built by the engine - i.e. it has a running task thread.  All other requests
         /// must be in one of the other states.  When in this state, the outstandingRequest and
         /// receivedResult members must be null.
-        /// 
-        /// Transitions: 
+        ///
+        /// Transitions:
         ///     Waiting:  When an msbuild callback is made the active build request needs to wait
         ///               for the results in order to continue to process.
         ///     Complete: The build request has generated all of the required results.
@@ -41,21 +41,21 @@ internal enum BuildRequestEntryState
 
         /// <summary>
         /// This state means the node has received all of the results needed to continue processing this
-        /// request.  When this state is set, the receivedResult member of this entry must be non-null.  
+        /// request.  When this state is set, the receivedResult member of this entry must be non-null.
         /// The request engine can continue it at some later point when it is no longer busy.
         /// Any number of entries may be in this state.
-        /// 
+        ///
         /// Transitions:
         ///         Active: The build request engine picks this ready request to process.
         /// </summary>
         Ready,
 
         /// <summary>
-        /// This state means the node is waiting for results from outstanding build requests.  When this 
-        /// state is set, the outstandingRequest or outstandingConfiguration members of the entry 
+        /// This state means the node is waiting for results from outstanding build requests.  When this
+        /// state is set, the outstandingRequest or outstandingConfiguration members of the entry
         /// must be non-null.
-        /// 
-        /// Transitions: 
+        ///
+        /// Transitions:
         ///           Ready: All of the results which caused the build request to wait have been received
         /// </summary>
         Waiting,
@@ -63,7 +63,7 @@ internal enum BuildRequestEntryState
         /// <summary>
         /// This state means the request has completed and results are available.  The engine will remove
         /// the request from the list and the results will be returned to the node for processing.
-        /// 
+        ///
         /// Transitions: None, this is the final state of the build request
         /// </summary>
         Complete
@@ -342,7 +342,7 @@ public void ReportResult(BuildResult result)
                 {
                     _outstandingRequests.Remove(result.NodeRequestId);
 
-                    // If we wish to implement behavior where we stop building after the first failing request, then check for 
+                    // If we wish to implement behavior where we stop building after the first failing request, then check for
                     // overall results being failure rather than just circular dependency. Sync with BasicScheduler.ReportResult and
                     // BasicScheduler.ReportRequestBlocked.
                     if (result.CircularDependency || (_outstandingRequests.Count == 0 && (_unresolvedConfigurations == null || _unresolvedConfigurations.Count == 0)))
@@ -475,7 +475,7 @@ public void Complete(BuildResult result)
                 ErrorUtilities.VerifyThrow(Result == null, "Entry already Completed.");
 
                 // If this request is determined to be a success, then all outstanding items must have been taken care of
-                // and it must be in the correct state.  It can complete unsuccessfully for a variety of reasons in a variety 
+                // and it must be in the correct state.  It can complete unsuccessfully for a variety of reasons in a variety
                 // of states.
                 if (result.OverallResult == BuildResultCode.Success)
                 {
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
index fe0362d6fba..fac725d8149 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
@@ -139,7 +139,7 @@ internal interface IBuildRequestEngine
 
         #region Methods
         /// <summary>
-        /// Prepares the engine for a new build and spins up the engine thread.  
+        /// Prepares the engine for a new build and spins up the engine thread.
         /// The engine must be in the Idle state, and not already be initialized.
         /// </summary>
         /// <param name="loggingContext">The logging context for the node.</param>
@@ -154,7 +154,7 @@ internal interface IBuildRequestEngine
         void CleanupForBuild();
 
         /// <summary>
-        /// Submits the specified request to the build queue. 
+        /// Submits the specified request to the build queue.
         /// </summary>
         /// <param name="request">The request to build.</param>
         /// <remarks>It is only valid to call this method when the engine is in the Idle or
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index 15d06a15c93..7bc41b77750 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -148,7 +148,7 @@ public BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata
                 else if (loadProject)
                 {
                     // We already had a configuration, load the project
-                    // If it exists but it cached, retrieve it 
+                    // If it exists but it cached, retrieve it
                     if (configuration.IsCached)
                     {
                         configuration.RetrieveFromCache();
diff --git a/src/Build/BackEnd/Components/Caching/IConfigCache.cs b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
index c0bfc8b5461..83b13f615fe 100644
--- a/src/Build/BackEnd/Components/Caching/IConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
@@ -77,7 +77,7 @@ BuildRequestConfiguration this[int configId]
         void ClearConfigurations();
 
         /// <summary>
-        /// Clear non explicltly loaded configurations. 
+        /// Clear non explicltly loaded configurations.
         /// </summary>
         /// <returns>The configuration ids which have been cleared.</returns>
         List<int> ClearNonExplicitlyLoadedConfigurations();
diff --git a/src/Build/BackEnd/Components/Caching/IResultsCache.cs b/src/Build/BackEnd/Components/Caching/IResultsCache.cs
index c1786e8dbb2..b1d70409322 100644
--- a/src/Build/BackEnd/Components/Caching/IResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IResultsCache.cs
@@ -49,9 +49,9 @@ internal interface IResultsCache : IBuildComponent, ITranslatable, IEnumerable<B
         /// <param name="request">The request whose results we should return</param>
         /// <param name="configInitialTargets">The initial targets for the request's configuration.</param>
         /// <param name="configDefaultTargets">The default targets for the request's configuration.</param>
-        /// <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".  
-        /// If true, then as long as there is a result in the cache (regardless of whether it was skipped or not), this method 
-        /// will return "Satisfied". In most cases this should be false, but it may be set to true in a situation where there is no 
+        /// <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".
+        /// If true, then as long as there is a result in the cache (regardless of whether it was skipped or not), this method
+        /// will return "Satisfied". In most cases this should be false, but it may be set to true in a situation where there is no
         /// chance of re-execution (which is the usual response to missing / skipped targets), and the caller just needs the data.</param>
         /// <returns>A response indicating the results, if any, and the targets needing to be built, if any.</returns>
         ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> configInitialTargets, List<string> configDefaultTargets, bool skippedResultsDoNotCauseCacheMiss);
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 41013a9701e..d8167fe45b0 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -148,9 +148,9 @@ public BuildResult GetResultsForConfiguration(int configurationId)
         /// <param name="request">The request whose results we should return</param>
         /// <param name="configInitialTargets">The initial targets for the request's configuration.</param>
         /// <param name="configDefaultTargets">The default targets for the request's configuration.</param>
-        /// <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".  
-        /// If true, then as long as there is a result in the cache (regardless of whether it was skipped or not), this method 
-        /// will return "Satisfied". In most cases this should be false, but it may be set to true in a situation where there is no 
+        /// <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".
+        /// If true, then as long as there is a result in the cache (regardless of whether it was skipped or not), this method
+        /// will return "Satisfied". In most cases this should be false, but it may be set to true in a situation where there is no
         /// chance of re-execution (which is the usual response to missing / skipped targets), and the caller just needs the data.</param>
         /// <returns>A response indicating the results, if any, and the targets needing to be built, if any.</returns>
         public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> configInitialTargets, List<string> configDefaultTargets, bool skippedResultsDoNotCauseCacheMiss)
@@ -298,7 +298,7 @@ internal static IBuildComponent CreateComponent(BuildComponentType componentType
         /// <param name="result">The result to examine</param>
         /// <param name="targets">The targets to search for</param>
         /// <param name="targetsMissingResults">An optional list to be populated with missing targets</param>
-        /// <param name="skippedResultsAreOK">If true, a status of "skipped" counts as having valid results 
+        /// <param name="skippedResultsAreOK">If true, a status of "skipped" counts as having valid results
         /// for that target.  Otherwise, a skipped target is treated as equivalent to a missing target.</param>
         /// <returns>False if there were missing results, true otherwise.</returns>
         private static bool CheckResults(BuildResult result, List<string> targets, HashSet<string> targetsMissingResults, bool skippedResultsAreOK)
@@ -320,7 +320,7 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
                 }
                 else
                 {
-                    // If the result was a failure and we have not seen any skipped targets up to this point, then we conclude we do 
+                    // If the result was a failure and we have not seen any skipped targets up to this point, then we conclude we do
                     // have results for this request, and they indicate failure.
                     if (result[target].ResultCode == TargetResultCode.Failure && (targetsMissingResults == null || targetsMissingResults.Count == 0))
                     {
diff --git a/src/Build/BackEnd/Components/Communications/INodeProvider.cs b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
index 2cb875e0764..0deb352e9e5 100644
--- a/src/Build/BackEnd/Components/Communications/INodeProvider.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
@@ -30,7 +30,7 @@ internal enum NodeProviderType
     }
 
     /// <summary>
-    /// This interface represents a collection of nodes in the system.  It provides methods to 
+    /// This interface represents a collection of nodes in the system.  It provides methods to
     /// enumerate active nodes as well as send data and receive events from those nodes.
     /// </summary>
     internal interface INodeProvider : IBuildComponent
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 4c7c7fbd385..68843247305 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -65,7 +65,7 @@ internal class NodeEndpointInProc : INodeEndpoint
 
         /// <summary>
         /// Set when a packet is available in the packet queue
-        /// </summary>      
+        /// </summary>
         private AutoResetEvent _packetAvailable;
 
         /// <summary>
@@ -84,7 +84,7 @@ internal class NodeEndpointInProc : INodeEndpoint
         private bool _peerConnected;
 
         /// <summary>
-        /// The asynchronous packet queue.  
+        /// The asynchronous packet queue.
         /// </summary>
         /// <remarks>
         /// Operations on this queue must be synchronized since it is accessible by multiple threads.
@@ -175,7 +175,7 @@ public void Listen(INodePacketFactory factory)
         }
 
         /// <summary>
-        /// Causes this node to connect to the matched endpoint.  
+        /// Causes this node to connect to the matched endpoint.
         /// </summary>
         /// <param name="factory">Unused</param>
         public void Connect(INodePacketFactory factory)
@@ -266,7 +266,7 @@ private void RaiseLinkStatusChanged(LinkStatus newStatus)
             }
         }
 
-        #endregion 
+        #endregion
 
         #region Private Methods
 
@@ -416,7 +416,7 @@ private void PacketPumpProc()
         {
             try
             {
-                // Ordering of the wait handles is important.  The first signalled wait handle in the array 
+                // Ordering of the wait handles is important.  The first signalled wait handle in the array
                 // will be returned by WaitAny if multiple wait handles are signalled.  We prefer to have the
                 // terminate event triggered so that we cannot get into a situation where packets are being
                 // spammed to the endpoint and it never gets an opportunity to shutdown.
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index f05aa33f9f6..b0031746031 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -11,7 +11,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// The NodeManager class is responsible for marshalling data to/from the NodeProviders and organizing the 
+    /// The NodeManager class is responsible for marshalling data to/from the NodeProviders and organizing the
     /// creation of new nodes on request.
     /// </summary>
     internal class NodeManager : INodeManager
@@ -23,7 +23,7 @@ internal class NodeManager : INodeManager
 
         /// <summary>
         /// The node provider for out-of-proc nodes.
-        /// </summary> 
+        /// </summary>
         private INodeProvider? _outOfProcNodeProvider;
 
         /// <summary>
@@ -56,9 +56,9 @@ internal class NodeManager : INodeManager
         /// BUGBUG: This is a fix which corrects an RI blocking BVT failure.  The real fix must be determined before RTM.
         /// This must be investigated and resolved before RTM.  The apparent issue is that a design-time build has already called EndBuild
         /// through the BuildManagerAccessor, and the nodes are shut down.  Shortly thereafter, the solution build manager comes through and calls EndBuild, which throws
-        /// another Shutdown packet in the queue, and causes the following build to stop prematurely.  This is all timing related - not every sequence of builds seems to 
+        /// another Shutdown packet in the queue, and causes the following build to stop prematurely.  This is all timing related - not every sequence of builds seems to
         /// cause the problem, probably due to the order in which the packet queue gets serviced relative to other threads.
-        /// 
+        ///
         /// It appears that the problem is that the BuildRequestEngine is being invoked in a way that causes a shutdown packet to appear to overlap with a build request packet.
         /// Interactions between the in-proc node communication thread and the shutdown mechanism must be investigated to determine how BuildManager.EndBuild is allowing itself
         /// to return before the node has indicated it is actually finished.
@@ -66,7 +66,7 @@ internal class NodeManager : INodeManager
         private bool _nodesShutdown = true;
 
         /// <summary>
-        /// Tracks whether ShutdownComponent has been called.  
+        /// Tracks whether ShutdownComponent has been called.
         /// </summary>
         private bool _componentShutdown;
 
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index ad7730289d5..e7e66d6b886 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -12,13 +12,13 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// The NodeManager class is responsible for marshalling data to/from the NodeProviders and organizing the 
+    /// The NodeManager class is responsible for marshalling data to/from the NodeProviders and organizing the
     /// creation of new nodes on request.
     /// </summary>
     internal class TaskHostNodeManager : INodeManager
     {
         /// <summary>
-        /// The node provider for task hosts. 
+        /// The node provider for task hosts.
         /// </summary>
         private INodeProvider _outOfProcTaskHostNodeProvider;
 
@@ -28,7 +28,7 @@ internal class TaskHostNodeManager : INodeManager
         private IBuildComponentHost _componentHost;
 
         /// <summary>
-        /// Tracks whether ShutdownComponent has been called.  
+        /// Tracks whether ShutdownComponent has been called.
         /// </summary>
         private bool _componentShutdown;
 
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index 0abf972541a..912c37ee0ca 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -14,9 +14,9 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// This class is responsible for serializing and deserializing anything that is not 
-    /// officially supported by ITranslator, but that we still want to do 
-    /// custom translation of.  
+    /// This class is responsible for serializing and deserializing anything that is not
+    /// officially supported by ITranslator, but that we still want to do
+    /// custom translation of.
     /// </summary>
     internal static class TranslatorExtensions
     {
diff --git a/src/Build/BackEnd/Components/IBuildComponent.cs b/src/Build/BackEnd/Components/IBuildComponent.cs
index e79f6a24444..411350f4278 100644
--- a/src/Build/BackEnd/Components/IBuildComponent.cs
+++ b/src/Build/BackEnd/Components/IBuildComponent.cs
@@ -6,7 +6,7 @@ namespace Microsoft.Build.BackEnd
     /// <summary>
     /// Each component in the build system which is registered with the Build Manager or a Node must
     /// implement this interface.
-    /// 
+    ///
     /// REFACTOR: Maybe these could all implement IDisposable.
     /// </summary>
     internal interface IBuildComponent
diff --git a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
index ccaf8c46ea1..893d8796e7d 100644
--- a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
@@ -47,7 +47,7 @@ internal BuildEventArgTransportSink(SendDataDelegate sendData)
 
         #region Properties
         /// <summary>
-        /// Provide a friendly name for the sink to make it easier to differentiate during 
+        /// Provide a friendly name for the sink to make it easier to differentiate during
         /// debugging and display
         /// </summary>
         public string Name
diff --git a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
index eb2fe9a8cee..17d2e672250 100644
--- a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
+++ b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
@@ -16,7 +16,7 @@ internal class CentralForwardingLogger : IForwardingLogger
         #region Properties
 
         /// <summary>
-        /// An IEventRedirector which will redirect any events forwarded from the logger. The eventRedirector determines where the events will 
+        /// An IEventRedirector which will redirect any events forwarded from the logger. The eventRedirector determines where the events will
         /// be redirected.
         /// </summary>
         public IEventRedirector BuildEventRedirector
@@ -59,7 +59,7 @@ public string Parameters
         #region Public
 
         /// <summary>
-        /// Initialize the logger with an eventSource and a node count. 
+        /// Initialize the logger with an eventSource and a node count.
         /// The logger will register and listen to anyEvents on the eventSource.
         /// The node count is for informational purposes. The logger may want to take different
         /// actions depending on how many nodes there are in the system.
@@ -102,7 +102,7 @@ public void Shutdown()
         #region Private
 
         /// <summary>
-        /// Forwards any event raised to the BuildEventRedirector, this redirector will send the event on a path which will 
+        /// Forwards any event raised to the BuildEventRedirector, this redirector will send the event on a path which will
         /// take it to a logger.
         /// </summary>
         /// <param name="sender">Who sent the message, this is not used</param>
@@ -110,7 +110,7 @@ public void Shutdown()
         private void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent)
         {
             // If no central logger was registered with the system
-            // there will not be a build event redirector as there is 
+            // there will not be a build event redirector as there is
             // nowhere to forward the events to.
             BuildEventRedirector?.ForwardEvent(buildEvent);
         }
diff --git a/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs b/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs
index edf9d9d2f3e..de3a78aea4a 100644
--- a/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs
@@ -28,7 +28,7 @@ internal class EventRedirectorToSink : IEventRedirector
         #region Constructors
         /// <summary>
         /// Initalize this class with a central logger id identifying the central logger to which
-        /// these events should consumed by. The redirector will send the messages to the registered sink to 
+        /// these events should consumed by. The redirector will send the messages to the registered sink to
         /// be consumed
         /// </summary>
         /// <param name="loggerId">Id which will be attached to the build event arguments to indicate which logger the events came from</param>
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index e76797ee3cc..5e5e883ff08 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -83,8 +83,8 @@ internal sealed class EventSourceSink :
         public event CustomBuildEventHandler CustomEventRaised;
 
         /// <summary>
-        /// this event is raised to log build status events, such as 
-        /// build/project/target/task started/stopped 
+        /// this event is raised to log build status events, such as
+        /// build/project/target/task started/stopped
         /// </summary>
         public event BuildStatusEventHandler StatusEventRaised;
 
@@ -102,7 +102,7 @@ internal sealed class EventSourceSink :
 
         #region Properties
         /// <summary>
-        /// Provide a friendly name for the sink to make it easier to differentiate during 
+        /// Provide a friendly name for the sink to make it easier to differentiate during
         /// debugging and display
         /// </summary>
         public string Name
@@ -313,7 +313,7 @@ internal void UnregisterAllEventHandlers()
         /// <param name="buildEvent">BuildMessageEventArgs</param>
         /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
         /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception> 
+        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
         private void RaiseMessageEvent(object sender, BuildMessageEventArgs buildEvent)
         {
             if (MessageRaised != null)
@@ -875,9 +875,9 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                     // if a fellow logger is throwing in an event handler.
                     this.UnregisterAllEventHandlers();
 
-                    // We ought to dump this farther up the stack, but if for example a task is logging an event within a 
-                    // catch(Exception) block and not rethrowing it, there's the possibility that this exception could 
-                    // just get silently eaten.  So better to have duplicates than to not log the problem at all. :) 
+                    // We ought to dump this farther up the stack, but if for example a task is logging an event within a
+                    // catch(Exception) block and not rethrowing it, there's the possibility that this exception could
+                    // just get silently eaten.  So better to have duplicates than to not log the problem at all. :)
                     ExceptionHandling.DumpExceptionToFile(exception);
 
                     throw;
@@ -888,9 +888,9 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                     // if a fellow logger is throwing in an event handler.
                     this.UnregisterAllEventHandlers();
 
-                    // We ought to dump this farther up the stack, but if for example a task is logging an event within a 
-                    // catch(Exception) block and not rethrowing it, there's the possibility that this exception could 
-                    // just get silently eaten.  So better to have duplicates than to not log the problem at all. :) 
+                    // We ought to dump this farther up the stack, but if for example a task is logging an event within a
+                    // catch(Exception) block and not rethrowing it, there's the possibility that this exception could
+                    // just get silently eaten.  So better to have duplicates than to not log the problem at all. :)
                     ExceptionHandling.DumpExceptionToFile(exception);
 
                     if (ExceptionHandling.IsCriticalException(exception))
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index a3b78640194..6d4973bc223 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -100,7 +100,7 @@ ICollection<ILogger> Loggers
 
         /// <summary>
         /// The list of descriptions which describe how to create forwarding loggers on a node.
-        /// This is used by the node provider to get a list of registered descriptions so that 
+        /// This is used by the node provider to get a list of registered descriptions so that
         /// they can be transmitted to child nodes.
         /// </summary>
         ICollection<LoggerDescription> LoggerDescriptions
@@ -616,13 +616,13 @@ BuildEventContext LogProjectStarted(
     }
 
     /// <summary>
-    /// Acts as an endpoint for a buildEventArg. The objects which implement this interface are intended to consume the BuildEventArg. 
+    /// Acts as an endpoint for a buildEventArg. The objects which implement this interface are intended to consume the BuildEventArg.
     /// </summary>
     internal interface IBuildEventSink
     {
         #region Properties
         /// <summary>
-        /// Provide a the sink a friendly name which can be used to distinguish sinks in memory 
+        /// Provide a the sink a friendly name which can be used to distinguish sinks in memory
         /// and for display
         /// </summary>
         string Name
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 1efec57dc44..15b6000a7aa 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -77,7 +77,7 @@ public ILoggingService LoggingService
         /// <summary>
         /// Retrieves the build event context
         /// UNDONE: (Refactor) We eventually want to remove this because all logging should go
-        /// through a context object.  This exists only so we can make certain 
+        /// through a context object.  This exists only so we can make certain
         /// logging calls in code which has not yet been fully refactored.
         /// </summary>
         public BuildEventContext BuildEventContext
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 2f95ae3f180..1456039d1ba 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -998,13 +998,13 @@ public bool RegisterLogger(ILogger logger)
 
                     // Get the Id of the eventSourceSink which was created for the first logger.
                     // We keep a reference to this Id so that all other central loggers registered on this logging service (from registerLogger)
-                    // will be attached to that eventSource sink so that they get all of the events forwarded by 
+                    // will be attached to that eventSource sink so that they get all of the events forwarded by
                     // forwarded by the CentralForwardingLogger
                     _centralForwardingLoggerSinkId = centralForwardingLoggerDescription.LoggerId;
                 }
                 else
                 {
-                    // We have already create a forwarding logger and have a single eventSink which 
+                    // We have already create a forwarding logger and have a single eventSink which
                     // a logger can listen to inorder to get all events in the system
                     EventSourceSink eventSource = (EventSourceSink)_eventSinkDictionary[_centralForwardingLoggerSinkId];
 
@@ -1035,7 +1035,7 @@ public void UnregisterAllLoggers()
                 }
             }
 
-            // UNDONE: (Logging) This should re-initialize this logging service. 
+            // UNDONE: (Logging) This should re-initialize this logging service.
         }
 
         /// <summary>
@@ -1641,10 +1641,10 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
                 // them.
                 _filterEventSource.Consume(eventArg);
 
-                // Now that the forwarding loggers have been given the chance to log the build started and finished events we need to check the 
+                // Now that the forwarding loggers have been given the chance to log the build started and finished events we need to check the
                 // central logger sinks to see if they have received the events or not. If the sink has not received the event we need to send it to the
                 // logger for backwards compatibility with orcas.
-                // In addition we need to make sure we manually forward the events because in orcas the forwarding loggers were not allowed to 
+                // In addition we need to make sure we manually forward the events because in orcas the forwarding loggers were not allowed to
                 // forward build started or build finished events. In the new OM we allow the loggers to forward the events. However since orcas did not forward them
                 // we need to support loggers which cannot forward the events.
                 if (eventArg is BuildStartedEventArgs)
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 33c747f9eb0..87ccf3c3fdf 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -26,7 +26,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// Logs a comment (BuildMessageEventArgs) with a certain MessageImportance level
         /// </summary>
         /// <param name="buildEventContext">Event context information which describes who is logging the event</param>
-        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on. 
+        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on.
         /// The higher the importance the lower the verbosity needs to be for the message to be seen</param>
         /// <param name="messageResourceName">String which identifies the message in the string resx</param>
         /// <param name="messageArgs">Arguments for the format string indexed by messageResourceName</param>
@@ -45,7 +45,7 @@ public void LogComment(BuildEventContext buildEventContext, MessageImportance im
         /// Log a comment
         /// </summary>
         /// <param name="buildEventContext">Event context information which describes who is logging the event</param>
-        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on. 
+        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on.
         /// The higher the importance the lower the verbosity needs to be for the message to be seen</param>
         /// <param name="message">Message to log</param>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
@@ -59,7 +59,7 @@ public void LogCommentFromText(BuildEventContext buildEventContext, MessageImpor
         /// Log a comment
         /// </summary>
         /// <param name="buildEventContext">Event context information which describes who is logging the event</param>
-        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on. 
+        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on.
         /// The higher the importance the lower the verbosity needs to be for the message to be seen</param>
         /// <param name="message">Message to log</param>
         /// <param name="messageArgs">Message formatting arguments</param>
@@ -368,7 +368,7 @@ public void LogWarningFromText(BuildEventContext buildEventContext, string subca
         #region Log status
 
         /// <summary>
-        /// Logs that the build has started 
+        /// Logs that the build has started
         /// </summary>
         public void LogBuildStarted()
         {
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index 7bff292f0e1..3d9a25df6cc 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -121,7 +121,7 @@ internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectT
         /// </summary>
         /// <remarks>
         /// This class is designed to be passed to loggers.
-        /// The expense of copying items is only incurred if and when 
+        /// The expense of copying items is only incurred if and when
         /// a logger chooses to enumerate over it.
         /// </remarks>
         internal class TargetOutputItemsInstanceEnumeratorProxy : IEnumerable<TaskItem>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index c5852c97d30..646381478b9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -19,26 +19,26 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     /// <remarks>
     /// What batching does
-    /// 
-    /// Batching partitions the items consumed by the batchable object into buckets, where each bucket 
-    /// contains a set of items that have the same value set on all item metadata consumed by the object. 
-    /// Metadata consumed may be unqualified, for example %(m), or qualified by the item list to which it 
+    ///
+    /// Batching partitions the items consumed by the batchable object into buckets, where each bucket
+    /// contains a set of items that have the same value set on all item metadata consumed by the object.
+    /// Metadata consumed may be unqualified, for example %(m), or qualified by the item list to which it
     /// refers, for example %(a.m).
-    /// 
-    /// If metadata is qualified, for example %(a.m), then this is considered distinct to metadata with the 
-    /// same name on a different item type. For example, %(a.m) is distinct to %(b.m), and items of type b 
-    /// are considered to always have a blank value for %(a.m). This means items of type b will only be 
+    ///
+    /// If metadata is qualified, for example %(a.m), then this is considered distinct to metadata with the
+    /// same name on a different item type. For example, %(a.m) is distinct to %(b.m), and items of type b
+    /// are considered to always have a blank value for %(a.m). This means items of type b will only be
     /// placed in buckets where %(a.m) is blank. However %(a.m) is equivalent to %(m) on items of type a.
-    /// 
-    /// There is an extra ambiguity rule: every items consumed by the object must have an explicit value for 
-    /// every piece of unqualified metadata. For example, if @(a), %(m), and %(a.n) are consumed, every item 
-    /// of type a must have a value for the metadata m but need not all necessarily have a value for the 
-    /// metadata n. This rule eliminates ambiguity about whether items that do not define values for an 
-    /// unqualified metadata should go in all buckets, or just into buckets with a blank value for 
+    ///
+    /// There is an extra ambiguity rule: every items consumed by the object must have an explicit value for
+    /// every piece of unqualified metadata. For example, if @(a), %(m), and %(a.n) are consumed, every item
+    /// of type a must have a value for the metadata m but need not all necessarily have a value for the
+    /// metadata n. This rule eliminates ambiguity about whether items that do not define values for an
+    /// unqualified metadata should go in all buckets, or just into buckets with a blank value for
     /// that metadata.
-    /// 
-    /// For example 
-    /// 
+    ///
+    /// For example
+    ///
     /// <ItemGroup>
     /// <a Include='a1;a2'>
     ///   <n>m0</n>
@@ -54,19 +54,19 @@ namespace Microsoft.Build.BackEnd
     /// </b>
     /// <b Include='b4'/>
     /// </ItemGroup>
-    /// 
+    ///
     /// <Target Name="t" >
     ///   <Message Text="a={@(a).%(a.n)} b={@(b).%(b.n)}" />
     /// </Target>
-    /// 
-    /// Will produce 5 buckets: 
-    /// 
+    ///
+    /// Will produce 5 buckets:
+    ///
     /// a={a1;a2.m0} b={.}
     /// a={a3.m1} b={.}
     /// a={.} b={b1.n0}
     /// a={.} b={b2;b3.n1}
     /// a={.} b={b4.}
-    /// 
+    ///
     /// </remarks>
     internal static class BatchingEngine
     {
@@ -113,14 +113,14 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
 
             ItemsAndMetadataPair pair = ExpressionShredder.GetReferencedItemNamesAndMetadata(batchableObjectParameters);
 
-            // All the @(itemname) item list references in the tag, including transforms, etc.        
+            // All the @(itemname) item list references in the tag, including transforms, etc.
             HashSet<string> consumedItemReferences = pair.Items;
 
-            // All the %(itemname.metadataname) references in the tag (not counting those embedded 
+            // All the %(itemname.metadataname) references in the tag (not counting those embedded
             // inside item transforms), and note that the itemname portion is optional.
             // The keys in the returned hash table are the qualified metadata names (e.g. "EmbeddedResource.Culture"
-            // or just "Culture").  The values are MetadataReference structs, which simply split out the item 
-            // name (possibly null) and the actual metadata name.            
+            // or just "Culture").  The values are MetadataReference structs, which simply split out the item
+            // name (possibly null) and the actual metadata name.
             Dictionary<string, MetadataReference> consumedMetadataReferences = pair.Metadata;
 
             List<ItemBucket> buckets = null;
@@ -136,14 +136,14 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
                 // This method goes through all the item list references and figures out which ones
                 // will be participating in batching, and which ones won't.  We get back a hashtable
                 // where the key is the item name that will be participating in batching.  The values
-                // are all String.Empty (not used).  This method may return additional item names 
+                // are all String.Empty (not used).  This method may return additional item names
                 // that weren't represented in "consumedItemReferences"... this would happen if there
-                // were qualified metadata references in the consumedMetadataReferences table, such as 
+                // were qualified metadata references in the consumedMetadataReferences table, such as
                 // %(EmbeddedResource.Culture).
                 Dictionary<string, ICollection<ProjectItemInstance>> itemListsToBeBatched = GetItemListsToBeBatched(consumedMetadataReferences, consumedItemReferences, lookup, elementLocation);
 
-                // At this point, if there were any metadata references in the tag, but no item 
-                // references to batch on, we've got a problem because we can't figure out which 
+                // At this point, if there were any metadata references in the tag, but no item
+                // references to batch on, we've got a problem because we can't figure out which
                 // item lists the user wants us to batch.
                 if (itemListsToBeBatched.Count == 0)
                 {
@@ -178,16 +178,16 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
 
         /// <summary>
         /// Of all the item lists that are referenced in this batchable object, which ones should we
-        /// batch on, and which ones should we just pass in wholesale to every invocation of the 
+        /// batch on, and which ones should we just pass in wholesale to every invocation of the
         /// target/task?
-        /// 
+        ///
         /// Rule #1.  If the user has referenced any *qualified* item metadata such as %(EmbeddedResource.Culture),
         /// then that item list "EmbeddedResource" will definitely get batched.
-        /// 
-        /// Rule #2.  For all the unqualified item metadata such as %(Culture), we make sure that 
+        ///
+        /// Rule #2.  For all the unqualified item metadata such as %(Culture), we make sure that
         /// every single item in every single item list being passed into the task contains a value
         /// for that metadata.  If not, it's an error.  If so, we batch all of those item lists.
-        /// 
+        ///
         /// All other item lists will not be batched, and instead will be passed in wholesale to all buckets.
         /// </summary>
         /// <returns>Dictionary containing the item names that should be batched.  If the items match unqualified metadata,
@@ -212,11 +212,11 @@ private static Dictionary<string, ICollection<ProjectItemInstance>> GetItemLists
                 if (consumedMetadataReference.ItemName != null)
                 {
                     // Rule #1.  Qualified metadata reference.
-                    // For metadata references that are qualified with an item name 
-                    // (e.g., %(EmbeddedResource.Culture) ), we add that item name to the list of 
+                    // For metadata references that are qualified with an item name
+                    // (e.g., %(EmbeddedResource.Culture) ), we add that item name to the list of
                     // consumed item names, even if the item name wasn't otherwise referenced via
                     // @(...) syntax, and even if every item in the list doesn't necessary contain
-                    // a value for this metadata.  This is the special power that you get by qualifying 
+                    // a value for this metadata.  This is the special power that you get by qualifying
                     // the metadata reference with an item name.
                     itemListsToBeBatched[consumedMetadataReference.ItemName] = null;
 
@@ -224,7 +224,7 @@ private static Dictionary<string, ICollection<ProjectItemInstance>> GetItemLists
                     // %(EmbeddedResource.Culture) effectively means that @(EmbeddedResource) is
                     // being consumed, even though we may not see literally "@(EmbeddedResource)"
                     // in the tag anywhere.  Adding it to this list allows us (down below in this
-                    // method) to check that every item in this list has a value for each 
+                    // method) to check that every item in this list has a value for each
                     // unqualified metadata reference.
                     consumedItemReferenceNames ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                     consumedItemReferenceNames.Add(consumedMetadataReference.ItemName);
@@ -364,7 +364,7 @@ private static List<ItemBucket> BucketConsumedItems(
         /// <summary>
         /// Gets the values of the specified metadata for the given item.
         /// The keys in the dictionary returned may be qualified and/or unqualified, exactly
-        /// as they are found in the metadata reference. 
+        /// as they are found in the metadata reference.
         /// For example if %(x) is found, the key is "x", if %(z.x) is found, the key is "z.x".
         /// This dictionary in each bucket is used by Expander to expand exactly the same metadata references, so
         /// %(x) is expanded using the key "x", and %(z.x) is expanded using the key "z.x".
@@ -393,7 +393,7 @@ private static Dictionary<string, string> GetItemMetadataValues(
                 {
                     try
                     {
-                        // This returns String.Empty for both metadata that is undefined and metadata that has 
+                        // This returns String.Empty for both metadata that is undefined and metadata that has
                         // an empty value; they are treated the same.
                         itemMetadataValues[metadataQualifiedName] = ((IItem)item).GetMetadataValueEscaped(metadataName);
                     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs b/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs
index 51fe0d9196d..7f0b5c187e6 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs
@@ -15,14 +15,14 @@ namespace Microsoft.Build.BackEnd
     internal interface ITargetBuilderCallback : IRequestBuilderCallback
     {
         /// <summary>
-        /// Invokes the specified targets using Dev9 behavior.  
+        /// Invokes the specified targets using Dev9 behavior.
         /// </summary>
         /// <param name="targets">The targets to build.</param>
         /// <param name="continueOnError">True to continue building the remaining targets if one fails.</param>
         /// <param name="referenceLocation">The <see cref="ElementLocation"/> of the reference.</param>
         /// <returns>The results for each target.</returns>
         /// <remarks>
-        /// The target is run using the data context of the Project, rather than the data context 
+        /// The target is run using the data context of the Project, rather than the data context
         /// of the current target.  This has the following effects:
         /// 1. Data visible to the CALLING target at the time it was first invoked is the only
         ///    data which the CALLED target can see.  No changes made between the time the CALLING
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ITaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/ITaskBuilder.cs
index b274bd8b11c..5daea9c8d78 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ITaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ITaskBuilder.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.BackEnd
     internal enum TaskExecutionMode
     {
         /// <summary>
-        /// This entry is necessary to use the enum with binary math. It is never used outside 
+        /// This entry is necessary to use the enum with binary math. It is never used outside
         /// intermediate calculations.
         /// </summary>
         Invalid = 0,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
index 74d4f09524a..94c1ee183ac 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
@@ -83,7 +83,7 @@ internal static IntrinsicTask InstantiateTask(ProjectTargetInstanceChild taskIns
         }
 
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         /// <param name="lookup">The lookup used for expansion and to receive created items and properties.</param>
         internal abstract void ExecuteTask(Lookup lookup);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
index 6e6c793ecc2..7d5eb31fc38 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
@@ -32,7 +32,7 @@ internal class CallTarget : ITask
         private readonly List<ITaskItem> _targetOutputs = new List<ITaskItem>();
 
         /// <summary>
-        /// A list of targets to build.  This is a required parameter.  If you want to build the 
+        /// A list of targets to build.  This is a required parameter.  If you want to build the
         /// default targets, use the <see cref="MSBuild"/> task and pass in Projects=$(MSBuildProjectFile).
         /// </summary>
         /// <value>Array of target names.</value>
@@ -92,8 +92,8 @@ public Task<bool> ExecuteInternal()
             }
 
             // This is a list of string[].  That is, each element in the list is a string[].  Each
-            // string[] represents a set of target names to build.  Depending on the value 
-            // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
+            // string[] represents a set of target names to build.  Depending on the value
+            // of the RunEachTargetSeparately parameter, we each just call the engine to run all
             // the targets together, or we call the engine separately for each target.
             List<string[]> targetLists = MSBuild.CreateTargetLists(Targets, RunEachTargetSeparately);
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 72d42315df5..08cc3e9f5e0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -167,7 +167,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
             // Second, expand the item include and exclude, and filter existing metadata as appropriate.
             List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata, loggingContext);
 
-            // Third, expand the metadata.           
+            // Third, expand the metadata.
             foreach (ProjectItemGroupTaskMetadataInstance metadataInstance in child.Metadata)
             {
                 bool condition = ConditionEvaluator.EvaluateCondition(
@@ -196,7 +196,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
 
                     string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location, loggingContext);
 
-                    // This both stores the metadata so we can add it to all the items we just created later, and 
+                    // This both stores the metadata so we can add it to all the items we just created later, and
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
                     metadataTable.SetValue(metadataInstance.Name, evaluatedValue);
                 }
@@ -236,7 +236,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
         }
 
         /// <summary>
-        /// Remove items from the world. Removes to items that are part of the project manifest are backed up, so 
+        /// Remove items from the world. Removes to items that are part of the project manifest are backed up, so
         /// they can be reverted when the project is reset after the end of the build.
         /// </summary>
         /// <param name="child">The item specification to evaluate and remove.</param>
@@ -280,7 +280,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
         }
 
         /// <summary>
-        /// Modifies items in the world - specifically, changes their metadata. Changes to items that are part of the project manifest are backed up, so 
+        /// Modifies items in the world - specifically, changes their metadata. Changes to items that are part of the project manifest are backed up, so
         /// they can be reverted when the project is reset after the end of the build.
         /// </summary>
         /// <param name="child">The item specification to evaluate and modify.</param>
@@ -681,7 +681,7 @@ internal Dictionary<string, string> AddedMetadata
             #region IMetadataTable Members
             // NOTE:  Leaving these methods public so as to avoid having to explicitly define them
             // through the IMetadataTable interface and then cast everywhere they're used.  This class
-            // is private, so it ultimately doesn't matter. 
+            // is private, so it ultimately doesn't matter.
 
             /// <summary>
             /// Gets the specified metadata value.  Returns an empty string if none is set.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index ccb65841cbb..df32111f095 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -83,7 +83,7 @@ internal static string GetParameterText(string prefix, string parameterName, ILi
                 // If the parameterName is not specified, no need to have an extra indent.
                 // Without parameterName:
                 //
-                // Input files: 
+                // Input files:
                 //     a.txt
                 //     b.txt
                 //
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index 4ddc0ffb430..b072bdbe462 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -78,8 +78,8 @@ private enum SkipNonExistentProjectsBehavior
         public ITaskHost HostObject { get; set; }
 
         /// <summary>
-        /// A list of property name/value pairs to apply as global properties to 
-        /// the child project.  
+        /// A list of property name/value pairs to apply as global properties to
+        /// the child project.
         /// A typical input: "propname1=propvalue1", "propname2=propvalue2", "propname3=propvalue3".
         /// </summary>
         /// <remarks>
@@ -87,7 +87,7 @@ private enum SkipNonExistentProjectsBehavior
         ///     <MSBuild
         ///         Properties="TargetPath=@(OutputPathItem)" />
         /// The engine fails on this because it doesn't like item lists being concatenated with string
-        /// constants when the data is being passed into an array parameter.  So the workaround is to 
+        /// constants when the data is being passed into an array parameter.  So the workaround is to
         /// write this in the project file:
         ///     <MSBuild
         ///         Properties="@(OutputPathItem->'TargetPath=%(Identity)')" />
@@ -144,7 +144,7 @@ private enum SkipNonExistentProjectsBehavior
         public string ToolsVersion { get; set; } = null;
 
         /// <summary>
-        /// When this is true we call the engine with all the projects at once instead of 
+        /// When this is true we call the engine with all the projects at once instead of
         /// calling the engine once per project
         /// </summary>
         public bool BuildInParallel { get; set; }
@@ -201,7 +201,7 @@ public string SkipNonexistentProjects
 
         /// <summary>
         /// Un-escape Targets, Properties (including Properties and AdditionalProperties as Project item metadata)
-        /// will be un-escaped before processing. e.g. %3B (an escaped ';') in the string for any of them will 
+        /// will be un-escaped before processing. e.g. %3B (an escaped ';') in the string for any of them will
         /// be treated as if it were an un-escaped ';'
         /// </summary>
         public string[] TargetAndPropertyListSeparators { get; set; } = null;
@@ -211,7 +211,7 @@ public string SkipNonexistentProjects
         /// <see cref="Projects"/> to build. This only applies to this build request (if another target calls the
         /// "missing target" later this will still result in an error).
         /// <remarks>
-        /// This could be useful when implementing a breaking protocol change between projects or stubbing behavior 
+        /// This could be useful when implementing a breaking protocol change between projects or stubbing behavior
         /// which may not make sense in all project types (e.g. Restore).
         /// </remarks>
         /// </summary>
@@ -264,7 +264,7 @@ public async Task<bool> ExecuteInternal()
             }
 
             bool isRunningMultipleNodes = BuildEngine2.IsRunningMultipleNodes;
-            // If we are in single proc mode and stopOnFirstFailure is true, we cannot build in parallel because 
+            // If we are in single proc mode and stopOnFirstFailure is true, we cannot build in parallel because
             // building in parallel sends all of the projects to the engine at once preventing us from not sending
             // any more projects after the first failure. Therefore, to preserve compatibility with whidbey if we are in this situation disable buildInParallel.
             if (!isRunningMultipleNodes && StopOnFirstFailure && BuildInParallel)
@@ -284,8 +284,8 @@ public async Task<bool> ExecuteInternal()
             }
 
             // This is a list of string[].  That is, each element in the list is a string[].  Each
-            // string[] represents a set of target names to build.  Depending on the value 
-            // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
+            // string[] represents a set of target names to build.  Depending on the value
+            // of the RunEachTargetSeparately parameter, we each just call the engine to run all
             // the targets together, or we call the engine separately for each target.
             List<string[]> targetLists = CreateTargetLists(Targets, RunEachTargetSeparately);
 
@@ -321,7 +321,7 @@ public async Task<bool> ExecuteInternal()
                     // Inform the user that we skipped the remaining projects because StopOnFirstFailure=true.
                     Log.LogMessageFromResources(MessageImportance.Low, "MSBuild.SkippingRemainingProjects");
 
-                    // We have encountered a failure.  Caller has requested that we not 
+                    // We have encountered a failure.  Caller has requested that we not
                     // continue with remaining projects.
                     break;
                 }
@@ -495,8 +495,8 @@ internal static List<string[]> CreateTargetLists(
             bool runEachTargetSeparately)
         {
             // This is a list of string[].  That is, each element in the list is a string[].  Each
-            // string[] represents a set of target names to build.  Depending on the value 
-            // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
+            // string[] represents a set of target names to build.  Depending on the value
+            // of the RunEachTargetSeparately parameter, we each just call the engine to run all
             // the targets together, or we call the engine separately for each target.
             var targetLists = new List<string[]>();
             if (runEachTargetSeparately && targets?.Length > 0)
@@ -648,12 +648,12 @@ internal static async Task<bool> ExecuteTargets(
                     // Inform the user that we skipped the remaining targets StopOnFirstFailure=true.
                     log.LogMessageFromResources(MessageImportance.Low, "MSBuild.SkippingRemainingTargets");
 
-                    // We have encountered a failure.  Caller has requested that we not 
+                    // We have encountered a failure.  Caller has requested that we not
                     // continue with remaining targets.
                     break;
                 }
 
-                // Send the project off to the build engine.  By passing in null to the 
+                // Send the project off to the build engine.  By passing in null to the
                 // first param, we are indicating that the project to build is the same
                 // as the *calling* project file.
 
@@ -677,7 +677,7 @@ internal static async Task<bool> ExecuteTargets(
                             {
                                 foreach (ITaskItem outputItemFromTarget in outputItemsFromTarget)
                                 {
-                                    // No need to rebase if the calling project is the same as the callee project 
+                                    // No need to rebase if the calling project is the same as the callee project
                                     // (project == null).  Also no point in trying to copy item metadata either,
                                     // because no items were passed into the Projects parameter!
                                     if (projects[i] != null)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
index 0c250da8f00..21650e6448f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
@@ -38,10 +38,10 @@ internal sealed class ItemBucket : IComparable
         private Lookup _lookup;
 
         /// <summary>
-        /// When buckets are being created for batching purposes, this indicates which order the 
+        /// When buckets are being created for batching purposes, this indicates which order the
         /// buckets were created in, so that the target/task being batched gets called with the items
         /// in the same order as they were declared in the project file.  For example, the first
-        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets 
+        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
         private int _bucketSequenceNumber;
@@ -153,10 +153,10 @@ internal Expander<ProjectPropertyInstance, ProjectItemInstance> Expander
 
 
         /// <summary>
-        /// When buckets are being created for batching purposes, this indicates which order the 
+        /// When buckets are being created for batching purposes, this indicates which order the
         /// buckets were created in, so that the target/task being batched gets called with the items
         /// in the same order as they were declared in the project file.  For example, the first
-        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets 
+        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
         internal int BucketSequenceNumber
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 9ead103fe08..b5bcf7ca165 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -24,33 +24,33 @@ namespace Microsoft.Build.BackEnd
     ///     - quick lookups
     ///     - scoping down of item subsets in nested scopes (useful for batches)
     ///     - isolation of adds, removes, modifies, and property sets inside nested scopes
-    ///     
+    ///
     /// When retrieving the item group for an item type, each table is consulted in turn,
     /// starting with the primary table (the "top" or "innermost" table), until a table is found that has an entry for that type.
     /// When an entry is found, it is returned without looking deeper.
     /// This makes it possible to let callers see only a subset of items without affecting or cloning the original item groups,
     /// by populating a scope with item groups that are empty or contain subsets of items in lower scopes.
-    /// 
+    ///
     /// Instances of this class can be cloned with Clone() to share between batches.
-    /// 
+    ///
     /// When EnterScope() is called, a fresh primary table is inserted, and all adds and removes will be invisible to
     /// any clones made before the scope was entered and anyone who has access to item groups in lower tables.
-    /// 
+    ///
     /// When LeaveScope() is called, the primary tables are merged into the secondary tables, and the primary tables are discarded.
     /// This makes the adds and removes in the primary tables visible to clones made during the previous scope.
-    /// 
+    ///
     /// Scopes can be populated (before Adds, Removes, and Lookups) using PopulateWithItem(). This reduces the set of items of a particular
     /// type that are visible in a scope, because lookups of items of this type will stop at this level and see the subset, rather than the
     /// larger set in a scope below.
-    /// 
+    ///
     /// Items can be added or removed by calling AddNewItem() and RemoveItem(). Only the primary level is modified.
     /// When items are added or removed they enter into a primary table exclusively for adds or removes, instead of the main primary table.
     /// This allows the adds and removes to be applied to the scope below on LeaveScope(). Even when LeaveScope() is called, the adds and removes
     /// stay in their separate add and remove tables: if they were applied to a main table, they could truncate the downward traversal performed by lookups
     /// and hide items in a lower main table. Only on the final call of LeaveScope() can all adds and removes be applied to the outermost table, i.e., the project.
-    /// 
+    ///
     /// Much the same applies to properties.
-    /// 
+    ///
     /// For sensible semantics, only the current primary scope can be modified at any point.
     /// </summary>
     internal class Lookup : IPropertyProvider<ProjectPropertyInstance>, IItemProvider<ProjectItemInstance>
@@ -221,7 +221,7 @@ internal List<string> GetPropertyOverrideMessages(Dictionary<string, string> loo
                     }
 
                     // Set the value of the hash to the new property value
-                    // PERF: we store the EvaluatedValueEscaped here to avoid unnecessary unescaping (the value is stored 
+                    // PERF: we store the EvaluatedValueEscaped here to avoid unnecessary unescaping (the value is stored
                     // escaped in the property)
                     lookupHash[propertyName] = ((IProperty)property).EvaluatedValueEscaped;
                 }
@@ -262,8 +262,8 @@ private void LeaveScope(Lookup.Scope scopeToLeave)
             ErrorUtilities.VerifyThrow(_lookupScopes.Count >= 2, "Too many calls to Leave().");
             ErrorUtilities.VerifyThrow(Object.ReferenceEquals(scopeToLeave, _lookupScopes.First.Value), "Attempting to leave with scope '{0}' but scope '{1}' is on top of the stack.", scopeToLeave.Description, _lookupScopes.First.Value.Description);
 
-            // Our lookup works by stopping the first time it finds an item group of the appropriate type. 
-            // So we can't apply an add directly into the table below because that could create a new group 
+            // Our lookup works by stopping the first time it finds an item group of the appropriate type.
+            // So we can't apply an add directly into the table below because that could create a new group
             // of that type, which would cause the next lookup to stop there and miss any existing items in a table below.
             // Instead we keep adds stored separately until we're leaving the very last scope. Until then
             // we only move adds down into the next add table below, and when we lookup we consider both tables.
@@ -279,7 +279,7 @@ private void LeaveScope(Lookup.Scope scopeToLeave)
 
             // Let go of our pointer into the clone table; we assume we won't need it after leaving scope and want to save memory.
             // This is an assumption on IntrinsicTask, that it won't ask to remove or modify a clone in a higher scope than it was handed out in.
-            // We mustn't call cloneTable.Clear() because other clones of this lookup may still be using it. When the last lookup clone leaves scope, 
+            // We mustn't call cloneTable.Clear() because other clones of this lookup may still be using it. When the last lookup clone leaves scope,
             // the table will be collected.
             _cloneTable = null;
 
@@ -413,7 +413,7 @@ private void MergeScopeIntoLastScope()
         /// </summary>
         public ProjectPropertyInstance GetProperty(string name, int startIndex, int endIndex)
         {
-            // Walk down the tables and stop when the first 
+            // Walk down the tables and stop when the first
             // property with this name is found
             foreach (Scope scope in _lookupScopes)
             {
@@ -716,8 +716,8 @@ internal void RemoveItem(ProjectItemInstance item)
             PrimaryRemoveTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryRemoveTable.Add(item);
 
-            // No need to remove this item from the primary add table if it's 
-            // already there -- we always apply removes after adds, so that add 
+            // No need to remove this item from the primary add table if it's
+            // already there -- we always apply removes after adds, so that add
             // will be reversed anyway.
         }
 
@@ -731,7 +731,7 @@ internal void ModifyItems(string itemType, ICollection<ProjectItemInstance> grou
             MustNotBeOuterScope();
 
 #if DEBUG
-            // This item should not already be in any remove table; there is no way a project can 
+            // This item should not already be in any remove table; there is no way a project can
             // modify items that were already removed
             // Obviously, do this only in debug, as it's a slow check for bugs.
             LinkedListNode<Scope> node = _lookupScopes.First;
@@ -912,7 +912,7 @@ private void MergeModificationsIntoModificationTable(Dictionary<ProjectItemInsta
                     foreach (var metadataChange in modify.Value.ExplicitModifications)
                     {
                         // If the existing metadata change list has an entry for this metadata, ignore this change.
-                        // We continue to allow changes made when KeepOnlySpecified is set because it is assumed that explicit metadata changes 
+                        // We continue to allow changes made when KeepOnlySpecified is set because it is assumed that explicit metadata changes
                         // always trump implicit ones.
                         if (!existingMetadataChanges.ContainsExplicitModification(metadataChange.Key))
                         {
@@ -960,7 +960,7 @@ private void MustNotBeInTable(ItemTypeToItemsMetadataUpdateDictionary table, Pro
 
         /// <summary>
         /// Verify item is not in any table in any scope
-        /// </summary>        
+        /// </summary>
         private void MustNotBeInAnyTables(ProjectItemInstance item)
         {
             // This item should not already be in any table; there is no way a project can
@@ -1360,8 +1360,8 @@ internal Scope(Lookup lookup, string description, ItemDictionary<ProjectItemInst
 
             /// <summary>
             /// The main table, populated with items that
-            /// are initially visible in this scope. Does not 
-            /// include adds or removes unless it's the table in 
+            /// are initially visible in this scope. Does not
+            /// include adds or removes unless it's the table in
             /// the outermost scope.
             /// </summary>
             internal ItemDictionary<ProjectItemInstance> Items
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index b4b97933ac7..e2c2e7cc772 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -292,7 +292,7 @@ public void WaitForCancelCompletion()
                 }
                 catch (AggregateException e) when (InnerExceptionsAreAllCancelledExceptions(e))
                 {
-                    // ignore -- just indicates that the task finished cancelling before we got a chance to wait on it.  
+                    // ignore -- just indicates that the task finished cancelling before we got a chance to wait on it.
                     taskCleanedUp = true;
                 }
 
@@ -608,7 +608,7 @@ internal static int WaitWithBuilderThreadStart(WaitHandle[] handles, bool recurs
                 }
                 finally
                 {
-                    // If this was the top level submission doing the waiting, we are done with this submission and it's 
+                    // If this was the top level submission doing the waiting, we are done with this submission and it's
                     // main thread building context
                     if (!recursive)
                     {
@@ -638,10 +638,10 @@ private void StartBuilderThread()
             _cancellationTokenSource = new CancellationTokenSource();
 
             // IMPLEMENTATION NOTE: It may look strange that we are creating new tasks here which immediately turn around and create
-            // more tasks that look async.  The reason for this is that while these methods are technically async, they really only 
+            // more tasks that look async.  The reason for this is that while these methods are technically async, they really only
             // unwind at very specific times according to the needs of MSBuild, in particular when we are waiting for results from
             // another project or when we are Yielding the Build Engine while running certain tasks.  Essentially, the Request Builder
-            // and related components form a giant state machine and the tasks are used to implement one very deep co-routine.  
+            // and related components form a giant state machine and the tasks are used to implement one very deep co-routine.
             if (IsBuilderUsingLegacyThreadingSemantics(_componentHost, _requestEntry))
             {
                 // Create a task which completes when the legacy threading task thread is finished.
@@ -650,13 +650,13 @@ private void StartBuilderThread()
                 _requestTask = Task.Factory.StartNew(
                     () =>
                     {
-                        // If this is a very quick-running request, it is possible that the request will have built and completed in 
+                        // If this is a very quick-running request, it is possible that the request will have built and completed in
                         // the time between when StartBuilderThread is called, and when the threadpool gets around to actually servicing
-                        // this request.  If that's the case, it's also possible that ShutdownComponent() could have already been called, 
-                        // in which case the componentHost will be null.  
+                        // this request.  If that's the case, it's also possible that ShutdownComponent() could have already been called,
+                        // in which case the componentHost will be null.
 
-                        // In that circumstance, by definition we don't have anyone who will want to wait on the LegacyThreadInactiveEvent 
-                        // task, so we can safely just return. Take a snapshot so that we don't fall victim to componentHost being set 
+                        // In that circumstance, by definition we don't have anyone who will want to wait on the LegacyThreadInactiveEvent
+                        // task, so we can safely just return. Take a snapshot so that we don't fall victim to componentHost being set
                         // to null between the null check and asking the LegacyThreadingData for the Task.
                         IBuildComponentHost componentHostSnapshot = _componentHost;
 
@@ -678,9 +678,9 @@ private void StartBuilderThread()
                 ErrorUtilities.VerifyThrow(_componentHost.LegacyThreadingData.MainThreadSubmissionId != _requestEntry.Request.SubmissionId, "Can't start builder thread when we are using legacy threading semantics for this request.");
 
                 // We do not run in STA by default.  Most code does not
-                // require the STA apartment and the .Net default is to 
+                // require the STA apartment and the .Net default is to
                 // create threads with MTA semantics.  We provide this
-                // switch so that those few tasks which may require it 
+                // switch so that those few tasks which may require it
                 // can be made to work.
                 if (Environment.GetEnvironmentVariable("MSBUILDFORCESTA") == "1")
                 {
@@ -804,7 +804,7 @@ private async Task BuildAndReport()
             BuildResult result = null;
             VerifyEntryInActiveState();
 
-            // Start the build request            
+            // Start the build request
             try
             {
                 result = await BuildProject();
@@ -896,7 +896,7 @@ private void ReportResultAndCleanUp(BuildResult result)
                 }
             }
 
-            // Clear out our state now in case any of these callbacks cause the engine to try and immediately 
+            // Clear out our state now in case any of these callbacks cause the engine to try and immediately
             // reuse this builder.
             BuildRequestEntry entryToComplete = _requestEntry;
             _nodeLoggingContext = null;
@@ -946,13 +946,13 @@ private async Task<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildReque
                 SaveOperatingEnvironment();
             }
 
-            // Issue the requests to the engine            
+            // Issue the requests to the engine
             RaiseOnNewBuildRequests(requests);
 
             // TODO: OPTIMIZATION: By returning null here, we commit to having to unwind the stack all the
             // way back to RequestThreadProc and then shutting down the thread before we can receive the
             // results and continue with them.  It is not always the case that this will be desirable, however,
-            // particularly if the results we need are immediately available.  In those cases, it would be 
+            // particularly if the results we need are immediately available.  In those cases, it would be
             // useful to wait here for a short period in case those results become available - one second
             // might be enough.  This means we may occasionally get more than one builder thread lying around
             // waiting for something to happen, but that would be short lived.  At the same time it would
@@ -1111,8 +1111,8 @@ private async Task<BuildResult> BuildProject()
         {
             ErrorUtilities.VerifyThrow(_targetBuilder != null, "Target builder is null");
 
-            // Make sure it is null before loading the configuration into the request, because if there is a problem 
-            // we do not wand to have an invalid projectLoggingContext floating around. Also if this is null the error will be 
+            // Make sure it is null before loading the configuration into the request, because if there is a problem
+            // we do not wand to have an invalid projectLoggingContext floating around. Also if this is null the error will be
             // logged with the node logging context
             _projectLoggingContext = null;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 537660af9bf..bb3f3c87d9e 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -419,8 +419,8 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                         "TargetDoesNotExist",
                         currentTargetEntry.Name);
 
-                        // If we already have results for this target which were not skipped, we can ignore it.  In 
-                        // addition, we can also ignore its before and after targets -- if this target has already run, 
+                        // If we already have results for this target which were not skipped, we can ignore it.  In
+                        // addition, we can also ignore its before and after targets -- if this target has already run,
                         // then so have they.
                         if (!CheckSkipTarget(ref stopProcessingStack, currentTargetEntry))
                         {
@@ -446,7 +446,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                             IList<TargetSpecification> dependencies = currentTargetEntry.GetDependencies(_projectLoggingContext);
 
                             // Push our before targets now, unconditionally.  If we have marked that we should stop processing the stack here, which can only
-                            // happen if our current target was supposed to stop processing AND we had no after targets, then our last before target should 
+                            // happen if our current target was supposed to stop processing AND we had no after targets, then our last before target should
                             // inherit the stop processing flag and we will reset it.
                             // Our parent is the target before which we run, just like a depends-on target.
                             IList<TargetSpecification> beforeTargets = _requestEntry.RequestConfiguration.Project.GetTargetsWhichRunBefore(currentTargetEntry.Name);
@@ -584,11 +584,11 @@ private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTa
                     {
                         TargetEntry topEntry = _targetsToBuild.Pop();
 
-                        // If this is a skip because of target failure, we should behave in the same way as we 
-                        // would if this target actually failed -- remove all its dependencies from the stack as 
-                        // well.  Otherwise, we could encounter a situation where a failure target happens in the 
+                        // If this is a skip because of target failure, we should behave in the same way as we
+                        // would if this target actually failed -- remove all its dependencies from the stack as
+                        // well.  Otherwise, we could encounter a situation where a failure target happens in the
                         // middle of execution once, then exits, then a request comes through to build the same
-                        // targets, reaches that target, skips-already-failed, and then continues building. 
+                        // targets, reaches that target, skips-already-failed, and then continues building.
                         PopDependencyTargetsOnTargetFailure(topEntry, targetResult, ref stopProcessingStack);
                     }
 
@@ -663,7 +663,7 @@ private async Task<bool> PushTargets(IList<TargetSpecification> targets, TargetE
 
                 if (buildReason == TargetBuiltReason.BeforeTargets || buildReason == TargetBuiltReason.AfterTargets)
                 {
-                    // Don't build any Before or After targets for which we already have results.  Unlike other targets, 
+                    // Don't build any Before or After targets for which we already have results.  Unlike other targets,
                     // we don't explicitly log a skipped-with-results message because it is not interesting.
                     if (_buildResult.HasResultsForTarget(targetSpecification.TargetName))
                     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index cef0fb834f9..e742933082c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -19,7 +19,7 @@
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
-#if MSBUILDENABLEVSPROFILING 
+#if MSBUILDENABLEVSPROFILING
 using Microsoft.VisualStudio.Profiler;
 #endif
 #nullable disable
@@ -507,7 +507,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                 // We either have some work to do or at least we need to infer outputs from inputs.
                                 bucketResult = await ProcessBucket(taskBuilder, targetLoggingContext, GetTaskExecutionMode(dependencyResult), lookupForInference, lookupForExecution);
 
-                                // Now aggregate the result with the existing known results.  There are four rules, assuming the target was not 
+                                // Now aggregate the result with the existing known results.  There are four rules, assuming the target was not
                                 // skipped due to being up-to-date:
                                 // 1. If this bucket failed or was cancelled, the aggregate result is failure.
                                 // 2. If this bucket Succeeded and we have not previously failed, the aggregate result is a success.
@@ -525,7 +525,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                     }
                                 }
 
-                                // Pop the lookup scopes, causing them to collapse their values back down into the 
+                                // Pop the lookup scopes, causing them to collapse their values back down into the
                                 // bucket's lookup.
                                 // NOTE: this order is important because when we infer outputs, we are trying
                                 // to produce the same results as would be produced from a full build; as such
@@ -557,7 +557,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                     }
                     finally
                     {
-                        // Don't log the last target finished event until we can process the target outputs as we want to attach them to the 
+                        // Don't log the last target finished event until we can process the target outputs as we want to attach them to the
                         // last target batch.
                         if (targetLoggingContext != null && i < numberOfBuckets - 1)
                         {
@@ -585,13 +585,13 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                     string targetReturns = _target.Returns;
                     ElementLocation targetReturnsLocation = _target.ReturnsLocation;
 
-                    // If there are no targets in the project file that use the "Returns" attribute, that means that we 
+                    // If there are no targets in the project file that use the "Returns" attribute, that means that we
                     // revert to the legacy behavior in the case where Returns is not specified (null, rather
-                    // than the empty string, which indicates no returns).  Legacy behavior is for all 
-                    // of the target's Outputs to be returned. 
-                    // On the other hand, if there is at least one target in the file that uses the Returns attribute, 
+                    // than the empty string, which indicates no returns).  Legacy behavior is for all
+                    // of the target's Outputs to be returned.
+                    // On the other hand, if there is at least one target in the file that uses the Returns attribute,
                     // then all targets in the file are run according to the new behaviour (return nothing unless otherwise
-                    // specified by the Returns attribute). 
+                    // specified by the Returns attribute).
                     if (targetReturns == null)
                     {
                         if (!_target.ParentProjectSupportsReturnsAttribute)
@@ -616,7 +616,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
 
                         // NOTE: we need to gather the outputs in batches, because the output specification may reference item metadata
                         // Also, we are using the baseLookup, which has possibly had changes made to it since the project started.  Because of this, the
-                        // set of outputs calculated here may differ from those which would have been calculated at the beginning of the target.  It is 
+                        // set of outputs calculated here may differ from those which would have been calculated at the beginning of the target.  It is
                         // assumed the user intended this.
                         List<ItemBucket> batchingBuckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location);
 
@@ -648,7 +648,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                 }
                 finally
                 {
-                    // log the last target finished since we now have the target outputs. 
+                    // log the last target finished since we now have the target outputs.
                     targetLoggingContext?.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems?.Count > 0 ? targetOutputItems : null);
                 }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
index 8409e8135ca..a3297139fa8 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
@@ -37,7 +37,7 @@ private TargetSpecification()
         }
 
         /// <summary>
-        /// Gets or sets the target name            
+        /// Gets or sets the target name
         /// </summary>
         public string TargetName => _targetName;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index dcf16e16545..4b40715d67b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -22,12 +22,12 @@ namespace Microsoft.Build.BackEnd
     using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
     using ItemVectorPartition = System.Collections.Generic.Dictionary<string, System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectItemInstance>>;
     // ItemVectorPartitionCollection is designed to contains a set of project items which have possibly undergone transforms.
-    // The outer dictionary it usually keyed by item type, so if items originally came from 
+    // The outer dictionary it usually keyed by item type, so if items originally came from
     // an expression like @(Foo), the outer dictionary would have a key of "Foo" in it.
     // Under that is a dictionary of expressions to items resulting from the expression.
     // For instance, if items were generated from an expression @(Foo->'%(Filename).obj'), then
-    // the inner dictionary would have a key of "@(Foo->'%(Filename).obj')", in which would be 
-    // contained a list of the items which were created/transformed using that pattern.    
+    // the inner dictionary would have a key of "@(Foo->'%(Filename).obj')", in which would be
+    // contained a list of the items which were created/transformed using that pattern.
     using ItemVectorPartitionCollection = System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectItemInstance>>>;
 
     /// <summary>
@@ -192,14 +192,14 @@ internal DependencyAnalysisResult PerformDependencyAnalysis(
                          * At this point, we know the following:
                          * 1) the target has outputs
                          * 2) the target has NO discrete outputs
-                         * 
+                         *
                          * This implies:
                          * 1) the target only references vectors (incl. transforms) in its outputs
                          * 2) all vectors referenced in the outputs are also referenced in the inputs
                          * 3) the referenced vectors are not empty
-                         * 
+                         *
                          * We can thus conclude: the target MUST have (non-discrete) inputs
-                         * 
+                         *
                          */
                         ErrorUtilities.VerifyThrow(itemVectorsReferencedInBothTargetInputsAndOutputs.Count > 0, "The target must have inputs.");
                         ErrorUtilities.VerifyThrow(!IsItemVectorEmpty(itemVectorsInTargetInputs), "The target must have inputs.");
@@ -970,7 +970,7 @@ internal static bool IsAnyOutOfDate<T>(out DependencyAnalysisLogDetail dependenc
             // Algorithm: walk through all the outputs to find the oldest output
             //            walk through the inputs as far as we need to until we find one that's newer (if any)
 
-            // PERF -- we could change this to ensure that we walk the shortest list first (because we walk that one entirely): 
+            // PERF -- we could change this to ensure that we walk the shortest list first (because we walk that one entirely):
             //         possibly the outputs list isn't actually the shortest list. However it always is the shortest
             //         in the cases I've seen, and adding this optimization would make the code hard to read.
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index f8768988732..ee09e5be50f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -347,7 +347,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
 
                 taskHost?.MarkAsInactive();
 
-                // Now all task batches are done, apply all item adds to the outer 
+                // Now all task batches are done, apply all item adds to the outer
                 // target batch; we do this even if the task wasn't found (in that case,
                 // no items or properties will have been added to the scope)
                 if (buckets != null)
@@ -414,14 +414,14 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 {
                     // Change to the project root directory.
                     // If that directory does not exist, do nothing. (Do not check first as it is almost always there and it is slow)
-                    // This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project. 
+                    // This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project.
                     // No errors are masked by doing this: errors loading the project from disk are reported at load time, if necessary.
                     NativeMethodsShared.SetCurrentDirectory(_buildRequestEntry.ProjectRootDirectory);
                 }
 
                 if (howToExecuteTask == TaskExecutionMode.ExecuteTaskAndGatherOutputs)
                 {
-                    // We need to find the task before logging the task started event so that the using task statement comes before the task started event 
+                    // We need to find the task before logging the task started event so that the using task statement comes before the task started event
                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);
                     TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);
                     if (requirements != null)
@@ -519,15 +519,15 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
         /// </summary>
         private IDictionary<string, string> GatherTaskIdentityParameters(Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
-            ErrorUtilities.VerifyThrowInternalNull(_taskNode, "taskNode"); // taskNode should never be null when we're calling this method. 
+            ErrorUtilities.VerifyThrowInternalNull(_taskNode, "taskNode"); // taskNode should never be null when we're calling this method.
 
             string msbuildArchitecture = expander.ExpandIntoStringAndUnescape(_taskNode.MSBuildArchitecture ?? String.Empty, ExpanderOptions.ExpandAll, _taskNode.MSBuildArchitectureLocation ?? ElementLocation.EmptyLocation);
             string msbuildRuntime = expander.ExpandIntoStringAndUnescape(_taskNode.MSBuildRuntime ?? String.Empty, ExpanderOptions.ExpandAll, _taskNode.MSBuildRuntimeLocation ?? ElementLocation.EmptyLocation);
 
             IDictionary<string, string> taskIdentityParameters = null;
 
-            // only bother to create a task identity parameter set if we're putting anything in there -- otherwise, 
-            // a null set will be treated as equivalent to all parameters being "don't care". 
+            // only bother to create a task identity parameter set if we're putting anything in there -- otherwise,
+            // a null set will be treated as equivalent to all parameters being "don't care".
             if (msbuildRuntime != String.Empty || msbuildArchitecture != String.Empty)
             {
                 taskIdentityParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
@@ -825,7 +825,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
 
                     // Set the property "MSBuildLastTaskResult" to reflect whether the task succeeded or not.
                     // The main use of this is if ContinueOnError is true -- so that the next task can consult the result.
-                    // So we want it to be "false" even if ContinueOnError is true. 
+                    // So we want it to be "false" even if ContinueOnError is true.
                     // The constants "true" and "false" should NOT be localized. They become property values.
                     bucket.Lookup.SetProperty(ProjectPropertyInstance.Create(ReservedPropertyNames.lastTaskResult, taskResult ? "true" : "false", true/* may be reserved */, _buildRequestEntry.RequestConfiguration.Project.IsImmutable));
                 }
@@ -894,7 +894,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     }
                     else if (type == typeof(Exception) || type.GetTypeInfo().IsSubclassOf(typeof(Exception)))
                     {
-                        // Occasionally, when debugging a very uncommon task exception, it is useful to loop the build with 
+                        // Occasionally, when debugging a very uncommon task exception, it is useful to loop the build with
                         // a debugger attached to break on 2nd chance exceptions.
                         // That requires that there needs to be a way to not catch here, by setting an environment variable.
                         if (ExceptionHandling.IsCriticalException(taskException) || (Environment.GetEnvironmentVariable("MSBUILDDONOTCATCHTASKEXCEPTIONS") == "1"))
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 569a498e1cd..e9e1bf575a2 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -427,8 +427,8 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -437,7 +437,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
 
                 if (_convertErrorsToWarnings)
                 {
-                    // Convert the error into a warning.  We do this because the whole point of 
+                    // Convert the error into a warning.  We do this because the whole point of
                     // ContinueOnError is that a project author expects that the task might fail,
                     // but wants to ignore the failures.  This implies that we shouldn't be logging
                     // errors either, because you should never have a successful build with errors.
@@ -497,8 +497,8 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -538,8 +538,8 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -579,8 +579,8 @@ public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -1023,7 +1023,7 @@ public override object InitializeLifetimeService()
                 ILease lease = (ILease)base.InitializeLifetimeService();
 
                 // Set how long a lease should be initially. Once a lease expires
-                // the remote object will be disconnected and it will be marked as being availiable 
+                // the remote object will be disconnected and it will be marked as being availiable
                 // for garbage collection
                 int initialLeaseTime = 1;
 
@@ -1045,7 +1045,7 @@ public override object InitializeLifetimeService()
                 // increase the lease time allowing the object to stay in memory
                 _sponsor = new ClientSponsor();
 
-                // When a new lease is requested lets make it last 1 minutes longer. 
+                // When a new lease is requested lets make it last 1 minutes longer.
                 int leaseExtensionTime = 1;
 
                 string leaseExtensionTimeFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDENGINEPROXYLEASEEXTENSIONTIME");
@@ -1082,7 +1082,7 @@ internal void MarkAsInactive()
                 ReleaseAllCores();
 
                 // Since the task has a pointer to this class it may store it in a static field. Null out
-                // internal data so the leak of this object doesn't lead to a major memory leak.            
+                // internal data so the leak of this object doesn't lead to a major memory leak.
                 _host = null;
                 _requestEntry = null;
 
@@ -1174,7 +1174,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                 }
                 else
                 {
-                    // UNDONE: (Refactor) Investigate making this a ReadOnly collection of some sort.  
+                    // UNDONE: (Refactor) Investigate making this a ReadOnly collection of some sort.
                     PropertyDictionary<ProjectPropertyInstance>[] propertyDictionaries = new PropertyDictionary<ProjectPropertyInstance>[projectFileNames.Length];
 
                     for (int i = 0; i < projectFileNames.Length; i++)
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 33d0de2f88c..4d7abb22231 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -40,7 +40,7 @@ internal enum SchedulableRequestState
         Blocked,
 
         /// <summary>
-        /// This request has yielded control of the node while it is running a long-running out-of-process program.  Any number of tasks on a 
+        /// This request has yielded control of the node while it is running a long-running out-of-process program.  Any number of tasks on a
         /// node may be in the yielding state.
         /// </summary>
         Yielding,
@@ -506,15 +506,15 @@ private void DetectCircularDependency(SchedulableRequest blockingRequest)
         /// of it having been previously scheduled in a multiproc scenario, but before this request was able to execute.
         /// </summary>
         /// <remarks>
-        /// Let A be 'this' project and B be 'blockingRequest' (the request which is going to block A.)  
-        /// An indirect circular dependency exists if there is a dependency path from B to A.  If there is no 
-        /// existing blocked request B' with the same global request id as B, then there can be no path from B to A because B is a brand new 
-        /// request with no other dependencies.  If there is an existing blocked request B' with the same global request ID as B, then we 
+        /// Let A be 'this' project and B be 'blockingRequest' (the request which is going to block A.)
+        /// An indirect circular dependency exists if there is a dependency path from B to A.  If there is no
+        /// existing blocked request B' with the same global request id as B, then there can be no path from B to A because B is a brand new
+        /// request with no other dependencies.  If there is an existing blocked request B' with the same global request ID as B, then we
         /// walk the set of dependencies recursively searching for A.  If A is found, we have a circular dependency.
         /// </remarks>
         private void DetectIndirectCircularDependency(SchedulableRequest blockingRequest)
         {
-            // If there is already a blocked request which has the same configuration id as the blocking request and that blocked request is (recursively) 
+            // If there is already a blocked request which has the same configuration id as the blocking request and that blocked request is (recursively)
             // waiting on this request, then that is an indirect circular dependency.
             SchedulableRequest alternateRequest = _schedulingData.GetBlockedRequestIfAny(blockingRequest.BuildRequest.GlobalRequestId);
             if (alternateRequest == null)
@@ -539,7 +539,7 @@ private void DetectIndirectCircularDependency(SchedulableRequest blockingRequest
                 evaluatedRequests.Add(requestToEvaluate);
 
                 // If the request is not scheduled, it's possible that is because it's been scheduled elsewhere and is blocked.
-                // Follow that path if it exists.                        
+                // Follow that path if it exists.
                 if (requestToEvaluate.State == SchedulableRequestState.Unscheduled)
                 {
                     requestToEvaluate = _schedulingData.GetBlockedRequestIfAny(requestToEvaluate.BuildRequest.GlobalRequestId);
@@ -567,7 +567,7 @@ private void DetectIndirectCircularDependency(SchedulableRequest blockingRequest
         /// </summary>
         private void ThrowIndirectCircularDependency(SchedulableRequest blockingRequest, SchedulableRequest requestToEvaluate)
         {
-            // We found a request which has the same global request ID as us in a chain which leads from the (already blocked) request 
+            // We found a request which has the same global request ID as us in a chain which leads from the (already blocked) request
             // which is trying to block us.  Calculate its list of ancestors by walking up the parent list.
             List<SchedulableRequest> ancestors = new List<SchedulableRequest>(16);
             while (requestToEvaluate.Parent != null)
@@ -585,7 +585,7 @@ private void ThrowIndirectCircularDependency(SchedulableRequest blockingRequest,
         /// </summary>
         private void DetectDirectCircularDependency(SchedulableRequest blockingRequest)
         {
-            // A circular dependency occurs when this project (or any of its ancestors) has the same global request id as the 
+            // A circular dependency occurs when this project (or any of its ancestors) has the same global request id as the
             // blocking request.
             List<SchedulableRequest> ancestors = new List<SchedulableRequest>(16);
             SchedulableRequest currentRequest = this;
@@ -644,7 +644,7 @@ internal void DisconnectRequestWeAreBlockedBy(BlockingRequestKey blockingRequest
             _requestsWeAreBlockedBy.Remove(blockingRequestKey);
             unblockingRequest._requestsWeAreBlocking.Remove(this);
 
-            // If the request we are blocked by also happens to be unscheduled, remove it as well so we don't try to run it later.  This is 
+            // If the request we are blocked by also happens to be unscheduled, remove it as well so we don't try to run it later.  This is
             // because circular dependency errors cause us to fail all outstanding requests on the current request.  See BuildRequsetEntry.ReportResult.
             if (unblockingRequest.State == SchedulableRequestState.Unscheduled)
             {
diff --git a/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs b/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
index bae176a6540..bc5e8f86256 100644
--- a/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
+++ b/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
@@ -25,7 +25,7 @@ internal enum ScheduleActionType
         Schedule,
 
         /// <summary>
-        /// The response indicates that the request should be send to the specified node, 
+        /// The response indicates that the request should be send to the specified node,
         /// along with the configuration for the request.
         /// </summary>
         ScheduleWithConfiguration,
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 6208aa883e4..2bae4049ae1 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -332,7 +332,7 @@ public IEnumerable<ScheduleResponse> ReportRequestBlocked(int nodeId, BuildReque
                 else if ((blocker.BlockingRequestId == blocker.BlockedRequestId) && blocker.BlockingRequestId != BuildRequest.InvalidGlobalRequestId)
                 {
                     ErrorUtilities.VerifyThrow(string.IsNullOrEmpty(blocker.BlockingTarget), "Blocking target should be null because this is not a request blocking on a target");
-                    // We are blocked waiting for a transfer of results.                    
+                    // We are blocked waiting for a transfer of results.
                     HandleRequestBlockedOnResultsTransfer(parentRequest, responses);
                 }
                 else if (blocker.BlockingRequestId != BuildRequest.InvalidGlobalRequestId)
@@ -363,7 +363,7 @@ public IEnumerable<ScheduleResponse> ReportRequestBlocked(int nodeId, BuildReque
                 responses.Add(ScheduleResponse.CreateCircularDependencyResponse(nodeId, parentRequest.BuildRequest, ex.Request));
             }
 
-            // Now see if we can schedule requests somewhere since we 
+            // Now see if we can schedule requests somewhere since we
             // a) have a new request; and
             // b) have a node which is now waiting and not doing anything.
             ScheduleUnassignedRequests(responses);
@@ -382,7 +382,7 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
 
             if (result.NodeRequestId == BuildRequest.ResultsTransferNodeRequestId)
             {
-                // We are transferring results.  The node to which they should be sent has already been recorded by the 
+                // We are transferring results.  The node to which they should be sent has already been recorded by the
                 // HandleRequestBlockedOnResultsTransfer method in the configuration.
                 BuildRequestConfiguration config = _configCache[result.ConfigurationId];
                 ScheduleResponse response = ScheduleResponse.CreateReportResultResponse(config.ResultsNodeId, result);
@@ -394,7 +394,7 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
                 SchedulableRequest request = _schedulingData.GetExecutingRequest(result.GlobalRequestId);
                 request.Complete(result);
 
-                // Report results to our parent, or report submission complete as necessary.            
+                // Report results to our parent, or report submission complete as necessary.
                 if (request.Parent != null)
                 {
                     // responses.Add(new ScheduleResponse(request.Parent.AssignedNode, new BuildRequestUnblocker(request.Parent.BuildRequest.GlobalRequestId, result)));
@@ -402,10 +402,10 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
 
                     // When adding the result to the cache we merge the result with what ever is already in the cache this may cause
                     // the result to have more target outputs in it than was was requested.  To fix this we can ask the cache itself for the result we just added.
-                    // When results are returned from the cache we filter them based on the targets we requested. This causes our result to only 
+                    // When results are returned from the cache we filter them based on the targets we requested. This causes our result to only
                     // include the targets we requested rather than the merged result.
 
-                    // Note: In this case we do not need to log that we got the results from the cache because we are only using the cache 
+                    // Note: In this case we do not need to log that we got the results from the cache because we are only using the cache
                     // for filtering the targets for the result instead rather than using the cache as the location where this result came from.
                     ScheduleResponse response = TrySatisfyRequestFromCache(request.Parent.AssignedNode, request.BuildRequest, skippedResultsDoNotCauseCacheMiss: _componentHost.BuildParameters.SkippedResultsDoNotCauseCacheMiss());
 
@@ -443,13 +443,13 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
                         int parentNode = (unscheduledRequest.Parent == null) ? InvalidNodeId : unscheduledRequest.Parent.AssignedNode;
 
                         // There are other requests which we can satisfy based on this result, lets pull the result out of the cache
-                        // and satisfy those requests.  Normally a skipped result would lead to the cache refusing to satisfy the 
-                        // request, because the correct response in that case would be to attempt to rebuild the target in case there 
+                        // and satisfy those requests.  Normally a skipped result would lead to the cache refusing to satisfy the
+                        // request, because the correct response in that case would be to attempt to rebuild the target in case there
                         // are state changes that would cause it to now excute.  At this point, however, we already know that the parent
-                        // request has completed, and we already know that this request has the same global request ID, which means that 
-                        // its configuration and set of targets are identical -- from MSBuild's perspective, it's the same.  So since 
-                        // we're not going to attempt to re-execute it, if there are skipped targets in the result, that's fine. We just 
-                        // need to know what the target results are so that we can log them. 
+                        // request has completed, and we already know that this request has the same global request ID, which means that
+                        // its configuration and set of targets are identical -- from MSBuild's perspective, it's the same.  So since
+                        // we're not going to attempt to re-execute it, if there are skipped targets in the result, that's fine. We just
+                        // need to know what the target results are so that we can log them.
                         ScheduleResponse response = TrySatisfyRequestFromCache(parentNode, unscheduledRequest.BuildRequest, skippedResultsDoNotCauseCacheMiss: true);
 
                         // If we have a response we need to tell the loggers that we satisified that request from the cache.
@@ -459,8 +459,8 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
                         }
                         else
                         {
-                            // Response may be null if the result was never added to the cache. This can happen if the result has 
-                            // an exception in it. If that is the case, we should report the result directly so that the 
+                            // Response may be null if the result was never added to the cache. This can happen if the result has
+                            // an exception in it. If that is the case, we should report the result directly so that the
                             // build manager knows that it needs to shut down logging manually.
                             response = GetResponseForResult(parentNode, unscheduledRequest.BuildRequest, newResult.Clone());
                         }
@@ -521,7 +521,7 @@ public void ReportBuildAborted(int nodeId)
         {
             _schedulingData.EventTime = DateTime.UtcNow;
 
-            // Get the list of build requests currently assigned to the node and report aborted results for them.            
+            // Get the list of build requests currently assigned to the node and report aborted results for them.
             TraceScheduler("Build aborted by node {0}", nodeId);
 
             foreach (SchedulableRequest request in _schedulingData.GetScheduledRequestsByNode(nodeId))
@@ -741,15 +741,15 @@ private void ScheduleUnassignedRequests(List<ScheduleResponse> responses)
                 }
                 else if (_schedulingData.BlockedRequestsCount != 0)
                 {
-                    // It is legitimate to have blocked requests with none executing if none of the requests can 
-                    // be serviced by any currently existing node, or if they are blocked by requests, none of 
-                    // which can be serviced by any currently existing node.  However, in that case, we had better 
-                    // be requesting the creation of a node that can service them.  
+                    // It is legitimate to have blocked requests with none executing if none of the requests can
+                    // be serviced by any currently existing node, or if they are blocked by requests, none of
+                    // which can be serviced by any currently existing node.  However, in that case, we had better
+                    // be requesting the creation of a node that can service them.
                     //
-                    // Note: This is O(# nodes * closure of requests blocking current set of blocked requests), 
-                    // but all three numbers should usually be fairly small and, more importantly, this situation 
-                    // should occur at most once per build, since it requires a situation where all blocked requests 
-                    // are blocked on the creation of a node that can service them. 
+                    // Note: This is O(# nodes * closure of requests blocking current set of blocked requests),
+                    // but all three numbers should usually be fairly small and, more importantly, this situation
+                    // should occur at most once per build, since it requires a situation where all blocked requests
+                    // are blocked on the creation of a node that can service them.
                     foreach (SchedulableRequest request in _schedulingData.BlockedRequests)
                     {
                         if (RequestOrAnyItIsBlockedByCanBeServiced(request))
@@ -857,7 +857,7 @@ private bool GetSchedulingPlanAndAlgorithm()
 
                 if (!String.IsNullOrEmpty(customScheduler))
                 {
-                    // Assign to the delegate 
+                    // Assign to the delegate
                     if (customScheduler.Equals("WithPlanByMostImmediateReferences", StringComparison.OrdinalIgnoreCase) && _schedulingPlan.IsPlanValid)
                     {
                         _customRequestSchedulingAlgorithm = AssignUnscheduledRequestsWithPlanByMostImmediateReferences;
@@ -1156,7 +1156,7 @@ private void AssignUnscheduledRequestsWithMaxWaitingRequests(List<ScheduleRespon
                     BuildRequest currentRequest = currentSchedulableRequest.BuildRequest;
                     int requiredNodeId = _schedulingData.GetAssignedNodeForRequestConfiguration(currentRequest.ConfigurationId);
 
-                    // This performs the depth-first traversal, assuming that the unassigned build requests has been populated such that the 
+                    // This performs the depth-first traversal, assuming that the unassigned build requests has been populated such that the
                     // top-most requests are the ones most recently issued.  We schedule the first request which can be scheduled to this node.
                     if (requiredNodeId == InvalidNodeId || requiredNodeId == nodeId)
                     {
@@ -1290,7 +1290,7 @@ private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleRe
 
             Dictionary<int, int> configurationCountsByNode = new Dictionary<int, int>(_availableNodes.Count);
 
-            // The configuration count limit will be the average configuration count * X (to allow for some wiggle room) where 
+            // The configuration count limit will be the average configuration count * X (to allow for some wiggle room) where
             // the default value of X is 1.1 (+ 10%)
             int configurationCountLimit = 0;
 
@@ -1329,8 +1329,8 @@ private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleRe
                     {
                         int requiredNodeId = _schedulingData.GetAssignedNodeForRequestConfiguration(request.BuildRequest.ConfigurationId);
 
-                        // Only schedule an entirely new configuration (one not already tied to this node) to this node if we're 
-                        // not already over the limit needed to keep a reasonable balance. 
+                        // Only schedule an entirely new configuration (one not already tied to this node) to this node if we're
+                        // not already over the limit needed to keep a reasonable balance.
                         if (request.AssignedNode == nodeId || requiredNodeId == nodeId || configurationCountsByNode[nodeId] <= configurationCountLimit)
                         {
                             AssignUnscheduledRequestToNode(request, nodeId, responses);
@@ -1345,8 +1345,8 @@ private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleRe
                 }
             }
 
-            // at this point, we may still have work left unassigned, but that's OK -- we're deliberately choosing to delay assigning all available 
-            // requests in order to avoid overloading certain nodes with excess numbers of requests.  
+            // at this point, we may still have work left unassigned, but that's OK -- we're deliberately choosing to delay assigning all available
+            // requests in order to avoid overloading certain nodes with excess numbers of requests.
         }
 
         /// <summary>
@@ -1423,7 +1423,7 @@ private bool AtSchedulingLimit()
                 return false;
             }
 
-            // We're at our limit of schedulable requests if: 
+            // We're at our limit of schedulable requests if:
             // (1) MaxNodeCount requests are currently executing
             if (_schedulingData.ExecutingRequestsCount >= _componentHost.BuildParameters.MaxNodeCount)
             {
@@ -1485,9 +1485,9 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
             {
                 int assignedNodeForConfiguration = _schedulingData.GetAssignedNodeForRequestConfiguration(request.BuildRequest.ConfigurationId);
 
-                // Although this request has not been scheduled, this configuration may previously have been 
-                // scheduled to an existing node.  If so, we shouldn't count it in our checks for new node 
-                // creation, because it'll only eventually get assigned to its existing node anyway.  
+                // Although this request has not been scheduled, this configuration may previously have been
+                // scheduled to an existing node.  If so, we shouldn't count it in our checks for new node
+                // creation, because it'll only eventually get assigned to its existing node anyway.
                 if (assignedNodeForConfiguration != Scheduler.InvalidNodeId)
                 {
                     continue;
@@ -1500,9 +1500,9 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
                     case NodeAffinity.InProc:
                         inProcNodesToCreate++;
 
-                        // If we've previously seen "Any"-affinitized requests, now that there are some 
-                        // genuine inproc requests, they get to play with the inproc node first, so 
-                        // push the "Any" requests to the out-of-proc nodes.  
+                        // If we've previously seen "Any"-affinitized requests, now that there are some
+                        // genuine inproc requests, they get to play with the inproc node first, so
+                        // push the "Any" requests to the out-of-proc nodes.
                         if (requestsWithAnyAffinityOnInProcNodes > 0)
                         {
                             requestsWithAnyAffinityOnInProcNodes--;
@@ -1539,7 +1539,7 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
                         break;
                 }
 
-                // We've already hit the limit of the number of nodes we'll be allowed to create, so just quit counting now. 
+                // We've already hit the limit of the number of nodes we'll be allowed to create, so just quit counting now.
                 if (inProcNodesToCreate >= availableNodesWithInProcAffinity && outOfProcNodesToCreate >= availableNodesWithOutOfProcAffinity)
                 {
                     break;
@@ -1549,7 +1549,7 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
             // If we think we want to create inproc nodes
             if (inProcNodesToCreate > 0)
             {
-                // In-proc node determination is simple: we want as many as are available.  
+                // In-proc node determination is simple: we want as many as are available.
                 inProcNodesToCreate = Math.Min(availableNodesWithInProcAffinity, inProcNodesToCreate);
 
                 // If we still want to create one, go ahead
@@ -1559,8 +1559,8 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
                     TraceScheduler("Requesting creation of new node satisfying affinity {0}", NodeAffinity.InProc);
                     responses.Add(ScheduleResponse.CreateNewNodeResponse(NodeAffinity.InProc, 1));
 
-                    // We only want to submit one node creation request at a time -- as part of node creation we recursively re-request the scheduler 
-                    // to do more scheduling, so the other request will be dealt with soon enough.  
+                    // We only want to submit one node creation request at a time -- as part of node creation we recursively re-request the scheduler
+                    // to do more scheduling, so the other request will be dealt with soon enough.
                     return true;
                 }
             }
@@ -1568,17 +1568,17 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
             // If we think we want to create out-of-proc nodes
             if (outOfProcNodesToCreate > 0)
             {
-                // Out-of-proc node determination is a bit more complicated.  If we have N out-of-proc requests, we want to 
-                // fill up to N out-of-proc nodes.  However, if we have N "any" requests, we must assume that at least some of them 
-                // will be fulfilled by the inproc node, in which case we only want to launch up to N-1 out-of-proc nodes, for a 
-                // total of N nodes overall -- the scheduler will only schedule to N nodes at a time, so launching any more than that 
-                // is ultimately pointless. 
+                // Out-of-proc node determination is a bit more complicated.  If we have N out-of-proc requests, we want to
+                // fill up to N out-of-proc nodes.  However, if we have N "any" requests, we must assume that at least some of them
+                // will be fulfilled by the inproc node, in which case we only want to launch up to N-1 out-of-proc nodes, for a
+                // total of N nodes overall -- the scheduler will only schedule to N nodes at a time, so launching any more than that
+                // is ultimately pointless.
                 int maxCreatableOutOfProcNodes = availableNodesWithOutOfProcAffinity;
 
                 if (requestsWithOutOfProcAffinity < availableNodesWithOutOfProcAffinity)
                 {
-                    // We don't have enough explicitly out-of-proc requests to justify creating every technically allowed 
-                    // out-of-proc node, so our max is actually one less than the absolute max for the reasons explained above. 
+                    // We don't have enough explicitly out-of-proc requests to justify creating every technically allowed
+                    // out-of-proc node, so our max is actually one less than the absolute max for the reasons explained above.
                     maxCreatableOutOfProcNodes--;
                 }
 
@@ -1591,12 +1591,12 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
                     responses.Add(ScheduleResponse.CreateNewNodeResponse(NodeAffinity.OutOfProc, outOfProcNodesToCreate));
                 }
 
-                // We only want to submit one node creation request at a time -- as part of node creation we recursively re-request the scheduler 
-                // to do more scheduling, so the other request will be dealt with soon enough.  
+                // We only want to submit one node creation request at a time -- as part of node creation we recursively re-request the scheduler
+                // to do more scheduling, so the other request will be dealt with soon enough.
                 return true;
             }
 
-            // If we haven't returned before now, we haven't asked that any new nodes be created.  
+            // If we haven't returned before now, we haven't asked that any new nodes be created.
             return false;
         }
 
@@ -1661,14 +1661,14 @@ private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequ
             // we will update the storage location in the configuration.  This is doing a bit of a run around the scheduler - we don't
             // create a new formal request, so we treat the blocked request as if it is still executing - this prevents any other requests
             // from getting onto that node and also means we don't have to do additional work to get the scheduler to understand the bizarre
-            // case of sending a request for results from a project's own configuration (which it believes reside on the very node which 
+            // case of sending a request for results from a project's own configuration (which it believes reside on the very node which
             // is actually requesting the results in the first place.)
             BuildRequestConfiguration configuration = _configCache[parentRequest.BuildRequest.ConfigurationId];
             responses.Add(ScheduleResponse.CreateScheduleResponse(configuration.ResultsNodeId, newRequest, false));
 
             TraceScheduler("Created request {0} (node request {1}) for transfer of configuration {2}'s results from node {3} to node {4}", newRequest.GlobalRequestId, newRequest.NodeRequestId, configuration.ConfigurationId, configuration.ResultsNodeId, parentRequest.AssignedNode);
 
-            // The configuration's results will now be homed at the new location (once they have come back from the 
+            // The configuration's results will now be homed at the new location (once they have come back from the
             // original node.)
             configuration.ResultsNodeId = parentRequest.AssignedNode;
         }
@@ -1870,7 +1870,7 @@ private void ResolveRequestFromCacheAndResumeIfPossible(SchedulableRequest reque
                         responses.Add(response);
                     }
 
-                    // Is the node we are reporting to idle? If so, does reporting this result allow it to proceed with work? 
+                    // Is the node we are reporting to idle? If so, does reporting this result allow it to proceed with work?
                     if (!_schedulingData.IsNodeWorking(response.NodeId))
                     {
                         ResumeReadyRequestIfAny(response.NodeId, responses);
@@ -2104,7 +2104,7 @@ internal void RecordResultToCurrentCacheIfConfigNotInOverrideCache(BuildResult r
         /// </summary>
         private ScheduleResponse GetResponseForResult(int parentRequestNode, BuildRequest requestWhichGeneratedResult, BuildResult result)
         {
-            // We have results, return them to the originating node, or if it is a root request, mark the submission complete.      
+            // We have results, return them to the originating node, or if it is a root request, mark the submission complete.
             if (requestWhichGeneratedResult.IsRootRequest)
             {
                 // return new ScheduleResponse(result);
@@ -2223,9 +2223,9 @@ private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request)
                     }
                 }
 
-                // if none of the requests we are blocked by can be serviced, it doesn't matter 
-                // whether we can be serviced or not -- the reason we're blocked is because none 
-                // of the requests we are blocked by can be serviced. 
+                // if none of the requests we are blocked by can be serviced, it doesn't matter
+                // whether we can be serviced or not -- the reason we're blocked is because none
+                // of the requests we are blocked by can be serviced.
                 return false;
             }
             else
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index e28c86db050..18ba022d5a6 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -605,7 +605,7 @@ public IEnumerable<SchedulableRequest> GetReadyRequestsByNode(int nodeId)
         }
 
         /// <summary>
-        /// Retrieves a set of build requests which have the specified parent.  If root is null, this will retrieve all of the 
+        /// Retrieves a set of build requests which have the specified parent.  If root is null, this will retrieve all of the
         /// top-level requests.
         /// </summary>
         public IEnumerable<SchedulableRequest> GetRequestsByHierarchy(SchedulableRequest root)
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 19f75d8da72..c15b5a25063 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -462,7 +462,7 @@ private void RecursiveAccumulateConfigurationTimes(SchedulableRequest request, D
         {
             double accumulatedTime;
 
-            // NOTE: Do we want to count it each time the config appears in the hierarchy?  This will inflate the 
+            // NOTE: Do we want to count it each time the config appears in the hierarchy?  This will inflate the
             // cost of frequently referenced configurations.
             accumulatedTimeByConfiguration.TryGetValue(request.BuildRequest.ConfigurationId, out accumulatedTime);
             accumulatedTimeByConfiguration[request.BuildRequest.ConfigurationId] = accumulatedTime + request.GetTimeSpentInState(SchedulableRequestState.Executing).TotalMilliseconds;
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 40dc8ffdf2b..5241e228c2f 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// sends requests to the main node that SDK resolution is handled in a central location.  This instance is registered in <see cref="Microsoft.Build.Execution.OutOfProcNode"/>
     /// using a factory so that parameters can be passed to the constructor.  This service caches responses for a given build so that it can avoid sending
     /// a packet where possible.  The cache is always in effect here because the out-of-proc node is only used for builds.
-    /// 
+    ///
     /// Since this object is a registered <see cref="IBuildComponent"/>, it is a singleton for the main process.  To get an instance of it, you
     /// must have access to an <see cref="IBuildComponentHost"/> and call <see cref="IBuildComponentHost.GetComponent"/> and pass <see cref="BuildComponentType.SdkResolverService"/>.
     /// </summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverServiceFactory.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverServiceFactory.cs
index 6c739e55493..4c0415bce26 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverServiceFactory.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverServiceFactory.cs
@@ -8,7 +8,7 @@
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
     /// <summary>
-    /// A factory used when creating a <see cref="OutOfProcNodeSdkResolverService"/> which can pass parameters to its constructor.  Our 
+    /// A factory used when creating a <see cref="OutOfProcNodeSdkResolverService"/> which can pass parameters to its constructor.  Our
     /// dependency inject cannot pass parameters to constructors so this factory is used as a middle man.
     /// </summary>
     internal sealed class OutOfProcNodeSdkResolverServiceFactory
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
index 23a79a398d6..3e319d90adf 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
@@ -41,7 +41,7 @@ public SdkResolverManifest(string DisplayName, string Path, Regex ResolvableSdkR
         public string Path { get; private set; }
 
         /// <summary>
-        /// Regex which matches all the sdk names that could be resolved by the resolvers associated with given manifest.  
+        /// Regex which matches all the sdk names that could be resolved by the resolvers associated with given manifest.
         /// </summary>
         public Regex ResolvableSdkRegex { get; private set; }
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 7e372fcdf7b..ea709d47440 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -201,7 +201,7 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
                 warnings.AddRange(firstWarnings);
             }
 
-            // Second pass: fallback to general resolvers. 
+            // Second pass: fallback to general resolvers.
             resolvers = GetResolvers(
                 _generalResolversManifestsRegistry,
                 loggingContext,
diff --git a/src/Build/BackEnd/Node/NativeMethods.cs b/src/Build/BackEnd/Node/NativeMethods.cs
index b986a5bce03..c1540aae0c2 100644
--- a/src/Build/BackEnd/Node/NativeMethods.cs
+++ b/src/Build/BackEnd/Node/NativeMethods.cs
@@ -86,8 +86,8 @@ internal struct STARTUP_INFO
             internal string lpDesktop;
 
             /// <summary>
-            /// For console processes, this is the title displayed in the title bar if a new console window is created. 
-            /// If NULL, the name of the executable file is used as the window title instead. 
+            /// For console processes, this is the title displayed in the title bar if a new console window is created.
+            /// If NULL, the name of the executable file is used as the window title instead.
             /// This parameter must be NULL for GUI or console processes that do not create a new console window
             /// </summary>
             internal string lpTitle;
@@ -103,7 +103,7 @@ internal struct STARTUP_INFO
             internal Int32 dwY;
 
             /// <summary>
-            /// If dwFlags specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in pixels. Otherwise, this member is ignored. 
+            /// If dwFlags specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in pixels. Otherwise, this member is ignored.
             /// </summary>
             internal Int32 dwXSize;
 
@@ -118,12 +118,12 @@ internal struct STARTUP_INFO
             internal Int32 dwXCountChars;
 
             /// <summary>
-            /// If dwFlags specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.dwFillAttribute 
+            /// If dwFlags specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.dwFillAttribute
             /// </summary>
             internal Int32 dwYCountChars;
 
             /// <summary>
-            /// If dwFlags specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a new console window is created in a console application. Otherwise, this member is ignored. 
+            /// If dwFlags specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a new console window is created in a console application. Otherwise, this member is ignored.
             /// </summary>
             internal Int32 dwFillAttribute;
 
@@ -177,12 +177,12 @@ internal struct SECURITY_ATTRIBUTES
 
             /// <summary>
             /// A pointer to a security descriptor for the object that controls the sharing of it.
-            /// If NULL is specified for this member, the object is assigned the default security descriptor of the calling process. 
-            /// This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL). 
+            /// If NULL is specified for this member, the object is assigned the default security descriptor of the calling process.
+            /// This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL).
             /// The default security descriptor is based on the default DACL of the access token belonging to the calling process.
-            /// By default, the default DACL in the access token of a process allows access only to the user represented by the access token. 
-            /// If other users must access the object, you can either create a security descriptor with the appropriate access, 
-            /// or add ACEs to the DACL that grants access to a group of users. 
+            /// By default, the default DACL in the access token of a process allows access only to the user represented by the access token.
+            /// If other users must access the object, you can either create a security descriptor with the appropriate access,
+            /// or add ACEs to the DACL that grants access to a group of users.
             /// </summary>
             public IntPtr lpSecurityDescriptor;
 
@@ -212,7 +212,7 @@ internal struct PROCESS_INFORMATION
 
             /// <summary>
             /// A value that can be used to identify a process.
-            /// The value is valid from the time the process is created until all handles to the process are closed and 
+            /// The value is valid from the time the process is created until all handles to the process are closed and
             /// the process object is freed; at this point, the identifier may be reused.
             /// </summary>
             public int dwProcessId;
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 7757598b2cd..afa0d2aec65 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -586,7 +586,7 @@ private void SendPacket(INodePacket packet)
             {
 #if RUNTIME_TYPE_NETCORE
                 if (packet is LogMessagePacketBase logMessage
-                    && logMessage.EventType == LoggingEventType.CustomEvent 
+                    && logMessage.EventType == LoggingEventType.CustomEvent
                     &&
                     (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
                     && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
@@ -729,7 +729,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             }
 
             // We want to make sure the global project collection has the toolsets which were defined on the parent
-            // so that any custom toolsets defined can be picked up by tasks who may use the global project collection but are 
+            // so that any custom toolsets defined can be picked up by tasks who may use the global project collection but are
             // executed on the child node.
             ICollection<Toolset> parentToolSets = _buildParameters.ToolsetProvider.Toolsets;
             if (parentToolSets != null)
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index f419172153b..aa28f7213e0 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.Experimental
 {
     /// <summary>
-    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server 
+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server
     /// </summary>
     public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler
     {
@@ -69,7 +69,7 @@ public delegate (int exitCode, string exitType) BuildCallback(
 
         /// <summary>
         /// Indicate that cancel has been requested and initiated.
-        /// </summary>        
+        /// </summary>
         private bool _cancelRequested = false;
         private string _serverBusyMutexName = default!;
 
@@ -92,7 +92,7 @@ public OutOfProcServerNode(BuildCallback buildFunction)
         /// <summary>
         /// Starts up the server node and processes all build requests until the server is requested to shut down.
         /// </summary>
-        /// <param name="shutdownException">The exception which caused shutdown, if any.</param> 
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
         /// <returns>The reason for shutting down.</returns>
         public NodeEngineShutdownReason Run(out Exception? shutdownException)
         {
diff --git a/src/Build/BackEnd/Shared/BuildAbortedException.cs b/src/Build/BackEnd/Shared/BuildAbortedException.cs
index d62a1504c70..8588ba771dd 100644
--- a/src/Build/BackEnd/Shared/BuildAbortedException.cs
+++ b/src/Build/BackEnd/Shared/BuildAbortedException.cs
@@ -88,7 +88,7 @@ protected override void InitializeCustomState(IDictionary<string, string> state)
         }
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
 #if NET8_0_OR_GREATER
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 838210573f6..eda42874f86 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -306,7 +306,7 @@ public bool IsTraversal
                     }
                     else if (FileUtilities.IsMetaprojectFilename(ProjectFullPath))
                     {
-                        // Metaprojects generated by the SolutionProjectGenerator are traversals.  They have no 
+                        // Metaprojects generated by the SolutionProjectGenerator are traversals.  They have no
                         // on-disk representation - they are ProjectInstances which exist only in memory.
                         _isTraversalProject = true;
                     }
diff --git a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
index 6617ff8b911..6f5ab6e48d6 100644
--- a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.BackEnd
     /// There are two cases:
     /// 1. The request was blocked waiting on a target in the same project.  In this case this class will contain
     ///    no information other than the request id.
-    /// 2. The request was blocked on some set of build requests.  This class will then contain the build results 
+    /// 2. The request was blocked on some set of build requests.  This class will then contain the build results
     ///    needed to satisfy those requests.
     /// </summary>
     internal class BuildRequestUnblocker : ITranslatable, INodePacket
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 149ec426518..68aa197381f 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -311,7 +311,7 @@ public int NodeRequestId
         }
 
         /// <summary>
-        /// Returns the exception generated while this result was run, if any. 
+        /// Returns the exception generated while this result was run, if any.
         /// </summary>
         public Exception Exception
         {
@@ -657,8 +657,8 @@ private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDict
         }
 
         /// <summary>
-        /// Creates the target result dictionary and populates it with however many target results are 
-        /// available given the list of targets passed. 
+        /// Creates the target result dictionary and populates it with however many target results are
+        /// available given the list of targets passed.
         /// </summary>
         private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionaryWithContents(BuildResult existingResults, string[] targetNames)
         {
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 2840148876c..d435d1c3606 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -185,7 +185,7 @@ void ITranslatable.Translate(ITranslator translator)
             {
                 lock (_result)
                 {
-                    // Should we have cached these items but now want to send them to another node, we need to 
+                    // Should we have cached these items but now want to send them to another node, we need to
                     // ensure they are loaded before doing so.
                     RetrieveItemsFromCache();
                     InternalTranslate(translator);
@@ -305,7 +305,7 @@ private void TranslateItems(ITranslator translator)
                 // When creating the interner, we use the number of items as the initial size of the collections since the
                 // number of strings will be of the order of the number of items in the collection.  This assumes basically
                 // one unique string per item (frequently a path related to the item) with most of the rest of the metadata
-                // being the same (and thus interning.)  This is a hueristic meant to get us in the ballpark to avoid 
+                // being the same (and thus interning.)  This is a hueristic meant to get us in the ballpark to avoid
                 // too many reallocations when growing the collections.
                 var interner = new LookasideStringInterner(StringComparer.Ordinal, _items.Length);
                 foreach (TaskItem t in _items)
diff --git a/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
index 6d25f2f4688..60dfee13d2c 100644
--- a/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
@@ -41,7 +41,7 @@ internal enum TaskRequirements
     /// are pass-throughs to just set some member variables and call methods directly on the task and associated objects.
     /// In the out-of-proc/AppDomain-isolated case, the object implementing these methods may break apart the information
     /// in the parameters to be consumed by the IContract representing the remote object through MAF.
-    /// 
+    ///
     /// REFACTOR - Eliminate this interface.
     /// </summary>
     internal interface ITaskExecutionHost
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 83b46097d82..76e975fe3c3 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -15,11 +15,11 @@ namespace Microsoft.Build.Collections
 {
     /// <summary>
     /// A dictionary of unordered property or metadata name/value pairs, with copy-on-write semantics.
-    /// 
+    ///
     /// The copy-on-write semantics are only possible if the contained type is immutable, which currently
     /// means it can only be used for ProjectMetadataInstance's.
     /// USE THIS DICTIONARY ONLY FOR IMMUTABLE TYPES. OTHERWISE USE PROPERTYDICTIONARY.
-    /// 
+    ///
     /// </summary>
     /// <remarks>
     /// The value that this adds over IDictionary&lt;string, T&gt; is:
@@ -27,9 +27,9 @@ namespace Microsoft.Build.Collections
     ///     - enforces that key = T.Name
     ///     - default enumerator is over values
     ///     - (marginal) enforces the correct key comparer
-    /// 
+    ///
     /// Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
-    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and 
+    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and
     /// either not expose this collection or expose it through a readonly wrapper.
     ///
     /// This collection is safe for concurrent readers and a single writer.
@@ -149,7 +149,7 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
                 return false;
             }
 
-            // Copy both backing collections to locals 
+            // Copy both backing collections to locals
             ImmutableDictionary<string, T> thisBacking = _backing;
             ImmutableDictionary<string, T> thatBacking = other._backing;
 
@@ -299,7 +299,7 @@ IEnumerable<KeyValuePair<string, T>> Items()
         }
 
         /// <summary>
-        /// Clone. As we're copy on write, this 
+        /// Clone. As we're copy on write, this
         /// should be cheap.
         /// </summary>
         internal CopyOnWritePropertyDictionary<T> DeepClone()
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index d2543da7f5b..ee57e45788c 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -13,17 +13,17 @@
 namespace Microsoft.Build.Collections
 {
     /// <summary>
-    /// Collection of items that allows a list of all items of a specified type to be 
-    /// retrieved in O(1), and specific items to be added, removed, or checked for in O(1). 
+    /// Collection of items that allows a list of all items of a specified type to be
+    /// retrieved in O(1), and specific items to be added, removed, or checked for in O(1).
     /// All items of a particular type can also be removed in O(1).
     /// Items are ordered with respect to all other items of their type.
     /// </summary>
     /// <remarks>
     /// Really a Dictionary&lt;string, ICollection&lt;T&gt;&gt; where the key (the item type) is obtained from IKeyed.Key
-    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and 
+    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and
     /// either not expose this collection or expose it through a readonly wrapper.
     /// At various places in this class locks are taken on the backing collection.  The reason for this is to allow
-    /// this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will 
+    /// this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will
     /// lock the backing collection when it does its deep cloning.  This prevents asynchronous access from corrupting
     /// the state of the enumeration until the collection has been fully copied.
     /// </remarks>
@@ -248,7 +248,7 @@ internal void Add(T projectItem)
         /// <remarks>
         /// If a list is emptied, removes the list from the enclosing collection
         /// so it can be garbage collected.
-        /// </remarks>        
+        /// </remarks>
         internal bool Remove(T projectItem)
         {
             lock (_itemLists)
diff --git a/src/Build/Collections/MultiDictionary.cs b/src/Build/Collections/MultiDictionary.cs
index 4c1243c7010..b2fc7427261 100644
--- a/src/Build/Collections/MultiDictionary.cs
+++ b/src/Build/Collections/MultiDictionary.cs
@@ -26,12 +26,12 @@ internal class MultiDictionary<K, V>
         where K : class
         where V : class
     {
-        // The simplest implementation of MultiDictionary would use a Dictionary<K, List<V>>. 
+        // The simplest implementation of MultiDictionary would use a Dictionary<K, List<V>>.
         // However, a List<T> with one element is 44 bytes (empty, 24 bytes)
         // even though a single Object takes up only 12 bytes.
         // If most values are only one element, we can save space by storing Object
         // and using its implicit type field to discriminate.
-        // 
+        //
         // Experiments, using a large number of keys:
         //
         // Dictionary<string,List<object>>, each key with one item, 127 bytes/key
@@ -47,7 +47,7 @@ internal class MultiDictionary<K, V>
         // MultiDictionary<string, object>, each key with 2 items, 139 bytes/key
         //
         // Savings for 10,000 objects with 1.01 per entry is 420Kb out of 1.2Mb
-        // If keys and values are already allocated (e.g., strings in use elsewhere) then this is 
+        // If keys and values are already allocated (e.g., strings in use elsewhere) then this is
         // the complete cost of the collection.
 
         /// <summary>
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 5b20c1f59ba..7672333cd2b 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -21,16 +21,16 @@ namespace Microsoft.Build.Collections
     ///     - default enumerator is over values
     ///     - (marginal) enforces the correct key comparer
     ///     - potentially makes copy on write possible
-    /// 
+    ///
     /// Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
-    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and 
+    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and
     /// either not expose this collection or expose it through a readonly wrapper.
     /// At various places in this class locks are taken on the backing collection.  The reason for this is to allow
-    /// this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will 
+    /// this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will
     /// lock the backing collection when it does its deep cloning.  This prevents asynchronous access from corrupting
     /// the state of the enumeration until the collection has been fully copied.
-    /// 
-    /// Since we use the mutable ignore case comparer we need to make sure that we lock our self before we call the comparer since the comparer can call back 
+    ///
+    /// Since we use the mutable ignore case comparer we need to make sure that we lock our self before we call the comparer since the comparer can call back
     /// into this dictionary which could cause a deadlock if another thread is also accessing another method in the dictionary.
     /// </remarks>
     /// <typeparam name="T">Property or Metadata class type to store</typeparam>
diff --git a/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs b/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
index 89412677013..2158d913c6a 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
@@ -9,12 +9,12 @@ namespace Microsoft.Build.Collections
 {
     /// <summary>
     /// ABOUT:
-    /// Helps with operations that rely on bit marking to indicate whether an item in the 
-    /// collection should be added, removed, visited already, etc. 
-    /// 
-    /// BitHelper doesn't allocate the array; you must pass in an array or ints allocated on the 
-    /// stack or heap. ToIntArrayLength() tells you the int array size you must allocate. 
-    /// 
+    /// Helps with operations that rely on bit marking to indicate whether an item in the
+    /// collection should be added, removed, visited already, etc.
+    ///
+    /// BitHelper doesn't allocate the array; you must pass in an array or ints allocated on the
+    /// stack or heap. ToIntArrayLength() tells you the int array size you must allocate.
+    ///
     /// USAGE:
     /// Suppose you need to represent a bit array of length (i.e. logical bit array length)
     /// BIT_ARRAY_LENGTH. Then this is the suggested way to instantiate BitHelper:
@@ -28,20 +28,20 @@ namespace Microsoft.Build.Collections
     ///     int[] m_arrayPtr = new int[intArrayLength];
     ///     bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
     /// ***************************************************************************
-    /// 
+    ///
     /// IMPORTANT:
     /// The second ctor args, length, should be specified as the length of the int array, not
     /// the logical bit array. Because length is used for bounds checking into the int array,
-    /// it's especially important to get this correct for the stackalloc version. See the code 
-    /// samples above; this is the value gotten from ToIntArrayLength(). 
-    /// 
-    /// The length ctor argument is the only exception; for other methods -- MarkBit and 
+    /// it's especially important to get this correct for the stackalloc version. See the code
+    /// samples above; this is the value gotten from ToIntArrayLength().
+    ///
+    /// The length ctor argument is the only exception; for other methods -- MarkBit and
     /// IsMarked -- pass in values as indices into the logical bit array, and it will be mapped
     /// to the position within the array of ints.
-    /// 
+    ///
     /// FUTURE OPTIMIZATIONS:
-    /// A method such as FindFirstMarked/Unmarked Bit would be useful for callers that operate 
-    /// on a bit array and then need to loop over it. In particular, if it avoided visiting 
+    /// A method such as FindFirstMarked/Unmarked Bit would be useful for callers that operate
+    /// on a bit array and then need to loop over it. In particular, if it avoided visiting
     /// every bit, it would allow good perf improvements when the bit array is sparse.
     /// </summary>
     internal unsafe class BitHelper
@@ -59,7 +59,7 @@ internal unsafe class BitHelper
         // array of ints
         private readonly int[] _array;
 
-        // whether to operate on stack alloc'd or heap alloc'd array 
+        // whether to operate on stack alloc'd or heap alloc'd array
         private readonly bool _useStackAlloc;
 
         /// <summary>
@@ -136,7 +136,7 @@ internal bool IsMarked(int bitPosition)
         }
 
         /// <summary>
-        /// How many ints must be allocated to represent n bits. Returns (n+31)/32, but 
+        /// How many ints must be allocated to represent n bits. Returns (n+31)/32, but
         /// avoids overflow
         /// </summary>
         /// <param name="n"></param>
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
index 49baf191c18..0e3499b0248 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
@@ -18,9 +18,9 @@ namespace Microsoft.Build.Collections
     /// </summary>
     internal static class HashHelpers
     {
-        // Table of prime numbers to use as hash table sizes. 
+        // Table of prime numbers to use as hash table sizes.
         // The entry used for capacity is the smallest prime number in this array
-        // that is larger than twice the previous capacity. 
+        // that is larger than twice the previous capacity.
 
         internal static readonly int[] primes = {
             3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919,
@@ -69,7 +69,7 @@ internal static int GetPrime(int min)
                 }
             }
 
-            // Outside of our predefined table. Compute the hard way. 
+            // Outside of our predefined table. Compute the hard way.
             for (int i = (min | 1); i < Int32.MaxValue; i += 2)
             {
                 if (IsPrime(i))
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index fb954982e34..8824d26e051 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -21,7 +21,7 @@
     * require T implements IKeyed, and accept IKeyed directly where necessary
     * all constructors require a comparer -- an IEqualityComparer<IKeyed> -- to avoid mistakes
     * change Contains to give you back the found entry, rather than a boolean
-    * change Add so that it always adds, even if there's an entry already present with the same name. 
+    * change Add so that it always adds, even if there's an entry already present with the same name.
            We want "replacement" semantics, like a dictionary keyed on name.
     * constructor that allows the collection to be read-only
     * implement IDictionary<string, T>
@@ -43,36 +43,36 @@ namespace Microsoft.Build.Collections
     /// Implementation notes:
     /// This uses an array-based implementation similar to <see cref="Dictionary{TKey, TValue}" />, using a buckets array
     /// to map hash values to the Slots array. Items in the Slots array that hash to the same value
-    /// are chained together through the "next" indices. 
-    /// 
+    /// are chained together through the "next" indices.
+    ///
     /// The capacity is always prime; so during resizing, the capacity is chosen as the next prime
-    /// greater than double the last capacity. 
-    /// 
-    /// The underlying data structures are lazily initialized. Because of the observation that, 
+    /// greater than double the last capacity.
+    ///
+    /// The underlying data structures are lazily initialized. Because of the observation that,
     /// in practice, hashtables tend to contain only a few elements, the initial capacity is
     /// set very small (3 elements) unless the ctor with a collection is used.
-    /// 
-    /// The +/- 1 modifications in methods that add, check for containment, etc allow us to 
-    /// distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to 
+    ///
+    /// The +/- 1 modifications in methods that add, check for containment, etc allow us to
+    /// distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to
     /// reset each bucket to -1 when resizing. See Contains, for example.
-    /// 
+    ///
     /// Set methods such as UnionWith, IntersectWith, ExceptWith, and SymmetricExceptWith modify
     /// this set.
-    /// 
+    ///
     /// Some operations can perform faster if we can assume "other" contains unique elements
     /// according to this equality comparer. The only times this is efficient to check is if
     /// other is a hashset. Note that checking that it's a hashset alone doesn't suffice; we
-    /// also have to check that the hashset is using the same equality comparer. If other 
+    /// also have to check that the hashset is using the same equality comparer. If other
     /// has a different equality comparer, it will have unique elements according to its own
-    /// equality comparer, but not necessarily according to ours. Therefore, to go these 
+    /// equality comparer, but not necessarily according to ours. Therefore, to go these
     /// optimized routes we check that other is a hashset using the same equality comparer.
-    /// 
-    /// A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for 
+    ///
+    /// A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for
     /// special empty set checks.)
-    /// 
-    /// A couple of methods have a special case if other is this (e.g. SymmetricExceptWith). 
+    ///
+    /// A couple of methods have a special case if other is this (e.g. SymmetricExceptWith).
     /// If we didn't have these checks, we could be iterating over the set and modifying at
-    /// the same time. 
+    /// the same time.
     /// </summary>
     /// <typeparam name="T"></typeparam>
     [DebuggerTypeProxy(typeof(Microsoft.Build.Collections.HashSetDebugView<>))]
@@ -90,7 +90,7 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
         // store lower 31 bits of hash code
         private const int Lower31BitMask = 0x7FFFFFFF;
 
-        // when constructing a hashset from an existing collection, it may contain duplicates, 
+        // when constructing a hashset from an existing collection, it may contain duplicates,
         // so this is used as the max acceptable excess ratio of capacity to count. Note that
         // this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
         // a lot of adds followed by removes. Users must explicitly shrink by calling TrimExcess.
@@ -147,8 +147,8 @@ public RetrievableEntryHashSet(IEnumerable<KeyValuePair<string, T>> collection,
 
         /// <summary>
         /// Implementation Notes:
-        /// Since resizes are relatively expensive (require rehashing), this attempts to minimize 
-        /// the need to resize by setting the initial capacity based on size of collection. 
+        /// Since resizes are relatively expensive (require rehashing), this attempts to minimize
+        /// the need to resize by setting the initial capacity based on size of collection.
         /// </summary>
         public RetrievableEntryHashSet(int suggestedCapacity, IEqualityComparer<string> comparer)
             : this(comparer)
@@ -158,8 +158,8 @@ public RetrievableEntryHashSet(int suggestedCapacity, IEqualityComparer<string>
 
         /// <summary>
         /// Implementation Notes:
-        /// Since resizes are relatively expensive (require rehashing), this attempts to minimize 
-        /// the need to resize by setting the initial capacity based on size of collection. 
+        /// Since resizes are relatively expensive (require rehashing), this attempts to minimize
+        /// the need to resize by setting the initial capacity based on size of collection.
         /// </summary>
         public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<string> comparer)
             : this(comparer)
@@ -192,9 +192,9 @@ public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<stri
 
         protected RetrievableEntryHashSet(SerializationInfo info, StreamingContext context)
         {
-            // We can't do anything with the keys and values until the entire graph has been 
-            // deserialized and we have a reasonable estimate that GetHashCode is not going to 
-            // fail.  For the time being, we'll just cache this.  The graph is not valid until 
+            // We can't do anything with the keys and values until the entire graph has been
+            // deserialized and we have a reasonable estimate that GetHashCode is not going to
+            // fail.  For the time being, we'll just cache this.  The graph is not valid until
             // OnDeserialization has been called.
             _siInfo = info;
         }
@@ -253,7 +253,7 @@ void ICollection<T>.Add(T item)
         }
 
         /// <summary>
-        /// Remove all items from this set. This clears the elements but not the underlying 
+        /// Remove all items from this set. This clears the elements but not the underlying
         /// buckets and slots array. Follow this call by TrimExcess to release these.
         /// </summary>
         public void Clear()
@@ -268,7 +268,7 @@ public void Clear()
                 Debug.Assert(_buckets != null, "m_buckets was null but m_lastIndex > 0");
 
                 // clear the elements so that the gc can reclaim the references.
-                // clear only up to m_lastIndex for m_slots 
+                // clear only up to m_lastIndex for m_slots
                 Array.Clear(_slots, 0, _lastIndex);
                 Array.Clear(_buckets, 0, _buckets.Length);
                 _lastIndex = 0;
@@ -392,7 +392,7 @@ public void CopyTo(T[] array, int arrayIndex)
 
         /// <summary>
         /// Remove entry that compares equal to T
-        /// </summary>        
+        /// </summary>
         public bool Remove(T item)
         {
             return Remove(item.Key);
@@ -542,9 +542,9 @@ public virtual void OnDeserialization(Object sender)
         {
             if (_siInfo == null)
             {
-                // It might be necessary to call OnDeserialization from a container if the 
-                // container object also implements OnDeserialization. However, remoting will 
-                // call OnDeserialization again. We can return immediately if this function is 
+                // It might be necessary to call OnDeserialization from a container if the
+                // container object also implements OnDeserialization. However, remoting will
+                // call OnDeserialization again. We can return immediately if this function is
                 // called twice. Note we set m_siInfo to null at the end of this method.
                 return;
             }
@@ -586,7 +586,7 @@ public virtual void OnDeserialization(Object sender)
         #region HashSet methods
 
         /// <summary>
-        /// Add item to this HashSet. 
+        /// Add item to this HashSet.
         /// *** MSBUILD NOTE: Always added - overwrite semantics
         /// </summary>
         public void Add(T item)
@@ -613,9 +613,9 @@ void ICollection<KeyValuePair<string, T>>.Add(KeyValuePair<string, T> entry)
 
         /// <summary>
         /// Take the union of this HashSet with other. Modifies this set.
-        /// 
-        /// Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
-        /// multiple resizes ended up not being useful in practice; quickly gets to the 
+        ///
+        /// Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding
+        /// multiple resizes ended up not being useful in practice; quickly gets to the
         /// point where it's a wasteful check.
         /// </summary>
         /// <param name="other">enumerable with items to add</param>
@@ -695,13 +695,13 @@ public void CopyTo(T[] array, int arrayIndex, int count)
         /// <summary>
         /// Sets the capacity of this list to the size of the list (rounded up to nearest prime),
         /// unless count is 0, in which case we release references.
-        /// 
+        ///
         /// This method can be used to minimize a list's memory overhead once it is known that no
-        /// new elements will be added to the list. To completely clear a list and release all 
+        /// new elements will be added to the list. To completely clear a list and release all
         /// memory referenced by the list, execute the following statements:
-        /// 
+        ///
         /// list.Clear();
-        /// list.TrimExcess(); 
+        /// list.TrimExcess();
         /// </summary>
         public void TrimExcess()
         {
@@ -724,7 +724,7 @@ public void TrimExcess()
                 Slot[] newSlots = new Slot[newSize];
                 int[] newBuckets = new int[newSize];
 
-                // move down slots and rehash at the same time. newIndex keeps track of current 
+                // move down slots and rehash at the same time. newIndex keeps track of current
                 // position in newSlots array
                 int newIndex = 0;
                 for (int i = 0; i < _lastIndex; i++)
@@ -771,9 +771,9 @@ private void Initialize(int capacity)
         }
 
         /// <summary>
-        /// Expand to new capacity. New capacity is next prime greater than or equal to suggested 
-        /// size. This is called when the underlying array is filled. This performs no 
-        /// defragmentation, allowing faster execution; note that this is reasonable since 
+        /// Expand to new capacity. New capacity is next prime greater than or equal to suggested
+        /// size. This is called when the underlying array is filled. This performs no
+        /// defragmentation, allowing faster execution; note that this is reasonable since
         /// AddEvenIfPresent attempts to insert new elements in re-opened spots.
         /// </summary>
         private void IncreaseCapacity()
diff --git a/src/Build/Collections/WeakValueDictionary.cs b/src/Build/Collections/WeakValueDictionary.cs
index 34d1267a234..b09f78484ff 100644
--- a/src/Build/Collections/WeakValueDictionary.cs
+++ b/src/Build/Collections/WeakValueDictionary.cs
@@ -119,7 +119,7 @@ public V this[K key]
                 {
                     Scavenge();
 
-                    // If that didn't do anything, raise the capacity at which 
+                    // If that didn't do anything, raise the capacity at which
                     // we next scavenge. Note that we never shrink, but neither
                     // does the underlying dictionary.
                     if (_dictionary.Count == _capacity)
diff --git a/src/Build/Construction/ProjectChooseElement.cs b/src/Build/Construction/ProjectChooseElement.cs
index 4ecc4131aca..0ef3acca430 100644
--- a/src/Build/Construction/ProjectChooseElement.cs
+++ b/src/Build/Construction/ProjectChooseElement.cs
@@ -44,7 +44,7 @@ private ProjectChooseElement(XmlElement xmlElement, ProjectRootElement containin
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index aab13ff3128..a8619b746fc 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -15,7 +15,7 @@
 namespace Microsoft.Build.Construction
 {
     /// <summary>
-    /// Abstract base class for MSBuild construction object model elements. 
+    /// Abstract base class for MSBuild construction object model elements.
     /// </summary>
     public abstract class ProjectElement : IProjectElement, ILinkableObject
     {
@@ -73,7 +73,7 @@ internal ProjectElement(XmlElement xmlElement, ProjectElementContainer parent, P
         /// </summary>
         /// <remarks>
         /// If this is true, then the <see cref="XmlElement"/> will still be used to hold the data for this (pseudo) ProjectElement, but
-        /// it will not be added to the Xml tree.  
+        /// it will not be added to the Xml tree.
         /// </remarks>
         internal virtual bool ExpressedAsAttribute
         {
@@ -95,8 +95,8 @@ internal virtual bool ExpressedAsAttribute
         }
 
         /// <summary>
-        /// Gets or sets the Condition value. 
-        /// It will return empty string IFF a condition attribute is legal but its not present or has no value. 
+        /// Gets or sets the Condition value.
+        /// It will return empty string IFF a condition attribute is legal but its not present or has no value.
         /// It will return null IFF a Condition attribute is illegal on that element.
         /// Removes the attribute if the value to set is empty.
         /// It is possible for derived classes to throw an <see cref="InvalidOperationException"/> if setting the condition is
@@ -120,7 +120,7 @@ public virtual string Condition
         }
 
         /// <summary>
-        /// Gets or sets the Label value. 
+        /// Gets or sets the Label value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -286,7 +286,7 @@ internal set
 
         /// <summary>
         /// Location of the corresponding Xml element.
-        /// May not be correct if file is not saved, or 
+        /// May not be correct if file is not saved, or
         /// file has been edited since it was last saved.
         /// In the case of an unsaved edit, the location only
         /// contains the path to the file that the element originates from.
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index c138612fced..d2386dc8028 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -42,7 +42,7 @@ internal ProjectElementContainer(ProjectElementContainerLink link)
         /// </summary>
         /// <comment>
         /// Should ideally be protected+internal.
-        /// </comment> 
+        /// </comment>
         internal ProjectElementContainer()
         {
         }
@@ -379,7 +379,7 @@ public virtual void DeepCopyFrom(ProjectElementContainer element)
         /// Appends the provided child.
         /// Does not dirty the project, does not add an element, does not set the child's parent,
         /// and does not check the parent's future siblings and parent are acceptable.
-        /// Called during project load, when the child can be expected to 
+        /// Called during project load, when the child can be expected to
         /// already have a parent and its element is already connected to the
         /// parent's element.
         /// All that remains is to set FirstChild/LastChild and fix up the linked list.
diff --git a/src/Build/Construction/ProjectExtensionsElement.cs b/src/Build/Construction/ProjectExtensionsElement.cs
index 83d6520abd8..7674069b671 100644
--- a/src/Build/Construction/ProjectExtensionsElement.cs
+++ b/src/Build/Construction/ProjectExtensionsElement.cs
@@ -47,7 +47,7 @@ private ProjectExtensionsElement(XmlElement xmlElement, ProjectRootElement proje
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
@@ -94,7 +94,7 @@ public override ElementLocation ConditionLocation
         }
 
         /// <summary>
-        /// Get or set the content of the first sub-element 
+        /// Get or set the content of the first sub-element
         /// with the provided name.
         /// </summary>
         public string this[string name]
diff --git a/src/Build/Construction/ProjectImportElement.cs b/src/Build/Construction/ProjectImportElement.cs
index a38385ca9b8..89c9202364a 100644
--- a/src/Build/Construction/ProjectImportElement.cs
+++ b/src/Build/Construction/ProjectImportElement.cs
@@ -48,7 +48,7 @@ internal ProjectImportElement(XmlElementWithLocation xmlElement, ProjectRootElem
         }
 
         /// <summary>
-        /// Gets or sets the Project value. 
+        /// Gets or sets the Project value.
         /// </summary>
         public string Project
         {
diff --git a/src/Build/Construction/ProjectItemDefinitionElement.cs b/src/Build/Construction/ProjectItemDefinitionElement.cs
index 85edb365e8a..d659c62c186 100644
--- a/src/Build/Construction/ProjectItemDefinitionElement.cs
+++ b/src/Build/Construction/ProjectItemDefinitionElement.cs
@@ -99,7 +99,7 @@ internal static ProjectItemDefinitionElement CreateDisconnected(string itemType,
 
             // Orcas inadvertently did not check for reserved item types (like "Choose") in item definitions,
             // as we do for item types in item groups. So we do not have a check here.
-            // Although we could perhaps add one, as such item definitions couldn't be used 
+            // Although we could perhaps add one, as such item definitions couldn't be used
             // since no items can have the reserved itemType.
             XmlElementWithLocation element = containingProject.CreateElement(itemType);
 
diff --git a/src/Build/Construction/ProjectItemElement.cs b/src/Build/Construction/ProjectItemElement.cs
index fb98d908339..27856edbeaa 100644
--- a/src/Build/Construction/ProjectItemElement.cs
+++ b/src/Build/Construction/ProjectItemElement.cs
@@ -54,7 +54,7 @@ internal ProjectItemElement(ProjectItemElementLink link)
         private string _update;
 
         /// <summary>
-        /// Whether the include value has wildcards, 
+        /// Whether the include value has wildcards,
         /// cached for performance.
         /// </summary>
         private bool? _includeHasWildcards;
@@ -87,7 +87,7 @@ public string ItemType
         }
 
         /// <summary>
-        /// Gets or sets the Include value. 
+        /// Gets or sets the Include value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty or null.
         /// </summary>
@@ -109,7 +109,7 @@ public string Include
         }
 
         /// <summary>
-        /// Gets or sets the Exclude value. 
+        /// Gets or sets the Exclude value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty or null.
         /// </summary>
@@ -331,7 +331,7 @@ public string KeepDuplicates
         public ElementLocation KeepDuplicatesLocation => GetAttributeLocation(XMakeAttributes.keepDuplicates);
 
         /// <summary>
-        /// Whether the include value has wildcards, 
+        /// Whether the include value has wildcards,
         /// cached for performance.
         /// </summary>
         internal bool IncludeHasWildcards
diff --git a/src/Build/Construction/ProjectItemGroupElement.cs b/src/Build/Construction/ProjectItemGroupElement.cs
index 03dc40eb8eb..bf74c24a299 100644
--- a/src/Build/Construction/ProjectItemGroupElement.cs
+++ b/src/Build/Construction/ProjectItemGroupElement.cs
@@ -102,13 +102,13 @@ public ProjectItemElement AddItem(string itemType, string include, IEnumerable<K
             ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
             ErrorUtilities.VerifyThrowArgumentLength(include, nameof(include));
 
-            // If there are no items, or it turns out that there are only items with 
+            // If there are no items, or it turns out that there are only items with
             // item types that sort earlier, then we should go after the last child
             ProjectElement reference = LastChild;
 
             foreach (ProjectItemElement item in Items)
             {
-                // If it's the same item type, and 
+                // If it's the same item type, and
                 if (MSBuildNameIgnoreCaseComparer.Default.Equals(itemType, item.ItemType))
                 {
                     // the include sorts after us,
diff --git a/src/Build/Construction/ProjectMetadataElement.cs b/src/Build/Construction/ProjectMetadataElement.cs
index 473f39c0476..0d6b355e117 100644
--- a/src/Build/Construction/ProjectMetadataElement.cs
+++ b/src/Build/Construction/ProjectMetadataElement.cs
@@ -74,7 +74,7 @@ public string Name
         }
 
         /// <summary>
-        /// Gets or sets the unevaluated value. 
+        /// Gets or sets the unevaluated value.
         /// Returns empty string if it is not present.
         /// </summary>
         public string Value
diff --git a/src/Build/Construction/ProjectOtherwiseElement.cs b/src/Build/Construction/ProjectOtherwiseElement.cs
index 81adce4ec70..2a0ddfb4d0a 100644
--- a/src/Build/Construction/ProjectOtherwiseElement.cs
+++ b/src/Build/Construction/ProjectOtherwiseElement.cs
@@ -42,7 +42,7 @@ private ProjectOtherwiseElement(XmlElementWithLocation xmlElement, ProjectRootEl
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
diff --git a/src/Build/Construction/ProjectOutputElement.cs b/src/Build/Construction/ProjectOutputElement.cs
index 43814d3f9a0..71b9baa98e2 100644
--- a/src/Build/Construction/ProjectOutputElement.cs
+++ b/src/Build/Construction/ProjectOutputElement.cs
@@ -43,7 +43,7 @@ private ProjectOutputElement(XmlElement xmlElement, ProjectRootElement containin
         }
 
         /// <summary>
-        /// Gets or sets the TaskParameter value. 
+        /// Gets or sets the TaskParameter value.
         /// Returns empty string if it is not present.
         /// </summary>
         public string TaskParameter
@@ -73,7 +73,7 @@ public string TaskParameter
         public bool IsOutputProperty => PropertyName.Length > 0;
 
         /// <summary>
-        /// Gets or sets the ItemType value. 
+        /// Gets or sets the ItemType value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -96,7 +96,7 @@ public string ItemType
         }
 
         /// <summary>
-        /// Gets or sets the PropertyName value. 
+        /// Gets or sets the PropertyName value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
diff --git a/src/Build/Construction/ProjectPropertyElement.cs b/src/Build/Construction/ProjectPropertyElement.cs
index eca5645ab18..c9020db30ba 100644
--- a/src/Build/Construction/ProjectPropertyElement.cs
+++ b/src/Build/Construction/ProjectPropertyElement.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.Construction
     /// ProjectPropertyElement class represents the Property element in the MSBuild project.
     /// </summary>
     /// <remarks>
-    /// We do not need to use or set the PropertyType enumeration in the CM. 
+    /// We do not need to use or set the PropertyType enumeration in the CM.
     /// The CM does not know about Environment or Global properties, and does not create Output properties.
     /// We can just verify that we haven't read a PropertyType.Reserved property ourselves.
     /// So the CM only represents Normal properties.
@@ -59,7 +59,7 @@ public string Name
         }
 
         /// <summary>
-        /// Gets or sets the unevaluated value. 
+        /// Gets or sets the unevaluated value.
         /// Returns empty string if it is not present.
         /// </summary>
         public string Value
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 1db13d96a4c..86c6a442d44 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -38,7 +38,7 @@ namespace Microsoft.Build.Construction
     /// project file schema.
     /// This class and its related classes allow a complete MSBuild project or targets file to be read and written.
     /// Comments and whitespace cannot be edited through this model at present.
-    /// 
+    ///
     /// Each project root element is associated with exactly one ProjectCollection. This allows the owner of that project collection
     /// to control its lifetime and not be surprised by edits via another project collection.
     /// </summary>
@@ -113,9 +113,9 @@ public class ProjectRootElement : ProjectElementContainer
         private string _escapedFullPath;
 
         /// <summary>
-        /// The directory that the project is in. 
+        /// The directory that the project is in.
         /// Essential for evaluating relative paths.
-        /// If the project is not loaded from disk, returns the current-directory from 
+        /// If the project is not loaded from disk, returns the current-directory from
         /// the time the project was loaded - this is the same behavior as Whidbey/Orcas.
         /// </summary>
         private string _directory;
@@ -271,7 +271,7 @@ private ProjectRootElement(XmlDocumentWithLocation document)
         internal event EventHandler<ProjectXmlChangedEventArgs> OnProjectXmlChanged;
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
@@ -366,10 +366,10 @@ public override string Condition
         #endregion
 
         /// <summary>
-        /// The directory that the project is in. 
+        /// The directory that the project is in.
         /// Essential for evaluating relative paths.
         /// Is never null, even if the FullPath does not contain directory information.
-        /// If the project has not been loaded from disk and has not been given a path, returns the current-directory from 
+        /// If the project has not been loaded from disk and has not been given a path, returns the current-directory from
         /// the time the project was loaded - this is the same behavior as Whidbey/Orcas.
         /// If the project has not been loaded from disk but has been given a path, this path may not exist.
         /// </summary>
@@ -582,20 +582,20 @@ public string RawXml
         /// Version number of this object.
         /// A host can compare this to a stored version number to determine whether
         /// a project's XML has changed, even if it has also been saved since.
-        /// 
+        ///
         /// The actual value is meaningless: an edit may increment it more than once,
         /// so it should only be compared to a stored value.
         /// </summary>
         /// <remarks>
-        /// Used by the Project class to figure whether changes have occurred that 
+        /// Used by the Project class to figure whether changes have occurred that
         /// it might want to pick up by reevaluation.
-        /// 
+        ///
         /// Used by the ProjectRootElement class to determine whether it needs to save.
-        /// 
+        ///
         /// This number is unique to the appdomain. That means that it is possible
         /// to know when a ProjectRootElement has been unloaded (perhaps after modification) and
         /// reloaded -- the version won't reset to '0'.
-        /// 
+        ///
         /// We're assuming we don't have over 2 billion edits.
         /// </remarks>
         public int Version
@@ -687,11 +687,11 @@ public override ElementLocation ConditionLocation
         internal bool IsMemberOfProjectCollection => _projectFileLocation != null;
 
         /// <summary>
-        /// Indicates whether there are any targets in this project 
+        /// Indicates whether there are any targets in this project
         /// that use the "Returns" attribute.  If so, then this project file
         /// is automatically assumed to be "Returns-enabled", and the default behavior
-        /// for targets without Returns attributes changes from using the Outputs to 
-        /// returning nothing by default. 
+        /// for targets without Returns attributes changes from using the Outputs to
+        /// returning nothing by default.
         /// </summary>
         internal bool ContainsTargetsWithReturnsAttribute { get; set; }
 
@@ -1305,7 +1305,7 @@ public ProjectItemGroupElement CreateItemGroupElement()
         }
 
         /// <summary>
-        /// Creates an import group. 
+        /// Creates an import group.
         /// Caller must add it to the location of choice in the project.
         /// </summary>
         public ProjectImportGroupElement CreateImportGroupElement()
@@ -1436,7 +1436,7 @@ public ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string as
         /// Creates a using task.
         /// Caller must add it to the location of choice in the project.
         /// Exactly one of assembly file and assembly name must be provided.
-        /// Also allows providing optional runtime and architecture specifiers.  Null is OK. 
+        /// Also allows providing optional runtime and architecture specifiers.  Null is OK.
         /// </summary>
         public ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture)
         {
@@ -1537,8 +1537,8 @@ public void Save(Encoding saveEncoding)
                 FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(_projectFileLocation.File);
 
                 // If the file was deleted by a race with someone else immediately after it was written above
-                // then we obviously can't read the write time. In this obscure case, we'll retain the 
-                // older last write time, which at worst would cause the next load to unnecessarily 
+                // then we obviously can't read the write time. In this obscure case, we'll retain the
+                // older last write time, which at worst would cause the next load to unnecessarily
                 // come from disk.
                 if (fileInfo != null)
                 {
@@ -1616,7 +1616,7 @@ public ProjectRootElement DeepClone()
         /// <summary>
         /// Reload the existing project root element from its file.
         /// An <see cref="InvalidOperationException"/> is thrown if the project root element is not associated with any file on disk.
-        /// 
+        ///
         /// See <see cref="ProjectRootElement.ReloadFrom(XmlReader, bool, bool?)"/>
         /// </summary>
         public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = null)
@@ -1629,7 +1629,7 @@ public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting =
         /// <summary>
         /// Reload the existing project root element from the given path
         /// An <see cref="InvalidOperationException"/> is thrown if the path does not exist.
-        /// 
+        ///
         /// See <see cref="ProjectRootElement.ReloadFrom(XmlReader, bool, bool?)"/>
         /// </summary>
         public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null)
@@ -1648,14 +1648,14 @@ public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? pre
 
         /// <summary>
         /// Reload the existing project root element from the given <paramref name="reader"/>
-        /// A reload operation completely replaces the state of this <see cref="ProjectRootElement"/> object. This operation marks the 
-        /// object as dirty (see <see cref="ProjectRootElement.MarkDirty"/> for side effects). 
-        /// 
+        /// A reload operation completely replaces the state of this <see cref="ProjectRootElement"/> object. This operation marks the
+        /// object as dirty (see <see cref="ProjectRootElement.MarkDirty"/> for side effects).
+        ///
         /// If the new state has invalid XML or MSBuild syntax, then this method throws an <see cref="InvalidProjectFileException"/>.
         /// When this happens, the state of this object does not change.
-        /// 
+        ///
         /// Reloading from an XMLReader will retain the previous root element location (<see cref="FullPath"/>, <see cref="DirectoryPath"/>, <see cref="ProjectFileLocation"/>).
-        /// 
+        ///
         /// </summary>
         /// <param name="reader">Reader to read from</param>
         /// <param name="throwIfUnsavedChanges">
diff --git a/src/Build/Construction/ProjectTargetElement.cs b/src/Build/Construction/ProjectTargetElement.cs
index e9893009031..f594efaf072 100644
--- a/src/Build/Construction/ProjectTargetElement.cs
+++ b/src/Build/Construction/ProjectTargetElement.cs
@@ -171,7 +171,7 @@ public string KeepDuplicateOutputs
                 if (String.IsNullOrEmpty(value) && !BuildParameters.KeepDuplicateOutputs)
                 {
                     // In 4.0, by default we do NOT keep duplicate outputs unless they user has either set the attribute
-                    // explicitly or overridden it globally with MSBUILDKEEPDUPLICATEOUTPUTS set to a non-empty value.                    
+                    // explicitly or overridden it globally with MSBUILDKEEPDUPLICATEOUTPUTS set to a non-empty value.
                     value = "False";
                 }
 
@@ -273,11 +273,11 @@ public string Returns
                         value,
                         true); /* only remove the element if the value is null -- setting to empty string is OK */
 
-                // if this target's Returns attribute is non-null, then there is at least one target in the 
-                // parent project that has the returns attribute.  
-                // NOTE: As things are currently, if a project is created that has targets with Returns, but then 
-                // all of those targets are set to not have Returns anymore, the PRE will still claim that it 
-                // contains targets with the Returns attribute.  Do we care? 
+                // if this target's Returns attribute is non-null, then there is at least one target in the
+                // parent project that has the returns attribute.
+                // NOTE: As things are currently, if a project is created that has targets with Returns, but then
+                // all of those targets are set to not have Returns anymore, the PRE will still claim that it
+                // contains targets with the Returns attribute.  Do we care?
                 if (returnsAttribute != null)
                 {
                     ((ProjectRootElement)Parent).ContainsTargetsWithReturnsAttribute = true;
@@ -313,7 +313,7 @@ public ElementLocation KeepDuplicateOutputsLocation
                 if ((location == null) && !BuildParameters.KeepDuplicateOutputs)
                 {
                     // In 4.0, by default we do NOT keep duplicate outputs unless they user has either set the attribute
-                    // explicitly or overridden it globally with MSBUILDKEEPDUPLICATEOUTPUTS set to a non-empty value.                    
+                    // explicitly or overridden it globally with MSBUILDKEEPDUPLICATEOUTPUTS set to a non-empty value.
                     location = NameLocation;
                 }
 
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index 94031b4994c..984ffe33b31 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -449,7 +449,7 @@ private void EnsureParametersInitialized()
                     {
                         // By pulling off and caching the Location early here, it becomes frozen for the life of this object.
                         // That means that if the name of the file is changed after first load (possibly from null) it will
-                        // remain the old value here. Correctly, this should cache the attribute not the location. Fixing 
+                        // remain the old value here. Correctly, this should cache the attribute not the location. Fixing
                         // that will need profiling, though, as this cache was added for performance.
                         _parameters[attribute.Name] = (attribute.Value, attribute.Location);
                     }
diff --git a/src/Build/Construction/ProjectUsingTaskBodyElement.cs b/src/Build/Construction/ProjectUsingTaskBodyElement.cs
index 9ef2a82faf0..ad1f97ce4a7 100644
--- a/src/Build/Construction/ProjectUsingTaskBodyElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskBodyElement.cs
@@ -46,7 +46,7 @@ private ProjectUsingTaskBodyElement(XmlElementWithLocation xmlElement, ProjectRo
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
@@ -56,7 +56,7 @@ public override string Condition
         }
 
         /// <summary>
-        /// Gets or sets the unevaluated value of the contents of the task xml 
+        /// Gets or sets the unevaluated value of the contents of the task xml
         /// Returns empty string if it is not present.
         /// </summary>
         public string TaskBody
@@ -159,7 +159,7 @@ private static void VerifyCorrectParent(ProjectElementContainer parent)
             var parentUsingTask = parent as ProjectUsingTaskElement;
             ErrorUtilities.VerifyThrowInvalidOperation(parentUsingTask != null, "OM_CannotAcceptParent");
 
-            // Since there is not going to be a TaskElement on the using task we need to validate and make sure there is a TaskFactory attribute on the parent element and 
+            // Since there is not going to be a TaskElement on the using task we need to validate and make sure there is a TaskFactory attribute on the parent element and
             // that it is not empty
             if (parentUsingTask.TaskFactory.Length == 0)
             {
diff --git a/src/Build/Construction/ProjectUsingTaskParameterElement.cs b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
index e7da47595bc..636fb171028 100644
--- a/src/Build/Construction/ProjectUsingTaskParameterElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
@@ -43,7 +43,7 @@ private ProjectUsingTaskParameterElement(XmlElementWithLocation xmlElement, Proj
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
diff --git a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
index 4056ee44afd..073739d11a6 100644
--- a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
@@ -47,7 +47,7 @@ internal ProjectConfigurationInSolution(string configurationName, string platfor
         /// This is a hacky method to remove the space in the "Any CPU" platform in project configurations.
         /// The problem is that this platform is stored as "AnyCPU" in project files, but the project system
         /// reports it as "Any CPU" to the solution configuration manager. Because of that all solution configurations
-        /// contain the version with a space in it, and when we try and give that name to actual projects, 
+        /// contain the version with a space in it, and when we try and give that name to actual projects,
         /// they have no clue what we're talking about. We need to remove the space in project platforms so that
         /// the platform name matches the one used in projects.
         /// </summary>
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index b13b09f50a1..3880a57f618 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -107,7 +107,7 @@ public sealed class ProjectInSolution
         /// <summary>
         /// The project configuration in given solution configuration
         /// K: full solution configuration name (cfg + platform)
-        /// V: project configuration 
+        /// V: project configuration
         /// </summary>
         private readonly Dictionary<string, ProjectConfigurationInSolution> _projectConfigurations;
         private IReadOnlyDictionary<string, ProjectConfigurationInSolution> _projectConfigurationsReadOnly;
@@ -208,14 +208,14 @@ public string AbsolutePath
         public string ProjectGuid { get; internal set; }
 
         /// <summary>
-        /// The guid, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, of this project's 
-        /// parent project, if any. 
+        /// The guid, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, of this project's
+        /// parent project, if any.
         /// </summary>
         public string ParentProjectGuid { get; internal set; }
 
         /// <summary>
-        /// List of guids, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, mapping to projects 
-        /// that this project has a build order dependency on, as defined in the solution file. 
+        /// List of guids, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, mapping to projects
+        /// that this project has a build order dependency on, as defined in the solution file.
         /// </summary>
         public IReadOnlyList<string> Dependencies => _dependenciesAsReadonly ?? (_dependenciesAsReadonly = _dependencies.AsReadOnly());
 
@@ -239,9 +239,9 @@ public IReadOnlyDictionary<string, ProjectConfigurationInSolution> ProjectConfig
         public SolutionProjectType ProjectType { get; set; }
 
         /// <summary>
-        /// Only applies to websites -- for other project types, references are 
+        /// Only applies to websites -- for other project types, references are
         /// either specified as Dependencies above, or as ProjectReferences in the
-        /// project file, which the solution doesn't have insight into. 
+        /// project file, which the solution doesn't have insight into.
         /// </summary>
         internal List<string> ProjectReferences { get; } = new List<string>();
 
@@ -270,7 +270,7 @@ internal void AddDependency(string referencedProjectGuid)
         }
 
         /// <summary>
-        /// Set the requested project configuration. 
+        /// Set the requested project configuration.
         /// </summary>
         internal void SetProjectConfiguration(string configurationName, ProjectConfigurationInSolution configuration)
         {
@@ -305,7 +305,7 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
                 FileStream fs = File.OpenRead(AbsolutePath);
                 using (XmlReader xmlReader = XmlReader.Create(fs, xrSettings))
                 {
-                    // Load the project file and get the first node    
+                    // Load the project file and get the first node
                     projectDocument.Load(xmlReader);
                 }
 
@@ -502,7 +502,7 @@ private static string CleanseProjectName(string projectName)
             // This is where we're going to work on the final string to return to the caller.
             var cleanProjectName = new StringBuilder(projectName);
 
-            // Replace each unclean character with a clean one            
+            // Replace each unclean character with a clean one
             foreach (char uncleanChar in s_charsToCleanse)
             {
                 cleanProjectName.Replace(uncleanChar, cleanCharacter);
diff --git a/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs b/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
index 57d868d3a03..ca74704b73e 100644
--- a/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
@@ -44,7 +44,7 @@ internal SolutionConfigurationInSolution(string configurationName, string platfo
         public string FullName { get; }
 
         /// <summary>
-        /// Given a configuration name and a platform name, compute the full name 
+        /// Given a configuration name and a platform name, compute the full name
         /// of this configuration
         /// </summary>
         internal static string ComputeFullName(string configurationName, string platformName)
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index a59fdb60e4d..7c8a7dcc867 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -51,7 +51,7 @@ public sealed class SolutionFile
         // An example of a property line looks like this:
         //      AspNetCompiler.VirtualPath = "/webprecompile"
         // Because website projects now include the target framework moniker as
-        // one of their properties, <PROPERTYVALUE> may now have '=' in it. 
+        // one of their properties, <PROPERTYVALUE> may now have '=' in it.
 
         private static readonly Lazy<Regex> s_crackPropertyLine = new Lazy<Regex>(
             () => new Regex(
@@ -142,7 +142,7 @@ internal SolutionFile()
         internal List<string> SolutionParserComments { get; } = new List<string>();
 
         /// <summary>
-        /// This property returns the list of error codes for warnings/errors that were generated during solution parsing. 
+        /// This property returns the list of error codes for warnings/errors that were generated during solution parsing.
         /// </summary>
         internal List<string> SolutionParserErrorCodes { get; } = new List<string>();
 
@@ -176,7 +176,7 @@ internal int VisualStudioVersion
 
         /// <summary>
         /// Returns true if the solution contains any .wdproj projects.  Used to determine
-        /// whether we need to load up any projects to examine dependencies. 
+        /// whether we need to load up any projects to examine dependencies.
         /// </summary>
         internal bool ContainsWebDeploymentProjects { get; private set; }
 
@@ -186,7 +186,7 @@ internal int VisualStudioVersion
         public IReadOnlyList<ProjectInSolution> ProjectsInOrder => _projectsInOrder.AsReadOnly();
 
         /// <summary>
-        /// The collection of projects in this solution, accessible by their guids as a 
+        /// The collection of projects in this solution, accessible by their guids as a
         /// string in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form
         /// </summary>
         public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_projects);
@@ -263,8 +263,8 @@ public static SolutionFile Parse(string solutionFile)
         }
 
         /// <summary>
-        /// Returns "true" if it's a project that's expected to be buildable, or false if it's 
-        /// not (e.g. a solution folder) 
+        /// Returns "true" if it's a project that's expected to be buildable, or false if it's
+        /// not (e.g. a solution folder)
         /// </summary>
         /// <param name="project">The project in the solution</param>
         /// <returns>Whether the project is expected to be buildable</returns>
@@ -275,9 +275,9 @@ internal static bool IsBuildableProject(ProjectInSolution project)
 
         /// <summary>
         /// Given a solution file, parses the header and returns the major version numbers of the solution file
-        /// and the visual studio. 
-        /// Throws InvalidProjectFileException if the solution header is invalid, or if the version is less than 
-        /// our minimum version. 
+        /// and the visual studio.
+        /// Throws InvalidProjectFileException if the solution header is invalid, or if the version is less than
+        /// our minimum version.
         /// </summary>
         internal static void GetSolutionFileAndVisualStudioMajorVersions(string solutionFile, out int solutionVersion, out int visualStudioMajorVersion)
         {
@@ -299,7 +299,7 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
                 fileStream = File.OpenRead(solutionFile);
                 reader = new StreamReader(fileStream, Encoding.GetEncoding(0)); // HIGHCHAR: If solution files have no byte-order marks, then assume ANSI rather than ASCII.
 
-                // Read first 4 lines of the solution file. 
+                // Read first 4 lines of the solution file.
                 // The header is expected to be in line 1 or 2
                 // VisualStudioVersion is expected to be in line 3 or 4.
                 for (int i = 0; i < 4; i++)
@@ -452,7 +452,7 @@ private string ReadLine()
         /// <summary>
         /// This method takes a path to a solution file, parses the projects and project dependencies
         /// in the solution file, and creates internal data structures representing the projects within
-        /// the SLN.  Used for conversion, which means it allows situations that we refuse to actually build. 
+        /// the SLN.  Used for conversion, which means it allows situations that we refuse to actually build.
         /// </summary>
         internal void ParseSolutionFileForConversion()
         {
@@ -630,7 +630,7 @@ internal void ParseSolution()
 
                 bool uniqueNameExists = projectsByUniqueName.ContainsKey(uniqueName);
 
-                // Add the unique name (if it does not exist) to the hash table 
+                // Add the unique name (if it does not exist) to the hash table
                 if (!uniqueNameExists)
                 {
                     projectsByUniqueName.Add(uniqueName, proj);
@@ -650,11 +650,11 @@ internal void ParseSolution()
         /// <summary>
         /// This method searches the first two lines of the solution file opened by the specified
         /// StreamReader for the solution file header.  An exception is thrown if it is not found.
-        /// 
+        ///
         /// The solution file header looks like this:
-        /// 
+        ///
         ///     Microsoft Visual Studio Solution File, Format Version 9.00
-        /// 
+        ///
         /// </summary>
         private void ParseFileHeader()
         {
@@ -688,9 +688,9 @@ private void ParseFileHeader()
         /// <summary>
         /// This method parses the Visual Studio version in Dev 12 solution files
         /// The version line looks like this:
-        /// 
+        ///
         /// VisualStudioVersion = 12.0.20311.0 VSPRO_PLATFORM
-        /// 
+        ///
         /// If such a line is found, the version is stored in this.currentVisualStudioVersion
         /// </summary>
         private static Version ParseVisualStudioVersion(string str)
@@ -714,11 +714,11 @@ private static Version ParseVisualStudioVersion(string str)
         /// This method extracts the whole part of the version number from the specified line
         /// containing the solution file format header, and throws an exception if the version number
         /// is outside of the valid range.
-        /// 
+        ///
         /// The solution file header looks like this:
-        /// 
+        ///
         ///     Microsoft Visual Studio Solution File, Format Version 9.00
-        /// 
+        ///
         /// </summary>
         /// <param name="versionString"></param>
         private void ValidateSolutionFileVersion(string versionString)
@@ -750,7 +750,7 @@ private void ValidateSolutionFileVersion(string versionString)
         }
 
         /// <summary>
-        /// 
+        ///
         /// This method processes a "Project" section in the solution file opened by the specified
         /// StreamReader, and returns a populated ProjectInSolution instance, if successful.
         /// An exception is thrown if the solution file is invalid.
@@ -763,7 +763,7 @@ private void ValidateSolutionFileVersion(string versionString)
         ///          ...
         ///      EndProjectSection
         ///  EndProject
-        /// 
+        ///
         /// </summary>
         private void ParseProject(string firstLine)
         {
@@ -808,7 +808,7 @@ private void ParseProject(string firstLine)
                 else if (line.StartsWith("ProjectSection(WebsiteProperties)", StringComparison.Ordinal))
                 {
                     // We have a WebsiteProperties section.  This section is present only in Venus
-                    // projects, and contains properties that we'll need in order to call the 
+                    // projects, and contains properties that we'll need in order to call the
                     // AspNetCompiler task.
                     line = ReadLine();
                     while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
@@ -845,7 +845,7 @@ private void ParseProject(string firstLine)
 
             // Add the project to the collection
             AddProjectToSolution(proj);
-            // If the project is an etp project then parse the etp project file 
+            // If the project is an etp project then parse the etp project file
             // to get the projects contained in it.
             if (IsEtpProjectFile(proj.RelativePath))
             {
@@ -854,7 +854,7 @@ private void ParseProject(string firstLine)
         } // ParseProject()
 
         /// <summary>
-        /// This method will parse a .etp project recursively and 
+        /// This method will parse a .etp project recursively and
         /// add all the projects found to projects and projectsInOrder
         /// </summary>
         /// <param name="etpProj">ETP Project</param>
@@ -899,8 +899,8 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
 
                 // We need to parse the .etp project file to get the names of projects contained
                 // in the .etp Project. The projects are listed under /EFPROJECT/GENERAL/References/Reference node in the .etp project file.
-                // The /EFPROJECT/GENERAL/Views/ProjectExplorer node will not necessarily contain 
-                // all the projects in the .etp project. Therefore, we need to look at 
+                // The /EFPROJECT/GENERAL/Views/ProjectExplorer node will not necessarily contain
+                // all the projects in the .etp project. Therefore, we need to look at
                 // /EFPROJECT/GENERAL/References/Reference.
                 // Find the /EFPROJECT/GENERAL/References/Reference node
                 // Note that this is case sensitive
@@ -926,10 +926,10 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
                         XmlNode projGuidNode = referenceNode.SelectSingleNode("GUIDPROJECTID");
 
                         // It is ok for a project to not have a guid inside an etp project.
-                        // If a solution file contains a project without a guid it fails to 
-                        // load in Everett. But if an etp project contains a project without 
+                        // If a solution file contains a project without a guid it fails to
+                        // load in Everett. But if an etp project contains a project without
                         // a guid it loads well in Everett and p2p references to/from this project
-                        // are preserved. So we should make sure that we dont error in this 
+                        // are preserved. So we should make sure that we dont error in this
                         // situation while upgrading.
                         proj.ProjectGuid = projGuidNode?.InnerText ?? String.Empty;
 
@@ -948,7 +948,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle security errors
             catch (SecurityException e)
             {
-                // Log a warning 
+                // Log a warning
                 string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
                 SolutionParserWarnings.Add(warning);
@@ -957,7 +957,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in path resolution
             catch (NotSupportedException e)
             {
-                // Log a warning 
+                // Log a warning
                 string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
                 SolutionParserWarnings.Add(warning);
@@ -966,7 +966,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in loading project file
             catch (IOException e)
             {
-                // Log a warning 
+                // Log a warning
                 string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
                 SolutionParserWarnings.Add(warning);
@@ -975,16 +975,16 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in loading project file
             catch (UnauthorizedAccessException e)
             {
-                // Log a warning 
+                // Log a warning
                 string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
                 SolutionParserWarnings.Add(warning);
                 SolutionParserErrorCodes.Add(errorCode);
             }
-            // handle XML parsing errors 
+            // handle XML parsing errors
             catch (XmlException e)
             {
-                // Log a warning 
+                // Log a warning
                 string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "Shared.InvalidProjectFile",
                    etpProj.RelativePath, e.Message);
                 SolutionParserWarnings.Add(warning);
@@ -1052,7 +1052,7 @@ private static void ParseAspNetCompilerProperty(
             // Project("{E24C65DC-7377-472B-9ABA-BC803B73C61A}") = "c:\...\myfirstwebsite\", "..\..\..\..\..\..\rajeev\temp\websites\myfirstwebsite", "{956CC04E-FD59-49A9-9099-96888CB6F366}"
             //     ProjectSection(WebsiteProperties) = preProject
             //       TargetFrameworkMoniker = ".NETFramework,Version%3Dv4.0"
-            //       ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
+            //       ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
             //       Debug.AspNetCompiler.VirtualPath = "/publishfirst"
             //       Debug.AspNetCompiler.PhysicalPath = "..\..\..\..\..\..\rajeev\temp\websites\myfirstwebsite\"
             //       Debug.AspNetCompiler.TargetPath = "..\..\..\..\..\..\rajeev\temp\publishfirst\"
@@ -1176,7 +1176,7 @@ private static void ParseAspNetCompilerProperty(
             }
             else
             {
-                // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
+                // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
                 if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
                     string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
@@ -1185,7 +1185,7 @@ private static void ParseAspNetCompilerProperty(
                     {
                         int indexOfBar = projectReferenceEntry.IndexOf('|');
 
-                        // indexOfBar could be -1 if we had semicolons in the file names, so skip entries that 
+                        // indexOfBar could be -1 if we had semicolons in the file names, so skip entries that
                         // don't contain a guid. File names may not contain the '|' character
                         if (indexOfBar != -1)
                         {
@@ -1208,7 +1208,7 @@ private static void ParseAspNetCompilerProperty(
                 else if (String.Equals(propertyName, "TargetFrameworkMoniker", StringComparison.OrdinalIgnoreCase))
                 {
                     // Website project need to back support 3.5 msbuild parser for the Blend (it is not move to .Net4.0 yet.)
-                    // However, 3.5 version of Solution parser can't handle a equal sign in the value.  
+                    // However, 3.5 version of Solution parser can't handle a equal sign in the value.
                     // The "=" in targetframeworkMoniker was escaped to "%3D" for Orcas
                     string targetFrameworkMoniker = TrimQuotes(propertyValue);
                     proj.TargetFrameworkMoniker = Shared.EscapingUtilities.UnescapeAll(targetFrameworkMoniker);
@@ -1237,7 +1237,7 @@ private static string TrimQuotes(
         /// Parse the first line of a Project section of a solution file. This line should look like:
         ///
         ///  Project("{Project type GUID}") = "Project name", "Relative path to project file", "{Project GUID}"
-        /// 
+        ///
         /// </summary>
         /// <param name="firstLine"></param>
         /// <param name="proj"></param>
@@ -1254,8 +1254,8 @@ internal void ParseFirstProjectLine(
             proj.RelativePath = match.Groups["RELATIVEPATH"].Value.Trim();
             proj.ProjectGuid = match.Groups["PROJECTGUID"].Value.Trim();
 
-            // If the project name is empty (as in some bad solutions) set it to some generated generic value.  
-            // This allows us to at least generate reasonable target names etc. instead of crashing. 
+            // If the project name is empty (as in some bad solutions) set it to some generated generic value.
+            // This allows us to at least generate reasonable target names etc. instead of crashing.
             if (String.IsNullOrEmpty(proj.ProjectName))
             {
                 proj.ProjectName = "EmptyProjectName." + Guid.NewGuid();
@@ -1296,7 +1296,7 @@ internal void ParseFirstProjectLine(
                     {
                         ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(FullPath), "ProjectUpgradeNeededToVcxProj", proj.RelativePath);
                     }
-                    // otherwise, we're parsing this solution file because we want the P2P information during 
+                    // otherwise, we're parsing this solution file because we want the P2P information during
                     // conversion, and it's perfectly valid for an unconverted solution file to still contain .vcprojs
                 }
                 else
@@ -1358,11 +1358,11 @@ internal void ParseNestedProjects()
         }
 
         /// <summary>
-        /// Read solution configuration section. 
+        /// Read solution configuration section.
         /// </summary>
         /// <remarks>
         /// A sample section:
-        /// 
+        ///
         /// GlobalSection(SolutionConfigurationPlatforms) = preSolution
         ///     Debug|Any CPU = Debug|Any CPU
         ///     Release|Any CPU = Release|Any CPU
@@ -1389,7 +1389,7 @@ internal void ParseSolutionConfigurations()
 
                 string[] configurationNames = str.Split(nameValueSeparators);
 
-                // There should be exactly one '=' character, separating two names. 
+                // There should be exactly one '=' character, separating two names.
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(configurationNames.Length == 2, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseInvalidSolutionConfigurationEntry", str);
 
@@ -1430,7 +1430,7 @@ internal static (string Configuration, string Platform) ParseConfigurationName(s
         /// </summary>
         /// <remarks>
         /// A sample (incomplete) section:
-        /// 
+        ///
         /// GlobalSection(ProjectConfigurationPlatforms) = postSolution
         /// 	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
         /// 	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
@@ -1466,7 +1466,7 @@ internal Dictionary<string, string> ParseProjectConfigurations()
 
                 string[] nameValue = str.Split('=');
 
-                // There should be exactly one '=' character, separating the name and value. 
+                // There should be exactly one '=' character, separating the name and value.
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(nameValue.Length == 2, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseInvalidProjectSolutionConfigurationEntry", str);
 
@@ -1477,17 +1477,17 @@ internal Dictionary<string, string> ParseProjectConfigurations()
         }
 
         /// <summary>
-        /// Read the project configuration information for every project in the solution, using pre-cached 
-        /// solution section data. 
+        /// Read the project configuration information for every project in the solution, using pre-cached
+        /// solution section data.
         /// </summary>
         /// <param name="rawProjectConfigurationsEntries">Cached data from the project configuration section</param>
         internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawProjectConfigurationsEntries)
         {
-            // Instead of parsing the data line by line, we parse it project by project, constructing the 
-            // entry name (e.g. "{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg") and retrieving its 
+            // Instead of parsing the data line by line, we parse it project by project, constructing the
+            // entry name (e.g. "{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg") and retrieving its
             // value from the raw data. The reason for this is that the IDE does it this way, and as the result
             // the '.' character is allowed in configuration names although it technically separates different
-            // parts of the entry name string. This could lead to ambiguous results if we tried to parse 
+            // parts of the entry name string. This could lead to ambiguous results if we tried to parse
             // the entry name instead of constructing it and looking it up. Although it's pretty unlikely that
             // this would ever be a problem, it's safer to do it the same way VS IDE does it.
             foreach (ProjectInSolution project in _projectsInOrder)
@@ -1503,9 +1503,9 @@ internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawP
                             project.ProjectGuid, solutionConfiguration.FullName);
 
                         // The "Build.0" entry tells us whether to build the project configuration in the given solution configuration.
-                        // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial, 
-                        // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used). 
-                        // The configuration name is not used, and the whole entry means "build the project configuration" 
+                        // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial,
+                        // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used).
+                        // The configuration name is not used, and the whole entry means "build the project configuration"
                         // if it's present in the solution file, and "don't build" if it's not.
                         string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0",
                             project.ProjectGuid, solutionConfiguration.FullName);
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 7b3d3c05b43..62d0b7e78a2 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -287,9 +287,9 @@ internal static string GetSolutionConfiguration(SolutionFile solutionFile, Solut
                                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(dependencyProject != null, "SubCategoryForSolutionParsingErrors", new BuildEventFileInfo(solutionFile.FullPath), "SolutionParseProjectDepNotFoundError", project.ProjectGuid, dependencyProjectGuid);
                             }
 
-                            // Add it to the list of dependencies, but only if it should build in this solution configuration 
+                            // Add it to the list of dependencies, but only if it should build in this solution configuration
                             // (If a project is not selected for build in the solution configuration, it won't build even if it's depended on by something that IS selected for build)
-                            // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise 
+                            // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise
                             if (dependencyProject.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat)
                             {
                                 if (dependencyProject.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out ProjectConfigurationInSolution dependencyProjectConfiguration) &&
@@ -420,10 +420,10 @@ private static void AddTasksToCopyAllDependenciesIntoBinDir(
             string fullFrameworkRefAssyPathName = GenerateSafePropertyName(project, "_FullFrameworkReferenceAssemblyPaths");
             string destinationFolder = String.Format(CultureInfo.InvariantCulture, @"$({0})\Bin\", GenerateSafePropertyName(project, "AspNetPhysicalPath"));
 
-            // This is a bit of a hack.  We're actually calling the "Copy" task on all of 
-            // the *non-existent* files.  Why?  Because we want to emit a warning in the 
+            // This is a bit of a hack.  We're actually calling the "Copy" task on all of
+            // the *non-existent* files.  Why?  Because we want to emit a warning in the
             // log for each non-existent file, and the Copy task does that nicely for us.
-            // I would have used the <Warning> task except for the fact that we are in 
+            // I would have used the <Warning> task except for the fact that we are in
             // string-resource lockdown.
             ProjectTaskInstance copyNonExistentReferencesTask = target.AddTask("Copy", String.Format(CultureInfo.InvariantCulture, "!Exists('%({0}.Identity)')", referenceItemName), "true");
             copyNonExistentReferencesTask.SetParameter("SourceFiles", "@(" + referenceItemName + "->'%(FullPath)')");
@@ -437,7 +437,7 @@ private static void AddTasksToCopyAllDependenciesIntoBinDir(
             getRefAssembliesTask.AddOutputProperty("ReferenceAssemblyPaths", targetFrameworkDirectoriesName, null);
             getRefAssembliesTask.AddOutputProperty("FullFrameworkReferenceAssemblyPaths", fullFrameworkRefAssyPathName, null);
 
-            // Call ResolveAssemblyReference on each of the .DLL files that were found on 
+            // Call ResolveAssemblyReference on each of the .DLL files that were found on
             // disk from the .REFRESH files as well as the P2P references.  RAR will crack
             // the dependencies, find PDBs, satellite assemblies, etc., and determine which
             // files need to be copy-localed.
@@ -698,11 +698,11 @@ private ProjectInstance[] Generate()
                 new BuildEventFileInfo(_solutionFile.FullPath),
                 "SolutionParseUpgradeNeeded");
 
-            // This is needed in order to make decisions about tools versions such as whether to put a 
-            // ToolsVersion parameter on <MSBuild> task tags and what MSBuildToolsPath to use when 
+            // This is needed in order to make decisions about tools versions such as whether to put a
+            // ToolsVersion parameter on <MSBuild> task tags and what MSBuildToolsPath to use when
             // scanning child projects for dependency information.
-            // The knowledge of whether it was explicitly specified is required because otherwise we 
-            // don't know whether we need to pass the ToolsVersion on to the child projects or not.  
+            // The knowledge of whether it was explicitly specified is required because otherwise we
+            // don't know whether we need to pass the ToolsVersion on to the child projects or not.
             string wrapperProjectToolsVersion = DetermineWrapperProjectToolsVersion(_toolsVersionOverride, out bool explicitToolsVersionSpecified);
 
             return CreateSolutionProject(wrapperProjectToolsVersion, explicitToolsVersionSpecified);
@@ -719,9 +719,9 @@ private ProjectInstance[] CreateSolutionProject(string wrapperProjectToolsVersio
             if (_solutionFile.ContainsWebDeploymentProjects)
             {
                 // If there are Web Deployment projects, we need to scan those project files
-                // and specify the references explicitly.  
-                // Other references are either ProjectReferences (taken care of by MSBuild) or 
-                // explicit manual references in the solution file -- which get parsed out by 
+                // and specify the references explicitly.
+                // Other references are either ProjectReferences (taken care of by MSBuild) or
+                // explicit manual references in the solution file -- which get parsed out by
                 // the SolutionParser.
                 string childProjectToolsVersion = DetermineChildProjectToolsVersion(wrapperProjectToolsVersion);
                 string fullSolutionConfigurationName = PredictActiveSolutionConfigurationName();
@@ -797,7 +797,7 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
 
                 bool canBuildDirectly = CanBuildDirectly(traversalInstance, project, projectConfiguration);
 
-                // Add an entry to @(ProjectReference) for the project.  This will be either a reference directly to the project, or to the 
+                // Add an entry to @(ProjectReference) for the project.  This will be either a reference directly to the project, or to the
                 // metaproject, as appropriate.
                 AddProjectReference(traversalInstance, traversalInstance, project, projectConfiguration, canBuildDirectly);
 
@@ -875,8 +875,8 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             }
 
             // Add our global extensibility points to the project representing the solution:
-            // Imported at the top:  $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportBefore\* 
-            // Imported at the bottom:  $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportAfter\*             
+            // Imported at the top:  $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportBefore\*
+            // Imported at the bottom:  $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportAfter\*
             ProjectImportElement importBefore = traversalProject.CreateImportElement(@"$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportBefore\*");
             importBefore.Condition = @"'$(ImportByWildcardBeforeSolution)' != 'false' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportBefore')"; // Avoids wildcard perf problem
 
@@ -972,7 +972,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             directorySolutionPropsPropertyGroup.AppendChild(directorySolutionPropsBasePathProperty);
             directorySolutionPropsPropertyGroup.AppendChild(directorySolutionPropsPathProperty);
 
-            // These are just dummies necessary to make the evaluation into a project instance succeed when 
+            // These are just dummies necessary to make the evaluation into a project instance succeed when
             // any custom imported targets have declarations like BeforeTargets="Build"
             // They'll be replaced momentarily with the real ones.
             string[] dummyTargetsForEvaluationTime = _defaultTargetNames.Union(_targetNames).ToArray();
@@ -1104,7 +1104,7 @@ private static string GetPropertiesMetadataForProjectReference(ProjectInstance t
 
             if (traversalProject.SubToolsetVersion != null)
             {
-                // Note: it is enough below to compare traversalProject.SubToolsetVersion with 4.0 as a means to verify if 
+                // Note: it is enough below to compare traversalProject.SubToolsetVersion with 4.0 as a means to verify if
                 // traversalProject.SubToolsetVersion < 12.0 since this path isn't followed for traversalProject.SubToolsetVersion values of 2.0 and 3.5
                 if (traversalProject.SubToolsetVersion.Equals("4.0", StringComparison.OrdinalIgnoreCase))
                 {
@@ -1414,15 +1414,15 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
 
             if (targetName == "Clean")
             {
-                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of 
-                // a "Clean" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of
+                // a "Clean" operation.  The best we can really do is offer up a
                 // message saying so.
                 AddErrorWarningMessageInstance(newTarget, null, XMakeElements.message, true, "SolutionVenusProjectNoClean");
             }
             else if (targetName == "Publish")
             {
-                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of 
-                // a "Publish" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of
+                // a "Publish" operation.  The best we can really do is offer up a
                 // message saying so.
                 AddErrorWarningMessageInstance(newTarget, null, XMakeElements.message, true, "SolutionVenusProjectNoPublish");
             }
@@ -1434,7 +1434,7 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
 
                 // We're going to build up an MSBuild condition string that represents the valid Configurations.
                 // We do this by OR'ing together individual conditions, each of which compares $(Configuration)
-                // with a valid configuration name.  We init our condition string to "false", so we can easily 
+                // with a valid configuration name.  We init our condition string to "false", so we can easily
                 // OR together more stuff as we go, and also easily take the negation of the condition by putting
                 // a ! around the whole thing.
                 var conditionDescribingValidConfigurations = new StringBuilder("(false)");
@@ -1446,7 +1446,7 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
                     var aspNetCompilerParameters = (AspNetCompilerParameters)aspNetConfiguration.Value;
 
                     // We only add the PropertyGroup once per Venus project.  Without the following "if", we would add
-                    // the same identical PropertyGroup twice, once when AddTargetForWebProject is called with 
+                    // the same identical PropertyGroup twice, once when AddTargetForWebProject is called with
                     // subTargetName=null and once when subTargetName="Rebuild".
                     if (targetName == null)
                     {
@@ -1486,7 +1486,7 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
                 // Add tasks to capture the auto-refreshed file references (those .REFRESH files).
                 AddTasksToResolveAutoRefreshFileReferences(newTarget, project, referenceItemName.ToString());
 
-                // Add a call to RAR (ResolveAssemblyReference) and the Copy task to put the referenced 
+                // Add a call to RAR (ResolveAssemblyReference) and the Copy task to put the referenced
                 // project outputs in the right place
                 AddTasksToCopyAllDependenciesIntoBinDir(newTarget, project, referenceItemName.ToString(), conditionDescribingValidConfigurations.ToString());
 
@@ -1570,7 +1570,7 @@ private void ValidateTargetFrameworkForWebProject(ProjectInSolution project)
             }
         }
 
-        // As of .NET Framework 4.0, there are only two versions of aspnet_compiler.exe: 2.0 and 4.0.  If 
+        // As of .NET Framework 4.0, there are only two versions of aspnet_compiler.exe: 2.0 and 4.0.  If
         // the TargetFrameworkVersion is less than 4.0, use the 2.0 version.  Otherwise, just use the 4.0
         // version of the executable, so that if say FV 4.1 is passed in, we don't throw an error.
         private void SetToolPathForAspNetCompilerTask(ProjectInSolution project, ProjectTaskInstance task)
@@ -1722,7 +1722,7 @@ private static void AddPropertyGroupForAspNetConfiguration(
 
                 if (!String.IsNullOrEmpty(lastFolderInPhysicalPath))
                 {
-                    // If there is a global property called "OutDir" set, that means the caller is trying to 
+                    // If there is a global property called "OutDir" set, that means the caller is trying to
                     // override the AspNetTargetPath.  What we want to do in this case is concatenate:
                     // $(OutDir) + "\_PublishedWebsites" + (the last portion of the folder in the AspNetPhysicalPath).
                     if (traversalProject.EvaluateCondition(" '$(OutDir)' != '' "))
@@ -2076,7 +2076,7 @@ private IDictionary<string, string> GetMetaprojectGlobalProperties(ProjectInstan
             }
 
             // If we have a sub-toolset version, it will be set on the P2P from the solution metaproj, so we need
-            // to make sure it's set here, too, so the global properties will match.  
+            // to make sure it's set here, too, so the global properties will match.
             if (traversalProject.SubToolsetVersion != null)
             {
                 if (traversalProject.SubToolsetVersion.Equals("4.0", StringComparison.OrdinalIgnoreCase))
@@ -2124,7 +2124,7 @@ private void ScanProjectDependencies(string childProjectToolsVersion, string ful
 
             foreach (ProjectInSolution project in _solutionFile.ProjectsInOrder)
             {
-                // We only need to scan .wdproj projects: Everything else is either MSBuildFormat or 
+                // We only need to scan .wdproj projects: Everything else is either MSBuildFormat or
                 // something we don't know how to do anything with anyway
                 if (project.ProjectType == SolutionProjectType.WebDeploymentProject)
                 {
@@ -2138,11 +2138,11 @@ private void ScanProjectDependencies(string childProjectToolsVersion, string ful
                     {
                         Project msbuildProject = new Project(project.AbsolutePath, _globalProperties, childProjectToolsVersion);
 
-                        // ProjectDependency items work exactly like ProjectReference items from the point of 
+                        // ProjectDependency items work exactly like ProjectReference items from the point of
                         // view of determining that project B depends on project A.  This item must cause
                         // project A to be built prior to project B.
                         //
-                        // This has the format 
+                        // This has the format
                         // <ProjectDependency Include="DependentProjectRelativePath">
                         //   <Project>{GUID}</Project>
                         // </Project>
diff --git a/src/Build/Construction/UsingTaskParameterGroupElement.cs b/src/Build/Construction/UsingTaskParameterGroupElement.cs
index 3e76edb1e85..9bbc27f71e2 100644
--- a/src/Build/Construction/UsingTaskParameterGroupElement.cs
+++ b/src/Build/Construction/UsingTaskParameterGroupElement.cs
@@ -45,7 +45,7 @@ private UsingTaskParameterGroupElement(XmlElementWithLocation xmlElement, Projec
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
@@ -128,7 +128,7 @@ private static void VerifyCorrectParent(ProjectElementContainer parent)
             ProjectUsingTaskElement parentUsingTask = parent as ProjectUsingTaskElement;
             ErrorUtilities.VerifyThrowInvalidOperation(parentUsingTask != null, "OM_CannotAcceptParent");
 
-            // Now since there is not goign to be a TaskElement on the using task we need to validate and make sure there is a TaskFactory attribute on the parent element and 
+            // Now since there is not goign to be a TaskElement on the using task we need to validate and make sure there is a TaskFactory attribute on the parent element and
             // that it is not empty
             if (parentUsingTask.TaskFactory.Length == 0)
             {
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 106b1ca08ee..d785f9f8c50 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -912,7 +912,7 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         /// uberGlob.IsMatch("foo.cs");
         /// ]]>
         /// </code>
-        /// 
+        ///
         /// </remarks>
         /// <returns>
         /// List of <see cref="GlobResult"/>.
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 5d2bf851cef..924b3e25db7 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1154,7 +1154,7 @@ public Project LoadProject(string fileName, IDictionary<string, string> globalPr
                 {
                     // We need to update the set of global properties to merge in the ProjectCollection global properties --
                     // otherwise we might end up declaring "not matching" a project that actually does ... and then throw
-                    // an exception when we go to actually add the newly created project to the ProjectCollection. 
+                    // an exception when we go to actually add the newly created project to the ProjectCollection.
                     // BUT remember that project global properties win -- don't override a property that already exists.
                     foreach (KeyValuePair<string, string> globalProperty in GlobalProperties)
                     {
@@ -1171,9 +1171,9 @@ public Project LoadProject(string fileName, IDictionary<string, string> globalPr
 
                 if (toolsVersion == null)
                 {
-                    // Load the project XML to get any ToolsVersion attribute. 
+                    // Load the project XML to get any ToolsVersion attribute.
                     // If there isn't already an equivalent project loaded, the real load we'll do will be satisfied from the cache.
-                    // If there is already an equivalent project loaded, we'll never need this XML -- but it'll already 
+                    // If there is already an equivalent project loaded, we'll never need this XML -- but it'll already
                     // have been loaded by that project so it will have been satisfied from the ProjectRootElementCache.
                     // Either way, no time wasted.
                     try
@@ -1350,7 +1350,7 @@ public void UnloadProject(Project project)
 
                 // Aggressively release any strings from all the contributing documents.
                 // It's fine if we cache less (by now we likely did a lot of loading and got the benefits)
-                // If we don't do this, we could be releasing the last reference to a 
+                // If we don't do this, we could be releasing the last reference to a
                 // ProjectRootElement, causing it to fall out of the weak cache leaving its strings and XML
                 // behind in the string cache.
                 project.Xml.XmlDocument.ClearAnyCachedStrings();
@@ -1578,12 +1578,12 @@ internal void OnAfterRenameLoadedProject(string oldFullPathIfAny, Project projec
                     ErrorUtilities.VerifyThrowInvalidOperation(existed, "OM_ProjectWasNotLoaded");
                 }
 
-                // The only time this ever gets called with a null full path is when the project is first being 
-                // constructed.  The mere fact that this method is being called means that this project will belong 
-                // to this project collection.  As such, it has already had all necessary global properties applied 
-                // when being constructed -- we don't need to do anything special here. 
-                // If we did add global properties here, we would just end up either duplicating work or possibly 
-                // wiping out global properties set on the project meant to override the ProjectCollection copies. 
+                // The only time this ever gets called with a null full path is when the project is first being
+                // constructed.  The mere fact that this method is being called means that this project will belong
+                // to this project collection.  As such, it has already had all necessary global properties applied
+                // when being constructed -- we don't need to do anything special here.
+                // If we did add global properties here, we would just end up either duplicating work or possibly
+                // wiping out global properties set on the project meant to override the ProjectCollection copies.
                 _loadedProjects.AddProject(project);
 
                 if (_hostServices != null)
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index cfc17374cb3..ddcf37f6b30 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -42,30 +42,30 @@ public class ProjectItem : IItem<ProjectMetadata>, IProjectMetadataParent
         /// </summary>
         /// <remarks>
         /// This is ONLY used to figure out %(RecursiveDir) when it is requested.
-        /// It's likely too expensive to figure that out if it isn't needed, so we store 
+        /// It's likely too expensive to figure that out if it isn't needed, so we store
         /// the necessary material here.
         /// </remarks>
         private readonly string _evaluatedIncludeBeforeWildcardExpansionEscaped;
 
         /// <summary>
         /// Item definitions are stored in one single table shared by all items of a particular item type.
-        /// 
+        ///
         /// When an item is created from another item, such as by using an expression like Include="@(x)",
-        /// any item definition metadata those source items have must override any item definition metadata 
-        /// associated with the new item type. 
-        /// 
+        /// any item definition metadata those source items have must override any item definition metadata
+        /// associated with the new item type.
+        ///
         /// Copying all those item definition metadata into real metadata on this item would be very inefficient, because
         /// it would turn a single shared table into a separate table for every item.
-        /// 
+        ///
         /// Instead, we get a reference to the item definition of the source items, and consult
         /// that table before we consult our own item type's item definition. Since item definitions can't change at this point,
         /// it's safe to reference their original table.
-        /// 
+        ///
         /// If our item gets copied again, we need a reference to the inherited item definition and we need the real item
         /// definition of the source items. Thus a list is created. On copying, a list is created, beginning with a clone
         /// of any list the source item had, and ending with the item definition list of the source item type.
-        /// 
-        /// When we look up a metadata value we look at 
+        ///
+        /// When we look up a metadata value we look at
         /// (1) directly associated metadata and built-in metadata
         /// (2) the inherited item definition list, starting from the top
         /// (3) the item definition associated with our item type
@@ -194,7 +194,7 @@ public string UnevaluatedInclude
         }
 
         /// <summary>
-        /// Gets the evaluated value of the include, unescaped. 
+        /// Gets the evaluated value of the include, unescaped.
         /// </summary>
         public string EvaluatedInclude
         {
@@ -425,7 +425,7 @@ public ProjectMetadata GetMetadata(string name)
         }
 
         /// <summary>
-        /// Get the evaluated value of a metadata on this item, possibly from an item definition. 
+        /// Get the evaluated value of a metadata on this item, possibly from an item definition.
         /// Returns empty string if it does not exist.
         /// To determine whether a piece of metadata does not exist vs. simply has no value, use <see cref="HasMetadata(string)">HasMetadata</see>.
         /// May be used to access the value of built-in metadata, such as "FullPath".
@@ -468,8 +468,8 @@ public bool HasMetadata(string name)
         }
 
         /// <summary>
-        /// See <see cref="GetMetadataValue(string)">GetMetadataValue</see> for a more detailed explanation.  
-        /// Returns the escaped value of the metadatum requested.  
+        /// See <see cref="GetMetadataValue(string)">GetMetadataValue</see> for a more detailed explanation.
+        /// Returns the escaped value of the metadatum requested.
         /// </summary>
         string IItem.GetMetadataValueEscaped(string name)
         {
@@ -523,7 +523,7 @@ ProjectMetadata IItem<ProjectMetadata>.GetMetadata(string name)
         }
 
         /// <summary>
-        /// Adds a ProjectMetadata to the item. 
+        /// Adds a ProjectMetadata to the item.
         /// This is ONLY called during evaluation and does not affect the XML.
         /// </summary>
         ProjectMetadata IItem<ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude)
@@ -558,7 +558,7 @@ public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
         /// <summary>
         /// Overload of <see cref="SetMetadataValue(string,string)"/>. Adds the option of not splitting the item element and thus affecting all sibling items.
         /// Sibling items are defined as all ProjectItem instances that were created from the same item element.
-        /// 
+        ///
         /// This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state without a reevaluation
         /// </summary>
         /// /// <param name="name">Metadata name</param>
@@ -663,7 +663,7 @@ public bool RemoveMetadata(string name)
         /// <summary>
         /// Renames the item.
         /// Equivalent to setting the <see cref="UnevaluatedInclude"/> value.
-        /// Generally, no expansion occurs. This is because it would potentially result in several items, 
+        /// Generally, no expansion occurs. This is because it would potentially result in several items,
         /// which is not meaningful semantics when renaming a single item.
         /// However if the item does not need to be split (which would invalidate its ProjectItemElement),
         /// and the new value expands to exactly one item, then its evaluated include is updated
@@ -671,12 +671,12 @@ public bool RemoveMetadata(string name)
         /// </summary>
         /// <remarks>
         /// Even if the new value expands to zero items, we do not expand it.
-        /// The common case we are interested in for expansion here is setting something 
-        /// like "$(sourcesroot)\foo.cs" and expanding that to a single item. 
-        /// If say "@(foo)" is set as the new name, and it expands to blank, that might 
-        /// be surprising to the host and maybe even unhandled, if on full reevaluation 
-        /// it wouldnt expand to blank. Thats why we're being cautious and supporting 
-        /// the most common scenario only. 
+        /// The common case we are interested in for expansion here is setting something
+        /// like "$(sourcesroot)\foo.cs" and expanding that to a single item.
+        /// If say "@(foo)" is set as the new name, and it expands to blank, that might
+        /// be surprising to the host and maybe even unhandled, if on full reevaluation
+        /// it wouldnt expand to blank. Thats why we're being cautious and supporting
+        /// the most common scenario only.
         /// Many hosts will do a ReevaluateIfNecessary before reading anyway.
         /// </remarks>
         public void Rename(string name)
@@ -826,7 +826,7 @@ internal void SplitOwnItemElement()
                 return;
             }
 
-            // ProjectMetadata objects may be being shared with other ProjectItem objects, 
+            // ProjectMetadata objects may be being shared with other ProjectItem objects,
             // or originate from item definitions, so it is necessary to replace ours with
             // new ones.
             List<ProjectMetadata> temporary = new List<ProjectMetadata>(_directMetadata.Count);
@@ -957,8 +957,8 @@ public ProjectItemElement ItemElement
             /// <param name="definingProject">The path to the project that defined the item.</param>
             /// <returns>A new project item.</returns>
             /// <comments>
-            /// NOTE: defining project is ignored because we already know the ItemElement associated with 
-            /// this item, and use that for where it is defined. 
+            /// NOTE: defining project is ignored because we already know the ItemElement associated with
+            /// this item, and use that for where it is defined.
             /// </comments>
             public ProjectItem CreateItem(string include, string definingProject)
             {
@@ -974,8 +974,8 @@ public ProjectItem CreateItem(string include, string definingProject)
             /// setting metadata should create new XML.
             /// </summary>
             /// <comments>
-            /// NOTE: defining project is ignored because we already know the ItemElement associated with 
-            /// this item, and use that for where it is defined. 
+            /// NOTE: defining project is ignored because we already know the ItemElement associated with
+            /// this item, and use that for where it is defined.
             /// </comments>
             public ProjectItem CreateItem(ProjectItem source, string definingProject)
             {
@@ -994,8 +994,8 @@ public ProjectItem CreateItem(ProjectItem source, string definingProject)
             /// If it's not, we have to clone that too.
             /// </remarks>
             /// <comments>
-            /// NOTE: defining project is ignored because we already know the ItemElement associated with 
-            /// this item, and use that for where it is defined. 
+            /// NOTE: defining project is ignored because we already know the ItemElement associated with
+            /// this item, and use that for where it is defined.
             /// </comments>
             public ProjectItem CreateItem(string evaluatedIncludeEscaped, ProjectItem source, string definingProject)
             {
@@ -1007,8 +1007,8 @@ public ProjectItem CreateItem(string evaluatedIncludeEscaped, ProjectItem source
             /// This is to support creating items from an include that may have a wildcard expression in it.
             /// </summary>
             /// <comments>
-            /// NOTE: defining project is ignored because we already know the ItemElement associated with 
-            /// this item, and use that for where it is defined. 
+            /// NOTE: defining project is ignored because we already know the ItemElement associated with
+            /// this item, and use that for where it is defined.
             /// </comments>
             public ProjectItem CreateItem(string evaluatedIncludeEscaped, string evaluatedIncludeBeforeWildcardExpansion, string definingProject)
             {
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index cfffb456d72..d3d70ef98de 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -105,7 +105,7 @@ public int MetadataCount
         }
 
         /// <summary>
-        /// Implementation of IKeyed exposing the item type, so these 
+        /// Implementation of IKeyed exposing the item type, so these
         /// can be put in a dictionary conveniently.
         /// </summary>
         string IKeyed.Key
@@ -168,7 +168,7 @@ public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
                 }
             }
 
-            // We can't use the item definition that this object came from as a root, as it doesn't map directly 
+            // We can't use the item definition that this object came from as a root, as it doesn't map directly
             // to a single XML element. Instead, add a new one to the project. Best we can do.
             ProjectItemDefinitionElement itemDefinition = _project.Xml.AddItemDefinition(_itemType);
 
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index bd4cc51c88a..df770c85ce7 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -65,7 +65,7 @@ internal ProjectMetadata(object parent, ProjectMetadataElement xml)
         }
 
         /// <summary>
-        /// Creates a metadata backed by XML. 
+        /// Creates a metadata backed by XML.
         /// Constructed during evaluation of a project.
         /// </summary>
         internal ProjectMetadata(IProjectMetadataParent parent, ProjectMetadataElement xml, string evaluatedValueEscaped, ProjectMetadata predecessor)
@@ -106,19 +106,19 @@ public string EvaluatedValue
 
         /// <summary>
         /// Gets or sets the unevaluated metadata value.
-        /// 
+        ///
         /// As well as updating the unevaluated value, the setter updates the evaluated value, but does not affect anything else in the project until reevaluation. For example,
         ///     --if a piece of metadata named "m" is modified on item of type "i", it does not affect "j" which is evaluated from "@(j->'%(m)')" until reevaluation.
         ///     --if the unevaluated value of "m" is set to something that is modified by evaluation, such as "$(p)", the evaluated value will be set to "$(p)" until reevaluation.
         /// This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state.
-        /// 
+        ///
         /// Setting metadata through a ProjectItem may cause the underlying ProjectItemElement to be split, if it originated with an itemlist, wildcard, or semicolon expression,
         /// because it was clear that the caller intended to only affect that particular item.
         /// Setting metadata through a ProjectMetadata does not cause any splitting, because we assume the caller presumably intends to affect all items using the underlying
         /// ProjectMetadataElement. At least, this seems a reasonable assumption, and it avoids the need for metadata to hold a pointer to their containing items.
         /// </summary>
         /// <remarks>
-        /// The containing project will be dirtied by the XML modification.  Unevaluated values are assumed to be passed in escaped as necessary. 
+        /// The containing project will be dirtied by the XML modification.  Unevaluated values are assumed to be passed in escaped as necessary.
         /// </remarks>
         public string UnevaluatedValue
         {
diff --git a/src/Build/Definition/SubToolset.cs b/src/Build/Definition/SubToolset.cs
index 95cf1aa153e..84747bbb9d2 100644
--- a/src/Build/Definition/SubToolset.cs
+++ b/src/Build/Definition/SubToolset.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// Aggregation of a set of properties that correspond to a particular sub-toolset.  
+    /// Aggregation of a set of properties that correspond to a particular sub-toolset.
     /// </summary>
     [DebuggerDisplay("SubToolsetVersion={SubToolsetVersion} #Properties={_properties.Count}")]
     public class SubToolset : ITranslatable
@@ -28,11 +28,11 @@ public class SubToolset : ITranslatable
 
         /// <summary>
         /// The properties defined by the subtoolset.
-        /// </summary> 
+        /// </summary>
         private PropertyDictionary<ProjectPropertyInstance> _properties;
 
         /// <summary>
-        /// Constructor that associates a set of properties with a sub-toolset version.  
+        /// Constructor that associates a set of properties with a sub-toolset version.
         /// </summary>
         internal SubToolset(string subToolsetVersion, PropertyDictionary<ProjectPropertyInstance> properties)
         {
@@ -62,7 +62,7 @@ public string SubToolsetVersion
         }
 
         /// <summary>
-        /// The properties that correspond to this particular sub-toolset. 
+        /// The properties that correspond to this particular sub-toolset.
         /// </summary>
         public IDictionary<string, ProjectPropertyInstance> Properties
         {
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 58b18cadab1..212fb7fecc1 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -902,7 +902,7 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
 
             try
             {
-                
+
                 List<ProjectPropertyInstance> reservedProperties = new List<ProjectPropertyInstance>();
 
                 reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.binPath, EscapingUtilities.Escape(ToolsPath), mayBeReserved: true));
diff --git a/src/Build/Definition/ToolsetPropertyDefinition.cs b/src/Build/Definition/ToolsetPropertyDefinition.cs
index da172891cd1..c7ee19a570d 100644
--- a/src/Build/Definition/ToolsetPropertyDefinition.cs
+++ b/src/Build/Definition/ToolsetPropertyDefinition.cs
@@ -79,7 +79,7 @@ public string Value
 
         /// <summary>
         /// A description of the location where the property was defined,
-        /// such as a registry key path or a path to a config file and 
+        /// such as a registry key path or a path to a config file and
         /// line number.
         /// </summary>
         public IElementLocation Source
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index d7d81e88dc6..dc91a43e774 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -115,7 +115,7 @@ internal static string ReadAllToolsets(
             initialProperties.ImportProperties(globalProperties);
 
             // The ordering here is important because the configuration file should have greater precedence
-            // than the registry, and we do a check and don't read in the new toolset if there's already one. 
+            // than the registry, and we do a check and don't read in the new toolset if there's already one.
             string defaultToolsVersionFromConfiguration = null;
             string overrideTasksPathFromConfiguration = null;
             string defaultOverrideToolsVersionFromConfiguration = null;
@@ -248,12 +248,12 @@ void ReadConfigToolset()
                 }
             }
 
-            // The 2.0 .NET Framework installer did not write a ToolsVersion key for itself in the registry. 
-            // The 3.5 installer writes one for 2.0, but 3.5 might not be installed.  
-            // The 4.0 and subsequent installers can't keep writing the 2.0 one, because (a) it causes SxS issues and (b) we 
+            // The 2.0 .NET Framework installer did not write a ToolsVersion key for itself in the registry.
+            // The 3.5 installer writes one for 2.0, but 3.5 might not be installed.
+            // The 4.0 and subsequent installers can't keep writing the 2.0 one, because (a) it causes SxS issues and (b) we
             // don't want it unless 2.0 is installed.
             // So if the 2.0 framework is actually installed, we're reading the registry, and either the registry or the config
-            // file have not already created the 2.0 toolset, mock up a fake one.  
+            // file have not already created the 2.0 toolset, mock up a fake one.
             if (((locations & ToolsetDefinitionLocations.Registry) != 0) && !toolsets.ContainsKey("2.0")
                 && FrameworkLocationHelper.PathToDotNetFrameworkV20 != null)
             {
@@ -396,8 +396,8 @@ internal string ReadToolsets(
         protected abstract IEnumerable<string> GetSubToolsetVersions(string toolsVersion);
 
         /// <summary>
-        /// Provides an enumerator over property definitions for a specified sub-toolset version 
-        /// under a specified toolset version. 
+        /// Provides an enumerator over property definitions for a specified sub-toolset version
+        /// under a specified toolset version.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version.</param>
@@ -421,10 +421,10 @@ private void ReadEachToolset(
             foreach (ToolsetPropertyDefinition toolsVersion in ToolsVersions)
             {
                 // If there's already an existing toolset, it's of higher precedence, so
-                // don't even bother to read this toolset in.  
+                // don't even bother to read this toolset in.
                 if (!toolsets.ContainsKey(toolsVersion.Name))
                 {
-                    // We clone here because we don't want to interfere with the evaluation 
+                    // We clone here because we don't want to interfere with the evaluation
                     // of subsequent Toolsets; otherwise, properties found during the evaluation
                     // of this Toolset would be persisted in initialProperties and appear
                     // to later Toolsets as Global or Environment properties from the Engine.
@@ -509,7 +509,7 @@ private Toolset ReadToolset(
                 IEnumerable<ToolsetPropertyDefinition> rawSubToolsetProperties = GetSubToolsetPropertyDefinitions(toolsVersion.Name, subToolsetVersion);
                 PropertyDictionary<ProjectPropertyInstance> subToolsetProperties = new PropertyDictionary<ProjectPropertyInstance>();
 
-                // If we have a sub-toolset, any values defined here will override the toolset properties. 
+                // If we have a sub-toolset, any values defined here will override the toolset properties.
                 foreach (ToolsetPropertyDefinition property in rawSubToolsetProperties)
                 {
                     EvaluateAndSetProperty(property, subToolsetProperties, globalProperties, initialProperties, false /* do not ever accumulate sub-toolset properties */, ref subToolsetToolsPath, ref subToolsetBinPath, ref expander);
@@ -646,7 +646,7 @@ private static void AppendStandardProperties(
         }
 
         /// <summary>
-        /// Processes a particular ToolsetPropertyDefinition into the correct value and location in the initial and/or final property set. 
+        /// Processes a particular ToolsetPropertyDefinition into the correct value and location in the initial and/or final property set.
         /// </summary>
         /// <param name="property">The ToolsetPropertyDefinition being analyzed.</param>
         /// <param name="properties">The final set of properties that we wish this toolset property to be added to. </param>
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 8d84d5dc908..2dd2bb89a95 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -301,8 +301,8 @@ public override int Column
         /// For when the line and column each fit in a short - under 65536
         /// (almost always will: microsoft.common.targets is less than 5000 lines long)
         /// When loading Australian Government, for example, there are over 31,000 ElementLocation
-        /// objects so this saves 4 bytes each = 123KB 
-        /// 
+        /// objects so this saves 4 bytes each = 123KB
+        ///
         /// A "very small" variation that used two bytes (or halves of a short) would fit about half of them
         /// and save 4 more bytes each, but the CLR packs each field to 4 bytes, so it isn't actually any smaller.
         /// </summary>
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 88b0de71dbb..71f51e9f272 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Construction
     /// <remarks>
     /// XmlDocument has many members, and this can't substitute for all of them. Location finding probably won't work if
     /// certain XmlDocument members are used. So for extra robustness, this could wrap an XmlDocument instead,
-    /// and expose the small number of members that the MSBuild code actually uses. 
+    /// and expose the small number of members that the MSBuild code actually uses.
     /// </remarks>
     internal class XmlDocumentWithLocation : XmlDocument
     {
diff --git a/src/Build/ElementLocation/XmlElementWithLocation.cs b/src/Build/ElementLocation/XmlElementWithLocation.cs
index ddbf27a08de..b45ccb5b723 100644
--- a/src/Build/ElementLocation/XmlElementWithLocation.cs
+++ b/src/Build/ElementLocation/XmlElementWithLocation.cs
@@ -128,7 +128,7 @@ public XmlAttributeWithLocation GetAttributeWithLocation(string name)
         }
 
         /// <summary>
-        /// Overridden to convert the display of the element from open form (separate open and closed tags) to closed form 
+        /// Overridden to convert the display of the element from open form (separate open and closed tags) to closed form
         /// (single closed tag) if the last child is being removed. This is simply for tidiness of the project file.
         /// For example, removing the only piece of metadata from an item will leave behind one tag instead of two.
         /// </summary>
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 7bc6e4a135d..fe42d76e2fb 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -80,7 +80,7 @@ internal InvalidProjectFileException(string message, InvalidProjectFileException
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
@@ -370,7 +370,7 @@ public string HelpKeyword
         }
 
         /// <summary>
-        /// Whether the exception has already been logged. Allows the exception to be logged at the 
+        /// Whether the exception has already been logged. Allows the exception to be logged at the
         /// most appropriate location, but continue to be propagated.
         /// </summary>
         public bool HasBeenLogged
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 1ebc9c9d1b1..df5b2a09797 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -139,7 +139,7 @@ public string ErrorCode
 
         /// <summary>
         /// Throws an InvalidToolsetDefinitionException.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -156,7 +156,7 @@ internal static void Throw(
         /// <summary>
         /// Throws an InvalidToolsetDefinitionException including a specified inner exception,
         /// which may be interesting to hosts.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index aeb2bc7414e..1d231597726 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -23,7 +23,7 @@ internal static class ConditionEvaluator
         /// inside of a condition and the string values that they are being tested against.
         /// So, for example, if the condition was " '$(Configuration)' == 'Debug' ", we
         /// would get passed in leftValue="$(Configuration)" and rightValueExpanded="Debug".
-        /// This call would add the string "Debug" to the list of possible values for the 
+        /// This call would add the string "Debug" to the list of possible values for the
         /// "Configuration" property.
         ///
         /// This method also handles the case when two or more properties are being
@@ -62,7 +62,7 @@ internal static void UpdateConditionedPropertiesTable(
                         string rightValueExpandedPiece;
 
                         // If there was no vertical bar, then just use the remainder of the right-hand-side
-                        // expression as the value of the property, and terminate the loop after this iteration.  
+                        // expression as the value of the property, and terminate the loop after this iteration.
                         // Also, if we're on the last segment of the left-hand-side, then use the remainder
                         // of the right-hand-side expression as the value of the property.
                         if ((indexOfVerticalBar == -1) || lastPiece)
@@ -73,7 +73,7 @@ internal static void UpdateConditionedPropertiesTable(
                         else
                         {
                             // If we found a vertical bar, then the portion before the vertical bar is the
-                            // property value which we will store in our table.  Then remove that portion 
+                            // property value which we will store in our table.  Then remove that portion
                             // from the original string so that the next iteration of the loop can easily search
                             // for the first vertical bar again.
                             rightValueExpandedPiece = rightValueExpanded.Substring(0, indexOfVerticalBar);
@@ -383,7 +383,7 @@ internal interface IConditionEvaluationState
         }
 
         /// <summary>
-        /// All the state necessary for the evaluation of conditionals so that the expression tree 
+        /// All the state necessary for the evaluation of conditionals so that the expression tree
         /// is stateless and reusable
         /// </summary>
         internal class ConditionEvaluationState<P, I> : IConditionEvaluationState
@@ -414,7 +414,7 @@ internal class ConditionEvaluationState<P, I> : IConditionEvaluationState
             public Dictionary<string, List<string>>? ConditionedPropertiesInProject { get; }
 
             /// <summary>
-            /// PRE collection. 
+            /// PRE collection.
             /// </summary>
             public ProjectRootElementCacheBase? LoadedProjectsCache { get; }
 
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index ee3ccbe9b2d..e16e7537379 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -63,7 +63,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     // Ignore invalid characters or path related exceptions
 
                     // We will ignore the PathTooLong exception caused by GetFullPath because in single proc this code
-                    // is not executed and the condition is just evaluated to false as File.Exists and Directory.Exists does not throw in this situation. 
+                    // is not executed and the condition is just evaluated to false as File.Exists and Directory.Exists does not throw in this situation.
                     // To be consistant with that we will return a false in this case also.
                     // DevDiv Bugs: 46035
 
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index aa512c045b3..3d0d6d99456 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -43,7 +43,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         internal abstract string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluationState state);
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal abstract void ResetState();
@@ -90,7 +90,7 @@ internal virtual bool PossibleOrCollision
         internal bool PotentialAndOrConflict()
         {
             // The values of the functions are assigned to boolean locals
-            // in order to force evaluation of the functions even when the 
+            // in order to force evaluation of the functions even when the
             // first one returns false
             bool detectOr = DetectOr();
             bool detectAnd = DetectAnd();
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index e1cf63fd6bf..208794b3603 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -45,11 +45,11 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                  "IllFormedCondition",
                  state.Condition);
 
-            // It's sometimes possible to bail out of expansion early if we just need to know whether 
+            // It's sometimes possible to bail out of expansion early if we just need to know whether
             // the result is empty string.
-            // If at least one of the left or the right hand side will evaluate to empty, 
+            // If at least one of the left or the right hand side will evaluate to empty,
             // and we know which do, then we already have enough information to evaluate this expression.
-            // That means we don't have to fully expand a condition like " '@(X)' == '' " 
+            // That means we don't have to fully expand a condition like " '@(X)' == '' "
             // which is a performance advantage if @(X) is a huge item list.
             bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);
             bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index 536ac17ae9b..acfdd72bce9 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -56,7 +56,7 @@ internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluatio
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 0f20ef208c3..2c172a9af0a 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -52,7 +52,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index 0984647db61..0407cd0d7f5 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -53,7 +53,7 @@ internal sealed class Parser
 
         private BuildEventContext _logBuildEventContext;
         /// <summary>
-        ///  Location contextual information which are attached to logging events to 
+        ///  Location contextual information which are attached to logging events to
         ///  say where they are in relation to the process, engine, project, target,task which is executing
         /// </summary>
         internal BuildEventContext LogBuildEventContext
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 2f05a821326..2c3dcc080df 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -148,7 +148,7 @@ internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluatio
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Build/Evaluation/Conditionals/Token.cs b/src/Build/Evaluation/Conditionals/Token.cs
index 182c3e3c6b0..9f86503f454 100644
--- a/src/Build/Evaluation/Conditionals/Token.cs
+++ b/src/Build/Evaluation/Conditionals/Token.cs
@@ -117,7 +117,7 @@ internal bool Expandable
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="type"></param>
         /// <returns></returns>
@@ -135,7 +135,7 @@ internal string String
                     return _tokenString;
                 }
 
-                // Return a token string for 
+                // Return a token string for
                 // an error message.
                 switch (_tokenType)
                 {
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index d28c9210e29..649ae9ac856 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -110,7 +110,7 @@ private EvaluationContext CreateUsedIsolatedContext()
 
         internal EvaluationContext ContextForNewProject()
         {
-            // Projects using isolated contexts need to get a new context instance 
+            // Projects using isolated contexts need to get a new context instance
             switch (Policy)
             {
                 case SharingPolicy.Shared:
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index 360843f9b58..fd102dff143 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -634,8 +634,8 @@ private static bool SinkValidName(string expression, ref int i, int end)
         }
 
         /// <summary>
-        /// Returns true if the character at the specified index 
-        /// is the specified char. 
+        /// Returns true if the character at the specified index
+        /// is the specified char.
         /// Leaves index one past the character.
         /// </summary>
         private static bool Sink(string expression, ref int i, char c)
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 729e99b48ab..d6074d17f46 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -45,7 +45,7 @@ string Directory
         }
 
         /// <summary>
-        /// Task classes and locations known to this project. 
+        /// Task classes and locations known to this project.
         /// This is the project-specific task registry, which is consulted before
         /// the toolset's task registry.
         /// </summary>
@@ -64,8 +64,8 @@ Toolset Toolset
         }
 
         /// <summary>
-        /// The sub-toolset version that should be used with this toolset to determine 
-        /// the full set of properties to be used by the build. 
+        /// The sub-toolset version that should be used with this toolset to determine
+        /// the full set of properties to be used by the build.
         /// </summary>
         string SubToolsetVersion
         {
@@ -92,7 +92,7 @@ PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesDictionary
         }
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         ISet<string> GlobalPropertiesToTreatAsLocal
         {
@@ -174,7 +174,7 @@ PropertyDictionary<P> Properties
         /// <summary>
         /// Enumerator over all item definitions.
         /// Exposed for debugging display.
-        /// Ideally the dictionary would be exposed, but there are 
+        /// Ideally the dictionary would be exposed, but there are
         /// covariance problems. (A dictionary of Key, Value cannot be upcast
         /// to a Dictionary of Key, IValue).
         /// </summary>
@@ -186,7 +186,7 @@ IEnumerable<D> ItemDefinitionsEnumerable
         /// <summary>
         /// Enumerator over all items.
         /// Exposed for debugging display.
-        /// Ideally the dictionary would be exposed, but there are 
+        /// Ideally the dictionary would be exposed, but there are
         /// covariance problems. (A dictionary of Key, Value cannot be upcast
         /// to a Dictionary of Key, IValue).
         /// </summary>
@@ -238,7 +238,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Properties encountered during evaluation. These are read during the first evaluation pass.
         /// Unlike those returned by the Properties property, these are ordered, and include any properties that
-        /// were subsequently overridden by others with the same name. It does not include any 
+        /// were subsequently overridden by others with the same name. It does not include any
         /// properties whose conditions did not evaluate to true.
         /// </summary>
         void AddToAllEvaluatedPropertiesList(P property);
@@ -246,7 +246,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
         /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-        /// were subsequently overridden by others with the same name and item type. It does not include any 
+        /// were subsequently overridden by others with the same name and item type. It does not include any
         /// elements whose conditions did not evaluate to true.
         /// </summary>
         void AddToAllEvaluatedItemDefinitionMetadataList(M itemDefinitionMetadatum);
diff --git a/src/Build/Evaluation/IItemFactory.cs b/src/Build/Evaluation/IItemFactory.cs
index 986386cd7a0..9624d90a562 100644
--- a/src/Build/Evaluation/IItemFactory.cs
+++ b/src/Build/Evaluation/IItemFactory.cs
@@ -49,18 +49,18 @@ ProjectItemElement ItemElement
 
         /// <summary>
         /// Creates an item based off the provided item, with cloning semantics.
-        /// New item is associated with the passed in defining project, not that of the original item. 
+        /// New item is associated with the passed in defining project, not that of the original item.
         /// </summary>
         T CreateItem(S source, string definingProject);
 
         /// <summary>
         /// Creates an item with the specified include and the metadata from the specified base item
-        /// New item is associated with the passed in defining project, not that of the original item. 
+        /// New item is associated with the passed in defining project, not that of the original item.
         /// </summary>
         T CreateItem(string include, S baseItem, string definingProject);
 
         /// <summary>
-        /// Creates an item using the specified evaluated include, include before wildcard expansion, 
+        /// Creates an item using the specified evaluated include, include before wildcard expansion,
         /// and defining project.
         /// </summary>
         T CreateItem(string include, string includeBeforeWildcardExpansion, string definingProject);
diff --git a/src/Build/Evaluation/IItemProvider.cs b/src/Build/Evaluation/IItemProvider.cs
index e4b2766c861..a8c30d5c4ba 100644
--- a/src/Build/Evaluation/IItemProvider.cs
+++ b/src/Build/Evaluation/IItemProvider.cs
@@ -15,7 +15,7 @@ internal interface IItemProvider<T> where T : IItem
     {
         /// <summary>
         /// Returns a list of items with the specified item type.
-        /// 
+        ///
         /// If there are no items of this type, returns an empty list.
         /// </summary>
         /// <param name="itemType">The item type of items to return.</param>
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index fe8b1805bab..485162b1638 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -169,9 +169,9 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                     ////////////////////////////////////////////////////
                     // UNDONE: Implement batching here.
                     //
-                    // We want to allow built-in metadata in metadata values here. 
+                    // We want to allow built-in metadata in metadata values here.
                     // For example, so that an Idl file can specify that its Tlb output should be named %(Filename).tlb.
-                    // 
+                    //
                     // In other words, we want batching. However, we won't need to go to the trouble of using the regular batching code!
                     // That's because that code is all about grouping into buckets of similar items. In this context, we're not
                     // invoking a task, and it's fine to process each item individually, which will always give the correct results.
@@ -183,7 +183,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                     //    or whether they contain any custom metadata && the Include involved an @(itemlist) expression.
                     // -- if either case is found, we go ahead and evaluate all the metadata separately for each item.
                     // -- otherwise we can do the old thing (evaluating all metadata once then applying to all items)
-                    // 
+                    //
                     // This algorithm gives the correct results except when:
                     // -- batchable expressions exist on the include, exclude, or condition on the item element itself
                     //
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs b/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
index 180d4565c72..6c7aac4421c 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
@@ -16,7 +16,7 @@ internal sealed class EvaluationLocationTabSeparatedPrettyPrinter : EvaluationLo
     {
         private const string Separator = "\t";
 
-        /// <inheritdoc/> 
+        /// <inheritdoc/>
         internal override void AppendHeader(StringBuilder stringBuilder)
         {
             AppendDefaultHeaderWithSeparator(stringBuilder, Separator);
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
index dc1132049de..7753ae7e5a5 100644
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ b/src/Build/Evaluation/ProjectStringCache.cs
@@ -218,7 +218,7 @@ private void VerifyState()
                     uniqueEntries.Add(entry);
                     ErrorUtilities.VerifyThrow(entry.RefCount > 0, "extra deref");
 
-                    // We only ever create one StringCacheEntry instance per unique string, and that instance should be 
+                    // We only ever create one StringCacheEntry instance per unique string, and that instance should be
                     // the same in both collections.
                     ErrorUtilities.VerifyThrow(Object.ReferenceEquals(entry, _strings[entry.CachedString]), "bad state");
                 }
@@ -228,7 +228,7 @@ private void VerifyState()
         }
 
         /// <summary>
-        /// Handle event that is fired when an entry in the project root element cache is removed 
+        /// Handle event that is fired when an entry in the project root element cache is removed
         /// from its strong cache.
         /// </summary>
         /// <remarks>
diff --git a/src/Build/Evaluation/SemiColonTokenizer.cs b/src/Build/Evaluation/SemiColonTokenizer.cs
index 6d00f63dff7..7cc65cfb2d5 100644
--- a/src/Build/Evaluation/SemiColonTokenizer.cs
+++ b/src/Build/Evaluation/SemiColonTokenizer.cs
@@ -70,7 +70,7 @@ public bool MoveNext()
                 string segment;
 
                 // Walk along the string, keeping track of whether we are in an item list expression.
-                // If we hit a semi-colon or the end of the string and we aren't in an item list, 
+                // If we hit a semi-colon or the end of the string and we aren't in an item list,
                 // add the segment to the list.
                 for (; _index < _expression.Length; _index++)
                 {
diff --git a/src/Build/Evaluation/StringMetadataTable.cs b/src/Build/Evaluation/StringMetadataTable.cs
index 0b0dd6b4e45..5e920a99c23 100644
--- a/src/Build/Evaluation/StringMetadataTable.cs
+++ b/src/Build/Evaluation/StringMetadataTable.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Evaluation
     internal class StringMetadataTable : IMetadataTable
     {
         /// <summary>
-        /// Table of metadata values. 
+        /// Table of metadata values.
         /// Each key may be qualified ("itemtype.name") or unqualified ("name").
         /// Unqualified are considered to apply to all item types.
         /// May be null, if empty.
diff --git a/src/Build/Evaluation/ToolsetProvider.cs b/src/Build/Evaluation/ToolsetProvider.cs
index 01fa37d33e2..bf1b87243a5 100644
--- a/src/Build/Evaluation/ToolsetProvider.cs
+++ b/src/Build/Evaluation/ToolsetProvider.cs
@@ -57,7 +57,7 @@ private ToolsetProvider(ITranslator translator)
         /// Retrieves the toolsets.
         /// </summary>
         /// <comments>
-        /// ValueCollection is already read-only. 
+        /// ValueCollection is already read-only.
         /// </comments>
         public ICollection<Toolset> Toolsets => _toolsets.Values;
 
@@ -96,8 +96,8 @@ internal static ToolsetProvider FactoryForDeserialization(ITranslator translator
         #endregion
 
         /// <summary>
-        /// Populate Toolsets with a dictionary of (toolset version, Toolset) 
-        /// using information from the registry and config file, if any.  
+        /// Populate Toolsets with a dictionary of (toolset version, Toolset)
+        /// using information from the registry and config file, if any.
         /// </summary>
         private void InitializeToolsetCollection(PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations toolsetDefinitionLocations)
         {
diff --git a/src/Build/Globbing/IMSBuildGlob.cs b/src/Build/Globbing/IMSBuildGlob.cs
index a101b9541de..115e71bf1c2 100644
--- a/src/Build/Globbing/IMSBuildGlob.cs
+++ b/src/Build/Globbing/IMSBuildGlob.cs
@@ -16,7 +16,7 @@ public interface IMSBuildGlob
         ///     - slashes are normalized
         ///     - arguments representing relative paths are normalized against the glob's root.
         ///     For example, the glob **/*.cs does not match ../a.cs, since ../a.cs points outside of the glob root.
-        /// 
+        ///
         ///     Returns false if <paramref name="stringToMatch" /> contains invalid path or file characters.
         /// </summary>
         /// <param name="stringToMatch">The string to match. If the string represents a relative path, it will get normalized against the glob's root. Cannot be null.</param>
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 58f9af58bdf..86e7e350efb 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -395,9 +395,9 @@ IReadOnlyDictionary<string, IReadOnlyCollection<string>> GetSolutionDependencies
                                     dependencyGuid);
                             }
 
-                            // Add it to the list of dependencies, but only if it should build in this solution configuration 
+                            // Add it to the list of dependencies, but only if it should build in this solution configuration
                             // (If a project is not selected for build in the solution configuration, it won't build even if it's depended on by something that IS selected for build)
-                            // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise 
+                            // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise
                             return dependencyProject?.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat
                                 ? dependencyProject.AbsolutePath
                                 : null;
@@ -491,7 +491,7 @@ private void DetectCycles(
                             }
 
                             // the project being evaluated has a circular dependency involving multiple projects
-                            // add this project to the list of projects involved in cycle 
+                            // add this project to the list of projects involved in cycle
                             var projectsInCycle = new List<string> { referenceNode.ProjectInstance.FullPath };
                             return (false, projectsInCycle);
                         }
@@ -604,7 +604,7 @@ private ProjectInstance GetInstanceForPlatformNegotiationWithCaching(
             ProjectCollection projectCollection)
         {
             return _platformNegotiationInstancesCache.GetOrAdd(
-                new ConfigurationMetadata(projectPath, CreatePropertyDictionary(globalProperties)), 
+                new ConfigurationMetadata(projectPath, CreatePropertyDictionary(globalProperties)),
                 new Lazy<ProjectInstance>(() => _projectInstanceFactory(projectPath, globalProperties, projectCollection))).Value;
         }
 
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index c636ae81b41..92b2cf72307 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1982,7 +1982,7 @@ public ProjectRootElement ToProjectRootElement()
             rootElement.DefaultTargets = String.Join(";", DefaultTargets);
             rootElement.ToolsVersion = ToolsVersion;
 
-            // Add all of the item definitions.            
+            // Add all of the item definitions.
             ProjectItemDefinitionGroupElement itemDefinitionGroupElement = rootElement.AddItemDefinitionGroup();
             foreach (ProjectItemDefinitionInstance itemDefinitionInstance in _itemDefinitions.Values)
             {
@@ -2253,7 +2253,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(
             }
 
             // If a ToolsVersion has been passed in using the /tv:xx switch, we want to generate an
-            // old-style solution wrapper project if it's < 4.0, to work around ordering issues.  
+            // old-style solution wrapper project if it's < 4.0, to work around ordering issues.
             if (toolsVersion != null)
             {
                 if (
@@ -2261,7 +2261,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(
                        String.Equals(toolsVersion, "3.0", StringComparison.OrdinalIgnoreCase) ||
                        String.Equals(toolsVersion, "3.5", StringComparison.OrdinalIgnoreCase))
                 {
-                    // Spawn the Orcas SolutionWrapperProject generator.  
+                    // Spawn the Orcas SolutionWrapperProject generator.
                     loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedExplicitToolsVersion", toolsVersion);
                     projectInstances = GenerateSolutionWrapperUsingOldOM(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, buildParameters, loggingService, projectBuildEventContext, isExplicitlyLoaded, sdkResolverService, submissionId);
                 }
@@ -2272,7 +2272,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(
             }
 
             // If the user didn't pass in a ToolsVersion, still try to make a best-effort guess as to whether
-            // we should be generating a 4.0+ or a 3.5-style wrapper project based on the version of the solution. 
+            // we should be generating a 4.0+ or a 3.5-style wrapper project based on the version of the solution.
             else
             {
                 string solutionFile = projectFile;
@@ -2282,9 +2282,9 @@ internal static ProjectInstance[] LoadSolutionForBuild(
                 }
                 SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFile, out int solutionVersion, out int visualStudioVersion);
 
-                // If we get to this point, it's because it's a valid version.  Map the solution version 
-                // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old 
-                // engine to generate the solution wrapper.  
+                // If we get to this point, it's because it's a valid version.  Map the solution version
+                // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old
+                // engine to generate the solution wrapper.
                 if (solutionVersion <= 9) /* Whidbey or before */
                 {
                     loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedOldSolutionVersion", "2.0", solutionVersion);
@@ -2600,7 +2600,7 @@ private static ProjectInstance[] GenerateSolutionWrapperUsingOldOM(
             int submissionId)
         {
             // Pass the toolsVersion of this project through, which will never be null -- either we passed the /tv:nn
-            // switch straight through, or we fabricated a ToolsVersion based on the solution version.  
+            // switch straight through, or we fabricated a ToolsVersion based on the solution version.
             // It's needed to determine which <UsingTask> tags to put in, whether to put a ToolsVersion parameter
             // on the <MSBuild> task tags, and what MSBuildToolsPath to use when scanning child projects
             // for dependency information.
@@ -2771,7 +2771,7 @@ private void Initialize(
                 this.SubToolsetVersion = this.Toolset.GenerateSubToolsetVersionUsingVisualStudioVersion(globalProperties, visualStudioVersionFromSolution);
             }
 
-            // Create a task registry which will fall back on the toolset task registry if necessary.          
+            // Create a task registry which will fall back on the toolset task registry if necessary.
             this.TaskRegistry = new TaskRegistry(this.Toolset, ProjectRootElementCache);
 
             if (globalProperties != null)
@@ -2780,9 +2780,9 @@ private void Initialize(
                 {
                     if (String.Equals(globalProperty.Key, Constants.SubToolsetVersionPropertyName, StringComparison.OrdinalIgnoreCase) && explicitSubToolsetVersion != null)
                     {
-                        // if we have a sub-toolset version explicitly provided by the ProjectInstance constructor, AND a sub-toolset version provided as a global property, 
-                        // make sure that the one passed in with the constructor wins.  If there isn't a matching global property, the sub-toolset version will be set at 
-                        // a later point. 
+                        // if we have a sub-toolset version explicitly provided by the ProjectInstance constructor, AND a sub-toolset version provided as a global property,
+                        // make sure that the one passed in with the constructor wins.  If there isn't a matching global property, the sub-toolset version will be set at
+                        // a later point.
                         _globalProperties.Set(ProjectPropertyInstance.Create(globalProperty.Key, explicitSubToolsetVersion, false /* may not be reserved */, _isImmutable));
                     }
                     else
@@ -2996,7 +2996,7 @@ private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, b
 
             foreach (ProjectProperty property in properties)
             {
-                // Allow reserved property names, since this is how they are added to the project instance. 
+                // Allow reserved property names, since this is how they are added to the project instance.
                 // The caller has prevented users setting them themselves.
                 ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable, property.IsEnvironmentProperty);
                 _properties.Set(instance);
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index dc807f89574..9726d2de0d2 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -99,7 +99,7 @@ private ProjectMetadataInstance(ITranslator translator)
         /// Name of the metadata
         /// </summary>
         /// <remarks>
-        /// This cannot be set, as it is used as the key into 
+        /// This cannot be set, as it is used as the key into
         /// the item's metadata table.
         /// </remarks>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -111,7 +111,7 @@ public string Name
         }
 
         /// <summary>
-        /// Evaluated value of the metadatum. 
+        /// Evaluated value of the metadatum.
         /// Never null.
         /// </summary>
         public string EvaluatedValue
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index efcc5bbec16..9c2d9ed766e 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -29,7 +29,7 @@ public class ProjectPropertyInstance : IKeyed, IValued, IProperty, IEquatable<Pr
         private string _name;
 
         /// <summary>
-        /// Evaluated value: stored escaped. 
+        /// Evaluated value: stored escaped.
         /// </summary>
         private string _escapedValue;
 
@@ -46,7 +46,7 @@ private ProjectPropertyInstance(string name, string escapedValue)
         /// Name of the property
         /// </summary>
         /// <remarks>
-        /// This cannot be set, as it is used as the key into 
+        /// This cannot be set, as it is used as the key into
         /// the project's properties table.
         /// </remarks>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -163,7 +163,7 @@ public override string ToString()
         }
 
         /// <summary>
-        /// Called before the build when virtual properties are added, 
+        /// Called before the build when virtual properties are added,
         /// and during the build when tasks emit properties.
         /// If name is invalid or reserved, throws ArgumentException.
         /// Creates mutable object.
@@ -177,7 +177,7 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue)
         }
 
         /// <summary>
-        /// Called before the build when virtual properties are added, 
+        /// Called before the build when virtual properties are added,
         /// and during the build when tasks emit properties.
         /// If name is invalid or reserved, throws ArgumentException.
         /// Creates mutable object.
diff --git a/src/Build/Instance/ProjectTargetInstanceChild.cs b/src/Build/Instance/ProjectTargetInstanceChild.cs
index a44cf35b295..37434efd537 100644
--- a/src/Build/Instance/ProjectTargetInstanceChild.cs
+++ b/src/Build/Instance/ProjectTargetInstanceChild.cs
@@ -21,9 +21,9 @@ public abstract class ProjectTargetInstanceChild : ITranslatable
         public abstract string Condition { get; }
 
         /// <summary>
-        /// Full path to the file in which the originating element was originally 
+        /// Full path to the file in which the originating element was originally
         /// defined.
-        /// If it originated in a project that was not loaded and has never been 
+        /// If it originated in a project that was not loaded and has never been
         /// given a path, returns an empty string.
         /// </summary>
         public string FullPath
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 15bb1ebc0cc..616a99de8f3 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -55,16 +55,16 @@ internal class AssemblyTaskFactory : ITaskFactory2
         private IDictionary<string, string> _factoryIdentityParameters;
 
         /// <summary>
-        /// Tracks whether, in the UsingTask invocation, we were specifically asked to use 
-        /// the task host.  If so, that overrides all other concerns, and we will launch 
-        /// the task host even if the requested runtime / architecture match that of the 
-        /// current MSBuild process. 
+        /// Tracks whether, in the UsingTask invocation, we were specifically asked to use
+        /// the task host.  If so, that overrides all other concerns, and we will launch
+        /// the task host even if the requested runtime / architecture match that of the
+        /// current MSBuild process.
         /// </summary>
         private bool _taskHostFactoryExplicitlyRequested;
 
         /// <summary>
-        /// Need to store away the taskloggingcontext used by CreateTaskInstance so that 
-        /// TaskLoader will be able to call back with errors.  
+        /// Need to store away the taskloggingcontext used by CreateTaskInstance so that
+        /// TaskLoader will be able to call back with errors.
         /// </summary>
         private TaskLoggingContext _taskLoggingContext;
 
@@ -123,16 +123,16 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> pa
         /// Initializes this factory for instantiating tasks with a particular inline task block and a set of UsingTask parameters.
         /// </summary>
         /// <param name="taskName">Name of the task.</param>
-        /// <param name="factoryIdentityParameters">Special parameters that the task factory can use to modify how it executes tasks, 
-        /// such as Runtime and Architecture.  The key is the name of the parameter and the value is the parameter's value. This 
+        /// <param name="factoryIdentityParameters">Special parameters that the task factory can use to modify how it executes tasks,
+        /// such as Runtime and Architecture.  The key is the name of the parameter and the value is the parameter's value. This
         /// is the set of parameters that was set on the UsingTask using e.g. the UsingTask Runtime and Architecture parameters.</param>
         /// <param name="parameterGroup">The parameter group.</param>
         /// <param name="taskBody">The task body.</param>
         /// <param name="taskFactoryLoggingHost">The task factory logging host.</param>
         /// <returns>A value indicating whether initialization was successful.</returns>
         /// <remarks>
-        /// <para>MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the 
-        /// factory can be asked whether or not task names can be created by the factory.  If a task factory implements ITaskFactory2, 
+        /// <para>MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the
+        /// factory can be asked whether or not task names can be created by the factory.  If a task factory implements ITaskFactory2,
         /// this Initialize method will be called in place of ITaskFactory.Initialize.</para>
         /// <para>
         /// The taskFactoryLoggingHost will log messages in the context of the target where the task is first used.
@@ -175,12 +175,12 @@ public ITask CreateTask(IBuildEngine taskFactoryLoggingHost)
         /// The task factory logging host will log messages in the context of the task.
         /// </param>
         /// <param name="taskIdentityParameters">
-        /// Special parameters that the task factory can use to modify how it executes tasks, such as Runtime and Architecture.  
-        /// The key is the name of the parameter and the value is the parameter's value.  This is the set of parameters that was 
-        /// set to the task invocation itself, via e.g. the special MSBuildRuntime and MSBuildArchitecture parameters.  
+        /// Special parameters that the task factory can use to modify how it executes tasks, such as Runtime and Architecture.
+        /// The key is the name of the parameter and the value is the parameter's value.  This is the set of parameters that was
+        /// set to the task invocation itself, via e.g. the special MSBuildRuntime and MSBuildArchitecture parameters.
         /// </param>
         /// <remarks>
-        /// If a task factory implements ITaskFactory2, MSBuild will call this method instead of ITaskFactory.CreateTask.  
+        /// If a task factory implements ITaskFactory2, MSBuild will call this method instead of ITaskFactory.CreateTask.
         /// </remarks>
         /// <returns>
         /// The generated task, or <c>null</c> if the task failed to be created.
@@ -323,10 +323,10 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
             IDictionary<string, string> mergedParameters = null;
             _taskLoggingContext = taskLoggingContext;
 
-            // Optimization for the common (vanilla AssemblyTaskFactory) case -- only calculate 
-            // the task factory parameters if we have any to calculate; otherwise even if we 
-            // still launch the task factory, it will be with parameters corresponding to the 
-            // current process. 
+            // Optimization for the common (vanilla AssemblyTaskFactory) case -- only calculate
+            // the task factory parameters if we have any to calculate; otherwise even if we
+            // still launch the task factory, it will be with parameters corresponding to the
+            // current process.
             if ((_factoryIdentityParameters?.Count > 0) || (taskIdentityParameters?.Count > 0))
             {
                 VerifyThrowIdentityParametersValid(taskIdentityParameters, taskLocation, _taskName, "MSBuildRuntime", "MSBuildArchitecture");
@@ -338,9 +338,9 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
             }
             else
             {
-                // if we don't have any task host parameters specified on either the using task or the 
+                // if we don't have any task host parameters specified on either the using task or the
                 // task invocation, then we will run in-proc UNLESS "TaskHostFactory" is explicitly specified
-                // as the task factory.  
+                // as the task factory.
                 useTaskFactory = _taskHostFactoryExplicitlyRequested;
             }
 
@@ -415,8 +415,8 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
         }
 
         /// <summary>
-        /// Is the given task name able to be created by the task factory. In the case of an assembly task factory 
-        /// this question is answered by checking the assembly wrapped by the task factory to see if it exists. 
+        /// Is the given task name able to be created by the task factory. In the case of an assembly task factory
+        /// this question is answered by checking the assembly wrapped by the task factory to see if it exists.
         /// </summary>
         internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, string> taskIdentityParameters, string taskProjectFile, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)
         {
@@ -428,7 +428,7 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
             try
             {
                 ErrorUtilities.VerifyThrowArgumentLength(taskName, "TaskName");
-                // Parameters match, so now we check to see if the task exists. 
+                // Parameters match, so now we check to see if the task exists.
                 return _typeLoader.ReflectionOnlyLoad(taskName, _loadedType.Assembly) != null;
             }
             catch (TargetInvocationException e)
@@ -468,7 +468,7 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
         #region Private members
 
         /// <summary>
-        /// Validates the given set of parameters, logging the appropriate errors as necessary. 
+        /// Validates the given set of parameters, logging the appropriate errors as necessary.
         /// </summary>
         private static void VerifyThrowIdentityParametersValid(IDictionary<string, string> identityParameters, IElementLocation errorLocation, string taskName, string runtimeName, string architectureName)
         {
@@ -514,14 +514,14 @@ private static void VerifyThrowIdentityParametersValid(IDictionary<string, strin
         }
 
         /// <summary>
-        /// Given the set of parameters that are set to the factory, and the set of parameters coming from the task invocation that we're searching for 
-        /// a matching record to, determine whether the parameters match this record.  
+        /// Given the set of parameters that are set to the factory, and the set of parameters coming from the task invocation that we're searching for
+        /// a matching record to, determine whether the parameters match this record.
         /// </summary>
         private static bool TaskIdentityParametersMatchFactory(IDictionary<string, string> factoryIdentityParameters, IDictionary<string, string> taskIdentityParameters)
         {
             if (taskIdentityParameters == null || taskIdentityParameters.Count == 0 || factoryIdentityParameters == null || factoryIdentityParameters.Count == 0)
             {
-                // either the task or the using task doesn't care about anything, in which case we match by default.  
+                // either the task or the using task doesn't care about anything, in which case we match by default.
                 return true;
             }
 
@@ -544,7 +544,7 @@ private static bool TaskIdentityParametersMatchFactory(IDictionary<string, strin
                 }
             }
 
-            // one or more does not match, so we don't match.  
+            // one or more does not match, so we don't match.
             return false;
         }
 
@@ -607,14 +607,14 @@ private static IDictionary<string, string> MergeTaskFactoryParameterSets(IDictio
         }
 
         /// <summary>
-        /// Returns true if the provided set of task host parameters matches the current process, 
-        /// and false otherwise. 
+        /// Returns true if the provided set of task host parameters matches the current process,
+        /// and false otherwise.
         /// </summary>
         private static bool TaskHostParametersMatchCurrentProcess(IDictionary<string, string> mergedParameters)
         {
             if (mergedParameters == null || mergedParameters.Count == 0)
             {
-                // We don't care, so they match by default. 
+                // We don't care, so they match by default.
                 return true;
             }
 
@@ -647,7 +647,7 @@ private static bool TaskHostParametersMatchCurrentProcess(IDictionary<string, st
         }
 
         /// <summary>
-        /// Log errors from TaskLoader. 
+        /// Log errors from TaskLoader.
         /// </summary>
         private void ErrorLoggingDelegate(string taskLocation, int taskLine, int taskColumn, string message, params object[] messageArgs)
         {
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 09bbe0eb985..20f381dda93 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -20,35 +20,35 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// The wrapper task for tasks that wish to take advantage of the 
+    /// The wrapper task for tasks that wish to take advantage of the
     /// task host factory feature.  Generated by AssemblyTaskFactory
-    /// when it wants to run the loaded task in the task host. 
+    /// when it wants to run the loaded task in the task host.
     /// </summary>
     internal class TaskHostTask : IGeneratedTask, ICancelableTask, INodePacketFactory, INodePacketHandler
     {
         /// <summary>
-        /// The IBuildEngine callback object.  
+        /// The IBuildEngine callback object.
         /// </summary>
         private IBuildEngine _buildEngine;
 
         /// <summary>
-        /// The host object that can be passed to this task.  
+        /// The host object that can be passed to this task.
         /// </summary>
         private ITaskHost _hostObject;
 
         /// <summary>
-        /// Logging context for logging errors / issues 
-        /// encountered in the TaskHostTask itself. 
+        /// Logging context for logging errors / issues
+        /// encountered in the TaskHostTask itself.
         /// </summary>
         private TaskLoggingContext _taskLoggingContext;
 
         /// <summary>
-        /// Location of the task in the project file. 
+        /// Location of the task in the project file.
         /// </summary>
         private IElementLocation _taskLocation;
 
         /// <summary>
-        ///  The provider for the task host nodes. 
+        ///  The provider for the task host nodes.
         /// </summary>
         private IBuildComponentHost _buildComponentHost;
 
@@ -68,57 +68,57 @@ internal class TaskHostTask : IGeneratedTask, ICancelableTask, INodePacketFactor
         private ConcurrentQueue<INodePacket> _receivedPackets;
 
         /// <summary>
-        /// The set of parameters used to decide which host to launch.  
+        /// The set of parameters used to decide which host to launch.
         /// </summary>
         private IDictionary<string, string> _taskHostParameters;
 
         /// <summary>
-        /// The type of the task that we are wrapping.  
+        /// The type of the task that we are wrapping.
         /// </summary>
         private LoadedType _taskType;
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// The AppDomainSetup we'll want to apply to the AppDomain that we may 
-        /// want to load the OOP task into. 
+        /// The AppDomainSetup we'll want to apply to the AppDomain that we may
+        /// want to load the OOP task into.
         /// </summary>
         private AppDomainSetup _appDomainSetup;
 #endif
 
         /// <summary>
-        /// The task host context of the task host we're launching -- used to 
-        /// communicate with the task host. 
+        /// The task host context of the task host we're launching -- used to
+        /// communicate with the task host.
         /// </summary>
         private HandshakeOptions _requiredContext = HandshakeOptions.None;
 
         /// <summary>
-        /// True if currently connected to the task host; false otherwise. 
+        /// True if currently connected to the task host; false otherwise.
         /// </summary>
         private bool _connectedToTaskHost = false;
 
         /// <summary>
-        /// The provider for task host nodes. 
+        /// The provider for task host nodes.
         /// </summary>
         private NodeProviderOutOfProcTaskHost _taskHostProvider;
 
         /// <summary>
-        /// Lock object to serialize access to the task host. 
+        /// Lock object to serialize access to the task host.
         /// </summary>
         private Object _taskHostLock;
 
         /// <summary>
-        /// Keeps track of whether the wrapped task has had cancel called against it. 
+        /// Keeps track of whether the wrapped task has had cancel called against it.
         /// </summary>
         private bool _taskCancelled;
 
         /// <summary>
-        /// The set of parameters that has been set to this wrapped task -- save them 
-        /// here so that we can forward them on to the task host. 
+        /// The set of parameters that has been set to this wrapped task -- save them
+        /// here so that we can forward them on to the task host.
         /// </summary>
         private IDictionary<string, object> _setParameters;
 
         /// <summary>
-        /// Did the task succeed? 
+        /// Did the task succeed?
         /// </summary>
         private bool _taskExecutionSucceeded = false;
 
@@ -180,7 +180,7 @@ public IBuildEngine BuildEngine
         }
 
         /// <summary>
-        /// The host object that can be passed to this task.  
+        /// The host object that can be passed to this task.
         /// </summary>
         public ITaskHost HostObject
         {
@@ -196,7 +196,7 @@ public ITaskHost HostObject
         }
 
         /// <summary>
-        /// Sets the requested task parameter to the requested value. 
+        /// Sets the requested task parameter to the requested value.
         /// </summary>
         public void SetPropertyValue(TaskPropertyInfo property, object value)
         {
@@ -210,8 +210,8 @@ public object GetPropertyValue(TaskPropertyInfo property)
         {
             if (_setParameters.TryGetValue(property.Name, out object value))
             {
-                // If we returned an exception, then we want to throw it when we 
-                // do the get.  
+                // If we returned an exception, then we want to throw it when we
+                // do the get.
                 if (value is Exception ex)
                 {
                     throw ex;
@@ -395,16 +395,16 @@ public void PacketReceived(int node, INodePacket packet)
         }
 
         /// <summary>
-        /// Called by TaskHostFactory to let the task know that if it needs to do any additional cleanup steps, 
-        /// now would be the time.  
+        /// Called by TaskHostFactory to let the task know that if it needs to do any additional cleanup steps,
+        /// now would be the time.
         /// </summary>
         internal void Cleanup()
         {
-            // for now, do nothing. 
+            // for now, do nothing.
         }
 
         /// <summary>
-        /// Handles the packets received from the task host. 
+        /// Handles the packets received from the task host.
         /// </summary>
         private void HandlePacket(INodePacket packet, out bool taskFinished)
         {
@@ -446,14 +446,14 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
             }
 #endif
 
-            // If it crashed, or if it failed, it didn't succeed.   
+            // If it crashed, or if it failed, it didn't succeed.
             _taskExecutionSucceeded = taskHostTaskComplete.TaskResult == TaskCompleteType.Success ? true : false;
 
             // reset the environment, as though the task were executed in this process all along.
             CommunicationsUtilities.SetEnvironment(taskHostTaskComplete.BuildProcessEnvironment);
 
-            // If it crashed during the execution phase, then we can effectively replicate the inproc task execution 
-            // behaviour by just throwing here and letting the taskbuilder code take care of it the way it would 
+            // If it crashed during the execution phase, then we can effectively replicate the inproc task execution
+            // behaviour by just throwing here and letting the taskbuilder code take care of it the way it would
             // have normally.
             // We will also replicate the same behaviour if the TaskHost caught some exceptions after execution of the task.
             if ((taskHostTaskComplete.TaskResult == TaskCompleteType.CrashedDuringExecution) ||
@@ -463,14 +463,14 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
             }
 
             // On the other hand, if it crashed during initialization, there's not really a way to effectively replicate
-            // the inproc behavior -- in the inproc case, the task would have failed to load and crashed long before now.  
-            // Furthermore, if we were just to throw here like in the execution case, we'd lose the ability to log 
-            // different messages based on the circumstances of the initialization failure -- whether it was a setter failure, 
-            // the task just could not be loaded, etc.  
-
-            // So instead, when we catch the exception in the task host, we'll also record what message we want it to use 
-            // when the error is logged; and given that information, log that error here.  This has the effect of differing 
-            // from the inproc case insofar as ContinueOnError is now respected, instead of forcing a stop here.  
+            // the inproc behavior -- in the inproc case, the task would have failed to load and crashed long before now.
+            // Furthermore, if we were just to throw here like in the execution case, we'd lose the ability to log
+            // different messages based on the circumstances of the initialization failure -- whether it was a setter failure,
+            // the task just could not be loaded, etc.
+
+            // So instead, when we catch the exception in the task host, we'll also record what message we want it to use
+            // when the error is logged; and given that information, log that error here.  This has the effect of differing
+            // from the inproc case insofar as ContinueOnError is now respected, instead of forcing a stop here.
             if (taskHostTaskComplete.TaskResult == TaskCompleteType.CrashedDuringInitialization)
             {
                 string exceptionMessage;
@@ -499,14 +499,14 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
         }
 
         /// <summary>
-        /// The task host node failed for some reason 
+        /// The task host node failed for some reason
         /// </summary>
         private void HandleNodeShutdown(NodeShutdown nodeShutdown)
         {
-            // if the task was canceled, it may send the shutdown packet before the task itself has exited -- 
-            // in this case, the shutdown is expected, so don't log errors.  Also don't update taskExecutionSucceeded, 
-            // as it has already been set properly (likely also to false) when we dealt with the TaskComplete 
-            // packet that was sent immediately prior to this.  
+            // if the task was canceled, it may send the shutdown packet before the task itself has exited --
+            // in this case, the shutdown is expected, so don't log errors.  Also don't update taskExecutionSucceeded,
+            // as it has already been set properly (likely also to false) when we dealt with the TaskComplete
+            // packet that was sent immediately prior to this.
             if (!_taskCancelled)
             {
                 // nothing much else to say.
@@ -536,8 +536,8 @@ private void HandleLoggedMessage(LogMessagePacket logMessagePacket)
                 case LoggingEventType.CustomEvent:
                     BuildEventArgs buildEvent = logMessagePacket.NodeBuildEvent.Value.Value;
 
-                    // "Custom events" in terms of the communications infrastructure can also be, e.g. custom error events, 
-                    // in which case they need to be dealt with in the same way as their base type of event. 
+                    // "Custom events" in terms of the communications infrastructure can also be, e.g. custom error events,
+                    // in which case they need to be dealt with in the same way as their base type of event.
                     if (buildEvent is BuildErrorEventArgs buildErrorEventArgs)
                     {
                         this.BuildEngine.LogErrorEvent(buildErrorEventArgs);
@@ -565,12 +565,12 @@ private void HandleLoggedMessage(LogMessagePacket logMessagePacket)
 
         /// <summary>
         /// Since we log that we weren't able to connect to the task host in a couple of different places,
-        /// extract it out into a separate method. 
+        /// extract it out into a separate method.
         /// </summary>
         private void LogErrorUnableToCreateTaskHost(HandshakeOptions requiredContext, string runtime, string architecture, NodeFailedToLaunchException e)
         {
             string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext) ??
-                // We don't know the path -- probably we're trying to get a 64-bit assembly on a 
+                // We don't know the path -- probably we're trying to get a 64-bit assembly on a
                 // 32-bit machine.  At least give them the exe name to look for, though ...
                 ((requiredContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2 ? "MSBuildTaskHost.exe" : "MSBuild.exe");
 
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 25c8c79067b..1fbad6a47b6 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -157,8 +157,8 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
-            // If we are in building across process we need the events to be serializable. This method will 
-            // check to see if we are building with multiple process and if the event is serializable. It will 
+            // If we are in building across process we need the events to be serializable. This method will
+            // check to see if we are building with multiple process and if the event is serializable. It will
             // also log a warning if the event is not serializable and drop the logging message.
             if (IsRunningMultipleNodes && !IsEventSerializable(e))
             {
@@ -178,8 +178,8 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
-            // If we are in building across process we need the events to be serializable. This method will 
-            // check to see if we are building with multiple process and if the event is serializable. It will 
+            // If we are in building across process we need the events to be serializable. This method will
+            // check to see if we are building with multiple process and if the event is serializable. It will
             // also log a warning if the event is not serializable and drop the logging message.
             if (IsRunningMultipleNodes && !IsEventSerializable(e))
             {
@@ -199,8 +199,8 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
-            // If we are in building across process we need the events to be serializable. This method will 
-            // check to see if we are building with multiple process and if the event is serializable. It will 
+            // If we are in building across process we need the events to be serializable. This method will
+            // check to see if we are building with multiple process and if the event is serializable. It will
             // also log a warning if the event is not serializable and drop the logging message.
             if (IsRunningMultipleNodes && !IsEventSerializable(e))
             {
@@ -220,8 +220,8 @@ public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
-            // If we are in building across process we need the events to be serializable. This method will 
-            // check to see if we are building with multiple process and if the event is serializable. It will 
+            // If we are in building across process we need the events to be serializable. This method will
+            // check to see if we are building with multiple process and if the event is serializable. It will
             // also log a warning if the event is not serializable and drop the logging message.
             if (IsRunningMultipleNodes && !IsEventSerializable(e))
             {
@@ -262,7 +262,7 @@ public override object InitializeLifetimeService()
             ILease lease = (ILease)base.InitializeLifetimeService();
 
             // Set how long a lease should be initially. Once a lease expires
-            // the remote object will be disconnected and it will be marked as being availiable 
+            // the remote object will be disconnected and it will be marked as being availiable
             // for garbage collection
             int initialLeaseTime = 1;
 
@@ -284,7 +284,7 @@ public override object InitializeLifetimeService()
             // increase the lease time allowing the object to stay in memory
             _sponsor = new ClientSponsor();
 
-            // When a new lease is requested lets make it last 1 minutes longer. 
+            // When a new lease is requested lets make it last 1 minutes longer.
             int leaseExtensionTime = 1;
 
             string leaseExtensionTimeFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDENGINEPROXYLEASEEXTENSIONTIME");
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index 4f7d6eb4f01..6a6f117d129 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -68,7 +68,7 @@ public PropertyData(
         private string _taskName;
 
         /// <summary>
-        /// The set of special parameters that, along with the name, contribute to the identity of 
+        /// The set of special parameters that, along with the name, contribute to the identity of
         /// this factory.
         /// </summary>
         private IDictionary<string, string> _factoryIdentityParameters;
@@ -153,8 +153,8 @@ public string Name
         }
 
         /// <summary>
-        /// The set of task identity parameters that were set on 
-        /// this particular factory's UsingTask statement. 
+        /// The set of task identity parameters that were set on
+        /// this particular factory's UsingTask statement.
         /// </summary>
         public IDictionary<string, string> FactoryIdentityParameters
         {
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 3627688d174..5b65829e926 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -375,11 +375,11 @@ private static void RegisterTasksFromUsingTaskElement
 
                 if (String.Equals(taskFactory, RegisteredTaskRecord.CodeTaskFactory, StringComparison.OrdinalIgnoreCase) || String.Equals(taskFactory, RegisteredTaskRecord.XamlTaskFactory, StringComparison.OrdinalIgnoreCase))
                 {
-                    // SHIM: One common pattern for people using CodeTaskFactory or XamlTaskFactory from M.B.T.v4.0.dll is to 
+                    // SHIM: One common pattern for people using CodeTaskFactory or XamlTaskFactory from M.B.T.v4.0.dll is to
                     // specify it using $(MSBuildToolsPath) -- which now no longer contains M.B.T.v4.0.dll.  This same pattern
-                    // may also occur if someone is using CodeTaskFactory or XamlTaskFactory from M.B.T.v12.0.dll.  So if we have a 
-                    // situation where the path being used doesn't contain the v4 or v12 tasks but DOES contain the v14+ tasks, just 
-                    // secretly substitute it here. 
+                    // may also occur if someone is using CodeTaskFactory or XamlTaskFactory from M.B.T.v12.0.dll.  So if we have a
+                    // situation where the path being used doesn't contain the v4 or v12 tasks but DOES contain the v14+ tasks, just
+                    // secretly substitute it here.
                     if (
                             assemblyFile != null &&
                             (assemblyFile.EndsWith(s_tasksV4Filename, StringComparison.OrdinalIgnoreCase) || assemblyFile.EndsWith(s_tasksV12Filename, StringComparison.OrdinalIgnoreCase)) &&
@@ -394,10 +394,10 @@ private static void RegisterTasksFromUsingTaskElement
                     }
                     else if (assemblyName != null)
                     {
-                        // SHIM: Another common pattern for people using CodeTaskFactory or XamlTaskFactory from 
-                        // M.B.T.v4.0.dll is to specify it using AssemblyName with a simple name -- which works only if that 
-                        // that assembly is in the current directory.  Much like with the above case, if we detect that 
-                        // situation, secretly substitute it here so that the majority of task factory users aren't broken. 
+                        // SHIM: Another common pattern for people using CodeTaskFactory or XamlTaskFactory from
+                        // M.B.T.v4.0.dll is to specify it using AssemblyName with a simple name -- which works only if that
+                        // that assembly is in the current directory.  Much like with the above case, if we detect that
+                        // situation, secretly substitute it here so that the majority of task factory users aren't broken.
                         if
                             (
                                 assemblyName.Equals(s_tasksV4SimpleName, StringComparison.OrdinalIgnoreCase) &&
@@ -577,9 +577,9 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
                             // otherwise, check the "short list" of everything else included here to see if one of them matches
                             foreach (RegisteredTaskRecord record in taskRecords.Values)
                             {
-                                // Just return the first one that actually matches.  There may be nulls in here as well, if we've previously attempted to 
-                                // find a variation on this task record and failed.  In that case, since it wasn't an exact match (otherwise it would have 
-                                // been picked up by the check above) just ignore it, the way we ignore task records that don't work with this set of 
+                                // Just return the first one that actually matches.  There may be nulls in here as well, if we've previously attempted to
+                                // find a variation on this task record and failed.  In that case, since it wasn't an exact match (otherwise it would have
+                                // been picked up by the check above) just ignore it, the way we ignore task records that don't work with this set of
                                 // parameters.
                                 if (record != null)
                                 {
@@ -592,7 +592,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
                             }
                         }
 
-                        // otherwise, nothing fit, so act like we never hit the cache at all.  
+                        // otherwise, nothing fit, so act like we never hit the cache at all.
                     }
                 }
 
@@ -618,19 +618,19 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             else
             {
                 // Since this is a fuzzy match, we could conceivably have several sets of task identity parameters that match
-                // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.  
+                // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.
                 //
-                // To prevent us inadvertently leaking something incompatible, in this case, we need to store not just the 
-                // record that we got this time, but ALL of the records that have previously matched this key.  
-                // 
-                // Furthermore, the first level key needs to be the name of the task, not its identity -- otherwise we might 
-                // end up with multiple entries containing subsets of the same fuzzy-matchable tasks.  E.g. with the following 
-                // set of steps: 
+                // To prevent us inadvertently leaking something incompatible, in this case, we need to store not just the
+                // record that we got this time, but ALL of the records that have previously matched this key.
+                //
+                // Furthermore, the first level key needs to be the name of the task, not its identity -- otherwise we might
+                // end up with multiple entries containing subsets of the same fuzzy-matchable tasks.  E.g. with the following
+                // set of steps:
                 // 1. Look up Foo | bar
-                // 2. Look up Foo | * (goes into Foo | bar cache entry) 
+                // 2. Look up Foo | * (goes into Foo | bar cache entry)
                 // 3. Look up Foo | baz (gets its own entry because it doesn't match Foo | bar)
-                // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up 
-                //    first, might get Foo | baz, which also matches, instead) 
+                // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up
+                //    first, might get Foo | baz, which also matches, instead)
                 ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords
                     = _cachedTaskRecordsWithFuzzyMatch.GetOrAdd(taskIdentity.Name,
                         _ => new(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));
@@ -916,7 +916,7 @@ public bool Equals(RegisteredTaskIdentity x, RegisteredTaskIdentity y)
                         return false;
                     }
 
-                    // have to have the same name 
+                    // have to have the same name
                     if (String.Equals(x.Name, y.Name, StringComparison.OrdinalIgnoreCase))
                     {
                         return IdentityParametersMatch(x.TaskIdentityParameters, y.TaskIdentityParameters, _exactMatchRequired);
@@ -939,9 +939,9 @@ public int GetHashCode(RegisteredTaskIdentity obj)
 
                     int nameHash = String.IsNullOrEmpty(obj.Name) ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(obj.Name);
 
-                    // Since equality for the exact comparer depends on the exact values of the parameters, 
-                    // we need our hash code to depend on them as well. However, for fuzzy matches, we just 
-                    // need the ultimate meaning of the parameters to be the same. 
+                    // Since equality for the exact comparer depends on the exact values of the parameters,
+                    // we need our hash code to depend on them as well. However, for fuzzy matches, we just
+                    // need the ultimate meaning of the parameters to be the same.
                     string runtime = null;
                     string architecture = null;
 
@@ -961,12 +961,12 @@ public int GetHashCode(RegisteredTaskIdentity obj)
                     }
                     else
                     {
-                        // Ideally, we'd like a hash code that returns the same thing for any runtime or 
-                        // architecture that is counted as a match in Runtime/ArchitectureValuesMatch.  
-                        // But since we can't really know that without having someone to compare against, 
-                        // in this case just give up and don't try to factor the runtime / architecture 
-                        // in, and take the minor hit of having more matching hash codes than we would 
-                        // have otherwise. 
+                        // Ideally, we'd like a hash code that returns the same thing for any runtime or
+                        // architecture that is counted as a match in Runtime/ArchitectureValuesMatch.
+                        // But since we can't really know that without having someone to compare against,
+                        // in this case just give up and don't try to factor the runtime / architecture
+                        // in, and take the minor hit of having more matching hash codes than we would
+                        // have otherwise.
                         paramHash = 0;
                     }
 
@@ -997,7 +997,7 @@ private static bool IdentityParametersMatch(IDictionary<string, string> x, IDict
                             return false;
                         }
 
-                        // make sure that each parameter value matches as well 
+                        // make sure that each parameter value matches as well
                         foreach (KeyValuePair<string, string> param in x)
                         {
                             string value;
@@ -1034,7 +1034,7 @@ private static bool IdentityParametersMatch(IDictionary<string, string> x, IDict
                             y.TryGetValue(XMakeAttributes.architecture, out architectureY);
                         }
 
-                        // null is OK -- it's treated as a "don't care" 
+                        // null is OK -- it's treated as a "don't care"
                         if (!XMakeAttributes.RuntimeValuesMatch(runtimeX, runtimeY))
                         {
                             return false;
@@ -1046,7 +1046,7 @@ private static bool IdentityParametersMatch(IDictionary<string, string> x, IDict
                         }
                     }
 
-                    // if we didn't return before now, all parameters were found and matched.  
+                    // if we didn't return before now, all parameters were found and matched.
                     return true;
                 }
             }
@@ -1292,7 +1292,7 @@ internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile,
                             if (TaskFactoryAttributeName == AssemblyTaskFactory || TaskFactoryAttributeName == TaskHostFactory)
                             {
                                 // Also we only need to check to see if the task name can be created by the factory if the taskName does not equal the Registered name
-                                // and the identity parameters don't match the factory's declared parameters. 
+                                // and the identity parameters don't match the factory's declared parameters.
                                 // This is because when the task factory is instantiated we try and load the Registered name from the task factory and fail it it cannot be loaded
                                 // therefore the fact that we have a factory means the Registered type and parameters can be created by the factory.
                                 if (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Fuzzy.Equals(this.TaskIdentity, taskIdentity))
@@ -1399,7 +1399,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                     }
                     else
                     {
-                        // We are not one of the default factories. 
+                        // We are not one of the default factories.
                         TaskEngineAssemblyResolver resolver = null;
 
                         try
@@ -1424,7 +1424,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
 
                                 if (loadedType == null)
                                 {
-                                    // We could not find the type (this is what null means from the Load method) but there is no reason given so we can only log the fact that 
+                                    // We could not find the type (this is what null means from the Load method) but there is no reason given so we can only log the fact that
                                     // we could not find the name given in the task factory attribute in the class specified in the assembly File or assemblyName fields.
                                     ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CouldNotFindFactory", TaskFactoryAttributeName, taskFactoryLoadInfo.AssemblyLocation);
                                 }
@@ -1701,7 +1701,7 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                         if (expandedType.StartsWith("Microsoft.Build.Framework.", StringComparison.OrdinalIgnoreCase) && !expandedType.Contains(","))
                         {
                             // This is workaround for internal bug https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1448821
-                            // Visual Studio can load different version of Microsoft.Build.Framework.dll and non fully classified type could be resolved from it 
+                            // Visual Studio can load different version of Microsoft.Build.Framework.dll and non fully classified type could be resolved from it
                             // which cause InvalidProjectFileException with "UnsupportedTaskParameterTypeError" message.
                             // Another way to address this is to load types from compiled assembly - that would be more robust solution but also much more complex and risky code changes.
                             paramType = Type.GetType(expandedType + "," + typeof(ITaskItem).GetTypeInfo().Assembly.FullName, false /* don't throw on error */, true /* case-insensitive */) ??
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index f4143ccaae7..96942d03d55 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -1285,7 +1285,7 @@ StringBuilder IStringBuilderProvider.Acquire(int capacity)
 
             // Prepare for next use.
             // Equivalent of sb.Clear() that works on .Net 3.5
-            shared.Length = 0; 
+            shared.Length = 0;
 
             return shared;
         }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 6c4e32345fb..a935708e681 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Logging
     /// <remarks>The logger is public so that it can be instantiated from MSBuild.exe via command-line switch.</remarks>
     public sealed class BinaryLogger : ILogger
     {
-        // version 2: 
+        // version 2:
         //   - new BuildEventContext.EvaluationId
         //   - new record kinds: ProjectEvaluationStarted, ProjectEvaluationFinished
         // version 3:
@@ -110,7 +110,7 @@ public enum ProjectImportsCollectionMode
         public LoggerVerbosity Verbosity { get; set; } = LoggerVerbosity.Diagnostic;
 
         /// <summary>
-        /// Gets or sets the parameters. The only supported parameter is the output log file path (for example, "msbuild.binlog"). 
+        /// Gets or sets the parameters. The only supported parameter is the output log file path (for example, "msbuild.binlog").
         /// </summary>
         public string Parameters { get; set; }
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 6c5ccd717d6..3c3e2a2faee 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -647,7 +647,7 @@ private BuildEventArgs ReadBuildErrorEventArgs()
                 };
             }
             e.BuildEventContext = fields.BuildEventContext;
-                
+
             return e;
         }
 
@@ -1573,7 +1573,7 @@ public void Dispose()
                 }
                 catch
                 {
-                    // The StringStorage class is not crucial for other functionality and if 
+                    // The StringStorage class is not crucial for other functionality and if
                     // there are exceptions when closing the temp file, it's too late to do anything about it.
                     // Since we don't want to disrupt anything and the file is in the TEMP directory, it will
                     // get cleaned up at some point anyway.
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index 136b0c94d7f..35886babcca 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -38,8 +38,8 @@ namespace Microsoft.Build.Logging
 
     /// <summary>
     /// This class implements the default logger that outputs event data
-    /// to the console (stdout). 
-    /// It is a facade: it creates, wraps and delegates to a kind of BaseConsoleLogger, 
+    /// to the console (stdout).
+    /// It is a facade: it creates, wraps and delegates to a kind of BaseConsoleLogger,
     /// either SerialConsoleLogger or ParallelConsoleLogger.
     /// </summary>
     /// <remarks>This class is not thread safe.</remarks>
@@ -329,7 +329,7 @@ protected WriteHandler WriteHandler
 
         /// <summary>
         /// Apply a parameter.
-        /// NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has 
+        /// NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has
         /// no good reason for being public.
         /// </summary>
         public void ApplyParameter(string parameterName, string parameterValue)
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index 7f90d035fd6..21271e12fb0 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -215,7 +215,7 @@ public string Parameters
         #region Data
         // The file logger which will do the actual logging of the node's build output
         private FileLogger _nodeFileLogger;
-        // Reference for the central logger 
+        // Reference for the central logger
         private IEventRedirector _buildEventRedirector;
         // The Id of the node the forwardingLogger is attached to
         private int _nodeId;
diff --git a/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs b/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
index 85824638836..d557bf890d2 100644
--- a/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
+++ b/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Logging
 {
     /// <summary>
-    /// Comparer for <see cref="EvaluationLocation"/> that ignores 
+    /// Comparer for <see cref="EvaluationLocation"/> that ignores
     /// both <see cref="EvaluationLocation.Id"/> and <see cref="EvaluationLocation.ParentId"/>
     /// </summary>
     internal class EvaluationLocationIdAgnosticComparer : IEqualityComparer<EvaluationLocation>
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index bd0abc891b9..f325ea36d27 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Logging
 {
     /// <summary>
     /// A specialization of the ConsoleLogger that logs to a file instead of the console.
-    /// The output in terms of what is written and how it looks is identical. For example you can 
+    /// The output in terms of what is written and how it looks is identical. For example you can
     /// log verbosely to a file using the FileLogger while simultaneously logging only high priority events
     /// to the console using a ConsoleLogger.
     /// </summary>
diff --git a/src/Build/Logging/LogFormatter.cs b/src/Build/Logging/LogFormatter.cs
index 280feeedc1f..b03391a34a1 100644
--- a/src/Build/Logging/LogFormatter.cs
+++ b/src/Build/Logging/LogFormatter.cs
@@ -20,7 +20,7 @@ internal static class LogFormatter
         internal static string FormatLogTimeStamp(DateTime timeStamp)
         {
             // From http://msdn2.microsoft.com/en-us/library/8kb3ddd4.aspx
-            // Custom DateTime Format Strings  
+            // Custom DateTime Format Strings
             //
             // HH Represents the hour as a number from 00 through 23, that is,
             //    the hour as represented by a zero-based 24-hour clock that counts the hours since midnight.
diff --git a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
index 63e8f26bbe3..876227f72f9 100644
--- a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
+++ b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
@@ -38,7 +38,7 @@ public ConsoleOutputAligner(int bufferWidth, bool alignMessages, IStringBuilderP
 
         /// <summary>
         /// Based on bufferWidth split message into multiple lines and indent if needed.
-        /// TAB character are interpreted by standard Console logic. 
+        /// TAB character are interpreted by standard Console logic.
         /// </summary>
         /// <param name="message">Input message. May contains tabs and new lines. Both \r\n and \n is supported but replaced into current environment new line.</param>
         /// <param name="prefixAlreadyWritten">true if message already contains prefix (message context, timestamp, etc...).</param>
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index d8d1dce3a34..280d61a3bad 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -181,7 +181,7 @@ private void ShownBuildEventContext(BuildEventContext e)
 
         /// <summary>
         /// Reset the states of per-build member variables
-        /// VSW#516376 
+        /// VSW#516376
         /// </summary>
         internal override void ResetConsoleLoggerState()
         {
@@ -339,7 +339,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// Does this in a "flat" style, without context.
         /// </summary>
@@ -351,7 +351,7 @@ private void ShowFlatErrorWarningSummary()
             }
 
             // If we're showing only warnings and/or errors, don't summarize.
-            // This is the buildc.err case. There's no point summarizing since we'd just 
+            // This is the buildc.err case. There's no point summarizing since we'd just
             // repeat the entire log content again.
             if (showOnlyErrors || showOnlyWarnings)
             {
@@ -384,7 +384,7 @@ private void ShowFlatErrorWarningSummary()
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// Does this in a "nested" style.
         /// </summary>
@@ -396,7 +396,7 @@ private void ShowNestedErrorWarningSummary()
             }
 
             // If we're showing only warnings and/or errors, don't summarize.
-            // This is the buildc.err case. There's no point summarizing since we'd just 
+            // This is the buildc.err case. There's no point summarizing since we'd just
             // repeat the entire log content again.
             if (showOnlyErrors || showOnlyWarnings)
             {
@@ -427,13 +427,13 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
             foreach (BuildEventArgs errorWarningEventArgs in listToProcess)
             {
                 // Target event may be null for a couple of reasons:
-                // 1) If the event was from a project load, or engine 
+                // 1) If the event was from a project load, or engine
                 // 2) If the flushing of the event queue for each request and result is turned off
                 // as this could cause errors and warnings to be seen by the logger after the target finished event
                 // which would cause the error or warning to have no matching target started event as they are removed
                 // when a target finished event is logged.
-                // 3) On NORMAL verbosity if the error or warning occurs in a project load then the error or warning and the target started event will be forwarded to 
-                // different forwarding loggers which cannot communicate to each other, meaning there will be no matching target started event logged 
+                // 3) On NORMAL verbosity if the error or warning occurs in a project load then the error or warning and the target started event will be forwarded to
+                // different forwarding loggers which cannot communicate to each other, meaning there will be no matching target started event logged
                 // as the forwarding logger did not know to forward the target started event
                 string targetName = null;
                 TargetStartedEventMinimumFields targetEvent = _buildEventManager.GetTargetStartedEvent(errorWarningEventArgs.BuildEventContext);
@@ -705,7 +705,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                             }
                         }
 
-                        // In single proc only make a space between the project done event and the next line, this 
+                        // In single proc only make a space between the project done event and the next line, this
                         // is to increase the readability on the single proc log when there are a number of done events
                         // or a mix of done events and project started events. Also only do this on the console and not any log file.
                         if (NumberOfProcessors == 1 && runningWithCharacterFileType)
@@ -725,7 +725,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
         /// <summary>
         /// Writes out the list of property names and their values.
         /// This could be done at any time during the build to show the latest
-        /// property values, using the cached reference to the list from the 
+        /// property values, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="e">A <see cref="BuildEventArgs"/> object containing information about the build event.</param>
@@ -792,7 +792,7 @@ internal override void OutputEnvironment(IDictionary<string, string> environment
         /// <summary>
         /// Writes out the list of item specs and their metadata.
         /// This could be done at any time during the build to show the latest
-        /// items, using the cached reference to the list from the 
+        /// items, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="e">A <see cref="BuildEventArgs"/> object containing information about the build event.</param>
@@ -1026,10 +1026,10 @@ internal string FindLogOutputProperties(BuildEventArgs e)
         public override void ErrorHandler(object sender, BuildErrorEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
-            // Keep track of the number of error events raised 
+            // Keep track of the number of error events raised
             errorCount++;
 
-            // If there is an error we need to walk up the call stack and make sure that 
+            // If there is an error we need to walk up the call stack and make sure that
             // the project started events back to the root project know an error has occurred
             // and are not removed when they finish
             _buildEventManager.SetErrorWarningFlagOnCallStack(e.BuildEventContext);
@@ -1075,7 +1075,7 @@ public override void WarningHandler(object sender, BuildWarningEventArgs e)
             // Keep track of the number of warning events raised during the build
             warningCount++;
 
-            // If there is a warning we need to walk up the call stack and make sure that 
+            // If there is a warning we need to walk up the call stack and make sure that
             // the project started events back to the root project know a warning has occurred
             // and are not removed when they finish
             _buildEventManager.SetErrorWarningFlagOnCallStack(e.BuildEventContext);
@@ -1149,7 +1149,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
 
             if (print)
             {
-                // If the event has a valid Project contextId but the project started event has not been fired, the message needs to be 
+                // If the event has a valid Project contextId but the project started event has not been fired, the message needs to be
                 // buffered until the project started event is fired
                 if (
                        _hasBuildStarted
@@ -1221,14 +1221,14 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
                 return;
             }
 
-            // Display any project started events which were deferred until a visible 
+            // Display any project started events which were deferred until a visible
             // message from their project is displayed
             if (IsVerbosityAtLeast(LoggerVerbosity.Normal))
             {
                 DisplayDeferredProjectStartedEvent(e);
             }
 
-            // Display any target started events which were deferred until a visible 
+            // Display any target started events which were deferred until a visible
             // message from their target is displayed
             if (IsVerbosityAtLeast(LoggerVerbosity.Detailed))
             {
@@ -1554,7 +1554,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                         resetColor();
                     }
 
-                    // Make the last shown build event context to be null so that the next message will always print out the target name. If this is not null 
+                    // Make the last shown build event context to be null so that the next message will always print out the target name. If this is not null
                     // then the first message after the project started event will not have the target name printed out which was causing some confusion.
                     ShownBuildEventContext(null);
                 }
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index d7612d7f3a6..de9c04f2c57 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -272,7 +272,7 @@ public int GetHashCode(T x)
     }
 
     /// <summary>
-    /// This class stands in for a full project started event because it contains only the 
+    /// This class stands in for a full project started event because it contains only the
     /// minimum amount of inforomation needed for the logger
     /// </summary>
     internal class ProjectStartedEventMinimumFields
@@ -410,7 +410,7 @@ internal ProjectStartedEventMinimumFields(int projectKey, int entryPointKey, Pro
     }
 
     /// <summary>
-    /// This class stands in for a full target started event because it contains only the 
+    /// This class stands in for a full target started event because it contains only the
     /// minimum amount of inforomation needed for the logger
     /// </summary>
     internal class TargetStartedEventMinimumFields
@@ -530,7 +530,7 @@ internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent, bo
     }
 
     /// <summary>
-    /// This class is used as a key to group warnings and errors by the project entry point and the target they 
+    /// This class is used as a key to group warnings and errors by the project entry point and the target they
     /// error or warning was in
     /// </summary>
     internal class ErrorWarningSummaryDictionaryKey
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index 7f12efba35c..77c521d5452 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -113,7 +113,7 @@ private void ProjectEvaluationFinishedRaised(object sender, BuildEventArgs e)
         /// <param name="pruneSmallItems">Whether small items should be pruned. This is called with false on some tests since the result may vary depending on the evaluator speed</param>
         /// <remarks>
         /// Not thread safe. After this method is called, the assumption is that no new ProjectEvaluationFinishedEventArgs will arrive.
-        /// In the regular code path, this method is called only once per build. But some test cases may call it multiple times to validate 
+        /// In the regular code path, this method is called only once per build. But some test cases may call it multiple times to validate
         /// the aggregated data.
         /// </remarks>
         internal ProfilerResult GetAggregatedResult(bool pruneSmallItems = true)
@@ -278,7 +278,7 @@ private static ProfiledLocation AggregateProfiledLocation(ProfiledLocation locat
         /// Pretty prints the aggregated results and saves it to disk.
         /// </summary>
         /// <remarks>
-        /// If the extension of the file to log is 'md', markdown content is generated. Otherwise, it falls 
+        /// If the extension of the file to log is 'md', markdown content is generated. Otherwise, it falls
         /// back to a tab separated format.
         /// </remarks>
         private void GenerateProfilerReport()
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index ac0ce5609c3..61f750ff472 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -67,7 +67,7 @@ public SerialConsoleLogger(
 
         /// <summary>
         /// Reset the states of per-build member variables
-        /// VSW#516376 
+        /// VSW#516376
         /// </summary>
         internal override void ResetConsoleLoggerState()
         {
@@ -182,7 +182,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// </summary>
         private void ShowErrorWarningSummary()
@@ -298,7 +298,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                 counter.InScope = false;
             }
 
-            // if verbosity is detailed or diagnostic, 
+            // if verbosity is detailed or diagnostic,
             // or there was an error or warning
             if (contextStack.Peek().hasErrorsOrWarnings
                 || (IsVerbosityAtLeast(LoggerVerbosity.Detailed)))
@@ -375,7 +375,7 @@ public override void TargetFinishedHandler(object sender, TargetFinishedEventArg
 
             bool targetHasErrorsOrWarnings = contextStack.Peek().hasErrorsOrWarnings;
 
-            // if verbosity is diagnostic, 
+            // if verbosity is diagnostic,
             // or there was an error or warning and verbosity is normal or detailed
             if ((targetHasErrorsOrWarnings && (IsVerbosityAtLeast(LoggerVerbosity.Normal)))
                   || Verbosity == LoggerVerbosity.Diagnostic)
@@ -885,8 +885,8 @@ internal Frame(
 
             /// <summary>
             /// For TargetStarted events, this stores the filename where the Target is defined
-            /// (e.g., Microsoft.Common.targets).  This is different than the project that is 
-            /// being built.  
+            /// (e.g., Microsoft.Common.targets).  This is different than the project that is
+            /// being built.
             /// For ProjectStarted events, this is null.
             /// </summary>
             internal string file;
diff --git a/src/Build/Resources/AssemblyResources.cs b/src/Build/Resources/AssemblyResources.cs
index 19954b16396..0eca428e261 100644
--- a/src/Build/Resources/AssemblyResources.cs
+++ b/src/Build/Resources/AssemblyResources.cs
@@ -20,7 +20,7 @@ internal static class AssemblyResources
         private static ResourceManager s_msbuildExeResourceManager;
 
         /// <summary>
-        /// The internals of the Engine are exposed to MSBuild.exe, so they must share the same AssemblyResources class and 
+        /// The internals of the Engine are exposed to MSBuild.exe, so they must share the same AssemblyResources class and
         /// ResourceUtilities class that uses it. To make this possible, MSBuild.exe registers its resources here and they are
         /// normally consulted last. This assumes that there are no duplicated resource ID's between the Engine and MSBuild.exe.
         /// (Actually there are currently two: LoggerCreationError and LoggerNotFoundError.
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index ed2e16683ba..f6c7a968081 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -132,17 +132,17 @@ internal static class Constants
         internal const string VisualStudioVersionPropertyName = "VisualStudioVersion";
 
         /// <summary>
-        /// Name of the property used to select which sub-toolset to use. 
+        /// Name of the property used to select which sub-toolset to use.
         /// </summary>
         internal const string SubToolsetVersionPropertyName = VisualStudioVersionPropertyName;
 
         /// <summary>
-        /// Value we should be setting VisualStudioVersion as the ultimate fallback when Dev10 is installed. 
+        /// Value we should be setting VisualStudioVersion as the ultimate fallback when Dev10 is installed.
         /// </summary>
         internal const string Dev10SubToolsetValue = "10.0";
 
         /// <summary>
-        /// Current version of this MSBuild Engine assembly in the 
+        /// Current version of this MSBuild Engine assembly in the
         /// form, e.g, "4.0"
         /// </summary>
         internal static string AssemblyVersion
@@ -231,12 +231,12 @@ internal static Tuple<string, Type> GetValue(string key)
         }
 
         /// <summary>
-        /// Tries to retrieve the type information for a type name / method name combination. 
-        /// 
+        /// Tries to retrieve the type information for a type name / method name combination.
+        ///
         /// It does 2 lookups:
         /// 1st try: 'typeFullName'
         /// 2nd try: 'typeFullName::simpleMethodName'
-        /// 
+        ///
         /// </summary>
         /// <param name="typeFullName">namespace qualified type name</param>
         /// <param name="simpleMethodName">name of the method</param>
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 0c26f6e1a8b..5942dad9bad 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -193,7 +193,7 @@ private static string[] GetFileList(
 
             var noWildcards = !FilespecHasWildcards(filespecEscaped) || FilespecMatchesLazyWildcard(filespecEscaped, forceEvaluateWildCards);
 
-            // It is possible to return original string if no wildcard matches and no entries in Exclude set. 
+            // It is possible to return original string if no wildcard matches and no entries in Exclude set.
             if (noWildcards && excludeSpecsEscaped?.Any() != true)
             {
                 // Just return the original string.
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index 32934034dee..ebe70f61d8c 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.Internal
 {
     /// <summary>
-    /// Thin wrapper around Microsoft.Win32.RegistryKey that can be 
+    /// Thin wrapper around Microsoft.Win32.RegistryKey that can be
     /// subclassed for testing purposes
     /// </summary>
     internal class RegistryKeyWrapper : IDisposable
@@ -92,7 +92,7 @@ public virtual string Name
         }
 
         /// <summary>
-        /// Convenient static helper method on RegistryKeyWrapper, for when someone is only intersted in knowing 
+        /// Convenient static helper method on RegistryKeyWrapper, for when someone is only intersted in knowing
         /// whether a particular registry key exists or not.
         /// </summary>
         public static bool KeyExists(string registryKeyPath, RegistryHive registryHive, RegistryView registryView)
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index 9ed8e0eb05d..f66c5bb3880 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -24,7 +24,7 @@ namespace Microsoft.Build.Utilities
     ///
     /// Ignores leading and trailing whitespace, but does not tolerate whitespace
     /// between components, unlike System.Version.
-    /// 
+    ///
     /// Also unlike System.Version, '+' is ignored as semver metadata as described
     /// above, not tolerated as positive sign of integer component.
     /// </summary>
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index c70d46dac78..67b454cc023 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -26,21 +26,21 @@ namespace Microsoft.Build.Internal
     internal static class Utilities
     {
         /// <summary>
-        /// Save off the contents of the environment variable that specifies whether we should treat higher toolsversions as the current 
+        /// Save off the contents of the environment variable that specifies whether we should treat higher toolsversions as the current
         /// toolsversion.  (Some hosts require this.)
         /// </summary>
         private static bool s_shouldTreatHigherToolsVersionsAsCurrent = (Environment.GetEnvironmentVariable("MSBUILDTREATHIGHERTOOLSVERSIONASCURRENT") != null);
 
         /// <summary>
-        /// Save off the contents of the environment variable that specifies whether we should treat all toolsversions, regardless of 
+        /// Save off the contents of the environment variable that specifies whether we should treat all toolsversions, regardless of
         /// whether they are higher or lower, as the current toolsversion.  (Some hosts require this.)
         /// </summary>
         private static bool s_shouldTreatOtherToolsVersionsAsCurrent = (Environment.GetEnvironmentVariable("MSBUILDTREATALLTOOLSVERSIONSASCURRENT") != null);
 
         /// <summary>
-        /// If set, default to the ToolsVersion from the project file (or if that doesn't isn't set, default to 2.0).  Otherwise, use Dev12+ 
-        /// defaulting logic: first check the MSBUILDDEFAULTTOOLSVERSION environment variable, then check for a DefaultOverrideToolsVersion, 
-        /// then if both fail, use the current ToolsVersion. 
+        /// If set, default to the ToolsVersion from the project file (or if that doesn't isn't set, default to 2.0).  Otherwise, use Dev12+
+        /// defaulting logic: first check the MSBUILDDEFAULTTOOLSVERSION environment variable, then check for a DefaultOverrideToolsVersion,
+        /// then if both fail, use the current ToolsVersion.
         /// </summary>
         private static bool s_uselegacyDefaultToolsVersionBehavior = (Environment.GetEnvironmentVariable("MSBUILDLEGACYDEFAULTTOOLSVERSION") != null);
 
@@ -56,10 +56,10 @@ internal static class Utilities
 
         /// <summary>
         /// INTERNAL FOR UNIT-TESTING ONLY
-        /// 
-        /// We've got several environment variables that we read into statics since we don't expect them to ever 
-        /// reasonably change, but we need some way of refreshing their values so that we can modify them for 
-        /// unit testing purposes. 
+        ///
+        /// We've got several environment variables that we read into statics since we don't expect them to ever
+        /// reasonably change, but we need some way of refreshing their values so that we can modify them for
+        /// unit testing purposes.
         /// </summary>
         internal static void RefreshInternalEnvironmentValues()
         {
@@ -94,7 +94,7 @@ internal static void SetXmlNodeInnerContents(XmlElementWithLocation node, string
                 }
             }
 
-            // The value does not contain valid XML markup.  Store it as text, so it gets 
+            // The value does not contain valid XML markup.  Store it as text, so it gets
             // escaped properly.
             node.InnerText = s;
         }
@@ -108,10 +108,10 @@ internal static string GetXmlNodeInnerContents(XmlElementWithLocation node)
         {
             // XmlNode.InnerXml gives back a string that consists of the set of characters
             // in between the opening and closing elements of the XML node, without doing any
-            // unescaping.  Any "strange" character sequences (like "<![CDATA[...]]>" will remain 
+            // unescaping.  Any "strange" character sequences (like "<![CDATA[...]]>" will remain
             // exactly so and will not be translated or interpreted.  The only modification that
             // .InnerXml will do is that it will normalize any Xml contained within.  This means
-            // normalizing whitespace between XML attributes and quote characters that surround XML 
+            // normalizing whitespace between XML attributes and quote characters that surround XML
             // attributes.  If PreserveWhitespace is false, then it will also normalize whitespace
             // between elements.
             //
@@ -138,19 +138,19 @@ internal static string GetXmlNodeInnerContents(XmlElementWithLocation node)
             // use ... InnerXml or InnerText.  There are two basic scenarios we care about.
             //
             // 1.)  The first scenario is that the user is trying to create a property whose
-            //      contents are actually XML.  That is to say that the contents may be written 
+            //      contents are actually XML.  That is to say that the contents may be written
             //      to a XML file, or may be passed in as a string to XmlDocument.LoadXml.
-            //      In this case, we would want to use XmlNode.InnerXml, because we DO NOT want 
-            //      character sequences to be unescaped.  If we did unescape them, then whatever 
+            //      In this case, we would want to use XmlNode.InnerXml, because we DO NOT want
+            //      character sequences to be unescaped.  If we did unescape them, then whatever
             //      XML parser tried to read in the stream as XML later on would totally barf.
             //
             // 2.)  The second scenario is the the user is trying to create a property that
             //      is just intended to be treated as a string.  That string may be very large
             //      and could contain all sorts of whitespace, carriage returns, special characters,
-            //      etc.  But in the end, it's just a big string.  In this case, whatever 
+            //      etc.  But in the end, it's just a big string.  In this case, whatever
             //      task is actually processing this string ... it's not going to know anything
             //      about character sequences such as &amp; and &lt;.  These character sequences
-            //      are specific to XML markup.  So, here we want to use XmlNode.InnerText so that 
+            //      are specific to XML markup.  So, here we want to use XmlNode.InnerText so that
             //      the character sequences get unescaped into their actual character before
             //      the string is passed to the task (or wherever else the property is used).
             //      Of course, if the string value of the property needs to contain characters
@@ -325,7 +325,7 @@ internal static string CreateToolsVersionListString(IEnumerable<Toolset> toolset
         }
 
         /// <summary>
-        /// Figure out what ToolsVersion to use to actually build the project with. 
+        /// Figure out what ToolsVersion to use to actually build the project with.
         /// </summary>
         /// <param name="explicitToolsVersion">The user-specified ToolsVersion (through e.g. /tv: on the command line)</param>
         /// <param name="toolsVersionFromProject">The ToolsVersion from the project file</param>
@@ -338,8 +338,8 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
         {
             string toolsVersionToUse = explicitToolsVersion;
 
-            // hosts may need to treat toolsversions later than the current one as the current one ... or may just 
-            // want to treat all toolsversions as though they're the current one, so give them that ability 
+            // hosts may need to treat toolsversions later than the current one as the current one ... or may just
+            // want to treat all toolsversions as though they're the current one, so give them that ability
             // through an environment variable
             if (s_shouldTreatOtherToolsVersionsAsCurrent)
             {
@@ -361,15 +361,15 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                     }
                 }
 
-                // If ToolsVersion has not either been explicitly set or been overridden via one of the methods 
+                // If ToolsVersion has not either been explicitly set or been overridden via one of the methods
                 // mentioned above
                 if (toolsVersionToUse == null)
                 {
-                    // We want to generate the ToolsVersion based on the legacy behavior if EITHER: 
-                    // - the environment variable (MSBUILDLEGACYDEFAULTTOOLSVERSION) is set 
-                    // - the current ToolsVersion doesn't actually exist.  This is extremely unlikely 
-                    //   to happen normally, but may happen in checked-in toolset scenarios, in which 
-                    //   case we want to make sure we're at least as tolerant as Dev11 was. 
+                    // We want to generate the ToolsVersion based on the legacy behavior if EITHER:
+                    // - the environment variable (MSBUILDLEGACYDEFAULTTOOLSVERSION) is set
+                    // - the current ToolsVersion doesn't actually exist.  This is extremely unlikely
+                    //   to happen normally, but may happen in checked-in toolset scenarios, in which
+                    //   case we want to make sure we're at least as tolerant as Dev11 was.
                     Toolset currentToolset = null;
 
                     if (getToolset != null)
@@ -377,11 +377,11 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                         currentToolset = getToolset(MSBuildConstants.CurrentToolsVersion);
                     }
 
-                    // if we want to do the legacy behavior, act as we did through Dev11:  
+                    // if we want to do the legacy behavior, act as we did through Dev11:
                     // - If project file defines a ToolsVersion that has a valid toolset associated with it, use that
                     // - Otherwise, if project file defines an invalid ToolsVersion, use the current ToolsVersion
-                    // - Otherwise, if project file does not define a ToolsVersion, use the default ToolsVersion (must 
-                    //   be "2.0" since 2.0 projects did not have a ToolsVersion field). 
+                    // - Otherwise, if project file does not define a ToolsVersion, use the default ToolsVersion (must
+                    //   be "2.0" since 2.0 projects did not have a ToolsVersion field).
                     if (s_uselegacyDefaultToolsVersionBehavior || (getToolset != null && currentToolset == null))
                     {
                         if (!String.IsNullOrEmpty(toolsVersionFromProject))
@@ -389,8 +389,8 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                             toolsVersionToUse = toolsVersionFromProject;
 
                             // If we can tell that the toolset specified in the project is not present
-                            // then we'll use the current version.  Otherwise, we'll assume our caller 
-                            // knew what it was doing. 
+                            // then we'll use the current version.  Otherwise, we'll assume our caller
+                            // knew what it was doing.
                             if (getToolset != null && getToolset(toolsVersionToUse) == null)
                             {
                                 toolsVersionToUse = MSBuildConstants.CurrentToolsVersion;
@@ -403,9 +403,9 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                     }
                     else
                     {
-                        // Otherwise, first check to see if the default ToolsVersion has been set in the environment.  
-                        // Ideally we'll check to make sure it's a valid ToolsVersion, but if we don't have the ability 
-                        // to do so, we'll assume the person who set the environment variable knew what they were doing. 
+                        // Otherwise, first check to see if the default ToolsVersion has been set in the environment.
+                        // Ideally we'll check to make sure it's a valid ToolsVersion, but if we don't have the ability
+                        // to do so, we'll assume the person who set the environment variable knew what they were doing.
                         if (!String.IsNullOrEmpty(s_defaultToolsVersionFromEnvironment))
                         {
                             if (getToolset == null || getToolset(s_defaultToolsVersionFromEnvironment) != null)
@@ -414,11 +414,11 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                             }
                         }
 
-                        // Otherwise, check to see if the override default toolsversion from the toolset works.  Though 
-                        // it's attached to the Toolset, it's actually MSBuild version dependent, so any loaded Toolset 
-                        // should have the same one. 
+                        // Otherwise, check to see if the override default toolsversion from the toolset works.  Though
+                        // it's attached to the Toolset, it's actually MSBuild version dependent, so any loaded Toolset
+                        // should have the same one.
                         //
-                        // And if that doesn't work, then just fall back to the current ToolsVersion. 
+                        // And if that doesn't work, then just fall back to the current ToolsVersion.
                         if (toolsVersionToUse == null)
                         {
                             if (getToolset != null && currentToolset != null)
@@ -468,9 +468,9 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
 
             PropertyDictionary<ProjectPropertyInstance> environmentProperties = new PropertyDictionary<ProjectPropertyInstance>(environmentVariablesBag.Count + 2);
 
-            // We set the MSBuildExtensionsPath variables here because we don't want to make them official 
-            // reserved properties; we need the ability for people to override our default in their 
-            // environment or as a global property.  
+            // We set the MSBuildExtensionsPath variables here because we don't want to make them official
+            // reserved properties; we need the ability for people to override our default in their
+            // environment or as a global property.
 
 #if !FEATURE_INSTALLED_MSBUILD
             string extensionsPath = BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
@@ -489,11 +489,11 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
             string extensionsPath64 = extensionsPath;
             environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
 #else
-            // "MSBuildExtensionsPath64". This points to whatever the value of "Program Files" environment variable is on a 
+            // "MSBuildExtensionsPath64". This points to whatever the value of "Program Files" environment variable is on a
             // 64-bit machine, and is empty on a 32-bit machine.
             if (FrameworkLocationHelper.programFiles64 != null)
             {
-                // if ProgramFiles and ProgramFiles(x86) are the same, then this is a 32-bit box, 
+                // if ProgramFiles and ProgramFiles(x86) are the same, then this is a 32-bit box,
                 // so we only want to set MSBuildExtensionsPath64 if they're not
                 string extensionsPath64 = NativeMethodsShared.IsWindows
                                               ? Path.Combine(
@@ -505,9 +505,9 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
 #endif
 
 #if FEATURE_INSTALLED_MSBUILD
-            // MSBuildExtensionsPath:  The way this used to work is that it would point to "Program Files\MSBuild" on both 
+            // MSBuildExtensionsPath:  The way this used to work is that it would point to "Program Files\MSBuild" on both
             // 32-bit and 64-bit machines.  We have a switch to continue using that behavior; however the default is now for
-            // MSBuildExtensionsPath to always point to the same location as MSBuildExtensionsPath32. 
+            // MSBuildExtensionsPath to always point to the same location as MSBuildExtensionsPath32.
 
             bool useLegacyMSBuildExtensionsPathBehavior = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLEGACYEXTENSIONSPATH"));
 
@@ -583,7 +583,7 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
         }
 
         /// <summary>
-        /// Extension to IEnumerable to get the count if it 
+        /// Extension to IEnumerable to get the count if it
         /// can be quickly gotten, otherwise 0.
         /// </summary>
         public static int FastCountOrZero(this IEnumerable enumerable)
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index d0cf997b9c7..bd14487bf55 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -64,7 +64,7 @@ private XmlReaderExtension(string file, bool loadAsReadOnly)
             }
             catch
             {
-                // GetXmlReader calls Read() to get Encoding and can throw. If it does, close 
+                // GetXmlReader calls Read() to get Encoding and can throw. If it does, close
                 // the streams as needed.
                 Dispose();
                 throw;
diff --git a/src/Deprecated/Conversion.UnitTests/OldVSProjectFileReader_Tests.cs b/src/Deprecated/Conversion.UnitTests/OldVSProjectFileReader_Tests.cs
index 1f71766cbd9..268e5d6c849 100644
--- a/src/Deprecated/Conversion.UnitTests/OldVSProjectFileReader_Tests.cs
+++ b/src/Deprecated/Conversion.UnitTests/OldVSProjectFileReader_Tests.cs
@@ -16,13 +16,13 @@
 namespace Microsoft.Build.UnitTests
 {
     /***************************************************************************
-     * 
+     *
      * Class:       OldVSProjectFileReader_Tests
      * Owner:       RGoel
-     * 
-     * This class contains the unit tests for the "OldVSProjectFileReader" class.  
+     *
+     * This class contains the unit tests for the "OldVSProjectFileReader" class.
      * See the comments in that class for a description of its purpose.
-     * 
+     *
      **************************************************************************/
     [TestClass]
     public class OldVSProjectFileReader_Tests
@@ -31,10 +31,10 @@ public class OldVSProjectFileReader_Tests
          *
          * Method:      OldVSProjectFileReader_Tests.CreateTemporaryProjectFile
          * Owner:       RGoel
-         * 
-         * Helper method which creates a temporary text file on disk with the 
+         *
+         * Helper method which creates a temporary text file on disk with the
          * specified contents.  Returns the temp filename as an [out] parameter.
-         * 
+         *
          **********************************************************************/
         private void CreateTemporaryProjectFile
             (
@@ -53,10 +53,10 @@ out string  projectFilename
          *
          * Method:      OldVSProjectFileReader_Tests.DeleteTemporaryProjectFile
          * Owner:       RGoel
-         * 
-         * Helper method to delete the temporary file created via 
+         *
+         * Helper method to delete the temporary file created via
          * "CreateTemporaryProjectFile".
-         * 
+         *
          **********************************************************************/
         private void DeleteTemporaryProjectFile
             (
@@ -70,28 +70,28 @@ string      projectFilename
          *
          * Method:      OldVSProjectFileReader_Tests.NoSpecialCharacters
          * Owner:       RGoel
-         * 
-         * Tests the OldVSProjectFileReader class, using a project file that 
+         *
+         * Tests the OldVSProjectFileReader class, using a project file that
          * does not contain any special characters.
-         * 
+         *
          **********************************************************************/
         [TestMethod]
-        public void NoSpecialCharacters 
+        public void NoSpecialCharacters
             (
             )
         {
             // The contents of the project file that we'll be testing.  Look at the
             // right side, for a cleaner copy without all the escaping.
-            string projectFileContents = 
+            string projectFileContents =
 
                 "<VisualStudioProject>\r\n" +                   //      <VisualStudioProject>
-                "\r\n" +                                        //      
+                "\r\n" +                                        //
                 "  <VisualBasic\r\n" +                          //        <VisualBasic
                 "    ProjectType = \"Local\"\r\n" +             //          ProjectType = "Local"
                 "    ProductVersion = \"7.10.3022\"\r\n" +      //          ProductVersion = "7.10.3022"
                 "  >\r\n" +                                     //        >
                 "  </VisualBasic>\r\n" +                        //        </VisualBasic>
-                "\r\n" +                                        //      
+                "\r\n" +                                        //
                 "</VisualStudioProject>\r\n";                   //      </VisualStudioProject>
 
             // Create a temp file on disk with the above contents.
@@ -161,7 +161,7 @@ public void NoSpecialCharacters
             // Read the next 20 characters into our buffer.
             charactersRead = reader.Read(characterBuffer, 0, 20);
 
-            // Read the next 20 characters into our buffer.  But actually, since 
+            // Read the next 20 characters into our buffer.  But actually, since
             // we're almost at the end of the file, we expect that only 7 characters
             // will actually be read.
             charactersRead = reader.Read(characterBuffer, 0, 20);
@@ -180,34 +180,34 @@ public void NoSpecialCharacters
             this.DeleteTemporaryProjectFile(projectFilename);
         }
 
-        
+
         /***********************************************************************
          *
          * Method:      OldVSProjectFileReader_Tests.XmlAttributesWithSpecialCharacters
          * Owner:       RGoel
-         * 
-         * Tests the OldVSProjectFileReader class, using a project file that 
+         *
+         * Tests the OldVSProjectFileReader class, using a project file that
          * contains special characters in some of the XML attribute values.
-         * 
+         *
          **********************************************************************/
         [TestMethod]
-        public void XmlAttributesWithSpecialCharacters 
+        public void XmlAttributesWithSpecialCharacters
             (
             )
         {
             // The contents of the project file that we'll be testing.  Look at the
             // right side, for a cleaner copy without all the escaping.
-            string projectFileContents = 
+            string projectFileContents =
 
                 "<VisualStudioProject>\r\n" +                   //      <VisualStudioProject>
-                "\r\n" +                                        //      
+                "\r\n" +                                        //
                 "  <VisualBasic\r\n" +                          //        <VisualBasic
                 "    ProjectType = \"Lo<cal\"\r\n" +            //          ProjectType = "Lo<cal"
                 "    ProductVersion = \"7<.10.>3022\"\r\n" +    //          ProductVersion = "7<.10.>3022"
                 "    A=\"blah>\" B=\"bloo<\"\r\n" +             //          A="blah>" B="bloo<"
                 "  >\r\n" +                                     //        >
                 "  </VisualBasic>\r\n" +                        //        </VisualBasic>
-                "\r\n" +                                        //      
+                "\r\n" +                                        //
                 "</VisualStudioProject>\r\n";                   //      </VisualStudioProject>
 
             // Create a temp file on disk with the above contents.
@@ -246,7 +246,7 @@ public void XmlAttributesWithSpecialCharacters
             // Read the remainder of the file.  Confirm that the < and > characters within
             // an attribute value got translated correctly.
             string restOfFile = reader.ReadToEnd();
-            Assert.AreEqual("10.&gt;3022\"\r\n    A=\"blah&gt;\" B=\"bloo&lt;\"\r\n  >\r\n  </VisualBasic>\r\n\r\n</VisualStudioProject>\r\n", 
+            Assert.AreEqual("10.&gt;3022\"\r\n    A=\"blah&gt;\" B=\"bloo&lt;\"\r\n  >\r\n  </VisualBasic>\r\n\r\n</VisualStudioProject>\r\n",
                 restOfFile);
 
             // Clean up.
@@ -258,12 +258,12 @@ public void XmlAttributesWithSpecialCharacters
          *
          * Method:      OldVSProjectFileReader_Tests.MultipleElementsOnSameLine
          * Owner:       RGoel
-         * 
-         * Tests the OldVSProjectFileReader class, using a project file that 
-         * contains multiple XML elements with attributes on the same line.  
+         *
+         * Tests the OldVSProjectFileReader class, using a project file that
+         * contains multiple XML elements with attributes on the same line.
          * This will actually never happen in a real VS7/Everett project file,
          * but it's good to test it anyway.
-         * 
+         *
          **********************************************************************/
         [TestMethod]
         public void MultipleElementsOnSameLine
@@ -272,7 +272,7 @@ public void MultipleElementsOnSameLine
         {
             // The contents of the project file that we'll be testing.  Look at the
             // right side, for a cleaner copy without all the escaping.
-            string projectFileContents = 
+            string projectFileContents =
 
                 "<Elem1 Attrib1=\"bl>>ah\"/><Elem2 Attrib2=\"bl<<oo\"/>";  //  <Elem1 Attrib1="bl>>ah"/><Elem2 Attrib2="bl<<oo"/>
 
@@ -287,7 +287,7 @@ public void MultipleElementsOnSameLine
             // an attribute value got translated correctly, but the < and > characters occurring
             // *outside* an attribute value are not touched.
             string wholeFile = reader.ReadToEnd();
-            Assert.AreEqual("<Elem1 Attrib1=\"bl&gt;&gt;ah\"/><Elem2 Attrib2=\"bl&lt;&lt;oo\"/>\r\n", 
+            Assert.AreEqual("<Elem1 Attrib1=\"bl&gt;&gt;ah\"/><Elem2 Attrib2=\"bl&lt;&lt;oo\"/>\r\n",
                 wholeFile);
 
             // Clean up.
@@ -307,7 +307,7 @@ public void AttributeValueUsingSingleQuotes
             )
         {
             // The contents of the project file that we'll be testing.
-            string projectFileContents = 
+            string projectFileContents =
                 "<Elem1 Attrib1 = '1234<56789 is a \"true\" statement'/>";
 
             // Create a temp file on disk with the above contents.
@@ -321,7 +321,7 @@ public void AttributeValueUsingSingleQuotes
             // an attribute value got translated correctly, but the < and > characters occurring
             // *outside* an attribute value are not touched.
             string wholeFile = reader.ReadToEnd();
-            Assert.AreEqual("<Elem1 Attrib1 = '1234&lt;56789 is a \"true\" statement'/>\r\n", 
+            Assert.AreEqual("<Elem1 Attrib1 = '1234&lt;56789 is a \"true\" statement'/>\r\n",
                 wholeFile);
 
             // Clean up.
@@ -416,7 +416,7 @@ public void Regress322573
             )
         {
             // The contents of the project file that we'll be testing.
-            string projectFileContents = 
+            string projectFileContents =
                 "<Elem1 StartArguments = \"???action=16&requestid=1000036&#14CA053601F66928BF0550E395A714E72C8D6066???  /HeadTraxStartversion 5.6.0.66 /RunningFromHeadTraxStart yes /HTXMutexName HTXMutex344\"/>";
 
             // Create a temp file on disk with the above contents.
@@ -429,7 +429,7 @@ public void Regress322573
             // Read the whole file into a string.  Confirm that the & character within
             // an attribute value got translated correctly.
             string wholeFile = reader.ReadToEnd();
-            Assert.AreEqual("<Elem1 StartArguments = \"???action=16&amp;requestid=1000036&amp;#14CA053601F66928BF0550E395A714E72C8D6066???  /HeadTraxStartversion 5.6.0.66 /RunningFromHeadTraxStart yes /HTXMutexName HTXMutex344\"/>\r\n", 
+            Assert.AreEqual("<Elem1 StartArguments = \"???action=16&amp;requestid=1000036&amp;#14CA053601F66928BF0550E395A714E72C8D6066???  /HeadTraxStartversion 5.6.0.66 /RunningFromHeadTraxStart yes /HTXMutexName HTXMutex344\"/>\r\n",
                 wholeFile);
 
             // Clean up.
@@ -457,7 +457,7 @@ public void Regress184573()
             // Instantiate our class with the project file.
             OldVSProjectFileReader reader = new OldVSProjectFileReader(projectFilename);
 
-            // Read the whole file into a string.  
+            // Read the whole file into a string.
             string wholeFile = reader.ReadToEnd();
             Assert.IsTrue(wholeFile.Length > 0, "High-bit character was stripped.");
 
@@ -484,7 +484,7 @@ public void Regress184573()
         }
 
         /// <summary>
-        /// Tests that a single ampersand replacement works correctly at the beginning of 
+        /// Tests that a single ampersand replacement works correctly at the beginning of
         /// a string, middle of a string, and end of a string.
         /// </summary>
         [TestMethod]
diff --git a/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs b/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
index 64fd843cc3b..c2992c6631c 100644
--- a/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
+++ b/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
@@ -86,13 +86,13 @@ internal static void ConvertAndCompare
     }
 
     /***************************************************************************
-     * 
+     *
      * Class:        ProjectFileConverter_Tests
      * Owner:       jomof
-     * 
-     * This class contains the unit tests for the " ProjectFileConverter" class.  
+     *
+     * This class contains the unit tests for the " ProjectFileConverter" class.
      * See the comments in that class for a description of its purpose.
-     * 
+     *
      **************************************************************************/
     [TestClass]
     public class  ProjectFileConverter_Tests
@@ -101,15 +101,15 @@ public class  ProjectFileConverter_Tests
          *
          * Method:   ProjectFileConverter_Tests.MakeRelativeWithHash
          * Owner:    jomof
-         * 
-         * Test where paths with '#' in them can be converted into relative 
+         *
+         * Test where paths with '#' in them can be converted into relative
          * paths
-         * 
+         *
          **********************************************************************/
         [TestMethod]
         public void MakeRelativeWithHash()
         {
-            // Intentionally making the paths not the same case, because this should be irrelevant.            
+            // Intentionally making the paths not the same case, because this should be irrelevant.
             string path1 = @"D:\Public\Samples\Visual J# .NET 2003\Crosslanguage\Copy (8) of TilePuzzle\TileDriver\TileDriver.vcproj";
             string path2 = @"D:\public\Samples\Visual J# .NET 2003\Crosslanguage\Copy (8) of TilePuzzle\PUZZLE.vjsproj";
 
@@ -118,15 +118,15 @@ public void MakeRelativeWithHash()
 
             Assert.AreEqual(@"TileDriver\TileDriver.vcproj", rel);
         }
-        
+
         /***********************************************************************
          *
          * Method:   ProjectFileConverter_Tests.MakeRelativeWithSpace
          * Owner:    RGoel
-         * 
+         *
          * Test where paths where the relative path ends up having a <space> in
          * it.
-         * 
+         *
          **********************************************************************/
         [TestMethod]
         public void MakeRelativeWithSpace()
@@ -401,7 +401,7 @@ public void RemoveReferencesToEmptyResxPerBug248965()
         public void VbConversionWithMyTypeAlreadySet()
         {
             // **********************************************
-            //                   EVERETT 
+            //                   EVERETT
             // **********************************************
             string everettProjectContents = @"
                 <VisualStudioProject>
@@ -607,7 +607,7 @@ public void VbConversionWithMyTypeAlreadySet()
         public void ConvertTrinityWithOfficeDocumentFile()
         {
             // **********************************************
-            //                   EVERETT 
+            //                   EVERETT
             // **********************************************
             string everettProjectContents = @"
                 <VisualStudioProject>
@@ -877,11 +877,11 @@ public void ConvertTrinityWithOfficeDocumentFile()
                     </ItemGroup>
                     <ProjectExtensions>
                         <VisualStudio>
-                            <UserProperties 
-                                OfficeDocumentPath=`.\EXCELPROJECT1.XLS` 
-                                OfficeProjectType=`XLS` 
-                                OfficeProject=`true` 
-                                TrustedAssembly=`c:\rajeev_temp_deleteme\ExcelProject1\ExcelProject1_bin\ExcelProject1.dll` 
+                            <UserProperties
+                                OfficeDocumentPath=`.\EXCELPROJECT1.XLS`
+                                OfficeProjectType=`XLS`
+                                OfficeProject=`true`
+                                TrustedAssembly=`c:\rajeev_temp_deleteme\ExcelProject1\ExcelProject1_bin\ExcelProject1.dll`
                              />
                         </VisualStudio>
                     </ProjectExtensions>
@@ -905,7 +905,7 @@ public void ConvertTrinityWithOfficeDocumentFile()
         public void ConvertEmptyFolders()
         {
             // **********************************************
-            //                   EVERETT 
+            //                   EVERETT
             // **********************************************
             string everettProjectContents = @"
 
@@ -1183,7 +1183,7 @@ public void ConvertP2PReference()
 
         /// <summary>
         /// This is to test that we convert Everett projects that are part of solutions including
-        /// VC++ projects. 
+        /// VC++ projects.
         /// </summary>
         [TestMethod]
         public void ConvertProjectWithVCInSolutionAndP2Ps()
@@ -1357,7 +1357,7 @@ public void ConvertProjectWithVCInSolutionAndP2Ps()
             File.Delete(everettProjectFile);
             File.Delete(everettSolutionFile);
         }
-        
+
         /// <summary>
         /// This is to test that we convert P2P references correctly by looking up the
         /// referenced project in the given .SLN file.  Force the conversion code to
@@ -1436,7 +1436,7 @@ public void ConvertP2PReferenceSearchForSolution()
             // **********************************************
             //                   EVERETT SOLUTION
             // **********************************************
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"WindowsApplication1.sln", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"WindowsApplication1.sln",
 
                 @"Microsoft Visual Studio Solution File, Format Version 8.00
                 Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `WindowsApplication1`, `Project\WindowsApplication1.csproj`, `{77E21864-797C-4220-974E-530BB832801B}`
@@ -1472,7 +1472,7 @@ public void ConvertP2PReferenceSearchForSolution()
             // **********************************************
             //                   RANDOM OTHER SOLUTION
             // **********************************************
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Project\Random.sln", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Project\Random.sln",
 
                 @"Microsoft Visual Studio Solution File, Format Version 8.00
                 Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `ClassLibrary2`, `ClassLibrary2\ClassLibrary2.csproj`, `{11111111-9E5C-4FE8-BE84-96F37D47F45A}`
@@ -1553,10 +1553,10 @@ public void ConvertP2PReferenceSearchForSolution()
 
             Helpers.CompareProjectXml(whidbeyProjectContents, project.RawXml);
         }
-        
+
         /// <summary>
         /// This is a test for bug VSWhidbey 472064.  We are making sure that if DebugSymbols is true in
-        /// the original project file, then we also emit DebugType to the whidbey project file.  We also 
+        /// the original project file, then we also emit DebugType to the whidbey project file.  We also
         /// emit ErrorReport = prompt to the whidbey project file if the language is C#
         /// </summary>
         /// <owner>FaisalMo</owner>
@@ -1564,12 +1564,12 @@ public void ConvertP2PReferenceSearchForSolution()
         public void ConvertEverettProjectWithNoDebugInfoFlag()
         {
             // **********************************************
-            //                   EVERETT 
+            //                   EVERETT
             // **********************************************
             string everettProjectContents = @"
                 <VisualStudioProject>
                     <CSHARP
-                        ProjectType = `Local`                        
+                        ProjectType = `Local`
                         SchemaVersion = `2.0`
                         ProjectGuid = `{172D0AFF-7BF3-4297-8168-792C46DC89DD}`
                     >
@@ -1776,12 +1776,12 @@ public void ConvertEverettProjectWithNoDebugInfoFlag()
         public void ConvertEverettProjectWithSpecialCharaceters()
         {
             // **********************************************
-            //                   EVERETT 
+            //                   EVERETT
             // **********************************************
             string everettProjectContents = @"
                 <VisualStudioProject>
                     <CSHARP
-                        ProjectType = `Local`                        
+                        ProjectType = `Local`
                         SchemaVersion = `2.0`
                         ProjectGuid = `{172D0AFF-7BF3-4297-8168-792C46DC89DD}`
                     >
@@ -1989,9 +1989,9 @@ public void ConvertEverettProjectWithSpecialCharaceters()
         }
 
         /// <summary>
-        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains 
-        /// references to v3.5 and before VC projects (.vcproj), convert that reference to 
-        /// instead reference a .vcxproj of the same name. 
+        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains
+        /// references to v3.5 and before VC projects (.vcproj), convert that reference to
+        /// instead reference a .vcxproj of the same name.
         /// </summary>
         [TestMethod]
         public void ConvertVCProjectReferenceExtensions()
@@ -2016,9 +2016,9 @@ public void ConvertVCProjectReferenceExtensions()
         }
 
         /// <summary>
-        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains 
-        /// references to v3.5 and before VC projects (.vcproj), convert that reference to 
-        /// instead reference a .vcxproj of the same name. 
+        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains
+        /// references to v3.5 and before VC projects (.vcproj), convert that reference to
+        /// instead reference a .vcxproj of the same name.
         /// </summary>
         [TestMethod]
         public void ConvertVCProjectReferenceExtensionsWildcard()
@@ -2043,9 +2043,9 @@ public void ConvertVCProjectReferenceExtensionsWildcard()
         }
 
         /// <summary>
-        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains 
-        /// references to v3.5 and before VC projects (.vcproj), convert that reference to 
-        /// instead reference a .vcxproj of the same name. 
+        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains
+        /// references to v3.5 and before VC projects (.vcproj), convert that reference to
+        /// instead reference a .vcxproj of the same name.
         /// </summary>
         [TestMethod]
         public void ConvertVCProjectReferenceExtensionsTrimNeeded()
@@ -2309,7 +2309,7 @@ public void ConvertFSharpOrcasProjectFile()
                     <Compile Include=""Program.fs"" />
                   </ItemGroup>
                   <Import Project=""$(MSBuildExtensionsPath)\FSharp\1.0\Microsoft.FSharp.Targets"" />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2378,7 +2378,7 @@ public void ConvertFSharpOrcasProjectFile()
                     </Otherwise>
                   </Choose>
                   <Import Project=""$(FSharpTargetsPath)"" Condition=""Exists('$(FSharpTargetsPath)')""/>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2442,7 +2442,7 @@ public void ConvertDev11PortableLibraryProjectFile()
                     <MinimumVisualStudioVersion Condition=""'$(MinimumVisualStudioVersion)' == ''"">11</MinimumVisualStudioVersion>
                   </PropertyGroup>
                   <Import Project=""$(MSBuildExtensionsPath32)\..\Microsoft SDKs\F#\3.0\Framework\v4.0\Microsoft.Portable.FSharp.Targets"" />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -2513,7 +2513,7 @@ public void ConvertDev11PortableLibraryProjectFile()
                     </Otherwise>
                   </Choose>
                   <Import Project=""$(FSharpTargetsPath)"" Condition=""Exists('$(FSharpTargetsPath)')""/>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -2528,7 +2528,7 @@ public void ConvertDev11PortableLibraryProjectFile()
 
         [TestMethod]
         public void ConvertDev12PortableLibraryProjectFileShouldBeNoOp()
-        { 
+        {
             string asDev12ProjectFile = ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion=""msbuilddefaulttoolsversion"" DefaultTargets=""Build"" xmlns=""msbuildnamespace"">
                   <Import Project=""$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props"" Condition=""Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')"" />
@@ -2581,7 +2581,7 @@ public void ConvertDev12PortableLibraryProjectFileShouldBeNoOp()
                     <FSharpTargetsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\FSharp\Microsoft.Portable.FSharp.Targets</FSharpTargetsPath>
                   </PropertyGroup>
                   <Import Project=""$(FSharpTargetsPath)"" Condition=""Exists('$(FSharpTargetsPath)')""/>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -2646,7 +2646,7 @@ public void ConvertFSharpDev10ProjectFile()
                   </ItemGroup>
                   <Import Project=""$(MSBuildExtensionsPath32)\FSharp\1.0\Microsoft.FSharp.Targets"" Condition=""!Exists('$(MSBuildBinPath)\Microsoft.Build.Tasks.v4.0.dll')"" />
                   <Import Project=""$(MSBuildExtensionsPath32)\..\Microsoft F#\v4.0\Microsoft.FSharp.Targets"" Condition="" Exists('$(MSBuildBinPath)\Microsoft.Build.Tasks.v4.0.dll')"" />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2718,7 +2718,7 @@ public void ConvertFSharpDev10ProjectFile()
                     </Otherwise>
                   </Choose>
                   <Import Project=""$(FSharpTargetsPath)"" Condition=""Exists('$(FSharpTargetsPath)')""/>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2785,7 +2785,7 @@ public void ConvertFSharpDev10ProjectFileWithMinVS()
                   </PropertyGroup>
                   <Import Project=""$(MSBuildExtensionsPath32)\FSharp\1.0\Microsoft.FSharp.Targets"" Condition=""!Exists('$(MSBuildBinPath)\Microsoft.Build.Tasks.v4.0.dll')"" />
                   <Import Project=""$(MSBuildExtensionsPath32)\..\Microsoft F#\v4.0\Microsoft.FSharp.Targets"" Condition="" Exists('$(MSBuildBinPath)\Microsoft.Build.Tasks.v4.0.dll')"" />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2859,7 +2859,7 @@ public void ConvertFSharpDev10ProjectFileWithMinVS()
                     </Otherwise>
                   </Choose>
                   <Import Project=""$(FSharpTargetsPath)"" Condition=""Exists('$(FSharpTargetsPath)')""/>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2870,7 +2870,7 @@ public void ConvertFSharpDev10ProjectFileWithMinVS()
                 ";
             Helpers.ConvertAndCompare(sampleFSharpDev10ProjectFile, asDev11ProjectFile);
         }
-        
+
         [TestMethod]
         public void ConvertFSharpDev11ProjectFile()
         {
@@ -2923,7 +2923,7 @@ public void ConvertFSharpDev11ProjectFile()
                     <Reference Include=""System.Core"" />
                     <Reference Include=""System.Numerics"" />
                   </ItemGroup>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -2996,7 +2996,7 @@ public void ConvertFSharpDev11ProjectFile()
                     <Reference Include=""System.Core"" />
                     <Reference Include=""System.Numerics"" />
                   </ItemGroup>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -3062,7 +3062,7 @@ public void ConvertFSharpDev11ProjectFileWithCustomFSharpCoreLocation()
                     <Reference Include=""System.Core"" />
                     <Reference Include=""System.Numerics"" />
                   </ItemGroup>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -3134,7 +3134,7 @@ public void ConvertFSharpDev11ProjectFileWithCustomFSharpCoreLocation()
                     <Reference Include=""System.Core"" />
                     <Reference Include=""System.Numerics"" />
                   </ItemGroup>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -3202,7 +3202,7 @@ public void ConvertFSharpDev12ProjectFileShouldBeNoOp()
                     <Reference Include=""System.Core"" />
                     <Reference Include=""System.Numerics"" />
                   </ItemGroup>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -3279,7 +3279,7 @@ public void ConvertWFProjectFile()
                   </ItemGroup>
                   <Import Project=""$(MSBuildBinPath)\Microsoft.CSharp.Targets"" />
                   <Import Project=""$(MSBuildExtensionsPath)\Microsoft\Windows Workflow Foundation\v3.0\Workflow.Targets"" />
-                </Project>                
+                </Project>
                     ";
             string wfDev10ProjectFile = ObjectModelHelpers.CleanupFileContents(@"
                     <Project DefaultTargets=""Build"" xmlns=""msbuildnamespace"" ToolsVersion=""msbuilddefaulttoolsversion"">
@@ -3655,7 +3655,7 @@ public void ConvertVB2008RepairRequired()
   </ItemGroup>
   <Import Project=""$(MSBuildBinPath)\Microsoft.VisualBasic.targets"" />
   <Import Project=""$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v9.0\WebApplications\Microsoft.WebApplication.targets"" />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name=""BeforeBuild"">
   </Target>
@@ -3844,7 +3844,7 @@ public void ConvertVB2008RepairRequired()
   <Import Project=""$(MSBuildBinPath)\Microsoft.VisualBasic.targets"" />
   <Import Project=""$(VSToolsPath)\WebApplications\Microsoft.WebApplication.targets"" Condition=""'$(VSToolsPath)' != ''"" />
   <Import Project=""$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\WebApplications\Microsoft.WebApplication.targets"" Condition=""false"" />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name=""BeforeBuild"">
   </Target>
@@ -5307,7 +5307,7 @@ public void ConvertVB2005ConversionRequired()
                           <LastGenOutput>Settings.Designer.vb</LastGenOutput>
                         </None>
                       </ItemGroup>
-                    </Project>  
+                    </Project>
                     ");
 
             Helpers.ConvertAndCompare(ProjectBefore, ProjectAfter);
@@ -5319,7 +5319,7 @@ public void ConvertVB2005ConversionRequired()
         [TestMethod]
         public void ConvertCS2005ExcelProjectConversionRequired()
         {
-            string projectBefore = 
+            string projectBefore =
                     @" <VisualStudioProject>
                         <CSHARP
                             ProjectType = ""Local""
@@ -5668,9 +5668,9 @@ public void CheckForReferencesReplacements()
         /// Check that when we're upgrading projects referencing and compiling .xaml source files
         /// we are correctly appending Generator and Subtype properties to the source file and not the
         /// reference
-        /// 
+        ///
         /// Check also that project references to vcproj have their extensions fixed to .vcxproj
-        /// 
+        ///
         /// Lastly, make sure that this still happens even if the ToolsVersion is > 3.5.
         /// </summary>
         [TestMethod]
@@ -5735,7 +5735,7 @@ public void CheckForReferencesReplacements_NewerToolsVersion()
 
         /// <summary>
         /// Check that when we're upgrading projects referencing and compiling .xaml source files
-        /// that we don't append the Generator and SubType properties to the source file if they 
+        /// that we don't append the Generator and SubType properties to the source file if they
         /// are already set.
         /// </summary>
         [TestMethod]
@@ -5806,8 +5806,8 @@ public void DoNotReplacePreExistingXamlProperties()
 
         /// <summary>
         /// Check that when we're upgrading projects referencing and compiling .xaml source files
-        /// that even if there are multiple instances of the metadata, we don't eliminate them -- 
-        /// we just also don't add any more. 
+        /// that even if there are multiple instances of the metadata, we don't eliminate them --
+        /// we just also don't add any more.
         /// </summary>
         [TestMethod]
         public void DontEliminateDuplicateXamlProperties()
@@ -5901,8 +5901,8 @@ public void DontEliminateDuplicateXamlProperties()
 
         /// <summary>
         /// Check that when we're upgrading projects referencing and compiling .xaml source files
-        /// that already have Generator and Subtype metadata, we don't make any changes and 
-        /// don't update the ToolsVersion. 
+        /// that already have Generator and Subtype metadata, we don't make any changes and
+        /// don't update the ToolsVersion.
         /// </summary>
         [TestMethod]
         public void DontUpdateToolsVersionIfNothingChanged()
diff --git a/src/Deprecated/Conversion/AdditionalOptionsParser.cs b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
index b1460c62f46..422ae5277e6 100644
--- a/src/Deprecated/Conversion/AdditionalOptionsParser.cs
+++ b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
@@ -144,7 +144,7 @@ string switchProjectPropertyName
     /// </summary>
     internal sealed class AdditionalOptionsParser
     {
-        // These are all that we recognize in the AdditionalOptions    
+        // These are all that we recognize in the AdditionalOptions
         private CompSwitchInfo[] validCompilerSwitches = new CompSwitchInfo[] {
             #region Info on the compiler switches to be parsed from AdditionalOptions
             // /codepage:<n>
diff --git a/src/Deprecated/Conversion/AssemblyInfo.cs b/src/Deprecated/Conversion/AssemblyInfo.cs
index 9f260a4bf6f..861a59d36f0 100644
--- a/src/Deprecated/Conversion/AssemblyInfo.cs
+++ b/src/Deprecated/Conversion/AssemblyInfo.cs
@@ -16,13 +16,13 @@
 #pragma warning restore 618
 
 // This is the assembly-level GUID, and the GUID for the TypeLib associated with
-// this assembly.  We should specify this explicitly, as opposed to letting 
+// this assembly.  We should specify this explicitly, as opposed to letting
 // tlbexp just pick whatever it wants.
 [assembly: GuidAttribute("634AFA8F-4271-4e2c-9525-D0B75DAA821A")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 
-// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
-// so that we don't run into known security issues with loading libraries from unsafe locations 
+// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
+// so that we don't run into known security issues with loading libraries from unsafe locations
 [assembly: DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories)]
 
 [assembly: CLSCompliant(true)]
diff --git a/src/Deprecated/Conversion/OldVSProjectFileReader.cs b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
index a0f8f164e17..995871eb31c 100644
--- a/src/Deprecated/Conversion/OldVSProjectFileReader.cs
+++ b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
@@ -15,21 +15,21 @@
 namespace Microsoft.Build.Conversion
 {
     /// <summary>
-    /// This class implements a custom text reader for the old VS7/Everett 
-    /// project file format.  The old format allowed certain XML special 
+    /// This class implements a custom text reader for the old VS7/Everett
+    /// project file format.  The old format allowed certain XML special
     /// characters to be present within an XML attribute value.  For example,
     ///
     ///     &lt;MyElement MyAttribute="My --> Value" /&gt;
     ///
     /// However, the System.Xml classes are more strict, and do not allow
-    /// the &lt; or &gt; characters to exist within an attribute value.  But 
+    /// the &lt; or &gt; characters to exist within an attribute value.  But
     /// the conversion utility still needs to be able to convert all old
     /// project files.  So the OldVSProjectFileReader class implements
     /// the TextReader interface, thereby effectively intercepting all of
     /// the calls which are used by the XmlTextReader to actually read the
-    /// raw text out of the file.  As we are reading the text out of the 
+    /// raw text out of the file.  As we are reading the text out of the
     /// file, we replace all &gt; (less-than) characters inside attribute values with "&gt;",
-    /// etc.  The XmlTextReader has no idea that this is going on, but 
+    /// etc.  The XmlTextReader has no idea that this is going on, but
     /// no longer complains about invalid characters.
     /// </summary>
     /// <owner>rgoel</owner>
@@ -80,7 +80,7 @@ public override void Close
 
         /// <summary>
         /// Returns the next character in the file, without actually advancing
-        /// the read pointer.  Returns -1 if we're already at the end of the file.  
+        /// the read pointer.  Returns -1 if we're already at the end of the file.
         /// </summary>
         /// <returns></returns>
         /// <owner>rgoel</owner>
@@ -88,7 +88,7 @@ public override int Peek
             (
             )
         {
-            // If necessary, read a new line of text into our internal buffer 
+            // If necessary, read a new line of text into our internal buffer
             // (this.singleLine).
             if (!this.ReadLineIntoInternalBuffer())
             {
@@ -101,7 +101,7 @@ public override int Peek
         }
 
         /// <summary>
-        /// Returns the next character in the file, and advances the read pointer.  
+        /// Returns the next character in the file, and advances the read pointer.
         /// Returns -1 if we're already at the end of the file.
         /// </summary>
         /// <returns></returns>
@@ -123,7 +123,7 @@ public override int Read
         }
 
         /// <summary>
-        /// Reads the specified number of characters into the caller's buffer, 
+        /// Reads the specified number of characters into the caller's buffer,
         /// starting at the specified index into the caller's buffer.  Returns
         /// the number of characters read, or 0 if we're already at the end of
         /// the file.
@@ -157,7 +157,7 @@ int charactersToRead        // The number of characters to read.
                 // Read more data from the underlying file if necessary.
                 if (!this.ReadLineIntoInternalBuffer())
                 {
-                    // If we've reached the end of the underlying file, exit the 
+                    // If we've reached the end of the underlying file, exit the
                     // loop.
                     break;
                 }
@@ -279,7 +279,7 @@ public override string ReadToEnd
 
         /// <summary>
         /// And this is where the real magic happens.  If our currently cached
-        /// "singleLine" has been used up, we read a new line of text from the 
+        /// "singleLine" has been used up, we read a new line of text from the
         /// underlying text file.  But as we read the line of text from the file,
         /// we immediately replace all instances of special characters that occur
         /// within double-quotes with the corresponding XML-friendly equivalents.
@@ -293,7 +293,7 @@ public override string ReadToEnd
         ///
         /// and we would store it this way in our "singleLine", so that the callers
         /// never know the difference.
-        /// 
+        ///
         /// This method returns true on success, and false if we were unable to
         /// read a new line (due to end of file).
         /// </summary>
@@ -319,7 +319,7 @@ private bool ReadLineIntoInternalBuffer
                 // with the escaped XML-friendly string equivalents.
                 this.singleLine = new StringBuilder(this.ReplaceSpecialCharacters(lineFromProjectFile));
 
-                // The underlying StreamReader.ReadLine method doesn't give us the 
+                // The underlying StreamReader.ReadLine method doesn't give us the
                 // trailing line endings, so add them back ourselves.
                 this.singleLine.Append(Environment.NewLine);
 
@@ -334,7 +334,7 @@ private bool ReadLineIntoInternalBuffer
         /// <summary>
         /// This method uses a regular expression to search for the stuff in
         /// between double-quotes.  We obviously don't want to touch the stuff
-        /// OUTSIDE of double-quotes, because then we would be mucking with the 
+        /// OUTSIDE of double-quotes, because then we would be mucking with the
         /// real angle-brackets that delimit the XML element names, etc.
         /// </summary>
         /// <param name="originalLine"></param>
@@ -345,7 +345,7 @@ private string ReplaceSpecialCharacters
             string originalLine
             )
         {
-            // Find the stuff within double-quotes, and send it off to the 
+            // Find the stuff within double-quotes, and send it off to the
             // "ReplaceSpecialCharactersInXmlAttribute" for proper replacement of
             // the special characters.
             Regex attributeValueInsideDoubleQuotesPattern = new Regex("= *\"[^\"]*\"");
@@ -353,7 +353,7 @@ string originalLine
             string replacedStuffInsideDoubleQuotes = attributeValueInsideDoubleQuotesPattern.Replace(originalLine,
                 new MatchEvaluator(this.ReplaceSpecialCharactersInXmlAttribute));
 
-            // Find the stuff within single-quotes, and send it off to the 
+            // Find the stuff within single-quotes, and send it off to the
             // "ReplaceSpecialCharactersInXmlAttribute" for proper replacement of
             // the special characters.
             Regex attributeValueInsideSingleQuotesPattern = new Regex("= *'[^']*'");
@@ -368,7 +368,7 @@ string originalLine
         /// This method is used as the delegate that is passed into Regex.Replace.
         /// It a regular expression to search for the stuff in
         /// between double-quotes.  We obviously don't want to touch the stuff
-        /// OUTSIDE of double-quotes, because then we would be mucking with the 
+        /// OUTSIDE of double-quotes, because then we would be mucking with the
         /// real angle-brackets that delimit the XML element names, etc.
         /// </summary>
         /// <param name="xmlAttribute"></param>
@@ -386,7 +386,7 @@ Match xmlAttribute
         }
 
         /// <summary>
-        /// This method actually does the replacement of special characters within the 
+        /// This method actually does the replacement of special characters within the
         /// text of the XML attribute.
         /// </summary>
         /// <param name="xmlAttributeText">Input string</param>
@@ -399,7 +399,7 @@ string xmlAttributeText
         {
             // Replace the special characters with their XML-friendly escaped equivalents.  The
             // "<" and ">" signs are easy, because if they exist at all within the value of an
-            // XML attribute, we know that they need to be replaced with "&lt;" and "&gt;" 
+            // XML attribute, we know that they need to be replaced with "&lt;" and "&gt;"
             // respectively.
             xmlAttributeText = xmlAttributeText.Replace("<", "&lt;");
             xmlAttributeText = xmlAttributeText.Replace(">", "&gt;");
@@ -415,8 +415,8 @@ string xmlAttributeText
         /// the "&amp;" character, it determines whether the "&amp;" character needs to be replaced
         /// with "&amp;amp;".  The old XML parser used in the VS.NET 2002/2003 project system
         /// was quite inconsistent in its treatment of escaped characters in XML, so here
-        /// we're having to make up for those bugs.  The new XML parser (System.Xml) 
-        /// is much more strict in enforcing proper XML syntax, and therefore doesn't 
+        /// we're having to make up for those bugs.  The new XML parser (System.Xml)
+        /// is much more strict in enforcing proper XML syntax, and therefore doesn't
         /// tolerate "&amp;" characters in the XML attribute value, unless the "&amp;" is being
         /// used to escape some special character.
         /// </summary>
@@ -429,7 +429,7 @@ string xmlAttributeText
             )
         {
             // Ampersands are a little trickier, because some instances of "&" we need to leave
-            // untouched, and some we need to replace with "&amp;".  For example, 
+            // untouched, and some we need to replace with "&amp;".  For example,
             //      aaa&bbb         should be replaced with         aaa&amp;bbb
             // But:
             //      aaa&lt;bbb      should not be touched.
@@ -457,7 +457,7 @@ string xmlAttributeText
 
                     // Perf note: Here we are walking through the entire list of entities, and
                     // doing a string comparison for each.  This is expensive, but this code
-                    // should only get executed in fairly rare circumstances.  It's not very 
+                    // should only get executed in fairly rare circumstances.  It's not very
                     // common for people to have these embedded into their project files.
                     bool foundEntity = false;
                     for (int i = 0; i < entities.Length; i++)
@@ -472,7 +472,7 @@ string xmlAttributeText
                         }
                     }
 
-                    // If it didn't match a well-known entity name, then the next thing to 
+                    // If it didn't match a well-known entity name, then the next thing to
                     // check is if it represents an ASCII code.  For example, in an XML
                     // attribute, if I wanted to represent the "+" sign, I could do this:
                     //
@@ -521,7 +521,7 @@ string xmlAttributeText
                         }
                     }
 
-                    // If the ampersand did not precede an actual well-known entity, then we DO want to 
+                    // If the ampersand did not precede an actual well-known entity, then we DO want to
                     // replace the "&" with a "&amp;".  Otherwise we don't.
                     if (!foundEntity)
                     {
@@ -568,7 +568,7 @@ int indexOfAmpersand
         // taken directly from the source code.
         private static readonly string[] entities =
         {
-            "quot",          // 
+            "quot",          //
             "amp",           // & - ampersand
             "apos",          // ' - apostrophe //// not part of HTML!
             "lt",            // < less than
@@ -685,7 +685,7 @@ int indexOfAmpersand
             "Zeta",         // greek capital letter zeta
             "Eta",          // greek capital letter eta
             "Theta",        // greek capital letter theta
-            "Iota",         // greek capital letter iota 
+            "Iota",         // greek capital letter iota
             "Kappa",        // greek capital letter kappa
             "Lambda",       // greek capital letter lambda
             "Mu",           // greek capital letter mu
@@ -699,7 +699,7 @@ int indexOfAmpersand
             "Upsilon",      // greek capital letter upsilon
             "Phi",          // greek capital letter phi
             "Chi",          // greek capital letter chi
-            "Psi",          // greek capital letter psi   
+            "Psi",          // greek capital letter psi
             "Omega",        // greek capital letter omega
             "alpha",        // greek small letter alpha
             "beta",         // greek small letter beta
@@ -709,7 +709,7 @@ int indexOfAmpersand
             "zeta",         // greek small letter zeta
             "eta",          // greek small letter eta
             "theta",        // greek small letter theta
-            "iota",         // greek small letter iota 
+            "iota",         // greek small letter iota
             "kappa",        // greek small letter kappa
             "lambda",       // greek small letter lambda
             "mu",           // greek small letter mu
@@ -724,7 +724,7 @@ int indexOfAmpersand
             "upsilon",      // greek small letter upsilon
             "phi",          // greek small letter phi
             "chi",          // greek small letter chi
-            "psi",          // greek small letter psi   
+            "psi",          // greek small letter psi
             "omega",        // greek small letter omega
             "thetasym",     // greek small letter theta symbol, U03D1 NEW
             "upsih",        // greek upsilon with hook symbol
@@ -755,71 +755,71 @@ int indexOfAmpersand
             "rsaquo",      // single right-pointing angle quotation mark, U203A ISO proposed
             "oline",       // overline, spacing overscore
             "frasl",       // fraction slash
-            "image",       // blackletter capital I, =imaginary part, U2111 ISOamso 
-            "weierp",      // script capital P, =power set, =Weierstrass p, U2118 ISOamso 
-            "real",        // blackletter capital R, =real part symbol, U211C ISOamso 
-            "trade",       // trade mark sign, U2122 ISOnum 
-            "alefsym",     // alef symbol, =first transfinite cardinal, U2135 NEW 
-            "larr",        // leftwards arrow, U2190 ISOnum 
+            "image",       // blackletter capital I, =imaginary part, U2111 ISOamso
+            "weierp",      // script capital P, =power set, =Weierstrass p, U2118 ISOamso
+            "real",        // blackletter capital R, =real part symbol, U211C ISOamso
+            "trade",       // trade mark sign, U2122 ISOnum
+            "alefsym",     // alef symbol, =first transfinite cardinal, U2135 NEW
+            "larr",        // leftwards arrow, U2190 ISOnum
             "uarr",        // upwards arrow, U2191 ISOnum
-            "rarr",        // rightwards arrow, U2192 ISOnum 
-            "darr",        // downwards arrow, U2193 ISOnum 
-            "harr",        // left right arrow, U2194 ISOamsa 
-            "crarr",       // downwards arrow with corner leftwards, =carriage return, U21B5 NEW 
-            "lArr",        // leftwards double arrow, U21D0 ISOtech 
-            "uArr",        // upwards double arrow, U21D1 ISOamsa 
-            "rArr",        // rightwards double arrow, U21D2 ISOtech 
-            "dArr",        // downwards double arrow, U21D3 ISOamsa 
-            "hArr",        // left right double arrow, U21D4 ISOamsa 
-            "forall",      // for all, U2200 ISOtech 
-            "part",        // partial differential, U2202 ISOtech  
-            "exist",       // there exists, U2203 ISOtech 
-            "empty",       // empty set, =null set, =diameter, U2205 ISOamso 
-            "nabla",       // nabla, =backward difference, U2207 ISOtech 
-            "isin",        // element of, U2208 ISOtech 
-            "notin",       // not an element of, U2209 ISOtech 
-            "ni",          // contains as member, U220B ISOtech 
-            "prod",        // n-ary product, =product sign, U220F ISOamsb 
-            "sum",         // n-ary sumation, U2211 ISOamsb 
-            "minus",       // minus sign, U2212 ISOtech 
-            "lowast",      // asterisk operator, U2217 ISOtech 
-            "radic",       // square root, =radical sign, U221A ISOtech 
-            "prop",        // proportional to, U221D ISOtech 
-            "infin",       // infinity, U221E ISOtech 
-            "ang",         // angle, U2220 ISOamso 
-            "and",         // logical and, =wedge, U2227 ISOtech 
-            "or",          // logical or, =vee, U2228 ISOtech 
-            "cap",         // intersection, =cap, U2229 ISOtech 
-            "cup",         // union, =cup, U222A ISOtech 
-            "int",         // integral, U222B ISOtech 
-            "there4",      // therefore, U2234 ISOtech 
-            "sim",         // tilde operator, =varies with, =similar to, U223C ISOtech 
-            "cong",        // approximately equal to, U2245 ISOtech 
-            "asymp",       // almost equal to, =asymptotic to, U2248 ISOamsr 
-            "ne",          // not equal to, U2260 ISOtech 
-            "equiv",       // identical to, U2261 ISOtech 
-            "le",          // less-than or equal to, U2264 ISOtech 
-            "ge",          // greater-than or equal to, U2265 ISOtech 
-            "sub",         // subset of, U2282 ISOtech 
-            "sup",         // superset of, U2283 ISOtech 
-            "nsub",        // not a subset of, U2284 ISOamsn 
-            "sube",        // subset of or equal to, U2286 ISOtech 
-            "supe",        // superset of or equal to, U2287 ISOtech 
-            "oplus",       // circled plus, =direct sum, U2295 ISOamsb 
-            "otimes",      // circled times, =vector product, U2297 ISOamsb 
-            "perp",        // up tack, =orthogonal to, =perpendicular, U22A5 ISOtech 
-            "sdot",        // dot operator, U22C5 ISOamsb 
-            "lceil",       // left ceiling, =apl upstile, U2308, ISOamsc  
-            "rceil",       // right ceiling, U2309, ISOamsc  
-            "lfloor",      // left floor, =apl downstile, U230A, ISOamsc  
-            "rfloor",      // right floor, U230B, ISOamsc  
-            "lang",        // left-pointing angle bracket, =bra, U2329 ISOtech 
-            "rang",        // right-pointing angle bracket, =ket, U232A ISOtech 
-            "loz",         // lozenge, U25CA ISOpub 
-            "spades",      // black spade suit, U2660 ISOpub 
-            "clubs",       // black club suit, =shamrock, U2663 ISOpub 
-            "hearts",      // black heart suit, =valentine, U2665 ISOpub 
-            "diams"        // black diamond suit, U2666 ISOpub 
+            "rarr",        // rightwards arrow, U2192 ISOnum
+            "darr",        // downwards arrow, U2193 ISOnum
+            "harr",        // left right arrow, U2194 ISOamsa
+            "crarr",       // downwards arrow with corner leftwards, =carriage return, U21B5 NEW
+            "lArr",        // leftwards double arrow, U21D0 ISOtech
+            "uArr",        // upwards double arrow, U21D1 ISOamsa
+            "rArr",        // rightwards double arrow, U21D2 ISOtech
+            "dArr",        // downwards double arrow, U21D3 ISOamsa
+            "hArr",        // left right double arrow, U21D4 ISOamsa
+            "forall",      // for all, U2200 ISOtech
+            "part",        // partial differential, U2202 ISOtech
+            "exist",       // there exists, U2203 ISOtech
+            "empty",       // empty set, =null set, =diameter, U2205 ISOamso
+            "nabla",       // nabla, =backward difference, U2207 ISOtech
+            "isin",        // element of, U2208 ISOtech
+            "notin",       // not an element of, U2209 ISOtech
+            "ni",          // contains as member, U220B ISOtech
+            "prod",        // n-ary product, =product sign, U220F ISOamsb
+            "sum",         // n-ary sumation, U2211 ISOamsb
+            "minus",       // minus sign, U2212 ISOtech
+            "lowast",      // asterisk operator, U2217 ISOtech
+            "radic",       // square root, =radical sign, U221A ISOtech
+            "prop",        // proportional to, U221D ISOtech
+            "infin",       // infinity, U221E ISOtech
+            "ang",         // angle, U2220 ISOamso
+            "and",         // logical and, =wedge, U2227 ISOtech
+            "or",          // logical or, =vee, U2228 ISOtech
+            "cap",         // intersection, =cap, U2229 ISOtech
+            "cup",         // union, =cup, U222A ISOtech
+            "int",         // integral, U222B ISOtech
+            "there4",      // therefore, U2234 ISOtech
+            "sim",         // tilde operator, =varies with, =similar to, U223C ISOtech
+            "cong",        // approximately equal to, U2245 ISOtech
+            "asymp",       // almost equal to, =asymptotic to, U2248 ISOamsr
+            "ne",          // not equal to, U2260 ISOtech
+            "equiv",       // identical to, U2261 ISOtech
+            "le",          // less-than or equal to, U2264 ISOtech
+            "ge",          // greater-than or equal to, U2265 ISOtech
+            "sub",         // subset of, U2282 ISOtech
+            "sup",         // superset of, U2283 ISOtech
+            "nsub",        // not a subset of, U2284 ISOamsn
+            "sube",        // subset of or equal to, U2286 ISOtech
+            "supe",        // superset of or equal to, U2287 ISOtech
+            "oplus",       // circled plus, =direct sum, U2295 ISOamsb
+            "otimes",      // circled times, =vector product, U2297 ISOamsb
+            "perp",        // up tack, =orthogonal to, =perpendicular, U22A5 ISOtech
+            "sdot",        // dot operator, U22C5 ISOamsb
+            "lceil",       // left ceiling, =apl upstile, U2308, ISOamsc
+            "rceil",       // right ceiling, U2309, ISOamsc
+            "lfloor",      // left floor, =apl downstile, U230A, ISOamsc
+            "rfloor",      // right floor, U230B, ISOamsc
+            "lang",        // left-pointing angle bracket, =bra, U2329 ISOtech
+            "rang",        // right-pointing angle bracket, =ket, U232A ISOtech
+            "loz",         // lozenge, U25CA ISOpub
+            "spades",      // black spade suit, U2660 ISOpub
+            "clubs",       // black club suit, =shamrock, U2663 ISOpub
+            "hearts",      // black heart suit, =valentine, U2665 ISOpub
+            "diams"        // black diamond suit, U2666 ISOpub
         };
     }
 }
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index 808ea0749a1..5e08c084d76 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -667,7 +667,7 @@ private void ConvertInMemoryToMSBuildProject()
                     )
                 {
                     // If it's minor upgrade, or nothing changed and the project was already TV 4.0 or higher,
-                    // set the ToolsVersion back to its old value. 
+                    // set the ToolsVersion back to its old value.
                     xmakeProject.ToolsVersion = oldToolsVersion;
                 }
             }
@@ -888,7 +888,7 @@ private bool FixTargetFrameworkSubset()
             {
                 if (String.Equals(propertyElement.Name, XMakeProjectStrings.TargetFrameworkSubset, StringComparison.OrdinalIgnoreCase))
                 {
-                    // For the Client profile, which was the only profile supported in Orcas SP1, we want to replace 
+                    // For the Client profile, which was the only profile supported in Orcas SP1, we want to replace
                     // <TargetFrameworkSubset/> with <TargetFrameworkProfile/>.
                     if (String.Equals(propertyElement.Value, XMakeProjectStrings.ClientProfile, StringComparison.OrdinalIgnoreCase))
                     {
@@ -899,7 +899,7 @@ private bool FixTargetFrameworkSubset()
 
                     // In all cases, <TargetFrameworkSubset/> is no longer supported.  If it comes from the project
                     // that we're converting, then we forcibly remove it.  If it comes from some import... the user is
-                    // on their own.  
+                    // on their own.
                     if (propertyElement.ContainingProject == xmakeProject)
                     {
                         propertyElement.Parent.RemoveChild(propertyElement);
@@ -957,8 +957,8 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
             // local function: wraps specified string value into Exists('value')
             Func<string, string> exists = s => string.Format(CultureInfo.InvariantCulture, "Exists('{0}')", s);
 
-            // local function: 
-            // Creates property group element containing one property fsharpDev12PlusProperty with value 'path'. 
+            // local function:
+            // Creates property group element containing one property fsharpDev12PlusProperty with value 'path'.
             // If addCondition is true, property group will have Exists(path) condition
             Action<string, ProjectElementContainer> appendPropertyGroupForDev12PlusTargetsPath =
                 (path, parent) =>
@@ -1061,7 +1061,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
 
                 someNonNullImportElement.Parent.InsertBeforeChild(chooseElement, someNonNullImportElement);
 
-                // Expected fragment of the project file after upgrade 
+                // Expected fragment of the project file after upgrade
                 //<Choose>
                 //  <When Condition="'$(VisualStudioVersion)' == '11.0'">
                 //    <PropertyGroup>
@@ -1074,7 +1074,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 //    </PropertyGroup>
                 //  </Otherwise>
                 //</Choose>
-                //<Import Project="$(FSharpTargetsPath)" Condition="Exists('$(FSharpTargetsPath)')" />           
+                //<Import Project="$(FSharpTargetsPath)" Condition="Exists('$(FSharpTargetsPath)')" />
 
                 var whenVsVersionIsDev11 = xmakeProject.CreateWhenElement("'$(VisualStudioVersion)' == '11.0'");
                 chooseElement.AppendChild(whenVsVersionIsDev11);
@@ -1148,7 +1148,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 }
             }
 
-            // try to find reference to FSharp.Core 
+            // try to find reference to FSharp.Core
             ProjectItemElement fsharpCoreItem = null;
             foreach (var item in xmakeProject.Items.Where(x => x.ItemType == ReferenceItemType))
             {
diff --git a/src/Deprecated/Engine.UnitTests/BatchingEngine_Tests.cs b/src/Deprecated/Engine.UnitTests/BatchingEngine_Tests.cs
index 591373a9614..affbc14d425 100644
--- a/src/Deprecated/Engine.UnitTests/BatchingEngine_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BatchingEngine_Tests.cs
@@ -33,7 +33,7 @@ private static string ExpandItemsIntoString
             string expression
             )
         {
-            
+
             Expander itemExpander = new Expander(new ReadOnlyLookup(bucket.Lookup), null, ExpanderOptions.ExpandItems);
             return itemExpander.ExpandAllIntoString(expression, (new XmlDocument()).CreateAttribute("foo"));
         }
@@ -216,7 +216,7 @@ public void NoItemsConsumed()
         /// <summary>
         /// Missing unittest found by mutation testing.
         /// REASON TEST WASN'T ORIGINALLY PRESENT: Missed test.
-        /// 
+        ///
         /// This test ensures that two items with duplicate attributes end up in exactly one batching
         /// bucket.
         /// </summary>
@@ -227,7 +227,7 @@ public void Regress_Mutation_DuplicateBatchingBucketsAreFoldedTogether()
             parameters.Add("%(File.Culture)");
 
             Hashtable itemsByType = new Hashtable(StringComparer.OrdinalIgnoreCase);
-            
+
             BuildItemGroup items = new BuildItemGroup();
             items.AddNewItem("File", "a.foo");
             items.AddNewItem("File", "b.foo"); // Need at least two items for this test case to ensure multiple buckets might be possible
diff --git a/src/Deprecated/Engine.UnitTests/BuildItemDefinitionGroupXml_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildItemDefinitionGroupXml_Tests.cs
index 09bad8c8d39..98e5575a033 100644
--- a/src/Deprecated/Engine.UnitTests/BuildItemDefinitionGroupXml_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildItemDefinitionGroupXml_Tests.cs
@@ -184,7 +184,7 @@ public void BasicItemDefinitionInProject()
                     <CppCompile>
                       <Defines>DEBUG</Defines>
                     </CppCompile>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemGroup>
                     <CppCompile Include='b.cpp'/>
                   </ItemGroup>
@@ -211,7 +211,7 @@ public void EscapingInItemDefinitionInProject()
                     <i Condition=`'%24'=='$'`>
                       <m Condition=`'%24'=='$'`>%24(xyz)</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -236,7 +236,7 @@ public void ItemDefinitionForOtherItemType()
                     <j>
                       <m>m1</m>
                     </j>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -261,13 +261,13 @@ public void RedefinitionLastOneWins()
                       <m>m1</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i>
                       <m>m2</m>
                       <o>o1</o>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)-%(i.n)-%(i.o)]`/>
                   </Target>
@@ -290,7 +290,7 @@ public void ItemExpressionInDefaultMetadataValueErrors()
                     <i>
                       <m>@(x)</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                 </Project>
             ", logger);
             p.Build("t");
@@ -341,16 +341,16 @@ public void MetadataConditionOnItemDefinition()
                     <j>
                       <n>n1</n>
                     </j>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i Condition=`'%(m)'=='m1'`>
                       <m>m2</m>
                     </i>
                     <!-- verify j metadata is distinct -->
                     <j Condition=`'%(j.n)'=='n1' and '%(n)'=='n1'`>
-                      <n>n2</n>   
+                      <n>n2</n>
                     </j>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                     <Message Text=`[%(j.n)]`/>
@@ -375,12 +375,12 @@ public void QualifiedMetadataConditionOnItemDefinitionBothQualifiedAndUnqualifie
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i Condition=`'%(i.m)'=='m1' and '%(m)'=='m1'`>
                       <m>m2</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -404,12 +404,12 @@ public void FalseMetadataConditionOnItemDefinitionBothQualifiedAndUnqualified()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i Condition=`'%(m)'=='m2' or '%(i.m)'!='m1'`>
                       <m>m3</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -434,12 +434,12 @@ public void MetadataConditionOnItemDefinitionChildBothQualifiedAndUnqualified()
                       <m>m1</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i>
                       <m Condition=`'%(m)'=='m1' and '%(n)'=='n1' and '%(i.m)'=='m1'`>m2</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -464,12 +464,12 @@ public void FalseMetadataConditionOnItemDefinitionChildBothQualifiedAndUnqualifi
                       <m>m1</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i>
                       <m Condition=`'%(m)'=='m2' or !('%(n)'=='n1') or '%(i.m)' != 'm1'`>m3</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -493,12 +493,12 @@ public void MetadataConditionOnItemDefinitionAndChildQualifiedWithUnrelatedItemT
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i Condition=`'%(j.m)'=='' and '%(j.m)'!='x'`>
                       <m Condition=`'%(j.m)'=='' and '%(j.m)'!='x'`>m2</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -511,8 +511,8 @@ public void MetadataConditionOnItemDefinitionAndChildQualifiedWithUnrelatedItemT
 
         /// <summary>
         /// Make ItemDefinitionGroup inside a target produce a nice error.
-        /// It will normally produce an error due to the invalid child tag, but 
-        /// we want to error even if there's no child tag. This will make it 
+        /// It will normally produce an error due to the invalid child tag, but
+        /// we want to error even if there's no child tag. This will make it
         /// easier to support it inside targets in a future version.
         /// </summary>
         [Test]
@@ -565,7 +565,7 @@ public void MetadataOnItemWins()
                     <CppCompile>
                       <Defines>DEBUG</Defines>
                     </CppCompile>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(CppCompile.Identity)==%(CppCompile.Defines)]`/>
                   </Target>
@@ -591,7 +591,7 @@ public void MixtureOfItemAndDefaultMetadata()
                     <CppCompile>
                       <Defines>DEBUG</Defines>
                     </CppCompile>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(CppCompile.Identity)==%(CppCompile.Defines)]`/>
                     <Message Text=`[%(CppCompile.Identity)==%(CppCompile.WarningLevel)]`/>
@@ -616,7 +616,7 @@ public void IntrinsicTaskModifyingDefaultMetadata()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <ItemGroup>
                       <i>
@@ -658,7 +658,7 @@ public void IntrinsicTaskConsumingDefaultMetadata()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <ItemGroup>
                       <i Condition=`'%(i.m)'=='m1'`>
@@ -689,13 +689,13 @@ public void DefinitionInImportedFile()
                     <CppCompile>
                       <Defines>DEBUG</Defines>
                     </CppCompile>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                 </Project>
             ");
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
                     <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <ItemGroup>
-                        <CppCompile Include='a.cpp'/>                      
+                        <CppCompile Include='a.cpp'/>
                       </ItemGroup>
                       <Import Project='" + importedFile + @"'/>
                       <Target Name=`t`>
@@ -725,7 +725,7 @@ public void ProjectAddNewItemPicksUpProjectItemDefinitions()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                 </Project>
                 ");
 
@@ -746,7 +746,7 @@ public void ProjectAddNewItemExistingGroupPicksUpProjectItemDefinitions()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemGroup>
                     <i Include='i2'>
                       <m>m2</m>
@@ -775,7 +775,7 @@ public void ItemsEmittedByTaskPickUpItemDefinitions()
                       <m>m1</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <CreateItem Include=`i1` AdditionalMetadata=`n=n2`>
                       <Output ItemName=`i` TaskParameter=`Include`/>
@@ -801,7 +801,7 @@ public void ItemsEmittedByIntrinsicTaskPickUpItemDefinitions()
                       <m>m1</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <ItemGroup>
                       <i Include=`i1`>
@@ -829,10 +829,10 @@ public void MutualReferenceToDefinition1()
                       <m>m1</m>
                       <n>~%(m)~</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                     <ItemGroup>
                       <i Include=`i1`/>
-                    </ItemGroup>   
+                    </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)][%(i.n)]`/>
                   </Target>
@@ -855,10 +855,10 @@ public void MutualReferenceToDefinition2()
                       <m>~%(n)~</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                     <ItemGroup>
                       <i Include=`i1`/>
-                    </ItemGroup>   
+                    </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)][%(i.n)]`/>
                   </Target>
@@ -882,10 +882,10 @@ public void MutualReferenceToDefinition3()
                       <n>%(i.m)</n>
                       <o>%(j.m)</o>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                     <ItemGroup>
                       <i Include=`i1`/>
-                    </ItemGroup>   
+                    </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)][%(i.n)][%(i.o)]`/>
                   </Target>
@@ -914,7 +914,7 @@ public void ProjectReevaluationReevaluatesItemDefinitions()
                       <Defines Condition=`'$(BuildFlavor)'=='ret'`>$(Defines);RETAIL</Defines>
                       <Defines Condition=`'$(BuildFlavor)'=='chk'`>$(Defines);DEBUG</Defines>
                     </CppCompile>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(CppCompile.Identity)==%(CppCompile.Defines)]`/>
                   </Target>
@@ -957,7 +957,7 @@ public void MSBuildCallDoesNotAffectCallingProjectsDefinitions()
                     <i>
                       <m>m2</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=""t"">
                     <Message Text=""[CHILD:%(i.m)]""/>
                   </Target>
@@ -978,7 +978,7 @@ public void MSBuildCallDoesNotAffectCallingProjectsDefinitions()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[PARENT-before:%(i.m)]`/>
                     <MSBuild Projects=`" + otherProject + @"`/>
@@ -1015,7 +1015,7 @@ public void DefaultMetadataTravelWithTargetOutputs()
                     <i>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=""t"" Outputs=""@(i)"">
                     <Message Text=""[CHILD:%(i.Identity):m=%(i.m),n=%(i.n)]""/>
                   </Target>
@@ -1058,7 +1058,7 @@ private static ItemDefinitionLibrary NewAndEvaluateItemDefinitionLibraryXml(XmlE
             library.Add(group);
 
             BuildPropertyGroup properties = new BuildPropertyGroup();
-            properties.SetProperty("p1", "v1");            
+            properties.SetProperty("p1", "v1");
             library.Evaluate(properties);
 
             return library;
diff --git a/src/Deprecated/Engine.UnitTests/BuildItemGroupProxy_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildItemGroupProxy_Tests.cs
index 36d2e5a250b..62ba6089195 100644
--- a/src/Deprecated/Engine.UnitTests/BuildItemGroupProxy_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildItemGroupProxy_Tests.cs
@@ -21,7 +21,7 @@ public class ItemGroupProxy_Tests
     {
         [Test]
         public void BasicProxying()
-        {          
+        {
             BuildItemGroup ig = new BuildItemGroup();
             BuildItem i1 = new BuildItem("name1", "value1");
             i1.SetMetadata("myMetaName", "myMetaValue");
diff --git a/src/Deprecated/Engine.UnitTests/BuildItemGroup_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildItemGroup_Tests.cs
index d3bfa33cdfe..423558040e6 100644
--- a/src/Deprecated/Engine.UnitTests/BuildItemGroup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildItemGroup_Tests.cs
@@ -223,7 +223,7 @@ public void AddExistingItemAt()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                 </Project>
             ", logger);
 
@@ -249,9 +249,9 @@ public void MutualReferenceToMetadata()
                     <i Include=`i1`>
                       <m>m1</m>
                       <m>%(m);m2</m>
-                      <m Condition='false'>%(m);m3</m> 
+                      <m Condition='false'>%(m);m3</m>
                     </i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -276,9 +276,9 @@ public void MutualReferenceToMetadataQualified()
                     <i Include=`i1`>
                       <m>m1</m>
                       <m>%(i.m);m2</m>
-                      <m Condition='false'>%(m);m3</m> 
+                      <m Condition='false'>%(m);m3</m>
                     </i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -303,14 +303,14 @@ public void MutualReferenceToMetadataMixed()
                     <i>
                       <l>l1</l>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemGroup>
                       <i Include=`i1`>
                       <n>overridden</n>
                       <m>m1</m>
                       <n>%(l);%(i.l);n1;%(m);%(i.m);%(o);%(i.o);n2</n>
                     </i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.n)]`/>
                   </Target>
@@ -335,12 +335,12 @@ public void MetadataReferenceToMetadataDefinition()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemGroup>
                     <i Include=`i1`>
                       <m>%(m);m2</m>
                     </i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -365,7 +365,7 @@ public void EscapedMetadataReference()
                     <i Include=`i1`>
                       <m>%25(m)</m>
                     </i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -529,11 +529,11 @@ public void AddItem1()
 
             item = CreatePersistedBuildItem(ig, "i", "i2");
             group.AddItem(item);
-            VerifyPersistedItemPosition(group, item, 1); // should be 2nd      
+            VerifyPersistedItemPosition(group, item, 1); // should be 2nd
 
             item = CreatePersistedBuildItem(ig, "i", "i0");
             group.AddItem(item);
-            VerifyPersistedItemPosition(group, item, 0); // should be first              
+            VerifyPersistedItemPosition(group, item, 0); // should be first
         }
 
         [Test]
@@ -559,7 +559,7 @@ public void AddItemEmptyNonPersistedGroup()
             group.AddItem(item);
             Assertion.AssertEquals(item, group[1]); // should be last again
         }
-        
+
         private static void VerifyPersistedItemPosition(BuildItemGroup group, BuildItem item, int position)
         {
             Assertion.AssertEquals(group[position].Include, group.ItemGroupElement.ChildNodes[position].Attributes["Include"].Value);
diff --git a/src/Deprecated/Engine.UnitTests/BuildItem_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildItem_Tests.cs
index 31e5f7f33bc..b9358208874 100644
--- a/src/Deprecated/Engine.UnitTests/BuildItem_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildItem_Tests.cs
@@ -95,7 +95,7 @@ public void Metadata()
 
             // Custom metadata count only
             Assertion.AssertEquals(2, item.CustomMetadataCount);
-            
+
             // All metadata count
             Assertion.AssertEquals(2 + FileUtilities.ItemSpecModifiers.All.Length, item.MetadataCount);
         }
@@ -103,7 +103,7 @@ public void Metadata()
         [Test]
         public void MetadataIncludesItemDefinitionMetadata()
         {
-            // Get an item of type "i" that has an item definition library 
+            // Get an item of type "i" that has an item definition library
             // for type "i" that has default value "m1" for metadata "m"
             // and has value "n1" for metadata "n"
             BuildItem item = GetXmlBackedItemWithDefinitionLibrary();
@@ -195,7 +195,7 @@ internal static BuildItem GetXmlBackedItemWithDefinitionLibrary()
             item.SetMetadata("n", "n1");
             return item;
         }
-        
+
         private static BuildItem CreateBuildItemFromXmlDocument(XmlDocument doc)
         {
             ItemDefinitionLibrary itemDefinitionLibrary = new ItemDefinitionLibrary(new Project());
diff --git a/src/Deprecated/Engine.UnitTests/BuildRequest_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildRequest_Tests.cs
index e9410241358..99734d73427 100644
--- a/src/Deprecated/Engine.UnitTests/BuildRequest_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildRequest_Tests.cs
@@ -60,8 +60,8 @@ public void TestConstructor1andProperties()
             Assert.IsTrue(string.Compare(buildProperty, "Value", StringComparison.OrdinalIgnoreCase) == 0, "Expected hashtable to contain a property group with a value of value");
             Assert.IsTrue((firstConstructorRequest.TargetNames.Length == 1) && (string.Compare("Build", firstConstructorRequest.TargetNames[0], StringComparison.OrdinalIgnoreCase) == 0), "Expected to have one target with a value of Build");
             Assert.IsTrue(string.Compare("ProjectFileName", firstConstructorRequest.ProjectFileName, StringComparison.OrdinalIgnoreCase) == 0, "Expected project file to be called ProjecFileName");
-      
-        
+
+
         }
 
         /// <summary>
@@ -158,8 +158,8 @@ public void GetTargetNamesList()
         {
             int nodeProxyId = 1;
             string projectFileName = "ProjectFileName";
-            string[] targetNames = null; 
-            
+            string[] targetNames = null;
+
             Dictionary<string, string> dictionary = null;
             int requestId = 1;
 
@@ -171,7 +171,7 @@ public void GetTargetNamesList()
             targetNames = new string[] { "Build" };
             buildRequest = new BuildRequest(nodeProxyId, projectFileName, targetNames, (IDictionary)dictionary, null, requestId, false, false);
             Assert.IsTrue(string.Compare("Build", buildRequest.GetTargetNamesList(),StringComparison.OrdinalIgnoreCase)==0, "Expected to see Build as the targetNamesList");
-           
+
             //Test the case where we pass in multiple targets
             targetNames = new string[] {"Build","Build2"};
             buildRequest = new BuildRequest(nodeProxyId, projectFileName, targetNames, (IDictionary)dictionary, null, requestId, false, false);
diff --git a/src/Deprecated/Engine.UnitTests/BuildResult_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildResult_Tests.cs
index fd513ec6bff..4a0f621d03c 100644
--- a/src/Deprecated/Engine.UnitTests/BuildResult_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildResult_Tests.cs
@@ -23,7 +23,7 @@ public class BuildResult_Tests
     {
         // A build result where the taskoutputs are null
         private BuildResult resultNoOutputs;
-        
+
         // A build result where the task outputs are acutal values
         private BuildResult resultWithOutputs;
 
@@ -36,7 +36,7 @@ public class BuildResult_Tests
         public void Initialize()
         {
             // Create some items and place them in a dictionary
-            // Add some include information so that when we check the final 
+            // Add some include information so that when we check the final
             // item spec we can verify that the item was recreated properly
             buildItem1.Include = "TestInclude1";
             buildItem2.Include = "TestInclude2";
@@ -76,13 +76,13 @@ public void TestConstructorsAndProperties()
             Assert.AreEqual(0, resultWithOutputsFromBuildResult.HandleId, "Expected resultWithOutputsFromBuildResult.NodeProxyId to be 0");
             Assert.AreEqual(1, resultWithOutputsFromBuildResult.RequestId, "Expected resultWithOutputsFromBuildResult.RequestId to be 1");
             Assert.AreEqual(2, resultWithOutputsFromBuildResult.ProjectId, "Expected resultWithOutputsFromBuildResult.ProjectId to be 1");
-            
+
             // Test some setters which are not set otherwise during the tests
             resultWithOutputsFromBuildResult.HandleId = 3;
             resultWithOutputsFromBuildResult.RequestId = 4;
             Assert.AreEqual(3, resultWithOutputsFromBuildResult.HandleId, "Expected resultWithOutputsFromBuildResult.NodeProxyId to be 3");
             Assert.AreEqual(4, resultWithOutputsFromBuildResult.RequestId, "Expected resultWithOutputsFromBuildResult.RequestId to be 4");
-            
+
             // Test the setting of RequestId
             resultWithOutputsFromBuildResult.RequestId = 4;
             Assert.AreEqual(4, resultWithOutputsFromBuildResult.RequestId, "Expected resultWithOutputsFromBuildResult.RequestId to be 4");
diff --git a/src/Deprecated/Engine.UnitTests/BuildTask_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildTask_Tests.cs
index e86fcf19d40..cace4161d89 100644
--- a/src/Deprecated/Engine.UnitTests/BuildTask_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildTask_Tests.cs
@@ -26,10 +26,10 @@ public class BuildTask_Tests
         /***********************************************************************
          * Test:            SetGetHostObjectInProject
          * Owner:           RGoel
-         * 
-         * Slightly more advanced unit test that loads a real project, finds the 
+         *
+         * Slightly more advanced unit test that loads a real project, finds the
          * appropriate task, and sets the host object for it.
-         * 
+         *
          **********************************************************************/
         [Test]
         public void SetGetHostObjectInProject()
@@ -42,7 +42,7 @@ public void SetGetHostObjectInProject()
                         <MakeDir Directories=`c:\rajeev` />
                         <Csc Sources=`foo.cs` />
                     </Target>
-                
+
                 </Project>
                 ";
 
diff --git a/src/Deprecated/Engine.UnitTests/CacheEntry_Tests.cs b/src/Deprecated/Engine.UnitTests/CacheEntry_Tests.cs
index a54dd736553..f01add7ddd7 100644
--- a/src/Deprecated/Engine.UnitTests/CacheEntry_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/CacheEntry_Tests.cs
@@ -49,7 +49,7 @@ public void CacheEntryGettersDefaultConstructors()
             BuildItemCacheEntry tice = new BuildItemCacheEntry();
             Assertion.AssertEquals(null, tice.Name);
             Assertion.AssertEquals(null, tice.BuildItems);
-            
+
             tice.Name = "tice";
             tice.BuildItems = buildItems;
             Assertion.AssertEquals("tice", tice.Name);
@@ -81,7 +81,7 @@ public void CacheEntryGettersDefaultConstructors()
         public void IsEquivalentProperty()
         {
             PropertyCacheEntry e = new PropertyCacheEntry("name", "value");
-            
+
             Assert.IsFalse(e.IsEquivalent(null));
             Assert.IsFalse(e.IsEquivalent(new BuildItemCacheEntry()));
             Assert.IsFalse(e.IsEquivalent(new PropertyCacheEntry()));
@@ -154,7 +154,7 @@ public void TestCacheEntryCustomSerialization()
                 BuildItemCacheEntry buildItemEntry = new BuildItemCacheEntry("Badger", buildItems);
                 BuildResultCacheEntry buildResultEntry = new BuildResultCacheEntry("Koi", buildItems, true);
                 PropertyCacheEntry propertyEntry = new PropertyCacheEntry("Seagull", "bread");
-                
+
                 stream.Position = 0;
                 // Serialize
                 buildItemEntry.WriteToStream(writer);
diff --git a/src/Deprecated/Engine.UnitTests/CacheManager_Tests.cs b/src/Deprecated/Engine.UnitTests/CacheManager_Tests.cs
index a29953fe147..7df64d0b0aa 100644
--- a/src/Deprecated/Engine.UnitTests/CacheManager_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/CacheManager_Tests.cs
@@ -34,7 +34,7 @@ public class CacheManager_Tests
         public void Initialize()
         {
             // Create some items and place them in a dictionary
-            // Add some include information so that when we check the final 
+            // Add some include information so that when we check the final
             // item spec we can verify that the item was recreated properly
             BuildItem buildItem1 = new BuildItem("BuildItem1", "Item1");
             buildItem1.Include = "TestInclude1";
@@ -42,7 +42,7 @@ public void Initialize()
             buildItems[0] = buildItem1;
             Dictionary<object, object> dictionary = new Dictionary<object, object>();
             dictionary.Add("TaskItems", buildItems);
-            
+
             Hashtable resultByTargetSuccess = new Hashtable(StringComparer.OrdinalIgnoreCase);
             resultByTargetSuccess.Add("TaskItems", Target.BuildState.CompletedSuccessfully);
             Hashtable resultByTargetFailure = new Hashtable(StringComparer.OrdinalIgnoreCase);
@@ -111,21 +111,21 @@ public void TestRequestCaching()
             string[] targets = new string[1]; targets[0] = "Target1";
             BuildRequest length1Request = new BuildRequest(1, "test.proj", targets, new BuildPropertyGroup(), null, 1, true, false);
             Assert.IsNull(cacheManager.GetCachedBuildResult(length1Request, out actuallyBuiltTargets), "Expect a null return value if no scope");
-            
+
             // Test the case when the scope exists but is empty
             CacheScope cacheScope = cacheManager.GetCacheScope("test.proj", new BuildPropertyGroup(), "3.5", CacheContentType.BuildResults);
             Assert.IsNull(cacheManager.GetCachedBuildResult(length1Request, out actuallyBuiltTargets), "Expect a null return value if scope is empty");
-            
+
             // Test the case when the scope exists but contains wrong data
             CacheEntry cacheEntry = new BuildResultCacheEntry("Target2", null, true);
             cacheManager.SetCacheEntries(new CacheEntry[] { cacheEntry }, "test.proj", new BuildPropertyGroup(), "3.5", CacheContentType.BuildResults);
             Assert.IsNull(cacheManager.GetCachedBuildResult(length1Request, out actuallyBuiltTargets), "Expect a null return value if scope contains wrong data");
-            
+
             // Test the case when everything is correct
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.defaultTargetCacheName, string.Empty));
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.initialTargetCacheName, string.Empty));
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.projectIdCacheName, "1"));
-            
+
             cacheEntry = new BuildResultCacheEntry("Target1", null, true);
             cacheManager.SetCacheEntries(new CacheEntry[] { cacheEntry }, "test.proj", new BuildPropertyGroup(), "3.5", CacheContentType.BuildResults);
             BuildResult buildResult = cacheManager.GetCachedBuildResult(length1Request, out actuallyBuiltTargets);
@@ -139,7 +139,7 @@ public void TestRequestCaching()
             targets = new string[2]; targets[0] = "Target2"; targets[1] = "Target3";
             BuildRequest length2Request = new BuildRequest(1, "test.proj", targets, new BuildPropertyGroup(), null, 1, true, false);
             Assert.IsNull(cacheManager.GetCachedBuildResult(length2Request, out actuallyBuiltTargets), "Expect a null return value if partial data in the scope");
-            
+
             // Test the correctness case for multiple targets
             cacheEntry = new BuildResultCacheEntry("Target3", null, true);
             cacheManager.SetCacheEntries(new CacheEntry[] { cacheEntry }, "test.proj", new BuildPropertyGroup(), "3.5", CacheContentType.BuildResults);
@@ -168,7 +168,7 @@ public void TestRequestCachingDefaultInitialTargets()
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.defaultTargetCacheName, "Target1;Target2"));
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.initialTargetCacheName, "Initial1"));
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.projectIdCacheName, "5"));
-            
+
             CacheEntry cacheEntry = new BuildResultCacheEntry("Initial1", null, true);
             cacheManager.SetCacheEntries(new CacheEntry[] { cacheEntry }, "test.proj", new BuildPropertyGroup(), "3.5", CacheContentType.BuildResults);
             cacheEntry = new BuildResultCacheEntry("Target1", null, true);
diff --git a/src/Deprecated/Engine.UnitTests/CacheScope_Tests.cs b/src/Deprecated/Engine.UnitTests/CacheScope_Tests.cs
index c31074ed5fd..a456c1f074d 100644
--- a/src/Deprecated/Engine.UnitTests/CacheScope_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/CacheScope_Tests.cs
@@ -33,7 +33,7 @@ public class CacheScope_Tests
         public void Initialize()
         {
             // Create some items and place them in a dictionary
-            // Add some include information so that when we check the final 
+            // Add some include information so that when we check the final
             // item spec we can verify that the item was recreated properly
             BuildItem[] buildItems = new BuildItem[1];
             buildItems[0] = new BuildItem("BuildItem1", "Item1");
diff --git a/src/Deprecated/Engine.UnitTests/Choose_Tests.cs b/src/Deprecated/Engine.UnitTests/Choose_Tests.cs
index 01740c10dbf..599b02f4046 100644
--- a/src/Deprecated/Engine.UnitTests/Choose_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Choose_Tests.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.UnitTests
      * Class:   ChooseTests
      * Owner:   davidle
      *
-     * 
+     *
      */
     [TestFixture]
     sealed public class ChooseTests
@@ -61,7 +61,7 @@ public void ExcessivelyNestedChoose()
          * Method:  Basic
          * Owner:   davidle
          *
-         * 
+         *
          */
         [Test]
         public void ChooseNotTaken()
@@ -94,7 +94,7 @@ public void ChooseNotTaken()
         public void NeitherConditionTaken()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <Choose>
                     <When Condition=`1==2`>
@@ -119,7 +119,7 @@ public void NeitherConditionTaken()
         public void OtherwiseTaken()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <Choose>
                     <When Condition=`1==2`>
@@ -148,7 +148,7 @@ public void TwoOtherwiseErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         <When Condition=`true`><PropertyGroup><x/></PropertyGroup></When>
@@ -178,7 +178,7 @@ public void JunkAfterWhenErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         <When Condition=`true`>xyz
@@ -209,7 +209,7 @@ public void JunkAfterOtherwiseErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         <When Condition=`true`>
@@ -242,7 +242,7 @@ public void BogusElementUnderChooseCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         <abc/>
@@ -274,7 +274,7 @@ public void ChooseWithConditionErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose Condition=`true`>
                         <When Condition=`true`>
@@ -304,7 +304,7 @@ public void OtherwiseWithConditionErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         <When Condition=`true`>
@@ -335,7 +335,7 @@ public void JunkUnderChooseErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         abc
@@ -363,7 +363,7 @@ public void JunkUnderChooseErrorCase()
         public void PropertyAssignmentToItemListCase()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <ItemGroup>
                     <x Include=`x1` />
@@ -393,7 +393,7 @@ public void PropertyAssignmentToItemListCase()
         public void ItemListAndPropertiesCase()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <Choose>
                     <When Condition=`1==1`>
@@ -428,7 +428,7 @@ public void ItemGroupInAChooseConditionCase()
             try
             {
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <ItemGroup><x Include=`x1`/></ItemGroup>
                       <Choose>
@@ -455,7 +455,7 @@ public void ItemGroupInAChooseConditionCase()
         public void NestedChooseAndPropertyInConditionCase()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <Choose>
                     <When Condition=`1==1`>
@@ -482,7 +482,7 @@ public void NestedChooseAndPropertyInConditionCase()
         public void ChooseTakesSameWhenInPass1And2()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <PropertyGroup><takefirst>true</takefirst></PropertyGroup>
                   <Choose>
@@ -509,7 +509,7 @@ public void ChooseTakesSameWhenInPass1And2()
         public void ChooseTakesOtherwiseInPass1And2()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <PropertyGroup><takefirst>false</takefirst></PropertyGroup>
                   <PropertyGroup><tookfirst>false</tookfirst></PropertyGroup>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
index 7367de52082..7cf7e0ed76c 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     /// <summary>
     /// Indirection delegate type for AddNewImport Method invocation
     /// </summary>
-    public delegate void AddNewImportDelegate(Project p, string path, string condition); 
+    public delegate void AddNewImportDelegate(Project p, string path, string condition);
 
     /// <summary>
     /// indirection for  tests of Project.AddNewImport and ImportCollection.AddNewImport
@@ -30,7 +30,7 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     public abstract class AddNewImportTests
     {
         #region Indirection Delegates
-     
+
         /// <summary>
         /// Indirection delegate for AddNewImport Method invocation
         /// </summary>
@@ -38,12 +38,12 @@ protected AddNewImportDelegate InvokeAddNewImportMethod
         {
             get;
             set;
-        } 
+        }
 
         #endregion
 
         /// <summary>
-        ///  AddNewImport Test, Empty 
+        ///  AddNewImport Test, Empty
         /// </summary>
         [Test]
         [ExpectedException(typeof(ArgumentException))]
@@ -54,7 +54,7 @@ public void AddNewImportFileName_Empty()
         }
 
         /// <summary>
-        ///  AddNewImport Test, Null 
+        ///  AddNewImport Test, Null
         /// </summary>
         [Test]
         [ExpectedException(typeof(ArgumentNullException))]
@@ -65,7 +65,7 @@ public void AddNewImportFileName_Null()
         }
 
         /// <summary>
-        ///  AddNewImport Test, Where imported file does not exist 
+        ///  AddNewImport Test, Where imported file does not exist
         /// </summary>
         [Test]
         public void AddNewImportFile_DoesNotExist()
@@ -95,7 +95,7 @@ public void AddNewImportFile_NoReadPermissions()
         }
 
         /// <summary>
-        ///  AddNewImport Test, Import a file with an empty condition. 
+        ///  AddNewImport Test, Import a file with an empty condition.
         /// </summary>
         [Test]
         public void AddNewImportFile_EmptyCondition()
@@ -276,7 +276,7 @@ public void AddNewImportStandardTwice()
                 Assertion.AssertEquals(0, p.Imports.Count);
                 object o = p.EvaluatedItems;  // force evaluation of imported projects.
                 Assertion.AssertEquals(2, CompatibilityTestHelpers.CountNodesWithName(p.Xml, "Import"));  // 2 in xml
-                Assertion.AssertEquals(1, p.Imports.Count); // 1 in OM. 
+                Assertion.AssertEquals(1, p.Imports.Count); // 1 in OM.
             }
             finally
             {
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroupCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroupCollection_Tests.cs
index 2e75151dd74..f759aadb7a7 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroupCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroupCollection_Tests.cs
@@ -146,7 +146,7 @@ public void CountOne()
         [Test]
         public void CountImportedOnly()
         {
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Import Project='import.proj' />
                     </Project>
@@ -262,7 +262,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
         {
             if (String.IsNullOrEmpty(importProjectContents))
             {
-                importProjectContents = @" 
+                importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1ImportedItem1 Include='n1iImportedItem1' />
@@ -280,7 +280,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
             if (String.IsNullOrEmpty(parentProjectContents))
             {
-                parentProjectContents = @" 
+                parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nMainItem1 Include='nMainItem1' />
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroup_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroup_Tests.cs
index 3f23ef5418e..2d100b12d75 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroup_Tests.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     /// Test Fixture Class for the v9 Object Model Public Interface Compatibility Tests for the BuildItemGroup Class.
     /// </summary>
     [TestFixture]
-    public sealed class BuildItemGroup_Tests 
+    public sealed class BuildItemGroup_Tests
     {
         #region Common Helpers
         /// <summary>
@@ -89,7 +89,7 @@ public void Cleanup()
         #endregion
 
         /// <summary>
-        /// Example test for BuildItemGroup 
+        /// Example test for BuildItemGroup
         /// ****Don't keep this test once you're done automating****
         /// </summary>
         [Test]
@@ -801,7 +801,7 @@ public void RemoveEvaluatedItem1()
                 Project p = new Project(new Engine());
                 BuildItemGroup group = p.AddNewItemGroup();
                 group.AddNewItem("foos", Path.Combine(ObjectModelHelpers.TempProjectDir, "*.foo"));
-                object o = p.EvaluatedItems; // this causes the failure 
+                object o = p.EvaluatedItems; // this causes the failure
                 group.RemoveItem(p.EvaluatedItems[0]); // Exception thrown here
                 Assertion.Fail("success as failure"); // should not get here due to exception above
             }
@@ -1156,7 +1156,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
         {
             if (String.IsNullOrEmpty(importProjectContents))
             {
-                importProjectContents = @" 
+                importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nImported Include='iImported' />
@@ -1175,7 +1175,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
             if (String.IsNullOrEmpty(parentProjectContents))
             {
-                parentProjectContents = @" 
+                parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1Main Include='iMain' />
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItem_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItem_Tests.cs
index 36346a09aed..6d6f10f2a5a 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItem_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItem_Tests.cs
@@ -119,8 +119,8 @@ public sealed class BuildItem_Tests
         /// <summary>
         /// string array of all Reserved Names for BuildItem name
         /// </summary>
-        private string[] reservedNames = new string[] 
-                { 
+        private string[] reservedNames = new string[]
+                {
                     "VisualStudioProject",
                     "Target",
                     "PropertyGroup",
@@ -400,7 +400,7 @@ public void ConditionGetEmptyString()
         [Test]
         public void ConditionGetFromImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nImported Include='iImported' Condition=""'a' == 'b'"" />
@@ -570,7 +570,7 @@ public void IncludeExcludeGetFromImportedProject()
         }
 
         /// <summary>
-        /// Tests BuildItem.Include attempt Set for an Imported BuildItem 
+        /// Tests BuildItem.Include attempt Set for an Imported BuildItem
         /// </summary>
         [Test]
         [ExpectedException(typeof(InvalidOperationException))]
@@ -957,7 +957,7 @@ public void CustomMetadataCountNamesWithNoCustomMetadata()
         [Test]
         public void CustomMetadataCountNamesWhenComingOnlyFromImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <nImported Include='iImported'>
@@ -988,7 +988,7 @@ public void CustomMetadataCountNamesWhenComingOnlyFromImportedProject()
         [Test]
         public void CustomMetadataCountNamesWhenComingOnlyFromParentProjectNoneFromImport()
         {
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nMain Include='iMain'>
@@ -1020,7 +1020,7 @@ public void CustomMetadataCountNamesWhenComingOnlyFromParentProjectNoneFromImpor
         [Test]
         public void CustomMetadataCountNamesWhenComingFromBothParentAndImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -1030,7 +1030,7 @@ public void CustomMetadataCountNamesWhenComingFromBothParentAndImportedProject()
                             </Project>
                         ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nMain Include='iMain'>
@@ -1146,7 +1146,7 @@ public void MetadataCountNamesFromImportedProjectNoCustomMetadata()
         [Test]
         public void MetadataCountNamesFromImportedProjectWithCustomMetadata()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <nImported Include='iImported'>
@@ -1228,7 +1228,7 @@ public void CopyCustomMetadataToSelf()
         [Test]
         public void CopyCustomMetadataToAnotherBuildItemWithNoCustomMetadataInSameProject()
         {
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1 Include='i1'>
@@ -1258,7 +1258,7 @@ public void CopyCustomMetadataToAnotherBuildItemWithNoCustomMetadataInSameProjec
         [Test]
         public void CopyCustomMetadataToAntherBuildItemWithAllOtherDifferentCustomMetadata()
         {
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1 Include='i1'>
@@ -1293,7 +1293,7 @@ public void CopyCustomMetadataToAntherBuildItemWithAllOtherDifferentCustomMetada
         [Test]
         public void CopyCustomMetadataToAnotherBuildItemWithAllOtherSameCustomMetadata()
         {
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1 Include='i1'>
@@ -1328,7 +1328,7 @@ public void CopyCustomMetadataToAnotherBuildItemWithAllOtherSameCustomMetadata()
         [Test]
         public void CopyCustomMetadataToAnotherBuildItemWithSomeOtherSameCustomMetadata()
         {
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1 Include='i1'>
@@ -1369,7 +1369,7 @@ public void CopyCustomMetadataToAnotherBuildItemWithSomeOtherSameCustomMetadata(
         [Test]
         public void CopyCustomMetadataToNonImportedBuildItemFromAnImportedBuildItem()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -1379,7 +1379,7 @@ public void CopyCustomMetadataToNonImportedBuildItemFromAnImportedBuildItem()
                             </Project>
                         ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nMain Include='iMain'>
@@ -1408,7 +1408,7 @@ public void CopyCustomMetadataToNonImportedBuildItemFromAnImportedBuildItem()
         [ExpectedException(typeof(InvalidOperationException))]
         public void CopyCustomMetadataToImportedBuildItem()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -1418,7 +1418,7 @@ public void CopyCustomMetadataToImportedBuildItem()
                             </Project>
                         ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nMain Include='iMain'>
@@ -1437,12 +1437,12 @@ public void CopyCustomMetadataToImportedBuildItem()
         }
 
         /// <summary>
-        /// Tests BuildItem.CopyCustomMetadataTo 
+        /// Tests BuildItem.CopyCustomMetadataTo
         /// </summary>
         [Test]
         public void CopyCustomMetadataToAnotherBuildItemThenSaveToDisk()
         {
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1 Include='i1'>
@@ -1488,7 +1488,7 @@ public void CopyCustomMetadataToAnotherBuildItemThenSaveToDisk()
         [Test]
         public void GetEvaluatedMetadataSimple()
         {
-            string projectContents = @" 
+            string projectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <n Include='i' >
@@ -1518,7 +1518,7 @@ public void GetEvaluatedMetadataSimple()
         [Test]
         public void GetEvaluatedMetadataFromImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <nImported Include='iImported'>
@@ -1529,7 +1529,7 @@ public void GetEvaluatedMetadataFromImportedProject()
                         </Project>
                     ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nMain Include='iMain' />
@@ -1554,7 +1554,7 @@ public void GetEvaluatedMetadataFromImportedProject()
         [Test]
         public void GetEvaluatedMetadataNoPropertyToEvaluateAgainst()
         {
-            string projectContents = @" 
+            string projectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <n Include='i' >
@@ -1656,7 +1656,7 @@ public void GetMetadataWhenValueContainsEscapableCharacters()
         [Test]
         public void GetMetadataWhenMetadataImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -1837,7 +1837,7 @@ public void RemoveMetadataOfBuiltInMetadata()
         [ExpectedException(typeof(InvalidOperationException))]
         public void RemoveMetadataFromImportedMetadata()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -1974,7 +1974,7 @@ public void SetMetadataValueToNull()
         [ExpectedException(typeof(InvalidOperationException))]
         public void SetMetadataOnImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -2081,7 +2081,7 @@ public void SetMetadataTreatMetadataValueAsLiteral()
         [Test]
         public void CloneBackedByXml()
         {
-            string projectContents = @" 
+            string projectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <n Include='i' Exclude='e' Condition=""'a' == 'b'"" >
@@ -2136,7 +2136,7 @@ public void CloneVirtual()
         [Test]
         public void CloneImportedBuildItem()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <nImported Include='iImported'>
@@ -2202,7 +2202,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
         {
             if (String.IsNullOrEmpty(importProjectContents))
             {
-                importProjectContents = @" 
+                importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nImported Include='iImported' />
@@ -2213,7 +2213,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
             if (String.IsNullOrEmpty(parentProjectContents))
             {
-                parentProjectContents = @" 
+                parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nMain Include='iMain' />
@@ -2383,7 +2383,7 @@ private void VerifyEscapeCharactersThrowExpectedException(TypeOfTest testType)
 
         /// <summary>
         /// Un-registers the existing logger and registers a new copy.
-        /// We will use this when we do multiple builds so that we can safely 
+        /// We will use this when we do multiple builds so that we can safely
         /// assert on log messages for that particular build.
         /// </summary>
         private void ResetLogger()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroupCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroupCollection_Tests.cs
index 0ecfa85e42f..f128a2e4a60 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroupCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroupCollection_Tests.cs
@@ -25,13 +25,13 @@ public class BuildPropertyGroupCollection_Tests
         /// <summary>
         /// Basic Project Contents with 1 Property Group
         /// </summary>
-        private string basicProjectContentsOnePropertyGroup = @" 
+        private string basicProjectContentsOnePropertyGroup = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <n>v</n>
                     </PropertyGroup>
                 </Project>
-                "; 
+                ";
         #endregion
 
         #region Count Tests
@@ -41,7 +41,7 @@ public class BuildPropertyGroupCollection_Tests
         [Test]
         public void CountZero()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 </Project>
                 ";
@@ -70,7 +70,7 @@ public void CountOne()
         [Test]
         public void CountMany()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <Optimize>true</Optimize>
@@ -240,7 +240,7 @@ public void IsSynchronizedDefault()
             BuildPropertyGroupCollection groups = p.PropertyGroups;
 
             Assertion.AssertEquals(false, groups.IsSynchronized);
-        } 
+        }
         #endregion
 
         #region Helper Methods
@@ -267,13 +267,13 @@ private static void RemovePropertyGroupThatContainsSpecifiedBuildProperty(Projec
 
         /// <summary>
         /// Helper Method to create a Main project that imports 1 other project.  Each project contains only one Build Property Group
-        ///     and each of those Build Property Groups contain a Build Property of a specific name (which is used as a flag/key) to 
+        ///     and each of those Build Property Groups contain a Build Property of a specific name (which is used as a flag/key) to
         ///     identify which Build Property Group we're working with.
         /// </summary>
         /// <returns>Project</returns>
         private static Project GetProjectWithOneImportProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <imported>v</imported>
@@ -281,7 +281,7 @@ private static Project GetProjectWithOneImportProject()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <main>v</main>
@@ -300,14 +300,14 @@ private static Project GetProjectWithOneImportProject()
             Project p = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory("main.proj", null);
             return p;
         }
-        
+
         /// <summary>
         /// Helper Method to create a Main project that imports 2 other projects, each with build property groups
         /// </summary>
         /// <returns>Project</returns>
         private static Project GetProjectWithTwoImportProjects()
         {
-            string subProjectContents = @" 
+            string subProjectContents = @"
                     <Project xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <n1>v1</n1>
@@ -318,7 +318,7 @@ private static Project GetProjectWithTwoImportProjects()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <n>v</n>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroup_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroup_Tests.cs
index 510aa0c0cc7..14337bd8b66 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroup_Tests.cs
@@ -25,7 +25,7 @@ public class BuildPropertyGroup_Tests
         /// <summary>
         /// Basic project content start
         /// </summary>
-        private string basicProjectContentsBefore = @" 
+        private string basicProjectContentsBefore = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -41,7 +41,7 @@ public class BuildPropertyGroup_Tests
         /// <summary>
         /// Basic project content with only one property group
         /// </summary>
-        private string basicProjectContentsWithOnePropertyGroup = @" 
+        private string basicProjectContentsWithOnePropertyGroup = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <PropertyGroup>
                                     <n>v</n>
@@ -508,7 +508,7 @@ public void RemovePropertyByBuildPropertyAllOfSeveral()
             group.SetProperty("n2", "v2");
             group.SetProperty("n3", "v3");
 
-            BuildProperty[] property = new BuildProperty[] 
+            BuildProperty[] property = new BuildProperty[]
                 {
                     GetSpecificBuildPropertyOutOfBuildPropertyGroup(group, "n1"),
                     GetSpecificBuildPropertyOutOfBuildPropertyGroup(group, "n2"),
@@ -582,7 +582,7 @@ public void AddNewPropertyValueToEmptyString()
             Project p = Build.UnitTests.ObjectModelHelpers.CreateInMemoryProject(basicProjectContentsBefore);
             AddNewPropertyToEachPropertyGroup(p, "n", String.Empty);
 
-            string projectContentsAfter = @" 
+            string projectContentsAfter = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -609,7 +609,7 @@ public void AddNewPropertySimpleNameValue()
             Project p = Build.UnitTests.ObjectModelHelpers.CreateInMemoryProject(basicProjectContentsBefore);
             AddNewPropertyToEachPropertyGroup(p, "n", "v");
 
-            string projectContentsAfter = @" 
+            string projectContentsAfter = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -639,7 +639,7 @@ public void AddNewPropertySeveralNameValuePairs()
             AddNewPropertyToEachPropertyGroup(p, "n3", "v3");
             AddNewPropertyToEachPropertyGroup(p, "n4", "v4");
 
-            string projectContentsAfter = @" 
+            string projectContentsAfter = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -672,7 +672,7 @@ public void AddNewPropertySimpleNameValueWithTreatPropertyValueAsLiteralTrue()
             Project p = Build.UnitTests.ObjectModelHelpers.CreateInMemoryProject(basicProjectContentsBefore);
             AddNewPropertyToEachPropertyGroupWithPropertyValueAsLiteral(p, "n", @"%*?@$();\", true);
 
-            string projectContentsAfter = @" 
+            string projectContentsAfter = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -699,7 +699,7 @@ public void AddNewPropertySimpleNameValueWithTreatPropertyValueAsLiteralFalse()
             Project p = Build.UnitTests.ObjectModelHelpers.CreateInMemoryProject(basicProjectContentsBefore);
             AddNewPropertyToEachPropertyGroupWithPropertyValueAsLiteral(p, "n", @"%*?@$();\", false);
 
-            string projectContentsAfter = @" 
+            string projectContentsAfter = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -763,7 +763,7 @@ public void AddNewPropertyToInMemoryGroup()
         [Test]
         public void ConditionGetWhenSetItXML()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup Condition="" '$(Foo)' == 'Bar' "">
                         <n1>v1</n1>
@@ -871,7 +871,7 @@ public void ConditionSetWithSpecialCharacters()
         [Test]
         public void IsImportedAllFromMainProject()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <n1>v1</n1>
@@ -898,7 +898,7 @@ public void IsImportedAllFromMainProject()
         [Test]
         public void IsImportedAllFromImportProject()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
@@ -917,7 +917,7 @@ public void IsImportedAllFromImportProject()
         [Test]
         public void IsImportedFromMainProjectAndImported()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <n1>v1</n1>
@@ -965,7 +965,7 @@ public void IsImportedWithVirtualPropertyGroups()
         [Test]
         public void SetImportedPropertyGroupConditionTrue()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
@@ -985,7 +985,7 @@ public void SetImportedPropertyGroupConditionTrue()
         [Test]
         public void SetImportedPropertyGroupConditionFalse()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
@@ -1005,7 +1005,7 @@ public void SetImportedPropertyGroupConditionFalse()
         [Test]
         public void SetImportedPropertyGroupCondition()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
@@ -1025,7 +1025,7 @@ public void SetImportedPropertyGroupCondition()
         [Test]
         public void SetImportedPropertyGroupConditionToEmtpySTring()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
@@ -1045,7 +1045,7 @@ public void SetImportedPropertyGroupConditionToEmtpySTring()
         [Test]
         public void SetImportedPropertyGroupConditionToNull()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildTask_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildTask_Tests.cs
index a4a1e25db4e..bcf2cd1b28f 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildTask_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildTask_Tests.cs
@@ -150,7 +150,7 @@ public void ConditionGetSpecialCharacters()
         [Test]
         public void ConditionGetFromImportedProject()
         {
-            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project xmlns='msbuildnamespace'>
                         <Target Name='t2' >
                         <t2.Task Condition=""'a' == 'b'"" >
@@ -383,7 +383,7 @@ public void ContinueOnErrorGetInvalid()
         [Test]
         public void ContinueOnErrorGetFromImportedProject()
         {
-            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project xmlns='msbuildnamespace'>
                         <Target Name='t2' >
                             <t2.Task ContinueOnError='true' />
@@ -1005,7 +1005,7 @@ public void ExecuteOnTaskThatDoesNothing()
         [Test]
         public void ExecuteFromImportedProject()
         {
-            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                         <Target Name='t' >
                             <Message Text='t.message' />
@@ -1013,7 +1013,7 @@ public void ExecuteFromImportedProject()
                     </Project>
                 ");
 
-            string parentProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+            string parentProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                         <Import Project='import.proj' />
                     </Project>
@@ -1025,7 +1025,7 @@ public void ExecuteFromImportedProject()
             Assertion.AssertEquals(true, task.Execute());
         }
         #endregion
-        
+
         #region GetParameterNames Tests
         /// <summary>
         /// Tests BuildTask.GetParameterNames when only one parameter exists on the BuildTask
@@ -1541,7 +1541,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
         {
             if (String.IsNullOrEmpty(importProjectContents))
             {
-                importProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+                importProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                         <Target Name='t2' >
                             <t2.Task2 parameter='value' />
@@ -1555,7 +1555,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
             if (String.IsNullOrEmpty(parentProjectContents))
             {
-                parentProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+                parentProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                         <Target Name='t1'>
                             <t1.Task1 parameter='value' />
@@ -1572,7 +1572,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
         /// <summary>
         /// Un-registers the existing logger and registers a new copy.
-        /// We will use this when we do multiple builds so that we can safely 
+        /// We will use this when we do multiple builds so that we can safely
         /// assert on log messages for that particular build.
         /// </summary>
         private void ResetLogger()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
index 78659e6084c..f0d85703be9 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
@@ -49,7 +49,7 @@ internal static class TestData
                     <Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <PropertyGroup>
                             <value>true</value>
-                        </PropertyGroup>  
+                        </PropertyGroup>
                        <UsingTask TaskName='TaskName' AssemblyFile='AssemblyName.dll' Condition='$(value)==true'/>
                     </Project>";
 
@@ -60,7 +60,7 @@ internal static class TestData
                     <Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <PropertyGroup>
                             <n>xmlValue</n>
-                        </PropertyGroup>     
+                        </PropertyGroup>
                     </Project>
                 ";
 
@@ -177,7 +177,7 @@ internal static class TestData
                         <Target Name='TestTarget'>
                             <Message Text='Executed TestTarget'/>
                         </Target>
-                    
+
                 ";
 
         /// <summary>
@@ -232,7 +232,7 @@ internal static class TestData
                     <Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <PropertyGroup>
                             <n>xmlValue</n>
-                        </PropertyGroup>                        
+                        </PropertyGroup>
                         <Target Name='CreatePropertyTarget'>
                             <CreateProperty Value='v'>
                                   <Output TaskParameter='Value' PropertyName='p'/>
@@ -247,7 +247,7 @@ internal static class TestData
                         <Target Name='printn'>
                             <Message Text='value is $(n)'/>
                         </Target>
-                       
+
                     </Project>
                 ";
 
@@ -266,14 +266,14 @@ internal static class TestData
                         </Target>
                         <Target Name='Target2'>
                             <Message Text='Executed Target 2'/>
-                        </Target>                           
+                        </Target>
                     </Project>
                 ";
 
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ContentInvalidTargetsWithOutput = @" 
+        internal const string ContentInvalidTargetsWithOutput = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='Target1' Outputs='$(p);@(i);$(q)'>
                             <CreateProperty Value='v'>
@@ -288,7 +288,7 @@ internal static class TestData
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ContentValidTargetsWithOutput = @" 
+        internal const string ContentValidTargetsWithOutput = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <PropertyGroup>
                                 <x>y</x>
@@ -307,13 +307,13 @@ internal static class TestData
                                 <q>u</q>
                             </PropertyGroup>
                         </Target>
-                          
+
                     </Project>";
 
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ItemGroup = @" 
+        internal const string ItemGroup = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <i Include='a' Condition='1==0'/>
@@ -325,7 +325,7 @@ internal static class TestData
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ItemGroup2 = @" 
+        internal const string ItemGroup2 = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup Condition='true'>
                                 <j Include='2a' Condition='1==0'/>
@@ -336,19 +336,19 @@ internal static class TestData
                                 <i2 Include='2a' Condition='1==0'/>
                                 <i2 Include='2b' Condition='true'/>
                                 <i2 Include='2c' Condition='true'/>
-                            </ItemGroup>  
+                            </ItemGroup>
                             <ItemGroup>
                                 <k Include='2a' Condition='1==0'/>
                                 <k Include='2b' Condition='true'/>
                                 <k Include='2c' Condition='true'/>
                             </ItemGroup>
-                           
+
                     </Project>";
 
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ItemGroup3 = @" 
+        internal const string ItemGroup3 = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup Condition='true'>
                                 <i Include='2a' Condition='1==0'/>
@@ -362,7 +362,7 @@ internal static class TestData
                                 <i Include='2a' Condition='1==0'/>
                                 <i Include='2b' Condition='true'/>
                                 <i Include='2c' Condition='true'/>
-                            </ItemGroup>  
+                            </ItemGroup>
                             <ItemGroup>
                                 <i Include='2a' Condition='1==0'/>
                                 <i Include='2b' Condition='true'/>
@@ -373,7 +373,7 @@ internal static class TestData
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string PropertyGroup = @" 
+        internal const string PropertyGroup = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <PropertyGroup Condition='true'>
                                 <n1 Condition='true'>v1</n1>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestHelpers.cs b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestHelpers.cs
index dd4aa83b78d..4ed7cdfc03f 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestHelpers.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestHelpers.cs
@@ -35,14 +35,14 @@ public static class CompatibilityTestHelpers
         /// URI for the msbuild xml schema
         /// </summary>
         internal static readonly Uri SchemaUrlMSBuild = new Uri("http://schemas.microsoft.com/developer/msbuild/2003");
-        
+
         /// <summary>
         /// Path for the msbuild xml schema
         /// </summary>
         internal static readonly string SchemaPathMSBuild = Path.Combine(SuiteBinPath, @"Microsoft.Build.xsd");
 
         /// <summary>
-        /// Field for suitbinPath, reference SuiteBinPath instead. 
+        /// Field for suitbinPath, reference SuiteBinPath instead.
         /// </summary>
         private static string suiteBinPath = null;
 
@@ -72,7 +72,7 @@ internal static string CreateTempProjectFile()
         }
 
         /// <summary>
-        /// Overload for project file content. 
+        /// Overload for project file content.
         /// </summary>
         /// <returns>Project File Content</returns>
         internal static string CreateTempProjectFile(string projContent)
@@ -83,11 +83,11 @@ internal static string CreateTempProjectFile(string projContent)
         /// <summary>
         /// Generate a C:\ drive path that is over a certain minimum length
         /// </summary>
-        /// 
+        ///
         internal static string GenerateLongPath(int minLength)
         {
             string folderName = "directory";
-            string drive = @"C:" + Path.DirectorySeparatorChar; 
+            string drive = @"C:" + Path.DirectorySeparatorChar;
             string longPath = drive;
             while (longPath.Length < (minLength + folderName.Length)) // does not consider slashes
             {
@@ -177,7 +177,7 @@ internal static Import GetImportByProjectPath(ImportCollection imports, string p
             {
                 if (import.ProjectPath == projPath)
                 {
-                    return import;           
+                    return import;
                 }
             }
 
@@ -205,7 +205,7 @@ internal static XmlNodeList GetNodesWithName(string projectXml, string nodeName)
 
             return nodes;
         }
-        
+
         /// <summary>
         /// Find and return a specified BuildProperty from a given project
         /// </summary>
@@ -224,7 +224,7 @@ internal static BuildProperty FindBuildProperty(Project p, string buildPropertyN
 
             return null;
         }
-           
+
         /// <summary>
         /// Find and return a specified BuildPropertyGroup from a given BuildProperty in a project
         /// </summary>
@@ -312,13 +312,13 @@ internal static UsingTask FindUsingTaskByName(string taskName, UsingTaskCollecti
         }
 
         /// <summary>
-        /// Construct a namespace manager 
+        /// Construct a namespace manager
         /// </summary>
         private static XmlNamespaceManager GetNsManager(XmlDocument xmlDoc)
         {
             XmlNamespaceManager namespaceManager = new XmlNamespaceManager(xmlDoc.NameTable);
             namespaceManager.AddNamespace("msb", CompatibilityTestHelpers.SchemaUrlMSBuild.ToString());
             return namespaceManager;
-        }      
+        }
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/EngineFileUtilities_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/EngineFileUtilities_Tests.cs
index 6d52b2ad042..144f075a8af 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/EngineFileUtilities_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/EngineFileUtilities_Tests.cs
@@ -19,7 +19,7 @@
 namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
 {
     /// <summary>
-    /// Test Fixture Class for the v9 Object Model Public Interface Compatibility Tests for the EngineFileUtilities Class. 
+    /// Test Fixture Class for the v9 Object Model Public Interface Compatibility Tests for the EngineFileUtilities Class.
     /// This is not a PRI 1 class for coverage
     /// </summary>
     [TestFixture]
@@ -30,7 +30,7 @@ public class EngineFileUtilities_Tests
         /// </summary>
         /// <remarks>found by kevinpi, Managed Lanaguages Team</remarks>
         [Test]
-        public void EscapeString_Null() 
+        public void EscapeString_Null()
         {
             try
             {
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/Engine_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/Engine_Tests.cs
index fb8071e9797..7a1a2d58135 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/Engine_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/Engine_Tests.cs
@@ -27,7 +27,7 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     [TestFixture]
     public sealed class Engine_Tests
     {
-        //// Note to CTI - http://msdn2.microsoft.com/en-us/library/microsoft.build.buildengine.engine.aspx is the 
+        //// Note to CTI - http://msdn2.microsoft.com/en-us/library/microsoft.build.buildengine.engine.aspx is the
         ////    MSDN of the Engine Class.
         #region Common Helpers
         /// <summary>
@@ -54,7 +54,7 @@ public void ConstructorEngineNoParameters()
 
             if (binPath20 == null)
             {
-                // if 2.0 can't be found in the registry, it's still the default, 
+                // if 2.0 can't be found in the registry, it's still the default,
                 // but we need to get it another way.
                 binPath20 = FrameworkLocationHelper.PathToDotNetFrameworkV20;
             }
@@ -113,7 +113,7 @@ public void ConstructorEngineBinPathNull()
         }
 
         /// <summary>
-        /// Tests the Engine Constructor - Engine(string binPath) with binpath 
+        /// Tests the Engine Constructor - Engine(string binPath) with binpath
         ///     set to the system root drive
         /// </summary>
         [Test]
@@ -125,7 +125,7 @@ public void ConstructorEngineBinPathRootDrive()
 
         /// <summary>
         /// Tests the Engine Constructor - Engine(string binPath) with a simple path
-        ///     that contains a trailing backslash.  Verify trailing backslash is 
+        ///     that contains a trailing backslash.  Verify trailing backslash is
         ///     removed.
         /// </summary>
         [Test]
@@ -1056,7 +1056,7 @@ public void BuildProjectFileDeepFolderLocation()
 
         #region BuildProjectFile(string projectFile, string targetName)
         /* This overload calls BuildProjectFile(projectFile, new string[] {targetName}, this.GlobalProperties,
-         *      null, BuildSettings.None) as such, passing on the projectFile and your targetName.  Because the 
+         *      null, BuildSettings.None) as such, passing on the projectFile and your targetName.  Because the
          *      null targetName is already covered in the BuildProjectFile(projectFile) overload, we don't
          *      need to test it again.
          */
@@ -1093,7 +1093,7 @@ public void BuildProjectFileTargetNameDoesNotExist()
 
         #region BuildProjectFile(string projectFile, string[] targetNames)
         /* This overload calls BuildProjectFile(projectFile, targetNames, this.GlobalProperties,
-                null, BuildSettings.None) as such, passing on the projectFile and your targetNames.  Because the 
+                null, BuildSettings.None) as such, passing on the projectFile and your targetNames.  Because the
          *      null targetNames is already covered in the BuildProjectFile(projectFile) overload, we don't
          *      need to test it again.
          */
@@ -1159,7 +1159,7 @@ public void BuildProjectFileTargetNamesSomeExistingSomeNonExisting()
          */
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties)
         ///     where globalProperties are null
         /// </summary>
         [Test]
@@ -1169,7 +1169,7 @@ public void BuildProjectFileGlobalPropertiesNull()
         }
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties)
         ///     where globalProperties are valid, different
         /// </summary>
         [Test]
@@ -1179,7 +1179,7 @@ public void BuildProjectFileGlobalPropertiesValidDifferent()
         }
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties)
         ///     where globalProperties are valid, same
         /// </summary>
         [Test]
@@ -1196,7 +1196,7 @@ public void BuildProjectFileGlobalPropertiesValidSame()
          */
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs)
         ///     where targetOutputs are null
         /// </summary>
         [Test]
@@ -1206,7 +1206,7 @@ public void BuildProjectFileTargetOutputsNull()
         }
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs)
         ///     where targetOutputs String.Empty
         /// </summary>
         [Test]
@@ -1216,7 +1216,7 @@ public void BuildProjectFileTargetOutputsEmptyString()
         }
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs)
         ///     where targetOutputs simple valid
         /// </summary>
         [Test]
@@ -1226,7 +1226,7 @@ public void BuildProjectFileTargetOutputsValid()
         }
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs)
         ///     where targetOutputs invalid
         /// </summary>
         [Test]
@@ -1280,7 +1280,7 @@ public void BuildProjectFileBuildFlagsDoNotResetPreviouslyBuiltTargetsMultipleSa
         #endregion
 
         #region BuildProjectFile(string projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs, BuildSettings buildFlags, string toolsVersion)
-        /* This is the method that all of the other BuildProjectFile overloads call (with null toolsVersion).  Therefore, 
+        /* This is the method that all of the other BuildProjectFile overloads call (with null toolsVersion).  Therefore,
          *  we don't need to re-test setting toolsVersion to null.
          */
 
@@ -1337,7 +1337,7 @@ public void BuildProjectFileToolsVersionInvalid()
          *  the example Dev Unit test.
          */
         #region Example Dev Unit Test For BuildProjectFiles()
-        //// Also, note in this example, there are examples of other Engine.Objects that should be 
+        //// Also, note in this example, there are examples of other Engine.Objects that should be
         //// useful for you.  RegisterDistributedLogger() tests below, you'll need to look at this
         //// ***************START: Example Dev Unit test***************
         ////[Test]
@@ -1406,7 +1406,7 @@ public void BuildProjectFileToolsVersionInvalid()
 
         /// <summary>
         /// Tests Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject,
-        ///                                 BuildPropertyGroup[] globalPropertiesPerProject, 
+        ///                                 BuildPropertyGroup[] globalPropertiesPerProject,
         ///                                 IDictionary[] targetOutputsPerProject, BuildSettings buildFlags,
         ///                                 string [] toolsVersions) with several project files (no traversal projects)
         ///                                 with no Project to Project (P2P) references between set of projects
@@ -1419,7 +1419,7 @@ public void BuildProjectFilesSeveralProjects()
 
         /// <summary>
         /// Tests Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject,
-        ///                                 BuildPropertyGroup[] globalPropertiesPerProject, 
+        ///                                 BuildPropertyGroup[] globalPropertiesPerProject,
         ///                                 IDictionary[] targetOutputsPerProject, BuildSettings buildFlags,
         ///                                 string [] toolsVersions) with a single traversal project that
         ///                                 points to several projects (no P2P references)
@@ -1432,9 +1432,9 @@ public void BuildProjectFilesTraveralProjectWithProjectsNoP2Ps()
 
         /// <summary>
         /// Tests Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject,
-        ///                                 BuildPropertyGroup[] globalPropertiesPerProject, 
+        ///                                 BuildPropertyGroup[] globalPropertiesPerProject,
         ///                                 IDictionary[] targetOutputsPerProject, BuildSettings buildFlags,
-        ///                                 string [] toolsVersions) with a single traversal project that points to 
+        ///                                 string [] toolsVersions) with a single traversal project that points to
         ///                                 4 projects (projects A, B, C and D) where A has a P2P to C, and B has
         ///                                 a P2P to D.
         /// </summary>
@@ -1446,7 +1446,7 @@ public void BuildProjectFilesTraveralProjectWithProjectsThatHaveP2Ps()
 
         /// <summary>
         /// Tests Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject,
-        ///                                 BuildPropertyGroup[] globalPropertiesPerProject, 
+        ///                                 BuildPropertyGroup[] globalPropertiesPerProject,
         ///                                 IDictionary[] targetOutputsPerProject, BuildSettings buildFlags,
         ///                                 string [] toolsVersions) with a traversal project, which in turn
         ///                                 points to several other traversal projects, each of which have their
@@ -1510,7 +1510,7 @@ public void GetLoadedProjectExisting()
         }
 
         /// <summary>
-        /// Tests Engine.GetLoadedProject(string projectFullFileName) with projectFullFileName set to an non-existing 
+        /// Tests Engine.GetLoadedProject(string projectFullFileName) with projectFullFileName set to an non-existing
         /// project file name, yet path exist
         /// </summary>
         [Test]
@@ -1614,7 +1614,7 @@ public void RegisterDistributedLoggerSameLoggerForCentralAndForwarding()
 
         #region RegisterLogger Tests
         /// <summary>
-        /// Tests Engine.RegisterLogger(ILogger logger) with 
+        /// Tests Engine.RegisterLogger(ILogger logger) with
         /// </summary>
         [Test]
         [Ignore("nyi")]
@@ -1689,7 +1689,7 @@ public void ShutdownLoadProjectLoggersNoBuild()
         }
 
         /// <summary>
-        /// Tests Engine.Shutdown() when you've loaded a project, loggers, etc, built, then only unloaded the loggers, 
+        /// Tests Engine.Shutdown() when you've loaded a project, loggers, etc, built, then only unloaded the loggers,
         ///     project still loaded
         /// </summary>
         [Test]
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/ImportCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/ImportCollection_Tests.cs
index a5c628e1154..59618157eba 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/ImportCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/ImportCollection_Tests.cs
@@ -32,7 +32,7 @@ public class ImportCollection_Tests : AddNewImportTests
         public ImportCollection_Tests()
         {
             InvokeAddNewImportMethod = new AddNewImportDelegate(AddNewImportOverload);
-        } 
+        }
 
         /// <summary>
         /// Count Test. Increment Count on Import Add
@@ -276,7 +276,7 @@ public void RemoveImport_SimpleDirtyAfterRemove()
             {
                 importPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("import.proj", TestData.Content3SimpleTargetsDefaultSpecified);
                 projectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("project.proj", TestData.Content3SimpleTargetsDefaultSpecified);
-                Project p = new Project(); 
+                Project p = new Project();
                 p.Imports.AddNewImport(importPath, "true");
                 object o = p.EvaluatedItems;
                 Import import = CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath);
@@ -289,7 +289,7 @@ public void RemoveImport_SimpleDirtyAfterRemove()
             finally
             {
                 CompatibilityTestHelpers.RemoveFile(importPath);
-                CompatibilityTestHelpers.RemoveFile(projectPath); 
+                CompatibilityTestHelpers.RemoveFile(projectPath);
             }
         }
 
@@ -359,7 +359,7 @@ public void GetEnumerator()
         }
 
         /// <summary>
-        /// SyncRoot Test, Take a lock on SyncRoot then iterate over it. 
+        /// SyncRoot Test, Take a lock on SyncRoot then iterate over it.
         /// </summary>
         [Test]
         public void SyncRoot()
@@ -376,10 +376,10 @@ public void SyncRoot()
                 object o = p.EvaluatedItems;
                 Import[] importArray = new Import[p.Imports.Count];
                 p.Imports.CopyTo(importArray, 0);
-                lock (p.Imports.SyncRoot) 
+                lock (p.Imports.SyncRoot)
                 {
                     int i = 0;
-                    foreach (Import import in p.Imports) 
+                    foreach (Import import in p.Imports)
                     {
                         Assertion.AssertEquals(importArray[i].ProjectPath, import.ProjectPath);
                        i++;
@@ -394,7 +394,7 @@ public void SyncRoot()
         }
 
          /// <summary>
-        /// isSynchronized, is false : returned collection is not threadsafe.  
+        /// isSynchronized, is false : returned collection is not threadsafe.
         /// </summary>
         [Test]
         public void IsSynchronized()
@@ -420,6 +420,6 @@ public void IsSynchronized()
         private void AddNewImportOverload(Project p, string path, string condition)
         {
             p.Imports.AddNewImport(path, condition);
-        } 
+        }
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/Import_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/Import_Tests.cs
index 24f45c85abb..047d4385a1f 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/Import_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/Import_Tests.cs
@@ -24,13 +24,13 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     /// Also see Toolset tests in the Project test class.
     /// </summary>
     [TestFixture]
-    public sealed class Import_Tests 
+    public sealed class Import_Tests
     {
         /// <summary>
         /// Condition Test, Simple Condition, assert only accessible after evaluation.
         /// </summary>
         [Test]
-        public void ConditionGet_Simple() 
+        public void ConditionGet_Simple()
         {
             string importPath = String.Empty;
             try
@@ -44,9 +44,9 @@ public void ConditionGet_Simple()
                 import = CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath);
                 Assertion.AssertEquals("true", import.Condition);
             }
-            finally 
+            finally
             {
-                CompatibilityTestHelpers.RemoveFile(importPath);           
+                CompatibilityTestHelpers.RemoveFile(importPath);
             }
         }
 
@@ -81,7 +81,7 @@ public void ConditionSet_Null()
             string importPath = String.Empty;
             try
             {
-                importPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("import.proj", TestData.Content3SimpleTargetsDefaultSpecified); 
+                importPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("import.proj", TestData.Content3SimpleTargetsDefaultSpecified);
                 Project p = new Project();
                 p.AddNewImport(importPath, "true");
                 object o = p.EvaluatedProperties;
@@ -122,9 +122,9 @@ public void ConditionSet_DirtyWhenSet()
                 CompatibilityTestHelpers.RemoveFile(projectPath);
             }
         }
-       
+
         /// <summary>
-        /// ProjectPath Test, get when set in the constructor. 
+        /// ProjectPath Test, get when set in the constructor.
         /// </summary>
         [Test]
         public void ProjectPathGetWhenSetInCtor()
@@ -135,10 +135,10 @@ public void ProjectPathGetWhenSetInCtor()
                 importPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("import.proj", TestData.Content3SimpleTargetsDefaultSpecified);
                 Project p = new Project();
                 p.AddNewImport(importPath, "true");
-                object o = p.EvaluatedProperties;  
-   
+                object o = p.EvaluatedProperties;
+
                 // The verbosity of this assertion is to abstract the internal implentation of FindFirstMatchingImportByPath.
-                Assertion.AssertEquals(importPath, CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath).ProjectPath); 
+                Assertion.AssertEquals(importPath, CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath).ProjectPath);
             }
             finally
             {
@@ -147,7 +147,7 @@ public void ProjectPathGetWhenSetInCtor()
         }
 
         /// <summary>
-        /// ProjectPath Test, get when set in ctor 
+        /// ProjectPath Test, get when set in ctor
         /// </summary>
         [Test]
         public void EvaluatedProjectPathGetWhenSetInCtor()
@@ -159,7 +159,7 @@ public void EvaluatedProjectPathGetWhenSetInCtor()
             {
                 Project p = new Project();
                 p.Load(projectPath);
- 
+
                 // The verbosity of this assertion is to abstract the internal implentation of FindFirstMatchingImportByPath.
                 Assertion.AssertEquals(fullImportPath, CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath).EvaluatedProjectPath);
             }
@@ -171,14 +171,14 @@ public void EvaluatedProjectPathGetWhenSetInCtor()
         }
 
         /// <summary>
-        /// ProjectPath Test, get when set in loaded xml. 
+        /// ProjectPath Test, get when set in loaded xml.
         /// </summary>
         [Test]
         public void ProjectPathGetWhenSetInXML()
         {
             string projectPath = String.Empty;
             string importPath = String.Empty;
-            string fullImportPath = String.Empty;            
+            string fullImportPath = String.Empty;
             try
             {
                 projectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("project.proj", TestData.ContentImportA);
@@ -186,7 +186,7 @@ public void ProjectPathGetWhenSetInXML()
                 fullImportPath = ObjectModelHelpers.CreateFileInTempProjectDirectory(importPath, TestData.ContentA);
                 Project p = new Project();
                 p.Load(projectPath);
-                Assertion.AssertEquals(importPath, CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath).ProjectPath);           
+                Assertion.AssertEquals(importPath, CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath).ProjectPath);
             }
             finally
             {
@@ -264,7 +264,7 @@ public void IsImported_ProjectImport()
         }
 
         /// <summary>
-        /// IsImported Test, true when import is via an imported project. 
+        /// IsImported Test, true when import is via an imported project.
         /// </summary>
         [Test]
         public void IsImported_ProjectImportImport()
@@ -300,7 +300,7 @@ public void IsImported_ProjectImportImport()
         public void ProjectPathSet_ScalarValue()
         {
             string importPath = String.Empty;
-            string importPath2 = String.Empty;           
+            string importPath2 = String.Empty;
             try
             {
                 importPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("import.proj", TestData.Content3SimpleTargetsDefaultSpecified);
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/InvalidProjectfileException_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/InvalidProjectfileException_Tests.cs
index c0bf9b10207..c557ff04b8c 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/InvalidProjectfileException_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/InvalidProjectfileException_Tests.cs
@@ -125,7 +125,7 @@ public void CtorArity4_NullMessageString()
         }
 
         /// <summary>
-        ///  Ctor Test 
+        ///  Ctor Test
         /// </summary>
         [Test]
         [ExpectedException(typeof(ArgumentException))]
@@ -157,7 +157,7 @@ public void CtorArity4_EmptyStringOtherParams()
         }
 
         /// <summary>
-        ///  Ctor Test 
+        ///  Ctor Test
         /// </summary>
         [Test]
         public void CtorArity4_NullStringOtherParams()
@@ -195,8 +195,8 @@ public void Ctor_Arity9PositveInts()
         }
 
         /// <summary>
-        ///  Ctor Test, this enforces lack of bounds checking and the lack of range checking (end can come before start) 
-        ///  on the line and column number params. 
+        ///  Ctor Test, this enforces lack of bounds checking and the lack of range checking (end can come before start)
+        ///  on the line and column number params.
         /// </summary>
         [Test]
         public void CtorArity9NegativeInts()
@@ -229,7 +229,7 @@ public void BaseMessage()
         }
 
         /// <summary>
-        /// XML Serialization Test, not supported, throws invalid operation Exception. 
+        /// XML Serialization Test, not supported, throws invalid operation Exception.
         /// </summary>
         [Test]
         [ExpectedException(typeof(InvalidOperationException))]
@@ -262,7 +262,7 @@ public void SerializationBinary()
             MemoryStream memoryStream = null;
             InvalidProjectFileException invalidProjectFileException =
                 new InvalidProjectFileException(projectFile, 1, 2, 3, 4, message, "errorSubCategory", "errorCode", "HelpKeyword");
-            
+
             try
             {
                 memoryStream = new MemoryStream();
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/InvalidToolsetDefinitionException_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/InvalidToolsetDefinitionException_Tests.cs
index cd392c6aa53..dff8021ab7d 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/InvalidToolsetDefinitionException_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/InvalidToolsetDefinitionException_Tests.cs
@@ -23,7 +23,7 @@
 namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
 {
     /// <summary>
-    /// STUB Fixture Class for the v9 OM Public Interface Compatibility Tests. RemoteErrorException class 
+    /// STUB Fixture Class for the v9 OM Public Interface Compatibility Tests. RemoteErrorException class
     /// Also see Toolset tests in the Project test class.
     /// </summary>
     [TestFixture]
@@ -40,12 +40,12 @@ public void CtorMessage()
         }
 
         /// <summary>
-        /// Ctor Test, set a null message. We do not guard against this. 
+        /// Ctor Test, set a null message. We do not guard against this.
         /// </summary>
         [Test]
         public void CtorMessage_Null()
         {
-            InvalidToolsetDefinitionException toolSetException = new InvalidToolsetDefinitionException(null); 
+            InvalidToolsetDefinitionException toolSetException = new InvalidToolsetDefinitionException(null);
         }
 
         /// <summary>
@@ -93,7 +93,7 @@ public void CtorArity3()
         }
 
         /// <summary>
-        /// XML Serialization Test, not supported, throws invalid operation Exception. 
+        /// XML Serialization Test, not supported, throws invalid operation Exception.
         /// </summary>
         [Test]
         [ExpectedException(typeof(InvalidOperationException))]
@@ -111,9 +111,9 @@ public void SerializationXML()
             }
             finally
             {
-                memoryStream.Close(); 
+                memoryStream.Close();
             }
-        }       
+        }
 
         /// <summary>
         /// Binary Serialization Test, serialize the exception out and back in from a stream. This uses the protected constructor
@@ -140,7 +140,7 @@ public void SerializationBinary()
         }
 
         /// <summary>
-        /// Binary Serialization Test, serialize a inherited exception out and back in from a stream. 
+        /// Binary Serialization Test, serialize a inherited exception out and back in from a stream.
         /// </summary>
         [Test]
         public void ProtectedConstructorTest()
@@ -175,15 +175,15 @@ internal class ExtendsInvalidToolsetDefinitionException : InvalidToolsetDefiniti
             /// </summary>
             public ExtendsInvalidToolsetDefinitionException(string message, string errorCode)
                 : base(message, errorCode)
-            { 
+            {
             }
 
             /// <summary>
             /// Basic Constructor Override
             /// </summary>
             public ExtendsInvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context)
-                : base(info, context) 
-            { 
+                : base(info, context)
+            {
             }
         }
     }
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/Project_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/Project_Tests.cs
index 443f8ab355f..1872557281b 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/Project_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/Project_Tests.cs
@@ -92,7 +92,7 @@ public void ConstructToolsVersionKnown_3_5()
                 }
                 else
                 {
-                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed."); 
+                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed.");
                 }
             }
 
@@ -177,7 +177,7 @@ public void ConstructToolsVersion_Known()
             }
 
             /// <summary>
-            /// Constructor Test, with Engine object, Null ToolsVersion 
+            /// Constructor Test, with Engine object, Null ToolsVersion
             /// </summary>
             [Test]
             public void ConstructToolsVersion_Null()
@@ -228,7 +228,7 @@ public void DefaultToolsVersionSetGet_Unknown()
                 Project p = new Project(new Engine());
                 p.DefaultToolsVersion = "999999";
 
-                // setting an unknown ToolsVersion will cause the DefaultToolsVersion (and ToolsVersion) 
+                // setting an unknown ToolsVersion will cause the DefaultToolsVersion (and ToolsVersion)
                 // to default to "4.0"
                 Assertion.AssertEquals("4.0", p.DefaultToolsVersion);
             }
@@ -304,7 +304,7 @@ public void ToolsVersionGetWhenSetInXml_3_5()
                 }
                 else
                 {
-                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed."); 
+                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed.");
                 }
             }
 
@@ -343,7 +343,7 @@ public void ToolsVersionGetWhenSetInProjectConstructor_3_5()
                 }
                 else
                 {
-                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed."); 
+                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed.");
                 }
             }
 
@@ -364,7 +364,7 @@ public void ToolsVersionGetWhenSetInProjectConstructor_4_0()
         [TestFixture]
         public sealed class TargetsCollection
         {
-            // More Tests in the target collection class. 
+            // More Tests in the target collection class.
 
             /// <summary>
             /// Target Test, Get a list of targets
@@ -443,7 +443,7 @@ public void AddNewUsingTaskFromAssemblyName()
         }
 
         /// <summary>
-        /// Tests for HasUnsavedChanges TimeOfLastChange 
+        /// Tests for HasUnsavedChanges TimeOfLastChange
         /// </summary>
         [TestFixture]
         public sealed class Dirty
@@ -633,7 +633,7 @@ public void SchemaFileIsValidatedValidXmlInvalidSchema()
             }
 
             /// <summary>
-            ///  SchemaFileIsValidated Test, setup valid project xml against invalid schema but turn 
+            ///  SchemaFileIsValidated Test, setup valid project xml against invalid schema but turn
             ///  validation off so it never runs.
             /// </summary>
             [Test]
@@ -845,7 +845,7 @@ public void BuildImportRemovedImport()
                     Project p = ObjectModelHelpers.CreateInMemoryProject(TestData.Content3SimpleTargetsNoDefaultSpecified, logger);
                     p.Imports.AddNewImport(projImport1, "true");
                     p.Imports.AddNewImport(projImport2, "true");
-                    object o = p.EvaluatedItems; // force evaluation of imported projects.               
+                    object o = p.EvaluatedItems; // force evaluation of imported projects.
                     p.Imports.RemoveImport(CompatibilityTestHelpers.GetImportByProjectPath(p.Imports, projImport2));
                     p.Build("ImportTarget1b");
                     Assertion.AssertEquals(false, logger.FullLog.Contains("Executed ImportTarget 2a"));
@@ -911,7 +911,7 @@ public void BuildIncrementalTargetExecutionFlag_Off()
                 Project p = ObjectModelHelpers.CreateInMemoryProject(TestData.Content3SimpleTargetsNoDefaultSpecified, logger);
                 p.Build("Target2");
                 bool buildSuccessful = p.Build(new string[] { "Target1" }, null, BuildSettings.None);
-               
+
                 Assertion.AssertEquals(true, buildSuccessful);
                 string skippedMessage = ResourceUtilities.FormatResourceString("TargetAlreadyCompleteSuccess", "Target1");
                 string skippedMessage2 = ResourceUtilities.FormatResourceString("TargetAlreadyCompleteSuccess", "Target2");
@@ -981,7 +981,7 @@ public void ResetBuildVirtualPropertyRemoval()
                 p.Build("CreatePropertyTarget");
                 Assertion.AssertEquals("v", p.GetEvaluatedProperty("p"));
                 p.ResetBuildStatus();
-                Assertion.AssertEquals(null, p.GetEvaluatedProperty("p")); 
+                Assertion.AssertEquals(null, p.GetEvaluatedProperty("p"));
             }
 
             /// <summary>
@@ -1032,7 +1032,7 @@ public void ResetBuildVirtualItemReset()
                 Assertion.AssertEquals(preCount - 1, p.EvaluatedItems.Count);
             }
         }
-      
+
         /// <summary>
         /// Tests for BuildEnabled property.
         /// </summary>
@@ -1149,7 +1149,7 @@ public sealed class XmlEncoding
             // More extensive tests of this property elsewhere in unit testing framework.
 
             /// <summary>
-            /// Encoding Test, Get, when set to default (UTF8) 
+            /// Encoding Test, Get, when set to default (UTF8)
             /// </summary>
             [Test]
             public void Encoding_Get_Default_UTF8()
@@ -1171,7 +1171,7 @@ public void Encoding_Get_Custom_Invalid()
             }
 
             /// <summary>
-            /// Encoding Test, get when set to invalid encoding 
+            /// Encoding Test, get when set to invalid encoding
             /// </summary>
             [Test]
             public void Encoding_Get_Custom_UTF16()
@@ -1195,7 +1195,7 @@ public sealed class Load
             ///  <bug>
             ///   Project.cs
             ///   Before: ErrorUtilities.VerifyThrowArgument(projectFileName.Length > 0, "EmptyProjectFileName" +buildEventContext.ToString());
-            ///   After: ErrorUtilities.VerifyThrowArgument(projectFileName.Length > 0, "EmptyProjectFileName"); 
+            ///   After: ErrorUtilities.VerifyThrowArgument(projectFileName.Length > 0, "EmptyProjectFileName");
             ///   Threw ArgumentException due to invalid keying into resources.
             ///  </bug>
             /// </bugs>
@@ -1219,10 +1219,10 @@ public void LoadProjectFileName_Null()
             }
 
             /// <summary>
-            ///   Load Test, load a project file twice. Unload Previous project, dump from cache. 
+            ///   Load Test, load a project file twice. Unload Previous project, dump from cache.
             /// </summary>
             /// <remarks>
-            ///  This is a test for nametable colissions on shared engines. 
+            ///  This is a test for nametable colissions on shared engines.
             ///  An Debug assertion was removed from Engine to prevent the assert from blocking suites.
             /// </remarks>
             [Test]
@@ -1272,7 +1272,7 @@ public void LoadProjectFile_FileContentEmpty()
             /// <summary>
             /// Load Test, with Valid Project File Name, which does not exist.
             /// </summary>
-            /// <remarks> 
+            /// <remarks>
             /// FileNotFound throws to expose ArgumentException in version v9 and earlier
             /// versions post v9 should throw and expose FileNotFoundException
             /// </remarks>
@@ -1298,7 +1298,7 @@ public void LoadProjectFileName_FileSystemPath()
             }
 
             /// <summary>
-            /// Load Test, Check FullFileName is set 
+            /// Load Test, Check FullFileName is set
             /// </summary>
             /// <bugs>
             ///  <bug>
@@ -1316,7 +1316,7 @@ public void LoadProjectFileName_isFullFileNameSet()
             }
 
             /// <summary>
-            /// Load Test, Check FullFileName is set 
+            /// Load Test, Check FullFileName is set
             /// </summary>
             /// <bugs>
             ///  <bug>
@@ -1451,7 +1451,7 @@ public void LoadProjectFile_IOException()
             /// </summary>
             /// <remarks>
             /// The file refereced in this test does not exist, as it cannot be created in
-            /// the file system. 
+            /// the file system.
             /// </remarks>
             [Test]
             [ExpectedException(typeof(ArgumentException))]
@@ -1561,7 +1561,7 @@ public void LoadProjectXMLString_Valid()
             }
 
             /// <summary>
-            /// Load Test, from a string of INVALID xml, 
+            /// Load Test, from a string of INVALID xml,
             /// </summary>
             [Test]
             [ExpectedException(typeof(InvalidProjectFileException))]
@@ -1583,7 +1583,7 @@ public void LoadProjectXMLString_CatchMissingImports()
             }
 
             /// <summary>
-            /// Load Test, from a string of xml 
+            /// Load Test, from a string of xml
             /// </summary>
             [Test]
             public void LoadProjectXMLString_IsDirtyAfterLoad()
@@ -1594,7 +1594,7 @@ public void LoadProjectXMLString_IsDirtyAfterLoad()
             }
 
             /// <summary>
-            /// Load Test, from a string of invalid xml 
+            /// Load Test, from a string of invalid xml
             /// </summary>
             [Test]
             public void LoadProjectXMLString_IgnoreMissingImports()
@@ -1609,7 +1609,7 @@ public void LoadProjectXMLString_IgnoreMissingImports()
         /// Tests for Save, Save TextReader.
         /// </summary>
         [TestFixture]
-        public sealed class Save 
+        public sealed class Save
         {
             /// <summary>
             ///  Save Test, Path is empty String
@@ -1725,7 +1725,7 @@ public void SaveInvalidFileName()
             /// </summary>
             /// <remarks>
             /// The file refereced in this test does not exist, as it cannot be created in
-            /// the file system. 
+            /// the file system.
             /// </remarks>
             [Test]
             [ExpectedException(typeof(PathTooLongException))]
@@ -1845,7 +1845,7 @@ public void Xml_GetAfterOMChange()
         }
 
         /// <summary>
-        /// Tests for the DefaultTargets Property. 
+        /// Tests for the DefaultTargets Property.
         /// </summary>
         [TestFixture]
         public sealed class DefaultTargets
@@ -1896,7 +1896,7 @@ public void DefaultTargetsGetWhenNotExplicitySetInXml()
             }
 
             /// <summary>
-            /// DefaultTargets Test, Set where defaultTargets contains a target that does not exist. 
+            /// DefaultTargets Test, Set where defaultTargets contains a target that does not exist.
             /// </summary>
             [Test]
             public void DefaultTargetsSetMissingTarget()
@@ -1905,11 +1905,11 @@ public void DefaultTargetsSetMissingTarget()
                 Project p = ObjectModelHelpers.CreateInMemoryProject(TestData.Content3SimpleTargetsDefaultSpecified, logger);
                 p.DefaultTargets = "missingTarget";
                 p.Build();
-                Assertion.AssertEquals(true, logger.FullLog.Contains("MSB4057")); // error MSB4057, the target does not exist 
+                Assertion.AssertEquals(true, logger.FullLog.Contains("MSB4057")); // error MSB4057, the target does not exist
             }
 
             /// <summary>
-            /// DefaultTargets Test, where defaultTargets list contain null targets. 
+            /// DefaultTargets Test, where defaultTargets list contain null targets.
             /// </summary>
             [Test]
             public void DefaultTargetsSetNullItemsInTargetList()
@@ -1936,7 +1936,7 @@ public void DefaultTargetsSpecialCharacterDelimiter()
                 p.Build();
 
                 // Test
-                Assertion.AssertEquals(true, logger.FullLog.Contains("MSB4057")); // error MSB4057, the target "TestTarget;TestTarget1" does not exist 
+                Assertion.AssertEquals(true, logger.FullLog.Contains("MSB4057")); // error MSB4057, the target "TestTarget;TestTarget1" does not exist
             }
 
             /// <summary>
@@ -1948,11 +1948,11 @@ public void DefaultTargetsSpecialCharactersInTargetName()
                 // Execute
                 Project p = new Project(new Engine());
                 p.DefaultTargets = "valid@target;$\\valid;%valid()";
-                Assertion.AssertEquals("valid@target; $\\valid; %valid()", p.DefaultTargets); // note whitespace 
+                Assertion.AssertEquals("valid@target; $\\valid; %valid()", p.DefaultTargets); // note whitespace
             }
 
             /// <summary>
-            /// DefaultTargets Test, where value contains empty items and 
+            /// DefaultTargets Test, where value contains empty items and
             /// excess whitespace around target names
             /// </summary>
             [Test]
@@ -1994,7 +1994,7 @@ public void DefaultTargets_IsDirtyWhenSet()
                 Assertion.AssertEquals(true, p.IsDirty);
             }
         }
-        
+
         /// <summary>
         /// Tests for the FullfileName Property.
         /// </summary>
@@ -2002,7 +2002,7 @@ public void DefaultTargets_IsDirtyWhenSet()
         public sealed class FullFileName
         {
             /// <summary>
-            ///  FullFileName Test, set then get 
+            ///  FullFileName Test, set then get
             /// </summary>
             [Test]
             public void FullFileNameSetGet()
@@ -2053,7 +2053,7 @@ public void FullFileNameSetProjectIsNotDirtyAfter()
         public sealed class InitialTargets
         {
             /// <summary>
-            ///  InitialTargets Test, set then get 
+            ///  InitialTargets Test, set then get
             /// </summary>
             [Test]
             public void InitialTargetsSetGet()
@@ -2064,7 +2064,7 @@ public void InitialTargetsSetGet()
             }
 
             /// <summary>
-            ///  InitialTargets Test, set then get 
+            ///  InitialTargets Test, set then get
             /// </summary>
             [Test]
             public void InitialTargetsSetGetMultiple()
@@ -2075,7 +2075,7 @@ public void InitialTargetsSetGetMultiple()
             }
 
             /// <summary>
-            ///  InitialTargets Test, 
+            ///  InitialTargets Test,
             /// </summary>
             [Test]
             public void InitialTargetsSetGetMultipleSpecialcharacters()
@@ -2164,7 +2164,7 @@ public void RemoveImportedPropertyGroupInvalidOp()
                 {
                     importedProjFilename = ObjectModelHelpers.CreateTempFileOnDisk(TestData.PropertyGroup);
                     mainProjFilename = ObjectModelHelpers.CreateTempFileOnDisk(TestData.Content3SimpleTargetsDefaultSpecified);
-                    Project mainProject = new Project(new Engine());                                         
+                    Project mainProject = new Project(new Engine());
                     Project importedProject = new Project(mainProject.ParentEngine);
                     mainProject.Load(mainProjFilename);
                     importedProject.Load(importedProjFilename);
@@ -2246,7 +2246,7 @@ public void GetConditionedPropertyValues_Null()
                 Project p = new Project();
                 string[] values = p.GetConditionedPropertyValues(null);
             }
-        
+
             /// <summary>
             /// Test the RemoveAllPropertyGroups method.
             /// </summary>
@@ -2331,7 +2331,7 @@ public void RemoveAllPropertyGroupsByConditionWithChoose()
                             <PropertyGroup Condition=`'$(x)'=='y'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
-  
+
                             <PropertyGroup Condition=`'$(x)'=='z'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
@@ -2340,7 +2340,7 @@ public void RemoveAllPropertyGroupsByConditionWithChoose()
                             <PropertyGroup Condition=`'$(x)'=='y'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
-  
+
                             <PropertyGroup Condition=`'$(x)'=='z'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
@@ -2532,7 +2532,7 @@ public void SetPropertyBeforeImportDoesNotExists()
                     object o = p.EvaluatedItems;
                     Assertion.AssertEquals(true, p.Xml.IndexOf("vNew") < p.Xml.IndexOf("Import"));
                 }
-                finally 
+                finally
                 {
                     CompatibilityTestHelpers.RemoveFile(importPath);
                 }
@@ -2576,7 +2576,7 @@ public void SetPropertyAfterImportWherePropertyExistsBefore()
                     object o = p.EvaluatedItems;
                     Assertion.AssertEquals(true, p.Xml.IndexOf("vNew") < p.Xml.IndexOf("Import"));
                 }
-                finally 
+                finally
                 {
                     CompatibilityTestHelpers.RemoveFile(importPath);
                 }
@@ -2740,7 +2740,7 @@ public void AddNewProperty_InvalidOp()
 
             /// <summary>
             /// AddNewPropertyGroup Test, before other groups
-            /// 
+            ///
             /// If "insertAtEnd", is inserted at the very end. Otherwise,
             /// we add the new property group just after the last property group in the
             /// main project file.  If there are currently no property groups in the main
@@ -2760,7 +2760,7 @@ public void AddNewPropertyGroupBeforeWithOneOtherPropertyGroup()
 
             /// <summary>
             /// AddNewPropertyGroup Test, before other groups
-            /// 
+            ///
             /// If "insertAtEnd", is inserted at the very end. Otherwise,
             /// we add the new property group just after the last property group in the
             /// main project file.  If there are currently no property groups in the main
@@ -2874,9 +2874,9 @@ public Import()
             {
                 InvokeAddNewImportMethod = new AddNewImportDelegate(AddNewImportOverload);
             }
-          
+
             /// <summary>
-            ///  Import Test, Get Import 
+            ///  Import Test, Get Import
             /// </summary>
             [Test]
             public void ImportsGet()
@@ -2958,7 +2958,7 @@ public void SetImportedPropertyThatExists()
             /// </summary>
             [Test]
             public void SetPropertySetValueLiteralFlag()
-            { 
+            {
                 string importedProjFilename = String.Empty;
                 string mainProjFilename = String.Empty;
                 try
@@ -2988,7 +2988,7 @@ public void SetPropertySetValueLiteralFlag()
             }
 
             /// <summary>
-            ///  SetImportedProperty Test,  null property name 
+            ///  SetImportedProperty Test,  null property name
             /// </summary>
             [Test]
             [ExpectedException(typeof(ArgumentNullException))]
@@ -3078,7 +3078,7 @@ private void AddNewImportOverload(Project p, string path, string condition)
         /// Tests for ProjectExtensions
         /// </summary>
         [TestFixture]
-        public sealed class ProjectExtensions 
+        public sealed class ProjectExtensions
         {
             /// <summary>
             /// GetProjectExtensions Test, where item id exists
@@ -3111,7 +3111,7 @@ public void GetProjectExtensionsWhereElementofIdMissing()
             }
 
             /// <summary>
-            /// GetProjectExtensions Test, check that namespace attributes are removed from nodes under an Id. 
+            /// GetProjectExtensions Test, check that namespace attributes are removed from nodes under an Id.
             /// </summary>
             [Test]
             public void GetProjectExtensionsNodePurgeNamespace()
@@ -3160,7 +3160,7 @@ public void SetProjectExtensionsNewItem_Null()
         /// Tests for EvaluatedItems EvaluatedItemsIgnoringCondition
         /// </summary>
         [TestFixture]
-        public sealed class EvaluatedItems 
+        public sealed class EvaluatedItems
         {
             /// <summary>
             /// EvaluatedItems, add an item, check addition to OM and xml
@@ -3220,7 +3220,7 @@ public void EvaluatedItemsIgnoreCondition()
         /// </summary>
         [TestFixture]
         public sealed class BuildItems
-        { 
+        {
             /// <summary>
             /// AddNewItem Test, pass in a a null item name
             /// </summary>
@@ -3302,7 +3302,7 @@ public void AddNewItemIncludePrecidece_SameTypes()
                 p.AddNewItem("i2", "d");
                 XmlDocument xmldoc = new XmlDocument();
                 xmldoc.LoadXml(p.Xml);
-                Assertion.AssertEquals(true, CompatibilityTestHelpers.GetNodesWithName(p.Xml, "ItemGroup")[1].InnerXml.Contains("Include=\"d\"")); 
+                Assertion.AssertEquals(true, CompatibilityTestHelpers.GetNodesWithName(p.Xml, "ItemGroup")[1].InnerXml.Contains("Include=\"d\""));
             }
 
             /// <summary>
@@ -3310,7 +3310,7 @@ public void AddNewItemIncludePrecidece_SameTypes()
             /// </summary>
             [Test]
             public void AddNewItemIncludePrecidece_NewGroup()
-            {       
+            {
                 Project p = ObjectModelHelpers.CreateInMemoryProject(TestData.ItemGroup2);
                 XmlDocument xmldoc = new XmlDocument();
                 xmldoc.LoadXml(p.Xml);
@@ -3528,11 +3528,11 @@ public void RemoveItemDirtyAfterRemove()
 
             /// <summary>
             /// RemoveItem Test, check that itemgroup is removed if removed item
-            /// was the last in the group. 
+            /// was the last in the group.
             /// </summary>
             [Test]
             public void RemoveItemLastInGroup()
-            {    
+            {
                 Project p = new Project();
                 BuildItem buildItem = p.AddNewItem("n", "i");
                 Assertion.AssertEquals(1, p.ItemGroups.Count);
@@ -3561,7 +3561,7 @@ public void RemoveItemsByNameXmlAndVirtual()
                 p.AddNewItem("j", "virtual");
                 p.RemoveItemsByName("j");
             }
-              
+
             /// <summary>
             /// ItemGroups Test, Assert colection contains virutal an concrete items
             /// </summary>
@@ -3594,7 +3594,7 @@ public void GetEvaluatedItemsByNameDoesNotExistItem()
                 Project p = new Project();
                 string name = "notFound";
                 BuildItemGroup emptyGroup = p.GetEvaluatedItemsByName(name);
-                Assertion.AssertEquals(0, emptyGroup.Count);  
+                Assertion.AssertEquals(0, emptyGroup.Count);
             }
 
             /// <summary>
@@ -3605,7 +3605,7 @@ public void GetEvaluatedItemsByNameTwoItems()
             {
                 Project p = new Project();
                 string name = "new";
-                p.SetProperty("condition", "false");            
+                p.SetProperty("condition", "false");
                 BuildItem buildItem = p.AddNewItem(name, "i1");
                 buildItem.Condition = "$(condition)";
                 p.AddNewItem(name, "i2");
@@ -3633,7 +3633,7 @@ public void GetEvaluatedItemsByNameIgnoringCondition()
             /// RemoveAllItemGroups Test, Remove all Item groups
             /// </summary>
             [Test]
-            public void RemoveAllItemGroups() 
+            public void RemoveAllItemGroups()
             {
                 Project p = new Project();
                 p.AddNewItem("item", "i");
@@ -3643,7 +3643,7 @@ public void RemoveAllItemGroups()
             }
 
             /// <summary>
-            /// RemoveAllItemGroups Test, project 
+            /// RemoveAllItemGroups Test, project
             /// </summary>
             [Test]
             public void RemoveAllItemGroupsDirtyAfterRemove()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/TargetCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/TargetCollection_Tests.cs
index 929bbcd5363..c8cbac228f7 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/TargetCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/TargetCollection_Tests.cs
@@ -108,7 +108,7 @@ public void CountMany()
         [Test]
         public void CountWithImportedTargets()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t2'>
                             <Message Text='imported.t2.task' />
@@ -117,7 +117,7 @@ public void CountWithImportedTargets()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='parent.t1.task' />
@@ -139,7 +139,7 @@ public void CountWithImportedTargets()
         [Test]
         public void CountWhenImportedAndParentBothContainSameTarget()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='imported.t2.task' />
@@ -147,7 +147,7 @@ public void CountWhenImportedAndParentBothContainSameTarget()
                     </Project>
                 ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='parent.t1.task' />
@@ -245,7 +245,7 @@ public void ExistsOfImportedTarget()
         [Test]
         public void ExistsWhenImportedTargetAndParentTargetHaveSameName()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='imported.t2.task' />
@@ -253,7 +253,7 @@ public void ExistsWhenImportedTargetAndParentTargetHaveSameName()
                     </Project>
                 ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='parent.t1.task' />
@@ -401,7 +401,7 @@ public void CopyToSimple()
 
             object[] array = new object[targets.Count];
             targets.CopyTo(array, 0);
-            
+
             List<string> listOfTargets = new List<string>();
             foreach (Target t in array)
             {
@@ -527,7 +527,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
         {
             if (String.IsNullOrEmpty(importProjectContents))
             {
-                importProjectContents = @" 
+                importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t2' />
                         <Target Name='t3' DependsOnTargets='t2' Inputs='in' Outputs='out' Condition=""'true' == 'true'""/>
@@ -538,7 +538,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
             if (String.IsNullOrEmpty(parentProjectContents))
             {
-                parentProjectContents = @" 
+                parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='parent.t1.task' />
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/Target_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/Target_Tests.cs
index 5e0eb30a014..7668dea1cc5 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/Target_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/Target_Tests.cs
@@ -39,7 +39,7 @@ public class Target_Tests
         /// </summary>
         private const string ProjectContentOneTargetWithInputsOutputs = @"
                                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                                    <Target Name='t1' 
+                                    <Target Name='t1'
                                             Outputs='out'
                                             Inputs='in' />
                                 </Project>
@@ -837,7 +837,7 @@ public void RemoveTaskAttemptWithTaskThatsInAnotherTarget()
         /// <summary>
         /// Tests Target.RemoveTask by attempting to remove a task from an imported target
         /// </summary>
-        [Test]  
+        [Test]
         [ExpectedException(typeof(InvalidOperationException))]
         public void RemoveTaskAttemptRemovalOfAnImportedTask()
         {
@@ -1063,7 +1063,7 @@ public void IsImportedOfANonImportedTarget()
         [Test]
         public void IsImportedTargetOfSameNameInBothWhereImportedComesLast()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='imported.t1.task' />
@@ -1071,7 +1071,7 @@ public void IsImportedTargetOfSameNameInBothWhereImportedComesLast()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='main.t1.task' />
@@ -1097,7 +1097,7 @@ public void IsImportedTargetOfSameNameInBothWhereImportedComesLast()
         [Test]
         public void IsImportedTargetOfSameNameInBothWhereImportedComesFirst()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='imported.t1.task' />
@@ -1105,7 +1105,7 @@ public void IsImportedTargetOfSameNameInBothWhereImportedComesFirst()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Import Project='import.proj' />
                         <Target Name='t1'>
@@ -1170,7 +1170,7 @@ private static void SaveProjectToDiskAndCompareAgainstExpectedContents(Project p
         /// <returns>Project</returns>
         private static Project GetProjectWithOneImportProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1' Condition=""'true' == 'true'"" Inputs='in' Outputs='out'>
                             <Message Text='imported.t1.task1' />
@@ -1179,7 +1179,7 @@ private static Project GetProjectWithOneImportProject()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Import Project='import1.proj' />
                         <Target Name='Build'>
@@ -1249,7 +1249,7 @@ private ITaskItem[] BuildAndGatherOutputs(string targetToBuild)
 
         /// <summary>
         /// Un-registers the existing logger and registers a new copy.
-        /// We will use this when we do multiple builds so that we can safely 
+        /// We will use this when we do multiple builds so that we can safely
         /// assert on log messages for that particular build.
         /// </summary>
         private void ResetLogger()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/ToolSet_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/ToolSet_Tests.cs
index 40c3501be80..18f16e6a9c5 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/ToolSet_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/ToolSet_Tests.cs
@@ -130,7 +130,7 @@ public void ToolsetImportProperties()
         /// </summary>
         [Test]
         public void ToolsetImportPropertiesNull()
-        {           
+        {
             BuildPropertyGroup buildPropertyGroup = null;
             Toolset toolset = new Toolset("toolversion", "c:\aPath", buildPropertyGroup);
             Assertion.AssertEquals(0, toolset.BuildProperties.Count);
@@ -163,7 +163,7 @@ public void ToolVersionGet()
         }
 
         /// <summary>
-        /// Toolset Test. Get Path (note stripping of the last slash) 
+        /// Toolset Test. Get Path (note stripping of the last slash)
         /// </summary>
         [Test]
         public void ToolPathGetTrailingSlash()
@@ -173,7 +173,7 @@ public void ToolPathGetTrailingSlash()
         }
 
         /// <summary>
-        /// Toolset Test. Get Path (root path, don't strip slash) 
+        /// Toolset Test. Get Path (root path, don't strip slash)
         /// </summary>
         [Test]
         public void ToolPathGetRootPath()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/ToolsetCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/ToolsetCollection_Tests.cs
index b49e5d85d1d..35055c8c6a4 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/ToolsetCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/ToolsetCollection_Tests.cs
@@ -181,7 +181,7 @@ public void ContainsObject_found()
             Toolset toolset2 = new Toolset("v2", @"c:\path");
             e.Toolsets.Add(toolset1);
             e.Toolsets.Add(toolset2);
-            
+
             Assertion.AssertEquals(true, e.Toolsets.Contains(toolset1));
         }
 
@@ -199,7 +199,7 @@ public void ContainsObject_notFound()
         }
 
         /// <summary>
-        /// Contains Test, by object. 
+        /// Contains Test, by object.
         /// </summary>
         [Test]
         public void ContainsToolsVersion_found()
@@ -213,7 +213,7 @@ public void ContainsToolsVersion_found()
         }
 
         /// <summary>
-        /// Contains Test, by object. 
+        /// Contains Test, by object.
         /// </summary>
         [Test]
         public void ContainsToolsVersion_notFound()
@@ -227,7 +227,7 @@ public void ContainsToolsVersion_notFound()
         }
 
         /// <summary>
-        /// Contains Test, by object. 
+        /// Contains Test, by object.
         /// </summary>
         [Test]
         public void ContainsToolsVersion_escapedVersions()
@@ -254,7 +254,7 @@ public void CopyToTest_IndexZero()
             Toolset toolset2 = new Toolset("v2", @"c:\path");
             e.Toolsets.Add(toolset1);
             e.Toolsets.Add(toolset2);
-            Toolset[] toolsetArray = new Toolset[e.Toolsets.Count]; 
+            Toolset[] toolsetArray = new Toolset[e.Toolsets.Count];
             e.Toolsets.CopyTo(toolsetArray, 0);
             Assertion.AssertEquals(e.Toolsets.Count, toolsetArray.Length);
             Assertion.AssertEquals(true, 0 < Array.IndexOf(toolsetArray, toolset1));
@@ -281,7 +281,7 @@ public void CopyToTest_OffsetIndex()
         }
 
         /// <summary>
-        /// CopyTo Test, copy into array that is initialized too small to contain all toolsets, 
+        /// CopyTo Test, copy into array that is initialized too small to contain all toolsets,
         /// at index zero
         /// </summary>
         [Test]
@@ -291,7 +291,7 @@ public void CopyToTest_ArrayTooSmall()
             Engine e = new Engine();
             Toolset toolset1 = new Toolset("v1", @"c:\path");
             e.Toolsets.Add(toolset1);
-            e.Toolsets.CopyTo(new Toolset[e.Toolsets.Count - 1], 0);  
+            e.Toolsets.CopyTo(new Toolset[e.Toolsets.Count - 1], 0);
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/UsingTaskCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/UsingTaskCollection_Tests.cs
index 7e9875d1e9c..5f65032a302 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/UsingTaskCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/UsingTaskCollection_Tests.cs
@@ -26,7 +26,7 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     public class UsingTaskCollection_Tests
     {
         /// <summary>
-        /// Imports Cache issue causes xml not to be loaded 
+        /// Imports Cache issue causes xml not to be loaded
         /// This is a test case to reproduce some quirkiness  found when running tests out of order.
         /// </summary>
         [Test]
@@ -116,10 +116,10 @@ public void Count_DecrementOnRemove()
         }
 
         /// <summary>
-        /// IsSynchronized Test           
+        /// IsSynchronized Test
         /// </summary>
         [Test]
-        public void IsSynchronized() 
+        public void IsSynchronized()
         {
             Project p = new Project(new Engine());
             p.AddNewUsingTaskFromAssemblyFile("TaskName", "AssemblyFile.dll");
@@ -127,7 +127,7 @@ public void IsSynchronized()
         }
 
         /// <summary>
-        /// SyncRoot Test, ensure that SyncRoot returns and we can take a lock on it.           
+        /// SyncRoot Test, ensure that SyncRoot returns and we can take a lock on it.
         /// </summary>
         [Test]
         public void SyncRoot()
@@ -149,7 +149,7 @@ public void SyncRoot()
         }
 
         /// <summary>
-        /// SyncRoot Test, copy into a strongly typed array and assert content against the source collection.        
+        /// SyncRoot Test, copy into a strongly typed array and assert content against the source collection.
         /// </summary>
         [Test]
         public void CopyTo_ZeroIndex()
@@ -168,7 +168,7 @@ public void CopyTo_ZeroIndex()
         }
 
         /// <summary>
-        /// SyncRoot Test, copy into a strongly typed array and assert content against the source collection.        
+        /// SyncRoot Test, copy into a strongly typed array and assert content against the source collection.
         /// </summary>
         [Test]
         public void CopyTo_OffsetIndex()
@@ -189,7 +189,7 @@ public void CopyTo_OffsetIndex()
         }
 
         /// <summary>
-        /// SyncRoot Test, copy into a strongly typed array with an offset where the array is too small      
+        /// SyncRoot Test, copy into a strongly typed array with an offset where the array is too small
         /// </summary>
         [Test]
         [ExpectedException(typeof(ArgumentException))]
@@ -204,7 +204,7 @@ public void CopyTo_OffsetIndexArrayTooSmall()
         }
 
         /// <summary>
-        /// Copy to a weakly typed array, no offset. Itterate over collection 
+        /// Copy to a weakly typed array, no offset. Itterate over collection
         /// </summary>
         [Test]
         public void CopyTo_WeakAndGetEnumerator()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/UsingTask_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/UsingTask_Tests.cs
index a18ddc9fb3c..1d3cc395fa9 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/UsingTask_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/UsingTask_Tests.cs
@@ -111,7 +111,7 @@ public void GetAssemblyFileNameSpecialCharsEscaped()
             string assemblyFileName = @"%25%2a%3f%40%24%28%29%3b\";
             Assertion.AssertNotNull(SetandGetAssemblyFileName(assemblyFileName));
         }
-        
+
         /// <summary>
         /// AssemblyFile test, set special non-escaped characters in ctor then get.
         /// </summary>
@@ -170,9 +170,9 @@ public void GetUsingTaskAssemblyFile_SetInXml()
             Assertion.AssertEquals("AssemblyName.dll", CompatibilityTestHelpers.FindUsingTaskByName("TaskName", p.UsingTasks).AssemblyFile);
         }
 
-        #endregion 
+        #endregion
 
-        #region TaskName 
+        #region TaskName
 
         /// <summary>
         /// TaskName Test, simple get
@@ -228,7 +228,7 @@ public void GetTaskNameSpeicalCharsEscaped()
         #region IsImported
 
         /// <summary>
-        /// IsImported Test, assert true for an improted file. 
+        /// IsImported Test, assert true for an improted file.
         /// </summary>
         [Test]
         public void IsImported_true()
@@ -251,7 +251,7 @@ public void IsImported_true()
         }
 
         /// <summary>
-        /// IsImported Test, assert true for an imported file. 
+        /// IsImported Test, assert true for an imported file.
         /// </summary>
         [Test]
         public void IsImported_false()
@@ -260,7 +260,7 @@ public void IsImported_false()
             p.LoadXml(TestData.ContentUsingTaskFile);
             object o = p.EvaluatedProperties;
             Assertion.AssertEquals(false, CompatibilityTestHelpers.FindUsingTaskByName("TaskName", p.UsingTasks).IsImported);
-        }   
+        }
 
         #endregion
 
@@ -303,7 +303,7 @@ public void GetUsingTaskCondition_SetInXml()
         #endregion
 
         /// <summary>
-        /// Set an assembly file name, then retrieve it. 
+        /// Set an assembly file name, then retrieve it.
         /// </summary>
         private string SetandGetAssemblyFileName(string assemblyFileName)
         {
@@ -312,6 +312,6 @@ private string SetandGetAssemblyFileName(string assemblyFileName)
             object o = p.EvaluatedItems;
             UsingTask usingTask = CompatibilityTestHelpers.FindUsingTaskByName("TaskName", p.UsingTasks);
             return usingTask.AssemblyFile;
-        }   
+        }
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/ConsoleLogger_Tests.cs b/src/Deprecated/Engine.UnitTests/ConsoleLogger_Tests.cs
index c20ec968081..1950b531777 100644
--- a/src/Deprecated/Engine.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ConsoleLogger_Tests.cs
@@ -104,7 +104,7 @@ private static void SingleMessageTest(LoggerVerbosity v, MessageImportance j, bo
                                   sc.Write, null, null);
                 L.Initialize(es, i);
                 string msg = "my 1337 message";
-                
+
                 BuildMessageEventArgs be = new BuildMessageEventArgs(msg, "help", "sender", j);
                 be.BuildEventContext = new BuildEventContext(1, 2, 3, 4);
                 es.RaiseMessageEvent(null, be);
@@ -279,7 +279,7 @@ public void TestVerbosityLessThan()
                 (new SerialConsoleLogger(LoggerVerbosity.Detailed)).IsVerbosityAtLeast(LoggerVerbosity.Detailed));
             Assertion.AssertEquals( false,
                 (new SerialConsoleLogger(LoggerVerbosity.Detailed)).IsVerbosityAtLeast(LoggerVerbosity.Diagnostic));
-            
+
             Assertion.AssertEquals( true,
                 (new SerialConsoleLogger(LoggerVerbosity.Diagnostic)).IsVerbosityAtLeast(LoggerVerbosity.Quiet));
             Assertion.AssertEquals( true,
@@ -362,7 +362,7 @@ public void SingleMessageTests_quiet_low()
         public void SingleMessageTests_quiet_medium()
         {
                 SingleMessageTest(LoggerVerbosity.Quiet,
-                                 MessageImportance.Normal, false); 
+                                 MessageImportance.Normal, false);
         }
 
         [Test]
@@ -373,7 +373,7 @@ public void SingleMessageTests_quiet_high()
         }
 
         [Test]
-        public void SingleMessageTests_medium_low() 
+        public void SingleMessageTests_medium_low()
         {
                 SingleMessageTest(LoggerVerbosity.Minimal,
                                  MessageImportance.Low, false);
@@ -383,7 +383,7 @@ public void SingleMessageTests_medium_low()
         public void SingleMessageTests_medium_medium()
         {
                 SingleMessageTest(LoggerVerbosity.Minimal,
-                                 MessageImportance.Normal, false); 
+                                 MessageImportance.Normal, false);
         }
 
         [Test]
@@ -402,9 +402,9 @@ public void SingleMessageTests_normal_low()
 
         [Test]
         public void SingleMessageTests_normal_medium()
-        { 
+        {
                 SingleMessageTest(LoggerVerbosity.Normal,
-                                 MessageImportance.Normal, true); 
+                                 MessageImportance.Normal, true);
         }
 
         [Test]
@@ -425,7 +425,7 @@ public void SingleMessageTests_detailed_low()
         public void SingleMessageTests_detailed_medium()
         {
                 SingleMessageTest(LoggerVerbosity.Detailed,
-                                 MessageImportance.Normal, true); 
+                                 MessageImportance.Normal, true);
         }
 
         [Test]
@@ -443,10 +443,10 @@ public void SingleMessageTests_diagnostic_low()
         }
 
         [Test]
-        public void SingleMessageTests_diagnostic_medium() 
+        public void SingleMessageTests_diagnostic_medium()
         {
                 SingleMessageTest(LoggerVerbosity.Diagnostic,
-                                 MessageImportance.Normal, true); 
+                                 MessageImportance.Normal, true);
         }
 
         [Test]
@@ -648,7 +648,7 @@ public void TestQuietWithError()
                 BuildErrorEventArgs beea = new BuildErrorEventArgs("VBC",
                                 "31415", "file.vb", 42, 0, 0, 0,
                                 "Some long message", "help", "sender");
-                
+
                 beea.BuildEventContext = buildEventContext;
                 es.RaiseErrorEvent(null, beea);
 
@@ -1076,7 +1076,7 @@ public void SingleLineFormatNoop()
             string ss = cl.IndentString(s, 0);
 
             //should be a no-op
-            Assertion.AssertEquals("foo" + Environment.NewLine, ss); 
+            Assertion.AssertEquals("foo" + Environment.NewLine, ss);
         }
 
         [Test]
@@ -1092,8 +1092,8 @@ public void MultilineFormatWindowsLineEndings()
             //should convert lines to system format
             Assertion.AssertEquals("    foo" + Environment.NewLine +
                                    "    bar" + Environment.NewLine +
-                                   "    baz" + Environment.NewLine + 
-                                   "    " + Environment.NewLine, ss); 
+                                   "    baz" + Environment.NewLine +
+                                   "    " + Environment.NewLine, ss);
         }
 
         [Test]
@@ -1107,7 +1107,7 @@ public void MultilineFormatUnixLineEndings()
             //should convert lines to system format
             Assertion.AssertEquals("foo" + Environment.NewLine +
                                    "bar" + Environment.NewLine +
-                                   "baz" + Environment.NewLine + Environment.NewLine, ss); 
+                                   "baz" + Environment.NewLine + Environment.NewLine, ss);
         }
 
         [Test]
@@ -1303,19 +1303,19 @@ public void NestedProjectNormal()
         [Test]
         public void CustomDisplayedAtDetailed()
         {
-            EventSource es = new EventSource(); 
-            SimulatedConsole sc = new SimulatedConsole(); 
+            EventSource es = new EventSource();
+            SimulatedConsole sc = new SimulatedConsole();
             ConsoleLogger L = new ConsoleLogger(LoggerVerbosity.Detailed,
                                                 sc.Write, null, null);
-            L.Initialize(es); 
+            L.Initialize(es);
 
-            MyCustomBuildEventArgs c = 
+            MyCustomBuildEventArgs c =
                     new MyCustomBuildEventArgs("msg");
 
             es.RaiseCustomEvent(null, c);
 
-            Assertion.AssertEquals("msg" + Environment.NewLine, 
-                                   sc.ToString()); 
+            Assertion.AssertEquals("msg" + Environment.NewLine,
+                                   sc.ToString());
         }
 
         [Test]
@@ -1338,18 +1338,18 @@ public void CustomDisplayedAtDiagnosticMP()
         [Test]
         public void CustomNotDisplayedAtNormal()
         {
-            EventSource es = new EventSource(); 
-            SimulatedConsole sc = new SimulatedConsole(); 
+            EventSource es = new EventSource();
+            SimulatedConsole sc = new SimulatedConsole();
             ConsoleLogger L = new ConsoleLogger(LoggerVerbosity.Normal,
                                                 sc.Write, null, null);
-            L.Initialize(es); 
+            L.Initialize(es);
 
-            MyCustomBuildEventArgs c = 
+            MyCustomBuildEventArgs c =
                     new MyCustomBuildEventArgs("msg");
 
             es.RaiseCustomEvent(null, c);
 
-            Assertion.AssertEquals(String.Empty, sc.ToString()); 
+            Assertion.AssertEquals(String.Empty, sc.ToString());
         }
 
         /// <summary>
@@ -1453,7 +1453,7 @@ public void DoNotDisplayPropertiesListIfDisabled()
             cl2.ParseParameters();
 
             WriteAndValidateProperties(cl, sc, false);
-        }       
+        }
 
         /// <summary>
         /// Create some items and log them
@@ -1488,7 +1488,7 @@ private void WriteAndValidateItems(BaseConsoleLogger cl, SimulatedConsole sc, bo
 
             item1type = "type" + Environment.NewLine;
             item2type = "type2" + Environment.NewLine;
-            
+
             string log = sc.ToString();
 
             Console.WriteLine("[" + log + "]");
@@ -1650,7 +1650,7 @@ public void DoNotDisplayItemListIfDisabled()
             cl2.ParseParameters();
 
             WriteAndValidateItems(cl2, sc, false);
-        }       
+        }
 
         [Test]
         public void ParametersEmptyTests()
@@ -1766,7 +1766,7 @@ public void ResetConsoleLoggerStateTestBasic()
             es.RaiseBuildStartedEvent(null,
                          new BuildStartedEventArgs("bs", null));
 
-            // BuildFinished 
+            // BuildFinished
             es.RaiseBuildFinishedEvent(null,
                           new BuildFinishedEventArgs("bf",
                                                      null, true));
@@ -1783,12 +1783,12 @@ public void ResetConsoleLoggerStateTestBasic()
             Assertion.Assert(!actualLog.Contains(warningString));
             Assertion.Assert(!actualLog.Contains("<red>"));
             Assertion.Assert(!actualLog.Contains("<yellow>"));
-            
+
             // errorString = 0 Error(s)
             // warningString = 0 Warning(s)
             errorString = ResourceUtilities.FormatResourceString("ErrorCount", 0);
             warningString = ResourceUtilities.FormatResourceString("WarningCount", 0);
-            
+
             // Verify that the log has correct error and warning string
             Assertion.Assert(actualLog.Contains(errorString));
             Assertion.Assert(actualLog.Contains(warningString));
@@ -1835,8 +1835,8 @@ public void ResetConsoleLoggerState_Initialize()
 
             es.RaiseErrorEvent(null, beea);
 
-            // NOTE: We don't call the es.RaiseBuildFinishedEvent(...) here as this 
-            // would call ResetConsoleLoggerState and we will fail to detect if Initialize() 
+            // NOTE: We don't call the es.RaiseBuildFinishedEvent(...) here as this
+            // would call ResetConsoleLoggerState and we will fail to detect if Initialize()
             // is not calling it.
 
             // Log so far
@@ -1860,7 +1860,7 @@ public void ResetConsoleLoggerState_Initialize()
             es.RaiseBuildStartedEvent(null,
                          new BuildStartedEventArgs("bs", null));
 
-            // BuildFinished 
+            // BuildFinished
             es.RaiseBuildFinishedEvent(null,
                           new BuildFinishedEventArgs("bf",
                                                      null, true));
@@ -1922,7 +1922,7 @@ public void ResetConsoleLoggerState_PerformanceCounters()
 
                 TaskStartedEventArgs taskStarted1 = new TaskStartedEventArgs(null, null, null, null, "task");
                 taskStarted1.BuildEventContext = project1Started.BuildEventContext;
-                // TaskStarted Event 
+                // TaskStarted Event
                 es.RaiseTaskStartedEvent(null, taskStarted1);
 
                 BuildMessageEventArgs messsage1 = new BuildMessageEventArgs(null, null, null, MessageImportance.High);
@@ -1950,7 +1950,7 @@ public void ResetConsoleLoggerState_PerformanceCounters()
 
                 TaskStartedEventArgs taskStarted2 = new TaskStartedEventArgs(null, null, null, null, "task2");
                 taskStarted2.BuildEventContext = project2Started.BuildEventContext;
-                // TaskStarted Event 
+                // TaskStarted Event
                 es.RaiseTaskStartedEvent(null, taskStarted2);
 
                 BuildMessageEventArgs messsage2 = new BuildMessageEventArgs(null, null, null, MessageImportance.High);
@@ -2000,7 +2000,7 @@ public void ResetConsoleLoggerState_PerformanceCounters()
                 // BuildStarted event
                 es.RaiseBuildStartedEvent(null,
                              new BuildStartedEventArgs("bs", null));
-                // BuildFinished 
+                // BuildFinished
                 es.RaiseBuildFinishedEvent(null,
                               new BuildFinishedEventArgs("bf",
                                                          null, true));
@@ -2054,7 +2054,7 @@ public void DeferredMessages()
                                                      null, true));
             actualLog = sc.ToString();
             Assertion.Assert(actualLog.Contains(ResourceUtilities.FormatResourceString("DeferredMessagesAvailiable")));
-            
+
             es = new EventSource();
             sc = new SimulatedConsole();
             // Create a ConsoleLogger with Normal verbosity
@@ -2159,9 +2159,9 @@ public void TestPrintTargetNamePerMessage()
         }
 
         /// <summary>
-        /// Verify that in the MP case and the older serial logger that there is no extra newline after the project done event. 
+        /// Verify that in the MP case and the older serial logger that there is no extra newline after the project done event.
         /// We cannot verify there is a newline after the project done event for the MP single proc log because
-        /// nunit is showing up as an unknown output type, this causes us to not print the newline because we think it may be to a 
+        /// nunit is showing up as an unknown output type, this causes us to not print the newline because we think it may be to a
         /// text file.
         /// </summary>
         [Test]
@@ -2172,7 +2172,7 @@ public void TestNewLineAfterProjectFinished()
             {
                 Console.Out.WriteLine("Iteration of I is {" + i + "}");
 
-                
+
                 EventSource es = new EventSource();
                 //Create a simulated console
                 SimulatedConsole sc = new SimulatedConsole();
diff --git a/src/Deprecated/Engine.UnitTests/CopyOnWriteHashtable_Tests.cs b/src/Deprecated/Engine.UnitTests/CopyOnWriteHashtable_Tests.cs
index 8a1b3cf86ea..0a277eee44a 100644
--- a/src/Deprecated/Engine.UnitTests/CopyOnWriteHashtable_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/CopyOnWriteHashtable_Tests.cs
@@ -29,7 +29,7 @@ public void Basic()
 
             // Just wrote to 'c' so it should contain data.
             Assertion.Assert(c.ContainsKey("Foo"));
-            
+
             // Writing to a depended upon hashtable should not be visible to the dependents.
             Assertion.Assert(!a.ContainsKey("Foo"));
             Assertion.Assert(!b.ContainsKey("Foo"));
@@ -63,7 +63,7 @@ public void Regress450669_CaseSensitiveBatch_HashtableCopyRespectsComparer()
         {
             Hashtable c = new Hashtable(StringComparer.OrdinalIgnoreCase);
             c["key"] = null;
-            CopyOnWriteHashtable refc = new CopyOnWriteHashtable(c, StringComparer.OrdinalIgnoreCase); 
+            CopyOnWriteHashtable refc = new CopyOnWriteHashtable(c, StringComparer.OrdinalIgnoreCase);
 
             Assertion.Assert(c.ContainsKey("kEy"));
             Assertion.Assert(refc.ContainsKey("kEy"));
@@ -72,7 +72,7 @@ public void Regress450669_CaseSensitiveBatch_HashtableCopyRespectsComparer()
         /// <summary>
         /// Missing unittest found by mutation testing.
         /// REASON TEST WASN'T ORIGINALLY PRESENT: (Note 1)
-        /// 
+        ///
         /// In this test, verify that a CopyOnWriteHashtable passed through the constructor that
         /// accepts an IDictionary results in a shallow copy not a deep copy.
         /// </summary>
@@ -88,7 +88,7 @@ public void Regress_Mutation_ConstructThroughDictionaryIsShallowCopy()
         /// <summary>
         /// Missing unittest found by mutation testing.
         /// REASON TEST WASN'T ORIGINALLY PRESENT: (Note 1)
-        /// 
+        ///
         /// In this test, verify that writing a value that exists already in a shallow copy
         /// doesn't cause a deep copy of the hash table.
         /// </summary>
@@ -98,7 +98,7 @@ public void Regress_Mutation_WritingSameValueShouldNotCauseDeepCopy()
             CopyOnWriteHashtable c = new CopyOnWriteHashtable(StringComparer.OrdinalIgnoreCase);
             c["answer"] = "yes";
             CopyOnWriteHashtable refc = new CopyOnWriteHashtable(c, StringComparer.OrdinalIgnoreCase);
-            
+
             Assertion.Assert(refc.IsShallowCopy);
             refc["answer"] = "yes";
             Assertion.Assert(refc.IsShallowCopy);  // Setting the same value should not cause a deep copy.
@@ -107,10 +107,10 @@ public void Regress_Mutation_WritingSameValueShouldNotCauseDeepCopy()
 
         /// <summary>
         /// Missing unittest found by mutation testing.
-        /// REASON TEST WASN'T ORIGINALLY PRESENT: This is a design change, we require a string comparer 
+        /// REASON TEST WASN'T ORIGINALLY PRESENT: This is a design change, we require a string comparer
         /// in all cases because we can't construct a deep copy without always knowing what string
         /// comparer to use.
-        /// 
+        ///
         /// In this test, try to construct a CopyOnWriteHashtable with no string comparer.
         /// </summary>
         [Test]
@@ -122,10 +122,10 @@ public void Regress_Mutation_MustHaveNonNullStringComparer()
 
         /// <summary>
         /// Missing unittest found by mutation testing.
-        /// REASON TEST WASN'T ORIGINALLY PRESENT: This is a design change, we require a string comparer 
+        /// REASON TEST WASN'T ORIGINALLY PRESENT: This is a design change, we require a string comparer
         /// in all cases because we can't construct a deep copy without always knowing what string
         /// comparer to use.
-        /// 
+        ///
         /// In this test, try to construct a CopyOnWriteHashtable with no string comparer.
         /// </summary>
         [Test]
@@ -138,7 +138,7 @@ public void Regress_Mutation_MustHaveNonNullStringComparer2()
         /// <summary>
         /// Missing unittest found by mutation testing.
         /// REASON TEST WASN'T ORIGINALLY PRESENT: Missed test.
-        /// 
+        ///
         /// In this test, make sure Clear works on shallow-copy hashtable.
         /// </summary>
         [Test]
@@ -157,11 +157,11 @@ public void Regress_Mutation_ClearReadOnlyData()
 
         /*
          * Root cause analysis: reasons for missing tests:
-         * 
+         *
          * (Note 1) It was intended that the user of CopyOnWriteHashtable should not be able to detect
          *          whether a shallow copy or deep copy was made. So there was no way to unittest this.
          *          This test required adding 'IsShallowCopy' to detect this case.
-         * 
+         *
          */
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/DualQueue_Tests.cs b/src/Deprecated/Engine.UnitTests/DualQueue_Tests.cs
index 36f96f964a3..a534f048eb9 100644
--- a/src/Deprecated/Engine.UnitTests/DualQueue_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/DualQueue_Tests.cs
@@ -34,8 +34,8 @@ public void TestQueueEnqueueMultipleWriterOneReader()
             // List of strings which are supposed to be in the queue
             List<string> stringsSupposedToBeInQueue  = new List<string>();
             // List of strings which are supposed to be in the queue which uses EnQueueArray
-            List<string> stringsSupposedToBeInQueueTwo = new List<string>();  
-            
+            List<string> stringsSupposedToBeInQueueTwo = new List<string>();
+
             // Array containing our set of ManualResetEvents which is the number of threads we are going to use
             ManualResetEvent[] waitHandles = new ManualResetEvent[50];
             for (int i = 0; i < waitHandles.Length; i++)
@@ -48,7 +48,7 @@ public void TestQueueEnqueueMultipleWriterOneReader()
                                   string string1 = System.Guid.NewGuid().ToString();
                                   string string2 = System.Guid.NewGuid().ToString();
                                   string string3 = System.Guid.NewGuid().ToString();
-                                  
+
                                   stringQueue.Enqueue(string1);
                                   lock (stringsSupposedToBeInQueue)
                                   {
@@ -61,18 +61,18 @@ public void TestQueueEnqueueMultipleWriterOneReader()
                                       stringsSupposedToBeInQueueTwo.Add(string2);
                                       stringsSupposedToBeInQueueTwo.Add(string3);
                                   }
-                                  
+
                                   // Say we are done the thread
                                   ((ManualResetEvent)state).Set();
                               }, waitHandles[i]);
             }
-            
+
           // Wait for all of the threads to complete
             foreach (ManualResetEvent resetEvent in waitHandles)
             {
                 resetEvent.WaitOne();
             }
-          
+
             // Pop off items from the queue and make sure that we got all of out items back out
             int numberOfItemsInQueue = 0;
             string result = null;
diff --git a/src/Deprecated/Engine.UnitTests/EngineLoggingServices_Tests.cs b/src/Deprecated/Engine.UnitTests/EngineLoggingServices_Tests.cs
index 523d1efcd70..0bed8bf8274 100644
--- a/src/Deprecated/Engine.UnitTests/EngineLoggingServices_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/EngineLoggingServices_Tests.cs
@@ -42,7 +42,7 @@ internal EngineLoggingServicesHelper()
         }
 
         /// <summary>
-        /// We dont need to do anything to process events, we just want to get what events are in the queue 
+        /// We dont need to do anything to process events, we just want to get what events are in the queue
         /// </summary>
         internal override bool ProcessPostedLoggingEvents()
         {
@@ -153,7 +153,7 @@ public void TearDown()
         public void LogErrorEvent()
         {
             List<BuildEventArgs> eventList = new List<BuildEventArgs>();
-            
+
             // Log a number of events and then make sure that queue at the end contains all of those events
             for (int i = 0; i < 10; i++)
             {
@@ -164,17 +164,17 @@ public void LogErrorEvent()
 
             // Get the logging queue after we have logged a number of messages
            DualQueue<BuildEventArgs> currentQueue = engineLoggingServicesHelper.GetCurrentQueueBuildEvents();
-            
+
             // Assert that every event we sent to the logger exists in the queue
             Assert.IsTrue(eventList.TrueForAll(delegate(BuildEventArgs args)
                                                {
                                                    return currentQueue.Contains(args);
                                                }), "Expected to find all events sent to LogErrorEvent");
-            
+
             // Assert that every event in the queue is of the correct type
             AssertForEachEventInQueue(currentQueue, IsInstanceOfType<BuildErrorEventArgs>);
         }
-        
+
         /// <summary>
         /// Test the case where null events are attempted to be logged
         /// </summary>
@@ -184,7 +184,7 @@ public void LogErrorEventNullEvent()
         {
             engineLoggingServicesHelper.LogErrorEvent(null);
         }
-        
+
         /// <summary>
         /// Test warning events
         /// </summary>
@@ -192,7 +192,7 @@ public void LogErrorEventNullEvent()
         public void LogWarningEvent()
         {
             List<BuildEventArgs> eventList = new List<BuildEventArgs>();
-           
+
             // Log a number of events
             for (int i = 0; i < 10; i++)
             {
@@ -200,7 +200,7 @@ public void LogWarningEvent()
                 eventList.Add(eventToAdd);
                 engineLoggingServicesHelper.LogWarningEvent(eventToAdd);
             }
-            
+
             // Get the logged event queue from the "logger"
            DualQueue<BuildEventArgs> currentQueue = engineLoggingServicesHelper.GetCurrentQueueBuildEvents();
 
@@ -209,7 +209,7 @@ public void LogWarningEvent()
                                                {
                                                    return currentQueue.Contains(args);
                                                }), "Expected to find all events sent to LogWarningEvent");
-            
+
             // Assert that every event in the queue is of the correct type
             AssertForEachEventInQueue(currentQueue, IsInstanceOfType<BuildWarningEventArgs>);
         }
@@ -254,7 +254,7 @@ public void LogMessageEventNullEvent()
         public void LogMessageEvent()
         {
             List<BuildEventArgs> eventList = new List<BuildEventArgs>();
-            
+
             // Log a number of message events and keep track of the events we tried to log
             for (int i = 0; i < 10; i++)
             {
@@ -304,7 +304,7 @@ public void LogCustomEventNullEvent()
         public void LogCustomEvent()
         {
             List<BuildEventArgs> eventList = new List<BuildEventArgs>();
-            
+
             // Log a number of events and keep track of which events we sent to the logger
             for (int i = 0; i < 10; i++)
             {
@@ -321,7 +321,7 @@ public void LogCustomEvent()
                                                {
                                                    return currentQueue.Contains(args);
                                                }), "Expected to find all events sent to logcustomevent");
-            
+
             // Assert that every event in the queue is of the correct type
             AssertForEachEventInQueue(currentQueue, IsInstanceOfType<MyCustomBuildEventArgs>);
         }
@@ -378,7 +378,7 @@ public void PostLoggingEventMessageEvent()
         public void PostLoggingEventMultiThreaded()
         {
             List<BuildEventArgs> eventsAdded = new List<BuildEventArgs>();
-            
+
             // Add a number of events on multiple threads
             ManualResetEvent[] waitHandles = new ManualResetEvent[10];
             for (int i = 0; i < waitHandles.Length; i++)
@@ -439,7 +439,7 @@ public void LogCommentFromTextNullMessage()
             // Would have tested the case where null was passed and critical events is false, but this would cause an assertion window
             // to popup thereby failing the test
         }
-       
+
         /// <summary>
         /// Test logging messages to the logger
         /// </summary>
@@ -449,21 +449,21 @@ public void LogCommentFromTextGoodMessages()
             // Send a message, this message should be posted to the queue
             engineLoggingServicesHelper.LogCommentFromText(null, MessageImportance.Low, "Message");
             engineLoggingServicesHelper.LogCommentFromText(null, MessageImportance.Low, string.Empty);
-            
+
             // Make sure that the one message got posted to the queue
             DualQueue<BuildEventArgs> currentQueue = engineLoggingServicesHelper.GetCurrentQueueBuildEvents();
             Assert.IsTrue(currentQueue.Count == 2, "Expected to find two events on the queue");
             AssertForEachEventInQueue(currentQueue, IsInstanceOfType<BuildMessageEventArgs>);
 
         }
-        
+
         /// <summary>
         /// Test logging message comments to the logger
         /// </summary>
         [Test]
         public void LogCommentGoodMessages()
         {
-            // Send a message while not logging critical events, since comments are not considered critical they should 
+            // Send a message while not logging critical events, since comments are not considered critical they should
             // not show up in the queue
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogComment((BuildEventContext)null, MessageImportance.Normal, "ErrorConvertedIntoWarning");
@@ -478,13 +478,13 @@ public void LogCommentGoodMessages()
             engineLoggingServicesHelper.LogComment((BuildEventContext)null, MessageImportance.Normal, "ErrorConvertedIntoWarning", 3);
             engineLoggingServicesHelper.LogComment((BuildEventContext)null, "ErrorConvertedIntoWarning");
             engineLoggingServicesHelper.LogComment((BuildEventContext)null, "ErrorCount", 3);
-            
+
             // Get the queue from the logger
            DualQueue<BuildEventArgs> currentQueue = engineLoggingServicesHelper.GetCurrentQueueBuildEvents();
-            
+
             // Make sure we got all the events we sent to the logger
             Assert.IsTrue(currentQueue.Count == 4, "Expected to find four events on the queue");
-            
+
             // Make sure that every event in the queue is of the correct type
             AssertForEachEventInQueue(currentQueue, IsInstanceOfType<BuildMessageEventArgs>);
         }
@@ -552,7 +552,7 @@ public void LogTaskStarted()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogTaskStarted(null, "taskName", "projectFile", "projectFileOfTaskNode");
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected to find no events in the queue");
-            
+
             // Test logging while logging all events
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogTaskStarted(null, "taskName", "projectFile", "projectFileOfTaskNode");
@@ -571,7 +571,7 @@ public void LogTaskFinished()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogTaskFinished(null, "taskName", "projectFile", "projectFileOfTaskNode", true);
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected to find no events in the queue");
-            
+
             // Test logging while logging all events
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogTaskFinished(null, "taskName", "projectFile", "projectFileOfTaskNode", true);
@@ -590,7 +590,7 @@ public void LogTargetStarted()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogTargetStarted(null, "TargetName", "projectFile", "projectFileOfTargetNode");
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected to find no events in the queue");
-            
+
             // Test logging while logging all events
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogTargetStarted(null, "targetName", "projectFile", "projectFileOfTargetNode");
@@ -609,7 +609,7 @@ public void LogTargetFinished()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogTargetFinished(null, "TargetName", "projectFile", "projectFileOfTargetNode", true);
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected to find no events in the queue");
-            
+
             // Test logging while logging all events, even non critical ones
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogTargetFinished(null, "TargetName", "projectFile", "projectFileOfTargetNode", true);
@@ -628,7 +628,7 @@ public void LogProjectStarted()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogProjectStarted(-1, null, null, "projectFile", "targetNames", null, null);
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected to find no events in the queue");
-            
+
             // Test logging while logging all events, even non critical ones
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogProjectStarted(-1, null, null, "projectFile", "targetNames", null, null);
@@ -647,7 +647,7 @@ public void LogProjectFinished()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogProjectFinished(null, "projectFile", true);
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected no events in queue but found some");
-            
+
             //Test logging while logging all events, even non critical ones
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogProjectFinished(null, "projectFile", true);
@@ -1252,9 +1252,9 @@ public void ConfigurationByEngine()
         #endregion
 
         #region OutProcLoggingTest
-       
+
         /// <summary>
-        /// Test logging the out of proc logger by sending events to the logger and check 
+        /// Test logging the out of proc logger by sending events to the logger and check
         /// the inproc logger queue which is the eventual handler of the events
         /// </summary>
         [Test]
@@ -1263,14 +1263,14 @@ public void OutProcLoggingTest()
 
             VerifyEventSourceHelper eventSourceHelper = new VerifyEventSourceHelper();
             EngineLoggingServicesInProc inProcLoggingServicesEventsAllEvents = new EngineLoggingServicesInProc(eventSourceHelper.sourceForEvents, false, new ManualResetEvent(false));
-            
+
 
             Engine buildEngine = new Engine();
             buildEngine.LoggingServices = inProcLoggingServicesEventsAllEvents;
-            
+
             EngineCallback outProcessorProxy = new EngineCallback(buildEngine);
             int nodeId = buildEngine.GetNextNodeId();
-            Node parentNode = new Node(nodeId, new LoggerDescription[0], outProcessorProxy, null, 
+            Node parentNode = new Node(nodeId, new LoggerDescription[0], outProcessorProxy, null,
                 ToolsetDefinitionLocations.ConfigurationFile | ToolsetDefinitionLocations.Registry, String.Empty);
 
 
@@ -1418,7 +1418,7 @@ public void OutProcLoggingTest()
             inProcLoggingServicesEventsAllEvents.ProcessPostedLoggingEvents();
             eventSourceHelper.AssertEventsAndNoOthers("anyEventRaised", "messageRaised");
             eventSourceHelper.ClearEvents();
-            
+
             //send a lot of events to test the event batching
             for (int i = 0; i < 600; i++)
             {
@@ -1432,7 +1432,7 @@ public void OutProcLoggingTest()
             // Check that the events are correctly sorted when posted with different logger ids
             loggingServicesOutProc.PostLoggingEvent(new BuildMessageEventArgs("Message", "help", "sender", MessageImportance.Low));
             loggingServicesOutProc.PostLoggingEvent(new NodeLoggingEventWithLoggerId(new BuildStartedEventArgs("message", "help"), EngineLoggingServicesInProc.FIRST_AVAILABLE_LOGGERID));
-            loggingServicesOutProc.PostLoggingEvent(new NodeLoggingEventWithLoggerId(new TargetFinishedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile", true), 
+            loggingServicesOutProc.PostLoggingEvent(new NodeLoggingEventWithLoggerId(new TargetFinishedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile", true),
                                                                                      EngineLoggingServicesInProc.FIRST_AVAILABLE_LOGGERID +1));
             loggingServicesOutProc.ProcessPostedLoggingEvents();
             inProcLoggingServicesEventsAllEvents.ProcessPostedLoggingEvents();
diff --git a/src/Deprecated/Engine.UnitTests/Engine_Tests.cs b/src/Deprecated/Engine.UnitTests/Engine_Tests.cs
index a1f4f2dd994..09d0fc9d8fb 100644
--- a/src/Deprecated/Engine.UnitTests/Engine_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Engine_Tests.cs
@@ -35,7 +35,7 @@ public void TestMSBuildForwardPropertiesFromChild()
             string[] propertiesToSerialize = childEngine.PropertyListToSerialize;
             Assert.IsNull(propertiesToSerialize, "Expected propertiesToSerialize to be null");
 	    childEngine.Shutdown();
-            
+
 	    Environment.SetEnvironmentVariable("MSBuildForwardPropertiesFromChild", string.Empty);
             childEngine = new Engine(new BuildPropertyGroup(), new ToolsetDefinitionLocations(), 3, true, 3, string.Empty, string.Empty);
             propertiesToSerialize = childEngine.PropertyListToSerialize;
@@ -71,7 +71,7 @@ public void TestMSBuildForwardPropertiesFromChild()
              Assert.IsTrue(string.Compare(propertiesToSerialize[0], "Platform") == 0);
              Assert.IsTrue(propertiesToSerialize.Length == 1);
              childEngine.Shutdown();
-             
+
             Environment.SetEnvironmentVariable("MSBuildForwardPropertiesFromChild", ";Platform");
              childEngine = new Engine(new BuildPropertyGroup(), new ToolsetDefinitionLocations(), 3, true, 3, string.Empty, string.Empty);
              propertiesToSerialize = childEngine.PropertyListToSerialize;
@@ -156,7 +156,7 @@ public void TestTEMBatchSizeSettings()
         public void SettingDefaultToolsVersionThrowsIfProjectsAlreadyLoaded()
         {
             Engine e = new Engine(ToolsetDefinitionLocations.None);
-            
+
             try
             {
                 e.AddToolset(new Toolset("1.0", "someToolsPath"));
@@ -166,7 +166,7 @@ public void SettingDefaultToolsVersionThrowsIfProjectsAlreadyLoaded()
             catch(InvalidOperationException)
             {
                 // Make sure the first one doesn't throw
-                Assertion.Assert(false); 
+                Assertion.Assert(false);
             }
 
             try
@@ -238,7 +238,7 @@ public void GetToolsVersionNames()
             // Check the contents after adding two more tools versions
             e.Toolsets.Add(new Toolset("Whidbey", @"C:\WhidbeyPath"));
             e.Toolsets.Add(new Toolset("orcas", @"C:\OrcasBinPath"));
-            
+
             Dictionary<string, object> toolsVersionNamesDictionary = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
             foreach (string name in e.Toolsets.ToolsVersions)
             {
@@ -367,11 +367,11 @@ public void MalformedProjectDoesNotGetAddedToEngine
                 // Get a little extra code coverage
                 myEngine.UnregisterAllLoggers();
                 myEngine.UnloadAllProjects();
-                
+
                 File.Delete(projectFile);
             }
         }
-        
+
         /// <summary>
         /// Engine.BuildProjectFile method with project file specified does not honor global properties set in the engine object
         /// Bug VSWhidbey 570988.
@@ -396,7 +396,7 @@ public void BuildProjectFileWithGlobalPropertiesSetInEngineObjectWithProjectFile
                 File.Delete(projectFile);
             }
         }
-        
+
         /// <summary>
         /// Engine.BuildProjectFile method with project file and target specified does not honor global properties set in the engine object
         /// Bug VSWhidbey 570988.
@@ -421,7 +421,7 @@ public void BuildProjectFileWithGlobalPropertiesSetInEngineObjectWithProjectFile
                 File.Delete(projectFile);
             }
         }
-        
+
         /// <summary>
         /// Engine.BuildProjectFile method with project file and target list specified does not honor global properties set in the engine object
         /// Bug VSWhidbey 570988.
@@ -512,10 +512,10 @@ public void BuildProjectFilesInParallel()
                 }
 
                 // Test building a traversal
-              
+
                 engine.BuildProjectFile(traversalProject);
                 engine.Shutdown();
-                
+
                 // Test building the same set of files in parallel
                 Console.Out.WriteLine("1:"+Process.GetCurrentProcess().MainModule.FileName);
                 Console.Out.WriteLine("2:" + AppDomain.CurrentDomain.BaseDirectory);
@@ -565,7 +565,7 @@ public void BuildProjectFilesInParallel2()
             string[][] targetNamesPerProject = new string[fileNames.Length][];
             IDictionary[] targetOutPutsPerProject = new IDictionary[fileNames.Length];
             BuildPropertyGroup[] globalPropertiesPerProject = new BuildPropertyGroup[fileNames.Length];
-            
+
             string[] tempfilesToDelete = new string[fileNames.Length];
             string[] tempfilesToDelete2 = new string[fileNames.Length];
             string[] tempfilesToDelete3 = new string[fileNames.Length];
@@ -584,7 +584,7 @@ public void BuildProjectFilesInParallel2()
                     fileNames2[i] = ProjectFiles2[0];
                     fileNamesLeafs[i] = FileNamesLeafs[0];
                     childTraversals[i] = ChildTraversals[0];
-                    
+
                     tempfilesToDelete[i] = ProjectFiles1[1];
                     tempfilesToDelete2[i] = ProjectFiles2[1];
                     tempfilesToDelete3[i] = FileNamesLeafs[1];
@@ -594,7 +594,7 @@ public void BuildProjectFilesInParallel2()
 
 
                 // Try building a traversal project that had other traversals
-                
+
                 engine.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Normal));
                 engine.BuildProjectFile(parentTraversal, new string[] { "Build" }, new BuildPropertyGroup(), null, BuildSettings.None, "3.5");
                 engine.Shutdown();
@@ -742,11 +742,11 @@ private string[] CreateSingleProjectTraversalFileWithExtension(string projectNam
                 fileStream.Write(projectFileContents);
             }
             return new string[] { projectFile, tempFile };
-        } 
+        }
 
         private string TraversalProjectFile(string extensionForChildProjects)
         {
-            
+
             string projectFileContents = @"
                 <Project ToolsVersion=""3.5"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
                     <ItemGroup>";
@@ -832,7 +832,7 @@ public void BuildProjectWithPoorlyFormattedGlobalProperty()
                          </Prj>
                        </ItemGroup>
                     <Target Name=`1`>
-                        <MSBuild Projects=`@(Prj)` />            
+                        <MSBuild Projects=`@(Prj)` />
                     </Target>
                  </Project>
                  ", childProject);
@@ -953,7 +953,7 @@ public void ProjectShouldUseDefaultToolsVersionIfOneIsNotSpecified()
             }
         }
 
-        
+
         /// <summary>
         /// Project built using MSBuild task should use the default tools version if one is not specified.
         /// </summary>
@@ -1083,7 +1083,7 @@ public void ProjectBuiltUsingMSBuildTaskAndToolsVersionShouldUseTheOneSpecifiedI
                 MockLogger logger = new MockLogger();
                 Engine e = new Engine();
                 e.RegisterLogger(logger);
-        
+
                 string p1Path = ObjectModelHelpers.CreateFileInTempProjectDirectory("p1.proj", projectContent);
                 string p2Path = ObjectModelHelpers.CreateFileInTempProjectDirectory("p2.proj", projectContent2);
 
diff --git a/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs b/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
index e724f3d0969..1bc062ea883 100644
--- a/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
@@ -148,7 +148,7 @@ public void AddNewItemWithSemicolon()
 
         /// <summary>
         /// If I try to add a new item to a project, and my new item's Include has a property that
-        /// contains an unescaped semicolon in it, then we shouldn't try to match it up against any existing 
+        /// contains an unescaped semicolon in it, then we shouldn't try to match it up against any existing
         /// wildcards.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -203,17 +203,17 @@ public void ModifyItemIncludeSemicolon()
         {
             // Populate the project directory with three physical files on disk -- a.weirdo, b.weirdo, c.weirdo.
             ModifyItem.CreateThreeWeirdoFilesHelper();
-            
+
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -221,7 +221,7 @@ public void ModifyItemIncludeSemicolon()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -229,7 +229,7 @@ public void ModifyItemIncludeSemicolon()
                         <MyWildcard Include=`foo;bar.weirdo` />
                         <MyWildcard Include=`c.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -250,17 +250,17 @@ public void ModifyItemIncludeEscapedSemicolon()
         {
             // Populate the project directory with three physical files on disk -- a.weirdo, b.weirdo, c.weirdo.
             ModifyItem.CreateThreeWeirdoFilesHelper();
-            
+
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -268,13 +268,13 @@ public void ModifyItemIncludeEscapedSemicolon()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -287,7 +287,7 @@ public void ModifyItemIncludeEscapedSemicolon()
 
         /// <summary>
         /// If I try to modify an item in a project, and my new item's Include has a property that
-        /// contains an unescaped semicolon in it, then we shouldn't try to match it up against any existing 
+        /// contains an unescaped semicolon in it, then we shouldn't try to match it up against any existing
         /// wildcards.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -296,11 +296,11 @@ public void ModifyItemAddPropertyContainingSemicolon()
         {
             // Populate the project directory with three physical files on disk -- a.weirdo, b.weirdo, c.weirdo.
             ModifyItem.CreateThreeWeirdoFilesHelper();
-            
+
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -310,7 +310,7 @@ public void ModifyItemAddPropertyContainingSemicolon()
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -318,7 +318,7 @@ public void ModifyItemAddPropertyContainingSemicolon()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -330,7 +330,7 @@ public void ModifyItemAddPropertyContainingSemicolon()
                         <MyWildcard Include=`$(FileNameWithSemicolon).weirdo` />
                         <MyWildcard Include=`c.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -547,7 +547,7 @@ public void SemicolonInConfiguration()
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
             ");
-            
+
             // ---------------------
             // Class1.cs
             // ---------------------
@@ -607,7 +607,7 @@ public void SemicolonInAssemblyName()
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
             ");
-            
+
             // ---------------------
             // Class1.cs
             // ---------------------
@@ -665,7 +665,7 @@ public void DollarSignInAssemblyName()
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
             ");
-            
+
             // ---------------------
             // Class1.cs
             // ---------------------
@@ -723,7 +723,7 @@ public void SemicolonInSourceCodeFilename()
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
             ");
-            
+
             // ---------------------
             // Class1.cs
             // ---------------------
@@ -924,7 +924,7 @@ static void Main(string[] args)
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
 
                     <!-- The old OM, which is what this solution is being built under, doesn't understand
-                         BeforeTargets, so this test was failing, because _AssignManagedMetadata was set 
+                         BeforeTargets, so this test was failing, because _AssignManagedMetadata was set
                          up as a BeforeTarget for Build.  Copied here so that build will return the correct
                          information again. -->
                     <Target Name=`BeforeBuild`>
@@ -957,7 +957,7 @@ public class Class1
             MockLogger log = ObjectModelHelpers.BuildTempProjectFileWithTargetsExpectSuccess(@"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1.sln", new string[] { targetForFirstProject }, new BuildPropertyGroup());
 
             Assertion.Assert(@"Did not find expected file Console;!@(foo)'^(Application1.exe",
-                File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir, 
+                File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir,
                 @"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1\bin\debug\Console;!@(foo)'^(Application1.exe")));
         }
     }
diff --git a/src/Deprecated/Engine.UnitTests/EventArgsFormatting_Tests.cs b/src/Deprecated/Engine.UnitTests/EventArgsFormatting_Tests.cs
index 4ec1aaea85f..b16138705af 100644
--- a/src/Deprecated/Engine.UnitTests/EventArgsFormatting_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/EventArgsFormatting_Tests.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.UnitTests
     /// <summary>
     /// These tests are repeated in the Utilities unit test assembly. We know that this isn't
     /// too useful, because both Engine and Utilities pull the code from the same Shared file. But it
-    /// gets a bunch of lines of extra coverage of Engine that we weren't otherwise getting, and 
+    /// gets a bunch of lines of extra coverage of Engine that we weren't otherwise getting, and
     /// in theory at least the implementation in Engine should be tested too.
     /// </summary>
     [TestFixture]
diff --git a/src/Deprecated/Engine.UnitTests/Expander_Tests.cs b/src/Deprecated/Engine.UnitTests/Expander_Tests.cs
index 9286aad3558..aff4a25012c 100644
--- a/src/Deprecated/Engine.UnitTests/Expander_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Expander_Tests.cs
@@ -140,9 +140,9 @@ public void ZeroItemsInProjectExpandsToEmpty()
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
 
                     <Target Name=`Build` Condition=`'@(foo)'!=''` >
-                        <Message Text=`This target should NOT run.`/>  
+                        <Message Text=`This target should NOT run.`/>
                     </Target>
-                  
+
                 </Project>
                 ");
 
@@ -158,7 +158,7 @@ public void ZeroItemsInProjectExpandsToEmpty()
                     <Target Name=`Build`>
                         <Message Text=`Item list foo contains @(foo)`/>
                     </Target>
-                  
+
                 </Project>
                 ");
 
@@ -266,11 +266,11 @@ public void ExpandAllIntoTaskItemsComplex()
 
             List<TaskItem> taskItems = expander.ExpandAllIntoTaskItems(
                 "@(Resource->'%(Filename)') ; @(Content) ; @(NonExistent) ; $(NonExistent) ; %(NonExistent) ; " +
-                "$(OutputPath) ; $(TargetPath) ; %(Language)_%(Culture)", 
+                "$(OutputPath) ; $(TargetPath) ; %(Language)_%(Culture)",
                  (new XmlDocument()).CreateAttribute("dummy"));
 
-            // the following items are passed to the TaskItem constructor, and thus their ItemSpecs should be 
-            // in escaped form. 
+            // the following items are passed to the TaskItem constructor, and thus their ItemSpecs should be
+            // in escaped form.
             ObjectModelHelpers.AssertItemsMatch(@"
                 string$(p): ddd=444
                 dialogs%253b: eee=555
@@ -337,7 +337,7 @@ public void ExpandAllIntoStringLeaveEscapedComplex()
         }
 
         /// <summary>
-        /// Exercises ExpandAllIntoString with a string that does not need expanding. 
+        /// Exercises ExpandAllIntoString with a string that does not need expanding.
         /// In this case the expanded string should be reference identical to the passed in string.
         /// </summary>
         [Test]
@@ -354,14 +354,14 @@ public void ExpandAllIntoStringExpectIdenticalReference()
             // Create a *non-literal* string. If we used a literal string, the CLR might (would) intern
             // it, which would mean that Expander would inevitably return a reference to the same string.
             // In real builds, the strings will never be literals, and we want to test the behavior in
-            // that situation. 
+            // that situation.
             xmlattribute.Value = "abc123" + new Random().Next();
             string expandedString = expander.ExpandAllIntoStringLeaveEscaped(xmlattribute.Value, xmlattribute);
 
             // Verify neither string got interned, so that this test is meaningful
             Assertion.Assert(null == string.IsInterned(xmlattribute.Value));
             Assertion.Assert(null == string.IsInterned(expandedString));
-            
+
             // Finally verify Expander indeed didn't create a new string.
             Assertion.Assert(Object.ReferenceEquals(xmlattribute.Value, expandedString));
         }
@@ -774,7 +774,7 @@ private XmlAttribute DummyAttribute
                 return dummyAttribute;
             }
         }
-        
+
         private bool EvaluateCondition(string conditionExpression, Expander expander)
         {
             Parser p = new Parser();
@@ -997,7 +997,7 @@ public void PropertyFunctionConstructor2()
         }
 
         /// <summary>
-        /// Expand property function calls a static method 
+        /// Expand property function calls a static method
         /// </summary>
         [Test]
         public void PropertyFunctionStaticMethodMakeRelative()
@@ -1071,7 +1071,7 @@ public void PropertyFunctionGetRegistryValueFromView_NonexistentKey()
         }
 
         /// <summary>
-        /// Expand property function calls a static method 
+        /// Expand property function calls a static method
         /// </summary>
         [Test]
         public void PropertyFunctionStaticMethod1()
@@ -1088,7 +1088,7 @@ public void PropertyFunctionStaticMethod1()
         }
 
         /// <summary>
-        /// Expand property function calls a static method 
+        /// Expand property function calls a static method
         /// </summary>
         [Test]
         public void PropertyFunctionStaticMethodQuoted1()
@@ -1147,9 +1147,9 @@ public void PropertyFunctionStaticMethodQuoted4()
 
             Assertion.AssertEquals(DateTime.Now.ToString("MM.dd.yyyy"), result);
         }
-        
+
         /// <summary>
-        /// Expand property function calls a static method 
+        /// Expand property function calls a static method
         /// </summary>
         [Test]
         public void PropertyFunctionStaticMethodNested()
@@ -1739,9 +1739,9 @@ public void RegistryPropertyMultiString()
             {
                 Registry.CurrentUser.DeleteSubKey(@"Software\Microsoft\MSBuild_test");
             }
-        }    
+        }
     }
- 
+
     /// <summary>
     /// Tests relating to SplitSemiColonSeparatedList method
     /// </summary>
diff --git a/src/Deprecated/Engine.UnitTests/ExpressionShredder_Tests.cs b/src/Deprecated/Engine.UnitTests/ExpressionShredder_Tests.cs
index ad182c69884..3d157e3478a 100644
--- a/src/Deprecated/Engine.UnitTests/ExpressionShredder_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ExpressionShredder_Tests.cs
@@ -31,20 +31,20 @@ public void Medley()
         {
             string[] tests = new string[]
             {
-                "a;@(foo,');');b", 
+                "a;@(foo,');');b",
                 "x@(z);@(zz)y",
                 "exists('@(u)')",
-                "a;b", 
+                "a;b",
                 "a;;",
-                "a", 
+                "a",
                 "@A->'%(x)'",
                 "@@(",
                 "@@",
                 "@(z1234567890_-AZaz->'z1234567890_-AZaz','a1234567890_-AZaz')",
-                "@(z1234567890_-AZaz,'a1234567890_-AZaz')", 
-                "@(z1234567890_-AZaz)", 
-                "@(z1234567890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'   )", 
-                "@(z123456.7890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'  )", 
+                "@(z1234567890_-AZaz,'a1234567890_-AZaz')",
+                "@(z1234567890_-AZaz)",
+                "@(z1234567890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'   )",
+                "@(z123456.7890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'  )",
                 "@(z->'%(x)",
                 "@(z->%(x)",
                 "@(z,'%(x)",
@@ -56,69 +56,69 @@ public void Medley()
                 "@(y)==$(d)",
                 "@(y)<=1",
                 "@(y -> '%(filename)')=='xxx'",
-                "@(x\u00DF)",   
-                "@(x1234567890_-AZaz->'x1234567890_-AZaz')", 
-                "@(x1234567890_-AZaz)", 
-                "@(x123 4567890_-AZaz->'x1234567890_-AZaz')", 
-                "@(x->)", 
+                "@(x\u00DF)",
+                "@(x1234567890_-AZaz->'x1234567890_-AZaz')",
+                "@(x1234567890_-AZaz)",
+                "@(x123 4567890_-AZaz->'x1234567890_-AZaz')",
+                "@(x->)",
                 "@(x->)",
                 "@(x->'x','')",
                 "@(x->'x',''",
                 "@(x->'x','",
-                "@(x->')", 
-                "@(x->''", 
+                "@(x->')",
+                "@(x->''",
                 "@(x->''",
                 "@(x->'",
-                "@(x->", 
+                "@(x->",
                 "@(x-",
-                "@(x,')", 
+                "@(x,')",
                 "@(x)@(x)",
                 "@(x)<x",
                 "@(x);@(x)",
                 "@(x)",
-                "@(x''';", 
-                "@(x", 
+                "@(x''';",
+                "@(x",
                 "@(x!)",
                 "@(w)>0",
                 "@(nonexistent)",
                 "@(nonexistent) and true",
                 "@(foo->'x')",
-                "@(foo->'abc;def', 'ghi;jkl')", 
-                "@(foo->';());', ';@();')", 
-                "@(foo->';');def;@ghi;", 
-                "@(foo->';')", 
+                "@(foo->'abc;def', 'ghi;jkl')",
+                "@(foo->';());', ';@();')",
+                "@(foo->';');def;@ghi;",
+                "@(foo->';')",
                 "@(foo-->'x')", // "foo-" is a legit item type
-                "@(foo, ';')", 
-                "@(a1234:567890_-AZaz->'z1234567890_-AZaz')", 
-                "@(a1234567890_-AZaz->'z1234567890_-AZaz')", 
-                "@(a1234567890_-AXZaxz  -> 'a1234567890_-AXZaxz'   ,  'z1234567890_-AXZaxz'   )", 
-                "@(a1234567890_-AXZaxz  , 'z123%%4567890_-AXZaxz'   )", 
-                "@(a->'a')", 
-                "@(a->'a'  ,  'a')", 
+                "@(foo, ';')",
+                "@(a1234:567890_-AZaz->'z1234567890_-AZaz')",
+                "@(a1234567890_-AZaz->'z1234567890_-AZaz')",
+                "@(a1234567890_-AXZaxz  -> 'a1234567890_-AXZaxz'   ,  'z1234567890_-AXZaxz'   )",
+                "@(a1234567890_-AXZaxz  , 'z123%%4567890_-AXZaxz'   )",
+                "@(a->'a')",
+                "@(a->'a'  ,  'a')",
                 "@(a)@(x)!=1",
-                "@(a)", 
+                "@(a)",
                 "@(a) @(x)!=1",
-                "@(a  ,  'a')", 
-                "@(_X->'_X','X')", 
-                "@(_X->'_X')", 
-                "@(_X,'X')", 
-                "@(_X)", 
+                "@(a  ,  'a')",
+                "@(_X->'_X','X')",
+                "@(_X->'_X')",
+                "@(_X,'X')",
+                "@(_X)",
                 "@(_->'@#$%$%^&*&*)','@#$%$%^&*&*)')",
                 "@(_->'@#$%$%^&*&*)')",
                 "@(_,'@#$%$%^&*&*)')",
                 "@(_)",
                 "@(\u1234%(x)",
                 "@(\u00DF)",
-                "@(Z1234567890_-AZaz)", 
-                "@(Z1234567890_-AZaz -> 'Z1234567890_-AZaz')", 
+                "@(Z1234567890_-AZaz)",
+                "@(Z1234567890_-AZaz -> 'Z1234567890_-AZaz')",
                 "@(Com:pile)",
                 "@(Com.pile)",
                 "@(Com%pile)",
                 "@(Com pile)",
-                "@(A1234567890_-AZaz,'!@#$%^&*)(_+'))", 
-                "@(A1234567890_-AZaz)", 
-                "@(A1234567890_-AZaz ->'A1234567890_-AZaz')", 
-                "@(A1234567890_-AZaz ->'A1234567890_-AZaz' , '!@#$%^&*)(_+'))", 
+                "@(A1234567890_-AZaz,'!@#$%^&*)(_+'))",
+                "@(A1234567890_-AZaz)",
+                "@(A1234567890_-AZaz ->'A1234567890_-AZaz')",
+                "@(A1234567890_-AZaz ->'A1234567890_-AZaz' , '!@#$%^&*)(_+'))",
                 "@(A->'foo%(x)bar',',')",
                 "@(A->'%(x))",
                 "@(A->'%(x)')@(B->'%(x);%(y)')@(C->'%(z)')",
@@ -129,14 +129,14 @@ public void Medley()
                 "@(A, '%(x)->%(y)')",
                 "@(A, '%(x)%(y)')",
                 "@(A > '%(x)','+')",
-                "@(:Z1234567890_-AZaz -> 'Z1234567890_-AZaz')", 
+                "@(:Z1234567890_-AZaz -> 'Z1234567890_-AZaz')",
                 "@(:Compile)",
                 "@(1x->'@#$%$%^&*&*)')",
                 "@(1Compile)",
-                "@(1->'a')", 
+                "@(1->'a')",
                 "@(.Compile)",
-                "@(.A1234567890_-AZaz ->'A1234567890_-AZaz')", 
-                "@(-x->'_X')", 
+                "@(.A1234567890_-AZaz ->'A1234567890_-AZaz')",
+                "@(-x->'_X')",
                 "@(-Compile)",
                 "@()",
                 "@() and true",
@@ -144,29 +144,29 @@ public void Medley()
                 "@(%(x)",
                 "@(", "@()", "@",
                 "@(",
-                "@( foo -> ';);' , ';);' )", 
-                "@( foo -> ');' )", 
+                "@( foo -> ';);' , ';);' )",
+                "@( foo -> ');' )",
                 "@( A -> '%(Directory)%(Filename)%(Extension)', ' ** ')",
                 "@( )",
-                "@(   foo  )", 
-                "@(   foo  ", 
-                "@(   a1234567890_-AXZaxz   )", 
+                "@(   foo  )",
+                "@(   foo  ",
+                "@(   a1234567890_-AXZaxz   )",
                 "@",
                 "@ (x)",
                 "@(x,'@(y)%(x)@(z->')",
                 "@(x,'@(y)')",   // verify items inside separators aren't found
-                "@(x,'@(y, '%(z)')')",   
-                "@(x,'@(y)%(z)')", 
+                "@(x,'@(y, '%(z)')')",
+                "@(x,'@(y)%(z)')",
                 "@(x,'@(y)%(x')",
                 "@(x,'')",
                 "@(x->'','')",
                 "@(x->'%(z)','')",
-                ";a;bbb;;c;;", 
-                ";;a", 
+                ";a;bbb;;c;;",
+                ";;a",
                 ";;;@(A->'%(x)');@(B)@(C->'%(y)');%(x)@(D->'%(y)');;",
-                ";;", 
-                ";", 
-                ";  ", 
+                ";;",
+                ";",
+                ";  ",
                 "1<=@(z)",
                 "1<=@(w)",
                 "'xxx!yyy'==@(z -> '%(filename)', '!')",
@@ -175,10 +175,10 @@ public void Medley()
                 "'$(c)@(y)'>1",
                 "%x)",
                 "%x",
-                "%(z1234567890_-AZaz.z1234567890_-AZaz)", 
-                "%(z1234567890_-AZaz)", 
-                "%(x1234567890_-AZaz.x1234567890_-AZaz)", 
-                "%(x1234567890_-AZaz)", 
+                "%(z1234567890_-AZaz.z1234567890_-AZaz)",
+                "%(z1234567890_-AZaz)",
+                "%(x1234567890_-AZaz.x1234567890_-AZaz)",
+                "%(x1234567890_-AZaz)",
                 "%(x._)",
                 "%(x)",
                 "%(x",
@@ -186,21 +186,21 @@ public void Medley()
                 "%(foo.bar.baz)",
                 "%(foo.bar baz)",
                 "%(foo bar.rhu barb)",
-                "%(abc._X)", 
+                "%(abc._X)",
                 "%(a@(z)",
-                "%(a1234567890_-AXZaxz)", 
-                "%(a12.a)", 
+                "%(a1234567890_-AXZaxz)",
+                "%(a12.a)",
                 "%(a.x)",
                 "%(a.x )",
                 "%(a.a@(z)",
                 "%(a.@(z)",
                 "%(a. x)",
-                "%(a)", 
+                "%(a)",
                 "%(a . x)",
-                "%(_X)", 
+                "%(_X)",
                 "%(_)",
-                "%(Z1234567890_-AZaz.Z1234567890_-AZaz)", 
-                "%(Z1234567890_-AZaz)", 
+                "%(Z1234567890_-AZaz.Z1234567890_-AZaz)",
+                "%(Z1234567890_-AZaz)",
                 "%(MyType.attr)",
                 "%(InvalidAttrWithA Space)",
                 "%(Foo.Bar.)",
@@ -212,8 +212,8 @@ public void Medley()
                 "%(Com%pile)",
                 "%(Com pile.Com pile)",
                 "%(Com pile)",
-                "%(A1234567890_-AZaz.A1234567890_-AZaz)", 
-                "%(A1234567890_-AZaz)", 
+                "%(A1234567890_-AZaz.A1234567890_-AZaz)",
+                "%(A1234567890_-AZaz)",
                 "%(A.x)%(b.x)",
                 "%(A.x)",
                 "%(A.x)  %( x )",
@@ -254,18 +254,18 @@ public void Medley()
                 "%(  Invalid AttrWithASpace  )",
                 "%(  A  .  )",
                 "%(   x   )",
-                "%(   a1234567890_-AXZaxz.a1234567890_-AXZaxz   )", 
+                "%(   a1234567890_-AXZaxz.a1234567890_-AXZaxz   )",
                 "% x",
                 "% (x)",
                 "$(c)@(y)>1",
-                "", 
+                "",
                 "",
                 "!@#$%^&*",
-                " @(foo->'', '')", 
-                " ->       ';abc;def;'   ,     'ghi;jkl'   )", 
+                " @(foo->'', '')",
+                " ->       ';abc;def;'   ,     'ghi;jkl'   )",
                 " %(A . x)%%%%%%%%(b . x) ",
-                "  ;  a   ;b   ;   ;c", 
-                "                $(AssemblyOriginatorKeyFile);\n\t                @(Compile);", 
+                "  ;  a   ;b   ;   ;c",
+                "                $(AssemblyOriginatorKeyFile);\n\t                @(Compile);",
                                 "@(_OutputPathItem->'%(FullPath)', ';');$(MSBuildAllProjects);"
             };
 
@@ -366,7 +366,7 @@ private static Hashtable GetConsumedItemReferences_OriginalImplementation(string
         /// <summary>
         /// Looks through the parameters of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Returns a Hashtable containing a bunch of MetadataReference
-        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <owner>SumedhK, RGoel</owner>
@@ -374,7 +374,7 @@ private static Hashtable GetConsumedItemReferences_OriginalImplementation(string
         private static Hashtable GetConsumedMetadataReferences_OriginalImplementation(string expression)
         {
             // The keys in the hash table are the qualified metadata names (e.g. "EmbeddedResource.Culture"
-            // or just "Culture").  The values are MetadataReference structs, which simply split out the item 
+            // or just "Culture").  The values are MetadataReference structs, which simply split out the item
             // name (possibly null) and the actual metadata name.
             Hashtable consumedMetadataReferences = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
@@ -386,7 +386,7 @@ private static Hashtable GetConsumedMetadataReferences_OriginalImplementation(st
         /// <summary>
         /// Looks through a single parameter of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Populates a Hashtable containing a bunch of MetadataReference
-        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <param name="batchableObjectParameter"></param>
@@ -476,7 +476,7 @@ Hashtable consumedMetadataReferences
         /// <summary>
         /// Looks through a single parameter of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Populates a MatchCollection object with any regex matches
-        /// found in the input.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// found in the input.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <param name="batchableObjectParameter"></param>
diff --git a/src/Deprecated/Engine.UnitTests/ExpressionTree_Tests.cs b/src/Deprecated/Engine.UnitTests/ExpressionTree_Tests.cs
index a1fc5b6ac9b..19c3ee674e3 100644
--- a/src/Deprecated/Engine.UnitTests/ExpressionTree_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ExpressionTree_Tests.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.UnitTests
     [TestFixture]
     public class ExpressionTreeTest
     {
-        private XmlAttribute dummyAttribute; 
+        private XmlAttribute dummyAttribute;
         private XmlAttribute DummyAttribute
         {
             get
@@ -112,7 +112,7 @@ public void EvaluatedAVarietyOfExpressionsWithProjectPerThreadProjectDirectoryNo
         }
 
         /// <summary>
-        /// A whole bunch of conditionals, that should be true, false, or error 
+        /// A whole bunch of conditionals, that should be true, false, or error
         /// (many coincidentally like existing QA tests) to give breadth coverage.
         /// Please add more cases as they arise.
         /// </summary>
@@ -216,7 +216,7 @@ private void EvaluateAVarietyOfExpressions()
                     "0==0.0",
                     "1\n\t==1",
                     "+4==4",
-                    "44==+44.0 and -44==-44.0",                    
+                    "44==+44.0 and -44==-44.0",
                     "false==no",
                     "true==yes",
                     "true==!false",
@@ -285,7 +285,7 @@ private void EvaluateAVarietyOfExpressions()
                     "exists('%3b')",
                     "exists('%27')",
                     "exists('@(v);@(nonexistent)')",
-                    @"HASTRAILINGSLASH('foo\')", 
+                    @"HASTRAILINGSLASH('foo\')",
                     @"!HasTrailingSlash('foo')",
                     @"HasTrailingSlash('foo/')",
                     @"HasTrailingSlash($(has_trailing_slash))",
diff --git a/src/Deprecated/Engine.UnitTests/FileLogger_Tests.cs b/src/Deprecated/Engine.UnitTests/FileLogger_Tests.cs
index 5605b1e2310..c688bd3e4b8 100644
--- a/src/Deprecated/Engine.UnitTests/FileLogger_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/FileLogger_Tests.cs
@@ -31,7 +31,7 @@ public void Basic()
             FileLogger fileLogger = new FileLogger();
             string logFile = Path.GetTempFileName();
             fileLogger.Parameters = "verbosity=Normal;logfile=" + logFile;
-            
+
             Project project = ObjectModelHelpers.CreateInMemoryProject(@"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                     <Target Name=`Build`>
@@ -74,7 +74,7 @@ public void BasicNoExistingFile()
                 if (null != log) File.Delete(log);
             }
         }
-        
+
         /// <summary>
         /// Invalid file should error nicely
         /// </summary>
@@ -92,7 +92,7 @@ public void InvalidFile()
             {
                 if (null != log) File.Delete(log);
             }
-        }        
+        }
 
         /// <summary>
         /// Specific verbosity overrides global verbosity
diff --git a/src/Deprecated/Engine.UnitTests/GroupingCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/GroupingCollection_Tests.cs
index 7d069a7ae05..b5b967ff15b 100644
--- a/src/Deprecated/Engine.UnitTests/GroupingCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/GroupingCollection_Tests.cs
@@ -202,7 +202,7 @@ public void RemoveTest()
         }
 
         /// <summary>
-        /// Make sure linked property group and item group counting works correctly. 
+        /// Make sure linked property group and item group counting works correctly.
         /// Parent grouping collections depend on child grouping collections to update the count for nested groups.
         /// </summary>
         /// <owner>LukaszG</owner>
@@ -243,13 +243,13 @@ public void LinkedCount()
             nestedGroup.Clear();
             nestedGroup.InsertAtEnd(this.ig2);
             nestedGroup.InsertAfter(this.ig3, this.ig2);
-            
+
             childGroup1.RemovePropertyGroup(this.pg1);
             childGroup1.RemoveItemGroup(this.ig1);
             childGroup1.InsertAtEnd(this.ig3);
 
             childGroup2.RemovePropertyGroup(this.pg1);
-            
+
             masterGroup.RemoveItemGroup(this.ig2);
 
             Assertion.AssertEquals(nestedGroup.ItemGroupCount, 2);
diff --git a/src/Deprecated/Engine.UnitTests/HashTableUtility_Tests.cs b/src/Deprecated/Engine.UnitTests/HashTableUtility_Tests.cs
index 2a7d3f3edab..94da0bd2342 100644
--- a/src/Deprecated/Engine.UnitTests/HashTableUtility_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/HashTableUtility_Tests.cs
@@ -23,10 +23,10 @@ public class HashTableUtilityTests
         /// <summary>
         /// Missing unittest found by mutation testing.
         /// REASON TEST WASN'T ORIGINALLY PRESENT: HashTableUtility was not a separate class and
-        /// there was no way to hit this case through BatchingEngine directly because it never 
+        /// there was no way to hit this case through BatchingEngine directly because it never
         /// calls Compare() with unequal numbers of items.
-        /// 
-        /// This test ensures that hashtable     with unequal numbers of items are considered not 
+        ///
+        /// This test ensures that hashtable     with unequal numbers of items are considered not
         /// equivalent.
         /// </summary>
         [Test]
diff --git a/src/Deprecated/Engine.UnitTests/ImportCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/ImportCollection_Tests.cs
index f44a4169435..040c59c4a85 100644
--- a/src/Deprecated/Engine.UnitTests/ImportCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ImportCollection_Tests.cs
@@ -113,19 +113,19 @@ public void RemoveExistingImport()
                 ");
 
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory("main.proj", null);
-            
+
             ImportCollection imports = project.Imports;
             Assertion.AssertEquals(2, imports.Count);
-            
+
             imports.RemoveImport(imports[Path.Combine(ObjectModelHelpers.TempProjectDir, "import1.proj")]);
-            
+
             // First validate that the ImportCollection only contains a single Import
             Assertion.AssertEquals(1, imports.Count);
 
-            // Now validate that the ImportCollection properly updated its parent Project (by inspecting the 
+            // Now validate that the ImportCollection properly updated its parent Project (by inspecting the
             // project's in-memory Xml)
             int importCount = 0;
-            
+
             foreach (XmlNode childNode in project.ProjectElement)
             {
                 if (childNode.Name == XMakeElements.import)
@@ -177,7 +177,7 @@ public void AttemptToRemoveImportedImportShouldThrowException()
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory("main.proj", null);
 
             ImportCollection imports = project.Imports;
-            
+
             // Should throw an InvalidOperationException
             imports.RemoveImport(imports[Path.Combine(ObjectModelHelpers.TempProjectDir, "import3.proj")]);
         }
@@ -198,7 +198,7 @@ public void AttemptToRemoveImportFromAnotherProjectShouldThrowException()
                     <Project xmlns=`msbuildnamespace`>
 
                         <Import Project=`import1.proj` />
-            
+
                         <Target Name=`Build`>
                             <WashCar/>
                         </Target>
@@ -212,7 +212,7 @@ public void AttemptToRemoveImportFromAnotherProjectShouldThrowException()
                     <Project xmlns=`msbuildnamespace`>
 
                         <Import Project=`import1.proj` />
-            
+
                         <Target Name=`Build`>
                             <WashCar/>
                         </Target>
diff --git a/src/Deprecated/Engine.UnitTests/IntrinsicTask_Tests.cs b/src/Deprecated/Engine.UnitTests/IntrinsicTask_Tests.cs
index 35f4de5709f..8d79bf8724e 100644
--- a/src/Deprecated/Engine.UnitTests/IntrinsicTask_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/IntrinsicTask_Tests.cs
@@ -29,7 +29,7 @@ public void PropertyGroup()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -151,7 +151,7 @@ public void PropertyGroupWithConditionOnGroup()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup Condition='false'> 
+                <PropertyGroup Condition='false'>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -164,7 +164,7 @@ public void PropertyGroupWithConditionOnGroup()
 
             content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup Condition='true'> 
+                <PropertyGroup Condition='true'>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -195,7 +195,7 @@ public void PropertyGroupWithConditionOnGroupUsingMetadataErrors()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup Condition=""'%(i0.m)'=='m2'""> 
+                <PropertyGroup Condition=""'%(i0.m)'=='m2'"">
                     <p1>@(i0)</p1>
                     <p2>%(i0.m)</p2>
                 </PropertyGroup>
@@ -211,7 +211,7 @@ public void ItemGroup()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -256,7 +256,7 @@ public void ItemGroupTrims()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='  $(p0)  '/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -316,7 +316,7 @@ public void ItemGroupWithTransform()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a.cpp'/>
                     <i2 Include=""@(i1->'%(filename).obj')""/>
                 </ItemGroup>
@@ -336,7 +336,7 @@ public void ItemGroupWithTransformInMetadataValue()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a.cpp'/>
                     <i2 Include='@(i1)'>
                        <m>@(i1->'%(filename).obj')</m>
@@ -357,7 +357,7 @@ public void ItemGroupWithExclude()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i2 Include='a1;@(i1);b1;b2' Exclude='@(i1);b1'/>
                 </ItemGroup>
@@ -377,7 +377,7 @@ public void ItemGroupWithMetadataInExclude()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>a1</m>
                     </i1>
@@ -401,7 +401,7 @@ public void ItemGroupWithConditionOnGroup()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup Condition='false'> 
+                <ItemGroup Condition='false'>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -415,7 +415,7 @@ public void ItemGroupWithConditionOnGroup()
 
             content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup Condition='true'> 
+                <ItemGroup Condition='true'>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -447,7 +447,7 @@ public void ItemGroupWithConditionOnGroupUsingMetadataErrors()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup Condition=""'%(i0.m)'!='m1'""> 
+                <ItemGroup Condition=""'%(i0.m)'!='m1'"">
                     <i1 Include='a1'/>
                     <i2 Include='%(i0.m)'/>
                     <i3 Include='%(i0.identity)'/>
@@ -467,7 +467,7 @@ public void PropertyGroupWithExternalPropertyReferences()
             // </PropertyGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>$(p0)</p1>
                 </PropertyGroup>
             </Target>";
@@ -488,7 +488,7 @@ public void ItemGroupWithPropertyReferences()
             // </PropertyGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='$(p0)'/>
                     <i2 Include='a2'/>
                 </ItemGroup>
@@ -509,7 +509,7 @@ public void ItemGroupWithMetadataReferences()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>m1</m>
                     </i1>
@@ -540,7 +540,7 @@ public void ItemGroupWithMetadataReferencesOnMetadataConditions()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>m1</m>
                     </i1>
@@ -609,7 +609,7 @@ public void ItemGroupWithExternalMetadataReferences()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='b1'>
                         <m>%(i0.m)</m>
                     </i1>
@@ -641,7 +641,7 @@ public void PropertyGroupWithCumulativePropertyReferences()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>v1</p1>
                     <p2>#$(p1)#</p2>
                     <p1>v2</p1>
@@ -677,7 +677,7 @@ public void PropertyGroupWithMetadataReferencesOnGroupErrors()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup Condition=""'%(i0.m)' != m1""> 
+                <PropertyGroup Condition=""'%(i0.m)' != m1"">
                     <p1>%(i0.m)</p1>
                 </PropertyGroup>
             </Target>";
@@ -706,7 +706,7 @@ public void PropertyGroupWithMetadataReferencesOnProperty()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1 Condition=""'%(i0.n)' != n3"">%(i0.n)</p1>
                 </PropertyGroup>
             </Target>";
@@ -750,7 +750,7 @@ public void ItemsCanReferencePropertiesInSameTarget()
                     <PropertyGroup>
                         <p0>v0</p0>
                     </PropertyGroup>
-                    <ItemGroup> 
+                    <ItemGroup>
                         <i1 Include='$(p0)'/>
                     </ItemGroup>
                     <Message Text=`[@(i1)]`/>
@@ -857,7 +857,7 @@ public void PropertiesVisibleToSubsequentTarget()
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`[$(p)]`/>                    
+                    <Message Text=`[$(p)]`/>
                   </Target>
                   <Target Name=`t`>
                     <PropertyGroup>
@@ -897,7 +897,7 @@ public void ItemsVisibleToSubsequentTarget()
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`[@(i)]`/>                    
+                    <Message Text=`[@(i)]`/>
                   </Target>
                   <Target Name=`t`>
                     <ItemGroup>
@@ -920,13 +920,13 @@ public void ItemsNotVisibleToParallelTargetBatches()
                   <ItemGroup>
                     <i Include=`1.in`><output>1.out</output></i>
                     <i Include=`2.in`><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.output)`>
                     <Message Text=`start:[@(i)]`/>
                     <ItemGroup>
                       <j Include=`%(i.identity)`/>
                     </ItemGroup>
-                    <Message Text=`end:[@(j)]`/>                    
+                    <Message Text=`end:[@(j)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -975,16 +975,16 @@ public void ItemsInPartialBuild()
                   <ItemGroup>
                     <i Include=`" + oldFiles[0] + "`><output>" + newFiles[0] + @"</output></i>
                     <i Include=`" + newFiles[1] + "`><output>" + oldFiles[1] + @"</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`final:[@(j)]`/>                    
+                    <Message Text=`final:[@(j)]`/>
                   </Target>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.Output)`>
                     <Message Text=`start:[@(j)]`/>
                     <ItemGroup>
                       <j Include=`%(i.identity)`/>
                     </ItemGroup>
-                    <Message Text=`end:[@(j)]`/>                    
+                    <Message Text=`end:[@(j)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -1016,16 +1016,16 @@ public void PropertiesInPartialBuild()
                   <ItemGroup>
                     <i Include=`" + oldFiles[0] + "`><output>" + newFiles[0] + @"</output></i>
                     <i Include=`" + newFiles[1] + "`><output>" + oldFiles[1] + @"</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`final:[$(p)]`/>                    
+                    <Message Text=`final:[$(p)]`/>
                   </Target>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.Output)`>
                     <Message Text=`start:[$(p)]`/>
                     <PropertyGroup>
                       <p>@(i)</p>
                     </PropertyGroup>
-                    <Message Text=`end:[$(p)]`/>                    
+                    <Message Text=`end:[$(p)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -1062,20 +1062,20 @@ public void ItemsInPartialBuildVisibleToSubsequentlyInferringTasks()
                   <ItemGroup>
                     <i Include=`" + oldInput + "`><output>" + newOutput + @"</output></i>
                     <i Include=`" + newInput + "`><output>" + oldOutput + @"</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`final:[@(i)]`/>                    
+                    <Message Text=`final:[@(i)]`/>
                   </Target>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.Output)`>
                     <Message Text=`start:[@(i)]`/>
                     <ItemGroup>
                       <j Include=`%(i.identity)`/>
                     </ItemGroup>
-                    <Message Text=`middle:[@(i)][@(j)]`/> 
+                    <Message Text=`middle:[@(i)][@(j)]`/>
                     <CreateItem Include=`@(j)`>
                       <Output TaskParameter=`Include` ItemName=`i`/>
                     </CreateItem>
-                    <Message Text=`end:[@(i)]`/>                    
+                    <Message Text=`end:[@(i)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -1084,11 +1084,11 @@ public void ItemsInPartialBuildVisibleToSubsequentlyInferringTasks()
                 // We should only see messages for the out of date inputs, but the itemgroup should do its work for both inputs;
                 // The final result should include the out of date inputs (twice) and the up to date inputs (twice).
                 // NOTE: outputs from regular tasks, like CreateItem, are gathered up and included in the project in the order (1) inferred (2) executed.
-                // Intrinsic tasks, because they affect the project directly, don't do this. So the final order we see is 
+                // Intrinsic tasks, because they affect the project directly, don't do this. So the final order we see is
                 // two inputs (old, new) from the ItemGroup; followed by the inferred CreateItem output, then the executed CreateItem output.
                 // I suggest this ordering isn't important: it's a new feature, so nobody will get broken.
-                logger.AssertLogContains(new string[] { "start:[" + newInput + "]", 
-                                                        "middle:[" + newInput + "][" + newInput + "]", 
+                logger.AssertLogContains(new string[] { "start:[" + newInput + "]",
+                                                        "middle:[" + newInput + "][" + newInput + "]",
                                                         "end:["   + newInput + ";" + newInput + "]",
                                                         "final:[" + oldInput + ";" + newInput + ";" + oldInput + ";" + newInput + "]" });
             }
@@ -1105,7 +1105,7 @@ public void IncludeNoOp()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include=''/>
                 </ItemGroup>
             </Target>";
@@ -1118,7 +1118,7 @@ public void RemoveNoOp()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Remove='a1'/>
                 </ItemGroup>
             </Target>";
@@ -1135,7 +1135,7 @@ public void RemoveItemInTarget()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
+                    <i1 Include='a1'/>
                     <i1 Remove='a1'/>
                 </ItemGroup>
             </Target>";
@@ -1160,7 +1160,7 @@ public void RemoveOfItemAddedInTargetByParallelTargetBatchDoesNothing()
                     <!-- just to cause two target batches -->
                     <i Include=`1.in`><output>1.out</output></i>
                     <i Include=`2.in`><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.output)`>
                     <ItemGroup>
                       <j Include=`a` Condition=`'%(i.Identity)'=='1.in'`/>
@@ -1196,7 +1196,7 @@ public void RemoveItemInTargetWithTransform()
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
                     <i0 Include='a.cpp;b.cpp'/>
-                    <i1 Include='a.obj;b.obj'/> 
+                    <i1 Include='a.obj;b.obj'/>
                     <i1 Remove=""@(i0->'%(filename).obj')""/>
                 </ItemGroup>
             </Target>";
@@ -1213,8 +1213,8 @@ public void RemoveWithMultipleItemspecs()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
-                    <i1 Include='a2'/> 
+                    <i1 Include='a1'/>
+                    <i1 Include='a2'/>
                     <i1 Remove='a1;a2'/>
                 </ItemGroup>
             </Target>";
@@ -1231,8 +1231,8 @@ public void RemoveAllItemsInList()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
-                    <i1 Include='a2'/> 
+                    <i1 Include='a1'/>
+                    <i1 Include='a2'/>
                     <i1 Remove='@(i1)'/>
                 </ItemGroup>
             </Target>";
@@ -1280,7 +1280,7 @@ public void RemoveItemOutsideTarget()
         }
 
         /// <summary>
-        /// Bare (batchable) metadata is prohibited on IG/PG conditions -- all other expressions 
+        /// Bare (batchable) metadata is prohibited on IG/PG conditions -- all other expressions
         /// should be allowed
         /// </summary>
         [Test]
@@ -1302,7 +1302,7 @@ public void ConditionOnPropertyGroupUsingPropertiesAndItemListsAndTransforms()
             // </PropertyGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup Condition=""'$(p0)'=='v0' and '@(i0)'=='a1;a2;a3;a4' and '@(i0->'%(identity).x','|')'=='a1.x|a2.x|a3.x|a4.x'""> 
+                <PropertyGroup Condition=""'$(p0)'=='v0' and '@(i0)'=='a1;a2;a3;a4' and '@(i0->'%(identity).x','|')'=='a1.x|a2.x|a3.x|a4.x'"">
                   <p1>v1</p1>
                 </PropertyGroup>
             </Target>";
@@ -1318,7 +1318,7 @@ public void ConditionOnPropertyGroupUsingPropertiesAndItemListsAndTransforms()
         }
 
         /// <summary>
-        /// Bare (batchable) metadata is prohibited on IG/PG conditions -- all other expressions 
+        /// Bare (batchable) metadata is prohibited on IG/PG conditions -- all other expressions
         /// should be allowed
         /// </summary>
         [Test]
@@ -1340,7 +1340,7 @@ public void ConditionOnItemGroupUsingPropertiesAndItemListsAndTransforms()
             // </PropertyGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup Condition=""'$(p0)'=='v0' and '@(i0)'=='a1;a2;a3;a4' and '@(i0->'%(identity).x','|')'=='a1.x|a2.x|a3.x|a4.x'"">  
+                <ItemGroup Condition=""'$(p0)'=='v0' and '@(i0)'=='a1;a2;a3;a4' and '@(i0->'%(identity).x','|')'=='a1.x|a2.x|a3.x|a4.x'"">
                   <i1 Include='x'/>
                 </ItemGroup>
             </Target>";
@@ -1359,9 +1359,9 @@ public void ConditionOnItemGroupUsingPropertiesAndItemListsAndTransforms()
         /// <summary>
         /// This bug was caused by batching over the ItemGroup as well as over each child.
         /// If the condition on a child did not exclude it, an unwitting child could be included multiple times,
-        /// once for each outer batch. The fix was to abandon the idea of outer batching and just 
+        /// once for each outer batch. The fix was to abandon the idea of outer batching and just
         /// prohibit batchable expressions on the ItemGroup conditions. It's just too hard to write such expressions
-        /// in a comprehensible way.    
+        /// in a comprehensible way.
         /// </summary>
         [Test]
         public void RegressPCHBug68578()
@@ -1379,7 +1379,7 @@ public void RegressPCHBug68578()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                   <!-- squint and pretend i0 is 'CppCompile' and 'm' is 'ObjectFile' -->
                   <Link Include=""A_PCH""/>
                   <Link Include=""@(i0->'%(m).obj')"" Condition=""'%(i0.m)' == 'm1'""/>
@@ -1504,13 +1504,13 @@ public void RemovesOfPersistedItemsAreReversed3()
                   <ItemGroup>
                     <i0 Include='a1'>
                       <m>m1</m>
-                    </i0> 
+                    </i0>
                   </ItemGroup>
                   <Target Name=`t`>
                     <ItemGroup>
                       <i0 Include='a1'>
                         <m>m2</m>
-                      </i0> 
+                      </i0>
                       <i0 Remove=`a1`/>
                     </ItemGroup>
                     <Message Text=`[%(i0.m)]`/>
@@ -1574,13 +1574,13 @@ public void RemovesOfItemsOnlyWithMetadataValue()
                   <ItemGroup>
                     <i0 Include='a1'>
                       <m>m1</m>
-                    </i0> 
+                    </i0>
                   </ItemGroup>
                   <Target Name=`t`>
                     <ItemGroup>
                       <i0 Include='a1'>
                         <m>m2</m>
-                      </i0> 
+                      </i0>
                       <i0 Remove=`a1` Condition=`'%(i0.m)' == 'm1'`/>
                     </ItemGroup>
                     <Message Text=`[%(i0.m)]`/>
@@ -1634,7 +1634,7 @@ public void RemoveWithWildcards()
                 string content = @"
                 <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <ItemGroup>
-                        <i1 Include='" + files[0] + ";" + files[1] + @";other'/> 
+                        <i1 Include='" + files[0] + ";" + files[1] + @";other'/>
                         <i1 Remove='$(temp)\*.tmp'/>
                     </ItemGroup>
                 </Target>";
@@ -1662,13 +1662,13 @@ public void RemovesNotVisibleToParallelTargetBatches()
                   <ItemGroup>
                     <i Include=`1.in`><output>1.out</output></i>
                     <i Include=`2.in`><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.output)`>
                     <Message Text=`start:[@(i)]`/>
                     <ItemGroup>
                       <i Remove=`1.in;2.in`/>
                     </ItemGroup>
-                    <Message Text=`end:[@(i)]`/>                    
+                    <Message Text=`end:[@(i)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -1687,13 +1687,13 @@ public void RemovesNotVisibleToParallelTargetBatches2()
                     <i Include=`1.in`><output>1.out</output></i>
                     <i Include=`2.in`><output>2.out</output></i>
                     <j Include=`j1`/>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.output)`>
                     <Message Text=`start:[@(j)]`/>
                     <ItemGroup>
                       <j Remove=`@(j)`/>
                     </ItemGroup>
-                    <Message Text=`end:[@(j)]`/>                    
+                    <Message Text=`end:[@(j)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -1717,7 +1717,7 @@ public void RemovesAreVisibleToCalledTarget()
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <ItemGroup>
                     <i Include=`i1;i2`/>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`a:[@(i)]`/>
                     <ItemGroup>
@@ -1725,7 +1725,7 @@ public void RemovesAreVisibleToCalledTarget()
                     </ItemGroup>
                     <Message Text=`b:[@(i)]`/>
                     <CallTarget Targets=`t2`/>
-                    <Message Text=`d:[@(i)]`/>                    
+                    <Message Text=`d:[@(i)]`/>
                   </Target>
                   <Target Name=`t2`>
                     <Message Text=`c:[@(i)]`/>
@@ -1783,7 +1783,7 @@ public void CalledTargetItemsAreNotVisibleToCallerTarget()
 
         /// <summary>
         /// Whidbey behavior was that items/properties emitted by a target calling another target, were
-        /// not visible to the calling target. (That was because the project items and properties had been cloned for the target batches.) 
+        /// not visible to the calling target. (That was because the project items and properties had been cloned for the target batches.)
         /// We must match that behavior. (For now)
         /// </summary>
         [Test]
@@ -1829,7 +1829,7 @@ public void ModifyNoOp()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1/>
                 </ItemGroup>
             </Target>";
@@ -1846,7 +1846,7 @@ public void ModifyItemInTarget()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
                     <i1>
@@ -1868,7 +1868,7 @@ public void ModifyItemInTargetLastMetadataWins()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
                     <i1>
@@ -1916,10 +1916,10 @@ public void ModifyItemInTargetWithCondition()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1 Condition=""'%(i1.m)'=='m2'"">
@@ -1945,10 +1945,10 @@ public void ModifyItemInTargetWithConditionOnMetadata()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1>
@@ -1991,10 +1991,10 @@ public void ModifyItemInTargetWithConditionWithoutItemTypeOnMetadataInCondition(
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1 Condition=""'%(m)'=='m2'"">
@@ -2021,10 +2021,10 @@ public void ModifyItemInTargetWithConditionOnMetadataWithoutItemTypeOnMetadataIn
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1>
@@ -2072,7 +2072,7 @@ public void ModifyItemOutsideTarget()
             IntrinsicTask task = CreateIntrinsicTask(content);
 
             Lookup lookup = GenerateLookup();
-            
+
             task.ExecuteTask(lookup);
 
             BuildItemGroup i0Group = lookup.GetItems("i0");
@@ -2149,7 +2149,7 @@ public void ModifiesOfPersistedItemsAreReversed1()
                     <ItemGroup>
                       <i0>
                         <m>m1</m>
-                      </i0> 
+                      </i0>
                     </ItemGroup>
                   </Target>
                   <Target Name=`t2`>
@@ -2190,7 +2190,7 @@ public void ModifiesOfPersistedItemsAreReversed2()
                       </i1>
                       <i1>
                         <n>n1</n>
-                      </i1> 
+                      </i1>
                     </ItemGroup>
                   </Target>
                   <Target Name=`t2`>
@@ -2307,7 +2307,7 @@ public void OutputPropertiesInTargetBatchesCreateItem()
                     <!-- just to cause two target batches -->
                     <i Include=`1.in`><output>1.out</output></i>
                     <i Include=`2.in`><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.output)`>
                     <Message Text=`start:[$(p)]`/>
                     <CreateProperty Value='$(p)--%(i.Identity)'>
@@ -2363,16 +2363,16 @@ public void PropertiesInInferredBuildCreateProperty()
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <ItemGroup>
                     <i Include=`" + files[0] + "`><output>" + files[1] + @"</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`final:[$(p)]`/>                    
+                    <Message Text=`final:[$(p)]`/>
                   </Target>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.Output)`>
                     <Message Text=`start:[$(p)]`/>
                     <CreateProperty Value='@(i)'>
                       <Output TaskParameter='Value' PropertyName='p'/>
                     </CreateProperty>
-                    <Message Text=`end:[$(p)]`/>                    
+                    <Message Text=`end:[$(p)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -2405,7 +2405,7 @@ public void ModifyItemPreviouslyModified()
                       </x>
                       <x>
                         <m1>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text=`[%(x.m1)]`/>
                   </Target>
@@ -2435,7 +2435,7 @@ public void ModifyItemPreviouslyModified2()
                     <ItemGroup>
                       <x>
                         <m1>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text=`[%(x.m1)]`/>
                   </Target>
@@ -2517,7 +2517,7 @@ public void FilterItemPreviouslyModified()
                       </x>
                       <x Condition=`'%(x.m1)'=='1'`>
                         <m1>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text=`[%(x.m1)]`/>
                   </Target>
@@ -2545,7 +2545,7 @@ public void FilterItemPreviouslyModified2()
                       </x>
                       <x>
                         <m1 Condition=`'%(x.m1)'=='1'`>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text=`[%(x.m1)]`/>
                   </Target>
@@ -2744,9 +2744,9 @@ private static IntrinsicTask CreateIntrinsicTask(string content)
             XmlDocument doc = new XmlDocument();
             doc.LoadXml(content);
 
-            IntrinsicTask task = new IntrinsicTask((XmlElement)doc.FirstChild.FirstChild, 
-                                                   new EngineLoggingServicesInProc(new EventSource(), true, null), 
-                                                   null, 
+            IntrinsicTask task = new IntrinsicTask((XmlElement)doc.FirstChild.FirstChild,
+                                                   new EngineLoggingServicesInProc(new EventSource(), true, null),
+                                                   null,
                                                    Directory.GetCurrentDirectory(),
                                                    new ItemDefinitionLibrary(new Project()));
             return task;
diff --git a/src/Deprecated/Engine.UnitTests/InvalidProjectFileException_Tests.cs b/src/Deprecated/Engine.UnitTests/InvalidProjectFileException_Tests.cs
index 599a19cfc3f..d11b243c0ef 100644
--- a/src/Deprecated/Engine.UnitTests/InvalidProjectFileException_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/InvalidProjectFileException_Tests.cs
@@ -30,11 +30,11 @@ public class InvalidProjectFileExceptionTests
         public void SerializeDeserialize()
         {
             InvalidProjectFileException e = new InvalidProjectFileException(
-                "projectFile", 
+                "projectFile",
                 1, 2, 3, 4,
                 "message",
                 "errorSubcategory",
-                "errorCode", 
+                "errorCode",
                 "helpKeyword");
 
             using (MemoryStream memstr = new MemoryStream())
diff --git a/src/Deprecated/Engine.UnitTests/ItemDefinitionLibrary_Tests.cs b/src/Deprecated/Engine.UnitTests/ItemDefinitionLibrary_Tests.cs
index db0a3760d63..b058f26bc06 100644
--- a/src/Deprecated/Engine.UnitTests/ItemDefinitionLibrary_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ItemDefinitionLibrary_Tests.cs
@@ -30,7 +30,7 @@ public void GetMetadataBeforeEvaluate()
             ItemDefinitionLibrary library = new ItemDefinitionLibrary(new Project());
             library.Add(group);
             library.GetDefaultMetadataValue("ccompile", "defines");
-        } 
+        }
 
         [Test]
         public void Basic()
@@ -44,7 +44,7 @@ public void Basic()
             library.Evaluate(null);
 
             Assertion.AssertEquals("DEBUG", library.GetDefaultMetadataValue("ccompile", "defines"));
-        }        
+        }
 
         [Test]
         public void SameGroupTwoChildrenSameItemTypeDifferentMetadata()
@@ -132,7 +132,7 @@ public void PropertyInMetadataValue()
 
         /// <summary>
         /// Verifies that, given metadata on an item definition, a corresponding item will pick up
-        /// that item definition metadata.  
+        /// that item definition metadata.
         /// </summary>
         [Test]
         public void ItemsPickUpItemDefinitionMetadata()
@@ -144,7 +144,7 @@ public void ItemsPickUpItemDefinitionMetadata()
                             <SomeMetadata>foo</SomeMetadata>
                         </ItemWithDefinition>
                     </ItemDefinitionGroup>
-                    
+
                     <ItemGroup>
                         <ItemWithDefinition Include=`foo.cs` />
                     </ItemGroup>
@@ -160,7 +160,7 @@ public void ItemsPickUpItemDefinitionMetadata()
 
         /// <summary>
         /// Verifies that, given metadata on an item definition, a corresponding item will pick up
-        /// that item definition metadata, even if the name of the item has since changed.  
+        /// that item definition metadata, even if the name of the item has since changed.
         /// </summary>
         [Test]
         public void ItemsPickUpItemDefinitionMetadataWithTransforms()
@@ -172,7 +172,7 @@ public void ItemsPickUpItemDefinitionMetadataWithTransforms()
                             <SomeMetadata>foo</SomeMetadata>
                         </ItemWithDefinition>
                     </ItemDefinitionGroup>
-                    
+
                     <ItemGroup>
                         <ItemWithDefinition Include=`foo.cs` />
                     </ItemGroup>
@@ -192,7 +192,7 @@ public void ItemsPickUpItemDefinitionMetadataWithTransforms()
 
         /// <summary>
         /// Verifies that, given metadata on an item definition, a corresponding item will pick up
-        /// that item definition metadata even if the definition is in a different project from the item.  
+        /// that item definition metadata even if the definition is in a different project from the item.
         /// </summary>
         [Test]
         public void ItemsPickUpItemDefinitionMetadataFromImportedProject()
diff --git a/src/Deprecated/Engine.UnitTests/ItemExpander_Tests.cs b/src/Deprecated/Engine.UnitTests/ItemExpander_Tests.cs
index a242d3b5282..eb909464aef 100644
--- a/src/Deprecated/Engine.UnitTests/ItemExpander_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ItemExpander_Tests.cs
@@ -157,7 +157,7 @@ public void ItemizeItemVectorNormal()
             Assertion.AssertEquals("First item WarningLevel should be 4", "4", compileItems[0].GetMetadata("WarningLevel"));
             Assertion.AssertEquals("First item should be b.cs", "b.cs", compileItems[1].FinalItemSpecEscaped);
             Assertion.AssertEquals("First item WarningLevel should be 3", "3", compileItems[1].GetMetadata("WarningLevel"));
-        }      
+        }
 
         /// <summary>
         /// Attempt to itemize an expression that is an @(...) item list concatenated with another string.
@@ -182,7 +182,7 @@ public void ItemizeItemVectorWithNoItemLists()
             Hashtable itemGroupsByType = this.GenerateTestItems();
 
             BuildItemGroup compileItems = ItemExpander.ItemizeItemVector("foobar", null, LookupHelpers.CreateLookup(itemGroupsByType).ReadOnlyLookup);
-            
+
             // If the specified expression does not contain any item lists, then we expect ItemizeItemVector
             // to give us back null, but not throw an exception.
             Assertion.AssertNull(compileItems);
@@ -278,17 +278,17 @@ public void ItemizeItemVectorWithSeparatorWithZeroItems2()
             logger.AssertLogContains("zz=[]");
         }
 
-        // Valid names. The goal here is that an item name is recognized iff it is valid 
+        // Valid names. The goal here is that an item name is recognized iff it is valid
         // in a project. (That is, iff it matches "[A-Za-z_][A-Za-z_0-9\-]*")
         private string[] validItemVectors = new string[]
         {
-            "@(   a1234567890_-AXZaxz   )", 
-            "@(z1234567890_-AZaz)", 
-            "@(A1234567890_-AZaz)", 
-            "@(Z1234567890_-AZaz)", 
-            "@(x1234567890_-AZaz)", 
-            "@(_X)", 
-            "@(a)", 
+            "@(   a1234567890_-AXZaxz   )",
+            "@(z1234567890_-AZaz)",
+            "@(A1234567890_-AZaz)",
+            "@(Z1234567890_-AZaz)",
+            "@(x1234567890_-AZaz)",
+            "@(_X)",
+            "@(a)",
             "@(_)"
         };
 
@@ -310,21 +310,21 @@ public void ItemizeItemVectorWithSeparatorWithZeroItems2()
 
         private string[] validMetadataExpressions = new string[]
         {
-            "%(   a1234567890_-AXZaxz.a1234567890_-AXZaxz   )", 
-            "%(z1234567890_-AZaz.z1234567890_-AZaz)", 
-            "%(A1234567890_-AZaz.A1234567890_-AZaz)", 
-            "%(Z1234567890_-AZaz.Z1234567890_-AZaz)", 
-            "%(x1234567890_-AZaz.x1234567890_-AZaz)", 
-            "%(abc._X)", 
-            "%(a12.a)", 
+            "%(   a1234567890_-AXZaxz.a1234567890_-AXZaxz   )",
+            "%(z1234567890_-AZaz.z1234567890_-AZaz)",
+            "%(A1234567890_-AZaz.A1234567890_-AZaz)",
+            "%(Z1234567890_-AZaz.Z1234567890_-AZaz)",
+            "%(x1234567890_-AZaz.x1234567890_-AZaz)",
+            "%(abc._X)",
+            "%(a12.a)",
             "%(x._)",
-            "%(a1234567890_-AXZaxz)", 
-            "%(z1234567890_-AZaz)", 
-            "%(A1234567890_-AZaz)", 
-            "%(Z1234567890_-AZaz)", 
-            "%(x1234567890_-AZaz)", 
-            "%(_X)", 
-            "%(a)", 
+            "%(a1234567890_-AXZaxz)",
+            "%(z1234567890_-AZaz)",
+            "%(A1234567890_-AZaz)",
+            "%(Z1234567890_-AZaz)",
+            "%(x1234567890_-AZaz)",
+            "%(_X)",
+            "%(a)",
             "%(_)"
         };
 
@@ -355,45 +355,45 @@ public void ItemizeItemVectorWithSeparatorWithZeroItems2()
 
         private string[] validItemVectorsWithTransforms = new string[]
         {
-            "@(z1234567890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'   )", 
-            "@(a1234567890_-AZaz->'z1234567890_-AZaz')", 
-            "@(A1234567890_-AZaz ->'A1234567890_-AZaz')", 
-            "@(Z1234567890_-AZaz -> 'Z1234567890_-AZaz')", 
-            "@(x1234567890_-AZaz->'x1234567890_-AZaz')", 
-            "@(_X->'_X')", 
-            "@(a->'a')", 
+            "@(z1234567890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'   )",
+            "@(a1234567890_-AZaz->'z1234567890_-AZaz')",
+            "@(A1234567890_-AZaz ->'A1234567890_-AZaz')",
+            "@(Z1234567890_-AZaz -> 'Z1234567890_-AZaz')",
+            "@(x1234567890_-AZaz->'x1234567890_-AZaz')",
+            "@(_X->'_X')",
+            "@(a->'a')",
             "@(_->'@#$%$%^&*&*)')"
         };
 
         private string[] validItemVectorsWithSeparators = new string[]
         {
-            "@(a1234567890_-AXZaxz  , 'z123%%4567890_-AXZaxz'   )", 
-            "@(z1234567890_-AZaz,'a1234567890_-AZaz')", 
-            "@(A1234567890_-AZaz,'!@#$%^&*)(_+'))", 
-            "@(_X,'X')", 
-            "@(a  ,  'a')", 
+            "@(a1234567890_-AXZaxz  , 'z123%%4567890_-AXZaxz'   )",
+            "@(z1234567890_-AZaz,'a1234567890_-AZaz')",
+            "@(A1234567890_-AZaz,'!@#$%^&*)(_+'))",
+            "@(_X,'X')",
+            "@(a  ,  'a')",
             "@(_,'@#$%$%^&*&*)')"
         };
 
         private string[] validItemVectorsWithTransformsAndSeparators = new string[]
         {
-            "@(a1234567890_-AXZaxz  -> 'a1234567890_-AXZaxz'   ,  'z1234567890_-AXZaxz'   )", 
-            "@(z1234567890_-AZaz->'z1234567890_-AZaz','a1234567890_-AZaz')", 
-            "@(A1234567890_-AZaz ->'A1234567890_-AZaz' , '!@#$%^&*)(_+'))", 
-            "@(_X->'_X','X')", 
-            "@(a->'a'  ,  'a')", 
+            "@(a1234567890_-AXZaxz  -> 'a1234567890_-AXZaxz'   ,  'z1234567890_-AXZaxz'   )",
+            "@(z1234567890_-AZaz->'z1234567890_-AZaz','a1234567890_-AZaz')",
+            "@(A1234567890_-AZaz ->'A1234567890_-AZaz' , '!@#$%^&*)(_+'))",
+            "@(_X->'_X','X')",
+            "@(a->'a'  ,  'a')",
             "@(_->'@#$%$%^&*&*)','@#$%$%^&*&*)')"
         };
 
         private string[] invalidItemVectorsWithTransforms = new string[]
         {
-            "@(z123456.7890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'  )", 
-            "@(a1234:567890_-AZaz->'z1234567890_-AZaz')", 
-            "@(.A1234567890_-AZaz ->'A1234567890_-AZaz')", 
-            "@(:Z1234567890_-AZaz -> 'Z1234567890_-AZaz')", 
-            "@(x123 4567890_-AZaz->'x1234567890_-AZaz')", 
-            "@(-x->'_X')", 
-            "@(1->'a')", 
+            "@(z123456.7890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'  )",
+            "@(a1234:567890_-AZaz->'z1234567890_-AZaz')",
+            "@(.A1234567890_-AZaz ->'A1234567890_-AZaz')",
+            "@(:Z1234567890_-AZaz -> 'Z1234567890_-AZaz')",
+            "@(x123 4567890_-AZaz->'x1234567890_-AZaz')",
+            "@(-x->'_X')",
+            "@(1->'a')",
             "@(1x->'@#$%$%^&*&*)')"
         };
 
@@ -419,14 +419,14 @@ public void ItemizeItemVectorsWithValidNames()
 
         /// <summary>
         /// Ensure that leading sand trailing pace is ignored for the item name
-        /// This tests "itemVectorPattern". 
+        /// This tests "itemVectorPattern".
         /// </summary>
         /// <owner>danmose</owner>
         [Test]
         public void ItemizeItemVectorsWithLeadingAndTrailingSpaces()
         {
             Hashtable itemGroupsByType = this.GenerateTestItems();
-            
+
             // Spaces around are fine, but it's ignored for the item name
             BuildItemGroup items = ItemExpander.ItemizeItemVector("@(  Compile    )", null, LookupHelpers.CreateLookup(itemGroupsByType).ReadOnlyLookup);
             Assertion.AssertEquals("Resulting item group should have 2 items", 2, items.Count);
@@ -434,7 +434,7 @@ public void ItemizeItemVectorsWithLeadingAndTrailingSpaces()
 
         /// <summary>
         /// Ensure that invalid item list expressions are not matched.
-        /// This tests "itemVectorPattern". 
+        /// This tests "itemVectorPattern".
         /// </summary>
         /// <owner>danmose</owner>
         [Test]
@@ -442,7 +442,7 @@ public void ItemizeItemVectorsWithInvalidNames()
         {
             Hashtable itemGroupsByType = this.GenerateTestItems();
 
-            // First, verify that a valid but simply non-existent item list returns an empty BuildItemGroup, 
+            // First, verify that a valid but simply non-existent item list returns an empty BuildItemGroup,
             // not just null.
             BuildItemGroup control = ItemExpander.ItemizeItemVector("@(nonexistent)", null, LookupHelpers.CreateLookup(itemGroupsByType).ReadOnlyLookup);
             Assertion.AssertEquals(0, control.Count);
diff --git a/src/Deprecated/Engine.UnitTests/Item_Tests.cs b/src/Deprecated/Engine.UnitTests/Item_Tests.cs
index 9534bcbef79..2e87f865741 100644
--- a/src/Deprecated/Engine.UnitTests/Item_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Item_Tests.cs
@@ -80,7 +80,7 @@ public void IncludeAndExcludeUnescaping()
                 Assertion.Assert(") should exclude both from );%29", i9Items.Count == 0);
                 Assertion.Assert("%2a should exclude %2a", i10Items.Count == 0);
                 Assertion.Assert("* matching foo should exclude foo", i11Items.Count == 0);
-                Assertion.Assert("* should exclude *", i12Items.Count == 0); 
+                Assertion.Assert("* should exclude *", i12Items.Count == 0);
             }
             finally
             {
@@ -103,7 +103,7 @@ public void ItemMetadataShouldBeEvaluatedEarly()
                         </Compile>
                         <CultureItem Include=`french`/>
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -145,20 +145,20 @@ public void HasMetadataAndGetItemMetadata()
             BuildItemGroup iItems = project.GetEvaluatedItemsByName("i");
             // I believe it is safe to assume ordering as ItemGroup is backed up by an ArrayList
             Assertion.Assert(iItems[0].FinalItemSpecEscaped == "i1");
-            Assertion.Assert(!iItems[0].HasMetadata("Culture")); // Does not have it 
+            Assertion.Assert(!iItems[0].HasMetadata("Culture")); // Does not have it
             Assertion.Assert(iItems[1].FinalItemSpecEscaped == "i2");
             Assertion.Assert(iItems[1].HasMetadata("Culture"));
             Assertion.Assert(iItems[1].HasMetadata("CuLtUrE"));
             Assertion.Assert(iItems[1].GetMetadata("CuLtUrE") == "klingon");
             Assertion.Assert(iItems[2].FinalItemSpecEscaped == "i3");
             Assertion.Assert(iItems[2].HasMetadata("Culture"));
-            Assertion.Assert(iItems[2].GetMetadata("Culture") == ""); 
+            Assertion.Assert(iItems[2].GetMetadata("Culture") == "");
             Assertion.Assert(iItems[3].FinalItemSpecEscaped == "i4");
             Assertion.Assert(iItems[3].HasMetadata("Culture"));
-            Assertion.Assert(iItems[3].GetMetadata("Culture") == ""); 
+            Assertion.Assert(iItems[3].GetMetadata("Culture") == "");
             Assertion.Assert(iItems[4].FinalItemSpecEscaped == "i1");
-            Assertion.Assert(iItems[4].HasMetadata("Culture")); 
-            Assertion.Assert(iItems[4].GetMetadata("Culture") == "vulcan"); 
+            Assertion.Assert(iItems[4].HasMetadata("Culture"));
+            Assertion.Assert(iItems[4].GetMetadata("Culture") == "vulcan");
         }
 
         [Test]
diff --git a/src/Deprecated/Engine.UnitTests/LogFormatter_Tests.cs b/src/Deprecated/Engine.UnitTests/LogFormatter_Tests.cs
index dc8f5e5ea13..130a81a5e79 100644
--- a/src/Deprecated/Engine.UnitTests/LogFormatter_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/LogFormatter_Tests.cs
@@ -22,7 +22,7 @@ public class LogFormatterTest
         /*
         * Method:  TimeSpanMediumDuration
         * Owner:   jomof
-        * 
+        *
         * Tests the mainline: a medium length duration
         */
         [Test]
@@ -30,14 +30,14 @@ public void TimeSpanMediumDuration()
         {
             TimeSpan t = new TimeSpan(1254544900);
             string result = LogFormatter.FormatTimeSpan(t);
-            Assertion.AssertEquals("00:02:05.45", result);            
+            Assertion.AssertEquals("00:02:05.45", result);
         }
 
 
         /*
         * Method:  TimeSpanZeroDuration
         * Owner:   jomof
-        * 
+        *
         * Format a TimeSpan where the duration is zero.
         */
         [Test]
@@ -45,7 +45,7 @@ public void TimeSpanZeroDuration()
         {
             TimeSpan t = new TimeSpan(0);
             string result = LogFormatter.FormatTimeSpan(t);
-            Assertion.AssertEquals("00:00:00", result);            
+            Assertion.AssertEquals("00:00:00", result);
         }
 
         [Test]
diff --git a/src/Deprecated/Engine.UnitTests/LoggerDescription_Tests.cs b/src/Deprecated/Engine.UnitTests/LoggerDescription_Tests.cs
index 9b5fc6a0ed8..6e19d450bc8 100644
--- a/src/Deprecated/Engine.UnitTests/LoggerDescription_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/LoggerDescription_Tests.cs
@@ -22,7 +22,7 @@ public class LoggerDescription_Tests
         [Test]
         public void LoggerDescriptionCustomSerialization()
         {
-  
+
             string className = "Class";
             string loggerAssemblyName = "Class";
             string loggerFileAssembly = null;
diff --git a/src/Deprecated/Engine.UnitTests/LoggerException_Tests.cs b/src/Deprecated/Engine.UnitTests/LoggerException_Tests.cs
index 0dd9d40ee95..d8c89af6e3f 100644
--- a/src/Deprecated/Engine.UnitTests/LoggerException_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/LoggerException_Tests.cs
@@ -29,10 +29,10 @@ public class InternalLoggerExceptionTests
         [Test]
         public void SerializeDeserialize()
         {
-            InternalLoggerException e = new InternalLoggerException("message", 
-                new Exception("innerException"), 
-                new BuildStartedEventArgs("evMessage", "evHelpKeyword"), 
-                "errorCode", 
+            InternalLoggerException e = new InternalLoggerException("message",
+                new Exception("innerException"),
+                new BuildStartedEventArgs("evMessage", "evHelpKeyword"),
+                "errorCode",
                 "helpKeyword",
                 false);
 
diff --git a/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs b/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
index 5338d973fe7..29fffbb8319 100644
--- a/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
@@ -18,7 +18,7 @@
 using System.Threading;
 
 namespace Microsoft.Build.UnitTests
-{  
+{
     [TestFixture]
     public class Lookup_Tests
     {
@@ -99,13 +99,13 @@ public void AddsAreCombinedWithPopulates()
             // Start a target
             lookup.EnterScope();
 
-            // We see the one item 
+            // We see the one item
             Assertion.AssertEquals("a1", lookup.GetItems("i1")[0].FinalItemSpec);
 
             // One item in the project
             Assertion.AssertEquals("a1", group1[0].FinalItemSpec);
             Assertion.AssertEquals(1, group1.Count);
-            
+
             // Start a task (eg) and add a new item
             lookup.EnterScope();
             lookup.AddNewItem(new BuildItem("i1", "a2"));
@@ -120,7 +120,7 @@ public void AddsAreCombinedWithPopulates()
 
             // Finish the task
             lookup.LeaveScope();
-          
+
             // We still see two items
             Assertion.AssertEquals("a1", lookup.GetItems("i1")[0].FinalItemSpec);
             Assertion.AssertEquals("a2", lookup.GetItems("i1")[1].FinalItemSpec);
@@ -196,13 +196,13 @@ public void Removes()
 
 // These tests used to have an #if DEBUG around them, because the method they
 // are testing only gets called in chk builds; they have been removed
-// entirely due to BVT bug 527712:  Main is attempting to run chk unit tests 
+// entirely due to BVT bug 527712:  Main is attempting to run chk unit tests
 // against ret bits.  Please only uncomment these tests if you have verified
 // that that scenario works.
-#if NULL    
+#if NULL
         /// <summary>
         /// Lookup class should never be asked to add an item that was already removed;
-        /// this is not something that is possible through a project file: all adds create 
+        /// this is not something that is possible through a project file: all adds create
         /// brand new items.
         /// </summary>
         [Test]
@@ -406,7 +406,7 @@ public void ModifyItemModifiedInPreviousScope()
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -446,7 +446,7 @@ public void ModifyItemTwiceInSameScope1()
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -511,7 +511,7 @@ public void ModifyItemTwiceInSameScope2()
             Assertion.AssertEquals("n2", foundGroup[0].GetMetadata("n"));
             Assertion.AssertEquals("o1", foundGroup[0].GetMetadata("o"));
 
-            // Make a modification to the item to be n=n3 
+            // Make a modification to the item to be n=n3
             newMetadata = new Dictionary<string, string>();
             newMetadata.Add("n", "n3");
             lookup.ModifyItems("i1", group, newMetadata);
@@ -604,7 +604,7 @@ public void ModifyItemPreviouslyModifiedAndGottenThroughGetItem()
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -651,7 +651,7 @@ public void ModifyItemPreviouslyModifiedAndGottenThroughGetItem()
         [Test]
         public void ModifyItemInProjectPreviouslyModifiedAndGottenThroughGetItem()
         {
-            // Create some project state with an item with m=m1 and n=n1 
+            // Create some project state with an item with m=m1 and n=n1
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
@@ -708,7 +708,7 @@ public void RemoveItemPreviouslyModifiedAndGottenThroughGetItem()
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -741,7 +741,7 @@ public void RemoveItemPreviouslyModifiedAndGottenThroughGetItem()
         [Test]
         public void RemoveItemFromProjectPreviouslyModifiedAndGottenThroughGetItem()
         {
-            // Create some project state with an item with m=m1 and n=n1 
+            // Create some project state with an item with m=m1 and n=n1
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
@@ -836,7 +836,7 @@ public void ModifiedProperty()
 
             lookup.EnterScope();
 
-            // Change the value again in the new scope 
+            // Change the value again in the new scope
             lookup.SetProperty(new BuildProperty("p1", "v3", PropertyType.OutputProperty));
 
             // Lookup is updated, but not the original item group
@@ -845,14 +845,14 @@ public void ModifiedProperty()
 
             lookup.EnterScope();
 
-            // Change the value again in the new scope 
+            // Change the value again in the new scope
             lookup.SetProperty(new BuildProperty("p1", "v4", PropertyType.OutputProperty));
 
             Assertion.AssertEquals("v4", lookup.GetProperty("p1").FinalValue);
 
             lookup.LeaveScope();
 
-            Assertion.AssertEquals("v4", lookup.GetProperty("p1").FinalValue);              
+            Assertion.AssertEquals("v4", lookup.GetProperty("p1").FinalValue);
 
             // Leave to the outer scope
             lookup.LeaveScope();
@@ -1030,6 +1030,6 @@ internal static ItemDefinitionLibrary CreateEmptyEvaluatedItemDefinitionLibrary(
             ItemDefinitionLibrary itemDefinitionLibrary = new ItemDefinitionLibrary(new Project());
             itemDefinitionLibrary.Evaluate(new BuildPropertyGroup());
             return itemDefinitionLibrary;
-        }    
+        }
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/MockNode.cs b/src/Deprecated/Engine.UnitTests/MockNode.cs
index e15b49678e1..4fcc7f66145 100644
--- a/src/Deprecated/Engine.UnitTests/MockNode.cs
+++ b/src/Deprecated/Engine.UnitTests/MockNode.cs
@@ -60,7 +60,7 @@ long executionTime
             postTaskOutputsInputs.Add("taskExecutedSuccessfully", taskExecutedSuccessfully);
             postTaskOutputsInputs.Add("thrownException", thrownException);
         }
- 
+
         /// <summary>
         /// Override to BuildProject file to return true so we can test that
         /// </summary>
@@ -89,6 +89,6 @@ override internal void GetLineColumnOfXmlNode(int nodeProxyId, out int lineNumbe
             lineNumber = 0;
             columnNumber = 0;
         }
-        
+
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/MockProjectStartedLogger.cs b/src/Deprecated/Engine.UnitTests/MockProjectStartedLogger.cs
index 39b945d3b31..8589999d8ce 100644
--- a/src/Deprecated/Engine.UnitTests/MockProjectStartedLogger.cs
+++ b/src/Deprecated/Engine.UnitTests/MockProjectStartedLogger.cs
@@ -23,12 +23,12 @@ class MockProjectStartedLogger : ILogger
         /// </summary>
         public LoggerVerbosity Verbosity
         {
-            get 
-            { 
-                return LoggerVerbosity.Diagnostic; 
+            get
+            {
+                return LoggerVerbosity.Diagnostic;
             }
-            set 
-            { 
+            set
+            {
             }
         }
 
@@ -37,15 +37,15 @@ public LoggerVerbosity Verbosity
         /// </summary>
         public string Parameters
         {
-            get 
-            { 
-                return null; 
+            get
+            {
+                return null;
             }
             set
             {
             }
         }
-        
+
         /// <summary>
         /// Subscribing to the events
         /// </summary>
@@ -56,7 +56,7 @@ public void Initialize(IEventSource eventSource)
         }
 
         /// <summary>
-        /// Handler for the ProjectStarted event. 
+        /// Handler for the ProjectStarted event.
         /// </summary>
         /// <param name="sender"></param>
         /// <param name="e"></param>
diff --git a/src/Deprecated/Engine.UnitTests/MockTask.cs b/src/Deprecated/Engine.UnitTests/MockTask.cs
index e884fd59f52..bded93b80f2 100644
--- a/src/Deprecated/Engine.UnitTests/MockTask.cs
+++ b/src/Deprecated/Engine.UnitTests/MockTask.cs
@@ -236,7 +236,7 @@ public ArrayList MyArrayListOutputParam
         }
 
         /// <summary>
-        /// Null ITaskItem[] output parameter. 
+        /// Null ITaskItem[] output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -250,7 +250,7 @@ public ITaskItem[] NullITaskItemArrayOutputParameter
         }
 
         /// <summary>
-        /// Empty string output parameter. 
+        /// Empty string output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -263,7 +263,7 @@ public string EmptyStringOutputParameter
         }
 
         /// <summary>
-        /// Empty string output parameter. 
+        /// Empty string output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -277,7 +277,7 @@ public string[] EmptyStringInStringArrayOutputParameter
         }
 
         /// <summary>
-        /// ITaskItem output parameter. 
+        /// ITaskItem output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -291,7 +291,7 @@ public ITaskItem ITaskItemOutputParameter
         }
 
         /// <summary>
-        /// string output parameter. 
+        /// string output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -304,7 +304,7 @@ public string StringOutputParameter
         }
 
         /// <summary>
-        /// string array output parameter. 
+        /// string array output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -317,7 +317,7 @@ public string[] StringArrayOutputParameter
         }
 
         /// <summary>
-        /// int output parameter. 
+        /// int output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -330,7 +330,7 @@ public int IntOutputParameter
         }
 
         /// <summary>
-        /// int array output parameter. 
+        /// int array output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -343,7 +343,7 @@ public int[] IntArrayOutputParameter
         }
 
         /// <summary>
-        /// object array output parameter. 
+        /// object array output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -403,7 +403,7 @@ public TaskItem[] TaskItemArrayOutputParameter
             }
         }
     }
-    
+
     /// <summary>
     /// A simple mock task for use with Unit Testing.
     /// </summary>
@@ -429,7 +429,7 @@ public IBuildEngine BuildEngine
         {
             get {return this.e;}
             set {this.e = value;}
-        }        
+        }
 
         /// <summary>
         /// Access the host object.
@@ -439,7 +439,7 @@ public ITaskHost HostObject
         {
             get {return null;}
             set {}
-        }        
+        }
 
         /// <summary>
         /// Main Execute method of the task does nothing.
diff --git a/src/Deprecated/Engine.UnitTests/NodeLoggingEventTests.cs b/src/Deprecated/Engine.UnitTests/NodeLoggingEventTests.cs
index bf0059aecfd..06abc5cd23d 100644
--- a/src/Deprecated/Engine.UnitTests/NodeLoggingEventTests.cs
+++ b/src/Deprecated/Engine.UnitTests/NodeLoggingEventTests.cs
@@ -205,7 +205,7 @@ public void TestLoggingEventCustomerSerialization()
             nodeLoggingEvent = new NodeLoggingEvent(null);
             nodeLoggingEvent.CreateFromStream(reader, loggingTypeCacheReads);
             Assert.IsTrue(nodeLoggingEvent.BuildEvent.GetType() ==typeof( TaskCommandLineEventArgs));
-            
+
             long streamReadEndPosition = stream.Position;
             Assert.AreEqual(streamWriteEndPosition, streamReadEndPosition, "Expected Read and Write Positions to match");
         }
diff --git a/src/Deprecated/Engine.UnitTests/NodeManager_Tests.cs b/src/Deprecated/Engine.UnitTests/NodeManager_Tests.cs
index ffac549db5f..ba016d9b45b 100644
--- a/src/Deprecated/Engine.UnitTests/NodeManager_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/NodeManager_Tests.cs
@@ -67,10 +67,10 @@ public void RegisterNullNodeProviders()
         [Test]
         public void RegisterNodeProviders()
         {
-                      
+
             MockNodeProvider ProviderOneNode = new MockNodeProvider();
             ProviderOneNode.NodeDescriptions.Add(new MockNodeDescription("Provider One Node One"));
-           
+
             MockNodeProvider ProviderThreeNodes = new MockNodeProvider();
             ProviderThreeNodes.NodeDescriptions.Add(new MockNodeDescription("Provider Two Node One"));
             ProviderThreeNodes.NodeDescriptions.Add(new MockNodeDescription("Provider Two Node Two"));
@@ -205,7 +205,7 @@ public void TestPostBuildRequestToNode()
             nodeManager.PostBuildRequestToNode(2, new BuildRequest(2, "ProjectFile", null, new BuildPropertyGroup(), null, 2, false, false));
             nodeManager.PostBuildRequestToNode(3, new BuildRequest(3, "ProjectFile", null, new BuildPropertyGroup(), null, 3, false, false));
             nodeManager.PostBuildRequestToNode(4, new BuildRequest(4, "ProjectFile", null, new BuildPropertyGroup(), null, 4, false, false));
-            
+
             Assert.IsTrue(ProviderThreeNodes.buildRequestsSubmittedToProvider.Count == 3, "Expected there to be three build results in the mock provider");
             Assert.IsTrue(ProviderThreeNodes.buildRequestsSubmittedToProvider[0].HandleId == 1, "Expected first NodeProxyId to be 1");
             Assert.IsTrue(ProviderThreeNodes.buildRequestsSubmittedToProvider[1].HandleId == 2, "Expected second NodeProxyId to be 2");
@@ -295,7 +295,7 @@ void INodeProvider.RegisterNodeLogger(LoggerDescription description )
             if ( description == null )
             {
                 throw new ArgumentException("Logger description should be non-null");
-            } 
+            }
         }
 
         void INodeProvider.PostBuildRequestToNode(int nodeIndex, BuildRequest buildRequest)
@@ -332,7 +332,7 @@ void INodeProvider.ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
 
         public void UpdateSettings(bool enableOutOfProcLogging, bool enableOnlyLogCriticalEvents, bool useBreadthFirstTraversalSetting)
         {
-          
+
         }
 
         #endregion
@@ -342,7 +342,7 @@ public void UpdateSettings(bool enableOutOfProcLogging, bool enableOnlyLogCritic
 
         public void AssignNodeIdentifiers(int[] nodeIdentifiers)
         {
-           
+
         }
 
         public void RequestNodeStatus(int nodeIndex, int requestId)
diff --git a/src/Deprecated/Engine.UnitTests/NodeRequestMapping_Tests.cs b/src/Deprecated/Engine.UnitTests/NodeRequestMapping_Tests.cs
index 917333040ba..75006eafe8d 100644
--- a/src/Deprecated/Engine.UnitTests/NodeRequestMapping_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/NodeRequestMapping_Tests.cs
@@ -36,7 +36,7 @@ public class NodeRequestMapping_Tests
         public void Initialize()
         {
             // Create some items and place them in a dictionary
-            // Add some include information so that when we check the final 
+            // Add some include information so that when we check the final
             // item spec we can verify that the item was recreated properly
             BuildItem buildItem1 = new BuildItem("BuildItem1", "Item1");
             buildItem1.Include = "TestInclude1";
@@ -70,7 +70,7 @@ public void AddResultToCache()
             Assert.AreEqual(1,requestMapping.HandleId,"Expected NodeProxyId to be 1");
             Assert.AreEqual(1,requestMapping.RequestId,"Expected RequestId to be 1");
             requestMapping.AddResultToCache(resultWithOutputs);
-            Assert.IsTrue(resultWithOutputs.EvaluationResult == ((BuildResultCacheEntry)cacheScope.GetCacheEntry("TaskItems")).BuildResult, 
+            Assert.IsTrue(resultWithOutputs.EvaluationResult == ((BuildResultCacheEntry)cacheScope.GetCacheEntry("TaskItems")).BuildResult,
                 "Expected EvaluationResult to be the same after it was retrieved from the cache");
             Assert.IsTrue(((BuildItem[])resultWithOutputs.OutputsByTarget["TaskItems"])[0].Include == ((BuildResultCacheEntry)cacheScope.GetCacheEntry("TaskItems")).BuildItems[0].Include,
                 "Expected EvaluationResult to be the same after it was retrieved from the cache");
@@ -89,7 +89,7 @@ public void AddResultToCacheUncacheableResult()
             Assert.AreEqual(1, requestMapping.HandleId, "Expected NodeProxyId to be 1");
             Assert.AreEqual(1, requestMapping.RequestId, "Expected RequestId to be 1");
             requestMapping.AddResultToCache(uncacheableResult);
-            Assert.IsNull(cacheScope.GetCacheEntry("TaskItems"), 
+            Assert.IsNull(cacheScope.GetCacheEntry("TaskItems"),
                 "Expected null to be retrieved from the cache as the targetNamesList should not have been added");
         }
 
@@ -124,7 +124,7 @@ public void AddResultToPassInNullCacheScope()
         } */
 
         /// <summary>
-        /// Make sure that the correct InternalErrorException exception is thrown if a null build result is 
+        /// Make sure that the correct InternalErrorException exception is thrown if a null build result is
         /// attempted to be cached. This test is
         /// here to describe the behavior but it is not run because it causes a pop up.
         /// </summary>
diff --git a/src/Deprecated/Engine.UnitTests/OnError_Tests.cs b/src/Deprecated/Engine.UnitTests/OnError_Tests.cs
index c7ae69c3c7d..8bbe6704f56 100644
--- a/src/Deprecated/Engine.UnitTests/OnError_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/OnError_Tests.cs
@@ -35,7 +35,7 @@ public void Basic()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -90,9 +90,9 @@ public void FailingTaskStillPublishesOutputs()
                     </root>");
 
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                         <Target Name='Build'>
-                            
+
                             <GenerateResource
                                 Sources='" + resx + @"'
                                 ExecuteAsTool='false'
@@ -100,11 +100,11 @@ public void FailingTaskStillPublishesOutputs()
                                     <Output TaskParameter='FilesWritten' ItemName='FilesWrittenItem'/>
                                     <Output TaskParameter='FilesWritten' PropertyName='FilesWrittenProperty'/>
                             </GenerateResource>
-                                               
+
                             <OnError ExecuteTargets='ErrorTarget'/>
                         </Target>
 
-                        <Target Name='ErrorTarget'>    
+                        <Target Name='ErrorTarget'>
                             <Message Text='[@(fileswrittenitem)]'/>
                             <Message Text='[$(fileswrittenproperty)]'/>
                         </Target>
@@ -146,16 +146,16 @@ public void OnErrorSeesPropertiesAndItemsFromFirstTarget()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                    <Target Name='Build'>
                       <!-- Create a bunch of items and properties -->
                       <CreateItem Include='a1'>
                         <Output ItemName='i1' TaskParameter='Include'/>
-                      </CreateItem> 
+                      </CreateItem>
                       <ItemGroup>
                         <i1 Include='a2'/>
-                      </ItemGroup> 
+                      </ItemGroup>
                       <CreateProperty Value='v1'>
                         <Output PropertyName='p1' TaskParameter='Value'/>
                       </CreateProperty>
@@ -193,7 +193,7 @@ public void TwoExecuteTargets()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -227,7 +227,7 @@ public void TwoOnErrorClauses()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -263,7 +263,7 @@ public void DependentTarget()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp' DependsOnTargets='CleanUp2'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -298,7 +298,7 @@ public void ErrorInChildIsHandledInParent()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -332,7 +332,7 @@ public void NonExistentExecuteTarget()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='Build'>
                       <Error Text='This is an error.'/>
                       <OnError ExecuteTargets='CleanUp'/>
@@ -360,7 +360,7 @@ public void TrueCondition()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -390,7 +390,7 @@ public void FalseCondition()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -421,7 +421,7 @@ public void PropertiesInExecuteTargets()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <PropertyGroup>
                      <Part1>Clean</Part1>
                      <Part2>Up</Part2>
@@ -456,7 +456,7 @@ public void ErrorTargetsContinueAfterErrorsInErrorHandler()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp1'>
                       <Message Text='CleanUp1-was-called.'/>
                       <Error Text='Error in CleanUp1.'/>
diff --git a/src/Deprecated/Engine.UnitTests/Parser_Tests.cs b/src/Deprecated/Engine.UnitTests/Parser_Tests.cs
index b37e54e36e6..3c355afad23 100644
--- a/src/Deprecated/Engine.UnitTests/Parser_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Parser_Tests.cs
@@ -133,13 +133,13 @@ public void FunctionCallParseTest()
             Parser p = new Parser();
             GenericExpressionNode tree;
             tree = p.Parse("SimpleFunctionCall()", null, ParserOptions.AllowAll);
-            
+
             tree = p.Parse("SimpleFunctionCall( 1234 )", null, ParserOptions.AllowAll);
             tree = p.Parse("SimpleFunctionCall( true )", null, ParserOptions.AllowAll);
             tree = p.Parse("SimpleFunctionCall( $(property) )", null, ParserOptions.AllowAll);
-            
+
             tree = p.Parse("SimpleFunctionCall( $(property), 1234, abcd, 'abcd efgh' )", null, ParserOptions.AllowAll);
-            
+
         }
 
         /// <owner>DavidLe</owner>
@@ -450,7 +450,7 @@ public void VerifyWarningForOrder()
                 ", new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath));
 
             // Make sure the log contains the correct strings.
-            Assertion.Assert("Need to warn for this expression - (a) == 1 and $(b) == 2 or $(c) == 3.", 
+            Assertion.Assert("Need to warn for this expression - (a) == 1 and $(b) == 2 or $(c) == 3.",
                 ml.FullLog.Contains("MSB4130:"));
 
             ml = ObjectModelHelpers.BuildProjectExpectSuccess(String.Format(@"
diff --git a/src/Deprecated/Engine.UnitTests/ProjectManager_Tests.cs b/src/Deprecated/Engine.UnitTests/ProjectManager_Tests.cs
index 41d99de4a84..fd25282c8a6 100644
--- a/src/Deprecated/Engine.UnitTests/ProjectManager_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ProjectManager_Tests.cs
@@ -24,7 +24,7 @@ namespace Microsoft.Build.UnitTests
     public class ProjectManager_Tests
     {
         /// <summary>
-        /// Add a project to the ProjectManager, and try to get it back out using the 
+        /// Add a project to the ProjectManager, and try to get it back out using the
         /// correct set of search criteria.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -37,7 +37,7 @@ public void SimpleAddAndRetrieveProject()
             // Instantiate new project manager.
             ProjectManager projectManager = new ProjectManager();
 
-            // Set up variables that represent the information we would be getting from 
+            // Set up variables that represent the information we would be getting from
             // the "MSBuild" task.
             string fullPath = @"c:\rajeev\temp\myapp.proj";
             BuildPropertyGroup globalProperties = new BuildPropertyGroup();
@@ -56,7 +56,7 @@ public void SimpleAddAndRetrieveProject()
             // and make sure we get back the same project we added.
             Assertion.AssertEquals(project1, projectManager.GetProject(fullPath, globalProperties, null));
         }
-        
+
         /// <summary>
         /// Verify project manager does not insert duplicates into project table.
         /// </summary>
@@ -128,7 +128,7 @@ public void TestForDuplicatesInProjectEntryTable()
         }
 
         /// <summary>
-        /// Add a project to the ProjectManager, and try to get it back out using the 
+        /// Add a project to the ProjectManager, and try to get it back out using the
         /// wrong set of search criteria (different set of global properties).
         /// </summary>
         /// <owner>RGoel</owner>
@@ -141,7 +141,7 @@ public void SimpleAddAndRetrieveProjectWithDifferentGlobals()
             // Instantiate new project manager.
             ProjectManager projectManager = new ProjectManager();
 
-            // Set up variables that represent the information we would be getting from 
+            // Set up variables that represent the information we would be getting from
             // the "MSBuild" task.
             string fullPath = @"c:\rajeev\temp\myapp.proj";
             BuildPropertyGroup globalProperties = new BuildPropertyGroup();
@@ -163,7 +163,7 @@ public void SimpleAddAndRetrieveProjectWithDifferentGlobals()
         }
 
         /// <summary>
-        /// Add a project to the ProjectManager, and try to get it back out using the 
+        /// Add a project to the ProjectManager, and try to get it back out using the
         /// wrong set of search criteria (different full path).
         /// </summary>
         /// <owner>RGoel</owner>
@@ -176,7 +176,7 @@ public void SimpleAddAndRetrieveProjectWithDifferentFullPath()
             // Instantiate new project manager.
             ProjectManager projectManager = new ProjectManager();
 
-            // Set up variables that represent the information we would be getting from 
+            // Set up variables that represent the information we would be getting from
             // the "MSBuild" task.
             BuildPropertyGroup globalProperties = new BuildPropertyGroup();
             globalProperties.SetProperty("Configuration", "Release");
diff --git a/src/Deprecated/Engine.UnitTests/PropertyGroup_Tests.cs b/src/Deprecated/Engine.UnitTests/PropertyGroup_Tests.cs
index a44c713c9b8..e843e109e04 100644
--- a/src/Deprecated/Engine.UnitTests/PropertyGroup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/PropertyGroup_Tests.cs
@@ -421,7 +421,7 @@ public void RemovePropertyFromPropertyGroupThatIsntItsParent()
                         break;
                     }
                 }
-                
+
                 //this should throw because the property comes from another property group
                 second.RemoveProperty(property);
             }
diff --git a/src/Deprecated/Engine.UnitTests/Scanner_Tests.cs b/src/Deprecated/Engine.UnitTests/Scanner_Tests.cs
index d1a2e0bf821..10edea8a5db 100644
--- a/src/Deprecated/Engine.UnitTests/Scanner_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Scanner_Tests.cs
@@ -41,9 +41,9 @@ public void ErrorPosition()
                 { " $(",                    "2",    "AllowAll"},              // Position of $
                 { " $",                     "2",    "AllowAll"},              // Position of $
                 { " @(foo)",                "2",    "AllowProperties"},       // Position of @
-                { " '@(foo)'",              "3",    "AllowProperties"},       // Position of @    
+                { " '@(foo)'",              "3",    "AllowProperties"},       // Position of @
                 /* test escaped chars: message shows them escaped so count should include them */
-                { "'%24%28x' == '%24(x''",   "21",  "AllowAll"}               // Position of extra quote 
+                { "'%24%28x' == '%24(x''",   "21",  "AllowAll"}               // Position of extra quote
             };
 
             // Some errors are caught by the Parser, not merely by the Lexer/Scanner. So we have to do a full Parse,
@@ -65,7 +65,7 @@ public void ErrorPosition()
                 }
             }
         }
- 
+
         /// <summary>
         /// Advance to the point of the lexer error. If the error is only caught by the parser, this isn't useful.
         /// </summary>
@@ -180,7 +180,7 @@ public void IllFormedQuotedString()
         public void NumericSingleTokenTests()
         {
             Scanner lexer;
-            
+
             lexer = new Scanner("1234", ParserOptions.AllowAll);
             Assertion.Assert(lexer.Advance());
             Assertion.AssertEquals(lexer.IsNext(Token.TokenType.Numeric), true);
diff --git a/src/Deprecated/Engine.UnitTests/SolutionWrapperProject_Tests.cs b/src/Deprecated/Engine.UnitTests/SolutionWrapperProject_Tests.cs
index 32930c3e3fb..8dcd83f8d6e 100644
--- a/src/Deprecated/Engine.UnitTests/SolutionWrapperProject_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/SolutionWrapperProject_Tests.cs
@@ -110,7 +110,7 @@ public void EmitToolsVersionAttributeToInMemoryProject9()
             }
             else
             {
-                Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed."); 
+                Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed.");
             }
         }
 
@@ -244,7 +244,7 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
             SolutionParser solution = SolutionParser_Tests.ParseSolutionHelper(solutionFileContents);
             BuildEventContext buildEventContext = new BuildEventContext(0, 0, 0, 0);
             SolutionWrapperProject.Generate(solution, project, "3.5", buildEventContext);
-            
+
             foreach (Target target in project.Targets)
             {
                 foreach (XmlNode childNode in target.TargetElement)
@@ -257,7 +257,7 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
 
                         Assertion.Assert(0 == String.Compare(
                                                             toolsVersionAttribute.Value,
-                                                            "$(ProjectToolsVersion)", 
+                                                            "$(ProjectToolsVersion)",
                                                             StringComparison.OrdinalIgnoreCase)
                                             );
                     }
@@ -300,15 +300,15 @@ public void ToolsVersionOverrideThrowsOnInvalidToolsVersion()
 
             try
             {
-                // We want to avoid using the solution cache -- it could lead to circumstances where detritus left 
-                // on the disk leads us down paths we didn't mean to go.  
+                // We want to avoid using the solution cache -- it could lead to circumstances where detritus left
+                // on the disk leads us down paths we didn't mean to go.
                 Environment.SetEnvironmentVariable("MSBuildUseNoSolutionCache", "1");
 
                 // We're not passing in a /tv:xx switch, so the solution project will have tools version 3.5
                 Project project = new Project();
                 SolutionParser solution = SolutionParser_Tests.ParseSolutionHelper(solutionFileContents);
                 BuildEventContext buildEventContext = new BuildEventContext(0, 0, 0, 0);
-            
+
                 SolutionWrapperProject.Generate(solution, project, "invalid", buildEventContext);
 
                 Assertion.AssertEquals("4.0", project.DefaultToolsVersion);
@@ -318,7 +318,7 @@ public void ToolsVersionOverrideThrowsOnInvalidToolsVersion()
                 Environment.SetEnvironmentVariable("MSBuildUseNoSolutionCache", oldUseNoCacheValue);
             }
         }
-            
+
         /// <summary>
         /// Test the SolutionWrapperProject.AddPropertyGroupForSolutionConfiguration method
         /// </summary>
@@ -383,7 +383,7 @@ public void TestDisambiguateProjectTargetName()
             // NOTE: ValidateSolutionConfiguration and ValidateToolsVersions are always added, so we need to add two extras
             Assertion.AssertEquals(ProjectInSolution.projectNamesToDisambiguate.Length + 2, countOfStandardTargets);
         }
-        
+
         /// <summary>
         /// Tests the algorithm for choosing default configuration/platform values for solutions
         /// </summary>
@@ -410,7 +410,7 @@ public void TestConfigurationPlatformDefaults1()
 
             Project msbuildProject = new Project();
             SolutionWrapperProject.Generate(solution, msbuildProject, null, null);
-            
+
             // Default for Configuration is "Debug", if present
             Assertion.AssertEquals("Debug", msbuildProject.GetEvaluatedProperty("Configuration"));
 
@@ -482,7 +482,7 @@ public void DefaultTargetFrameworkVersion()
 
             // v3.5 by default
             Assertion.AssertEquals("v4.0", msbuildProject.EvaluatedProperties["TargetFrameworkVersion"].Value);
-            // may be user defined 
+            // may be user defined
             msbuildProject.SetProperty("TargetFrameworkVersion", "userdefined");
             Assertion.AssertEquals("userdefined", msbuildProject.EvaluatedProperties["TargetFrameworkVersion"].Value);
             // v2.0 if MSBuildToolsVersion is 2.0
@@ -541,7 +541,7 @@ public void TestTargetFrameworkPaths2()
             msbuildProject.SetProperty("TargetFrameworkVersion", "v3.5");
             bool success = msbuildProject.Build("GetFrameworkPathAndRedistList");
             Assertion.AssertEquals(true, success);
-            
+
             AssertProjectContainsItem(msbuildProject, "_CombinedTargetFrameworkDirectoriesItem", FrameworkLocationHelper.PathToDotNetFrameworkV20);
             if (FrameworkLocationHelper.PathToDotNetFrameworkV35 != null && FrameworkLocationHelper.PathToDotNetFrameworkV30 != null)
             {
@@ -620,7 +620,7 @@ private static Project CreateVenusSolutionProject(BuildPropertyGroup globalPrope
             SolutionWrapperProject.Generate(solution, msbuildProject, toolsVersion, null);
             return msbuildProject;
         }
-  
+
         private void AssertProjectContainsItem(Project msbuildProject, string itemName, string itemSpec)
         {
             BuildItemGroup itemGroup = (BuildItemGroup)msbuildProject.EvaluatedItemsByName[itemName];
@@ -718,7 +718,7 @@ public void SolutionParserShouldNotIncreaseNumberOfProjectsLoadedByHost()
             Engine engine = new Engine();
             Project project = new Project(engine, null);
 
-            // This project considers itself loaded-by-host. Setting a file name on it, causes it to 
+            // This project considers itself loaded-by-host. Setting a file name on it, causes it to
             // ensure the engine believes it is loaded-by-host...
             project.FullFileName = "my project";
 
diff --git a/src/Deprecated/Engine.UnitTests/TargetCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/TargetCollection_Tests.cs
index fa53fd1ac3e..86236768ef1 100644
--- a/src/Deprecated/Engine.UnitTests/TargetCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TargetCollection_Tests.cs
@@ -51,7 +51,7 @@ public void Cleanup()
 
         /// <summary>
         /// Un-registers the existing logger and registers a new copy.
-        /// We will use this when we do multiple builds so that we can safely 
+        /// We will use this when we do multiple builds so that we can safely
         /// assert on log messages for that particular build.
         /// </summary>
         private void ResetLogger()
@@ -148,7 +148,7 @@ public void SetInputsOutputsIncremental()
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <Target Name=`t` Inputs=`" + newFile + "` Outputs=`" + oldFile + @"`>
-                    <Message Text=`building target !!`/>                  
+                    <Message Text=`building target !!`/>
                 </Target>
                 </Project>
             ", logger);
@@ -167,7 +167,7 @@ public void SetInputsOutputsIncremental()
                 p.Build(new string[] { "t" });
 
                 logger.AssertLogDoesntContain("building target !!");
-                
+
 
             }
             finally
@@ -234,7 +234,7 @@ public void GetValidTargetInputsAndOutputs()
         {
             string targetOutputsString = "target_output";
             string targetInputsString = "target_input";
-            
+
             Target myTarget = myProject.Targets.AddNewTarget("BuildMe");
             myTarget.Inputs = targetInputsString;
             myTarget.Outputs = targetOutputsString;
@@ -282,11 +282,11 @@ public void SetTargetInputsAndOutputsOnAnAlreadyBuiltTarget()
 
             ITaskItem[] outputItems = BuildAndGatherOutputs("BuildMe");
 
-            
+
             Assertion.Assert(myLogger.FullLog.Contains("afoo"));
             Assertion.Assert(myLogger.FullLog.Contains("bfoo"));
             Assertion.AssertEquals(outputItems[0].ToString(), "1");
-            Assertion.AssertEquals(outputItems[1].ToString(), "2"); 
+            Assertion.AssertEquals(outputItems[1].ToString(), "2");
         }
 
         /// <summary>
@@ -340,7 +340,7 @@ public void ChangingAnExistingTargetInputsAndOutputs()
 
             ITaskItem[] outputItems1 = BuildAndGatherOutputs("BuildMe");
 
-            
+
             Assertion.Assert(myLogger.FullLog.Contains("a2foo"));
             Assertion.Assert(myLogger.FullLog.Contains("b2foo"));
             Assertion.AssertEquals(outputItems1[0].ToString(), "1-1");
@@ -396,7 +396,7 @@ public void ChangingAnExistingTargetInputs()
 
             ITaskItem[] outputItems1 = BuildAndGatherOutputs("BuildMe");
 
-            
+
             Assertion.Assert(myLogger.FullLog.Contains("a;bfoo"));
             Assertion.Assert(myLogger.FullLog.Contains("a2foo"));
             Assertion.Assert(myLogger.FullLog.Contains("b2foo"));
@@ -592,7 +592,7 @@ public void AddNewTargetWithOutputsString()
             Assertion.Assert(myLogger.FullLog.Contains("Exec"));
             Assertion.Assert(myLogger.FullLog.Contains("a;bfoo"));
             Assertion.AssertEquals(outputItems[0].ToString(), "1");
-            Assertion.AssertEquals(outputItems[1].ToString(), "2"); 
+            Assertion.AssertEquals(outputItems[1].ToString(), "2");
         }
 
         /// <summary>
@@ -876,7 +876,7 @@ public void TransformInTargetConditionLegal()
                     <x Include=`a.ext;b.ext`/>
                   </ItemGroup>
                   <Target Name=`t` Condition=`@(x -> '%(filename)')=='a;b'`>
-                    <Message Text=`#@(x)#`/>                  
+                    <Message Text=`#@(x)#`/>
                 </Target>
                 </Project>
             ", logger);
diff --git a/src/Deprecated/Engine.UnitTests/TargetDependencyAnalyzer_Tests.cs b/src/Deprecated/Engine.UnitTests/TargetDependencyAnalyzer_Tests.cs
index a7ebf203b7f..d73c3addeed 100644
--- a/src/Deprecated/Engine.UnitTests/TargetDependencyAnalyzer_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TargetDependencyAnalyzer_Tests.cs
@@ -82,7 +82,7 @@ public void EmptyItemSpecInTargetOutputs()
             ml.AssertLogDoesntContain("Running Build target");
             ml.AssertLogContains("MSB4168");
 
-            // Clear the mock logger object out so it is not reused            
+            // Clear the mock logger object out so it is not reused
             ml = null;
 
             ml = ObjectModelHelpers.BuildProjectExpectFailure(@"
@@ -115,11 +115,11 @@ public void EmptyItemSpecInTargetOutputs()
 
         /// <summary>
         /// Tests this case:
-        /// 
+        ///
         /// <Target Name="x"
         ///         Inputs="@(Items);c.cs"
         ///         Outputs="@(Items->'%(Filename).dll')" />
-        /// 
+        ///
         /// If Items = [a.cs;b.cs], and only b.cs is out of date w/r/t its
         /// correlated output b.dll, then we should only build "b" incrementally.
         /// </summary>
@@ -128,8 +128,8 @@ public void MetaInputAndInputItemThatCorrelatesWithOutputItem()
         {
             string inputs = "@(Items);c.cs";
             string outputs = "@(Items->'%(Filename).dll')";
-            FileWriteInfo[] filesToAnalyze = new FileWriteInfo[] 
-                                             { 
+            FileWriteInfo[] filesToAnalyze = new FileWriteInfo[]
+                                             {
                                                  new FileWriteInfo("a.cs", yesterday),
                                                  new FileWriteInfo("a.dll", today),
                                                  new FileWriteInfo("b.cs", today),
@@ -151,11 +151,11 @@ public void MetaInputAndInputItemThatCorrelatesWithOutputItem()
 
         /// <summary>
         /// Tests this case:
-        /// 
+        ///
         /// <Target Name="x"
         ///         Inputs="@(Items)"
         ///         Outputs="@(Items->'%(Filename).dll');@(Items->'%(Filename).xml')" />
-        /// 
+        ///
         /// If Items = [a.cs;b.cs;c.cs], and only b.cs is out of date w/r/t its
         /// correlated outputs (dll or xml), then we should only build "b" incrementally.
         /// </summary>
@@ -165,8 +165,8 @@ public void InputItemThatCorrelatesWithMultipleTransformOutputItems()
             string inputs = "@(Items)";
             string outputs = "@(Items->'%(Filename).dll');@(Items->'%(Filename).xml')";
 
-            FileWriteInfo[] filesToAnalyze = new FileWriteInfo[] 
-                                             { 
+            FileWriteInfo[] filesToAnalyze = new FileWriteInfo[]
+                                             {
                                                  new FileWriteInfo("a.cs", yesterday),
                                                  new FileWriteInfo("a.dll", today),
                                                  new FileWriteInfo("a.xml", today),
@@ -182,7 +182,7 @@ public void InputItemThatCorrelatesWithMultipleTransformOutputItems()
             items.AddNewItem("Items", "a.cs");
             items.AddNewItem("Items", "b.cs");
             items.AddNewItem("Items", "c.cs");
-            
+
             Hashtable itemsByName = new Hashtable(StringComparer.OrdinalIgnoreCase);
             itemsByName.Add("Items", items);
 
@@ -264,7 +264,7 @@ out Hashtable upToDateTargetInputs
                 // now do the dependency analysis
                 ItemBucket itemBucket = new ItemBucket(null, null, LookupHelpers.CreateLookup(itemsByName), 0);
                 TargetDependencyAnalyzer analyzer = new TargetDependencyAnalyzer(ObjectModelHelpers.TempProjectDir, p.Targets["Build"], p.ParentEngine.LoggingServices, (BuildEventContext)null);
-                
+
                 return analyzer.PerformDependencyAnalysis(itemBucket, out changedTargetInputs, out upToDateTargetInputs);
             }
             finally
@@ -287,7 +287,7 @@ public void TestIsAnyOutOfDate1()
             IsAnyOutOfDateTestHelper
                 (
                 new DateTime(2000, 1, 1), /* input1 */
-                new DateTime(2000, 1, 1), /* input2 */ 
+                new DateTime(2000, 1, 1), /* input2 */
                 new DateTime(2001, 1, 1), /* output1 */
                 new DateTime(2001, 1, 1), /* output2 */
                 false /* none out of date */
@@ -549,7 +549,7 @@ bool isUpToDate
         /// <param name="isUpToDate"></param>
         private void IsAnyOutOfDateTestHelper
             (
-            DateTime? input1Time, 
+            DateTime? input1Time,
             DateTime? input2Time,
             DateTime? output1Time,
             DateTime? output2Time,
diff --git a/src/Deprecated/Engine.UnitTests/TargetInProgressState_Tests.cs b/src/Deprecated/Engine.UnitTests/TargetInProgressState_Tests.cs
index 7208e44a525..8d0c697a940 100644
--- a/src/Deprecated/Engine.UnitTests/TargetInProgressState_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TargetInProgressState_Tests.cs
@@ -43,7 +43,7 @@ public void TargetInProgressStateCustomSerialization()
                       <Target Name='t' DependsOnTargets='Build'/>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.Targets` />
                     </Project>
-                "); 
+                ");
             EngineCallback engineCallback = new EngineCallback(engine);
             Target build = project.Targets["Build"];
             List<ProjectBuildState> waitingBuildStates = null;
@@ -60,8 +60,8 @@ public void TargetInProgressStateCustomSerialization()
             initiatingRequest.AddBlockingTarget("Build");
             BuildRequest [] outstandingBuildRequests = null;
             string projectName = "SuperTestProject";
-            
-            
+
+
 
             TargetInProgessState targetInProgress1 = new TargetInProgessState(
                                                               engineCallback,
@@ -71,7 +71,7 @@ public void TargetInProgressStateCustomSerialization()
                                                               outstandingBuildRequests,
                                                               projectName
                                                           );
-            
+
             targetInProgress1.ParentTargetsForBuildRequests = null;
             Assertion.AssertNull(targetInProgress1.ParentTargetsForBuildRequests);
             Assertion.Assert(!targetInProgress1.RequestedByHost);
@@ -212,7 +212,7 @@ public void TargetIdWrapperCustomSerialization()
                 originalWrapper.name = string.Empty;
                 originalWrapper.nodeId = 6;
                 originalWrapper.projectId = 8;
-                
+
                 stream.Position = 0;
                 // Serialize
                 originalWrapper.WriteToStream(writer);
diff --git a/src/Deprecated/Engine.UnitTests/TaskEngine_Tests.cs b/src/Deprecated/Engine.UnitTests/TaskEngine_Tests.cs
index 4ee7f8d6178..1408438e97c 100644
--- a/src/Deprecated/Engine.UnitTests/TaskEngine_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskEngine_Tests.cs
@@ -24,9 +24,9 @@ namespace Microsoft.Build.UnitTests
     public class TaskEngineTest
     {
         /*********************************************************************************
-         * 
+         *
          *                                     BOOL
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "bool" parameter where no XML attribute was specified on the task.
@@ -38,7 +38,7 @@ public void InitTask_Bool_NoAttribute()
             XmlElement taskNode;
             TaskEngine taskEngine;
             MockTask mockTask;
-            ItemBucket itemBucket; 
+            ItemBucket itemBucket;
             EngineProxy engineProxy;
             taskNode = CreateXmlTaskNode();
             taskNode.RemoveAttribute("MyBoolParam");
@@ -130,9 +130,9 @@ public void InitTask_Bool_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     BOOL[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "bool[]" parameter where no XML attribute was specified on the task.
@@ -235,9 +235,9 @@ public void InitTask_BoolArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     INT
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "int" parameter where no XML attribute was specified on the task.
@@ -340,9 +340,9 @@ public void InitTask_Int_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     INT[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "int[]" parameter where no XML attribute was specified on the task.
@@ -445,9 +445,9 @@ public void InitTask_IntArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     STRING
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "string" parameter where no XML attribute was specified on the task.
@@ -550,9 +550,9 @@ public void InitTask_String_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     STRING[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "string[]" parameter where no XML attribute was specified on the task.
@@ -680,9 +680,9 @@ public void InitTask_StringArray_SingleItem()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     ITASKITEM
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "ITaskItem" parameter where no XML attribute was specified on the task.
@@ -887,9 +887,9 @@ public void InitTask_ITaskItem_CannotAcceptTwoItems()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     ITASKITEM[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "string[]" parameter where no XML attribute was specified on the task.
@@ -992,9 +992,9 @@ public void InitTask_ITaskItemArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] BOOL
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "bool" parameter where no XML attribute was specified on the task.
@@ -1077,9 +1077,9 @@ public void InitTask_Required_Bool_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] BOOL[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "bool[]" parameter where no XML attribute was specified on the task.
@@ -1174,9 +1174,9 @@ public void InitTask_Required_BoolArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] INT
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "int" parameter where no XML attribute was specified on the task.
@@ -1259,9 +1259,9 @@ public void InitTask_Required_Int_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] INT[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "int[]" parameter where no XML attribute was specified on the task.
@@ -1356,9 +1356,9 @@ public void InitTask_Required_IntArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] STRING
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "string" parameter where no XML attribute was specified on the task.
@@ -1441,9 +1441,9 @@ public void InitTask_Required_String_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] STRING[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "string[]" parameter where no XML attribute was specified on the task.
@@ -1538,9 +1538,9 @@ public void InitTask_Required_StringArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] ITASKITEM
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "ITaskItem" parameter where no XML attribute was specified on the task.
@@ -1623,9 +1623,9 @@ public void InitTask_Required_ITaskItem_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] ITASKITEM[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "string[]" parameter where no XML attribute was specified on the task.
@@ -1720,9 +1720,9 @@ public void InitTask_Required_ITaskItemArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                  OUTPUT PARAMS
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Attempts to gather outputs from a task parameter of type "ArrayList".  This should fail. Bug #416910
@@ -1774,7 +1774,7 @@ public void TaskOutputsNullITaskItemArrayParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(LookupHelpers.CreateLookup(new Hashtable()), myTaskOutputSpecification, "NullITaskItemArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -1828,7 +1828,7 @@ public void TaskOutputsEmptyStringInStringArrayParameterIntoItemList()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(LookupHelpers.CreateLookup(new Hashtable()), myTaskOutputSpecification, "EmptyStringInStringArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -1854,7 +1854,7 @@ public void TaskOutputsStringParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "StringOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -1880,7 +1880,7 @@ public void TaskOutputsStringArrayParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "StringArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -1906,7 +1906,7 @@ public void TaskOutputsIntParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "IntOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -1932,7 +1932,7 @@ public void TaskOutputsIntArrayParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "IntArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
 
@@ -1985,7 +1985,7 @@ public void TaskOutputsITaskItemParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(LookupHelpers.CreateLookup(new Hashtable()), myTaskOutputSpecification, "ITaskItemOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -2011,7 +2011,7 @@ public void TaskOutputsTaskItemParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "TaskItemOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -2037,7 +2037,7 @@ public void TaskOutputsTaskItemArrayParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "TaskItemArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -2063,7 +2063,7 @@ public void TaskOutputsMyTaskItemParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "MyTaskItemOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -2089,7 +2089,7 @@ public void TaskOutputsMyTaskItemArrayParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "MyTaskItemArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         [Test]
@@ -2113,7 +2113,7 @@ public void TasksAreDiscoveredWhenTaskConditionTrue()
                                    TaskExecutionMode.ExecuteTaskAndGatherOutputs,
                                    LookupHelpers.CreateLookup(new Hashtable())));
         }
-        
+
         [Test]
         public void TasksNotDiscoveredWhenTaskConditionFalse()
         {
@@ -2238,7 +2238,7 @@ public void OverridePropertiesInCreateProperty()
                                      Condition=""'%(LogicalName)' != '' "">
                          <Output TaskParameter=""Value"" PropertyName=""LinkSwitches""/>
                     </CreateProperty>
-                    <Message Text=`final:[$(LinkSwitches)]`/>                    
+                    <Message Text=`final:[$(LinkSwitches)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -2265,7 +2265,7 @@ public void OverridePropertiesInInferredCreateProperty()
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <ItemGroup>
                     <i Include=`" + files[0] + "`><output>" + files[1] + @"</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <ItemGroup>
                      <EmbeddedResource Include='a.resx'>
                     <LogicalName>foo</LogicalName>
@@ -2278,7 +2278,7 @@ public void OverridePropertiesInInferredCreateProperty()
                     </EmbeddedResource>
                     </ItemGroup>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`final:[$(LinkSwitches)]`/>   
+                    <Message Text=`final:[$(LinkSwitches)]`/>
                   </Target>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.Output)`>
                     <Message Text=`start:[Hello]`/>
@@ -2286,7 +2286,7 @@ public void OverridePropertiesInInferredCreateProperty()
                                      Condition=""'%(LogicalName)' != '' "">
                          <Output TaskParameter=""Value"" PropertyName=""LinkSwitches""/>
                     </CreateProperty>
-                    <Message Text=`end:[hello]`/>                    
+                    <Message Text=`end:[hello]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -2308,9 +2308,9 @@ public void OverridePropertiesInInferredCreateProperty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     Helpers
-         * 
+         *
          *********************************************************************************/
         private void InstantiateMockTaskHelper
             (
@@ -2347,7 +2347,7 @@ string condition
             Engine engine = new Engine(@"c:\");
             Project project = new Project(engine);
             EngineCallback engineCallback = new EngineCallback(engine);
-            TaskExecutionModule taskExecutionModule = new TaskExecutionModule(engineCallback, 
+            TaskExecutionModule taskExecutionModule = new TaskExecutionModule(engineCallback,
                                         TaskExecutionModule.TaskExecutionModuleMode.SingleProcMode, false);
             ProjectBuildState buildContext = new ProjectBuildState(null, null, new BuildEventContext(0, 1, 1, 1));
             int nodeProxyID = engineCallback.CreateTaskContext(project, null, buildContext, taskNode, EngineCallback.inProcNode, new BuildEventContext(BuildEventContext.InvalidNodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId));
@@ -2359,7 +2359,7 @@ string condition
                                     project.FullFileName,
                                     engine.LoggingServices,
                                     nodeProxyID,
-                                    taskExecutionModule, 
+                                    taskExecutionModule,
                                     new BuildEventContext(0, 1, 1, 1)
                                 );
             taskEngine.TaskClass = taskClass;
diff --git a/src/Deprecated/Engine.UnitTests/TaskExecutionContext_Tests.cs b/src/Deprecated/Engine.UnitTests/TaskExecutionContext_Tests.cs
index 9cca1f5f524..98b52a7bd56 100644
--- a/src/Deprecated/Engine.UnitTests/TaskExecutionContext_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskExecutionContext_Tests.cs
@@ -33,18 +33,18 @@ public void TaskExecutionContextCreation()
              // Create some items to instantiate a task execution context and check to make sure those values are set properly
             Engine engine = new Engine();
                    engine.BinPath="TestBinPath";
-          
-            ArrayList targetsToBuild = new ArrayList(); 
+
+            ArrayList targetsToBuild = new ArrayList();
             targetsToBuild.Add("targetName");
             ProjectBuildState projectContext = new ProjectBuildState(null, targetsToBuild, new BuildEventContext(0, 1, 1, 1));
 
             TaskExecutionContext context = new TaskExecutionContext(null, null, null, projectContext, 4, EngineCallback.inProcNode, new BuildEventContext(BuildEventContext.InvalidNodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId));
-         
+
             Assert.IsTrue(context.BuildContext.TargetNamesToBuild.Contains("targetName"),"Expected target list to contain targetName");
             Assert.IsNull(context.ParentTarget,"ParentTarget should be null");
             Assert.IsNull(context.ThrownException,"ThrownException should be null");
             Assert.AreEqual(4,context.HandleId,"Node ProxyId should be 4");
-        } 
+        }
 
 
         /// <summary>
diff --git a/src/Deprecated/Engine.UnitTests/TaskExecutionState_Test.cs b/src/Deprecated/Engine.UnitTests/TaskExecutionState_Test.cs
index fe1a2deeeb3..6773c945fcd 100644
--- a/src/Deprecated/Engine.UnitTests/TaskExecutionState_Test.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskExecutionState_Test.cs
@@ -56,7 +56,7 @@ public void SetUp()
         }
 
         /// <summary>
-        /// Test the case where the execution directory does not equal the current directory. In that 
+        /// Test the case where the execution directory does not equal the current directory. In that
         /// case the current directory should be switched to the execution directory
         /// </summary>
         [Test]
@@ -195,7 +195,7 @@ int nodeProxyId
             )
             : base(howToExecuteTask,
                 lookupForInference,
-                lookupForExecution, 
+                lookupForExecution,
                 taskXmlNode,
                 hostObject,
                 projectFileOfTaskNode,
diff --git a/src/Deprecated/Engine.UnitTests/TaskItem_Tests.cs b/src/Deprecated/Engine.UnitTests/TaskItem_Tests.cs
index d71b488df0a..9121f2694fe 100644
--- a/src/Deprecated/Engine.UnitTests/TaskItem_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskItem_Tests.cs
@@ -23,28 +23,28 @@ public class TaskItemTests
         /*
         * Method:  SimpleCopyMetadataTo
         * Owner:   jomof
-        * 
+        *
         * Try the most basic CopyMetadataTo(...)
-        * 
+        *
         */
         [Test]
         public void SimpleCopyMetadataTo()
         {
             TaskItem from = new TaskItem("myfile.txt");
             from.SetMetadata("Culture", "fr");
-            
+
             TaskItem to = new TaskItem("myfile.bin");
             from.CopyMetadataTo(to);
-            
+
             Assertion.AssertEquals("fr", to.GetMetadata("Culture"));
         }
-        
+
         /*
         * Method:  CopyMetadataToDoesNotCopyExtension
         * Owner:   jomof
-        * 
+        *
         * Make sure that CopyMetadataTo(...) does not copy extension.
-        * 
+        *
         */
         [Test]
         public void CopyMetadataToDoesNotCopyExtension()
@@ -53,7 +53,7 @@ public void CopyMetadataToDoesNotCopyExtension()
             TaskItem to = new TaskItem("myfile.bin");
 
             from.CopyMetadataTo(to);
-            
+
             Assertion.AssertEquals(".bin", to.GetMetadata("Extension"));
         }
 
diff --git a/src/Deprecated/Engine.UnitTests/TaskRegistry_Tests.cs b/src/Deprecated/Engine.UnitTests/TaskRegistry_Tests.cs
index 0b70e2bc552..e5fb70692da 100644
--- a/src/Deprecated/Engine.UnitTests/TaskRegistry_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskRegistry_Tests.cs
@@ -290,13 +290,13 @@ internal class TaskRegistryHelperMethods
 
         internal static Expander RegistryExpander
         {
-            get 
+            get
             {
                 if (registryExpander == null)
                 {
                     registryExpander = GetExpander();
                 }
-                return registryExpander; 
+                return registryExpander;
             }
         }
 
diff --git a/src/Deprecated/Engine.UnitTests/TaskWorkerThread_Tests.cs b/src/Deprecated/Engine.UnitTests/TaskWorkerThread_Tests.cs
index 023dae3a02c..40e460cb8a1 100644
--- a/src/Deprecated/Engine.UnitTests/TaskWorkerThread_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskWorkerThread_Tests.cs
@@ -144,13 +144,13 @@ private List<TaskExecutionStateHelper> InitializeTaskState()
 
         /// <summary>
         /// Right now we are just testing the fact that the TaskWorker thread will take in a couple of tasks, some doing blocking
-        /// callbacks and make sure that each of the tasks completed correctly. Since the tasks are the ones which will 
+        /// callbacks and make sure that each of the tasks completed correctly. Since the tasks are the ones which will
         /// in the end set the exit event, if the test does not complete then the test has failed.
         /// </summary>
         [Test]
         public void TaskWorkerThreadTest()
         {
-            // This event will be triggered right before a "engine" call back is made. 
+            // This event will be triggered right before a "engine" call back is made.
             // Once this event is fired we insert another item into the queue
             ManualResetEvent rightBeforeCallbackBlock = new ManualResetEvent(false);
 
@@ -179,7 +179,7 @@ public void TaskWorkerThreadTest()
 
             workerThread.ActivateThread();
 
-            // Wait for the call back to happen     
+            // Wait for the call back to happen
             rightBeforeCallbackBlock.WaitOne();
 
             // Lets insert a execution task which and post a work item which will cause a localDoneEvent to be set
diff --git a/src/Deprecated/Engine.UnitTests/ToolsVersion_Tests.cs b/src/Deprecated/Engine.UnitTests/ToolsVersion_Tests.cs
index 0a2eb0629af..3c6dad2f290 100644
--- a/src/Deprecated/Engine.UnitTests/ToolsVersion_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ToolsVersion_Tests.cs
@@ -82,7 +82,7 @@ public void InvalidToolPath()
             TaskRegistry taskRegistry = (TaskRegistry) t.GetTaskRegistry(null);
 
             Console.WriteLine(mockLogger.FullLog);
-            Assert.AreEqual(1, mockLogger.WarningCount, "Expected a warning for invalid character in toolpath"); 
+            Assert.AreEqual(1, mockLogger.WarningCount, "Expected a warning for invalid character in toolpath");
         }
 
         public ToolsetState_Tests()
@@ -154,7 +154,7 @@ private XmlDocument loadXmlFromPath(string path)
               new DefaultTasksFile("d:\\directory1\\directory2\\f.tasks",
                       @"<Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <UsingTask TaskName='f1' AssemblyName='f' />
-                       </Project>"), 
+                       </Project>"),
               new DefaultTasksFile("c:\\directory1\\directory2\\g.custom.tasks",
                       @"<Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <UsingTask TaskName='g1' AssemblyName='g' />
diff --git a/src/Deprecated/Engine.UnitTests/ToolsetConfigurationReader_Tests.cs b/src/Deprecated/Engine.UnitTests/ToolsetConfigurationReader_Tests.cs
index 735d39dbc35..13390e24c6c 100644
--- a/src/Deprecated/Engine.UnitTests/ToolsetConfigurationReader_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ToolsetConfigurationReader_Tests.cs
@@ -142,7 +142,7 @@ public void MSBuildToolsetsTest_BasicWithOtherConfigEntries()
         #region "Invalid cases (exception is expected to be thrown)"
 
         /// <summary>
-        /// name attribute is missing from toolset element 
+        /// name attribute is missing from toolset element
         /// </summary>
         [Test]
         [ExpectedException(typeof(ConfigurationErrorsException))]
@@ -196,7 +196,7 @@ public void ToolsVersionTest_MultipleElementsWithSameName()
         }
 
         /// <summary>
-        /// empty toolset element 
+        /// empty toolset element
         /// </summary>
         [Test]
         [ExpectedException(typeof(ConfigurationErrorsException))]
@@ -422,7 +422,7 @@ public void PropertyTest_GetValueByName()
             Assertion.AssertEquals(msbuildToolsetSection.Default, "2.0");
             Assertion.AssertEquals(1, msbuildToolsetSection.Toolsets.Count);
             Assertion.AssertEquals(2, msbuildToolsetSection.Toolsets.GetElement("2.0").PropertyElements.Count);
-            Assertion.AssertEquals(@"D:\windows\Microsoft.NET\Framework\v2.0.x86ret\", 
+            Assertion.AssertEquals(@"D:\windows\Microsoft.NET\Framework\v2.0.x86ret\",
                                    msbuildToolsetSection.Toolsets.GetElement("2.0").PropertyElements.GetElement("MSBuildBinPath").Value);
             Assertion.AssertEquals(@"SomeOtherPropertyValue",
                                    msbuildToolsetSection.Toolsets.GetElement("2.0").PropertyElements.GetElement("SomeOtherPropertyName").Value);
diff --git a/src/Deprecated/Engine.UnitTests/ToolsetReader_Tests.cs b/src/Deprecated/Engine.UnitTests/ToolsetReader_Tests.cs
index ceee9e343dd..2ace0785e85 100644
--- a/src/Deprecated/Engine.UnitTests/ToolsetReader_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ToolsetReader_Tests.cs
@@ -574,7 +574,7 @@ public void BlankPropertyNameInRegistry()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -626,7 +626,7 @@ public void BlankPropertyValueInRegistry()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -680,7 +680,7 @@ public void InvalidPropertyNameInRegistry()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -750,7 +750,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString2()
 
         /// <summary>
         /// Tests that any escaped xml in config file, is treated well
-        /// Note that this comes for free with the current implementation using the 
+        /// Note that this comes for free with the current implementation using the
         /// framework api to access section in the config file
         /// </summary>
         [Test]
@@ -819,7 +819,7 @@ public void GetToolsetData_NoConflict()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.ConfigurationFile | ToolsetDefinitionLocations.Registry
                                                        );
@@ -868,7 +868,7 @@ public void ToolsetInitializationFlagsSetToNone()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.None
                                                        );
@@ -920,7 +920,7 @@ public void ToolsetInitializationFlagsSetToRegistry()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -950,7 +950,7 @@ public void ThrowOnNonStringRegistryValueTypes()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -973,7 +973,7 @@ public void PropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -1019,7 +1019,7 @@ public void ToolsetInitializationFlagsSetToConfigurationFile()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.ConfigurationFile
                                                        );
@@ -1068,7 +1068,7 @@ public void PropertyInConfigurationFileReferencesRegistryLocation()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.ConfigurationFile | ToolsetDefinitionLocations.Registry
                                                        );
@@ -1089,10 +1089,10 @@ public void ToolsPathInRegistryHasInvalidPathChars()
             currentVersionRegistryKey.SetValue("DefaultToolsVersion", "2.0");
             RegistryKey key1 = toolsVersionsRegistryKey.CreateSubKey("2.0");
             key1.SetValue("MSBuildBinPath", @"D:\some\foo|bar\path\");
-            
+
             ToolsetCollection values = new ToolsetCollection(new Engine(ToolsetDefinitionLocations.None));
 
-            // should throw... 
+            // should throw...
             string defaultToolsVersion = ToolsetReader.ReadAllToolsets
                                                        (
                                                            values,
@@ -1130,7 +1130,7 @@ public void SamePropertyDefinedMultipleTimesForSingleToolsVersionInConfiguration
                                                            values,
                                                            null,
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.ConfigurationFile
                                                        );
@@ -1162,7 +1162,7 @@ public void SamePropertyDifferentCaseDefinedMultipleTimesForSingleToolsVersionIn
                                                            values,
                                                            null,
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.ConfigurationFile
                                                        );
@@ -1243,7 +1243,7 @@ public void SameToolsVersionDifferentCaseDefinedMultipleTimesInConfigurationFile
                                                            ToolsetDefinitionLocations.ConfigurationFile
                                                        );
         }
-        
+
         [Test]
         [ExpectedException(typeof(InvalidToolsetDefinitionException))]
         public void CannotSetReservedPropertyInConfigFile()
@@ -1295,7 +1295,7 @@ public void CannotSetReservedPropertyInRegistry()
                                                            ToolsetDefinitionLocations.Registry
                                                        );
         }
-        
+
         /// <summary>
         /// Properties defined in previously processed toolset definitions should
         /// not affect the evaluation of subsequent toolset definitions.
@@ -1335,7 +1335,7 @@ public void NoInterferenceBetweenToolsetDefinitions()
                                                        );
 
             Assertion.AssertEquals(2, values.Count);
-            
+
             Assertion.AssertEquals(@"D:\20\some\folder\on\disk", values["2.0"].ToolsPath);
             Assertion.AssertEquals(2, values["2.0"].BuildProperties.Count);
             Assertion.AssertEquals(@"another", values["2.0"].BuildProperties["p1"].Value);
@@ -1463,7 +1463,7 @@ public void RegistryValidRegistryExpressionRecursive()
         {
             // Property pointing to itself - should not hang :-)
             RegistryValidRegistryExpressionHelper
-                (@"$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"\ToolsVersions\2.0@p)", 
+                (@"$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"\ToolsVersions\2.0@p)",
                  @"$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"\ToolsVersions\2.0@p)");
         }
 
@@ -1707,8 +1707,8 @@ public void GetToolsetData_RegistryNotPresent()
 
         /// <summary>
         /// Test the case where nothing is specified in the config file
-        /// Note that config file not present is same as config file 
-        /// with no MSBuildToolsets Section 
+        /// Note that config file not present is same as config file
+        /// with no MSBuildToolsets Section
         /// </summary>
         [Test]
         public void GetToolsetData_ConfigFileNotPresent()
@@ -2097,7 +2097,7 @@ public void GlobalPropertiesInToolsetsAreExpandedButAreNotOverwritten()
                        <property name=""gp1"" value=""v2""/>
                        <property name=""p2"" value=""$(gp1)""/>
                      </toolset>
-                   </msbuildToolsets> 
+                   </msbuildToolsets>
                  </configuration>");
 
             Engine e = new Engine(ToolsetDefinitionLocations.None);
@@ -2105,7 +2105,7 @@ public void GlobalPropertiesInToolsetsAreExpandedButAreNotOverwritten()
 
             BuildPropertyGroup globalProperties = e.GlobalProperties;
             globalProperties.SetProperty("gp1", "gv1");
-            
+
             BuildPropertyGroup initialProperties = new BuildPropertyGroup();
             initialProperties.ImportProperties(e.EnvironmentProperties);
             initialProperties.ImportProperties(globalProperties);
@@ -2150,7 +2150,7 @@ public enum WhereToThrow
         protected MockRegistryKey(RegistryKey wrappedKey, RegistryKey registryHive)
             : base(wrappedKey, registryHive)
         { }
-        
+
         /// <summary>
         /// Construct the mock key with a wrapper
         /// </summary>
diff --git a/src/Deprecated/Engine.UnitTests/ToolsetRegistryReader_Tests.cs b/src/Deprecated/Engine.UnitTests/ToolsetRegistryReader_Tests.cs
index a15965d4f01..846fa1e8929 100644
--- a/src/Deprecated/Engine.UnitTests/ToolsetRegistryReader_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ToolsetRegistryReader_Tests.cs
@@ -69,7 +69,7 @@ private void DeleteTestRegistryKey()
         public void ReadRegistry_DeletedKey()
         {
             DeleteTestRegistryKey();
-            
+
             ToolsetReader reader = new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath));
             ToolsetCollection values = new ToolsetCollection(new Engine(ToolsetDefinitionLocations.None));
 
@@ -174,7 +174,7 @@ public void ReadRegistry_OnlyOneSubkey()
         public void ReadRegistry_Basic()
         {
             RegistryKey key1 = toolsVersionsRegistryKey.CreateSubKey("tv1");
-            key1.SetValue("msbuildtoolspath", "c:\\xxx");            
+            key1.SetValue("msbuildtoolspath", "c:\\xxx");
             key1.SetValue("name1", "value1");
             RegistryKey key2 = toolsVersionsRegistryKey.CreateSubKey("tv2");
             key2.SetValue("name2", "value2");
@@ -248,7 +248,7 @@ public void ReadRegistry_IgnoreSubKeysExceptTopMostSubKeys()
             Assertion.Assert(0 == String.Compare("c:\\yyy", values["tv2"].ToolsPath, StringComparison.OrdinalIgnoreCase));
             Assertion.Assert(0 == String.Compare("value2", values["tv2"].BuildProperties["name2"].Value, StringComparison.OrdinalIgnoreCase));
         }
-        
+
         /// <summary>
         /// Regular case of getting default tools version
         /// </summary>
diff --git a/src/Deprecated/Engine.UnitTests/Utilities_Tests.cs b/src/Deprecated/Engine.UnitTests/Utilities_Tests.cs
index 7d3d8fdcccd..89e9a47c74a 100644
--- a/src/Deprecated/Engine.UnitTests/Utilities_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Utilities_Tests.cs
@@ -27,11 +27,11 @@ public class UtilitiesTest
 
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     '$(Configuration)' == 'Debug'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -50,11 +50,11 @@ public void GatherReferencedPropertyNames1 ()
 
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     'Debug' != '$(Configuration)'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -70,14 +70,14 @@ public void GatherReferencedPropertyNames2 ()
             Assertion.AssertEquals(1, configurations.Count);
             Assertion.AssertEquals("Debug", configurations[0]);
         }
-        
+
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     '$(Configuration)|$(Platform)' != 'Debug|x86'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -96,14 +96,14 @@ public void GatherReferencedPropertyNames3 ()
             Assertion.AssertEquals("Debug", configurations[0]);
             Assertion.AssertEquals("x86", platforms[0]);
         }
-    
+
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     'Debug|x86' == '$(Configuration)|$(Platform)'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -125,11 +125,11 @@ public void GatherReferencedPropertyNames4 ()
 
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     '$(Configuration)|$(Platform)|$(Machine)' == 'Debug|x86|RGOEL3'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -154,11 +154,11 @@ public void GatherReferencedPropertyNames5 ()
 
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     '$(Configuration)|$(Platform)|$(Machine)' == 'Debug'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -179,11 +179,11 @@ public void GatherReferencedPropertyNames6 ()
 
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     '$(Configuration)' == 'Debug|x86|RGOEL3'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -228,7 +228,7 @@ public void IllegalConditionOnProjectExtensions()
         public void RepeatedProjectExtensions()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`> 
+                <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                     <ProjectExtensions/>
                     <Import Project=`$(MSBuildBinPath)\\Microsoft.CSharp.Targets` />
                     <ProjectExtensions/>
diff --git a/src/Deprecated/Engine.UnitTests/XmlSearcher_Tests.cs b/src/Deprecated/Engine.UnitTests/XmlSearcher_Tests.cs
index 88cf72e8dd1..91a3ddf7adc 100644
--- a/src/Deprecated/Engine.UnitTests/XmlSearcher_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/XmlSearcher_Tests.cs
@@ -146,7 +146,7 @@ public void GetLineColumnOfXmlNode()
             // Correct answer is:
             //      Line Number 9
             //      Column Number 5
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 7, 0, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(9, foundLineNumber);
             Assertion.AssertEquals(5, foundColumnNumber);
@@ -157,7 +157,7 @@ public void GetLineColumnOfXmlNode()
             //      Line Number 6
             //      Column Number 19
             // This is because the text node actually begins immediately after the closing ">" in "<WarningLevel>".
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 6, 0, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(6, foundLineNumber);
             Assertion.AssertEquals(19, foundColumnNumber);
@@ -167,7 +167,7 @@ public void GetLineColumnOfXmlNode()
             // Correct answer is:
             //      Line Number 4
             //      Column Number 18
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 2, 2, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(4, foundLineNumber);
             Assertion.AssertEquals(18, foundColumnNumber);
@@ -177,19 +177,19 @@ public void GetLineColumnOfXmlNode()
             // Correct answer is:
             //      Line Number 9
             //      Column Number 17
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 8, 0, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(9, foundLineNumber);
             Assertion.AssertEquals(17, foundColumnNumber);
 
             // Let's try passing in a bogus element number.
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 25, 0, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(0, foundLineNumber);
             Assertion.AssertEquals(0, foundColumnNumber);
 
             // And let's try passing in a bogus attribute number.
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 7, 4, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(0, foundLineNumber);
             Assertion.AssertEquals(0, foundColumnNumber);
@@ -197,7 +197,7 @@ public void GetLineColumnOfXmlNode()
 
         /// <summary>
         /// Given a string representing the contents of the project file, create a project file
-        /// on disk with those contents.  Then call the method to find the line/column number of 
+        /// on disk with those contents.  Then call the method to find the line/column number of
         /// a particular node in the project file, based on the element/attribute number of that node.
         /// </summary>
         /// <param name="projectFileContents"></param>
@@ -214,8 +214,8 @@ out int foundColumnNumber
         {
             string projectFile = ObjectModelHelpers.CreateTempFileOnDisk(projectFileContents);
 
-            XmlSearcher.GetLineColumnByNodeNumber(projectFile, 
-                xmlElementNumberToSearchFor, xmlAttributeNumberToSearchFor, 
+            XmlSearcher.GetLineColumnByNodeNumber(projectFile,
+                xmlElementNumberToSearchFor, xmlAttributeNumberToSearchFor,
                 out foundLineNumber, out foundColumnNumber);
 
             // Delete the temp file.
diff --git a/src/Deprecated/Engine.UnitTests/enginehelpers.cs b/src/Deprecated/Engine.UnitTests/enginehelpers.cs
index f2da5eaf5c5..b0ffab3708f 100644
--- a/src/Deprecated/Engine.UnitTests/enginehelpers.cs
+++ b/src/Deprecated/Engine.UnitTests/enginehelpers.cs
@@ -17,7 +17,7 @@
 using System.Text.RegularExpressions;
 using System.Collections.Generic;
 
-    
+
 namespace Microsoft.Build.UnitTests
 {
     /*
@@ -27,7 +27,7 @@ namespace Microsoft.Build.UnitTests
      * Utility methods for unit tests that work through the object model.
      *
      */
-    sealed public class EngineHelpers        
+    sealed public class EngineHelpers
     {
         internal static string EnsureNoLeadingSlash(string path)
         {
@@ -62,26 +62,26 @@ internal static bool IsSlash(char c)
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
         /// <owner>RGoel</owner>
         static internal void AssertItemsMatch
             (
-            string expectedItemsString, 
+            string expectedItemsString,
             BuildItem[] actualItems
             )
         {
@@ -89,27 +89,27 @@ BuildItem[] actualItems
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
         /// <owner>RGoel</owner>
         static internal void AssertItemsMatch
             (
-            string expectedItemsString, 
-            BuildItem[] actualItems, 
+            string expectedItemsString,
+            BuildItem[] actualItems,
             bool orderOfItemsShouldMatch
             )
         {
@@ -125,26 +125,26 @@ bool orderOfItemsShouldMatch
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
         /// <owner>RGoel</owner>
         static internal void AssertItemsMatch
             (
-            string expectedItemsString, 
+            string expectedItemsString,
             BuildItemGroup actualItems
             )
         {
@@ -152,27 +152,27 @@ BuildItemGroup actualItems
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
         /// <owner>RGoel</owner>
         static internal void AssertItemsMatch
             (
-            string expectedItemsString, 
-            BuildItemGroup actualItems, 
+            string expectedItemsString,
+            BuildItemGroup actualItems,
             bool orderOfItemsShouldMatch
             )
         {
diff --git a/src/Deprecated/Engine.UnitTests/projectschemavalidationhandler_tests.cs b/src/Deprecated/Engine.UnitTests/projectschemavalidationhandler_tests.cs
index 3a64926a5c5..38f8fe15228 100644
--- a/src/Deprecated/Engine.UnitTests/projectschemavalidationhandler_tests.cs
+++ b/src/Deprecated/Engine.UnitTests/projectschemavalidationhandler_tests.cs
@@ -21,13 +21,13 @@ namespace Microsoft.Build.UnitTests
     public class ProjectSchemaValidationHandlerTest
     {
         /***********************************************************************
-         * 
+         *
          * Test:        ProjectSchemaValidationHandlerTest.VerifyProjectSchema
          * Owner:       JomoF
-         *  
+         *
          * This calls VerifyProjectSchema to validate a project XML
          * specified in a string
-         * 
+         *
          **********************************************************************/
         [Test]
         [ExpectedException(typeof(InvalidProjectFileException))]
@@ -53,7 +53,7 @@ public void VerifyInvalidProjectSchema
 
                 try
                 {
-                    validator.VerifyProjectSchema(ObjectModelHelpers.CleanupFileContents(projectContents), 
+                    validator.VerifyProjectSchema(ObjectModelHelpers.CleanupFileContents(projectContents),
                         msbuildTempXsdFilenames[0]);
                 }
                 catch (InvalidProjectFileException e)
@@ -82,7 +82,7 @@ public void VerifyInvalidSchemaItself1
                 invalidSchemaFile = Path.GetTempFileName();
 
                 File.WriteAllText(invalidSchemaFile, "<this_is_invalid_schema_content/>");
-                
+
                 string projectContents = @"
                     <Project xmlns=`msbuildnamespace`>
                         <Target Name=`Build` />
@@ -163,13 +163,13 @@ public void VerifyInvalidSchemaItself2
         }
 
         /***********************************************************************
-         * 
+         *
          * Test:        ProjectSchemaValidationHandlerTest.VerifyProjectSchema
          * Owner:       JomoF
-         *  
+         *
          * This calls VerifyProjectSchema to validate a project XML
          * specified in a string
-         * 
+         *
          **********************************************************************/
         [Test]
         public void VerifyValidProjectSchema
@@ -191,7 +191,7 @@ public void VerifyValidProjectSchema
                 Engine e = new Engine(@"c:\");
                 ProjectSchemaValidationHandler validator = new ProjectSchemaValidationHandler(null, e.LoggingServices, @"c:\");
 
-                validator.VerifyProjectSchema(ObjectModelHelpers.CleanupFileContents(projectContents), 
+                validator.VerifyProjectSchema(ObjectModelHelpers.CleanupFileContents(projectContents),
                     msbuildTempXsdFilenames[0]);
             }
             finally
diff --git a/src/Deprecated/Engine/Choose/Choose.cs b/src/Deprecated/Engine/Choose/Choose.cs
index 0ca947a0486..4440f2adc84 100644
--- a/src/Deprecated/Engine/Choose/Choose.cs
+++ b/src/Deprecated/Engine/Choose/Choose.cs
@@ -81,7 +81,7 @@ int nestingDepth
             ProjectXmlUtilities.VerifyThrowElementName(chooseElement, XMakeElements.choose);
 
             // Stack overflow guard. The only way in the MSBuild file format that MSBuild elements can be
-            // legitimately nested without limit is the <Choose> construct. So, enforce a nesting limit 
+            // legitimately nested without limit is the <Choose> construct. So, enforce a nesting limit
             // to avoid blowing our stack.
             nestingDepth++;
             ProjectErrorUtilities.VerifyThrowInvalidProject(nestingDepth <= maximumChooseNesting, chooseElement, "ChooseOverflow", maximumChooseNesting);
diff --git a/src/Deprecated/Engine/Choose/GroupingCollection.cs b/src/Deprecated/Engine/Choose/GroupingCollection.cs
index 16c60f1e1af..68b63ff1db0 100644
--- a/src/Deprecated/Engine/Choose/GroupingCollection.cs
+++ b/src/Deprecated/Engine/Choose/GroupingCollection.cs
@@ -102,7 +102,7 @@ internal bool IsSynchronized
             }
         }
         /// <summary>
-        /// This ICollection method copies the contents of this collection to an 
+        /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <remarks>
@@ -171,7 +171,7 @@ internal int ItemGroupCount
         }
 
         /// <summary>
-        /// This ICollection method copies the contents of this collection to an 
+        /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <remarks>
diff --git a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
index b3cf778c04d..1913af98416 100644
--- a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
+++ b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
@@ -116,7 +116,7 @@ private void ConstructFrom(CopyOnWriteHashtable that)
             {
                 this.writeableData = null;
 
-                // If the source it was writeable, need to transform it into 
+                // If the source it was writeable, need to transform it into
                 // read-only because we don't want subsequent writes to bleed through.
                 if (that.writeableData != null)
                 {
diff --git a/src/Deprecated/Engine/Collections/DualQueue.cs b/src/Deprecated/Engine/Collections/DualQueue.cs
index 4136db8a3e9..c5f80e33746 100644
--- a/src/Deprecated/Engine/Collections/DualQueue.cs
+++ b/src/Deprecated/Engine/Collections/DualQueue.cs
@@ -276,7 +276,7 @@ private Queue<T> GetReadingQueue()
         /// <returns></returns>
         internal bool Contains(T item)
         {
-            // The dual queue in general contains an item if the item exists 
+            // The dual queue in general contains an item if the item exists
             // in one or even both of the backing queues
             return backingQueueA.Contains(item) || backingQueueB.Contains(item);
         }
@@ -316,7 +316,7 @@ internal bool Contains(T item)
         private Queue<T> backingQueueB;
 
         /// <summary>
-        /// Count of the current writer queue - we only own the reader queue in Count so we have to keep 
+        /// Count of the current writer queue - we only own the reader queue in Count so we have to keep
         /// the count for the writer queue separately.
         /// </summary>
         private int writingQueueCount;
diff --git a/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs b/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs
index 4355f02bb7b..df9a96b548c 100644
--- a/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs
+++ b/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs
@@ -11,7 +11,7 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
-    /// All the state necessary for the evaluation of conditionals so that the expression tree 
+    /// All the state necessary for the evaluation of conditionals so that the expression tree
     /// is stateless and reusable
     /// </summary>
     internal struct ConditionEvaluationState
diff --git a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
index bde7889d466..66cc6c8674e 100644
--- a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
@@ -57,8 +57,8 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
 
                         // Ignore invalid characters or path related exceptions
 
-                        // We will ignore the PathTooLong exception caused by GetFullPath becasue in single proc this code 
-                        // is not executed and the condition is just evaluated to false as File.Exists and Directory.Exists does not throw in this situation. 
+                        // We will ignore the PathTooLong exception caused by GetFullPath becasue in single proc this code
+                        // is not executed and the condition is just evaluated to false as File.Exists and Directory.Exists does not throw in this situation.
                         // To be consistant with that we will return a false in this case also.
                         // DevDiv Bugs: 46035
 
diff --git a/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs b/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
index f1bfdaf7f4d..2fcb5fc2cc8 100644
--- a/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
@@ -32,7 +32,7 @@ internal abstract class GenericExpressionNode
         internal abstract string GetUnexpandedValue(ConditionEvaluationState state);
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal abstract void ResetState();
@@ -70,7 +70,7 @@ internal virtual bool PossibleOrCollision
         internal bool PotentialAndOrConflict()
         {
             // The values of the functions are assigned to boolean locals
-            // in order to force evaluation of the functions even when the 
+            // in order to force evaluation of the functions even when the
             // first one returns false
             bool detectOr = DetectOr();
             bool detectAnd = DetectAnd();
diff --git a/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs b/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs
index 53ae427394c..8d1c921e271 100644
--- a/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs
@@ -68,7 +68,7 @@ internal override string GetExpandedValue(ConditionEvaluationState state)
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
index c090f79f569..90daa06c3a6 100644
--- a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
@@ -65,7 +65,7 @@ internal override string GetUnexpandedValue(ConditionEvaluationState state)
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Deprecated/Engine/Conditionals/Parser.cs b/src/Deprecated/Engine/Conditionals/Parser.cs
index a6759139298..48cb79aa33b 100644
--- a/src/Deprecated/Engine/Conditionals/Parser.cs
+++ b/src/Deprecated/Engine/Conditionals/Parser.cs
@@ -48,7 +48,7 @@ internal sealed class Parser
 
         private BuildEventContext logBuildEventContext;
         /// <summary>
-        ///  Location contextual information which are attached to logging events to 
+        ///  Location contextual information which are attached to logging events to
         ///  say where they are in relation to the process, engine, project, target,task which is executing
         /// </summary>
         internal BuildEventContext LogBuildEventContext
diff --git a/src/Deprecated/Engine/Conditionals/Scanner.cs b/src/Deprecated/Engine/Conditionals/Scanner.cs
index ae786ef938b..58a1ad65a64 100644
--- a/src/Deprecated/Engine/Conditionals/Scanner.cs
+++ b/src/Deprecated/Engine/Conditionals/Scanner.cs
@@ -21,7 +21,7 @@ namespace Microsoft.Build.BuildEngine
     ///    do {
     ///      s.Advance();
     ///    while (s.IsNext(Token.EndOfInput));
-    /// 
+    ///
     ///  After Advance() is called, you can get the current token (s.CurrentToken),
     ///  check it's type (s.IsNext()), get the string for it (s.NextString()).
     /// </summary>
@@ -37,7 +37,7 @@ internal sealed class Scanner
         private ParserOptions options;
         private string errorResource = null;
 
-        // Shared instances of "hardcoded" token strings. These are only used 
+        // Shared instances of "hardcoded" token strings. These are only used
         // in error messages.
         private const string comma = ",";
         private const string leftParenthesis = "(";
@@ -129,7 +129,7 @@ internal int GetErrorPosition()
             return errorPosition;
         }
 
-        // The string (usually a single character) we found unexpectedly. 
+        // The string (usually a single character) we found unexpectedly.
         // We might want to show it in the error message, to help the user spot the error.
         internal string UnexpectedlyFound
         {
@@ -310,7 +310,7 @@ internal bool Advance()
         }
 
         /// <summary>
-        /// Parses either the $(propertyname) syntax or the %(metadataname) syntax, 
+        /// Parses either the $(propertyname) syntax or the %(metadataname) syntax,
         /// and returns the parsed string beginning with the '$' or '%', and ending with the
         /// closing parenthesis.
         /// </summary>
diff --git a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
index 6c4005ca9c9..1b50b71ac2e 100644
--- a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
@@ -73,7 +73,7 @@ internal override string GetExpandedValue(ConditionEvaluationState state)
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Deprecated/Engine/Conditionals/Token.cs b/src/Deprecated/Engine/Conditionals/Token.cs
index d9fcca9d366..88fe9857196 100644
--- a/src/Deprecated/Engine/Conditionals/Token.cs
+++ b/src/Deprecated/Engine/Conditionals/Token.cs
@@ -44,7 +44,7 @@ internal Token(TokenType type, string tokenString)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="type"></param>
         /// <returns></returns>
diff --git a/src/Deprecated/Engine/Engine/BatchingEngine.cs b/src/Deprecated/Engine/Engine/BatchingEngine.cs
index 3b7b78a6015..04aa8cc8791 100644
--- a/src/Deprecated/Engine/Engine/BatchingEngine.cs
+++ b/src/Deprecated/Engine/Engine/BatchingEngine.cs
@@ -20,26 +20,26 @@ namespace Microsoft.Build.BuildEngine
     /// </summary>
     /// <remarks>
     /// What batching does
-    /// 
-    /// Batching partitions the items consumed by the batchable object into buckets, where each bucket 
-    /// contains a set of items that have the same value set on all item metadata consumed by the object. 
-    /// Metadata consumed may be unqualified, for example %(m), or qualified by the item list to which it 
+    ///
+    /// Batching partitions the items consumed by the batchable object into buckets, where each bucket
+    /// contains a set of items that have the same value set on all item metadata consumed by the object.
+    /// Metadata consumed may be unqualified, for example %(m), or qualified by the item list to which it
     /// refers, for example %(a.m).
-    /// 
-    /// If metadata is qualified, for example %(a.m), then this is considered distinct to metadata with the 
-    /// same name on a different item type. For example, %(a.m) is distinct to %(b.m), and items of type b 
-    /// are considered to always have a blank value for %(a.m). This means items of type b will only be 
+    ///
+    /// If metadata is qualified, for example %(a.m), then this is considered distinct to metadata with the
+    /// same name on a different item type. For example, %(a.m) is distinct to %(b.m), and items of type b
+    /// are considered to always have a blank value for %(a.m). This means items of type b will only be
     /// placed in buckets where %(a.m) is blank. However %(a.m) is equivalent to %(m) on items of type a.
-    /// 
-    /// There is an extra ambiguity rule: every items consumed by the object must have an explicit value for 
-    /// every piece of unqualified metadata. For example, if @(a), %(m), and %(a.n) are consumed, every item 
-    /// of type a must have a value for the metadata m but need not all necessarily have a value for the 
-    /// metadata n. This rule eliminates ambiguity about whether items that do not define values for an 
-    /// unqualified metadata should go in all buckets, or just into buckets with a blank value for 
+    ///
+    /// There is an extra ambiguity rule: every items consumed by the object must have an explicit value for
+    /// every piece of unqualified metadata. For example, if @(a), %(m), and %(a.n) are consumed, every item
+    /// of type a must have a value for the metadata m but need not all necessarily have a value for the
+    /// metadata n. This rule eliminates ambiguity about whether items that do not define values for an
+    /// unqualified metadata should go in all buckets, or just into buckets with a blank value for
     /// that metadata.
-    /// 
-    /// For example 
-    /// 
+    ///
+    /// For example
+    ///
     /// <ItemGroup>
     /// <a Include='a1;a2'>
     ///   <n>m0</n>
@@ -55,19 +55,19 @@ namespace Microsoft.Build.BuildEngine
     /// </b>
     /// <b Include='b4'/>
     /// </ItemGroup>
-    /// 
+    ///
     /// <Target Name="t" >
     ///   <Message Text="a={@(a).%(a.n)} b={@(b).%(b.n)}" />
     /// </Target>
-    /// 
-    /// Will produce 5 buckets: 
-    /// 
+    ///
+    /// Will produce 5 buckets:
+    ///
     /// a={a1;a2.m0} b={.}
     /// a={a3.m1} b={.}
     /// a={.} b={b1.n0}
     /// a={.} b={b2;b3.n1}
     /// a={.} b={b4.}
-    /// 
+    ///
     /// </remarks>
     internal static class BatchingEngine
     {
@@ -113,14 +113,14 @@ string implicitBatchableItemType
             ItemsAndMetadataPair pair = ExpressionShredder.GetReferencedItemNamesAndMetadata(batchableObjectParameters);
 
             // All the @(itemname) item list references in the tag, including transforms, etc.
-            // The keys in the hashtable are the item names, and the values are all String.Empty (not used).            
+            // The keys in the hashtable are the item names, and the values are all String.Empty (not used).
             Hashtable consumedItemReferences = pair.Items;
 
-            // All the %(itemname.metadataname) references in the tag (not counting those embedded 
+            // All the %(itemname.metadataname) references in the tag (not counting those embedded
             // inside item transforms), and note that the itemname portion is optional.
             // The keys in the returned hash table are the qualified metadata names (e.g. "EmbeddedResource.Culture"
-            // or just "Culture").  The values are MetadataReference structs, which simply split out the item 
-            // name (possibly null) and the actual metadata name.            
+            // or just "Culture").  The values are MetadataReference structs, which simply split out the item
+            // name (possibly null) and the actual metadata name.
             Dictionary<string, MetadataReference> consumedMetadataReferences = pair.Metadata;
 
             ArrayList buckets = null;
@@ -136,14 +136,14 @@ string implicitBatchableItemType
                 // This method goes through all the item list references and figures out which ones
                 // will be participating in batching, and which ones won't.  We get back a hashtable
                 // where the key is the item name that will be participating in batching.  The values
-                // are all String.Empty (not used).  This method may return additional item names 
+                // are all String.Empty (not used).  This method may return additional item names
                 // that weren't represented in "consumedItemReferences"... this would happen if there
-                // were qualified metadata references in the consumedMetadataReferences table, such as 
+                // were qualified metadata references in the consumedMetadataReferences table, such as
                 // %(EmbeddedResource.Culture).
                 Hashtable itemListsToBeBatched = GetItemListsToBeBatched(parentNode, consumedMetadataReferences, consumedItemReferences, lookup);
 
-                // At this point, if there were any metadata references in the tag, but no item 
-                // references to batch on, we've got a problem because we can't figure out which 
+                // At this point, if there were any metadata references in the tag, but no item
+                // references to batch on, we've got a problem because we can't figure out which
                 // item lists the user wants us to batch.
                 if (itemListsToBeBatched.Count == 0)
                 {
@@ -179,16 +179,16 @@ string implicitBatchableItemType
 
         /// <summary>
         /// Of all the item lists that are referenced in this batchable object, which ones should we
-        /// batch on, and which ones should we just pass in wholesale to every invocation of the 
+        /// batch on, and which ones should we just pass in wholesale to every invocation of the
         /// target/task?
-        /// 
+        ///
         /// Rule #1.  If the user has referenced any *qualified* item metadata such as %(EmbeddedResource.Culture),
         /// then that item list "EmbeddedResource" will definitely get batched.
-        /// 
-        /// Rule #2.  For all the unqualified item metadata such as %(Culture), we make sure that 
+        ///
+        /// Rule #2.  For all the unqualified item metadata such as %(Culture), we make sure that
         /// every single item in every single item list being passed into the task contains a value
         /// for that metadata.  If not, it's an error.  If so, we batch all of those item lists.
-        /// 
+        ///
         /// All other item lists will not be batched, and instead will be passed in wholesale to all buckets.
         /// </summary>
         /// <returns>Hashtable containing the item names that should be batched.</returns>
@@ -213,11 +213,11 @@ Lookup lookup
                 if (consumedMetadataReference.itemName != null)
                 {
                     // Rule #1.  Qualified metadata reference.
-                    // For metadata references that are qualified with an item name 
-                    // (e.g., %(EmbeddedResource.Culture) ), we add that item name to the list of 
+                    // For metadata references that are qualified with an item name
+                    // (e.g., %(EmbeddedResource.Culture) ), we add that item name to the list of
                     // consumed item names, even if the item name wasn't otherwise referenced via
                     // @(...) syntax, and even if every item in the list doesn't necessary contain
-                    // a value for this metadata.  This is the special power that you get by qualifying 
+                    // a value for this metadata.  This is the special power that you get by qualifying
                     // the metadata reference with an item name.
                     itemListsToBeBatched[consumedMetadataReference.itemName] = String.Empty;
 
@@ -225,7 +225,7 @@ Lookup lookup
                     // %(EmbeddedResource.Culture) effectively means that @(EmbeddedResource) is
                     // being consumed, even though we may not see literally "@(EmbeddedResource)"
                     // in the tag anywhere.  Adding it to this list allows us (down below in this
-                    // method) to check that every item in this list has a value for each 
+                    // method) to check that every item in this list has a value for each
                     // unqualified metadata reference.
                     consumedItemReferenceNames = Utilities.CreateTableIfNecessary(consumedItemReferenceNames);
                     consumedItemReferenceNames[consumedMetadataReference.itemName] = String.Empty;
@@ -370,7 +370,7 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
         /// <summary>
         /// Gets the values of the specified metadata for the given item.
         /// The keys in the dictionary returned may be qualified and/or unqualified, exactly
-        /// as they are found in the metadata reference. 
+        /// as they are found in the metadata reference.
         /// For example if %(x) is found, the key is "x", if %(z.x) is found, the key is "z.x".
         /// This dictionary in each bucket is used by Expander to expand exactly the same metadata references, so
         /// %(x) is expanded using the key "x", and %(z.x) is expanded using the key "z.x".
diff --git a/src/Deprecated/Engine/Engine/BuildRequest.cs b/src/Deprecated/Engine/Engine/BuildRequest.cs
index 1e4f2694f47..08612a49045 100644
--- a/src/Deprecated/Engine/Engine/BuildRequest.cs
+++ b/src/Deprecated/Engine/Engine/BuildRequest.cs
@@ -579,7 +579,7 @@ internal BuildResult GetBuildResult()
         }
 
         /// <summary>
-        /// Provides unique identifers for the caching system so we can retrieve this set of targets 
+        /// Provides unique identifers for the caching system so we can retrieve this set of targets
         /// at a later time. This list should be either a null array or a list of strings which are not null.
         /// </summary>
         /// <returns></returns>
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index 35a9bf9fcf2..876aea82f2e 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -24,7 +24,7 @@ public class BuildTask
     {
         #region Member Data
 
-        // The task XML element, if this is a persisted target.  
+        // The task XML element, if this is a persisted target.
         private XmlElement taskElement = null;
 
         // This is the "Condition" attribute on the task element.
@@ -93,14 +93,14 @@ bool importedFromAnotherProject
                         this.continueOnErrorAttribute = taskAttribute;
                         break;
 
-                    // this only makes sense in the context of the new OM, 
-                    // so just ignore it.  
+                    // this only makes sense in the context of the new OM,
+                    // so just ignore it.
                     case XMakeAttributes.msbuildRuntime:
                         // do nothing
                         break;
 
-                    // this only makes sense in the context of the new OM, 
-                    // so just ignore it.  
+                    // this only makes sense in the context of the new OM,
+                    // so just ignore it.
                     case XMakeAttributes.msbuildArchitecture:
                         // do nothing
                         break;
@@ -152,7 +152,7 @@ public string Condition
 
             set
             {
-                // If this Task object is not actually represented by a 
+                // If this Task object is not actually represented by a
                 // task element in the project file, then do not allow
                 // the caller to set the condition.
                 error.VerifyThrowInvalidOperation(this.taskElement != null,
@@ -196,7 +196,7 @@ public bool ContinueOnError
 
             set
             {
-                // If this Task object is not actually represented by a 
+                // If this Task object is not actually represented by a
                 // task element in the project file, then do not allow
                 // the caller to set the attribute.
                 error.VerifyThrowInvalidOperation(this.taskElement != null,
diff --git a/src/Deprecated/Engine/Engine/CacheManager.cs b/src/Deprecated/Engine/Engine/CacheManager.cs
index 5dab13cb787..0d9d9c19f37 100644
--- a/src/Deprecated/Engine/Engine/CacheManager.cs
+++ b/src/Deprecated/Engine/Engine/CacheManager.cs
@@ -28,8 +28,8 @@ internal enum CacheContentType
     }
 
     /// <summary>
-    /// This class is responsible for maintaining the set of object 
-    /// cached during a build session. This class is not thread safe and 
+    /// This class is responsible for maintaining the set of object
+    /// cached during a build session. This class is not thread safe and
     /// is intended to be used from the Engine thread.
     /// </summary>
     internal class CacheManager
diff --git a/src/Deprecated/Engine/Engine/CacheScope.cs b/src/Deprecated/Engine/Engine/CacheScope.cs
index 99891eac6e5..5ddeae99288 100644
--- a/src/Deprecated/Engine/Engine/CacheScope.cs
+++ b/src/Deprecated/Engine/Engine/CacheScope.cs
@@ -20,9 +20,9 @@ namespace Microsoft.Build.BuildEngine
     /// threads. It is also lock free for multiple readers (via use of Hashtable as
     /// the backing store).
     /// We use a ReaderWriterLock in here so that when a request comes in for multiple
-    /// cache entries we guarantee that all the entries come from a consistent view of 
+    /// cache entries we guarantee that all the entries come from a consistent view of
     /// the cache at some point in time. Without a lock we might get a write in between
-    /// the reads and half of the entries would represent the values before the write and 
+    /// the reads and half of the entries would represent the values before the write and
     /// the rest after. This is unacceptable as at no point in time the cache actually contained
     /// the entries that would be returned without the lock. This is required by the caching APIs
     /// provided to the tasks which support retrieving multiple entries at once.
@@ -36,7 +36,7 @@ internal class CacheScope
         /// </summary>
         internal CacheScope(string scopeName, BuildPropertyGroup scopeProperties, string scopeToolsVersion)
         {
-            // Make certain we don't cache a reference to a Project object, which would defeat 
+            // Make certain we don't cache a reference to a Project object, which would defeat
             // the purpose of this cache
             scopeProperties.ClearParentProject();
 
@@ -215,7 +215,7 @@ internal void ClearCacheEntry(string name)
         }
 
         /// <summary>
-        /// This method returns true if the cache entry for a given name is present in the cache. 
+        /// This method returns true if the cache entry for a given name is present in the cache.
         /// This method is thread safe.
         /// </summary>
         internal bool ContainsCacheEntry(string name)
@@ -231,7 +231,7 @@ internal void AddCacheEntryForBuildResults(BuildResult buildResult)
         {
             ErrorUtilities.VerifyThrow(buildResult != null, "Expect a non-null build result");
 
-            // Don't cache results if they are marked as uncacheable 
+            // Don't cache results if they are marked as uncacheable
             if (!buildResult.UseResultCache)
             {
                 return;
diff --git a/src/Deprecated/Engine/Engine/EngineCallback.cs b/src/Deprecated/Engine/Engine/EngineCallback.cs
index c296b99e327..a8bdfe7a632 100644
--- a/src/Deprecated/Engine/Engine/EngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/EngineCallback.cs
@@ -45,7 +45,7 @@ public void PostBuildRequestsToHost(BuildRequest[] buildRequests)
             if (buildRequests.Length > 0)
             {
                 // We can safely assume that all requests need to be routed to the same engine because
-                // they originated from the same task 
+                // they originated from the same task
                 for (int i = 0; i < buildRequests.Length; i++)
                 {
                     ProcessBuildRequest(buildRequests[i]);
@@ -133,7 +133,7 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
                     {
                         ErrorUtilities.VerifyThrow(parentProject != null, "Parent project must be non-null");
 
-                        // This means the caller (the MSBuild task) wants us to use the same project as the calling 
+                        // This means the caller (the MSBuild task) wants us to use the same project as the calling
                         // project.  This allows people to avoid passing in the Projects parameter on the MSBuild task.
                         Project projectToBuild = parentProject;
 
@@ -216,7 +216,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
                 Console.WriteLine("Received result for HandleId " + buildResult.HandleId + ":" + buildResult.RequestId + " mapped to " + routingContext.ParentHandleId + ":" + routingContext.ParentRequestId);
             }
 
-            // Update the results with the original handle id and request id, so that 
+            // Update the results with the original handle id and request id, so that
             buildResult.HandleId = routingContext.ParentHandleId;
 
             // If the build result is created from a generated build request a done notice should be posted as other targets could be waiting for this target to finish
@@ -262,7 +262,7 @@ public void SetCacheEntries
             {
                 // Property values are compared using case sensitive comparisons because the case of property values do have meaning.
                 // In this case we are using properties in a manner where we do not want case sensitive comparisons.
-                // There is not enough benefit for this one special case to add case insensitive 
+                // There is not enough benefit for this one special case to add case insensitive
                 // comparisons to build properties. We instead uppercase all of the keys for both get and set CachedEntries.
                 scopeProperties = new BuildPropertyGroup();
                 scopeProperties.SetProperty("CacheKey", cacheKey.ToUpper(CultureInfo.InvariantCulture));
@@ -315,7 +315,7 @@ public CacheEntry[] GetCacheEntries
             {
                 // Property values are compared using case sensitive comparisons because the case of property values do have meaning.
                 // In this case we are using properties in a manner where we do not want case sensitive comparisons.
-                // There is not enough benefit for this one special case to add case insensitive 
+                // There is not enough benefit for this one special case to add case insensitive
                 // comparisons to build properties. We instead uppercase all of the keys for both get and set CachedEntries.
                 scopeProperties = new BuildPropertyGroup();
                 scopeProperties.SetProperty("CacheKey", cacheKey.ToUpper(CultureInfo.InvariantCulture));
@@ -364,7 +364,7 @@ public CacheEntry[] GetCacheEntries
         public void PostLoggingMessagesToHost(int nodeId, NodeLoggingEvent[] nodeLoggingEventArray)
         {
             // We can safely assume that all messages need to be routed to the same engine because
-            // they originated from the same task. This is true as long as we don't allow multiple engines within 
+            // they originated from the same task. This is true as long as we don't allow multiple engines within
             // a single process to utilize external nodes.
             if (nodeLoggingEventArray.Length > 0)
             {
diff --git a/src/Deprecated/Engine/Engine/EngineCommand.cs b/src/Deprecated/Engine/Engine/EngineCommand.cs
index 5dd38dd9f98..f07861b2d3d 100644
--- a/src/Deprecated/Engine/Engine/EngineCommand.cs
+++ b/src/Deprecated/Engine/Engine/EngineCommand.cs
@@ -102,9 +102,9 @@ internal override void Execute(Engine parentEngine)
     internal class ChangeTraversalTypeCommand : EngineCommand
     {
         /// <summary>
-        /// Create a command that will switch the traversal of the system to breadthFirst traversal or depth first traveral. 
-        /// changeLocalTraversalOnly is used to determine whether or not to change the traversal for the whole system or only the current node. 
-        /// changeLocalTraversalOnly is set to true in the when a node is first started and in the updateNodeSettings method as these traversal changes are for the local node only. The reason 
+        /// Create a command that will switch the traversal of the system to breadthFirst traversal or depth first traveral.
+        /// changeLocalTraversalOnly is used to determine whether or not to change the traversal for the whole system or only the current node.
+        /// changeLocalTraversalOnly is set to true in the when a node is first started and in the updateNodeSettings method as these traversal changes are for the local node only. The reason
         /// is because updateNodeSettings is called when the parent has told the node to switch traversal types, there is no need to forward the change to the engine again.
         /// Also, when a node starts up it is set to breadth first traversal, this is the default so the parent engine need not be notified of this change.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
index c07525b9d17..018b94a2ae6 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
-    /// This abstract class defines a logging service, provided by the engine, for internal logging 
+    /// This abstract class defines a logging service, provided by the engine, for internal logging
     /// purposes. This class is very different from the IBuildEngine interface which provides logging
     /// services for tasks. This class allows for better encapsulation by making it clear when only
     /// logging services are needed and not the rest of the engine data and methods. This class allows
@@ -232,7 +232,7 @@ internal virtual bool NeedsFlush(long currentTickCount)
         /// Raises ErrorEvent and AnyEvent at all registered loggers.
         /// </summary>
         /// <owner>t-jeffv, SumedhK</owner>
-        /// <param name="e"></param> 
+        /// <param name="e"></param>
         internal void LogErrorEvent(BuildErrorEventArgs e)
         {
             // We are intentionally passing in null for the "sender" object, even when
@@ -240,7 +240,7 @@ internal void LogErrorEvent(BuildErrorEventArgs e)
             // tight coupling between loggers and tasks in this way.  It's not good
             // for a logger to be able to call back into a task.  It could be a security
             // issue, and it apparently will also cause us problems if we adopt the
-            // new Longhorn Add-In Programming Model.  
+            // new Longhorn Add-In Programming Model.
 
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             PostLoggingEvent(e);
@@ -250,7 +250,7 @@ internal void LogErrorEvent(BuildErrorEventArgs e)
         /// Raises MessageEvent and AnyEvent at all registered loggers.
         /// </summary>
         /// <owner>t-jeffv, SumedhK</owner>
-        /// <param name="e"></param> 
+        /// <param name="e"></param>
         internal void LogMessageEvent(BuildMessageEventArgs e)
         {
             if (!OnlyLogCriticalEvents)
@@ -271,7 +271,7 @@ internal void LogMessageEvent(BuildMessageEventArgs e)
         /// Raises WarningEvent and AnyEvent at all registered loggers.
         /// </summary>
         /// <owner>t-jeffv, SumedhK</owner>
-        /// <param name="e"></param> 
+        /// <param name="e"></param>
         internal void LogWarningEvent(BuildWarningEventArgs e)
         {
             // We are intentionally passing in null for the "sender" object, even when
@@ -289,7 +289,7 @@ internal void LogWarningEvent(BuildWarningEventArgs e)
         /// Raises CustomEvent and AnyEvent at all registered loggers.
         /// </summary>
         /// <owner>t-jeffv, SumedhK</owner>
-        /// <param name="e"></param> 
+        /// <param name="e"></param>
         internal void LogCustomEvent(CustomBuildEventArgs e)
         {
             // We are intentionally passing in null for the "sender" object, even when
@@ -978,7 +978,7 @@ internal bool FlushBuildEventsImmediatly
         protected bool flushBuildEventsImmediatly;
 
         /// <summary>
-        /// A dual queue which allows for one reader multiple writer access (used to receive events from 
+        /// A dual queue which allows for one reader multiple writer access (used to receive events from
         /// the engine and the TEM)
         /// </summary>
         protected DualQueue<BuildEventArgs> loggingQueueOfBuildEvents;
@@ -1008,7 +1008,7 @@ internal bool FlushBuildEventsImmediatly
         protected bool requestedQueueFlush;
 
         /// <summary>
-        /// An event used to request a flush of the logging service. Typically triggered due to 
+        /// An event used to request a flush of the logging service. Typically triggered due to
         /// a spike in logging activity.
         /// </summary>
         protected ManualResetEvent flushRequestEvent;
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
index 6e9885a4a92..24f9abb42e4 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
@@ -102,7 +102,7 @@ internal override bool ProcessPostedLoggingEvents()
         }
 
         /// <summary>
-        /// This method process a single BuildEvent argument, it will raise the event to registered loggers and 
+        /// This method process a single BuildEvent argument, it will raise the event to registered loggers and
         /// check to see if the there are forwarding loggers who need to see the event also, if so the message will
         /// be posted to another logger
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs b/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
index de4d5685304..61eb63a4541 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
@@ -47,10 +47,10 @@ internal EngineLoggingServicesOutProc(Node parentNode, ManualResetEvent flushReq
 
         /// <summary>
         /// The out of proc logging service is concerned with flushing the events out to the node provider
-        /// to be sent to the parent engine. Events which are not marked with a logger id end up being wrapped 
+        /// to be sent to the parent engine. Events which are not marked with a logger id end up being wrapped
         /// in a NodeLoggingEvent which was a default loggerId of 0. All events posted as BuildEventArgs fall
         /// into this category. Events with a loggerId need be posted as NodeLoggerEventWithLoggerId objects.
-        /// This function is thread safe and is called both from the engine thread and communication threads to 
+        /// This function is thread safe and is called both from the engine thread and communication threads to
         /// ensure that the events are delivered in coherent order.
         /// </summary>
         internal override bool ProcessPostedLoggingEvents()
@@ -76,7 +76,7 @@ internal override bool ProcessPostedLoggingEvents()
                     processedEvents = true;
                 }
 
-                // Grab all the forwarded events 
+                // Grab all the forwarded events
                 NodeLoggingEvent nodeLoggingEvent = null;
                 while ((nodeLoggingEvent = loggingQueueOfNodeEvents.Dequeue()) != null)
                 {
diff --git a/src/Deprecated/Engine/Engine/EngineProxy.cs b/src/Deprecated/Engine/Engine/EngineProxy.cs
index 1adb71454fd..be9ddf33e89 100644
--- a/src/Deprecated/Engine/Engine/EngineProxy.cs
+++ b/src/Deprecated/Engine/Engine/EngineProxy.cs
@@ -156,7 +156,7 @@ public void LogErrorEvent(BuildErrorEventArgs e)
 
             if (ContinueOnError)
             {
-                // Convert the error into a warning.  We do this because the whole point of 
+                // Convert the error into a warning.  We do this because the whole point of
                 // ContinueOnError is that a project author expects that the task might fail,
                 // but wants to ignore the failures.  This implies that we shouldn't be logging
                 // errors either, because you should never have a successful build with errors.
@@ -225,7 +225,7 @@ public void LogWarningEvent(BuildWarningEventArgs e)
             {
                 // We'd like to add the project file to the message, but since this property
                 // is read-only on the BuildWarningEventArgs type, this requires creating a new
-                // instance.  However, if some task logged a custom warning type, we don't want 
+                // instance.  However, if some task logged a custom warning type, we don't want
                 // to impolitely throw the custom type data away.
 
                 string message = GetUpdatedMessage(e.File, e.Message, parentProjectFullFileName);
@@ -562,7 +562,7 @@ public override object InitializeLifetimeService()
             ILease lease = (ILease)base.InitializeLifetimeService();
 
             // Set how long a lease should be initially. Once a lease expires
-            // the remote object will be disconnected and it will be marked as being availiable 
+            // the remote object will be disconnected and it will be marked as being availiable
             // for garbage collection
             int initialLeaseTime = 1;
 
@@ -584,7 +584,7 @@ public override object InitializeLifetimeService()
             // increase the lease time allowing the object to stay in memory
             sponsor = new ClientSponsor();
 
-            // When a new lease is requested lets make it last 1 minutes longer. 
+            // When a new lease is requested lets make it last 1 minutes longer.
             int leaseExtensionTime = 1;
 
             string leaseExtensionTimeFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDENGINEPROXYLEASEEXTENSIONTIME");
diff --git a/src/Deprecated/Engine/Engine/EventSource.cs b/src/Deprecated/Engine/Engine/EventSource.cs
index 08ae814e058..7428ad2d1e5 100644
--- a/src/Deprecated/Engine/Engine/EventSource.cs
+++ b/src/Deprecated/Engine/Engine/EventSource.cs
@@ -650,8 +650,8 @@ internal void RaiseStronglyTypedEvent(BuildEventArgs e)
         public event CustomBuildEventHandler CustomEventRaised;
 
         /// <summary>
-        /// this event is raised to log build status events, such as 
-        /// build/project/target/task started/stopped 
+        /// this event is raised to log build status events, such as
+        /// build/project/target/task started/stopped
         /// </summary>
         /// <owner> t-jeffv, sumedhk </owner>
         public event BuildStatusEventHandler StatusEventRaised;
diff --git a/src/Deprecated/Engine/Engine/ExecutionContext.cs b/src/Deprecated/Engine/Engine/ExecutionContext.cs
index ef68b9c8f8c..026de371572 100644
--- a/src/Deprecated/Engine/Engine/ExecutionContext.cs
+++ b/src/Deprecated/Engine/Engine/ExecutionContext.cs
@@ -41,7 +41,7 @@ internal int HandleId
         }
 
         /// <summary>
-        /// The node on which this context is being executed 
+        /// The node on which this context is being executed
         /// </summary>
         internal int NodeIndex
         {
diff --git a/src/Deprecated/Engine/Engine/Expander.cs b/src/Deprecated/Engine/Engine/Expander.cs
index 3255c4ce3a0..bb29943dc58 100644
--- a/src/Deprecated/Engine/Engine/Expander.cs
+++ b/src/Deprecated/Engine/Engine/Expander.cs
@@ -36,7 +36,7 @@ internal class Expander
         // instead of using the overhead of a lookup
         private BuildPropertyGroup properties;
 
-        // Table of metadata values. 
+        // Table of metadata values.
         // May have some qualified keys (type.name) or all unqualified.
         // If all unqualified, the implicitMetadataItemType field indicates the type.
         private Dictionary<string, string> itemMetadata;
@@ -211,8 +211,8 @@ XmlAttribute expressionAttribute
 
         /// <summary>
         /// Expands item metadata, properties, and items (in that order), and produces a list of TaskItems.
-        /// 
-        /// All data accessed through the TaskItem (ItemSpec and metadata) is going to be unescaped, so it's nice 
+        ///
+        /// All data accessed through the TaskItem (ItemSpec and metadata) is going to be unescaped, so it's nice
         /// and ready for a task to consume.
         /// </summary>
         /// <param name="expression"></param>
@@ -463,7 +463,7 @@ XmlNode expressionNode
             // where we've essentially read up to and copied into the target string.
             int sourceIndex = 0;
 
-            // Search for "$(" in the sourceString.  Loop until we don't find it 
+            // Search for "$(" in the sourceString.  Loop until we don't find it
             // any more.
             while (propertyStartIndex != -1)
             {
@@ -496,9 +496,9 @@ XmlNode expressionNode
                 {
                     // Aha, we found the closing parenthesis.  All the stuff in
                     // between the "$(" and the ")" constitutes the property body.
-                    // Note: Current propertyStartIndex points to the "$", and 
+                    // Note: Current propertyStartIndex points to the "$", and
                     // propertyEndIndex points to the ")".  That's why we have to
-                    // add 2 for the start of the substring, and subtract 2 for 
+                    // add 2 for the start of the substring, and subtract 2 for
                     // the length.
                     string propertyBody = expression.Substring(propertyStartIndex + 2, propertyEndIndex - propertyStartIndex - 2);
 
@@ -525,7 +525,7 @@ XmlNode expressionNode
                         propertyValue = LookupProperty(properties, propertyBody, expressionNode);
                     }
 
-                    // If it's a property function result, it may return null, so check before we add it.  
+                    // If it's a property function result, it may return null, so check before we add it.
                     if (propertyValue != null)
                     {
                         // Append the property value to our targetString, and advance
@@ -553,7 +553,7 @@ XmlNode expressionNode
                 // PERF: This method is called very often - of the order of 3,000 times per project.
                 // StringBuilder by default is initialized with a 16 char string and doubles the length
                 // whenever it's too short. We want to avoid reallocation but also avoid excessive allocation.
-                // The length of the source string turns out to be a fair compromise. (The final result may 
+                // The length of the source string turns out to be a fair compromise. (The final result may
                 // be longer or it may be shorter.)
                 StringBuilder result = new StringBuilder(expression.Length);
 
@@ -759,7 +759,7 @@ private object ExpandPropertyBody(string propertyBody, object propertyValue, Bui
                 }
             }
 
-            // Find the property value in our property collection.  This 
+            // Find the property value in our property collection.  This
             // will automatically return "" (empty string) if the property
             // doesn't exist in the collection, and we're not executing a static function
             if (!String.IsNullOrEmpty(propertyName))
@@ -1180,10 +1180,10 @@ public object Execute(Expander expander, object objectInstance, BuildPropertyGro
                     }
 
                     // Handle special cases where the object type needs to affect the choice of method
-                    // The default binder and method invoke, often chooses the incorrect Equals and CompareTo and 
+                    // The default binder and method invoke, often chooses the incorrect Equals and CompareTo and
                     // fails the comparison, because what we have on the right is generally a string.
                     // This special casing is to realize that its a comparison that is taking place and handle the
-                    // argument type coercion accordingly; effectively pre-preparing the argument type so 
+                    // argument type coercion accordingly; effectively pre-preparing the argument type so
                     // that it matches the left hand side ready for the default binders method invoke.
                     if (objectInstance != null && args.Length == 1 && (String.Equals("Equals", this.name, StringComparison.OrdinalIgnoreCase) || String.Equals("CompareTo", this.name, StringComparison.OrdinalIgnoreCase)))
                     {
@@ -1215,7 +1215,7 @@ public object Execute(Expander expander, object objectInstance, BuildPropertyGro
                             if ((bindingFlags & BindingFlags.InvokeMethod) == BindingFlags.InvokeMethod)
                             {
                                 // The standard binder failed, so do our best to coerce types into the arguments for the function
-                                // This may happen if the types need coercion, but it may also happen if the object represents a type that contains open type parameters, that is, ContainsGenericParameters returns true. 
+                                // This may happen if the types need coercion, but it may also happen if the object represents a type that contains open type parameters, that is, ContainsGenericParameters returns true.
                                 functionResult = LateBindExecute(ex, bindingFlags, objectInstance, args, false /* is not constructor */);
                             }
                             else
@@ -1668,7 +1668,7 @@ private static void AddArgument(List<string> arguments, StringBuilder argumentBu
                 // becomes possible through an empty argument between commas.
                 ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, nameof(argumentBuilder));
                 // we reached the end of an argument, add the builder's final result
-                // to our arguments. 
+                // to our arguments.
                 string argValue = argumentBuilder.ToString().Trim();
                 // We support passing of null through the argument constant value null
                 if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
@@ -1717,7 +1717,7 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                             // We'll also allow the user to specify the leaf or full type name on the enum
                             string argument = args[n].ToString().Replace('|', ',').Replace(typeFullName, "").Replace(typeLeafName, "");
 
-                            // Parse the string representation of the argument into the destination enum                                
+                            // Parse the string representation of the argument into the destination enum
                             coercedArguments[n] = Enum.Parse(enumType, argument);
                         }
                         else
@@ -1869,7 +1869,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
 
         /// <summary>
         /// Expands all embedded item metadata in the given string, using the bucketed items.
-        /// 
+        ///
         /// This method leaves the expression escaped.  Callers may need to unescape on their own as appropriate.
         /// </summary>
         /// <remarks>
diff --git a/src/Deprecated/Engine/Engine/IEngineCallback.cs b/src/Deprecated/Engine/Engine/IEngineCallback.cs
index cb5b1969340..46dbdc61083 100644
--- a/src/Deprecated/Engine/Engine/IEngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/IEngineCallback.cs
@@ -20,7 +20,7 @@ internal interface IEngineCallback
         void PostBuildRequestsToHost(BuildRequest[] buildRequests);
 
         /// <summary>
-        /// This method is called to send results to the parent engine in response to an earlier 
+        /// This method is called to send results to the parent engine in response to an earlier
         /// build request.
         /// </summary>
         /// <param name="buildResult"></param>
diff --git a/src/Deprecated/Engine/Engine/INodeProvider.cs b/src/Deprecated/Engine/Engine/INodeProvider.cs
index 9ae4d575f26..0f5e2d6106a 100644
--- a/src/Deprecated/Engine/Engine/INodeProvider.cs
+++ b/src/Deprecated/Engine/Engine/INodeProvider.cs
@@ -9,10 +9,10 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This interface is used by to provide an engine coordinating a build with access
-    /// to child engines which can execute parts of the build. The provider is entirely 
+    /// to child engines which can execute parts of the build. The provider is entirely
     /// responsible for establishing and maintaining the communication between the parent
-    /// engine and the child engines. The provider is also responsible for describing the 
-    /// capabilities of the communication channel and the machines on which the child engines 
+    /// engine and the child engines. The provider is also responsible for describing the
+    /// capabilities of the communication channel and the machines on which the child engines
     /// are running so that the parent engine can schedule and coordinate the work appropriately
     /// </summary>
     internal interface INodeProvider
@@ -31,9 +31,9 @@ void Initialize(string configuration, IEngineCallback engineCallback, BuildPrope
                         ToolsetDefinitionLocations toolsetSearchLocations, string startupDirectory);
 
         /// <summary>
-        /// This method is called by the NodeManager after the Initialize method to query 
+        /// This method is called by the NodeManager after the Initialize method to query
         /// the provider about number and capability of the nodes that it can make available to
-        /// the parent engine. 
+        /// the parent engine.
         /// </summary>
         /// <returns>Description of nodes that this provider</returns>
         INodeDescription[] QueryNodeDescriptions();
@@ -47,7 +47,7 @@ void Initialize(string configuration, IEngineCallback engineCallback, BuildPrope
         void AssignNodeIdentifiers(int[] nodeIdentifiers);
 
         /// <summary>
-        /// This method is called by the NodeManager to pass in a description of a forwarding logger 
+        /// This method is called by the NodeManager to pass in a description of a forwarding logger
         /// that should be loaded on the nodes exposed by the provider. This method can only be called
         /// after Initialize method has been called.
         /// </summary>
@@ -64,7 +64,7 @@ void Initialize(string configuration, IEngineCallback engineCallback, BuildPrope
         void PostBuildRequestToNode(int nodeIndex, BuildRequest buildRequest);
 
         /// <summary>
-        /// This method is called by the coordinating engine to send results requested by a 
+        /// This method is called by the coordinating engine to send results requested by a
         /// node during intermediate evaluation
         /// </summary>
         /// <param name="nodeIndex"></param>
diff --git a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
index 30b2bc929a9..e38ed53576e 100644
--- a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
+++ b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
@@ -116,7 +116,7 @@ internal static string Unescape(string escaped)
         }
 
         /// <summary>
-        /// Perform a bitwise OR on the first and second (first | second) 
+        /// Perform a bitwise OR on the first and second (first | second)
         /// </summary>
         internal static int BitwiseOr(int first, int second)
         {
@@ -124,7 +124,7 @@ internal static int BitwiseOr(int first, int second)
         }
 
         /// <summary>
-        /// Perform a bitwise AND on the first and second (first &amp; second) 
+        /// Perform a bitwise AND on the first and second (first &amp; second)
         /// </summary>
         internal static int BitwiseAnd(int first, int second)
         {
@@ -132,7 +132,7 @@ internal static int BitwiseAnd(int first, int second)
         }
 
         /// <summary>
-        /// Perform a bitwise XOR on the first and second (first ^ second) 
+        /// Perform a bitwise XOR on the first and second (first ^ second)
         /// </summary>
         internal static int BitwiseXor(int first, int second)
         {
@@ -140,7 +140,7 @@ internal static int BitwiseXor(int first, int second)
         }
 
         /// <summary>
-        /// Perform a bitwise NOT on the first and second (~first) 
+        /// Perform a bitwise NOT on the first and second (~first)
         /// </summary>
         internal static int BitwiseNot(int first)
         {
@@ -225,11 +225,11 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         }
 
         /// <summary>
-        /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location. 
+        /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
         /// Throws UriFormatException.
         /// </summary>
         /// <param name="basePath">
-        /// The base path we want to relativize to. Must be absolute.  
+        /// The base path we want to relativize to. Must be absolute.
         /// Should <i>not</i> include a filename as the last segment will be interpreted as a directory.
         /// </param>
         /// <param name="path">
@@ -297,11 +297,11 @@ internal static string ValueOrDefault(string conditionValue, string defaultValue
 
         /// <summary>
         /// Returns true if a task host exists that can service the requested runtime and architecture
-        /// values, and false otherwise. 
+        /// values, and false otherwise.
         /// </summary>
         /// <comments>
         /// The old engine ignores the concept of the task host entirely, so it shouldn't really
-        /// matter what we return.  So we return "true" because regardless of the task host parameters, 
+        /// matter what we return.  So we return "true" because regardless of the task host parameters,
         /// the task will be successfully run (in-proc).
         /// </comments>
         internal static bool DoesTaskHostExist(string runtime, string architecture)
diff --git a/src/Deprecated/Engine/Engine/ItemBucket.cs b/src/Deprecated/Engine/Engine/ItemBucket.cs
index 6cd83a31170..708426b1251 100644
--- a/src/Deprecated/Engine/Engine/ItemBucket.cs
+++ b/src/Deprecated/Engine/Engine/ItemBucket.cs
@@ -34,10 +34,10 @@ internal sealed class ItemBucket : IComparable
         private Lookup lookup;
 
         /// <summary>
-        /// When buckets are being created for batching purposes, this indicates which order the 
+        /// When buckets are being created for batching purposes, this indicates which order the
         /// buckets were created in, so that the target/task being batched gets called with the items
         /// in the same order as they were declared in the project file.  For example, the first
-        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets 
+        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
         private int bucketSequenceNumber;
@@ -147,10 +147,10 @@ internal Expander Expander
         }
 
         /// <summary>
-        /// When buckets are being created for batching purposes, this indicates which order the 
+        /// When buckets are being created for batching purposes, this indicates which order the
         /// buckets were created in, so that the target/task being batched gets called with the items
         /// in the same order as they were declared in the project file.  For example, the first
-        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets 
+        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
         /// <owner>RGoel</owner>
diff --git a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
index 896a869526c..d6e579757fb 100644
--- a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
+++ b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
@@ -67,7 +67,7 @@ internal BuildEventArgs BuildEvent
         }
 
         /// <summary>
-        /// The ID of the central logger to which this event should be forwarded. By default 
+        /// The ID of the central logger to which this event should be forwarded. By default
         /// all regular non-forwarded events are sent to all loggers registered on the parent.
         /// </summary>
         internal virtual int LoggerId
diff --git a/src/Deprecated/Engine/Engine/NodeManager.cs b/src/Deprecated/Engine/Engine/NodeManager.cs
index 72dd15b4ae6..5846767cc00 100644
--- a/src/Deprecated/Engine/Engine/NodeManager.cs
+++ b/src/Deprecated/Engine/Engine/NodeManager.cs
@@ -218,7 +218,7 @@ internal void ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
                     // At this point we have nulled out the task execution module and have told our task worker threads to exit
                     // we do not want the engine build loop to continue to do any work becasue the operations of the build loop
                     // require the task execution module in many cases. Before this fix, when the engine build loop was allowed
-                    // to do work after the task execution module we would get random null reference excetpions depending on 
+                    // to do work after the task execution module we would get random null reference excetpions depending on
                     // what was the first line to use the TEM after it was nulled out.
                     parentEngine.SetEngineAbortTo(true);
                 }
diff --git a/src/Deprecated/Engine/Engine/NodeWorkerThread.cs b/src/Deprecated/Engine/Engine/NodeWorkerThread.cs
index 4486e5be236..9f739801664 100644
--- a/src/Deprecated/Engine/Engine/NodeWorkerThread.cs
+++ b/src/Deprecated/Engine/Engine/NodeWorkerThread.cs
@@ -86,7 +86,7 @@ internal ManualResetEvent LocalDoneNoticeEvent
 
         /// <summary>
         /// This a base loop of a worker thread. The worker thread is asleep waiting for either an
-        /// event indicating that it should shut down or that it should become active and take 
+        /// event indicating that it should shut down or that it should become active and take
         /// ownership of the work item queue
         /// </summary>
         private void MainThreadLoop()
@@ -283,7 +283,7 @@ private void NodeActionLoop(NodeLoopExecutionMode executionMode, int nodeProxyId
                 else if (eventType == 1 && executionMode == NodeLoopExecutionMode.WaitingPassiveThread ||
                          eventType == 2 && executionMode == NodeLoopExecutionMode.WaitingActiveThread)
                 {
-                    // There maybe multiple results in the list so we need to loop over it 
+                    // There maybe multiple results in the list so we need to loop over it
                     // and store the results
                     int originalResultCount = resultCount;
                     lock (targetEvaluationResults)
@@ -291,7 +291,7 @@ private void NodeActionLoop(NodeLoopExecutionMode executionMode, int nodeProxyId
                         //Console.WriteLine("Worker thread for: " + nodeProxyId + " Got results");
                         LinkedListNode<BuildResult> currentNode = targetEvaluationResults.First;
                         while (currentNode != null)
-                        {   
+                        {
                             BuildResult buildResult = currentNode.Value;
                             ErrorUtilities.VerifyThrow(
                                             buildResult.RequestId < requestResults.Length,
@@ -315,7 +315,7 @@ private void NodeActionLoop(NodeLoopExecutionMode executionMode, int nodeProxyId
                     }
                 }
                 // Check if we need to update the state
-                if (executionMode == NodeLoopExecutionMode.BaseActiveThread && !threadActive) 
+                if (executionMode == NodeLoopExecutionMode.BaseActiveThread && !threadActive)
                 {
                     continueExecution = false;
                 }
@@ -364,7 +364,7 @@ internal void ActivateThread()
         internal static void WaitForResults(int nodeProxyId, BuildResult[] requestResults)
         {
             TaskWorkerThread workerThread = TaskWorkerThread.GetWorkerThreadForProxyId(nodeProxyId);
-            workerThread.NodeActionLoop(workerThread.threadActive ? NodeLoopExecutionMode.WaitingActiveThread : 
+            workerThread.NodeActionLoop(workerThread.threadActive ? NodeLoopExecutionMode.WaitingActiveThread :
                                         NodeLoopExecutionMode.WaitingPassiveThread,
                                         nodeProxyId, requestResults);
         }
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index e99d8f5961b..4f16c9086b6 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -80,7 +80,7 @@ public class Project
 
         // We need to know if the projectContextId which was generated during the
         // instantiation of the project instance has been used. If the Id has been used,
-        // which would make the value true, we will then generate a new projectContextId 
+        // which would make the value true, we will then generate a new projectContextId
         // on the next project started event
         private bool haveUsedInitialProjectContextId;
 
@@ -607,7 +607,7 @@ public string InitialTargets
         {
             get
             {
-                // Return the concatenation of the initial target names from the main project and the ones from 
+                // Return the concatenation of the initial target names from the main project and the ones from
                 // all the imported projects.  Join target names together with semicolons in between.
                 return String.Join("; ", (string[])this.CombinedInitialTargetNames.ToArray(typeof(string)));
             }
@@ -782,7 +782,7 @@ public string ToolsVersion
         {
             get
             {
-                // We could have a toolsversion already (either from the Project element, or 
+                // We could have a toolsversion already (either from the Project element, or
                 // from an externally set override value). If not, read it off the Project
                 // element now
                 if (!OverridingToolsVersion)
@@ -2753,7 +2753,7 @@ string itemInclude
                     {
                         if (String.Equals(originalItem.Name, itemName, StringComparison.OrdinalIgnoreCase))
                         {
-                            // If the new item that the user is trying to add is already covered by 
+                            // If the new item that the user is trying to add is already covered by
                             // a wildcard in an existing item of the project, then there's really
                             // no need to physically touch the project file.  As long as the new item
                             // is on disk, the next reevaluation will automatically pick it up.  When
@@ -2779,7 +2779,7 @@ string itemInclude
 
                                 // Don't bother adding to item lists by name, as we're going to have to evaluate the project as a whole later anyway
 
-                                // We haven't actually changed the XML for the project, because we're 
+                                // We haven't actually changed the XML for the project, because we're
                                 // just piggybacking onto an existing item that was a wildcard.  However,
                                 // we should reevaluate on the next build.
                                 this.MarkProjectAsDirtyForReevaluation();
@@ -3283,7 +3283,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                      buildContext.CurrentBuildContextState != ProjectBuildState.BuildContextState.RequestFilled)
                 {
                     // If the target that threw an exception is being built due to an
-                    // dependson or onerror relationship, it is necessary to make sure 
+                    // dependson or onerror relationship, it is necessary to make sure
                     // the buildrequests waiting on targets below it get notified of the failure. In single
                     // threaded mode there is only a single outstanding request so this issue is avoided.
                     if (exitedDueToError)
@@ -3346,7 +3346,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
 
         internal void CalculateNextActionForProjectContext(ProjectBuildState buildContext)
         {
-            // If the build request has been already complete 
+            // If the build request has been already complete
             if (buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.RequestFilled)
             {
                 return;
@@ -3408,7 +3408,7 @@ internal void CalculateNextActionForProjectContext(ProjectBuildState buildContex
                             // Check if there are no more targets to run
                             if (buildContext.GetNextTarget() == null)
                             {
-                                // The request is complete 
+                                // The request is complete
                                 buildContext.RecordBuildCompletion(true);
                             }
                             else
@@ -3523,9 +3523,9 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
                     // Flag the start of the project build.
                     //
                     // This also passes all the current properties/items and their values. The logger might want to use the
-                    // object it gets from this event to see updated property/item values later in the build: so be 
-                    // careful to use the original "evaluatedProperties" and "evaluatedItems" table, not the clone 
-                    // "EvaluatedProperties" or "EvaluatedItems" table. It's fine to pass these live tables, because we're 
+                    // object it gets from this event to see updated property/item values later in the build: so be
+                    // careful to use the original "evaluatedProperties" and "evaluatedItems" table, not the clone
+                    // "EvaluatedProperties" or "EvaluatedItems" table. It's fine to pass these live tables, because we're
                     // wrapping them in read-only proxies.
                     BuildPropertyGroup propertyGroupForStartedEvent = this.evaluatedProperties;
 
@@ -3848,7 +3848,7 @@ bool importedProject
 
             try
             {
-                // Make the correct project directory available. This is needed because it is 
+                // Make the correct project directory available. This is needed because it is
                 // used for evaluating "exists" in conditional expressions, for example on <Import> elements.
                 Project.PerThreadProjectDirectory = ProjectDirectory;
 
@@ -4279,7 +4279,7 @@ private void EvaluateProject(bool currentlyLoading)
                 }
                 finally
                 {
-                    // We reset the path back to the original value in case the 
+                    // We reset the path back to the original value in case the
                     // host is depending on the current directory to find projects
                     Project.PerThreadProjectDirectory = currentPerThreadProjectDirectory;
                 }
@@ -4376,7 +4376,7 @@ internal void AddToItemListByNameIgnoringCondition(BuildItem item)
             // used as a key into the overall hash table, is case-insensitive.
             BuildItemGroup itemListByNameIgnoringCondition = (BuildItemGroup)this.evaluatedItemsByNameIgnoringCondition[item.Name];
 
-            // If no such BuildItemGroup exists yet, create a new BuildItemGroup and add it to 
+            // If no such BuildItemGroup exists yet, create a new BuildItemGroup and add it to
             // the hashtable of ItemGroups by type.
             if (itemListByNameIgnoringCondition == null)
             {
@@ -4403,7 +4403,7 @@ internal void AddToItemListByName(BuildItem item)
             // used as a key into the overall hash table, is case-insensitive.
             BuildItemGroup itemListByName = (BuildItemGroup)this.evaluatedItemsByName[item.Name];
 
-            // If no such BuildItemGroup exists yet, create a new BuildItemGroup and add it to 
+            // If no such BuildItemGroup exists yet, create a new BuildItemGroup and add it to
             // the hashtable of ItemGroups by type.
             if (itemListByName == null)
             {
diff --git a/src/Deprecated/Engine/Engine/ProjectBuildState.cs b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
index be2c64a3767..478876c6fe7 100644
--- a/src/Deprecated/Engine/Engine/ProjectBuildState.cs
+++ b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class is used to maintain a state of execution of a build request. Once a build request is
-    /// received it is wrapped in this class 
+    /// received it is wrapped in this class
     /// </summary>
     [DebuggerDisplay("ProjectBuildState (NameOfTargetInProgress={NameOfTargetInProgress}, NameOfBlockingTarget={NameOfBlockingTarget}, BuildResult={BuildResult}, BuildComplete={BuildComplete})")]
     internal sealed class ProjectBuildState
@@ -152,7 +152,7 @@ internal string GetNextTarget()
         }
 
         /// <summary>
-        /// Remove the top blocking target 
+        /// Remove the top blocking target
         /// </summary>
         internal void RemoveBlockingTarget()
         {
@@ -161,7 +161,7 @@ internal void RemoveBlockingTarget()
         }
 
         /// <summary>
-        /// Add another blocking target 
+        /// Add another blocking target
         /// </summary>
         internal void AddBlockingTarget(string targetName)
         {
@@ -218,7 +218,7 @@ internal bool ContainsCycle(string name)
         }
 
         /// <summary>
-        /// This method return true if a given target name appears anywhere in the list of 
+        /// This method return true if a given target name appears anywhere in the list of
         /// blocking targets
         /// </summary>
         internal bool ContainsBlockingTarget(string name)
@@ -233,7 +233,7 @@ internal bool ContainsBlockingTarget(string name)
 
         /// <summary>
         /// This method is used by the target cycle detector to find the parent target for
-        /// the given target. The parent only exists if there is at least 1 
+        /// the given target. The parent only exists if there is at least 1
         /// blocking target. If there is less than 1 blocking target the parent is determined
         /// by the orgin of the build request that caused this build context.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/ProjectManager.cs b/src/Deprecated/Engine/Engine/ProjectManager.cs
index 3c4c1ad9e70..90d91d61884 100644
--- a/src/Deprecated/Engine/Engine/ProjectManager.cs
+++ b/src/Deprecated/Engine/Engine/ProjectManager.cs
@@ -58,7 +58,7 @@ string fullPath
         }
 
         /// <summary>
-        /// Searches our tables for a project with same full path, tools version, and global property settings 
+        /// Searches our tables for a project with same full path, tools version, and global property settings
         /// Removes particular project from the project manager.
         /// </summary>
         /// <param name="project"></param>
@@ -96,8 +96,8 @@ Project project
         }
 
         /// <summary>
-        /// Searches our tables for a project with same full path and global property settings 
-        /// as those passed in to the method.  
+        /// Searches our tables for a project with same full path and global property settings
+        /// as those passed in to the method.
         /// </summary>
         /// <param name="projectFileFullPath"></param>
         /// <param name="globalProperties"></param>
@@ -117,8 +117,8 @@ string toolsVersion
 
         /// <summary>
         /// Searches our tables for a project with same project id
-        /// as the one passed in to the method. Note this method is currently O(n) 
-        /// with the number of projects, so if it used on a hot code path it needs to 
+        /// as the one passed in to the method. Note this method is currently O(n)
+        /// with the number of projects, so if it used on a hot code path it needs to
         /// use an extra hashtable to achieve O(1).
         /// </summary>
         /// <param name="projectId"></param>
@@ -265,7 +265,7 @@ string toolsVersion
         #region Methods managing the record of unloaded projects
 
         /// <summary>
-        /// This function adds the project to the table of previously loaded projects, if it's 
+        /// This function adds the project to the table of previously loaded projects, if it's
         /// not already present.
         /// </summary>
         private void AddUnloadedProjectRecord
@@ -387,7 +387,7 @@ internal static Project GetProject(Hashtable table, string projectFileFullPath,
         }
 
         /// <summary>
-        /// Retrieve the project entry from the entry table based on project file name, globalProperties, and toolsVersion. 
+        /// Retrieve the project entry from the entry table based on project file name, globalProperties, and toolsVersion.
         /// </summary>
         internal static ProjectEntry GetProjectEntry(Hashtable entryTable, string projectFileFullPath, BuildPropertyGroup globalProperties, string toolsVersion)
         {
@@ -414,12 +414,12 @@ internal static ProjectEntry GetProjectEntry(Hashtable entryTable, string projec
         #region Data
         // This hash table tracks all the projects that are currently building,
         // or are being kept around from the last build for perf reasons (so
-        // we don't have to reload the same projects over and over in IDE 
+        // we don't have to reload the same projects over and over in IDE
         // scenarios.
         // The key for this hash table is the case-insensitive full path to the
         // project file.  The value in this hash table is an ArrayList of Project
         // objects that came from that full path.  The reason there could be
-        // multiple Project objects with the same full path is because they 
+        // multiple Project objects with the same full path is because they
         // may each be using a different set of global properties, and we can't
         // have them tromp on each other.
         private Hashtable projects;
@@ -431,7 +431,7 @@ internal static ProjectEntry GetProjectEntry(Hashtable entryTable, string projec
         private Hashtable unloadedProjects;
         #endregion
 
-        #region Helper class 
+        #region Helper class
         internal class ProjectEntry
         {
             internal BuildPropertyGroup globalProperties;
diff --git a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
index de94023867b..c7279efa3d0 100644
--- a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
+++ b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
@@ -124,7 +124,7 @@ string projectFile
                 schemaFile = Path.Combine(binPath, "Microsoft.Build.xsd");
             }
 
-            // Log the schema file we're using, particularly since it can vary 
+            // Log the schema file we're using, particularly since it can vary
             // according to  the toolset being used
             engineLoggingServices.LogComment(buildEventContext, "SchemaFileLocation", schemaFile);
 
diff --git a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
index f7b892ae87e..7bbbd5d0915 100644
--- a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
+++ b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
@@ -15,7 +15,7 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
-    /// Thin wrapper around Microsoft.Win32.RegistryKey that can be 
+    /// Thin wrapper around Microsoft.Win32.RegistryKey that can be
     /// subclassed for testing purposes
     /// </summary>
     internal class RegistryKeyWrapper
diff --git a/src/Deprecated/Engine/Engine/RequestRoutingContext.cs b/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
index 958bbf9468e..c2d5e701a0a 100644
--- a/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
+++ b/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This context is created to contain information about a build request that has been forwarded to
-    /// a child node for execution. All further communication from the child with regard to the build 
+    /// a child node for execution. All further communication from the child with regard to the build
     /// request (such a logging messages, errors, follow up build requests or build result) will be
     /// processing using information from this context.
     /// </summary>
diff --git a/src/Deprecated/Engine/Engine/Router.cs b/src/Deprecated/Engine/Engine/Router.cs
index cd4de9d5bec..8b785aa17f1 100644
--- a/src/Deprecated/Engine/Engine/Router.cs
+++ b/src/Deprecated/Engine/Engine/Router.cs
@@ -39,7 +39,7 @@ internal Router(Engine parentEngine, Scheduler scheduler)
         #region Properties
 
         /// <summary>
-        /// Returns true on the child engine and false otherwise. this is used by the engine to determine if the engine is running on a child 
+        /// Returns true on the child engine and false otherwise. this is used by the engine to determine if the engine is running on a child
         /// process or not. The childMode is set to true in the NodeLocalEngineLoop which is only executed on a child process.
         /// </summary>
         internal bool ChildMode
@@ -90,12 +90,12 @@ internal bool SingleThreadedMode
         /// <summary>
         /// This method creates a BuildResult using the information contained in a completed build request and
         /// then routes it to the right node. On a child process, this means either consume the result localy,
-        /// or send it to the parent node. On a parent node, this means either consume the result locally or 
+        /// or send it to the parent node. On a parent node, this means either consume the result locally or
         /// send it to a child node
         /// </summary>
         internal void PostDoneNotice(BuildRequest buildRequest)
         {
-            // Create a container with the results of the evaluation 
+            // Create a container with the results of the evaluation
             BuildResult buildResult = buildRequest.GetBuildResult();
 
             // If we're supposed to use caching and this request wasn't restored from cache, cache it
@@ -105,7 +105,7 @@ internal void PostDoneNotice(BuildRequest buildRequest)
                 cacheScope.AddCacheEntryForBuildResults(buildResult);
             }
 
-            // an external request is any request that came from the parent engine, all requests to a child are external 
+            // an external request is any request that came from the parent engine, all requests to a child are external
             // unless the project was alredy loaded on the node itself
             if (buildRequest.IsExternalRequest)
             {
@@ -147,7 +147,7 @@ internal void PostDoneNotice(int nodeId, BuildResult buildResult)
 
         /// <summary>
         /// This method is called once the engine has decided to sent a build request to a child node.
-        /// Route the given BuildRequest to the given node. If necessary a routing context is 
+        /// Route the given BuildRequest to the given node. If necessary a routing context is
         /// created to manage future communication with the node regarding the build request.
         /// </summary>
         internal void PostBuildRequest(BuildRequest currentRequest, int nodeIndex)
@@ -212,6 +212,6 @@ internal void PostBuildRequest(BuildRequest currentRequest, int nodeIndex)
         /// What is the parent Node on which the engine is hosted if we are a child process
         /// </summary>
         private Node parentNode;
-        #endregion 
+        #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Engine/Scheduler.cs b/src/Deprecated/Engine/Engine/Scheduler.cs
index 0af5b3dbf00..5171c454631 100644
--- a/src/Deprecated/Engine/Engine/Scheduler.cs
+++ b/src/Deprecated/Engine/Engine/Scheduler.cs
@@ -112,7 +112,7 @@ internal int CalculateNodeForBuildRequest(BuildRequest currentRequest, int nodeI
 
                         for (int i = 0; i < nodes.Length; i++)
                         {
-                            //postBlockCount indicates the number of projects which should be sent to a node to unblock it due to the 
+                            //postBlockCount indicates the number of projects which should be sent to a node to unblock it due to the
                             //node running out of work.
                             if (postBlockCount[i] != 0 && postBlockCount[i] < blockedNodeRemainingProjectCount)
                             {
@@ -157,7 +157,7 @@ internal int CalculateNodeForBuildRequest(BuildRequest currentRequest, int nodeI
                     }
                     else
                     {
-                        // round robin schedule the build request 
+                        // round robin schedule the build request
                         nodeUsed = (lastUsedNode % nodes.Length);
 
                         // Running total of the number of times this round robin scheduler has been called
@@ -269,7 +269,7 @@ internal void NotifyOfBuildResult(int nodeId, BuildResult buildResult)
                         // Remove this build request from the list of requests the parent request is waiting on. This may unblock the parent request
                         parentRecord.ReportChildCompleted(recordKey);
 
-                        // If completing the child request has unblocked the parent request due to all of the the Child requests being completed 
+                        // If completing the child request has unblocked the parent request due to all of the the Child requests being completed
                         // decrement the number of blocked requests.
                         if (!parentRecord.Blocked)
                         {
@@ -305,7 +305,7 @@ internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, i
                     bool useBreadthFirstTraversal = false;
                     for (int i = 0; i < totalRequestsPerNode.Length; i++)
                     {
-                        // Continue using breadth-first traversal as long as the non-blocked work load for this node is below 
+                        // Continue using breadth-first traversal as long as the non-blocked work load for this node is below
                         // the nodeWorkloadProjectCount or its postBlockCount is non-zero
                         if ((totalRequestsPerNode[i] - blockedRequestsPerNode[i]) < nodeWorkLoadProjectCount || postBlockCount[i] != 0)
                         {
diff --git a/src/Deprecated/Engine/Engine/SchedulerRecord.cs b/src/Deprecated/Engine/Engine/SchedulerRecord.cs
index 8695ba4205b..9113e2adf50 100644
--- a/src/Deprecated/Engine/Engine/SchedulerRecord.cs
+++ b/src/Deprecated/Engine/Engine/SchedulerRecord.cs
@@ -41,7 +41,7 @@ string[] targetsBuild
 
         #region Properties
         /// <summary>
-        /// Returns true if this request is blocked waiting for the child requests to 
+        /// Returns true if this request is blocked waiting for the child requests to
         /// complete
         /// </summary>
         internal bool Blocked
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index 42435566ead..45612ae14d7 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -46,11 +46,11 @@ internal enum BuildState
             CompletedSuccessfully,
 
             // We have attempted to build this target and all its dependent
-            // targets.  However, something failed during that process, and 
+            // targets.  However, something failed during that process, and
             // we consider ourselves done with this target.
             CompletedUnsuccessfully,
 
-            // This target is to be skipped.  This state is the result of a target 
+            // This target is to be skipped.  This state is the result of a target
             // having a condition attribute and that condition evaluating to false.
             Skipped
         }
@@ -146,7 +146,7 @@ bool importedFromAnotherProject
             this.buildState = BuildState.NotStarted;
             this.id = project.ParentEngine.GetNextTargetId();
 
-            // The target name and target dependendencies (dependencies on other 
+            // The target name and target dependendencies (dependencies on other
             // targets) are specified as attributes of the <target> element.
 
             XmlAttribute returnsAttribute = null;
@@ -164,7 +164,7 @@ bool importedFromAnotherProject
                     case XMakeAttributes.name:
                         this.targetName = EscapingUtilities.UnescapeAll(targetAttribute.Value);
 
-                        // Target names cannot contain MSBuild special characters, embedded properties, 
+                        // Target names cannot contain MSBuild special characters, embedded properties,
                         // or item lists.
                         int indexOfSpecialCharacter = this.targetName.IndexOfAny(XMakeElements.illegalTargetNameCharacters);
                         if (indexOfSpecialCharacter >= 0)
@@ -204,7 +204,7 @@ bool importedFromAnotherProject
                         break;
 
                     // These are only recognized by the new OM:
-                    // while the solution wrapper generator is using 
+                    // while the solution wrapper generator is using
                     // the old OM to parse projects for dependencies,
                     // we must make sure to not fail for these
                     case XMakeAttributes.beforeTargets:
@@ -217,9 +217,9 @@ bool importedFromAnotherProject
                 }
             }
 
-            // Hack to help the 3.5 engine at least pretend to still be able to build on top of 
-            // the 4.0 targets.  In cases where there is no Outputs attribute, just a Returns attribute, 
-            // we can approximate the correct behaviour by making the Returns attribute our "outputs" attribute. 
+            // Hack to help the 3.5 engine at least pretend to still be able to build on top of
+            // the 4.0 targets.  In cases where there is no Outputs attribute, just a Returns attribute,
+            // we can approximate the correct behaviour by making the Returns attribute our "outputs" attribute.
             if (this.outputsAttribute == null && returnsAttribute != null)
             {
                 this.outputsAttribute = returnsAttribute;
@@ -506,7 +506,7 @@ internal TargetExecutionWrapper ExecutionState
         #region Methods
 
         /// <summary>
-        /// Allows the caller to use a foreach loop to enumerate through the individual 
+        /// Allows the caller to use a foreach loop to enumerate through the individual
         /// BuildTask objects contained within this Target.
         /// </summary>
         /// <returns></returns>
@@ -559,8 +559,8 @@ ProjectBuildState buildContext
             switch (buildState)
             {
                 case BuildState.InProgress:
-                    // In single proc mode if the build state was already "in progress" 
-                    // and somebody just told us to build ourselves, it means that there is 
+                    // In single proc mode if the build state was already "in progress"
+                    // and somebody just told us to build ourselves, it means that there is
                     // a loop (circular dependency) in the target dependency graph. In multi
                     // proc mode we need to analyze the dependency graph before we can
                     // tell if there a circular dependency or if two independent chains
@@ -593,7 +593,7 @@ ProjectBuildState buildContext
                         (buildState == BuildState.CompletedSuccessfully) ? "TargetAlreadyCompleteSuccess" : "TargetAlreadyCompleteFailure",
                         this.targetName);
 
-                    // Only contexts which are generated from an MSBuild task could need 
+                    // Only contexts which are generated from an MSBuild task could need
                     // the outputs of this target, such contexts have a non-null evaluation
                     // request
                     if ((buildState == BuildState.CompletedSuccessfully) &&
@@ -746,7 +746,7 @@ internal XmlAttribute SetOrRemoveTargetAttribute
             string attributeValue
             )
         {
-            // If this Target object is not actually represented by a 
+            // If this Target object is not actually represented by a
             // <Target> element in the parentProject.file, then do not allow
             // the caller to set the condition.
             error.VerifyThrowInvalidOperation(this.targetElement != null, "CannotSetCondition");
diff --git a/src/Deprecated/Engine/Engine/TargetCollection.cs b/src/Deprecated/Engine/Engine/TargetCollection.cs
index a936991ff67..a10b4ee96a5 100644
--- a/src/Deprecated/Engine/Engine/TargetCollection.cs
+++ b/src/Deprecated/Engine/Engine/TargetCollection.cs
@@ -127,7 +127,7 @@ public Target this[string index]
         #region Methods
 
         /// <summary>
-        /// This ICollection method copies the contents of this collection to an 
+        /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -160,7 +160,7 @@ public IEnumerator GetEnumerator
         /// <summary>
         /// Adds a new Target to our collection.  This method does nothing
         /// to manipulate the project's XML content.
-        /// If a target with the same name already exists, it is replaced by 
+        /// If a target with the same name already exists, it is replaced by
         /// the new one.
         /// </summary>
         /// <param name="newTarget">target to add</param>
@@ -196,7 +196,7 @@ string targetName
             this.targetTable[targetName] = newTarget;
 
             // The project file has been modified and needs to be saved and re-evaluated.
-            // Also though, adding/removing a target requires us to re-walk all the XML 
+            // Also though, adding/removing a target requires us to re-walk all the XML
             // in order to re-compute out the "first logical target" as well as re-compute
             // the target overriding rules.
             this.parentProject.MarkProjectAsDirtyForReprocessXml();
@@ -229,7 +229,7 @@ Target targetToRemove
             this.parentProject.ProjectElement.RemoveChild(targetToRemove.TargetElement);
 
             // Remove the target from our hashtable, if it exists.  It might not exist, and that's okay.
-            // The reason it might not exist is because of target overriding, and the fact that 
+            // The reason it might not exist is because of target overriding, and the fact that
             // our hashtable only stores the *last* target of a given name.
             if ((Target)this.targetTable[targetToRemove.Name] == targetToRemove)
             {
@@ -240,7 +240,7 @@ Target targetToRemove
             targetToRemove.ParentProject = null;
 
             // The project file has been modified and needs to be saved and re-evaluated.
-            // Also though, adding/removing a target requires us to re-walk all the XML 
+            // Also though, adding/removing a target requires us to re-walk all the XML
             // in order to re-compute the "first logical target" as well as re-compute
             // the target overriding rules.
             this.parentProject.MarkProjectAsDirtyForReprocessXml();
diff --git a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
index 3578916f165..61b57ba2378 100644
--- a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
+++ b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
@@ -208,14 +208,14 @@ out Hashtable upToDateTargetInputs
                          * At this point, we know the following:
                          * 1) the target has outputs
                          * 2) the target has NO discrete outputs
-                         * 
+                         *
                          * This implies:
                          * 1) the target only references vectors (incl. transforms) in its outputs
                          * 2) all vectors referenced in the outputs are also referenced in the inputs
                          * 3) the referenced vectors are not empty
-                         * 
+                         *
                          * We can thus conclude: the target MUST have (non-discrete) inputs
-                         * 
+                         *
                          */
                         ErrorUtilities.VerifyThrow(itemVectorsReferencedInBothTargetInputsAndOutputs.Count > 0, "The target must have inputs.");
                         Debug.Assert(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs).Count > 0, "The target must have inputs.");
@@ -755,8 +755,8 @@ ArrayList targetOutputItemSpecs
         /// each "partition" Hashtable is indexed by the item vector itself.
         /// </remarks>
         /// <owner>SumedhK</owner>
-        /// <param name="attributeContainingItems">The XML attribute which we're operating on here.  
-        /// The sole purpose of passing in this parameter is to be able to provide line/column number 
+        /// <param name="attributeContainingItems">The XML attribute which we're operating on here.
+        /// The sole purpose of passing in this parameter is to be able to provide line/column number
         /// information in the event there's an error.</param>
         /// <param name="items"></param>
         /// <param name="bucket"></param>
@@ -918,7 +918,7 @@ internal static bool IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAn
             // Algorithm: walk through all the outputs to find the oldest output
             //            walk through the inputs as far as we need to until we find one that's newer (if any)
 
-            // PERF -- we could change this to ensure that we walk the shortest list first (because we walk that one entirely): 
+            // PERF -- we could change this to ensure that we walk the shortest list first (because we walk that one entirely):
             //         possibly the outputs list isn't actually the shortest list. However it always is the shortest
             //         in the cases I've seen, and adding this optimization would make the code hard to read.
 
@@ -1200,7 +1200,7 @@ private int CompareLastWriteTimes(string path1, string path2, out bool path1Does
 
         #endregion
 
-        // the project directory, all relative paths are 
+        // the project directory, all relative paths are
         // relative to here
         private string projectDirectory;
         // the target to analyze
diff --git a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
index b47e12001b6..84728a83d94 100644
--- a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
+++ b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
@@ -89,7 +89,7 @@ BuildEventContext targetBuildEventContext
 
         private bool haveRunANonIntrinsicTask = false;
 
-        // Lookup containing project content used to 
+        // Lookup containing project content used to
         // initialize the target batches
         private Lookup projectContent;
         private LookupEntry placeholderForClonedProjectContent;
@@ -139,9 +139,9 @@ internal void ContinueBuild
 
             try
             {
-                // In the single threaded mode we want to avoid looping all the way back to the 
+                // In the single threaded mode we want to avoid looping all the way back to the
                 // engine because there is no need for to be interruptable to address
-                // other build requests. Instead we loop inside this function untill the target is 
+                // other build requests. Instead we loop inside this function untill the target is
                 // fully built.
                 do
                 {
@@ -166,7 +166,7 @@ internal void ContinueBuild
                         ContinueBuildingErrorClause(buildContext);
                     }
 
-                    // In the single threaded mode we need to pull up the outputs of the previous 
+                    // In the single threaded mode we need to pull up the outputs of the previous
                     // step
                     if (parentEngine.Router.SingleThreadedMode &&
                         inProgressBuildState == InProgressBuildState.RunningTasks)
@@ -247,7 +247,7 @@ private void ContinueBuildingDependencies(ProjectBuildState buildContext)
                 return;
             }
 
-            // Now that the previous dependent target has been build we need to move to the next dependent target if 
+            // Now that the previous dependent target has been build we need to move to the next dependent target if
             // there is one
             currentDependentTarget++;
 
@@ -266,7 +266,7 @@ ProjectBuildState buildContext
                 string nameDependentTarget = dependsOnTargetNames[currentDependentTarget];
                 Target targetToBuild = parentProject.Targets[nameDependentTarget];
 
-                // If we couldn't find the dependent Target object, we have a problem. 
+                // If we couldn't find the dependent Target object, we have a problem.
                 ProjectErrorUtilities.VerifyThrowInvalidProject(targetToBuild != null, targetClass.DependsOnTargetsAttribute,
                     "TargetDoesNotExist", nameDependentTarget);
 
@@ -325,7 +325,7 @@ ProjectBuildState buildContext
                 string nameErrorTarget = onErrorTargets[currentErrorTarget];
                 Target targetToBuild = parentProject.Targets[nameErrorTarget];
 
-                // If we couldn't find the on error Target object, we have a problem. 
+                // If we couldn't find the on error Target object, we have a problem.
                 ProjectErrorUtilities.VerifyThrowInvalidProject(targetToBuild != null, targetElement,
                     "TargetDoesNotExist", nameErrorTarget);
 
@@ -434,7 +434,7 @@ bool startingFirstTask
             bool exitDueToError = true;
             try
             {
-                // If this is the first task - initialize for running it 
+                // If this is the first task - initialize for running it
                 if (startingFirstTask)
                 {
                     InitializeForRunningTargetBatches();
@@ -464,7 +464,7 @@ bool startingFirstTask
                         return;
                     }
 
-                    //Check if this was the last bucket 
+                    //Check if this was the last bucket
                     if (currentBucket == buckets.Count)
                     {
                         FinishRunningTargetBatches(buildContext);
@@ -569,7 +569,7 @@ private void InitializeForRunningSingleTargetBatch()
             if ((howToBuild != DependencyAnalysisResult.SkipNoInputs) &&
                 (howToBuild != DependencyAnalysisResult.SkipNoOutputs))
             {
-                // Within each target batch items are divided into lookup and execution; they must be 
+                // Within each target batch items are divided into lookup and execution; they must be
                 // kept separate: enforce this by cloning and entering scope
                 lookupForInference = bucket.Lookup;
                 lookupForExecution = bucket.Lookup.Clone();
@@ -691,7 +691,7 @@ private void ExecuteCurrentTask(ProjectBuildState buildContext)
 
             ErrorUtilities.VerifyThrow(taskElementList.Count > (currentTask - skippedNodeCount),
                 "The TaskElementCollection in this target doesn't have the same number of BuildTask objects as the number of actual task elements.");
-            // Send the task for execution 
+            // Send the task for execution
             SubmitNonIntrinsicTask(
                 (XmlElement)targetChildNode,
                 ((BuildTask)taskElementList[currentTask - skippedNodeCount]).HostObject,
@@ -839,8 +839,8 @@ private void ProcessTaskOutputs(TaskExecutionContext executionContext)
                     }
                     // We need to disable the execution of the task if it was previously enabled,
                     // and if were only doing execution we can stop processing at the point the
-                    // error occurred. If the task fails (which implies that ContinueOnError != 'true'), then do 
-                    // not execute the remaining tasks because they may depend on the completion 
+                    // error occurred. If the task fails (which implies that ContinueOnError != 'true'), then do
+                    // not execute the remaining tasks because they may depend on the completion
                     // of this task.
                     ErrorUtilities.VerifyThrow(howToBuild == DependencyAnalysisResult.FullBuild ||
                                                 howToBuild == DependencyAnalysisResult.IncrementalBuild,
@@ -910,7 +910,7 @@ private void FinishRunningTargetBatches(ProjectBuildState buildContext)
                 // used for dependency analysis, but we assume that's what the user intended
                 GatherTargetOutputs();
 
-                // Only contexts which are generated from an MSBuild task could need 
+                // Only contexts which are generated from an MSBuild task could need
                 // the outputs of the target, such contexts have a non-null evaluation
                 // request
                 if (buildContext.BuildRequest.OutputsByTarget != null &&
@@ -943,9 +943,9 @@ private void GatherTargetOutputs()
 
             XmlAttribute targetOutputsAttribute = targetElement.Attributes[XMakeAttributes.outputs];
 
-            // Hack to help the 3.5 engine at least pretend to still be able to build on top of 
-            // the 4.0 targets.  In cases where there is no Outputs attribute, just a Returns attribute, 
-            // we can approximate the correct behaviour by making the Returns attribute our "outputs" attribute. 
+            // Hack to help the 3.5 engine at least pretend to still be able to build on top of
+            // the 4.0 targets.  In cases where there is no Outputs attribute, just a Returns attribute,
+            // we can approximate the correct behaviour by making the Returns attribute our "outputs" attribute.
             if (targetOutputsAttribute == null)
             {
                 targetOutputsAttribute = targetElement.Attributes[XMakeAttributes.returns];
@@ -1010,7 +1010,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 waitingTargets.RemoveAt(0);
 
                 //Don't report any messages within the context in which the error occurred. That context
-                //is addressed as the base of the stack 
+                //is addressed as the base of the stack
                 if (buildContext == errorContext ||
                     buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.RequestFilled)
                 {
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index e7b5a534131..7d32fb9648c 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -300,7 +300,7 @@ internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
 
                 engineProxy?.MarkAsInActive();
 
-                // Now all task batches are done, apply all item adds to the outer 
+                // Now all task batches are done, apply all item adds to the outer
                 // target batch; we do this even if the task wasn't found (in that case,
                 // no items or properties will have been added to the scope)
                 if (buckets != null)
@@ -355,7 +355,7 @@ private bool ExecuteBucket(EngineProxy engineProxy, ItemBucket bucket, int bucke
             {
                 // Now that we know we will need to execute the task,
                 // Ensure the TaskEngine is initialized with the task class
-                // This does the work of task discovery, if it 
+                // This does the work of task discovery, if it
                 // hasn't already been done.
                 bool taskClassWasFound = FindTask();
 
@@ -738,7 +738,7 @@ private bool ExecuteInstantiatedTask(EngineProxy engineProxy, ItemBucket bucket,
                     {
                         loggingServices.LogTaskWarningFromException(buildEventContext, e,
                             // Don't try and log the line/column number for this error if
-                            // ContinueOnError=true, because it's too expensive to do so, 
+                            // ContinueOnError=true, because it's too expensive to do so,
                             // and this error may be fairly common and expected.
                             new BuildEventFileInfo(projectFileOfTaskNode), TaskName);
 
@@ -1189,8 +1189,8 @@ private List<TaskOutput> GetTaskOutputSpecifications(bool showWarnings)
                 {
                     TaskOutput taskOutputSpecification = new TaskOutput((XmlElement)childNode);
 
-                    // The "ItemName" attribute of the <Output> tag is usually just a straight 
-                    // string representing the item name.  If it contains any "@" signs, the 
+                    // The "ItemName" attribute of the <Output> tag is usually just a straight
+                    // string representing the item name.  If it contains any "@" signs, the
                     // project author most likely made a mistake, and so we throw a warning here.
                     XmlAttribute itemNameAttribute = taskOutputSpecification.ItemNameAttribute;
                     if (showWarnings && taskOutputSpecification.IsItemVector &&
@@ -1200,8 +1200,8 @@ private List<TaskOutput> GetTaskOutputSpecifications(bool showWarnings)
                             projectFileOfTaskNode), "AtSignInTaskOutputItemName", itemNameAttribute.Value);
                     }
 
-                    // The "PropertyName" attribute of the <Output> tag is usually just a straight 
-                    // string representing the property name.  If it contains any "$" signs, the 
+                    // The "PropertyName" attribute of the <Output> tag is usually just a straight
+                    // string representing the property name.  If it contains any "$" signs, the
                     // project author most likely made a mistake, and so we throw a warning here.
                     XmlAttribute propertyNameAttribute = taskOutputSpecification.PropertyNameAttribute;
                     if (showWarnings && taskOutputSpecification.IsProperty &&
@@ -1485,8 +1485,8 @@ out bool taskParameterSet
                     finalTaskInputs.AddRange(finalTaskItems);
                 }
 
-                // If there were no items, don't change the parameter's value.  EXCEPT if it's marked as a required 
-                // parameter, in which case we made an explicit decision to pass in an empty array.  This is 
+                // If there were no items, don't change the parameter's value.  EXCEPT if it's marked as a required
+                // parameter, in which case we made an explicit decision to pass in an empty array.  This is
                 // to avoid project authors having to add Conditions on all their tasks to avoid calling them
                 // when a particular item list is empty.  This way, we just call the task with an empty list,
                 // the task will loop over an empty list, and return quickly.
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
index 892ae43873b..d87825821f6 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
@@ -50,7 +50,7 @@ bool profileExecution
 
             SetBatchRequestSize();
 
-            // In singleproc mode the task execution module executes tasks on the engine thread. In multi proc mode a new thread is 
+            // In singleproc mode the task execution module executes tasks on the engine thread. In multi proc mode a new thread is
             // created so the TEM can submit tasks to a worker queue which will run the tasks on a new thread.
             if (moduleMode != TaskExecutionModuleMode.SingleProcMode)
             {
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionState.cs b/src/Deprecated/Engine/Engine/TaskExecutionState.cs
index 2da1fadc4bb..80fc3861753 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionState.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionState.cs
@@ -21,7 +21,7 @@ namespace Microsoft.Build.BuildEngine
     /// The node completes the class instantiating by providing the object with node side data.
     /// This class is distinct from the task engine in that it (possibly) travels cross process
     /// between the engine and the node carrying with it the data needed to instantiate the task
-    /// engine. The task engine can't subsume this class because the task engine is bound to the 
+    /// engine. The task engine can't subsume this class because the task engine is bound to the
     /// node process and can't travel cross process.
     /// </summary>
     internal class TaskExecutionState
@@ -216,8 +216,8 @@ internal void NotifyOfWait(long waitStartTime)
 
         #region MethodsNeededForUnitTesting
         /// <summary>
-        /// Since we could not derrive from TaskEngine and have no Interface, we need to overide the method in here and 
-        /// replace the calls when testing the class because of the calls to TaskEngine. If at a future time we get a mock task 
+        /// Since we could not derrive from TaskEngine and have no Interface, we need to overide the method in here and
+        /// replace the calls when testing the class because of the calls to TaskEngine. If at a future time we get a mock task
         /// engine, Interface or a non sealed TaskEngine these methods can disappear.
         /// </summary>
         /// <returns></returns>
diff --git a/src/Deprecated/Engine/Engine/TaskRegistry.cs b/src/Deprecated/Engine/Engine/TaskRegistry.cs
index b9769cbf454..0b8e3b7e7a3 100644
--- a/src/Deprecated/Engine/Engine/TaskRegistry.cs
+++ b/src/Deprecated/Engine/Engine/TaskRegistry.cs
@@ -30,7 +30,7 @@ namespace Microsoft.Build.BuildEngine
     /// <example>
     /// &lt;UsingTask TaskName="Microsoft.Build.Tasks.Csc"                     ==> look for the "Csc" task in the
     ///            AssemblyName="Microsoft.Build.Tasks"/&gt;                       weakly-named "Microsoft.Build.Tasks" assembly
-    /// 
+    ///
     /// &lt;UsingTask TaskName="t1"                                            ==> look for the "t1" task in the
     ///            AssemblyName="mytasks, Culture=en, Version=1.0.0.0"/&gt;        strongly-named "mytasks" assembly
     ///
diff --git a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
index a944142b0a3..8c60ecd9468 100644
--- a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
+++ b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
@@ -424,7 +424,7 @@ BuildResult[] buildResults
                 else if ((eventType == 1 && executionMode == NodeLoopExecutionMode.WaitingPassiveThread) ||
                          (eventType == 2 && executionMode == NodeLoopExecutionMode.WaitingActiveThread))
                 {
-                    // There maybe multiple results in the list so we need to loop over it 
+                    // There maybe multiple results in the list so we need to loop over it
                     // and store the results
                     int originalResultCount = resultCount;
                     lock (postedBuildResults)
@@ -532,7 +532,7 @@ internal int[] GetWaitingTasksData(List<BuildRequest[]> outstandingRequests)
                 int i = 0;
                 foreach (DictionaryEntry entry in waitingTasks)
                 {
-                    // Store the node proxy 
+                    // Store the node proxy
                     waitingTasksArray[i] = (int)entry.Key;
                     // Loop through the build requests and add uncomplete requests to the list
                     WaitingTaskData taskData = (WaitingTaskData)entry.Value;
@@ -597,7 +597,7 @@ internal void Shutdown()
         private WaitHandle[] WaitingActiveThreadWaitHandles;
         private WaitHandle[] WaitingPassiveThreadWaitHandles;
 
-        // Data shared between worked threads for one TEM, this data is initialized by the first 
+        // Data shared between worked threads for one TEM, this data is initialized by the first
         // thread
         private ManualResetEvent exitTaskThreads;          // Used to signal all threads to exit
         private ExitTaskCache exitTaskThreadsCache;        // cached value to avoid waiting on the kernel event
diff --git a/src/Deprecated/Engine/Engine/Toolset.cs b/src/Deprecated/Engine/Engine/Toolset.cs
index be0f64d822f..e67724efe90 100644
--- a/src/Deprecated/Engine/Engine/Toolset.cs
+++ b/src/Deprecated/Engine/Engine/Toolset.cs
@@ -22,7 +22,7 @@ public class Toolset
         // The MSBuildBinPath (and ToolsPath) for this tools version
         private string toolsPath;
 
-        // Properties 
+        // Properties
         private BuildPropertyGroup properties;
 
         /// <summary>
@@ -69,7 +69,7 @@ public string ToolsVersion
         }
 
         /// <summary>
-        /// Path to this toolset's tasks and targets. Corresponds to $(MSBuildToolsPath) in a project or targets file. 
+        /// Path to this toolset's tasks and targets. Corresponds to $(MSBuildToolsPath) in a project or targets file.
         /// </summary>
         public string ToolsPath
         {
diff --git a/src/Deprecated/Engine/Engine/ToolsetCollection.cs b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
index 78fa2e1cf1b..e5e85a280cb 100644
--- a/src/Deprecated/Engine/Engine/ToolsetCollection.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
@@ -21,14 +21,14 @@ namespace Microsoft.Build.BuildEngine
     /// </summary>
     public class ToolsetCollection : ICollection<Toolset>
     {
-        // the parent engine 
+        // the parent engine
         private Engine parentEngine = null;
 
         // underlying map keyed off toolsVersion
         private Dictionary<string, Toolset> toolsetMap = null;
 
         /// <summary>
-        /// Private default Ctor. Other classes should not be constructing 
+        /// Private default Ctor. Other classes should not be constructing
         /// instances of this class without providing an Engine object.
         /// </summary>
         private ToolsetCollection()
diff --git a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
index e2e91a177d0..dee78cabbf1 100644
--- a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
@@ -137,7 +137,7 @@ private ToolsetConfigurationSection ConfigurationSection
                     {
                         Configuration configuration = readApplicationConfiguration();
 
-                        // This will be null if the application config file does not have the following section 
+                        // This will be null if the application config file does not have the following section
                         // definition for the msbuildToolsets section as the first child element.
                         //   <configSections>
                         //     <section name=""msbuildToolsets"" type=""Microsoft.Build.BuildEngine.ToolsetConfigurationSection, Microsoft.Build.Engine"" />
@@ -153,8 +153,8 @@ private ToolsetConfigurationSection ConfigurationSection
                             configurationSection = configuration.GetSection("msbuildToolsets") as ToolsetConfigurationSection;
                         }
                     }
-                    // ConfigurationException is obsolete, but we catch it rather than 
-                    // ConfigurationErrorsException (which is what we throw below) because it is more 
+                    // ConfigurationException is obsolete, but we catch it rather than
+                    // ConfigurationErrorsException (which is what we throw below) because it is more
                     // general and we don't want to miss catching some other derived exception.
                     catch (ConfigurationException ex)
                     {
@@ -181,7 +181,7 @@ private ToolsetConfigurationSection ConfigurationSection
     /// <summary>
     /// This class is used to programmatically read msbuildToolsets section
     /// in from the configuration file.  An example of application config file:
-    /// 
+    ///
     /// &lt;configuration&gt;
     ///     &lt;msbuildToolsets default="2.0"&gt;
     ///         &lt;toolset toolsVersion="2.0"&gt;
@@ -193,7 +193,7 @@ private ToolsetConfigurationSection ConfigurationSection
     ///         &lt;/toolset&gt;
     ///     &lt;/msbuildToolsets&gt;
     /// &lt;/configuration&gt;
-    /// 
+    ///
     /// </summary>
     /// <remarks>
     /// Internal for unit testing only
@@ -201,7 +201,7 @@ private ToolsetConfigurationSection ConfigurationSection
     internal sealed class ToolsetConfigurationSection : ConfigurationSection
     {
         /// <summary>
-        /// toolsVersion element collection 
+        /// toolsVersion element collection
         /// </summary>
         [ConfigurationProperty("", IsDefaultCollection = true)]
         public ToolsetElementCollection Toolsets
@@ -392,7 +392,7 @@ public string toolsVersion
         }
 
         /// <summary>
-        /// Property element collection 
+        /// Property element collection
         /// </summary>
         [ConfigurationProperty("", IsDefaultCollection = true)]
         public PropertyElementCollection PropertyElements
@@ -479,7 +479,7 @@ protected override object GetElementKey(ConfigurationElement element)
 
             /// <summary>
             /// Collection type
-            /// This has to be public as cannot change access modifier when overriding  
+            /// This has to be public as cannot change access modifier when overriding
             /// </summary>
             public override ConfigurationElementCollectionType CollectionType
             {
diff --git a/src/Deprecated/Engine/Engine/ToolsetReader.cs b/src/Deprecated/Engine/Engine/ToolsetReader.cs
index e476e2b9a2e..14f68b2d47a 100644
--- a/src/Deprecated/Engine/Engine/ToolsetReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetReader.cs
@@ -115,11 +115,11 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
                                                BuildPropertyGroup initialProperties,
                                                ToolsetDefinitionLocations locations)
         {
-            // The 2.0 .NET Framework installer did not write a ToolsVersion key for itself in the registry. 
-            // The 3.5 installer writes one for 2.0, but 3.5 might not be installed.  
-            // The 4.0 and subsequent installers can't keep writing the 2.0 one, because (a) it causes SxS issues and (b) we 
+            // The 2.0 .NET Framework installer did not write a ToolsVersion key for itself in the registry.
+            // The 3.5 installer writes one for 2.0, but 3.5 might not be installed.
+            // The 4.0 and subsequent installers can't keep writing the 2.0 one, because (a) it causes SxS issues and (b) we
             // don't want it unless 2.0 is installed.
-            // So if the 2.0 framework is actually installed, and we're reading the registry, create a toolset for it. 
+            // So if the 2.0 framework is actually installed, and we're reading the registry, create a toolset for it.
             // The registry and config file can overwrite it.
             if (
                 ((locations & ToolsetDefinitionLocations.Registry) != 0) &&
@@ -186,7 +186,7 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
                     ErrorUtilities.VerifyThrow(Constants.defaultToolsVersion == "2.0", "Getting 2.0 FX path so default should be 2.0");
                     string pathToFramework = FrameworkLocationHelper.PathToDotNetFrameworkV20;
 
-                    // We could not find the default toolsversion because it was not installed on the machine. Fallback to the 
+                    // We could not find the default toolsversion because it was not installed on the machine. Fallback to the
                     // one we expect to always be there when running msbuild 4.0.
                     if (pathToFramework == null)
                     {
@@ -280,7 +280,7 @@ private void ReadEachToolset(ToolsetCollection toolsets,
         {
             foreach (PropertyDefinition toolsVersion in ToolsVersions)
             {
-                // We clone here because we don't want to interfere with the evaluation 
+                // We clone here because we don't want to interfere with the evaluation
                 // of subsequent Toolsets; otherwise, properties found during the evaluation
                 // of this Toolset would be persisted in initialProperties and appear
                 // to later Toolsets as Global or Environment properties from the Engine.
diff --git a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
index 46a2434dab9..1aca18c0ebd 100644
--- a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
@@ -154,7 +154,7 @@ private static string GetValue(RegistryKeyWrapper wrapper, string valueName)
                 object result = wrapper.GetValue(valueName);
 
                 // RegistryKey.GetValue returns null if the value is not present
-                // and String.Empty if the value is present and no data is defined. 
+                // and String.Empty if the value is present and no data is defined.
                 // We preserve this distinction, because a string property in the registry with
                 // no value really has an empty string for a value (which is a valid property value)
                 // rather than null for a value (which is an invalid property value)
diff --git a/src/Deprecated/Engine/Engine/UsingTask.cs b/src/Deprecated/Engine/Engine/UsingTask.cs
index 119da7388b2..1d51301bf7d 100644
--- a/src/Deprecated/Engine/Engine/UsingTask.cs
+++ b/src/Deprecated/Engine/Engine/UsingTask.cs
@@ -139,7 +139,7 @@ internal UsingTask(XmlElement usingTaskNode, bool isImported)
                         // ignore
                         break;
                     case XMakeElements.usingTaskParameterGroup:
-                        // ignore 
+                        // ignore
                         break;
                     default:
                         illegalChildElementFound = true;
@@ -153,9 +153,9 @@ internal UsingTask(XmlElement usingTaskNode, bool isImported)
                 }
             }
 
-            // UsingTask has no valid child elements in 3.5 syntax, but in 4.0 syntax it does. 
+            // UsingTask has no valid child elements in 3.5 syntax, but in 4.0 syntax it does.
             // So ignore any valid 4.0 child elements and try to load the project as usual, but
-            // still error out if something we don't expect is found. 
+            // still error out if something we don't expect is found.
             if (illegalChildElementFound)
             {
                 ProjectXmlUtilities.ThrowProjectInvalidChildElement(illegalChildElement);
diff --git a/src/Deprecated/Engine/Engine/Utilities.cs b/src/Deprecated/Engine/Engine/Utilities.cs
index f3ccf678690..a88f594fef9 100644
--- a/src/Deprecated/Engine/Engine/Utilities.cs
+++ b/src/Deprecated/Engine/Engine/Utilities.cs
@@ -30,7 +30,7 @@ public static class Utilities
         /// inside of a condition and the string values that they are being tested against.
         /// So, for example, if the condition was " '$(Configuration)' == 'Debug' ", we
         /// would get passed in leftValue="$(Configuration)" and rightValueExpanded="Debug".
-        /// This call would add the string "Debug" to the list of possible values for the 
+        /// This call would add the string "Debug" to the list of possible values for the
         /// "Configuration" property.
         ///
         /// This method also handles the case when two or more properties are being
@@ -73,7 +73,7 @@ string rightValueExpanded               // The fully expanded value on the right
                         string rightValueExpandedPiece;
 
                         // If there was no vertical bar, then just use the remainder of the right-hand-side
-                        // expression as the value of the property, and terminate the loop after this iteration.  
+                        // expression as the value of the property, and terminate the loop after this iteration.
                         // Also, if we're on the last segment of the left-hand-side, then use the remainder
                         // of the right-hand-side expression as the value of the property.
                         if ((indexOfVerticalBar == -1) || (i == (leftValuePieces.Length - 1)))
@@ -84,7 +84,7 @@ string rightValueExpanded               // The fully expanded value on the right
                         else
                         {
                             // If we found a vertical bar, then the portion before the vertical bar is the
-                            // property value which we will store in our table.  Then remove that portion 
+                            // property value which we will store in our table.  Then remove that portion
                             // from the original string so that the next iteration of the loop can easily search
                             // for the first vertical bar again.
                             rightValueExpandedPiece = rightValueExpanded.Substring(0, indexOfVerticalBar);
@@ -120,7 +120,7 @@ string rightValueExpanded               // The fully expanded value on the right
         /*
          * Method:  GatherReferencedPropertyNames
          * Owner:   DavidLe
-         * 
+         *
          * Find and record all of the properties that are referenced in the given
          * condition.
          *
@@ -137,7 +137,7 @@ Hashtable conditionedPropertiesTable  // Can be null
             EvaluateCondition(condition, conditionAttribute, expander, conditionedPropertiesTable, ParserOptions.AllowProperties | ParserOptions.AllowItemLists, null, null);
         }
 
-        // An array of hashtables with cached expression trees for all the combinations of condition strings 
+        // An array of hashtables with cached expression trees for all the combinations of condition strings
         // and parser options
         private static volatile Hashtable[] cachedExpressionTrees = new Hashtable[8 /* == ParserOptions.AllowAll*/]
             {
@@ -258,7 +258,7 @@ BuildEventContext buildEventContext
 
                 parsedExpression = conditionParser.Parse(condition, conditionAttribute, itemListOptions);
 
-                // It's possible two threads will add a different tree to the same entry in the hashtable, 
+                // It's possible two threads will add a different tree to the same entry in the hashtable,
                 // but it should be rare and it's not a problem - the previous entry will be thrown away.
                 // We could ensure no dupes with double check locking but it's not really necessary here.
                 // Also, we don't want to lock on every read.
@@ -308,7 +308,7 @@ internal static void SetXmlNodeInnerContents(XmlNode node, string s)
                 }
             }
 
-            // The value does not contain valid XML markup.  Store it as text, so it gets 
+            // The value does not contain valid XML markup.  Store it as text, so it gets
             // escaped properly.
             node.InnerText = s;
         }
@@ -323,10 +323,10 @@ internal static string GetXmlNodeInnerContents(XmlNode node)
         {
             // XmlNode.InnerXml gives back a string that consists of the set of characters
             // in between the opening and closing elements of the XML node, without doing any
-            // unescaping.  Any "strange" character sequences (like "<![CDATA[...]]>" will remain 
+            // unescaping.  Any "strange" character sequences (like "<![CDATA[...]]>" will remain
             // exactly so and will not be translated or interpreted.  The only modification that
             // .InnerXml will do is that it will normalize any Xml contained within.  This means
-            // normalizing whitespace between XML attributes and quote characters that surround XML 
+            // normalizing whitespace between XML attributes and quote characters that surround XML
             // attributes.  If PreserveWhitespace is false, then it will also normalize whitespace
             // between elements.
             //
@@ -353,19 +353,19 @@ internal static string GetXmlNodeInnerContents(XmlNode node)
             // use ... InnerXml or InnerText.  There are two basic scenarios we care about.
             //
             // 1.)  The first scenario is that the user is trying to create a property whose
-            //      contents are actually XML.  That is to say that the contents may be written 
+            //      contents are actually XML.  That is to say that the contents may be written
             //      to a XML file, or may be passed in as a string to XmlDocument.LoadXml.
-            //      In this case, we would want to use XmlNode.InnerXml, because we DO NOT want 
-            //      character sequences to be unescaped.  If we did unescape them, then whatever 
+            //      In this case, we would want to use XmlNode.InnerXml, because we DO NOT want
+            //      character sequences to be unescaped.  If we did unescape them, then whatever
             //      XML parser tried to read in the stream as XML later on would totally barf.
             //
             // 2.)  The second scenario is the the user is trying to create a property that
             //      is just intended to be treated as a string.  That string may be very large
             //      and could contain all sorts of whitespace, carriage returns, special characters,
-            //      etc.  But in the end, it's just a big string.  In this case, whatever 
+            //      etc.  But in the end, it's just a big string.  In this case, whatever
             //      task is actually processing this string ... it's not going to know anything
             //      about character sequences such as &amp; and &lt;.  These character sequences
-            //      are specific to XML markup.  So, here we want to use XmlNode.InnerText so that 
+            //      are specific to XML markup.  So, here we want to use XmlNode.InnerText so that
             //      the character sequences get unescaped into their actual character before
             //      the string is passed to the task (or wherever else the property is used).
             //      Of course, if the string value of the property needs to contain characters
diff --git a/src/Deprecated/Engine/Engine/XmlSearcher.cs b/src/Deprecated/Engine/Engine/XmlSearcher.cs
index 033ed172e99..ec51217b82f 100644
--- a/src/Deprecated/Engine/Engine/XmlSearcher.cs
+++ b/src/Deprecated/Engine/Engine/XmlSearcher.cs
@@ -57,8 +57,8 @@ out int foundColumnNumber
             // the given XmlNode in its original container document.  Element number is
             // simply a 1-based number identifying a particular XML element starting from
             // the beginning of the document, ignoring depth.  As you're walking the tree,
-            // visiting each node in order, and recursing deeper whenever possible, the Nth 
-            // element you visit has element number N.  Attribute number is simply the 
+            // visiting each node in order, and recursing deeper whenever possible, the Nth
+            // element you visit has element number N.  Attribute number is simply the
             // 1-based index of the attribute within the given Xml element.  An attribute
             // number of zero indicates that we're not searching for a particular attribute,
             // and all we care about is the element as a whole.
@@ -99,8 +99,8 @@ out int attributeNumber
 
             XmlNode elementToFind;
 
-            // First determine the XmlNode in the main hierarchy to search for.  If the passed-in 
-            // node is already an XmlElement or Text node, then we already have the node 
+            // First determine the XmlNode in the main hierarchy to search for.  If the passed-in
+            // node is already an XmlElement or Text node, then we already have the node
             // that we're searching for.  But if the passed-in node is an XmlAttribute, then
             // we want to search for the XmlElement that contains that attribute.
             // If the node is any other type, try the parent node. It's a better line number than no line number.
@@ -130,7 +130,7 @@ out int attributeNumber
             }
 
             // Figure out the element number for this particular XML element, by iteratively
-            // visiting every single node in the XmlDocument in sequence.  Start with the 
+            // visiting every single node in the XmlDocument in sequence.  Start with the
             // root node which is the XmlDocument node.
             XmlNode xmlNode = xmlNodeToFind.OwnerDocument;
             while (true)
@@ -182,7 +182,7 @@ out int attributeNumber
 
             if (xmlNode == null)
             {
-                // We visited every XmlElement in the document without finding the 
+                // We visited every XmlElement in the document without finding the
                 // specific XmlElement we were supposed to.  Oh well, too bad.
                 elementNumber = 0;
                 return false;
@@ -218,8 +218,8 @@ out int attributeNumber
         }
 
         /// <summary>
-        /// Read through the entire XML of a given project file, searching for the element/attribute 
-        /// specified by element number and attribute number.  Return the line number and column 
+        /// Read through the entire XML of a given project file, searching for the element/attribute
+        /// specified by element number and attribute number.  Return the line number and column
         /// number where it was found.
         /// </summary>
         /// <param name="projectFile">Path to project file on disk.</param>
@@ -257,7 +257,7 @@ out int foundColumnNumber
                     reader.DtdProcessing = DtdProcessing.Ignore;
                     int currentXmlElementNumber = 0;
 
-                    // While we haven't reached the end of the file, and we haven't found the 
+                    // While we haven't reached the end of the file, and we haven't found the
                     // specified node ...
                     while (reader.Read() && (foundColumnNumber == 0) && (foundLineNumber == 0))
                     {
@@ -291,7 +291,7 @@ out int foundColumnNumber
                                 else if (reader.MoveToFirstAttribute())
                                 {
                                     // Caller wants a particular attribute within the element,
-                                    // and the element does have 1 or more attributes.  So let's 
+                                    // and the element does have 1 or more attributes.  So let's
                                     // try to find the right one.
                                     int currentXmlAttributeNumber = 0;
 
diff --git a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
index 9a09530d884..f62d0a4f61d 100644
--- a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
@@ -75,7 +75,7 @@ public InvalidProjectFileException(string message, Exception innerException)
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
@@ -331,7 +331,7 @@ public string HelpKeyword
         }
 
         /// <summary>
-        /// Whether the exception has already been logged. Allows the exception to be logged at the 
+        /// Whether the exception has already been logged. Allows the exception to be logged at the
         /// most appropriate location, but continue to be propagated.
         /// </summary>
         internal bool HasBeenLogged
diff --git a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
index 7beacba7655..492a829536a 100644
--- a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
@@ -119,7 +119,7 @@ public string ErrorCode
 
         /// <summary>
         /// Throws an InvalidToolsetDefinitionException.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -138,7 +138,7 @@ params object[] args
         /// <summary>
         /// Throws an InvalidToolsetDefinitionException including a specified inner exception,
         /// which may be interesting to hosts.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
diff --git a/src/Deprecated/Engine/Errors/RemoteErrorException.cs b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
index a2e3e5493b6..a8d62fd2b3e 100644
--- a/src/Deprecated/Engine/Errors/RemoteErrorException.cs
+++ b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
@@ -32,7 +32,7 @@ internal RemoteErrorException(string message, Exception innerException, BuildEve
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
diff --git a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
index 43d4d1681f8..ab7cf76f593 100644
--- a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
+++ b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
@@ -146,7 +146,7 @@ internal bool FindCycles()
                     BreadthFirstTraversal(node);
                 }
             }
-            // Verify that all nodes have been reached 
+            // Verify that all nodes have been reached
             foreach (GraphNode node in dependencyGraph.Values)
             {
                 if (node.traversalIndex == GraphNode.InvalidIndex)
@@ -199,10 +199,10 @@ private void LinkCrossNodeBuildRequests()
                     }
 
                     // If the request being analyzed came from one of the child nodes, its incoming external request's
-                    // handleId will point at a routing context on the parent engine. If the outgoing request 
-                    // orginated from another child the two requests (outgoing and incoming) point at different 
-                    // routing contexts. In that case it is necessary to unwind the incoming request to the routing 
-                    // context of the outgoing request. If outgoing request originated from the parent node - 
+                    // handleId will point at a routing context on the parent engine. If the outgoing request
+                    // orginated from another child the two requests (outgoing and incoming) point at different
+                    // routing contexts. In that case it is necessary to unwind the incoming request to the routing
+                    // context of the outgoing request. If outgoing request originated from the parent node -
                     // there will be only one routing request.
                     if (node.targetState.TargetId.nodeId != 0)
                     {
diff --git a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
index 96b17f23abc..c3f7438d0a8 100644
--- a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
+++ b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class is used to construct and contain the state of an inprogress targets. The primary data
-    /// includes build requests blocked until this target completes and build requests that must complete 
+    /// includes build requests blocked until this target completes and build requests that must complete
     /// before this target can make forward process.
     /// </summary>
     internal class TargetInProgessState
@@ -87,7 +87,7 @@ internal TargetIdWrapper TargetId
         }
 
         /// <summary>
-        /// List of unique identifiers for the targets that are blocked until the current 
+        /// List of unique identifiers for the targets that are blocked until the current
         /// target completes
         /// </summary>
         internal List<TargetIdWrapper> ParentTargets
@@ -99,7 +99,7 @@ internal List<TargetIdWrapper> ParentTargets
         }
 
         /// <summary>
-        /// List of build requests that are blocked until the current 
+        /// List of build requests that are blocked until the current
         /// target completes
         /// </summary>
         internal List<BuildRequest> ParentBuildRequests
@@ -111,7 +111,7 @@ internal List<BuildRequest> ParentBuildRequests
         }
 
         /// <summary>
-        /// Array of build requests that must complete before the current 
+        /// Array of build requests that must complete before the current
         /// target can make forward process
         internal BuildRequest[] OutstandingBuildRequests
         {
@@ -233,7 +233,7 @@ out BuildRequest parentTriggeringRequest
                 {
                     return new TargetIdWrapper(((TaskExecutionContext)executionContext).ParentTarget);
                 }
-                // If the parent context if a routing context the parent target is not available 
+                // If the parent context if a routing context the parent target is not available
                 // on the current node, so store the request instead
                 else
                 {
@@ -604,7 +604,7 @@ public override int GetHashCode()
 
             // Target name
             internal string name;
-            // Id for the parent project 
+            // Id for the parent project
             internal int projectId;
             // Id for the node where the target exists
             internal int nodeId;
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index e398bba1776..338456d3812 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -53,7 +53,7 @@ public class BuildItem
 
         // This is the "Include" value of a virtual item. This
         // may contain wildcards.
-        // For persisted (non-virtual) items, the include is gotten from 
+        // For persisted (non-virtual) items, the include is gotten from
         // the backing xml; there is no point storing a copy here, and this
         // remains null.
         private string include = null;
@@ -400,7 +400,7 @@ internal BuildItem(XmlDocument ownerDocument, string name, string include, ItemD
         /// when a build generates a large number of items.
         /// </remarks>
         /// <param name="ownerDocument">can be null</param>
-        /// <param name="name">can be null</param> 
+        /// <param name="name">can be null</param>
         private BuildItem(XmlDocument ownerDocument, string name, string include, bool createCustomMetadataCache, ItemDefinitionLibrary itemDefinitionLibrary)
         {
             BuildItemHelper(ownerDocument, name, include, createCustomMetadataCache, itemDefinitionLibrary);
@@ -1133,7 +1133,7 @@ internal static BuildItem CreateClonedParentedItem(BuildItem childItem, BuildIte
         /// FUTURE: Currently this isn't done when the item is constructed; so for example HasMetadata will always return
         /// false until EvaluatedAllItemMetadata is explicitly called. The reason for this is that Metadata are
         /// not first class objects, they are merely string pairs produced by running over the child XML with a particular expander.
-        /// When Metadata are first class objects this method can be changed to merely evaluate them, 
+        /// When Metadata are first class objects this method can be changed to merely evaluate them,
         /// just as BuildItemGroup.Evaluate does for BuildItem, then methods like HasMetadata behave more sanely. Of course this
         /// could be a breaking change.
         /// </remarks>
@@ -1205,7 +1205,7 @@ public bool HasMetadata(string metadataName)
             ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
             ErrorUtilities.VerifyThrow(this.unevaluatedCustomMetadata != null, "Item not initialized properly. unevaluatedCustomAttributes is null.");
 #if DEBUG
-            // The hashtable of metadata (this.unevaluatedCustomMetadata) should never contain 
+            // The hashtable of metadata (this.unevaluatedCustomMetadata) should never contain
             // values for those reserved metadata that the engine provides (Filename, RelativeDir,
             // Extension, etc.).  The one exception is that the hashtable is allowed to contain
             // a value for "RecursiveDir" because that one is extra special ... tasks are allowed
@@ -1272,7 +1272,7 @@ public string GetMetadata(string metadataName)
         }
 
         /// <summary>
-        /// Retrieves an arbitrary metadata from the item element, expands any property and item references within it, and 
+        /// Retrieves an arbitrary metadata from the item element, expands any property and item references within it, and
         /// unescapes it.
         /// </summary>
         /// <remarks>Custom attributes on virtual items are not evaluated.</remarks>
@@ -1901,7 +1901,7 @@ public BuildItem Clone()
         }
 
         /// <summary>
-        /// Updates the build item xml backing store with the passed in xml backing store. 
+        /// Updates the build item xml backing store with the passed in xml backing store.
         /// </summary>
         internal void UpdateBackingXml(BuildItemGroupChildXml backingXml)
         {
diff --git a/src/Deprecated/Engine/Items/BuildItemGroup.cs b/src/Deprecated/Engine/Items/BuildItemGroup.cs
index 7d0238b9222..c3e6cb2d3c0 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroup.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroup.cs
@@ -350,7 +350,7 @@ internal void AddExistingItemAt(int index, BuildItem itemToAdd)
                 itemToAdd.ItemDefinitionLibrary = parentProject.ItemDefinitionLibrary;
             }
 
-            // If this BuildItemGroup is a persisted <ItemGroup>, then we need the 
+            // If this BuildItemGroup is a persisted <ItemGroup>, then we need the
             // items to have a reference back to their parent BuildItemGroup.  This
             // makes it *much* easier to delete items through the object model.
             if (IsPersisted)
@@ -383,11 +383,11 @@ internal void AddItem(BuildItem itemToAdd)
                 ErrorUtilities.VerifyThrow(itemToAdd.ItemElement.OwnerDocument == xml.OwnerDocument, "Cannot add an Item with a different XML owner document.");
 
                 // Generally, the desired behavior is to keep items of the same Type physically
-                // contiguous within the BuildItemGroup.  (It's just easier to read that way.)  So we 
+                // contiguous within the BuildItemGroup.  (It's just easier to read that way.)  So we
                 // scan through the existing items in our BuildItemGroup, and try to find the spot where
-                // the new item would fit in alphabetically.  This is nice because it helps 
-                // source code control scenarios where multiple clients are adding items to 
-                // the same list.  By putting them in alphabetical order, there's less of a 
+                // the new item would fit in alphabetically.  This is nice because it helps
+                // source code control scenarios where multiple clients are adding items to
+                // the same list.  By putting them in alphabetical order, there's less of a
                 // chance of merge conflicts.
                 int insertionIndex = items.Count;
                 for (int i = 0; i < items.Count; i++)
@@ -488,7 +488,7 @@ internal void RemoveItemWithBackup(BuildItem itemToRemove)
                 BackupPersistedItems();
             }
 
-            // Don't remove the XML node, or mark the itemgroup as dirty; this is 
+            // Don't remove the XML node, or mark the itemgroup as dirty; this is
             // strictly an operation on temporary items, because we'll be un-backing up the
             // persisted items at the end of the build
 
@@ -859,7 +859,7 @@ bool expandMetadata
                 BuildItemGroup itemizedGroup = expander.ExpandSingleItemListExpressionIntoItemsLeaveEscaped(itemIncludePieces[i], originalItem.IncludeAttribute);
                 if (itemizedGroup == null)
                 {
-                    // The expression did not represent a single @(...) item list reference. 
+                    // The expression did not represent a single @(...) item list reference.
                     if (expandMetadata)
                     {
                         // We're inside a target: metadata expressions like %(foo) are legal, so expand them now
diff --git a/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs b/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
index 4a08bf3edab..481b6a9e178 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.BuildEngine
     /// This class represents a collection of persisted &lt;ItemGroup&gt;'s.  Each
     /// MSBuild project has exactly one BuildItemGroupCollection, which includes
     /// all the imported ItemGroups as well as the ones in the main project file.
-    /// 
+    ///
     /// The implementation of this class is that it's basically a Facade.  It just
     /// calls into the GroupingCollection within the Project to do it's work.  It
     /// doesn't maintain any BuildPropertyGroup state on its own.
@@ -120,8 +120,8 @@ internal BuildItemGroup LastLocalItemGroup
                 {
                     if (itemGroup.IsImported)
                     {
-                        // As soon as we hit an imported BuildItemGroup, we want to 
-                        // completely bail out.  The goal of this function is 
+                        // As soon as we hit an imported BuildItemGroup, we want to
+                        // completely bail out.  The goal of this function is
                         // to return the last itemGroup that is *before* any
                         // imported itemGroups.
                         break;
@@ -141,7 +141,7 @@ internal BuildItemGroup LastLocalItemGroup
         #region Methods
 
         /// <summary>
-        /// This ICollection method copies the contents of this collection to an 
+        /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <owner>DavidLe</owner>
diff --git a/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs b/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
index 117abf65a61..a97cd96962d 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
@@ -10,12 +10,12 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
-    /// An enumerable wrapper for a hashtable-by-name of BuildItemGroups that allows read-only 
+    /// An enumerable wrapper for a hashtable-by-name of BuildItemGroups that allows read-only
     /// access to the items.
     /// </summary>
     /// <remarks>
     /// This class is designed to be passed to loggers.
-    /// The expense of copying items is only incurred if and when 
+    /// The expense of copying items is only incurred if and when
     /// a logger chooses to enumerate over it.
     /// </remarks>
     /// <owner>danmose</owner>
diff --git a/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs b/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
index a53bff392ac..345e22ce67d 100644
--- a/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
+++ b/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
@@ -173,7 +173,7 @@ private void MustBeEvaluated()
         /// <remarks>
         /// Only used by ItemDefinitionLibrary -- private and nested inside it as no other class should know about this.
         /// Since at present this has no OM or editing support, and is not passed around,
-        /// there are currently no separate classes for the child tags, and no separate BuildItemDefinitionGroup class. 
+        /// there are currently no separate classes for the child tags, and no separate BuildItemDefinitionGroup class.
         /// They can be broken out in future if necessary.
         /// </remarks>
         private class BuildItemDefinitionGroupXml
@@ -211,7 +211,7 @@ internal BuildItemDefinitionGroupXml(XmlElement element, Project parentProject)
             #region Public Methods
 
             /// <summary>
-            /// Given the properties and dictionary of previously encountered item definitions, evaluates 
+            /// Given the properties and dictionary of previously encountered item definitions, evaluates
             /// this group of item definitions and adds to the dictionary as necessary.
             /// </summary>
             /// <exception cref="InvalidProjectFileException">If the item definitions are incorrectly defined</exception>
@@ -233,7 +233,7 @@ internal void Evaluate(BuildPropertyGroup properties, ItemDefinitionsDictionary
             }
 
             /// <summary>
-            /// Given the properties and dictionary of previously encountered item definitions, evaluates 
+            /// Given the properties and dictionary of previously encountered item definitions, evaluates
             /// this specific item definition element and adds to the dictionary as necessary.
             /// </summary>
             /// <exception cref="InvalidProjectFileException">If the item definition is incorrectly defined</exception>
@@ -264,7 +264,7 @@ private void EvaluateItemDefinitionElement(XmlElement itemDefinitionElement, Bui
             }
 
             /// <summary>
-            /// Given the properties and dictionary of previously encountered item definitions, evaluates 
+            /// Given the properties and dictionary of previously encountered item definitions, evaluates
             /// this specific item definition child element and adds to the dictionary as necessary.
             /// </summary>
             /// <exception cref="InvalidProjectFileException">If the item definition is incorrectly defined</exception>
@@ -303,7 +303,7 @@ private void EvaluateItemDefinitionChildElement(XmlElement itemDefinitionChildEl
                     itemDefinitionsDictionary.Add(itemType, metadataDictionary);
                 }
 
-                // We only store the evaluated value; build items store the unevaluated value as well, but apparently only to 
+                // We only store the evaluated value; build items store the unevaluated value as well, but apparently only to
                 // gather recursive portions (its re-evaluation always goes back to the XML).
                 // Overwrite any existing default value for this particular metadata
                 metadataDictionary[itemDefinitionChildElement.Name] = evaluatedMetadataValue;
diff --git a/src/Deprecated/Engine/Items/ItemExpander.cs b/src/Deprecated/Engine/Items/ItemExpander.cs
index 8aa0fd4540c..0a07bfe84cd 100644
--- a/src/Deprecated/Engine/Items/ItemExpander.cs
+++ b/src/Deprecated/Engine/Items/ItemExpander.cs
@@ -131,7 +131,7 @@ ReadOnlyLookup readOnlyLookup
         /// <returns>Given string, with embedded item vectors expanded.</returns>
         internal static string ExpandEmbeddedItemVectors(string s, XmlNode parentNode, ReadOnlyLookup readOnlyLookup)
         {
-            // Before we do the expensive RegEx stuff, at least make sure there's 
+            // Before we do the expensive RegEx stuff, at least make sure there's
             // an @ sign in the expression somewhere.  If not, skip all the hard work.
             if (s.IndexOf('@') != -1)
             {
@@ -167,9 +167,9 @@ ReadOnlyLookup readOnlyLookup
         }
 
         /// <summary>
-        /// Attempts to extract the items in the given item vector expression. Item vectors embedded in strings, 
-        /// and item vectors with separator specifications are considered invalid, because it is not clear 
-        /// if those item vectors are meant to be lists or strings -- if the latter, the ExpandEmbeddedItemVectors() 
+        /// Attempts to extract the items in the given item vector expression. Item vectors embedded in strings,
+        /// and item vectors with separator specifications are considered invalid, because it is not clear
+        /// if those item vectors are meant to be lists or strings -- if the latter, the ExpandEmbeddedItemVectors()
         /// method should be used instead.
         /// </summary>
         /// <param name="itemVectorExpression"></param>
@@ -250,7 +250,7 @@ private static Match GetItemVectorMatches(string expression)
         {
             Match itemVectorMatch = null;
 
-            // Before we do the expensive RegEx stuff, at least make sure there's 
+            // Before we do the expensive RegEx stuff, at least make sure there's
             // an @ sign in the expression somewhere.  If not, skip all the hard work.
             if (expression.IndexOf('@') != -1)
             {
@@ -304,15 +304,15 @@ private BuildItemGroup ItemizeItemVector(Match itemVector)
 
         /// <summary>
         /// Expands a single item vector.
-        /// 
+        ///
         /// Item vectors are composed of a name, a transform, and a separator i.e.
-        /// 
+        ///
         ///     @(&lt;name&gt;->'&lt;transform&gt;','&lt;separator&gt;')
-        /// 
+        ///
         /// If a separator is not specified it defaults to a semi-colon. The transform expression is also optional, but if
         /// specified, it allows each item in the vector to have its item-spec converted to a different form. The transform
         /// expression can reference any custom metadata defined on the item, as well as the pre-defined item-spec modifiers.
-        /// 
+        ///
         /// NOTE:
         /// 1) white space between &lt;name&gt;, &lt;transform&gt; and &lt;separator&gt; is ignored
         ///    i.e. @(&lt;name&gt;, '&lt;separator&gt;') is valid
@@ -324,19 +324,19 @@ private BuildItemGroup ItemizeItemVector(Match itemVector)
         /// <remarks>This is the MatchEvaluator delegate passed to Regex.Replace().</remarks>
         /// <example>
         /// if @(files) is a vector for the files a.txt and b.txt, then:
-        /// 
+        ///
         ///     "my list: @(files)"                                 expands to      "my list: a.txt;b.txt"
-        /// 
+        ///
         ///     "my list: @(files,' ')"                             expands to      "my list: a.txt b.txt"
-        /// 
+        ///
         ///     "my list: @(files, '')"                             expands to      "my list: a.txtb.txt"
-        /// 
+        ///
         ///     "my list: @(files, '; ')"                           expands to      "my list: a.txt; b.txt"
-        /// 
+        ///
         ///     "my list: @(files->'%(Filename)')"                  expands to      "my list: a;b"
-        /// 
+        ///
         ///     "my list: @(files -> 'temp\%(Filename).xml', ' ')   expands to      "my list: temp\a.xml temp\b.xml"
-        /// 
+        ///
         ///     "my list: @(files->'')                              expands to      "my list: ;"
         /// </example>
         /// <owner>SumedhK</owner>
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index fe15c1e9287..6122f522356 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -38,7 +38,7 @@ internal static List<string> SplitSemiColonSeparatedList(string expression)
             string segment;
 
             // Walk along the string, keeping track of whether we are in an item list expression.
-            // If we hit a semi-colon or the end of the string and we aren't in an item list, 
+            // If we hit a semi-colon or the end of the string and we aren't in an item list,
             // add the segment to the list.
             for (int current = 0; current < expression.Length; current++)
             {
@@ -348,8 +348,8 @@ private static bool SinkValidName(string expression, ref int i, int end)
         }
 
         /// <summary>
-        /// Returns true if the character at the specified index 
-        /// is the specified char. 
+        /// Returns true if the character at the specified index
+        /// is the specified char.
         /// Leaves index one past the character.
         /// </summary>
         private static bool Sink(string expression, ref int i, char c)
diff --git a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
index db111e979dc..5d3c0c41de2 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
@@ -19,45 +19,45 @@ namespace Microsoft.Build.BuildEngine
     ///     - quick lookups
     ///     - scoping down of item subsets in nested scopes (useful for batches)
     ///     - isolation of adds, removes, modifies, and property sets inside nested scopes
-    ///     
+    ///
     /// When retrieving the item group for an item type, each table is consulted in turn,
     /// starting with the primary table (the "top" or "innermost" table), until a table is found that has an entry for that type.
     /// When an entry is found, it is returned without looking deeper.
     /// This makes it possible to let callers see only a subset of items without affecting or cloning the original item groups,
     /// by populating a scope with item groups that are empty or contain subsets of items in lower scopes.
-    /// 
+    ///
     /// Instances of this class can be cloned with Clone() to share between batches.
-    /// 
+    ///
     /// When EnterScope() is called, a fresh primary table is inserted, and all adds and removes will be invisible to
     /// any clones made before the scope was entered and anyone who has access to item groups in lower tables.
-    /// 
+    ///
     /// When LeaveScope() is called, the primary tables are merged into the secondary tables, and the primary tables are discarded.
     /// This makes the adds and removes in the primary tables visible to clones made during the previous scope.
-    /// 
+    ///
     /// Scopes can be populated (before Adds, Removes, and Lookups) using PopulateWithItem(). This reduces the set of items of a particular
     /// type that are visible in a scope, because lookups of items of this type will stop at this level and see the subset, rather than the
     /// larger set in a scope below.
-    /// 
+    ///
     /// Items can be added or removed by calling AddNewItem() and RemoveItem(). Only the primary level is modified.
     /// When items are added or removed they enter into a primary table exclusively for adds or removes, instead of the main primary table.
     /// This allows the adds and removes to be applied to the scope below on LeaveScope(). Even when LeaveScope() is called, the adds and removes
     /// stay in their separate add and remove tables: if they were applied to a main table, they could truncate the downward traversal performed by lookups
     /// and hide items in a lower main table. Only on the final call of LeaveScope() can all adds and removes be applied to the outermost table, i.e., the project.
-    /// 
+    ///
     /// Much the same applies to properties.
-    /// 
+    ///
     /// For sensible semantics, only the current primary scope can be modified at any point.
     /// </summary>
     /// <remarks>
     /// THREAD SAFETY:
-    ///     - BuildItemGroups are currently unsafe for concurrent reading and writing (they have a List field). So a Lookup cannot be read and written to 
+    ///     - BuildItemGroups are currently unsafe for concurrent reading and writing (they have a List field). So a Lookup cannot be read and written to
     ///       concurrently.
-    ///     - To avoid this problem, the lookup can be populated with a clone of an item group, and lookup can be Truncate()'d at the level of that clone 
+    ///     - To avoid this problem, the lookup can be populated with a clone of an item group, and lookup can be Truncate()'d at the level of that clone
     ///       until control of the lookup goes back to the safe thread.
-    /// 
+    ///
     /// FUTURE:
-    ///     - We could eliminate all the code performing resetting of project build state (currently implemented using special tables for Output properties and 
-    ///       backups of persisted item groups and metadata before modification) by using a Lookup, entering scope at the start of a build, 
+    ///     - We could eliminate all the code performing resetting of project build state (currently implemented using special tables for Output properties and
+    ///       backups of persisted item groups and metadata before modification) by using a Lookup, entering scope at the start of a build,
     ///       then when build state needs to be reset, throwing away the Lookup (rather than leaving scope).
     /// </remarks>
     internal class Lookup
@@ -81,7 +81,7 @@ internal class Lookup
 
         /// <summary>
         /// Projects store their items in a hashtable of item groups by name (which we handle in our lookup table)
-        /// but also in a single item group. When we leave scope the last time, we have to update this item group as 
+        /// but also in a single item group. When we leave scope the last time, we have to update this item group as
         /// well. This is only used when we leave scope the last time.
         /// </summary>
         private BuildItemGroup projectItems;
@@ -299,8 +299,8 @@ internal void LeaveScope()
             MustBeOwningThread();
             ErrorUtilities.VerifyThrowNoAssert(lookupEntries.Count >= 2, "Too many calls to Leave().");
 
-            // Our lookup works by stopping the first time it finds an item group of the appropriate type. 
-            // So we can't apply an add directly into the table below because that could create a new group 
+            // Our lookup works by stopping the first time it finds an item group of the appropriate type.
+            // So we can't apply an add directly into the table below because that could create a new group
             // of that type, which would cause the next lookup to stop there and miss any existing items in a table below.
             // Instead we keep adds stored separately until we're leaving the very last scope. Until then
             // we only move adds down into the next add table below, and when we lookup we consider both tables.
@@ -316,7 +316,7 @@ internal void LeaveScope()
 
             // Let go of our pointer into the clone table; we assume we won't need it after leaving scope and want to save memory.
             // This is an assumption on IntrinsicTask, that it won't ask to remove or modify a clone in a higher scope than it was handed out in.
-            // We mustn't call cloneTable.Clear() because other clones of this lookup may still be using it. When the last lookup clone leaves scope, 
+            // We mustn't call cloneTable.Clear() because other clones of this lookup may still be using it. When the last lookup clone leaves scope,
             // the table will be collected.
             cloneTable = null;
 
@@ -458,7 +458,7 @@ private void MergeScopeIntoLastScope()
         /// </summary>
         internal BuildProperty GetProperty(string name)
         {
-            // Walk down the tables and stop when the first 
+            // Walk down the tables and stop when the first
             // property with this name is found
             foreach (LookupEntry entry in lookupEntries)
             {
@@ -746,8 +746,8 @@ internal void RemoveItem(BuildItem item)
             PrimaryRemoveTable = Utilities.CreateTableIfNecessary(PrimaryRemoveTable);
             ImportItemIntoTable(PrimaryRemoveTable, item);
 
-            // No need to remove this item from the primary add table if it's 
-            // already there -- we always apply removes after adds, so that add 
+            // No need to remove this item from the primary add table if it's
+            // already there -- we always apply removes after adds, so that add
             // will be reversed anyway.
         }
 
@@ -763,7 +763,7 @@ internal void ModifyItems(string name, BuildItemGroup group, Dictionary<string,
             MustNotBeOuterScope();
 
 #if DEBUG
-            // This item should not already be in any remove table; there is no way a project can 
+            // This item should not already be in any remove table; there is no way a project can
             // modify items that were already removed
             // Obviously, do this only in debug, as it's a slow check for bugs.
             LinkedListNode<LookupEntry> node = lookupEntries.First;
@@ -1043,7 +1043,7 @@ private void MustNotBeInTable(Hashtable table, string name, BuildItemGroup group
 
         /// <summary>
         /// Verify item is not in any table in any scope
-        /// </summary>        
+        /// </summary>
         private void MustNotBeInAnyTables(BuildItem item)
         {
             // This item should not already be in any table; there is no way a project can
@@ -1088,7 +1088,7 @@ private void MustNotBeOuterScope()
     /// <summary>
     /// Read-only wrapper around a lookup.
     /// Passed to Expander and ItemExpander, which only need to
-    /// use a lookup in a read-only fashion, thus increasing 
+    /// use a lookup in a read-only fashion, thus increasing
     /// encapsulation of the data in the Lookup.
     /// </summary>
     internal class ReadOnlyLookup
@@ -1150,8 +1150,8 @@ internal LookupEntry(Hashtable items, BuildPropertyGroup properties)
 
         /// <summary>
         /// The main table, populated with items that
-        /// are initially visible in this scope. Does not 
-        /// include adds or removes unless it's the table in 
+        /// are initially visible in this scope. Does not
+        /// include adds or removes unless it's the table in
         /// the outermost scope.
         /// </summary>
         internal Hashtable Items
diff --git a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
index 8a68a2a2f19..6ccaf624e4e 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.BuildEngine
     /// This call is used to contain, serialize and deserialize arguments for call
     /// made via INodeProvider and IEngineCallback interfaces. To make calls via these
     /// interfaces asyncronous the parameters are queued up for a IO thread which
-    /// reads/writes the shared memory buffer to transfer these parameters cross 
+    /// reads/writes the shared memory buffer to transfer these parameters cross
     /// process.
     /// </summary>
     internal abstract class LocalCallDescriptor
@@ -316,7 +316,7 @@ internal BuildRequest[] BuildRequests
                 return buildRequests;
             }
         }
-        #endregion 
+        #endregion
 
         #region CustomSerializationToStream
         internal override void WriteToStream(BinaryWriter writer)
@@ -1439,7 +1439,7 @@ internal override void WriteToStream(BinaryWriter writer)
                 writer.Write((byte)1);
                 writer.Write(scopeName);
             }
-            #endregion 
+            #endregion
             #region ScopeProperties
             if (scopeProperties == null)
             {
@@ -1461,7 +1461,7 @@ internal override void WriteToStream(BinaryWriter writer)
                 writer.Write((byte)1);
                 writer.Write(scopeToolsVersion);
             }
-            #endregion 
+            #endregion
             writer.Write((byte)cacheContentType);
         }
         internal override void CreateFromStream(BinaryReader reader)
@@ -1572,7 +1572,7 @@ internal enum LocalCallType
         /// </summary>
         ShutdownNode = 8,
         /// <summary>
-        /// Call type for the node to indicate that it has shutdown 
+        /// Call type for the node to indicate that it has shutdown
         /// </summary>
         ShutdownComplete = 9,
         /// <summary>
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index e8b4a9f0417..73869190849 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -110,10 +110,10 @@ private void StartCommunicationThreads()
             // The writer thread should be created before the
             // reader thread because some LocalCallDescriptors
             // assume the shared memory for the writer thread
-            // has already been created. The method will both 
-            // instantiate the shared memory for the writer 
+            // has already been created. The method will both
+            // instantiate the shared memory for the writer
             // thread and also start the writer thread itself.
-            // We will verifyThrow in the method if the 
+            // We will verifyThrow in the method if the
             // sharedMemory was not created correctly.
             engineCallback.StartWriterThread(nodeNumber);
 
@@ -124,7 +124,7 @@ private void StartCommunicationThreads()
                         // Generate the name for the shared memory region
                         LocalNodeProviderGlobalNames.NodeInputMemoryName(nodeNumber),
                         SharedMemoryType.ReadOnly,
-                        // Reuse an existing shared memory region as it should have already 
+                        // Reuse an existing shared memory region as it should have already
                         // been created by the parent node side
                         true
                   );
@@ -150,7 +150,7 @@ private void StopCommunicationThreads()
             Thread writerThread = engineCallback.GetWriterThread();
             // The threads may not exist if the child has timed out before the parent has told the node
             // to start up its communication threads. This can happen if the node is started with /nodemode:x
-            // and no parent is running, or if the parent node has spawned a new process and then crashed 
+            // and no parent is running, or if the parent node has spawned a new process and then crashed
             // before establishing communication with the child node.
             writerThread?.Join();
 
@@ -263,7 +263,7 @@ public static void StartLocalNodeServer(int nodeNumber)
                     globalNodeActivate.Reset();
                     // Set the global inuse event so other parent processes know this node is now initialized
                     globalNodeInUse.Set();
-                    // Make a copy of the parents handle to protect ourselves in case the parent dies, 
+                    // Make a copy of the parents handle to protect ourselves in case the parent dies,
                     // this is to prevent a parent from reserving a node another parent is trying to use.
                     globalNodeReserveHandle =
                         new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeReserveEventName(nodeNumber));
@@ -359,7 +359,7 @@ private void SharedMemoryReaderThread()
                     {
                         // Read the list of LocalCallDescriptors from sharedMemory,
                         // this will be null if a large object is being read from shared
-                        // memory and will continue to be null until the large object has 
+                        // memory and will continue to be null until the large object has
                         // been completly sent.
                         IList localCallDescriptorList = sharedMemory.Read();
 
@@ -472,7 +472,7 @@ string parentStartupDirectory
 
             inUseEvent.Set();
 
-            // Clear the environment so that we dont have extra variables laying around, this 
+            // Clear the environment so that we dont have extra variables laying around, this
             // may be a performance hog but needs to be done
             IDictionary variableDictionary = Environment.GetEnvironmentVariables();
             foreach (string variableName in variableDictionary.Keys)
@@ -518,7 +518,7 @@ private bool IsParentProcessAlive()
 
             if (!isParentAlive)
             {
-                // No logging's going to reach the parent at this point: 
+                // No logging's going to reach the parent at this point:
                 // indicate on the console what's going on
                 string message = ResourceUtilities.FormatResourceString("ParentProcessUnexpectedlyDied", node.NodeId);
                 Console.WriteLine(message);
@@ -605,8 +605,8 @@ internal static string DumpFileName
         // This event is used to cause the child to create the shared memory structures to start communication
         // with the parent
         private static EventWaitHandle globalInitiateActivationEvent;
-        // This event is used to indicate to the parent that shared memory buffers have been created and are ready for 
-        // use 
+        // This event is used to indicate to the parent that shared memory buffers have been created and are ready for
+        // use
         private static EventWaitHandle globalNodeActivate;
         // Private local events
         private static ManualResetEvent communicationThreadExitEvent = new ManualResetEvent(false);
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
index d88fc4c9267..fd704d3f171 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
@@ -93,7 +93,7 @@ internal static string NodeInitiateActivationEventName(int nodeNumber)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="nodeNumber"></param>
         /// <returns></returns>
diff --git a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
index 7eb8902bcd6..6956ca4e3e0 100644
--- a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
+++ b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
@@ -38,7 +38,7 @@ internal enum ObjectType
         // Has the object been serialized using .net serialization (binary formatter)
         NetSerialization = 1,
         // Used to mark that the next int read represents how many bytes are in the
-        // large object which is about to be sent      
+        // large object which is about to be sent
         FrameMarker = 2,
         // Mark the end of the batch in sharedMemory.
         EndMarker = 3,
@@ -121,7 +121,7 @@ internal SharedMemory(string name, SharedMemoryType type, bool allowExistingMapp
                 InitializeStreams(type);
                 try
                 {
-                    // This could fail if two different administrator accounts try and 
+                    // This could fail if two different administrator accounts try and
                     // access each others nodes as events and semaphores are protected
                     // against cross account access
                     InitializeSynchronization();
@@ -156,8 +156,8 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
             IntPtr pSDNative = IntPtr.Zero;
             try
             {
-                // Check to see if the user is an administrator, this is done to prevent non 
-                // administrator processes from accessing the shared memory. On a vista machine 
+                // Check to see if the user is an administrator, this is done to prevent non
+                // administrator processes from accessing the shared memory. On a vista machine
                 // the check does not differentiate beween the application being elevated to have
                 // administrator rights or the application being started with administrator rights.
                 // If the user is an administator create a new set of securityAttributes which make
@@ -178,7 +178,7 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
                     Marshal.StructureToPtr(saAttr, pointerToSecurityAttributes, true);
                 }
 
-                // The file mapping has either the default (current user) security permissions or 
+                // The file mapping has either the default (current user) security permissions or
                 // permissions restricted to only administrator users depending on the check above.
                 // If pointerToSecurityAttributes is null the default permissions are used.
                 this.pageFileMapping =
@@ -213,7 +213,7 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
 
             if (!this.pageFileMapping.IsInvalid && !pageFileMapping.IsClosed)
             {
-                // Maps a view of a file mapping into the address space of the calling process so that we can use the 
+                // Maps a view of a file mapping into the address space of the calling process so that we can use the
                 // view to read and write to the shared memory region.
                 this.pageFileView =
                     NativeMethods.MapViewOfFile
@@ -375,7 +375,7 @@ private bool IsFull
             get
             {
                 // If the flag is set true is returned
-                // A timeout of 0 means the WaitOne will time out 
+                // A timeout of 0 means the WaitOne will time out
                 // instantly and return false if the flag is not set.
                 return fullFlag.WaitOne(0, false);
             }
@@ -603,7 +603,7 @@ private void SerializeCallDescriptorToStream(DualQueue<LocalCallDescriptor> obje
         {
             // Get the object by peeking at the queue rather than dequeueing the object. This is done
             // because we only want to dequeue the object when it has completely been put in shared memory.
-            // This may be done right away if the object is small enough to fit in the shared memory or 
+            // This may be done right away if the object is small enough to fit in the shared memory or
             // may happen after a the object is sent as a number of smaller chunks.
             object objectToWrite = objectsToWrite.Peek();
             Debug.Assert(objectToWrite != null, "Expect to get a non-null object from the queue");
@@ -703,19 +703,19 @@ internal IList Read()
             {
                 if (NumberOfUnreadBatches > 0)
                 {
-                    // The read stream is a memory stream where data read from the shared memory section 
-                    // will be copied to. From  this memory stream LocalCallDescriptors are deserialized. 
+                    // The read stream is a memory stream where data read from the shared memory section
+                    // will be copied to. From  this memory stream LocalCallDescriptors are deserialized.
                     // Stream position may not be 0 if we are reading a multipart object
                     int readStartPosition = (int)readStream.Position;
 
-                    // Read the first int from the memory file. This indicates the number of bytes written to 
+                    // Read the first int from the memory file. This indicates the number of bytes written to
                     // shared memory by the write method.
                     int endWritePosition = Marshal.ReadInt32((IntPtr)((int)pageFileView));
 
                     // Copy the bytes written into the shared memory section into the readStream memory stream.
                     Marshal.Copy
                     (
-                        (IntPtr)((int)pageFileView + 4 + readStream.Position), // Source 
+                        (IntPtr)((int)pageFileView + 4 + readStream.Position), // Source
                         readBuffer, //Destination
                         (int)(readStream.Position + (readBytesTotal - readBytesRemaining)), // Start Index
                         (int)(endWritePosition - readStream.Position) //Length of data
@@ -774,8 +774,8 @@ internal IList Read()
                             }
                         }
 
-                        // Deserialized the objects in the read stream and add them into the arrayList as long as 
-                        // we did not encounter a frameMarker which says a large object is next or the end marker 
+                        // Deserialized the objects in the read stream and add them into the arrayList as long as
+                        // we did not encounter a frameMarker which says a large object is next or the end marker
                         // which marks the end of the batch.
                         while (((int)ObjectType.EndMarker != objectId) && ((int)ObjectType.FrameMarker != objectId))
                         {
@@ -911,7 +911,7 @@ internal void Reset()
 
         private BinaryFormatter binaryFormatter;
 
-        // Binary reader and writer used to read and write from the memory streams used to contain the deserialized LocalCallDescriptors before and after they are copied 
+        // Binary reader and writer used to read and write from the memory streams used to contain the deserialized LocalCallDescriptors before and after they are copied
         // to and from the shared memory region.
         private BinaryWriter binaryWriter;
         private BinaryReader binaryReader;
@@ -926,8 +926,8 @@ internal void Reset()
         private MemoryStream readStream;
 
         // The count on a semaphore is decremented each time a thread enters the semaphore,
-        // and incremented when a thread releases the semaphore. 
-        // When the count is zero, subsequent requests block until other threads release the semaphore. 
+        // and incremented when a thread releases the semaphore.
+        // When the count is zero, subsequent requests block until other threads release the semaphore.
         // A semaphore is considered siginaled when the count > 1 and not siginaled when the count is 0.
 
         // unreadBatchCounter is used to track how many batches are remaining to be read from shared memory.
@@ -960,10 +960,10 @@ internal void Reset()
 
         // Because we are using reflection to get the writeToStream and readFromStream methods from the classes in the framework assembly we found
         // we were spending a lot of time reflecting for these methods. The loggingTypeCache, caches the methodInfo for the classes and then look them
-        // up when serializing or deserializing the objects. 
+        // up when serializing or deserializing the objects.
         private Hashtable loggingTypeCache;
 
-        // Keep a pointer to the queue which contains the large object which is being deserialized. We do this because we want to make sure 
+        // Keep a pointer to the queue which contains the large object which is being deserialized. We do this because we want to make sure
         // after the object is properly sent we dequeue off the correct queue.
         private DualQueue<LocalCallDescriptor> largeObjectsQueue;
         #endregion
diff --git a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
index 81bcca5a7f1..e95d131901a 100644
--- a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
@@ -137,7 +137,7 @@ public void ParseParameters()
         }
 
         /// <summary>
-        /// An implementation of IComparer useful for comparing the keys 
+        /// An implementation of IComparer useful for comparing the keys
         /// on DictionaryEntry's
         /// </summary>
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
@@ -153,7 +153,7 @@ public int Compare(Object a, Object b)
         }
 
         /// <summary>
-        /// An implementation of IComparer useful for comparing the ItemSpecs 
+        /// An implementation of IComparer useful for comparing the ItemSpecs
         /// on ITaskItem's
         /// </summary>
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
@@ -238,7 +238,7 @@ internal void WriteLinePrettyFromResource(int indentLevel, string resourceString
         }
 
         /// <summary>
-        /// Writes to the log, using the default indentation. Does not 
+        /// Writes to the log, using the default indentation. Does not
         /// terminate with a newline.
         /// </summary>
         internal void WritePretty(string formattedString)
@@ -291,7 +291,7 @@ internal void ShowPerfSummary()
         }
 
         /// <summary>
-        /// Writes to the log, using the specified indentation. Does not 
+        /// Writes to the log, using the specified indentation. Does not
         /// terminate with a newline.
         /// </summary>
         internal void WritePretty(int indentLevel, string formattedString)
@@ -448,7 +448,7 @@ internal void InitializeConsoleMethods(LoggerVerbosity logverbosity, WriteHandle
         /// <summary>
         /// Writes out the list of property names and their values.
         /// This could be done at any time during the build to show the latest
-        /// property values, using the cached reference to the list from the 
+        /// property values, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="properties">List of properties</param>
@@ -502,7 +502,7 @@ internal virtual void OutputProperties(ArrayList list)
         /// <summary>
         /// Writes out the list of item specs and their metadata.
         /// This could be done at any time during the build to show the latest
-        /// items, using the cached reference to the list from the 
+        /// items, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="items">List of items</param>
@@ -765,7 +765,7 @@ internal virtual void PrintCounterMessage(WriteLinePrettyFromResourceDelegate Wr
             }
 
             /// <summary>
-            /// Returns an IComparer that will put erformance counters 
+            /// Returns an IComparer that will put erformance counters
             /// in descending order by elapsed time.
             /// </summary>
             internal static IComparer DescendingByElapsedTimeComparer
@@ -774,7 +774,7 @@ internal static IComparer DescendingByElapsedTimeComparer
             }
 
             /// <summary>
-            /// Private IComparer class for sorting performance counters 
+            /// Private IComparer class for sorting performance counters
             /// in descending order by elapsed time.
             /// </summary>
             internal class DescendingByElapsedTime : IComparer
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index 049c264d0ac..6405295a126 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -36,8 +36,8 @@ namespace Microsoft.Build.BuildEngine
 
     /// <summary>
     /// This class implements the default logger that outputs event data
-    /// to the console (stdout). 
-    /// It is a facade: it creates, wraps and delegates to a kind of BaseConsoleLogger, 
+    /// to the console (stdout).
+    /// It is a facade: it creates, wraps and delegates to a kind of BaseConsoleLogger,
     /// either SerialConsoleLogger or ParallelConsoleLogger.
     /// </summary>
     /// <remarks>This class is not thread safe.</remarks>
@@ -287,7 +287,7 @@ protected WriteHandler WriteHandler
 
         /// <summary>
         /// Apply a parameter.
-        /// NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has 
+        /// NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has
         /// no good reason for being public.
         /// </summary>
         public void ApplyParameter(string parameterName, string parameterValue)
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index 334a6a4c43d..05f5b1d2269 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -196,7 +196,7 @@ public string Parameters
         #region Data
         // The file logger which will do the actual logging of the node's build output
         private FileLogger nodeFileLogger;
-        // Reference for the central logger 
+        // Reference for the central logger
         private IEventRedirector buildEventRedirector;
 
         // The Id of the node the forwardingLogger is attached to
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index 1f574b8af5e..25db6182dcf 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// A specialization of the ConsoleLogger that logs to a file instead of the console.
-    /// The output in terms of what is written and how it looks is identical. For example you can 
+    /// The output in terms of what is written and how it looks is identical. For example you can
     /// log verbosely to a file using the FileLogger while simultaneously logging only high priority events
     /// to the console using a ConsoleLogger.
     /// </summary>
diff --git a/src/Deprecated/Engine/Logging/LogFormatter.cs b/src/Deprecated/Engine/Logging/LogFormatter.cs
index 34d8ee31a0c..dfa7ff4a349 100644
--- a/src/Deprecated/Engine/Logging/LogFormatter.cs
+++ b/src/Deprecated/Engine/Logging/LogFormatter.cs
@@ -22,7 +22,7 @@ internal static class LogFormatter
         internal static string FormatLogTimeStamp(DateTime timeStamp)
         {
             // From http://msdn2.microsoft.com/en-us/library/8kb3ddd4.aspx
-            // Custom DateTime Format Strings  
+            // Custom DateTime Format Strings
             //
             // HH Represents the hour as a number from 00 through 23, that is,
             //    the hour as represented by a zero-based 24-hour clock that counts the hours since midnight.
diff --git a/src/Deprecated/Engine/Logging/LoggerDescription.cs b/src/Deprecated/Engine/Logging/LoggerDescription.cs
index 227d86a6940..fabc6e48949 100644
--- a/src/Deprecated/Engine/Logging/LoggerDescription.cs
+++ b/src/Deprecated/Engine/Logging/LoggerDescription.cs
@@ -317,7 +317,7 @@ internal void CreateFromStream(BinaryReader reader)
             {
                 loggerClassName = reader.ReadString();
             }
-            #endregion 
+            #endregion
             #region LoggerSwitchParameters
             if (reader.ReadByte() == 0)
             {
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index f90d16e88e4..ecf3dc192b4 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -152,7 +152,7 @@ private void ShownBuildEventContext(BuildEventContext e)
 
         /// <summary>
         /// Reset the states of per-build member variables
-        /// VSW#516376 
+        /// VSW#516376
         /// </summary>
         internal override void ResetConsoleLoggerState()
         {
@@ -293,7 +293,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
                 // if verbosity is normal, detailed or diagnostic
                 if (IsVerbosityAtLeast(LoggerVerbosity.Normal))
                 {
-                    // The time elapsed is the difference between when the BuildStartedEventArg 
+                    // The time elapsed is the difference between when the BuildStartedEventArg
                     // was created and when the BuildFinishedEventArg was created
                     string timeElapsed = LogFormatter.FormatTimeSpan(e.Timestamp - buildStarted);
 
@@ -307,7 +307,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// Does this in a "flat" style, without context.
         /// </summary>
@@ -319,7 +319,7 @@ private void ShowFlatErrorWarningSummary()
             }
 
             // If we're showing only warnings and/or errors, don't summarize.
-            // This is the buildc.err case. There's no point summarizing since we'd just 
+            // This is the buildc.err case. There's no point summarizing since we'd just
             // repeat the entire log content again.
             if (showOnlyErrors || showOnlyWarnings)
             {
@@ -352,7 +352,7 @@ private void ShowFlatErrorWarningSummary()
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// Does this in a "nested" style.
         /// </summary>
@@ -364,7 +364,7 @@ private void ShowNestedErrorWarningSummary()
             }
 
             // If we're showing only warnings and/or errors, don't summarize.
-            // This is the buildc.err case. There's no point summarizing since we'd just 
+            // This is the buildc.err case. There's no point summarizing since we'd just
             // repeat the entire log content again.
             if (showOnlyErrors || showOnlyWarnings)
             {
@@ -397,13 +397,13 @@ private void ShowErrorWarningSummary<T>(ArrayList listToProcess) where T : Build
                 T errorWarningEventArgs = (T)listToProcess[listCount];
 
                 // Target event may be null for a couple of reasons:
-                // 1) If the event was from a project load, or engine 
+                // 1) If the event was from a project load, or engine
                 // 2) If the flushing of the event queue for each request and result is turned off
                 // as this could cause errors and warnings to be seen by the logger after the target finished event
                 // which would cause the error or warning to have no matching target started event as they are removed
                 // when a target finished event is logged.
-                // 3) On NORMAL verbosity if the error or warning occurres in a project load then the error or warning and the target started event will be forwarded to 
-                // different forwarding loggers which cannot communicate to each other, meaning there will be no matching target started event logged 
+                // 3) On NORMAL verbosity if the error or warning occurres in a project load then the error or warning and the target started event will be forwarded to
+                // different forwarding loggers which cannot communicate to each other, meaning there will be no matching target started event logged
                 // as the forwarding logger did not know to forward the target started event
                 string targetName = null;
                 TargetStartedEventMinimumFields targetEvent = buildEventManager.GetTargetStartedEvent(errorWarningEventArgs.BuildEventContext);
@@ -591,7 +591,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                             }
                         }
 
-                        // In single proc only make a space between the project done event and the next line, this 
+                        // In single proc only make a space between the project done event and the next line, this
                         // is to increase the readability on the single proc log when there are a number of done events
                         // or a mix of done events and project started events. Also only do this on the console and not any log file.
                         if (numberOfProcessors == 1 && runningWithCharacterFileType)
@@ -611,7 +611,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
         /// <summary>
         /// Writes out the list of property names and their values.
         /// This could be done at any time during the build to show the latest
-        /// property values, using the cached reference to the list from the 
+        /// property values, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="properties">List of properties</param>
@@ -653,7 +653,7 @@ internal override void OutputProperties(ArrayList list)
         /// <summary>
         /// Writes out the list of item specs and their metadata.
         /// This could be done at any time during the build to show the latest
-        /// items, using the cached reference to the list from the 
+        /// items, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="items">List of items</param>
@@ -851,10 +851,10 @@ public override void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
         public override void ErrorHandler(object sender, BuildErrorEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
-            // Keep track of the number of error events raisd 
+            // Keep track of the number of error events raisd
             errorCount++;
 
-            // If there is an error we need to walk up the call stack and make sure that 
+            // If there is an error we need to walk up the call stack and make sure that
             // the project started events back to the root project know an error has occurred
             // and are not removed when they finish
             buildEventManager.SetErrorWarningFlagOnCallStack(e.BuildEventContext);
@@ -900,7 +900,7 @@ public override void WarningHandler(object sender, BuildWarningEventArgs e)
             // Keep track of the number of warning events raised during the build
             warningCount++;
 
-            // If there is a warning we need to walk up the call stack and make sure that 
+            // If there is a warning we need to walk up the call stack and make sure that
             // the project started events back to the root project know a warning has ocured
             // and are not removed when they finish
             buildEventManager.SetErrorWarningFlagOnCallStack(e.BuildEventContext);
@@ -984,7 +984,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
 
             if (print)
             {
-                // If the event has a valid Project contextId but the project started event has not been fired, the message needs to be 
+                // If the event has a valid Project contextId but the project started event has not been fired, the message needs to be
                 // buffered until the project started event is fired
                 if (
                        hasBuildStarted
@@ -1022,14 +1022,14 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
                 return;
             }
 
-            // Display any project started events which were deferred until a visible 
+            // Display any project started events which were deferred until a visible
             // message from their project is displayed
             if (IsVerbosityAtLeast(LoggerVerbosity.Normal))
             {
                 DisplayDeferredProjectStartedEvent(e);
             }
 
-            // Display any target started events which were deferred until a visible 
+            // Display any target started events which were deferred until a visible
             // message from their target is displayed
             if (IsVerbosityAtLeast(LoggerVerbosity.Detailed))
             {
@@ -1185,7 +1185,7 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
                     // Take into account the new line char which will be added to the end or each reformatted string
                     int bufferWidthMinusNewLine = bufferWidth - 1;
 
-                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. 
+                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages.
                     // If there is not enough room just print the message out and let the console do the formatting
                     bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;
                     bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 919014c2898..648e5f48a44 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -295,7 +295,7 @@ public int GetHashCode(T x)
     }
 
     /// <summary>
-    /// This class stands in for a full project started event because it contains only the 
+    /// This class stands in for a full project started event because it contains only the
     /// minimum amount of inforomation needed for the logger
     /// </summary>
     internal class ProjectStartedEventMinimumFields
@@ -430,7 +430,7 @@ internal ProjectStartedEventMinimumFields(int projectKey, int entryPointKey, Pro
     }
 
     /// <summary>
-    /// This class stands in for a full target started event because it contains only the 
+    /// This class stands in for a full target started event because it contains only the
     /// minimum amount of inforomation needed for the logger
     /// </summary>
     internal class TargetStartedEventMinimumFields
@@ -517,7 +517,7 @@ internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent)
     }
 
     /// <summary>
-    /// This class is used as a key to group warnings and errors by the project entry point and the target they 
+    /// This class is used as a key to group warnings and errors by the project entry point and the target they
     /// error or warning was in
     /// </summary>
     internal class ErrorWarningSummaryDictionaryKey
diff --git a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
index 35a75e0f540..7fd23470acf 100644
--- a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
@@ -72,7 +72,7 @@ ColorResetter colorReset
 
         /// <summary>
         /// Reset the states of per-build member variables
-        /// VSW#516376 
+        /// VSW#516376
         /// </summary>
         internal override void ResetConsoleLoggerState()
         {
@@ -182,7 +182,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// </summary>
         private void ShowErrorWarningSummary()
@@ -300,7 +300,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                 counter.InScope = false;
             }
 
-            // if verbosity is detailed or diagnostic, 
+            // if verbosity is detailed or diagnostic,
             // or there was an error or warning
             if (contextStack.Peek().hasErrorsOrWarnings
                 || (IsVerbosityAtLeast(LoggerVerbosity.Detailed)))
@@ -379,7 +379,7 @@ public override void TargetFinishedHandler(object sender, TargetFinishedEventArg
 
             bool targetHasErrorsOrWarnings = contextStack.Peek().hasErrorsOrWarnings;
 
-            // if verbosity is diagnostic, 
+            // if verbosity is diagnostic,
             // or there was an error or warning and verbosity is normal or detailed
             if ((targetHasErrorsOrWarnings && (IsVerbosityAtLeast(LoggerVerbosity.Normal)))
                   || Verbosity == LoggerVerbosity.Diagnostic)
@@ -882,8 +882,8 @@ string parent
 
             /// <summary>
             /// For TargetStarted events, this stores the filename where the Target is defined
-            /// (e.g., Microsoft.Common.targets).  This is different than the project that is 
-            /// being built.  
+            /// (e.g., Microsoft.Common.targets).  This is different than the project that is
+            /// being built.
             /// For ProjectStarted events, this is null.
             /// </summary>
             internal string file;
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index 80cb2bc1705..a90066fefd3 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -27,19 +27,19 @@ internal enum PropertyType
         // by the author.
         NormalProperty,
 
-        // An "imported" property is like a "normal" property, except that 
+        // An "imported" property is like a "normal" property, except that
         // instead of coming directly from the project file, its definition
         // is in one of the imported files (e.g., "CSharp.buildrules").
         ImportedProperty,
 
         // A "global" property is the kind that is set outside of the project file.
         // Once such a property is set, it cannot be overridden by the project file.
-        // For example, when the user sets a property via a switch on the XMake 
+        // For example, when the user sets a property via a switch on the XMake
         // command-line, this is a global property.  In the IDE case, "Configuration"
         // would be a global property set by the IDE.
         GlobalProperty,
 
-        // A "reserved" property behaves much like a read-only property, except 
+        // A "reserved" property behaves much like a read-only property, except
         // that the names are not arbitrary; they are chosen by us.  Also,
         // no user can ever set or override these properties.  For example,
         // "XMakeProjectName" would be a property that is only settable by
@@ -88,15 +88,15 @@ public class BuildProperty
         // this node may look like this:
         //      <WarningLevel Condition="...">4</WarningLevel>
         //
-        // If this property is not represented by an actual XML element in the 
+        // If this property is not represented by an actual XML element in the
         // project file, it's okay if this is null.
         private XmlElement propertyElement = null;
 
-        // This is the specific XML attribute in the above XML element which 
+        // This is the specific XML attribute in the above XML element which
         // contains the "Condition".
         private XmlAttribute conditionAttribute = null;
 
-        // If this property is persisted in the project file, then we need to 
+        // If this property is persisted in the project file, then we need to
         // store a reference to the parent <PropertyGroup>.
         private BuildPropertyGroup parentPersistedPropertyGroup = null;
 
@@ -696,7 +696,7 @@ internal bool IsEquivalent
             BuildProperty compareToProperty
         )
         {
-            // Intentionally do not compare parentPersistedPropertyGroup, because this is 
+            // Intentionally do not compare parentPersistedPropertyGroup, because this is
             // just a back-pointer, and doesn't really contribute to the "identity" of
             // the property.
 
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index c067add2c83..ecbd7f6b82b 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -32,7 +32,7 @@ public class BuildPropertyGroup : IItemPropertyGrouping, IEnumerable
 
         // This is the XML element representing the <PropertyGroup> in the XMake
         // project file.  If this BuildPropertyGroup object doesn't represent an
-        // actual <PropertyGroup> element in the XMake project file, it's 
+        // actual <PropertyGroup> element in the XMake project file, it's
         // okay if this remains null throughout the life of this object.
         private XmlElement propertyGroupElement = null;
 
@@ -66,7 +66,7 @@ public class BuildPropertyGroup : IItemPropertyGrouping, IEnumerable
         // in the order that they appear in the project file.  In this list,
         // there can be multiple properties of the same name.  This member
         // is only valid (non-null) if this is a persisted <PropertyGroup>.
-        // For virtual property groups (e.g., evaluated property groups, 
+        // For virtual property groups (e.g., evaluated property groups,
         // global property groups, etc.), this will remain null.
         private ArrayList propertyList = null;
 
@@ -343,7 +343,7 @@ public string Condition
 
             set
             {
-                // If this BuildPropertyGroup object is not actually represented by a 
+                // If this BuildPropertyGroup object is not actually represented by a
                 // <PropertyGroup> element in the project file, then do not allow
                 // the caller to set the condition.
                 MustBePersisted("CannotSetCondition", null);
@@ -363,7 +363,7 @@ public string Condition
         /// </summary>
         public void SetImportedPropertyGroupCondition(string condition)
         {
-            // If this BuildPropertyGroup object is not actually represented by a 
+            // If this BuildPropertyGroup object is not actually represented by a
             // <PropertyGroup> element in the project file, then do not allow
             // the caller to set the condition.
             MustBePersisted("CannotSetCondition", null);
@@ -538,12 +538,12 @@ public BuildProperty this[string propertyName]
             get
             {
                 // We don't support this method for PropertyGroups that are persisted.
-                // This is because persisted PropertyGroups can contain multiple 
+                // This is because persisted PropertyGroups can contain multiple
                 // properties with the same name, so you can't index by name.
                 MustBeVirtual("CannotAccessPropertyByName");
 
-                // Do the lookup in the hash table using the hash table's 
-                // indexer method.  Get back the property data object, 
+                // Do the lookup in the hash table using the hash table's
+                // indexer method.  Get back the property data object,
                 // which will be "null" if the property hasn't been set. Note
                 // that we key off property names in a case-insensitive fashion.
                 return (BuildProperty)propertyTableByName[propertyName];
@@ -630,7 +630,7 @@ bool deepClone
 
                 if (deepClone)
                 {
-                    // Loop through every BuildProperty in our collection, and add those same properties 
+                    // Loop through every BuildProperty in our collection, and add those same properties
                     // to the cloned collection.
 
                     // Create a new virtual BuildPropertyGroup.
@@ -697,7 +697,7 @@ part of the project */
                     this.importedFromAnotherProject
                     );
 
-                // Loop through every BuildProperty in our collection, and add those same properties 
+                // Loop through every BuildProperty in our collection, and add those same properties
                 // to the cloned collection.
                 foreach (BuildProperty property in this)
                 {
@@ -734,8 +734,8 @@ internal void ImportInitialProperties
             BuildPropertyGroup globalProperties
         )
         {
-            // The consumer of the OM has the ability to add new properties to the 
-            // GlobalProperties BuildPropertyGroup, and the OM doesn't expose the 
+            // The consumer of the OM has the ability to add new properties to the
+            // GlobalProperties BuildPropertyGroup, and the OM doesn't expose the
             // property type, because that would be too dangerous.  So all properties
             // created by the OM consumer will be "normal" properties, even those
             // set in the GlobalProperties BuildPropertyGroup.  But in order to make
@@ -782,7 +782,7 @@ BuildProperty newProperty
         {
             // We don't support this method for PropertyGroups that are
             // represented by an actual <PropertyGroup> element.  This is because
-            // persisted PropertyGroups can contain multiple properties with the same 
+            // persisted PropertyGroups can contain multiple properties with the same
             // name, so the behavior of SetProperty becomes ambiguous.
             MustBeVirtual("NeedVirtualPropertyGroup");
 
@@ -794,12 +794,12 @@ BuildProperty newProperty
 
             if (existingProperty != null)
             {
-                // If the existing property is an XMake reserved property, we may have an 
+                // If the existing property is an XMake reserved property, we may have an
                 // invalid project file, because reserved properties are not allowed to
                 // be set.
-                // Don't fail if the new property is itself a "reserved" property.  We 
-                // want to be able to override reserved properties with new reserved 
-                // properties, otherwise the engine itself would never be allowed to 
+                // Don't fail if the new property is itself a "reserved" property.  We
+                // want to be able to override reserved properties with new reserved
+                // properties, otherwise the engine itself would never be allowed to
                 // change the value of a reserved property.
                 ProjectErrorUtilities.VerifyThrowInvalidProject(
                     (existingProperty.Type != PropertyType.ReservedProperty) ||
@@ -808,7 +808,7 @@ BuildProperty newProperty
 
                 // Also make sure it's not a read-only property (such as a property
                 // that was set at the XMake command-line), but don't actually throw
-                // an error in this case.  Only output properties from tasks are allowed 
+                // an error in this case.  Only output properties from tasks are allowed
                 // to override read-only properties
                 if ((existingProperty.Type == PropertyType.GlobalProperty) &&
                     (newProperty.Type != PropertyType.OutputProperty))
@@ -1037,7 +1037,7 @@ BuildProperty property
         {
             error.VerifyThrowArgumentNull(property, nameof(property));
 
-            // If this is a persisted <PropertyGroup>, then remove the property element from 
+            // If this is a persisted <PropertyGroup>, then remove the property element from
             // the XML and from the array list.
             if (IsPersisted)
             {
@@ -1085,10 +1085,10 @@ string propertyName
             {
                 MustBePersisted("NeedPersistedPropertyGroup", XMakeElements.propertyGroup);
 
-                // For persisted <PropertyGroup>'s, there could be multiple properties 
-                // with the given name.  We need to loop through our arraylist of properties, 
-                // finding all the ones with the given property name, and delete them.  But we 
-                // shouldn't be modifying the arraylist while we're still enumerating through 
+                // For persisted <PropertyGroup>'s, there could be multiple properties
+                // with the given name.  We need to loop through our arraylist of properties,
+                // finding all the ones with the given property name, and delete them.  But we
+                // shouldn't be modifying the arraylist while we're still enumerating through
                 // it.  So, first we create a new list of all the properties we want to remove,
                 // and then we later go through and actually remove them.
                 ArrayList propertiesToRemove = new ArrayList();
@@ -1114,7 +1114,7 @@ string propertyName
             {
                 MustBeVirtual("NeedVirtualPropertyGroup");
 
-                // We only need to remove the BuildProperty object with the given name from 
+                // We only need to remove the BuildProperty object with the given name from
                 // the Hashtable.  There can be only one.
                 this.propertyTableByName.Remove(propertyName);
 
@@ -1191,7 +1191,7 @@ BuildPropertyGroup sourceProperties
         /// </summary>
         internal void ClearHelper(bool clearImportedPropertyGroup)
         {
-            // If this group is backed by XML, clear all attributes and 
+            // If this group is backed by XML, clear all attributes and
             // children out unless it's an imported group, in which case we don't want to modify the XML
             if (IsPersisted && !clearImportedPropertyGroup)
             {
@@ -1273,7 +1273,7 @@ internal void MarkPropertyGroupAsDirty
                 else
                 {
                     // This is not a change to the contents of the project file, however
-                    // this change does require a re-evaluation of the project.  For 
+                    // this change does require a re-evaluation of the project.  For
                     // example, if a global property changes....
                     this.ParentProject.MarkProjectAsDirtyForReevaluation();
                 }
@@ -1326,9 +1326,9 @@ internal void GatherEnvironmentVariables()
         /// </summary>
         private void SetExtensionsPathProperties()
         {
-            // We set the MSBuildExtensionsPath variables here because we don't want to make them official 
-            // reserved properties; we need the ability for people to override our default in their 
-            // environment or as a global property.  
+            // We set the MSBuildExtensionsPath variables here because we don't want to make them official
+            // reserved properties; we need the ability for people to override our default in their
+            // environment or as a global property.
 
             // "MSBuildExtensionsPath32". This points to whatever the value of "Program Files (x86)" environment variable is;
             // but on a 32 bit box this isn't set, and we should use "Program Files" instead.
@@ -1346,9 +1346,9 @@ private void SetExtensionsPathProperties()
             string extensionsPath32 = Path.Combine(programFiles32, ReservedPropertyNames.extensionsPathSuffix);
             SetProperty(new BuildProperty(ReservedPropertyNames.extensionsPath32, extensionsPath32, PropertyType.EnvironmentProperty));
 
-            // MSBuildExtensionsPath:  The way this used to work is that it would point to "Program Files\MSBuild" on both 
+            // MSBuildExtensionsPath:  The way this used to work is that it would point to "Program Files\MSBuild" on both
             // 32-bit and 64-bit machines.  We have a switch to continue using that behavior; however the default is now for
-            // MSBuildExtensionsPath to always point to the same location as MSBuildExtensionsPath32. 
+            // MSBuildExtensionsPath to always point to the same location as MSBuildExtensionsPath32.
 
             bool useLegacyMSBuildExtensionsPathBehavior = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLEGACYEXTENSIONSPATH"));
 
@@ -1398,7 +1398,7 @@ BuildPropertyGroup compareToPropertyGroup
             if (this.Count == compareToPropertyGroup.Count)
             {
                 // If both bags do have the same number of elements, it should
-                // be sufficient to check if one bag contains all of the 
+                // be sufficient to check if one bag contains all of the
                 // elements in the other.
                 foreach (DictionaryEntry entry in this.propertyTableByName)
                 {
@@ -1449,8 +1449,8 @@ string errorResourceName
         {
             error.VerifyThrowInvalidOperation(IsVirtual, errorResourceName, XMakeElements.propertyGroup);
 
-            // If this is a virtual BuildPropertyGroup (not a <PropertyGroup> element), then 
-            // we should not have an ArrayList of BuildProperty objects ... we should only have 
+            // If this is a virtual BuildPropertyGroup (not a <PropertyGroup> element), then
+            // we should not have an ArrayList of BuildProperty objects ... we should only have
             // the hash table.
             error.VerifyThrow(this.propertyList == null,
                 "ArrayList of BuildProperty objects not expected for a virtual BuildPropertyGroup.");
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
index 8a9b3a26939..15751e39f9c 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BuildEngine
     /// This class represents a collection of persisted &lt;PropertyGroup&gt;'s.  Each
     /// MSBuild project has exactly one BuildPropertyGroupCollection, which includes
     /// all the imported PropertyGroups as well as the ones in the main project file.
-    /// 
+    ///
     /// The implementation of this class is that it's basically a Facade.  It just
     /// calls into the GroupingCollection within the Project to do it's work.  It
     /// doesn't maintain any BuildPropertyGroup state on its own.
@@ -113,8 +113,8 @@ internal BuildPropertyGroup LastLocalPropertyGroup
                 {
                     if (propertyGroup.IsImported)
                     {
-                        // As soon as we hit an imported BuildPropertyGroup, we want to 
-                        // completely bail out.  The goal of this function is 
+                        // As soon as we hit an imported BuildPropertyGroup, we want to
+                        // completely bail out.  The goal of this function is
                         // to return the last BuildPropertyGroup that is *before* any
                         // imported PropertyGroups.
                         break;
@@ -134,7 +134,7 @@ internal BuildPropertyGroup LastLocalPropertyGroup
         #region Methods
 
         /// <summary>
-        /// This ICollection method copies the contents of this collection to an 
+        /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <owner>RGoel</owner>
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
index 4304d1e91d4..41fb6995ac2 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
@@ -10,12 +10,12 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
-    /// An enumerable wrapper for a BuildPropertyGroup that allows read-only 
+    /// An enumerable wrapper for a BuildPropertyGroup that allows read-only
     /// access to the properties.
     /// </summary>
     /// <remarks>
     /// This class is designed to be passed to loggers.
-    /// The expense of copying properties is only incurred if and when 
+    /// The expense of copying properties is only incurred if and when
     /// a logger chooses to enumerate over it.
     /// </remarks>
     /// <owner>danmose</owner>
diff --git a/src/Deprecated/Engine/Resources/AssemblyResources.cs b/src/Deprecated/Engine/Resources/AssemblyResources.cs
index c7ed902495b..31da122b840 100644
--- a/src/Deprecated/Engine/Resources/AssemblyResources.cs
+++ b/src/Deprecated/Engine/Resources/AssemblyResources.cs
@@ -23,7 +23,7 @@ internal static class AssemblyResources
         private static ResourceManager msbuildExeResourceManager;
 
         /// <summary>
-        /// The internals of the Engine are exposed to MSBuild.exe, so they must share the same AssemblyResources class and 
+        /// The internals of the Engine are exposed to MSBuild.exe, so they must share the same AssemblyResources class and
         /// ResourceUtilities class that uses it. To make this possible, MSBuild.exe registers its resources here and they are
         /// normally consulted last. This assumes that there are no duplicated resource ID's between the Engine and MSBuild.exe.
         /// (Actually there are currently two: LoggerCreationError and LoggerNotFoundError.
diff --git a/src/Deprecated/Engine/Resources/Constants.cs b/src/Deprecated/Engine/Resources/Constants.cs
index ce6972f0b2a..8078797df60 100644
--- a/src/Deprecated/Engine/Resources/Constants.cs
+++ b/src/Deprecated/Engine/Resources/Constants.cs
@@ -81,7 +81,7 @@ internal static class Constants
         internal const string defaultSolutionWrapperProjectToolsVersion = "4.0";
 
         /// <summary>
-        /// Current version of this MSBuild Engine assembly in the 
+        /// Current version of this MSBuild Engine assembly in the
         /// form, e.g, "4.0"
         /// </summary>
         internal static string AssemblyVersion
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index 394b68bbee2..2f2aa8920eb 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -56,7 +56,7 @@ internal AssemblyNameExtension(string assemblyName)
 
         /// <summary>
         /// Construct from a string, but immediately construct a real AssemblyName.
-        /// This will cause an exception to be thrown up front if the assembly name 
+        /// This will cause an exception to be thrown up front if the assembly name
         /// isn't well formed.
         /// </summary>
         /// <param name="assemblyName">
@@ -253,7 +253,7 @@ internal int CompareTo(AssemblyNameExtension that)
         /// <returns></returns>
         internal new int GetHashCode()
         {
-            // Ok, so this isn't a great hashing algorithm. However, basenames with different 
+            // Ok, so this isn't a great hashing algorithm. However, basenames with different
             // versions or PKTs are relatively uncommon and so collisions should be low.
             // Hashing on FullName is wrong because the order of tuple fields is undefined.
             int hash = StringComparer.OrdinalIgnoreCase.GetHashCode(this.Name);
@@ -288,7 +288,7 @@ internal int CompareBaseNameTo(AssemblyNameExtension that)
         }
 
         /// <summary>
-        /// An implementation of compare that compares two base 
+        /// An implementation of compare that compares two base
         /// names as quickly as possible.
         /// </summary>
         /// <param name="that"></param>
@@ -480,7 +480,7 @@ private static AssemblyName GetAssemblyNameFromDisplayName(string displayName)
         }
 
         /// <summary>
-        /// Return a string that has AssemblyName special characters escaped. 
+        /// Return a string that has AssemblyName special characters escaped.
         /// Those characters are Equals(=), Comma(,), Quote("), Apostrophe('), Backslash(\).
         /// </summary>
         /// <remarks>
diff --git a/src/Deprecated/Engine/Shared/ConversionUtilities.cs b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
index a339ba5793f..4533e5ba505 100644
--- a/src/Deprecated/Engine/Shared/ConversionUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
@@ -14,12 +14,12 @@ namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
     /// This class contains only static methods, which are useful throughout many
-    /// of the MSBuild classes and don't really belong in any specific class.   
+    /// of the MSBuild classes and don't really belong in any specific class.
     /// </summary>
     internal static class ConversionUtilities
     {
         /// <summary>
-        /// Converts a string to a bool.  We consider "true/false", "on/off", and 
+        /// Converts a string to a bool.  We consider "true/false", "on/off", and
         /// "yes/no" to be valid boolean representations in the XML.
         /// </summary>
         /// <param name="parameterValue">The string to convert.</param>
diff --git a/src/Deprecated/Engine/Shared/EscapingUtilities.cs b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
index 618918de5af..a3dba500388 100644
--- a/src/Deprecated/Engine/Shared/EscapingUtilities.cs
+++ b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
@@ -127,7 +127,7 @@ string unescapedString
             // This is where we're going to build up the final string to return to the caller.
             StringBuilder escapedString = new StringBuilder(unescapedString);
 
-            // Replace each unescaped special character with an escape sequence one            
+            // Replace each unescaped special character with an escape sequence one
             foreach (char unescapedChar in charsToEscape)
             {
                 int unescapedCharCode = Convert.ToInt32(unescapedChar);
diff --git a/src/Deprecated/Engine/Shared/ExceptionHandling.cs b/src/Deprecated/Engine/Shared/ExceptionHandling.cs
index a3a04ef335a..bf6a914bc26 100644
--- a/src/Deprecated/Engine/Shared/ExceptionHandling.cs
+++ b/src/Deprecated/Engine/Shared/ExceptionHandling.cs
@@ -94,7 +94,7 @@ internal static bool NotExpectedReflectionException(Exception e)
                 || e is InvalidCastException
                 || e is AmbiguousMatchException         // thrown when binding to a member results in more than one member matching the binding criteria
                 || e is InvalidFilterCriteriaException  // thrown in FindMembers when the filter criteria is not valid for the type of filter you are using
-                || e is TargetException                 // thrown when an attempt is made to invoke a non-static method on a null object.  This may occur because the caller does not 
+                || e is TargetException                 // thrown when an attempt is made to invoke a non-static method on a null object.  This may occur because the caller does not
                                                         //     have access to the member, or because the target does not define the member, and so on.
                 || e is MissingFieldException           // thrown when code in a dependent assembly attempts to access a missing field in an assembly that was modified.
                 || !NotExpectedException(e)             // Reflection can throw IO exceptions if the assembly cannot be opened
diff --git a/src/Deprecated/Engine/Shared/FileMatcher.cs b/src/Deprecated/Engine/Shared/FileMatcher.cs
index 13f25e1be16..a7328b6cf4e 100644
--- a/src/Deprecated/Engine/Shared/FileMatcher.cs
+++ b/src/Deprecated/Engine/Shared/FileMatcher.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
-    /// Functions for matching file names with patterns. 
+    /// Functions for matching file names with patterns.
     /// </summary>
     /// <owner>JomoF</owner>
     internal static class FileMatcher
@@ -134,7 +134,7 @@ private static string[] GetAccessibleFilesAndDirectories(string path, string pat
         /// <summary>
         /// Same as Directory.GetFiles(...) except that files that
         /// aren't accessible are skipped instead of throwing an exception.
-        /// 
+        ///
         /// Other exceptions are passed through.
         /// </summary>
         /// <param name="path">The path.</param>
@@ -193,7 +193,7 @@ bool stripProjectDirectory
         /// <summary>
         /// Same as Directory.GetDirectories(...) except that files that
         /// aren't accessible are skipped instead of throwing an exception.
-        /// 
+        ///
         /// Other exceptions are passed through.
         /// </summary>
         /// <param name="path">The path.</param>
@@ -372,7 +372,7 @@ GetFileSystemEntries getFileSystemEntries
                 out filenamePart
             );
 
-            /* 
+            /*
              * Handle the special case in which filenamePart is '**'.
              * In this case, filenamePart becomes '*.*' and the '**' is appended
              * to the end of the wildcardDirectory part.
@@ -412,12 +412,12 @@ out string filenamePart
             {
                 /*
                  * No dir separator found. This is either this form,
-                 * 
+                 *
                  *      Source.cs
                  *      *.cs
-                 * 
+                 *
                  *  or this form,
-                 * 
+                 *
                  *     **
                  */
                 fixedDirectoryPart = String.Empty;
@@ -438,14 +438,14 @@ out string filenamePart
                  * wildcard is after the dir separator.
                  *
                  * The form is one of these:
-                 * 
+                 *
                  *      dir1\Source.cs
                  *      dir1\*.cs
-                 * 
+                 *
                  * Where the trailing spec is meant to be a filename. Or,
-                 * 
+                 *
                  *      dir1\**
-                 * 
+                 *
                  * Where the trailing spec is meant to be any file recursively.
                  */
 
@@ -465,11 +465,11 @@ out string filenamePart
             {
                 /*
                  * There is no separator before the wildcard, so the form is like this:
-                 * 
+                 *
                  *      dir?\Source.cs
-                 * 
+                 *
                  * or this,
-                 * 
+                 *
                  *      dir?\**
                  */
                 fixedDirectoryPart = String.Empty;
@@ -487,7 +487,7 @@ out string filenamePart
         }
 
         /// <summary>
-        /// Removes the leading ".\" from all of the paths in the array. 
+        /// Removes the leading ".\" from all of the paths in the array.
         /// </summary>
         /// <param name="paths">Paths to remove .\ from.</param>
         private static void RemoveInitialDotSlash
@@ -515,7 +515,7 @@ internal static bool IsDirectorySeparator(char c)
             return c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar;
         }
         /// <summary>
-        /// Removes the current directory converting the file back to relative path 
+        /// Removes the current directory converting the file back to relative path
         /// </summary>
         /// <param name="paths">Paths to remove current directory from.</param>
         /// <param name="projectDirectory"></param>
@@ -549,7 +549,7 @@ string projectDirectory
         }
 
         /// <summary>
-        /// Get all files that match either the file-spec or the regular expression. 
+        /// Get all files that match either the file-spec or the regular expression.
         /// </summary>
         /// <param name="listOfFiles">List of files that gets populated.</param>
         /// <param name="baseDirectory">The path to enumerate</param>
@@ -645,7 +645,7 @@ GetFileSystemEntries getFileSystemEntries
                     //        foo\**\bar
                     //
                     // back into remainingWildcardDirectory.
-                    // This is a performance optimization. We don't want to enumerate everything if we 
+                    // This is a performance optimization. We don't want to enumerate everything if we
                     // don't have to.
                     pattern = remainingWildcardDirectory.Substring(0, indexOfNextSlash);
                     remainingWildcardDirectory = remainingWildcardDirectory.Substring(indexOfNextSlash + 1);
@@ -658,7 +658,7 @@ GetFileSystemEntries getFileSystemEntries
                     }
                 }
 
-                // We never want to strip the project directory from the leaves, because the current 
+                // We never want to strip the project directory from the leaves, because the current
                 // process directory maybe different
                 string[] subdirs = getFileSystemEntries(FileSystemEntity.Directories, baseDirectory, pattern, null, false);
                 foreach (string subdir in subdirs)
@@ -671,7 +671,7 @@ GetFileSystemEntries getFileSystemEntries
         /// <summary>
         /// Given a file spec, create a regular expression that will match that
         /// file spec.
-        /// 
+        ///
         /// PERF WARNING: this method is called in performance-critical
         /// scenarios, so keep it fast and cheap
         /// </summary>
@@ -693,7 +693,7 @@ out bool isLegalFileSpec
             /*
              * The code below uses tags in the form <:tag:> to encode special information
              * while building the regular expression.
-             * 
+             *
              * This format was chosen because it's not a legal form for filespecs. If the
              * filespec comes in with either "<:" or ":>", return isLegalFileSpec=false to
              * prevent intrusion into the special processing.
@@ -718,13 +718,13 @@ out bool isLegalFileSpec
                 return String.Empty;
             }
 
-            /* 
+            /*
              * Trailing dots in file names have to be treated specially.
              * We want:
-             * 
+             *
              *     *. to match foo
-             * 
-             * but 'foo' doesn't have a trailing '.' so we need to handle this while still being careful 
+             *
+             * but 'foo' doesn't have a trailing '.' so we need to handle this while still being careful
              * not to match 'foo.txt'
              */
             if (filenamePart.EndsWith(".", StringComparison.Ordinal))
@@ -760,33 +760,33 @@ out bool isLegalFileSpec
 
             /*
              * Iteratively reduce four cases involving directory separators
-             * 
+             *
              *  (1) <:dirseparator:>.<:dirseparator:> -> <:dirseparator:>
              *        This is an identity, so for example, these two are equivalent,
-             * 
+             *
              *            dir1\.\dir2 == dir1\dir2
-             * 
+             *
              *    (2) <:dirseparator:><:dirseparator:> -> <:dirseparator:>
              *      Double directory separators are treated as a single directory separator,
              *      so, for example, this is an identity:
-             * 
+             *
              *          f:\dir1\\dir2 == f:\dir1\dir2
-             * 
+             *
              *      The single exemption is for UNC path names, like this:
-             * 
+             *
              *          \\server\share != \server\share
-             * 
+             *
              *      This case is handled by the <:uncslashslash:> which was substituted in
              *      a prior step.
-             * 
+             *
              *  (3) <:fixeddir:>.<:dirseparator:>.<:dirseparator:> -> <:fixeddir:>.<:dirseparator:>
              *      A ".\" at the beginning of a line is equivalent to nothing, so:
-             * 
+             *
              *          .\.\dir1\file.txt == .\dir1\file.txt
-             * 
+             *
              *  (4) <:dirseparator:>.<:eol:> -> <:eol:>
              *      A "\." at the end of a line is equivalent to nothing, so:
-             * 
+             *
              *          dir1\dir2\. == dir1\dir2             *
              */
             int sizeBefore;
@@ -822,11 +822,11 @@ out bool isLegalFileSpec
 
             /*
              * Call out legal recursion operators:
-             * 
+             *
              *        fixed-directory + **\
              *        \**\
              *        **\**
-             * 
+             *
              */
             do
             {
@@ -900,7 +900,7 @@ out bool isLegalFileSpec
         }
 
         /// <summary>
-        /// Given a filespec, get the information needed for file matching. 
+        /// Given a filespec, get the information needed for file matching.
         /// </summary>
         /// <param name="filespec">The filespec.</param>
         /// <param name="regexFileMatch">Receives the regular expression.</param>
@@ -976,7 +976,7 @@ GetFileSystemEntries getFileSystemEntries
 
             /*
              * Check for patterns in the filespec that are explicitly illegal.
-             * 
+             *
              * Any path with "..." in it is illegal.
              */
             if (-1 != filespec.IndexOf("...", StringComparison.Ordinal))
@@ -988,9 +988,9 @@ GetFileSystemEntries getFileSystemEntries
             /*
              * If there is a ':' anywhere but the second character, this is an illegal pattern.
              * Catches this case among others,
-             * 
+             *
              *        http://www.website.com
-             * 
+             *
              */
             int rightmostColon = filespec.LastIndexOf(":", StringComparison.Ordinal);
 
@@ -1111,7 +1111,7 @@ GetFileSystemEntries getFileSystemEntries
         }
 
         /// <summary>
-        /// Given a filespec, find the files that match. 
+        /// Given a filespec, find the files that match.
         /// </summary>
         /// <param name="filespec">Get files that match the given file spec.</param>
         /// <returns>The array of files.</returns>
@@ -1126,7 +1126,7 @@ string filespec
         }
 
         /// <summary>
-        /// Given a filespec, find the files that match. 
+        /// Given a filespec, find the files that match.
         /// </summary>
         /// <param name="filespec">Get files that match the given file spec.</param>
         /// <param name="getFileSystemEntries">Get files that match the given file spec.</param>
diff --git a/src/Deprecated/Engine/Shared/FileUtilities.cs b/src/Deprecated/Engine/Shared/FileUtilities.cs
index 7b19c8ec90a..41e312d62b6 100644
--- a/src/Deprecated/Engine/Shared/FileUtilities.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilities.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
     /// This class contains utility methods for file IO.
-    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in 
+    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in
     /// each class get pulled into the resulting assembly.
     /// </summary>
     /// <owner>SumedhK</owner>
@@ -31,7 +31,7 @@ internal static class FileUtilities
         /// <owner>SumedhK</owner>
         internal static class ItemSpecModifiers
         {
-            // NOTE: If you add an item here that starts with a new letter, you need to update the case 
+            // NOTE: If you add an item here that starts with a new letter, you need to update the case
             // statements in IsItemSpecModifier and IsDerivableItemSpecModifier.
             internal const string FullPath = "FullPath";
             internal const string RootDir = "RootDir";
@@ -97,21 +97,21 @@ internal static bool IsItemSpecModifier(string name)
                 return false;
             }
 
-            /* 
+            /*
              * What follows requires some explanation.
-             * 
-             * This function is called many times and slowness here will be amplified 
+             *
+             * This function is called many times and slowness here will be amplified
              * in critical performance scenarios.
-             * 
+             *
              * The following switch statement attempts to identify item spec modifiers that
-             * have the exact case that our constants in ItemSpecModifiers have. This is the 
+             * have the exact case that our constants in ItemSpecModifiers have. This is the
              * 99% case.
-             * 
+             *
              * Further, the switch statement can identify certain cases in which there is
              * definitely no chance that 'name' is an item spec modifier. For example, a
              * 7 letter 'name' that doesn't start with 'r' or 'R' can't be RootDir and
              * therefore is not an item spec modifier.
-             * 
+             *
              */
             switch (name.Length)
             {
@@ -263,7 +263,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
                 {
                     if (name[0] == 'R' || name[0] == 'r')
                     {
-                        // The only 12 letter ItemSpecModifier that starts with 'R' is 'RecursiveDir' 
+                        // The only 12 letter ItemSpecModifier that starts with 'R' is 'RecursiveDir'
                         return false;
                     }
                 }
@@ -274,7 +274,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
 
         /// <summary>
         /// Performs path manipulations on the given item-spec as directed.
-        /// 
+        ///
         /// Supported modifiers:
         ///     %(FullPath)         = full path of item
         ///     %(RootDir)          = root directory of item
@@ -287,7 +287,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
         ///     %(ModifiedTime)     = last write time of item
         ///     %(CreatedTime)      = creation time of item
         ///     %(AccessedTime)     = last access time of item
-        /// 
+        ///
         /// NOTES:
         /// 1) This method always returns an empty string for the %(RecursiveDir) modifier because it does not have enough
         ///    information to compute it -- only the BuildItem class can compute this modifier.
@@ -298,7 +298,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
         /// 1) successive slashes are combined into 1 slash
         /// 2) trailing periods are discarded
         /// 3) forward slashes are changed to back-slashes
-        /// 
+        ///
         /// As a result, we cannot rely on any file-spec that has passed through a Path method to remain the same. We will
         /// therefore not bother preserving slashes and periods when file-specs are transformed.
         /// </remarks>
@@ -459,7 +459,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         }
                         else
                         {
-                            // File does not exist, or path is a directory                        
+                            // File does not exist, or path is a directory
                             modifiedItemSpec = String.Empty;
                         }
                     }
@@ -477,7 +477,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         }
                         else
                         {
-                            // File does not exist, or path is a directory                        
+                            // File does not exist, or path is a directory
                             modifiedItemSpec = String.Empty;
                         }
                     }
@@ -573,7 +573,7 @@ internal static bool EndsWithSlash(string fileSpec)
         }
 
         /// <summary>
-        /// Indicates if the given character is a slash. 
+        /// Indicates if the given character is a slash.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <param name="c"></param>
@@ -722,7 +722,7 @@ internal static string CurrentExecutableConfigurationFilePath
         /// <summary>
         /// Gets a file info object for the specified file path. If the file path
         /// is invalid, or is a directory, or cannot be accessed, or does not exist,
-        /// it returns null rather than throwing or returning a FileInfo around a non-existent file. 
+        /// it returns null rather than throwing or returning a FileInfo around a non-existent file.
         /// This allows it to be called where File.Exists() (which never throws, and returns false
         /// for directories) was called - but with the advantage that a FileInfo object is returned
         /// that can be queried (e.g., for LastWriteTime) without hitting the disk again.
@@ -784,11 +784,11 @@ internal static bool IsVCProjFilename(string filename)
         }
 
         /// <summary>
-        /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location. 
+        /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
         /// Throws UriFormatException.
         /// </summary>
         /// <param name="basePath">
-        /// The base path we want to relativize to. Must be absolute.  
+        /// The base path we want to relativize to. Must be absolute.
         /// Should <i>not</i> include a filename as the last segment will be interpreted as a directory.
         /// </param>
         /// <param name="path">
diff --git a/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs b/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs
index 528bb121c15..097c2d3b1c3 100644
--- a/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs
@@ -15,13 +15,13 @@ namespace Microsoft.Build.BuildEngine.Shared
     /// <summary>
     /// This class contains utility methods for file IO.
     /// Separate from FileUtilities because some assemblies may only need the patterns.
-    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in 
+    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in
     /// each class get pulled into the resulting assembly.
     /// </summary>
     /// <owner>SumedhK, JomoF</owner>
     internal static class FileUtilitiesRegex
     {
-        // regular expression used to match file-specs beginning with "<drive letter>:" 
+        // regular expression used to match file-specs beginning with "<drive letter>:"
         internal static readonly Regex DrivePattern = new Regex(@"^[A-Za-z]:");
 
         // regular expression used to match UNC paths beginning with "\\<server>\<share>"
diff --git a/src/Deprecated/Engine/Shared/InternalErrorException.cs b/src/Deprecated/Engine/Shared/InternalErrorException.cs
index 218c3e31f65..b4e04642429 100644
--- a/src/Deprecated/Engine/Shared/InternalErrorException.cs
+++ b/src/Deprecated/Engine/Shared/InternalErrorException.cs
@@ -14,12 +14,12 @@ namespace Microsoft.Build.BuildEngine.Shared
     /// This exception is to be thrown whenever an assumption we have made in the code turns out to be false. Thus, if this
     /// exception ever gets thrown, it is because of a bug in our own code, not because of something the user or project author
     /// did wrong.
-    /// 
+    ///
     /// !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
     /// WARNING: When this file is shared into multiple assemblies each assembly will view this as a different type.
     ///          Don't throw this exception from one assembly and catch it in another.
     /// !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
-    ///     
+    ///
     /// </summary>
     /// <owner>RGoel</owner>
     [Serializable]
diff --git a/src/Deprecated/Engine/Shared/NativeMethodsShared.cs b/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
index 6b4863fedc9..a411b606cbb 100644
--- a/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
+++ b/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
@@ -103,9 +103,9 @@ internal static string FindOnPath(string filename)
         #region PInvoke
 
         /// <summary>
-        /// Gets the current OEM code page which is used by console apps 
+        /// Gets the current OEM code page which is used by console apps
         /// (as opposed to the Windows/ANSI code page)
-        /// Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page 
+        /// Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
         /// that needs to be used for instance when writing to batch files
         /// </summary>
         /// <owner>LukaszG</owner>
diff --git a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
index efddac5040a..d5f7d9097e4 100644
--- a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
@@ -43,7 +43,7 @@ internal bool IncludeInBuild
         /// This is a hacky method to remove the space in the "Any CPU" platform in project configurations.
         /// The problem is that this platform is stored as "AnyCPU" in project files, but the project system
         /// reports it as "Any CPU" to the solution configuration manager. Because of that all solution configurations
-        /// contain the version with a space in it, and when we try and give that name to actual projects, 
+        /// contain the version with a space in it, and when we try and give that name to actual projects,
         /// they have no clue what we're talking about. We need to remove the space in project platforms so that
         /// the platform name matches the one used in projects.
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs b/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs
index c4e02764d55..7c93d4bf4bc 100644
--- a/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs
@@ -8,14 +8,14 @@
 using System.Xml;
 
 /******************************************************************************
- * 
+ *
  *                              !! WARNING !!
- * 
+ *
  * This class depends on the build engine assembly! Do not share this class
  * into any assembly that is not supposed to take a dependency on the build
  * engine assembly!
- * 
- * 
+ *
+ *
  ******************************************************************************/
 
 namespace Microsoft.Build.BuildEngine.Shared
@@ -321,7 +321,7 @@ object arg3
 
         /// <summary>
         /// Throws an InvalidProjectFileException using the given data.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
diff --git a/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs b/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs
index d04ee7cc6bb..12b2ab979d5 100644
--- a/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs
@@ -16,7 +16,7 @@ internal static class ProjectFileErrorUtilities
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -39,7 +39,7 @@ params object[] args
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/ProjectInSolution.cs b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
index 8e025bb32ae..9d2bc12f0d8 100644
--- a/src/Deprecated/Engine/Shared/ProjectInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
@@ -87,7 +87,7 @@ internal sealed class ProjectInSolution
         /// <summary>
         /// The project configuration in given solution configuration
         /// K: full solution configuration name (cfg + platform)
-        /// V: project configuration 
+        /// V: project configuration
         /// </summary>
         private Dictionary<string, ProjectConfigurationInSolution> projectConfigurations;
 
@@ -356,7 +356,7 @@ private static string CleanseProjectName(string projectName)
             // This is where we're going to work on the final string to return to the caller.
             StringBuilder cleanProjectName = new StringBuilder(projectName);
 
-            // Replace each unclean character with a clean one            
+            // Replace each unclean character with a clean one
             foreach (char uncleanChar in charsToCleanse)
             {
                 cleanProjectName.Replace(uncleanChar, cleanCharacter);
diff --git a/src/Deprecated/Engine/Shared/ResourceUtilities.cs b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
index 396ff96d1f8..7eeac400a28 100644
--- a/src/Deprecated/Engine/Shared/ResourceUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
@@ -72,7 +72,7 @@ private static string GetHelpKeyword(string resourceName)
         /// <summary>
         /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they too are returned.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -94,7 +94,7 @@ internal static string FormatResourceString(out string code, out string helpKeyw
         /// <summary>
         /// Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they are discarded.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -113,7 +113,7 @@ internal static string FormatResourceString(string resourceName, params object[]
 
         /// <summary>
         /// Formats the given string using the variable arguments passed in.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -142,12 +142,12 @@ internal static string FormatString(string unformatted, params object[] args)
                 // String.Format() will throw a FormatException if args does
                 // not have enough elements to match each format parameter.
                 // However, it provides no feedback in the case when args contains
-                // more elements than necessary to replace each format 
+                // more elements than necessary to replace each format
                 // parameter.  We'd like to know if we're providing too much
                 // data in cases like these, so we'll fail if this code runs.
                 //
                 // See DevDiv Bugs 15210 for more information.
-                                
+
                 // We create an array with one fewer element
                 object[] trimmedArgs = new object[args.Length - 1];
                 Array.Copy(args, 0, trimmedArgs, 0, args.Length - 1);
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 68d1bfee87b..6e146f197df 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -142,7 +142,7 @@ internal ArrayList SolutionParserComments
         }
 
         /// <summary>
-        /// This property returns the list of error codes for warnings/errors that were generated during solution parsing. 
+        /// This property returns the list of error codes for warnings/errors that were generated during solution parsing.
         /// UNIT TESTING ONLY
         /// </summary>
         internal ArrayList SolutionParserErrorCodes
@@ -414,11 +414,11 @@ internal void ParseSolution()
         /// <summary>
         /// This method searches the first two lines of the solution file opened by the specified
         /// StreamReader for the solution file header.  An exception is thrown if it is not found.
-        /// 
+        ///
         /// The solution file header looks like this:
-        /// 
+        ///
         ///     Microsoft Visual Studio Solution File, Format Version 9.00
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         private void ParseFileHeader()
@@ -454,11 +454,11 @@ private void ParseFileHeader()
         /// This method extracts the whole part of the version number from the specified line
         /// containing the solution file format header, and throws an exception if the version number
         /// is outside of the valid range.
-        /// 
+        ///
         /// The solution file header looks like this:
-        /// 
+        ///
         ///     Microsoft Visual Studio Solution File, Format Version 9.00
-        /// 
+        ///
         /// </summary>
         /// <param name="versionString"></param>
         /// <owner>RGoel</owner>
@@ -506,7 +506,7 @@ private void ValidateSolutionFileVersion(string versionString)
         }
 
         /// <summary>
-        /// 
+        ///
         /// This method processes a "Project" section in the solution file opened by the specified
         /// StreamReader, and returns a populated ProjectInSolution instance, if successful.
         /// An exception is thrown if the solution file is invalid.
@@ -519,7 +519,7 @@ private void ValidateSolutionFileVersion(string versionString)
         ///          ...
         ///      EndProjectSection
         ///  EndProject
-        /// 
+        ///
         /// </summary>
         /// <param name="firstLine"></param>
         /// <returns></returns>
@@ -567,7 +567,7 @@ private void ParseProject(string firstLine)
                 else if (line.StartsWith("ProjectSection(WebsiteProperties)", StringComparison.Ordinal))
                 {
                     // We have a WebsiteProperties section.  This section is present only in Venus
-                    // projects, and contains properties that we'll need in order to call the 
+                    // projects, and contains properties that we'll need in order to call the
                     // AspNetCompiler task.
                     line = ReadLine();
                     while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
@@ -593,7 +593,7 @@ private void ParseProject(string firstLine)
             {
                 // Add the project to the collection
                 AddProjectToSolution(proj);
-                // If the project is an etp project then parse the etp project file 
+                // If the project is an etp project then parse the etp project file
                 // to get the projects contained in it.
                 if (IsEtpProjectFile(proj.RelativePath))
                 {
@@ -603,7 +603,7 @@ private void ParseProject(string firstLine)
         } // ParseProject()
 
         /// <summary>
-        /// This method will parse a .etp project recursively and 
+        /// This method will parse a .etp project recursively and
         /// add all the projects found to projects and projectsInOrder
         /// </summary>
         /// <param name="etpProj">ETP Project</param>
@@ -648,8 +648,8 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
 
                 // We need to parse the .etp project file to get the names of projects contained
                 // in the .etp Project. The projects are listed under /EFPROJECT/GENERAL/References/Reference node in the .etp project file.
-                // The /EFPROJECT/GENERAL/Views/ProjectExplorer node will not necessarily contain 
-                // all the projects in the .etp project. Therefore, we need to look at 
+                // The /EFPROJECT/GENERAL/Views/ProjectExplorer node will not necessarily contain
+                // all the projects in the .etp project. Therefore, we need to look at
                 // /EFPROJECT/GENERAL/References/Reference.
                 // Find the /EFPROJECT/GENERAL/References/Reference node
                 // Note that this is case sensitive
@@ -676,10 +676,10 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
                             proj.ProjectGuid = projGuidNode.InnerText;
                         }
                         // It is ok for a project to not have a guid inside an etp project.
-                        // If a solution file contains a project without a guid it fails to 
-                        // load in Everett. But if an etp project contains a project without 
+                        // If a solution file contains a project without a guid it fails to
+                        // load in Everett. But if an etp project contains a project without
                         // a guid it loads well in Everett and p2p references to/from this project
-                        // are preserved. So we should make sure that we dont error in this 
+                        // are preserved. So we should make sure that we dont error in this
                         // situation while upgrading.
                         else
                         {
@@ -700,7 +700,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle security errors
             catch (SecurityException e)
             {
-                // Log a warning 
+                // Log a warning
                 string errorCode, ignoredKeyword;
                 string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
@@ -710,7 +710,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in path resolution
             catch (NotSupportedException e)
             {
-                // Log a warning 
+                // Log a warning
                 string errorCode, ignoredKeyword;
                 string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
@@ -720,7 +720,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in loading project file
             catch (IOException e)
             {
-                // Log a warning 
+                // Log a warning
                 string errorCode, ignoredKeyword;
                 string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
@@ -730,17 +730,17 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in loading project file
             catch (UnauthorizedAccessException e)
             {
-                // Log a warning 
+                // Log a warning
                 string errorCode, ignoredKeyword;
                 string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
                 solutionParserWarnings.Add(warning);
                 solutionParserErrorCodes.Add(errorCode);
             }
-            // handle XML parsing errors 
+            // handle XML parsing errors
             catch (XmlException e)
             {
-                // Log a warning 
+                // Log a warning
                 string errorCode, ignoredKeyword;
                 string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.InvalidProjectFile",
                    etpProj.RelativePath, e.Message);
@@ -814,7 +814,7 @@ string propertyValue
             //
             // Project("{E24C65DC-7377-472B-9ABA-BC803B73C61A}") = "c:\...\myfirstwebsite\", "..\..\..\..\..\..\rajeev\temp\websites\myfirstwebsite", "{956CC04E-FD59-49A9-9099-96888CB6F366}"
             //     ProjectSection(WebsiteProperties) = preProject
-            //       ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
+            //       ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
             //       Debug.AspNetCompiler.VirtualPath = "/publishfirst"
             //       Debug.AspNetCompiler.PhysicalPath = "..\..\..\..\..\..\rajeev\temp\websites\myfirstwebsite\"
             //       Debug.AspNetCompiler.TargetPath = "..\..\..\..\..\..\rajeev\temp\publishfirst\"
@@ -936,7 +936,7 @@ string propertyValue
             }
             else
             {
-                // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
+                // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
                 if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
                     string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' });
@@ -945,7 +945,7 @@ string propertyValue
                     {
                         int indexOfBar = projectReferenceEntry.IndexOf('|');
 
-                        // indexOfBar could be -1 if we had semicolons in the file names, so skip entries that 
+                        // indexOfBar could be -1 if we had semicolons in the file names, so skip entries that
                         // don't contain a guid. File names may not contain the '|' character
                         if (indexOfBar != -1)
                         {
@@ -993,7 +993,7 @@ string property
         /// Parse the first line of a Project section of a solution file. This line should look like:
         ///
         ///  Project("{Project type GUID}") = "Project name", "Relative path to project file", "{Project GUID}"
-        /// 
+        ///
         /// </summary>
         /// <param name="firstLine"></param>
         /// <param name="proj"></param>
@@ -1076,11 +1076,11 @@ internal void ParseNestedProjects()
         }
 
         /// <summary>
-        /// Read solution configuration section. 
+        /// Read solution configuration section.
         /// </summary>
         /// <remarks>
         /// A sample section:
-        /// 
+        ///
         /// GlobalSection(SolutionConfigurationPlatforms) = preSolution
         ///     Debug|Any CPU = Debug|Any CPU
         ///     Release|Any CPU = Release|Any CPU
@@ -1104,7 +1104,7 @@ internal void ParseSolutionConfigurations()
 
                 string[] configurationNames = str.Split(nameValueSeparators);
 
-                // There should be exactly one '=' character, separating two names. 
+                // There should be exactly one '=' character, separating two names.
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(configurationNames.Length == 2, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(SolutionFile, this.currentLineNumber, 0), "SolutionParseInvalidSolutionConfigurationEntry", str);
 
@@ -1135,7 +1135,7 @@ internal void ParseSolutionConfigurations()
         /// </summary>
         /// <remarks>
         /// A sample (incomplete) section:
-        /// 
+        ///
         /// GlobalSection(ProjectConfigurationPlatforms) = postSolution
         /// 	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
         /// 	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
@@ -1166,7 +1166,7 @@ internal Hashtable ParseProjectConfigurations()
 
                 string[] nameValue = str.Split(new char[] { '=' });
 
-                // There should be exactly one '=' character, separating the name and value. 
+                // There should be exactly one '=' character, separating the name and value.
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(nameValue.Length == 2, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(SolutionFile, this.currentLineNumber, 0), "SolutionParseInvalidProjectSolutionConfigurationEntry", str);
 
@@ -1178,18 +1178,18 @@ internal Hashtable ParseProjectConfigurations()
         }
 
         /// <summary>
-        /// Read the project configuration information for every project in the solution, using pre-cached 
-        /// solution section data. 
+        /// Read the project configuration information for every project in the solution, using pre-cached
+        /// solution section data.
         /// </summary>
         /// <param name="rawProjectConfigurationsEntries">Cached data from the project configuration section</param>
         /// <owner>LukaszG</owner>
         internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurationsEntries)
         {
-            // Instead of parsing the data line by line, we parse it project by project, constructing the 
-            // entry name (e.g. "{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg") and retrieving its 
+            // Instead of parsing the data line by line, we parse it project by project, constructing the
+            // entry name (e.g. "{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg") and retrieving its
             // value from the raw data. The reason for this is that the IDE does it this way, and as the result
             // the '.' character is allowed in configuration names although it technically separates different
-            // parts of the entry name string. This could lead to ambiguous results if we tried to parse 
+            // parts of the entry name string. This could lead to ambiguous results if we tried to parse
             // the entry name instead of constructing it and looking it up. Although it's pretty unlikely that
             // this would ever be a problem, it's safer to do it the same way VS IDE does it.
             char[] configPlatformSeparators = new char[] { ConfigurationInSolution.configurationPlatformSeparator };
@@ -1207,9 +1207,9 @@ internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurati
                             project.ProjectGuid, solutionConfiguration.FullName);
 
                         // The "Build.0" entry tells us whether to build the project configuration in the given solution configuration.
-                        // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial, 
-                        // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used). 
-                        // The configuration name is not used, and the whole entry means "build the project configuration" 
+                        // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial,
+                        // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used).
+                        // The configuration name is not used, and the whole entry means "build the project configuration"
                         // if it's present in the solution file, and "don't build" if it's not.
                         string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0",
                             project.ProjectGuid, solutionConfiguration.FullName);
diff --git a/src/Deprecated/Engine/Shared/UnitTests/FileMatcher_Tests.cs b/src/Deprecated/Engine/Shared/UnitTests/FileMatcher_Tests.cs
index b3b15a8d70b..72f6c5dd81b 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/FileMatcher_Tests.cs
@@ -26,13 +26,13 @@ public class FileMatcherTest
        /*
         * Method:  GetFileSystemEntries
         * Owner:   jomof
-        * 
+        *
         * Simulate Directories.GetFileSystemEntries where file names are short.
-        * 
+        *
         */
         private static string[] GetFileSystemEntries(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
         {
-            if 
+            if
             (
                 pattern==@"LONGDI~1"
                 && (@"D:\"==path || @"\\server\share\"==path || path.Length==0)
@@ -40,7 +40,7 @@ private static string[] GetFileSystemEntries(FileMatcher.FileSystemEntity entity
             {
                 return new string [] {Path.Combine(path, "LongDirectoryName")};
             }
-            else if 
+            else if
             (
                 pattern==@"LONGSU~1"
                 && (@"D:\LongDirectoryName"==path || @"\\server\share\LongDirectoryName"==path || @"LongDirectoryName"==path)
@@ -48,7 +48,7 @@ private static string[] GetFileSystemEntries(FileMatcher.FileSystemEntity entity
             {
                 return new string [] {Path.Combine (path, "LongSubDirectory")};
             }
-            else if 
+            else if
             (
                 pattern==@"LONGFI~1.TXT"
                 && (@"D:\LongDirectoryName\LongSubDirectory"==path || @"\\server\share\LongDirectoryName\LongSubDirectory"==path || @"LongDirectoryName\LongSubDirectory"==path)
@@ -56,14 +56,14 @@ private static string[] GetFileSystemEntries(FileMatcher.FileSystemEntity entity
             {
                 return new string[] { Path.Combine (path, "LongFileName.txt") };
             }
-            else if 
+            else if
             (
                 pattern==@"pomegr~1"
                 && @"c:\apple\banana\tomato"==path
             )
             {
                 return new string[] { Path.Combine (path, "pomegranate") };
-            } 
+            }
             else if
             (
                 @"c:\apple\banana\tomato\pomegranate\orange"==path
@@ -71,8 +71,8 @@ private static string[] GetFileSystemEntries(FileMatcher.FileSystemEntity entity
             {
                 // No files exist here. This is an empty directory.
                 return new string[0];
-            }            
-            else            
+            }
+            else
             {
                 Console.WriteLine("GetFileSystemEntries('{0}', '{1}')", path, pattern);
                 Assertion.Assert("Unexpected input into GetFileSystemEntries", false);
@@ -102,12 +102,12 @@ public void BasicMatchDriver()
                 null
             );
         }
-        
+
         /// <summary>
         /// This pattern should *not* recurse indefinitely since there is no '**' in the pattern:
-        /// 
+        ///
         ///        c:\?emp\foo
-        /// 
+        ///
         /// </summary>
         [Test]
         public void Regress162390()
@@ -118,9 +118,9 @@ public void Regress162390()
                 new string[] { @"c:\temp\foo.txt" },    // Should match
                 new string[] { @"c:\timp\foo.txt" },    // Shouldn't match
                 new string[]                            // Should not even consider.
-                { 
+                {
                     @"c:\temp\sub\foo.txt"
-                } 
+                }
             );
         }
 
@@ -128,9 +128,9 @@ public void Regress162390()
         /*
         * Method:  GetLongFileNameForShortLocalPath
         * Owner:   jomof
-        * 
+        *
         * Convert a short local path to a long path.
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForShortLocalPath()
@@ -140,16 +140,16 @@ public void GetLongFileNameForShortLocalPath()
                 @"D:\LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(longPath, @"D:\LongDirectoryName\LongSubDirectory\LongFileName.txt");
-        } 
-               
+        }
+
         /*
         * Method:  GetLongFileNameForLongLocalPath
         * Owner:   jomof
-        * 
+        *
         * Convert a long local path to a long path (nop).
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForLongLocalPath()
@@ -159,16 +159,16 @@ public void GetLongFileNameForLongLocalPath()
                 @"D:\LongDirectoryName\LongSubDirectory\LongFileName.txt",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(longPath, @"D:\LongDirectoryName\LongSubDirectory\LongFileName.txt");
-        }    
-        
+        }
+
         /*
         * Method:  GetLongFileNameForShortUncPath
         * Owner:   jomof
-        * 
+        *
         * Convert a short UNC path to a long path.
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForShortUncPath()
@@ -178,16 +178,16 @@ public void GetLongFileNameForShortUncPath()
                 @"\\server\share\LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(longPath, @"\\server\share\LongDirectoryName\LongSubDirectory\LongFileName.txt");
-        } 
-               
+        }
+
         /*
         * Method:  GetLongFileNameForLongUncPath
         * Owner:   jomof
-        * 
+        *
         * Convert a long UNC path to a long path (nop)
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForLongUncPath()
@@ -197,16 +197,16 @@ public void GetLongFileNameForLongUncPath()
                 @"\\server\share\LongDirectoryName\LongSubDirectory\LongFileName.txt",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(longPath, @"\\server\share\LongDirectoryName\LongSubDirectory\LongFileName.txt");
-        }     
-        
+        }
+
         /*
         * Method:  GetLongFileNameForRelativePath
         * Owner:   jomof
-        * 
+        *
         * Convert a short relative path to a long path
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForRelativePath()
@@ -216,16 +216,16 @@ public void GetLongFileNameForRelativePath()
                 @"LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(longPath, @"LongDirectoryName\LongSubDirectory\LongFileName.txt");
-        }       
-        
+        }
+
         /*
         * Method:  GetLongFileNameForRelativePathPreservesTrailingSlash
         * Owner:   jomof
-        * 
+        *
         * Convert a short relative path with a trailing backslash to a long path
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForRelativePathPreservesTrailingSlash()
@@ -235,16 +235,16 @@ public void GetLongFileNameForRelativePathPreservesTrailingSlash()
                 @"LONGDI~1\LONGSU~1\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(@"LongDirectoryName\LongSubDirectory\", longPath);
-        }           
-        
+        }
+
         /*
         * Method:  GetLongFileNameForRelativePathPreservesExtraSlashes
         * Owner:   jomof
-        * 
+        *
         * Convert a short relative path with doubled embedded backslashes to a long path
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForRelativePathPreservesExtraSlashes()
@@ -254,16 +254,16 @@ public void GetLongFileNameForRelativePathPreservesExtraSlashes()
                 @"LONGDI~1\\LONGSU~1\\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(@"LongDirectoryName\\LongSubDirectory\\", longPath);
-        }  
-            
+        }
+
         /*
         * Method:  GetLongFileNameForMixedLongAndShort
         * Owner:   jomof
-        * 
+        *
         * Only part of the path might be short.
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForMixedLongAndShort()
@@ -273,17 +273,17 @@ public void GetLongFileNameForMixedLongAndShort()
                 @"c:\apple\banana\tomato\pomegr~1\orange\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals (@"c:\apple\banana\tomato\pomegranate\orange\", longPath);
-        } 
-        
+        }
+
         /*
         * Method:  GetLongFileNameWherePartOfThePathDoesntExist
         * Owner:   jomof
-        * 
+        *
         * Part of the path may not exist. In this case, we treat the non-existent parts
         * as if they were already a long file name.
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameWherePartOfThePathDoesntExist()
@@ -293,44 +293,44 @@ public void GetLongFileNameWherePartOfThePathDoesntExist()
                 @"c:\apple\banana\tomato\pomegr~1\orange\chocol~1\vanila~1",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals (@"c:\apple\banana\tomato\pomegranate\orange\chocol~1\vanila~1", longPath);
-        }                
-        
+        }
+
         [Test]
         public void BasicMatch()
         {
             ValidateFileMatch("file.txt", "File.txt", false);
             ValidateNoFileMatch("file.txt", "File.bin", false);
         }
-        
+
         [Test]
         public void MatchSingleCharacter()
         {
             ValidateFileMatch("file.?xt", "File.txt", false);
             ValidateNoFileMatch("file.?xt", "File.bin", false);
         }
-        
+
         [Test]
         public void MatchMultipleCharacters()
         {
             ValidateFileMatch("*.txt", "*.txt", false);
             ValidateNoFileMatch("*.txt", "*.bin", false);
         }
-        
+
         [Test]
         public void SimpleRecursive()
         {
             ValidateFileMatch("**", ".\\File.txt", true);
         }
-        
+
         [Test]
         public void DotForCurrentDirectory()
         {
             ValidateFileMatch(".\\file.txt", ".\\File.txt", false);
             ValidateNoFileMatch(".\\file.txt", ".\\File.bin", false);
         }
-                                        
+
         [Test]
         public void DotDotForParentDirectory()
         {
@@ -339,17 +339,17 @@ public void DotDotForParentDirectory()
             ValidateNoFileMatch("..\\..\\*.*", "..\\..\\dir1\\dir2\\File.txt", false);
             ValidateNoFileMatch("..\\..\\*.*", "..\\..\\dir1\\dir2\\File", false);
         }
-        
+
         [Test]
         public void ReduceDoubleSlashesBaseline()
         {
             // Baseline
             ValidateFileMatch("f:\\dir1\\dir2\\file.txt", "f:\\dir1\\dir2\\file.txt", false);
             ValidateFileMatch("**\\*.cs", "dir1\\dir2\\file.cs", true);
-            ValidateFileMatch("**\\*.cs", "file.cs", true);     
-        } 
-           
-            
+            ValidateFileMatch("**\\*.cs", "file.cs", true);
+        }
+
+
         [Test]
         public void ReduceDoubleSlashes()
         {
@@ -371,7 +371,7 @@ public void DoubleSlashesOnBothSidesOfComparison()
             ValidateFileMatch("..\\**/.\\*.cs", "..\\dir1\\dir2//\\file.cs", true, false);
             ValidateFileMatch("..\\**\\./.\\*.cs", "..\\dir1/\\/\\/dir2\\file.cs", true, false);
         }
-        
+
         [Test]
         public void DecomposeDotSlash()
         {
@@ -387,11 +387,11 @@ public void DecomposeDotSlash()
             ValidateFileMatch(".//dir1\\dir2\\file.txt", ".\\dir1\\dir2\\file.txt", false);
             ValidateFileMatch(".//.//dir1\\dir2\\file.txt", ".\\dir1\\dir2\\file.txt", false);
         }
-        
+
         [Test]
         public void RecursiveDirRecursive()
         {
-           // Check that a wildcardpath of **\x\**\ matches correctly since, \**\ is a 
+           // Check that a wildcardpath of **\x\**\ matches correctly since, \**\ is a
             // separate code path.
             ValidateFileMatch(@"c:\foo\**\x\**\*.*", @"c:\foo\x\file.txt", true);
             ValidateFileMatch(@"c:\foo\**\x\**\*.*", @"c:\foo\y\x\file.txt", true);
@@ -411,23 +411,23 @@ public void Regress155731()
             ValidateFileMatch(@"a\b\**\**\**\e\*", @"a\b\c\d\e\f.txt", true);
             ValidateFileMatch(@"a\b\**\**\**\**\e\*", @"a\b\c\d\e\f.txt", true);
         }
-           
+
         [Test]
         public void ParentWithoutSlash()
         {
             // However, we don't wtool this to match,
             ValidateNoFileMatch(@"C:\foo\**", @"C:\foo", true);
             // becase we don't know whether foo is a file or folder.
-            
+
             // Same for UNC
             ValidateNoFileMatch
                 (
                 "\\\\server\\c$\\Documents and Settings\\User\\**",
                 "\\\\server\\c$\\Documents and Settings\\User",
                 true
-                );            
-        } 
-                                       
+                );
+        }
+
         [Test]
         public void Unc()
         {
@@ -465,9 +465,9 @@ public void Unc()
                 "\\\\server\\c$\\Documents and Settings\\User\\Source.cs",
                 true
                 );
-        
+
         }
-        
+
         [Test]
         public void ExplicitToolCompatibility()
         {
@@ -491,45 +491,45 @@ public void ExplicitToolCompatibility()
             ValidateFileMatch("org/IIS/**/SourceSafe/*", "org/IIS\\SourceSafe/Entries", true);
             ValidateFileMatch("org/IIS/**/SourceSafe/*", "org/IIS/pluggin/tools/tool/SourceSafe/Entries", true);
             ValidateNoFileMatch("org/IIS/**/SourceSafe/*", "org/IIS/SourceSafe/foo/bar/Entries", true);
-            ValidateNoFileMatch("org/IIS/**/SourceSafe/*", "org/IISSourceSage/Entries", true);        
+            ValidateNoFileMatch("org/IIS/**/SourceSafe/*", "org/IISSourceSage/Entries", true);
         }
-        
+
         [Test]
         public void ExplicitToolIncompatibility()
         {
             // NOTE: Weirdly, ANT syntax is to match a file here.
             // We don't because MSBuild philosophy is that a trailing slash indicates a directory
-            ValidateNoFileMatch("**/test/**", ".\\test", true); 
+            ValidateNoFileMatch("**/test/**", ".\\test", true);
 
             // NOTE: We deviate from ANT format here. ANT would append a ** to any path
             // that ends with '/' or '\'. We think this is the wrong thing because 'folder\'
             // is a valid folder name.
             ValidateNoFileMatch("org/", "org/IISSourceSage/Entries", false);
-            ValidateNoFileMatch("org\\", "org/IISSourceSage/Entries", false);        
+            ValidateNoFileMatch("org\\", "org/IISSourceSage/Entries", false);
         }
-        
+
         [Test]
         public void MultipleStarStar()
         {
-            // Multiple-** matches 
+            // Multiple-** matches
             ValidateFileMatch("c:\\**\\jomof\\**\\*.*", "c:\\Documents and Settings\\JomoF\\NTUSER.DAT", true);
             ValidateNoFileMatch("c:\\**\\jomof1\\**\\*.*", "c:\\Documents and Settings\\JomoF\\NTUSER.DAT", true);
             ValidateFileMatch("c:\\**\\jomof\\**\\*.*", "c://Documents and Settings\\JomoF\\NTUSER.DAT", true);
             ValidateNoFileMatch("c:\\**\\jomof1\\**\\*.*", "c:\\Documents and Settings//JomoF\\NTUSER.DAT", true);
-    
+
         }
-        
+
         [Test]
         public void Regress54411()
         {
             // Regress bug#54411:  Item recursion doesn't work as expected on "c:\foo\**"
-            ValidateFileMatch("c:\\foo\\**", "c:\\foo\\bar\\subfile.txt", true);    
+            ValidateFileMatch("c:\\foo\\**", "c:\\foo\\bar\\subfile.txt", true);
         }
-        
+
         [Test]
         public void IllegalPaths()
         {
-            
+
             // Certain patterns are illegal.
             ValidateIllegal("**.cs");
             ValidateIllegal("***");
@@ -578,7 +578,7 @@ public void Regress367780_CrashOnStarDotDot()
                 Directory.Delete(workingPathSubfolder);
                 Directory.Delete(workingPath);
             }
-            
+
         }
 
         [Test]
@@ -1061,12 +1061,12 @@ internal bool DirectoryExists(string path)
 
         /// <summary>
         /// A general purpose method used to:
-        /// 
+        ///
         /// (1) Simulate a file system.
         /// (2) Check whether all matchingFiles where hit by the filespec pattern.
         /// (3) Check whether all nonmatchingFiles were *not* hit by the filespec pattern.
         /// (4) Check whether all untouchableFiles were not even requested (usually for perf reasons).
-        /// 
+        ///
         /// These can be used in various combinations to test the filematcher framework.
         /// </summary>
         /// <param name="filespec">A FileMatcher filespec, possibly with wildcards.</param>
@@ -1163,17 +1163,17 @@ string expectedFilenamePart
                 string filenamePart;
                 FileMatcher.SplitFileSpec
                 (
-                    filespec, 
-                    out fixedDirectoryPart, 
-                    out wildcardDirectoryPart, 
+                    filespec,
+                    out fixedDirectoryPart,
+                    out wildcardDirectoryPart,
                     out filenamePart,
                     new FileMatcher.GetFileSystemEntries(GetFileSystemEntriesLoopBack)
                 );
 
-                if 
+                if
                     (
-                    expectedWildcardDirectoryPart!=wildcardDirectoryPart 
-                    || expectedFixedDirectoryPart!=fixedDirectoryPart 
+                    expectedWildcardDirectoryPart!=wildcardDirectoryPart
+                    || expectedFixedDirectoryPart!=fixedDirectoryPart
                     || expectedFilenamePart!=filenamePart
                     )
                 {
@@ -1197,7 +1197,7 @@ bool shouldBeRecursive
             {
                 ValidateFileMatch(filespec, fileToMatch, shouldBeRecursive, /* Simulate filesystem? */ true);
             }
-            
+
             /*************************************************************************************
             * Given a pattern (filespec) and a candidate filename (fileToMatch). Verify that they
             * do indeed match.
@@ -1216,7 +1216,7 @@ bool fileSystemSimulation
                 }
 
                 // Now, simulate a filesystem with only fileToMatch. Make sure the file exists that way.
-                if (fileSystemSimulation) 
+                if (fileSystemSimulation)
                 {
                     MatchDriver
                     (
@@ -1320,7 +1320,7 @@ bool shouldBeRecursive
 
 
 
-#endregion        
+#endregion
     }
 }
 
diff --git a/src/Deprecated/Engine/Shared/UnitTests/FileUtilities_Tests.cs b/src/Deprecated/Engine/Shared/UnitTests/FileUtilities_Tests.cs
index a51a2a98b5b..8237c76152d 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/FileUtilities_Tests.cs
@@ -266,7 +266,7 @@ public void IsItemSpecModifier()
             Assertion.Assert("test 57", !FileUtilities.IsItemSpecModifier("createdxxxx"));
             Assertion.Assert("test 58", !FileUtilities.IsItemSpecModifier("Createdxxxx"));
             Assertion.Assert("test 59", !FileUtilities.IsItemSpecModifier("xxxxxxxxxxx"));
-            
+
             Assertion.Assert("test 60", !FileUtilities.IsItemSpecModifier("recursivexxx"));
             Assertion.Assert("test 61", !FileUtilities.IsItemSpecModifier("Recursivexxx"));
             Assertion.Assert("test 62", !FileUtilities.IsItemSpecModifier("accessedxxxx"));
@@ -274,7 +274,7 @@ public void IsItemSpecModifier()
             Assertion.Assert("test 64", !FileUtilities.IsItemSpecModifier("modifiedxxxx"));
             Assertion.Assert("test 65", !FileUtilities.IsItemSpecModifier("Modifiedxxxx"));
             Assertion.Assert("test 66", !FileUtilities.IsItemSpecModifier("xxxxxxxxxxxx"));
-            
+
             Assertion.Assert("test 67", !FileUtilities.IsItemSpecModifier(null));
         }
 
diff --git a/src/Deprecated/Engine/Shared/UnitTests/MockEngine.cs b/src/Deprecated/Engine/Shared/UnitTests/MockEngine.cs
index 0d6c712ce5c..6c955fb201c 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/MockEngine.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/MockEngine.cs
@@ -18,19 +18,19 @@
 namespace Microsoft.Build.UnitTests
 {
     /***************************************************************************
-     * 
+     *
      * Class:       MockEngine
      * Owner:       RGoel
-     * 
+     *
      * In order to execute tasks, we have to pass in an Engine object, so the
      * task can log events.  It doesn't have to be the real Engine object, just
      * something that implements the IBuildEngine2 interface.  So, we mock up
      * a fake engine object here, so we're able to execute tasks from the unit tests.
-     * 
+     *
      * The unit tests could have instantiated the real Engine object, but then
      * we would have had to take a reference onto the Microsoft.Build.Engine assembly, which
      * is somewhat of a no-no for task assemblies.
-     * 
+     *
      **************************************************************************/
     sealed internal class MockEngine : IBuildEngine2
     {
@@ -167,7 +167,7 @@ public int ColumnNumberOfTaskNode
                 return 0;
             }
         }
-        
+
         public BuildPropertyGroup GlobalProperties
         {
             set { engineGlobalProperties = value; }
@@ -179,7 +179,7 @@ internal string Log
             set { log = value; }
             get { return log; }
         }
-        
+
         public bool IsRunningMultipleNodes
         {
             get { return isRunningMultipleNodes; }
@@ -188,9 +188,9 @@ public bool IsRunningMultipleNodes
 
         public bool BuildProjectFile
             (
-            string projectFileName, 
-            string[] targetNames, 
-            IDictionary globalPropertiesPassedIntoTask, 
+            string projectFileName,
+            string[] targetNames,
+            IDictionary globalPropertiesPassedIntoTask,
             IDictionary targetOutputs
             )
         {
@@ -220,7 +220,7 @@ string toolsVersion
 
             return engine.BuildProjectFile(projectFileName, targetNames, finalGlobalProperties, targetOutputs, BuildSettings.None, toolsVersion);
         }
-        
+
         public bool BuildProjectFilesInParallel
         (
             string[] projectFileNames,
@@ -238,7 +238,7 @@ bool unloadProjectsOnCompletion
             for (int i = 0; i < projectFileNames.Length; i++)
             {
 
-                BuildPropertyGroup finalGlobalProperties = null;  
+                BuildPropertyGroup finalGlobalProperties = null;
                 if (globalProperties[i] != null)
                 {
                     finalGlobalProperties = new BuildPropertyGroup();
@@ -265,7 +265,7 @@ string projectFileName
 
         public bool BuildProjectFile
             (
-            string projectFileName, 
+            string projectFileName,
             string[] targetNames
             )
         {
@@ -275,7 +275,7 @@ string[] targetNames
 
         public bool BuildProjectFile
             (
-            string projectFileName, 
+            string projectFileName,
             string targetName
             )
         {
@@ -292,14 +292,14 @@ BuildPropertyGroup globalProperties
         {
             return engine.BuildProjectFile(projectFile, targetNames, globalProperties);
         }
-        
+
         public void UnregisterAllLoggers
             (
             )
         {
             engine.UnregisterAllLoggers();
         }
-        
+
         public void UnloadAllProjects
             (
             )
@@ -321,7 +321,7 @@ internal void AssertLogContains(string contains)
                 upperLog = log;
                 upperLog = upperLog.ToUpperInvariant();
             }
-            
+
             // If we do not contain this string than pass it to
             // MockLogger. Since MockLogger is also registered as
             // a logger it may have this string.
@@ -331,7 +331,7 @@ internal void AssertLogContains(string contains)
                 )
               )
             {
-               mockLogger.AssertLogContains(contains); 
+               mockLogger.AssertLogContains(contains);
             }
         }
 
@@ -356,7 +356,7 @@ internal void AssertLogDoesntContain(string contains)
                     contains.ToUpperInvariant()
                 )
             );
-            
+
             // If we do not contain this string than pass it to
             // MockLogger. Since MockLogger is also registered as
             // a logger it may have this string.
diff --git a/src/Deprecated/Engine/Shared/UnitTests/MockLogger.cs b/src/Deprecated/Engine/Shared/UnitTests/MockLogger.cs
index 330c0d1a9d7..91576965afd 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/MockLogger.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/MockLogger.cs
@@ -17,7 +17,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 
-    
+
 namespace Microsoft.Build.UnitTests
 {
     /*
@@ -38,7 +38,7 @@ internal sealed class MockLogger : ILogger
         private List<BuildWarningEventArgs> warnings = new List<BuildWarningEventArgs>();
         private List<ExternalProjectStartedEventArgs> externalProjectStartedEvents = new List<ExternalProjectStartedEventArgs>();
         private List<ExternalProjectFinishedEventArgs> externalProjectFinishedEvents = new List<ExternalProjectFinishedEventArgs>();
-        
+
         /*
          * Method:  ErrorCount
          * Owner:   jomof
@@ -49,8 +49,8 @@ internal sealed class MockLogger : ILogger
         internal int ErrorCount
         {
             get { return this.errorCount; }
-        }          
-        
+        }
+
         /*
          * Method:  WarningCount
          * Owner:   jomof
@@ -113,9 +113,9 @@ internal List<ExternalProjectFinishedEventArgs> ExternalProjectFinishedEvents
         internal string FullLog
         {
             get { return this.fullLog.ToString(); }
-        }      
-#endregion                    
-        
+        }
+#endregion
+
 #region Minimal ILogger implementation
 
         /*
@@ -129,14 +129,14 @@ public LoggerVerbosity Verbosity
         {
             get  {return LoggerVerbosity.Normal;}
             set  {/* do nothing */}
-        }  
-        
+        }
+
         /*
          * Property:    Parameters
          * Owner:       SumedhK
-         * 
+         *
          * The mock logger does not take parameters.
-         * 
+         *
          */
         public string Parameters
         {
@@ -150,7 +150,7 @@ public string Parameters
                 // do nothing
             }
         }
-        
+
         /*
          * Method:  Initialize
          * Owner:   jomof
@@ -175,9 +175,9 @@ public void ClearLog()
         /*
          * Method:  Shutdown
          * Owner:   SumedhK
-         * 
+         *
          * The mock logger does not need to release any resources.
-         * 
+         *
          */
         public void Shutdown()
         {
@@ -203,7 +203,7 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                 if (w.Code != "MSB4056" && !w.Message.Contains("MSB4056"))
                 {
                     fullLog.AppendFormat("{0}({1},{2}): {3} warning {4}: {5}\r\n",
-                        w.File, 
+                        w.File,
                         w.LineNumber,
                         w.ColumnNumber,
                         w.Subcategory,
@@ -219,7 +219,7 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                 BuildErrorEventArgs e = (BuildErrorEventArgs) eventArgs;
 
                 fullLog.AppendFormat("{0}({1},{2}): {3} error {4}: {5}\r\n",
-                    e.File, 
+                    e.File,
                     e.LineNumber,
                     e.ColumnNumber,
                     e.Subcategory,
diff --git a/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs b/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
index 1d28600ad11..980d0451b44 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
@@ -20,7 +20,7 @@
 using Microsoft.Build.BuildEngine;
 using Microsoft.Build.Framework;
 using Microsoft.VisualStudio.Internal;
-    
+
 namespace Microsoft.Build.UnitTests
 {
     /*
@@ -30,14 +30,14 @@ namespace Microsoft.Build.UnitTests
      * Utility methods for unit tests that work through the object model.
      *
      */
-    public static class ObjectModelHelpers        
+    public static class ObjectModelHelpers
     {
         private const string msbuildNamespace = "http://schemas.microsoft.com/developer/msbuild/2003";
         private const string msbuildDefaultToolsVersion = BrandNames.VSGeneralVersion;
         private const string msbuildAssemblyVersion = BrandNames.VSGeneralAssemblyVersion;
 
         /// <summary>
-        /// Return the default tools version 
+        /// Return the default tools version
         /// </summary>
         internal static string MSBuildDefaultToolsVersion
         {
@@ -52,7 +52,7 @@ private set
         }
 
         /// <summary>
-        /// Return the current assembly version 
+        /// Return the current assembly version
         /// </summary>
         internal static string MSBuildAssemblyVersion
         {
@@ -124,7 +124,7 @@ static internal BuildItem AssertSingleItem(Project p, string type, string itemIn
 
         /// <summary>
         /// Given a hash table of ITaskItems, make sure there is exactly one
-        /// item and that the key is 'key' and the Value is an ITaskItem with 
+        /// item and that the key is 'key' and the Value is an ITaskItem with
         /// an item spec of 'itemSpec'
         /// </summary>
         /// <param name="d"></param>
@@ -151,19 +151,19 @@ static internal void AssertSingleItemInDictionary(IDictionary d, string expected
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
@@ -174,19 +174,19 @@ static internal void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
@@ -226,7 +226,7 @@ static internal void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
             for (int actualItemIndex = 0 ; actualItemIndex < actualItems.Length ; actualItemIndex++)
             {
                 ITaskItem actualItem = actualItems[actualItemIndex];
-                
+
                 // Loop through all the expected items to find one with the same item spec.
                 ITaskItem expectedItem = null;
                 int expectedItemIndex;
@@ -260,13 +260,13 @@ static internal void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
                         string expectedMetadataValue = expectedItem.GetMetadata(metadataName);
                         string actualMetadataValue = actualItem.GetMetadata(metadataName);
 
-                        Assertion.Assert(string.Format("Item '{0}' does not have expected metadata '{1}'.", actualItem.ItemSpec, metadataName), 
+                        Assertion.Assert(string.Format("Item '{0}' does not have expected metadata '{1}'.", actualItem.ItemSpec, metadataName),
                             actualMetadataValue.Length > 0 || expectedMetadataValue.Length == 0);
 
-                        Assertion.Assert(string.Format("Item '{0}' has unexpected metadata {1}={2}.", actualItem.ItemSpec, metadataName, actualMetadataValue), 
+                        Assertion.Assert(string.Format("Item '{0}' has unexpected metadata {1}={2}.", actualItem.ItemSpec, metadataName, actualMetadataValue),
                             actualMetadataValue.Length == 0 || expectedMetadataValue.Length > 0);
 
-                        Assertion.Assert(string.Format("Item '{0}' has metadata {1}={2} instead of expected {1}={3}.", 
+                        Assertion.Assert(string.Format("Item '{0}' has metadata {1}={2} instead of expected {1}={3}.",
                             actualItem.ItemSpec, metadataName, actualMetadataValue, expectedMetadataValue),
                             actualMetadataValue == expectedMetadataValue);
                     }
@@ -377,7 +377,7 @@ static internal string CleanupFileContents(string projectFileContents)
         /// <owner>RGoel</owner>
         static private string NormalizeXmlWhitespace(XmlDocument xmldoc)
         {
-            // Normalize all the whitespace by writing the Xml document out to a 
+            // Normalize all the whitespace by writing the Xml document out to a
             // string, with PreserveWhitespace=false.
             xmldoc.PreserveWhitespace = false;
             StringWriter stringWriter = new StringWriter();
@@ -421,7 +421,7 @@ static internal Project CreateInMemoryProject(string xml)
         {
             return CreateInMemoryProject(xml, new ConsoleLogger());
         }
-        
+
         /// <summary>
         /// Create a project in memory. Load up the given XML.
         /// </summary>
@@ -488,7 +488,7 @@ static internal Project CreateInMemoryProject(Engine e, string xml, ILogger logg
             // Return to the original directory.
             Directory.SetCurrentDirectory(originalDir);
 
-            return p;   
+            return p;
         }
 
         /// <summary>
@@ -591,10 +591,10 @@ internal static void DeleteTempProjectDirectory()
             // For some reason sometimes get "directory is not empty"
             // Try to be as robust as possible using retries and catching all exceptions.
             for (int retries = 0; retries < 5; retries++)
-            {          
+            {
                 try
                 {
-                    // Manually deleting all children, but intentionally leaving the 
+                    // Manually deleting all children, but intentionally leaving the
                     // Temp project directory behind due to locking issues which were causing
                     // failures in main on Amd64-WOW runs.
                     if (Directory.Exists(TempProjectDir))
@@ -630,7 +630,7 @@ internal static string CreateFileInTempProjectDirectory(string fileRelativePath,
 
             // retries to deal with occasional locking issues where the file can't be written to initially
             for (int retries = 0; retries < 5; retries++)
-            {          
+            {
                 try
                 {
                     File.WriteAllText(fullFilePath, CleanupFileContents(fileContents));
@@ -642,11 +642,11 @@ internal static string CreateFileInTempProjectDirectory(string fileRelativePath,
                     {
                         Console.WriteLine(ex.ToString());
                     }
-                    else 
+                    else
                     {
-                        // All the retries have failed, so we're pretty much screwed. Might as well fail with the 
-                        // actual problem now instead of with some more difficult-to-understand 
-                        // issue later. 
+                        // All the retries have failed, so we're pretty much screwed. Might as well fail with the
+                        // actual problem now instead of with some more difficult-to-understand
+                        // issue later.
                         throw ex;
                     }
                 }
diff --git a/src/Deprecated/Engine/Shared/UnitTests/SolutionParser_Tests.cs b/src/Deprecated/Engine/Shared/UnitTests/SolutionParser_Tests.cs
index cfebd960b5a..2d8491dfb9a 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/SolutionParser_Tests.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/SolutionParser_Tests.cs
@@ -34,7 +34,7 @@ public void BasicParseFirstProjectLine()
 
             p.ParseFirstProjectLine
             (
-                "Project(\"{Project GUID}\") = \"Project name\", \"Relative path to project file\", \"Unique name-GUID\"", 
+                "Project(\"{Project GUID}\") = \"Project name\", \"Relative path to project file\", \"Unique name-GUID\"",
                  proj
             );
             Assertion.AssertEquals(SolutionProjectType.Unknown, proj.ProjectType);
@@ -56,7 +56,7 @@ public void ParseFirstProjectLineWithDifferentSpacing()
 
             p.ParseFirstProjectLine
             (
-                "Project(\" {Project GUID} \")  = \" Project name \",  \" Relative path to project file \"    , \" Unique name-GUID \"", 
+                "Project(\" {Project GUID} \")  = \" Project name \",  \" Relative path to project file \"    , \" Unique name-GUID \"",
                  proj
             );
             Assertion.AssertEquals(SolutionProjectType.Unknown, proj.ProjectType);
@@ -94,7 +94,7 @@ public void ParseEtpProject()
                         </References>
                     </GENERAL>
                 </EFPROJECT>";
-               
+
                 File.WriteAllText(proj1Path, etpProjContent);
 
                 // Create the SolutionParser object
@@ -350,7 +350,7 @@ public void ParseNestedEtpProjectMultipleLevel()
                 File.Delete(proj2Path);
                 File.Delete(proj3Path);
             }
-            
+
         }
 
         /// <summary>
@@ -450,14 +450,14 @@ public void ParseFirstProjectLineWhereProjectNameHasSpecialCharacters()
 
             p.ParseFirstProjectLine
             (
-                "Project(\"{Project GUID}\")  = \"MyProject,(=IsGreat)\",  \"Relative path to project file\"    , \"Unique name-GUID\"", 
+                "Project(\"{Project GUID}\")  = \"MyProject,(=IsGreat)\",  \"Relative path to project file\"    , \"Unique name-GUID\"",
                  proj
             );
             Assertion.AssertEquals(SolutionProjectType.Unknown, proj.ProjectType);
             Assertion.AssertEquals("MyProject,(=IsGreat)", proj.ProjectName);
             Assertion.AssertEquals("Relative path to project file", proj.RelativePath);
             Assertion.AssertEquals("Unique name-GUID", proj.ProjectGuid);
-        }   
+        }
 
         /// <summary>
         /// Helper method to create a SolutionParser object, and call it to parse the SLN file
@@ -502,7 +502,7 @@ public void BadVersionStamp()
 
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
         }
-        
+
         /// <summary>
         /// Expected version numbers less than 7 to cause an invalid project file exception.
         /// </summary>
@@ -547,7 +547,7 @@ public void Version9()
                 ";
 
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
-            
+
             Assertion.AssertEquals(9, solution.Version);
         }
 
@@ -566,7 +566,7 @@ public void Version10()
         }
 
         /// <summary>
-        /// Test to parse a very basic .sln file to validate that description property in a solution file 
+        /// Test to parse a very basic .sln file to validate that description property in a solution file
         /// is properly handled.
         /// </summary>
         /// <owner>yroy</owner>
@@ -650,7 +650,7 @@ public void BasicSolution()
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
 
             Assertion.AssertEquals(3, solution.Projects.Length);
-            
+
             Assertion.AssertEquals(SolutionProjectType.ManagedProject,  solution.Projects[0].ProjectType);
             Assertion.AssertEquals("ConsoleApplication1",                      solution.Projects[0].ProjectName);
             Assertion.AssertEquals(@"ConsoleApplication1\ConsoleApplication1.vbproj", solution.Projects[0].RelativePath);
@@ -675,7 +675,7 @@ public void BasicSolution()
             Assertion.AssertEquals(null,                                       solution.Projects[2].ParentProjectGuid);
             Assertion.AssertEquals("ClassLibrary1",                            solution.Projects[2].GetUniqueProjectName());
 
-        }   
+        }
 
         /// <summary>
         /// Exercises solution folders, and makes sure that samely named projects in different
@@ -731,7 +731,7 @@ public void SolutionFolders()
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
 
             Assertion.AssertEquals(5, solution.Projects.Length);
-            
+
             Assertion.AssertEquals(@"ClassLibrary1\ClassLibrary1.csproj",      solution.Projects[0].RelativePath);
             Assertion.AssertEquals("{34E0D07D-CF8F-459D-9449-C4188D8C5564}",   solution.Projects[0].ProjectGuid);
             Assertion.AssertEquals(0,                                          solution.Projects[0].Dependencies.Count);
@@ -815,7 +815,7 @@ public void SolutionDependencies()
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
 
             Assertion.AssertEquals(3, solution.Projects.Length);
-            
+
             Assertion.AssertEquals(@"ClassLibrary1\ClassLibrary1.csproj",      solution.Projects[0].RelativePath);
             Assertion.AssertEquals("{05A5AD00-71B5-4612-AF2F-9EA9121C4111}",   solution.Projects[0].ProjectGuid);
             Assertion.AssertEquals(1,                                          solution.Projects[0].Dependencies.Count);
@@ -891,7 +891,7 @@ public void VenusProject()
             SolutionParser solution = ParseSolutionHelper(solutionFileContents.Replace('`', '"'));
 
             Assertion.AssertEquals(1, solution.Projects.Length);
-            
+
             Assertion.AssertEquals(SolutionProjectType.WebProject,      solution.Projects[0].ProjectType);
             Assertion.AssertEquals(@"C:\WebSites\WebApplication3\",            solution.Projects[0].ProjectName);
             Assertion.AssertEquals(@"C:\WebSites\WebApplication3\",            solution.Projects[0].RelativePath);
@@ -974,7 +974,7 @@ public void VenusProjectInASolutionFolder()
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
 
             Assertion.AssertEquals(3, solution.Projects.Length);
-            
+
             Assertion.AssertEquals(SolutionProjectType.WebProject,      solution.Projects[0].ProjectType);
             Assertion.AssertEquals(@"C:\WebSites\WebApplication3\",            solution.Projects[0].GetUniqueProjectName());
 
@@ -1138,7 +1138,7 @@ public void ParseInvalidSolutionConfigurations3()
         }
 
         /// <summary>
-        /// Make sure the project configurations in solution configurations get parsed correctly 
+        /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a simple mixed C#/VC solution
         /// </summary>
         /// <owner>LukaszG</owner>
@@ -1237,7 +1237,7 @@ public void ParseProjectConfigurationsInSolutionConfigurations1()
         }
 
         /// <summary>
-        /// Make sure the project configurations in solution configurations get parsed correctly 
+        /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a more tricky solution
         /// </summary>
         /// <owner>LukaszG</owner>
diff --git a/src/Deprecated/Engine/Shared/UnitTests/XmlUtilities_Tests.cs b/src/Deprecated/Engine/Shared/UnitTests/XmlUtilities_Tests.cs
index 56948d3d86b..55f9f452285 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/XmlUtilities_Tests.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/XmlUtilities_Tests.cs
@@ -46,7 +46,7 @@ public void InvalidNameErrorLocation()
         }
 
         /// <summary>
-        /// Helper for invalid name error location test 
+        /// Helper for invalid name error location test
         /// </summary>
         /// <param name="name"></param>
         /// <param name="badChar"></param>
diff --git a/src/Deprecated/Engine/Shared/XMakeElements.cs b/src/Deprecated/Engine/Shared/XMakeElements.cs
index f179b6c2add..3e759935887 100644
--- a/src/Deprecated/Engine/Shared/XMakeElements.cs
+++ b/src/Deprecated/Engine/Shared/XMakeElements.cs
@@ -54,8 +54,8 @@ internal static bool IsValidTaskChildNode(XmlNode childNode)
         internal static readonly char[] illegalTargetNameCharacters = new char[] { '$', '@', '(', ')', '%', '*', '?', '.' };
 
         // Names that cannot be used as property or item names because they are reserved
-        internal static readonly string[] illegalPropertyOrItemNames = new string[] { 
-//            XMakeElements.project, // "Project" is not reserved, because unfortunately ProjectReference items 
+        internal static readonly string[] illegalPropertyOrItemNames = new string[] {
+//            XMakeElements.project, // "Project" is not reserved, because unfortunately ProjectReference items
                                      // already use it as metadata name.
             XMakeElements.visualStudioProject,
             XMakeElements.target,
diff --git a/src/Deprecated/Engine/Shared/XmlUtilities.cs b/src/Deprecated/Engine/Shared/XmlUtilities.cs
index 78f2965d971..700cbfdb753 100644
--- a/src/Deprecated/Engine/Shared/XmlUtilities.cs
+++ b/src/Deprecated/Engine/Shared/XmlUtilities.cs
@@ -81,7 +81,7 @@ internal static string GetXmlNodeFile(XmlNode node, string defaultFile)
         }
 
         /// <summary>
-        /// An XML document can have many root nodes, but usually we want the single root 
+        /// An XML document can have many root nodes, but usually we want the single root
         /// element. Callers can test each root node in turn with this method, until it returns
         /// true.
         /// </summary>
@@ -154,8 +154,8 @@ internal static bool IsValidElementName(string name)
         }
 
         /// <summary>
-        /// Finds the location of the first invalid character, if any, in the name of an 
-        /// item, property, or piece of metadata. Returns the location of the first invalid character, or -1 if there are none. 
+        /// Finds the location of the first invalid character, if any, in the name of an
+        /// item, property, or piece of metadata. Returns the location of the first invalid character, or -1 if there are none.
         /// Valid names must match this pattern:  [A-Za-z_][A-Za-z_0-9\-.]*
         /// Note, this is a subset of all possible valid XmlElement names: we use a subset because we also
         /// have to match this same set in our regular expressions, and allowing all valid XmlElement name
@@ -192,8 +192,8 @@ internal static int LocateFirstInvalidElementNameCharacter(string name)
         }
 
         /// <summary>
-        /// Load the xml file using XMLTextReader and locate the element and attribute specified and then 
-        /// return the value. This is a quick way to peek at the xml file whithout having the go through 
+        /// Load the xml file using XMLTextReader and locate the element and attribute specified and then
+        /// return the value. This is a quick way to peek at the xml file whithout having the go through
         /// the XMLDocument (MSDN article (Chapter 9 - Improving XML Performance)).
         /// </summary>
         internal static string GetAttributeValueForElementFromFile
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index a0bdcf41c6d..f8c02067a6f 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -213,7 +213,7 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile, st
                 return false;
             }
 
-            // We also store the version of MSBuild that wrote the file and verify it's the same as ours: that ensures that we 
+            // We also store the version of MSBuild that wrote the file and verify it's the same as ours: that ensures that we
             // don't read possibly incompatible caches.
             string thisVersion = Constants.AssemblyVersion;
             if (!String.Equals(cacheVersion, thisVersion, StringComparison.OrdinalIgnoreCase))
@@ -238,11 +238,11 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile, st
                 return false;
             }
 
-            // If there are inputs to check, we should also add the solution file, as we need to make sure the 
+            // If there are inputs to check, we should also add the solution file, as we need to make sure the
             // solution file is up to date with respect to the cache file
 
             // Get the solution file name because the solution file may be something like myDirectory\mysolution.sln
-            // and since we have already calculated the directory for the solution file, we just need the filename name to 
+            // and since we have already calculated the directory for the solution file, we just need the filename name to
             // combine with the directory to get the full path to the solution file without having to call GetFullPath again.
             string solutionFileName = Path.GetFileName(solutionFile);
             string solutionFileLocation = Path.Combine(solutionFileDirectory, solutionFileName);
@@ -297,8 +297,8 @@ private static Project CreateNewProject(SolutionParser solution, string wrapperP
         /// </summary>
         private static void CreateSolutionProject(SolutionParser solution, Project msbuildProject, BuildEventContext projectBuildEventContext, string wrapperProjectToolsVersion, Engine parentEngine, string solutionProjectCache)
         {
-            // We have to figure out what tools version the children will be built with, because we will 
-            // have to load and scan them to construct the solution wrapper project, and we should use the 
+            // We have to figure out what tools version the children will be built with, because we will
+            // have to load and scan them to construct the solution wrapper project, and we should use the
             // same tools version they'll build with.
             string childProjectToolsVersion = DetermineChildProjectToolsVersion(parentEngine, wrapperProjectToolsVersion);
 
@@ -676,7 +676,7 @@ string fullConfigurationName
             newTask.SetParameterValue("SolutionFile", solutionPath, true /* treat as literal */);
 
             // If the user passed in an override stylesheet for this .VCPROJ (by specifying a global
-            // property called VCBuildOverride), we need to use it to resolve the output path.  Override 
+            // property called VCBuildOverride), we need to use it to resolve the output path.  Override
             // stylesheets can be used to change the directory that VC projects get built to.
             newTask.SetParameterValue("Override", "$(VCBuildOverride)");
 
@@ -783,7 +783,7 @@ out string addedReferenceGuids
                         addCreateItem = true;
                     }
 
-                    // Add create item if either of the conditions above was true. 
+                    // Add create item if either of the conditions above was true.
                     // This merges the one-item item list into the main list, adding the appropriate guid metadata
                     if (addCreateItem)
                     {
@@ -914,8 +914,8 @@ string subTargetName
 
             if (subTargetName == "Publish")
             {
-                // Well, hmmm.  The VCBuild doesn't support any kind of 
-                // a "Publish" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The VCBuild doesn't support any kind of
+                // a "Publish" operation.  The best we can really do is offer up a
                 // message saying so.
                 AddErrorWarningMessageElement(newTarget, XMakeElements.warning, true, "SolutionVCProjectNoPublish");
 
@@ -1113,10 +1113,10 @@ string conditionDescribingValidConfigurations
             string destinationFolder = String.Format(CultureInfo.InvariantCulture,
                 @"$({0})\Bin\", GenerateSafePropertyName(proj, "AspNetPhysicalPath"));
 
-            // This is a bit of a hack.  We're actually calling the "Copy" task on all of 
-            // the *non-existent* files.  Why?  Because we want to emit a warning in the 
+            // This is a bit of a hack.  We're actually calling the "Copy" task on all of
+            // the *non-existent* files.  Why?  Because we want to emit a warning in the
             // log for each non-existent file, and the Copy task does that nicely for us.
-            // I would have used the <Warning> task except for the fact that we are in 
+            // I would have used the <Warning> task except for the fact that we are in
             // string-resource lockdown.
             BuildTask copyNonExistentReferencesTask = target.AddNewTask("Copy");
             copyNonExistentReferencesTask.SetParameterValue("SourceFiles", "@(" + referenceItemName + "->'%(FullPath)')", false /* Do not treat as literal */);
@@ -1124,7 +1124,7 @@ string conditionDescribingValidConfigurations
             copyNonExistentReferencesTask.Condition = String.Format(CultureInfo.InvariantCulture, "!Exists('%({0}.Identity)')", referenceItemName);
             copyNonExistentReferencesTask.ContinueOnError = true;
 
-            // Call ResolveAssemblyReference on each of the .DLL files that were found on 
+            // Call ResolveAssemblyReference on each of the .DLL files that were found on
             // disk from the .REFRESH files as well as the P2P references.  RAR will crack
             // the dependencies, find PDBs, satellite assemblies, etc., and determine which
             // files need to be copy-localed.
@@ -1222,7 +1222,7 @@ string solutionFile
 
                 if (!String.IsNullOrEmpty(lastFolderInPhysicalPath))
                 {
-                    // If there is a global property called "OutDir" set, that means the caller is trying to 
+                    // If there is a global property called "OutDir" set, that means the caller is trying to
                     // override the AspNetTargetPath.  What we want to do in this case is concatenate:
                     //  $(OutDir) + "\_PublishedWebsites" + (the last portion of the folder in the AspNetPhysicalPath).
                     BuildProperty targetPathOverrideProperty = newPropertyGroup.AddNewProperty(GenerateSafePropertyName(proj, "AspNetTargetPath"),
@@ -1360,15 +1360,15 @@ string subTargetName
 
             if (subTargetName == "Clean")
             {
-                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of 
-                // a "Clean" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of
+                // a "Clean" operation.  The best we can really do is offer up a
                 // message saying so.
                 AddErrorWarningMessageElement(newTarget, XMakeElements.message, true, "SolutionVenusProjectNoClean");
             }
             else if (subTargetName == "Publish")
             {
-                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of 
-                // a "Publish" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of
+                // a "Publish" operation.  The best we can really do is offer up a
                 // message saying so.
                 AddErrorWarningMessageElement(newTarget, XMakeElements.message, true, "SolutionVenusProjectNoPublish");
             }
@@ -1384,7 +1384,7 @@ string subTargetName
 
                 // We're going to build up an MSBuild condition string that represents the valid Configurations.
                 // We do this by OR'ing together individual conditions, each of which compares $(Configuration)
-                // with a valid configuration name.  We init our condition string to "false", so we can easily 
+                // with a valid configuration name.  We init our condition string to "false", so we can easily
                 // OR together more stuff as we go, and also easily take the negation of the condition by putting
                 // a ! around the whole thing.
                 StringBuilder conditionDescribingValidConfigurations = new StringBuilder("(false)");
@@ -1396,7 +1396,7 @@ string subTargetName
                     AspNetCompilerParameters aspNetCompilerParameters = (AspNetCompilerParameters)aspNetConfiguration.Value;
 
                     // We only add the PropertyGroup once per Venus project.  Without the following "if", we would add
-                    // the same identical PropertyGroup twice, once when AddTargetForWebProject is called with 
+                    // the same identical PropertyGroup twice, once when AddTargetForWebProject is called with
                     // subTargetName=null and once when subTargetName="Rebuild".
                     if (subTargetName == null)
                     {
@@ -1434,7 +1434,7 @@ string subTargetName
                 // Add tasks to capture the auto-refreshed file references (those .REFRESH files).
                 AddTasksToResolveAutoRefreshFileReferences(newTarget, proj, referenceItemName.ToString());
 
-                // Add a call to RAR (ResolveAssemblyReference) and the Copy task to put the referenced 
+                // Add a call to RAR (ResolveAssemblyReference) and the Copy task to put the referenced
                 // project outputs in the right place
                 AddTasksToCopyAllDependenciesIntoBinDir(newTarget, proj, referenceItemName.ToString(), conditionDescribingValidConfigurations.ToString());
 
@@ -2045,7 +2045,7 @@ private static void ScanProjectDependencies(SolutionParser solution, Engine pare
                         // the one containing the solution file, and we'd get the relative path wrong
                         msbuildProject.Load(project.AbsolutePath);
 
-                        // Project references for MSBuild projects could be affected by the active configuration, 
+                        // Project references for MSBuild projects could be affected by the active configuration,
                         // so set it before retrieving references.
                         msbuildProject.GlobalProperties.SetProperty("Configuration",
                             project.ProjectConfigurations[fullSolutionConfigurationName].ConfigurationName, true /* treat as literal */);
@@ -2061,7 +2061,7 @@ private static void ScanProjectDependencies(SolutionParser solution, Engine pare
                         }
 
                         //
-                        // ProjectDependency items work exactly like ProjectReference items from the point of 
+                        // ProjectDependency items work exactly like ProjectReference items from the point of
                         // view of determining that project B depends on project A.  This item must cause
                         // project A to be built prior to project B.
                         //
diff --git a/src/Deprecated/Engine/Solution/VCProjectParser.cs b/src/Deprecated/Engine/Solution/VCProjectParser.cs
index 285725eb8e2..34a790dfcf9 100644
--- a/src/Deprecated/Engine/Solution/VCProjectParser.cs
+++ b/src/Deprecated/Engine/Solution/VCProjectParser.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BuildEngine
     internal static class VCProjectParser
     {
         /// <summary>
-        /// For a given VC project, retrieves the projects it references 
+        /// For a given VC project, retrieves the projects it references
         /// </summary>
         /// <param name="projectPath"></param>
         /// <returns></returns>
diff --git a/src/Deprecated/Engine/Solution/VCWrapperProject.cs b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
index 95534559b85..b8b79a7e356 100644
--- a/src/Deprecated/Engine/Solution/VCWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
@@ -35,8 +35,8 @@ string subTargetName
             Target newTarget = msbuildProject.Targets.AddNewTarget(targetName);
             if (subTargetName == "Publish")
             {
-                // Well, hmmm.  The VCBuild doesn't support any kind of 
-                // a "Publish" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The VCBuild doesn't support any kind of
+                // a "Publish" operation.  The best we can really do is offer up a
                 // message saying so.
                 SolutionWrapperProject.AddErrorWarningMessageElement(newTarget, XMakeElements.error, true, "SolutionVCProjectNoPublish");
             }
@@ -221,7 +221,7 @@ internal static string VCBuildLocationHint
         }
 
         // The code below is mostly copied from the VCBuild task that we shipped in 3.5.
-        // It is the logic it uses to find vcbuild.exe. That logic had a flaw - 
+        // It is the logic it uses to find vcbuild.exe. That logic had a flaw -
         // in 64 bit MSBuild, in a vanilla command window (like in Team Build) it would not
         // find vcbuild.exe. We use the logic below to predict whether VCBuild will find it,
         // and if it won't, we will pass the "hint" to use the 64 bit program files location.
@@ -231,7 +231,7 @@ internal static string VCBuildLocationHint
         /// </summary>
         // root registry key for VS9
         private const string vs9RegKey = @"SOFTWARE\Microsoft\VisualStudio\9.0";
-        // the name of the value containing disk install directory for the IDE components 
+        // the name of the value containing disk install directory for the IDE components
         // ("...\common7\ide" for layouts)
         private const string vs9InstallDirValueName = "InstallDir";
         // relative path from the above directory to vcbuild.exe on layouts
@@ -244,7 +244,7 @@ internal static string VCBuildLocationHint
         /// </summary>
         // root registry key for VC9
         private const string vc9RegKey = @"SOFTWARE\Microsoft\VCExpress\9.0";
-        // the name of the value containing disk install directory for the IDE components 
+        // the name of the value containing disk install directory for the IDE components
         // ("...\common7\ide" for layouts)
         private const string vc9InstallDirValueName = "InstallDir";
         // relative path from the above directory to vcbuild.exe on layouts
diff --git a/src/Deprecated/Engine/Tasks/IntrinsicTask.cs b/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
index cfd1bf7c879..5c833b7e4b6 100644
--- a/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
+++ b/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
@@ -68,7 +68,7 @@ internal IntrinsicTask(XmlElement taskNodeXmlElement, EngineLoggingServices logg
         #region Methods
 
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         internal void ExecuteTask(Lookup lookup)
         {
@@ -157,7 +157,7 @@ private void ExecuteItemGroup(Lookup lookup)
                     // "Execute" each bucket
                     foreach (ItemBucket bucket in buckets)
                     {
-                        // Gather the outputs, but don't make them visible to other buckets 
+                        // Gather the outputs, but don't make them visible to other buckets
                         switch (child.ChildType)
                         {
                             case ChildType.BuildItemAdd:
@@ -204,7 +204,7 @@ private void ExecuteAdd(BuildItemGroupChildXml child, ItemBucket bucket)
         }
 
         /// <summary>
-        /// Remove items from the world. Removes to items that are part of the project manifest are backed up, so 
+        /// Remove items from the world. Removes to items that are part of the project manifest are backed up, so
         /// they can be reverted when the project is reset after the end of the build.
         /// </summary>
         private void ExecuteRemove(BuildItemGroupChildXml child, ItemBucket bucket)
@@ -230,7 +230,7 @@ private void ExecuteRemove(BuildItemGroupChildXml child, ItemBucket bucket)
         }
 
         /// <summary>
-        /// Modifies items in the world - specifically, changes their metadata. Changes to items that are part of the project manifest are backed up, so 
+        /// Modifies items in the world - specifically, changes their metadata. Changes to items that are part of the project manifest are backed up, so
         /// they can be reverted when the project is reset after the end of the build.
         /// </summary>
         /// <param name="child"></param>
@@ -375,6 +375,6 @@ internal static bool IsIntrinsicTaskName(string name)
                 || String.Equals(name, XMakeElements.itemGroup, StringComparison.Ordinal);
         }
 
-        #endregion  
+        #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs b/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs
index 630ce7f29a6..eb7abc45aa8 100644
--- a/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs
+++ b/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs
@@ -36,9 +36,9 @@ string filespec
 
             if (containsEscapedWildcards && containsRealWildcards)
             {
-                // Umm, this makes no sense.  The item's Include has both escaped wildcards and 
+                // Umm, this makes no sense.  The item's Include has both escaped wildcards and
                 // real wildcards.  What does he want us to do?  Go to the file system and find
-                // files that literally have '*' in their filename?  Well, that's not going to 
+                // files that literally have '*' in their filename?  Well, that's not going to
                 // happen because '*' is an illegal character to have in a filename.
 
                 // Just return the original string.
@@ -64,7 +64,7 @@ string filespec
                 // and on every machine.
                 Array.Sort(fileList);
 
-                // We must now go back and make sure all special characters are escaped because we always 
+                // We must now go back and make sure all special characters are escaped because we always
                 // store data in the engine in escaped form so it doesn't screw up our parsing.
                 // Note that this means that characters that were not escaped in the original filespec
                 // may now be escaped, but that's not easy to avoid.
@@ -75,7 +75,7 @@ string filespec
             }
             else
             {
-                // No real wildcards means we just return the original string.  Don't even bother 
+                // No real wildcards means we just return the original string.  Don't even bother
                 // escaping ... it should already be escaped appropriately since it came directly
                 // from the project file or the OM host.
                 fileList = new string[] { filespec };
diff --git a/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs b/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
index 7cbe04cbcdc..59cecdf0b05 100644
--- a/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
+++ b/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
@@ -154,8 +154,8 @@ internal static XmlAttribute GetConditionAttribute(XmlElement element, bool veri
                         condition = attribute;
                         break;
 
-                    // Label  is only recognized by the new OM.  
-                    // Ignore BUT ONLY if the caller of this function is a 
+                    // Label  is only recognized by the new OM.
+                    // Ignore BUT ONLY if the caller of this function is a
                     // PropertyGroup, ItemDefinitionGroup, or ItemGroup: the "Label"
                     // attribute is only legal on those element types.
                     case XMakeAttributes.label:
@@ -200,7 +200,7 @@ internal static XmlAttribute SetOrRemoveAttribute(XmlElement element, string nam
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
+        /// Returns the value of the attribute.
         /// If the attribute is null, returns an empty string.
         /// </summary>
         internal static string GetAttributeValue(XmlAttribute attribute)
diff --git a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
index 703349fde83..aa52ae16cdb 100644
--- a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
@@ -31,7 +31,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class BuildFinishedEventArgs2 : BuildFinishedEventArgs
diff --git a/src/Framework.UnitTests/BuildMessageEventArgs_Tests.cs b/src/Framework.UnitTests/BuildMessageEventArgs_Tests.cs
index 4d829a9222d..d347eece0b0 100644
--- a/src/Framework.UnitTests/BuildMessageEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildMessageEventArgs_Tests.cs
@@ -37,7 +37,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class BuildMessageEventArgs2 : BuildMessageEventArgs
diff --git a/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs
index c3a2115e069..6e19e294d9d 100644
--- a/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs
@@ -35,7 +35,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Trivially exercise getHashCode. 
+        /// Trivially exercise getHashCode.
         /// </summary>
         [Fact]
         public void TestGetHashCode()
@@ -44,7 +44,7 @@ public void TestGetHashCode()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class BuildStartedEventArgs2 : BuildStartedEventArgs
diff --git a/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs b/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs
index 919bcc523d1..361e4044ebf 100644
--- a/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs
@@ -47,7 +47,7 @@ public void TestGetHashCode()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class BuildWarningEventArgs2 : BuildWarningEventArgs
diff --git a/src/Framework.UnitTests/CriticalBuildMessageEventArgs_Tests.cs b/src/Framework.UnitTests/CriticalBuildMessageEventArgs_Tests.cs
index 0fe6a0094a4..ed16a63a917 100644
--- a/src/Framework.UnitTests/CriticalBuildMessageEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/CriticalBuildMessageEventArgs_Tests.cs
@@ -30,7 +30,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class CriticalBuildMessageEventArgs2 : CriticalBuildMessageEventArgs
diff --git a/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs b/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
index ec67a9b96aa..5e65f74a575 100644
--- a/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
+++ b/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
@@ -192,7 +192,7 @@ public void TestBuildErrorEventArgs()
         }
 
         /// <summary>
-        /// Compare two BuildEventArgs 
+        /// Compare two BuildEventArgs
         /// </summary>
         private static void VerifyBuildErrorEventArgs(BuildErrorEventArgs genericEvent, BuildErrorEventArgs newGenericEvent)
         {
@@ -614,7 +614,7 @@ public void TestProjectStartedPropertySerialization()
         }
 
         /// <summary>
-        /// Compare the BuildProperties in propertyList with the Name Value pairs in the entryList. 
+        /// Compare the BuildProperties in propertyList with the Name Value pairs in the entryList.
         /// We need to make sure that each of the BuildProperties passed into the serializer come out correctly
         /// </summary>
         /// <param name="entryList">List of DictionaryEntries which were deserialized</param>
@@ -701,7 +701,7 @@ public void TestProjectStartedEventArgs()
         }
 
         /// <summary>
-        /// Compare two project started events 
+        /// Compare two project started events
         /// </summary>
         private static void VerifyProjectStartedEvent(ProjectStartedEventArgs genericEvent, ProjectStartedEventArgs newGenericEvent)
         {
diff --git a/src/Framework.UnitTests/ExternalProjectFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/ExternalProjectFinishedEventArgs_Tests.cs
index 9f21ebb48fa..b6b7290ba12 100644
--- a/src/Framework.UnitTests/ExternalProjectFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ExternalProjectFinishedEventArgs_Tests.cs
@@ -29,7 +29,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class ExternalProjectFinishedEventArgs2 : ExternalProjectFinishedEventArgs
diff --git a/src/Framework.UnitTests/ExternalProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ExternalProjectStartedEventArgs_Tests.cs
index c3a47382a31..12e34378a48 100644
--- a/src/Framework.UnitTests/ExternalProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ExternalProjectStartedEventArgs_Tests.cs
@@ -29,7 +29,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class ExternalProjectStartedEventArgs2 : ExternalProjectStartedEventArgs
diff --git a/src/Framework.UnitTests/ProjectFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectFinishedEventArgs_Tests.cs
index d55d227ec28..c7a17d9889c 100644
--- a/src/Framework.UnitTests/ProjectFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectFinishedEventArgs_Tests.cs
@@ -28,7 +28,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class ProjectFinishedEventArgs2 : ProjectFinishedEventArgs
diff --git a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
index 2ab1af0fbd1..67bacf49a74 100644
--- a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
@@ -51,7 +51,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Verify different Items and properties are not taken into account in the equals comparison. They should 
+        /// Verify different Items and properties are not taken into account in the equals comparison. They should
         /// not be considered as part of the equals evaluation
         /// </summary>
         [Fact]
@@ -75,7 +75,7 @@ public void ItemsAndPropertiesDifferentEquals()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class ProjectStartedEventArgs2 : ProjectStartedEventArgs
diff --git a/src/Framework.UnitTests/TargetFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/TargetFinishedEventArgs_Tests.cs
index 6bd3ad2ba7f..5f5fe57ead6 100644
--- a/src/Framework.UnitTests/TargetFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TargetFinishedEventArgs_Tests.cs
@@ -31,7 +31,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class TargetFinishedEventArgs2 : TargetFinishedEventArgs
diff --git a/src/Framework.UnitTests/TargetStartedEventArgs_Tests.cs b/src/Framework.UnitTests/TargetStartedEventArgs_Tests.cs
index 6eb88790fb7..571f57c4690 100644
--- a/src/Framework.UnitTests/TargetStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TargetStartedEventArgs_Tests.cs
@@ -31,7 +31,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class TargetStartedEventArgs2 : TargetStartedEventArgs
diff --git a/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs b/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs
index 4d053b565cb..dcc3c74c515 100644
--- a/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs
@@ -29,7 +29,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class TaskCommandLineEventArgs2 : TaskCommandLineEventArgs
diff --git a/src/Framework.UnitTests/TaskFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/TaskFinishedEventArgs_Tests.cs
index 1c5af624176..4a567d7f69a 100644
--- a/src/Framework.UnitTests/TaskFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TaskFinishedEventArgs_Tests.cs
@@ -29,7 +29,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class TaskFinishedEventArgs2 : TaskFinishedEventArgs
diff --git a/src/Framework.UnitTests/TaskStartedEventArgs_Tests.cs b/src/Framework.UnitTests/TaskStartedEventArgs_Tests.cs
index b5cee33aa50..8a6358f4d2e 100644
--- a/src/Framework.UnitTests/TaskStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TaskStartedEventArgs_Tests.cs
@@ -31,7 +31,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class TaskStartedEventArgs2 : TaskStartedEventArgs
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index 550f487f8ab..d3ae3878226 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -399,9 +399,9 @@ public void Translate(ref TimeSpan value)
                 value = new System.TimeSpan(ticks);
             }
 
-            // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext.  
-            // However, it also does not ever need to translate BuildEventContexts, so it should be perfectly safe to 
-            // compile this method out of that assembly. 
+            // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext.
+            // However, it also does not ever need to translate BuildEventContexts, so it should be perfectly safe to
+            // compile this method out of that assembly.
 #if !CLR2COMPATIBILITY
 
             /// <summary>
@@ -635,7 +635,7 @@ public void TranslateDictionary<K, V>(
             }
 
             /// <summary>
-            /// Translates a dictionary of { string, T }.  
+            /// Translates a dictionary of { string, T }.
             /// </summary>
             /// <typeparam name="T">The reference type for the values</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
@@ -1084,9 +1084,9 @@ public void Translate(ref TimeSpan value)
                 _writer.Write(value.Ticks);
             }
 
-            // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext.  
-            // However, it also does not ever need to translate BuildEventContexts, so it should be perfectly safe to 
-            // compile this method out of that assembly. 
+            // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext.
+            // However, it also does not ever need to translate BuildEventContexts, so it should be perfectly safe to
+            // compile this method out of that assembly.
 #if !CLR2COMPATIBILITY
 
             /// <summary>
@@ -1107,7 +1107,7 @@ public void Translate(ref BuildEventContext value)
                 _writer.Write(value.TargetId);
                 _writer.Write(value.TaskId);
             }
-#endif 
+#endif
 
             /// <summary>
             /// Translates a CultureInfo
@@ -1304,7 +1304,7 @@ public void TranslateDictionary<K, V>(
             }
 
             /// <summary>
-            /// Translates a dictionary of { string, T }.  
+            /// Translates a dictionary of { string, T }.
             /// </summary>
             /// <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 206ab7fa5a9..883bbca9d12 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// This class encapsulates the default data associated with build events. 
+    /// This class encapsulates the default data associated with build events.
     /// It is intended to be extended/sub-classed.
     /// </summary>
     // WARNING: marking a type [Serializable] without implementing
@@ -124,7 +124,7 @@ protected internal DateTime RawTimestamp
         }
 
         /// <summary>
-        /// The thread that raised event.  
+        /// The thread that raised event.
         /// </summary>
         public int ThreadId => threadId;
 
@@ -260,7 +260,7 @@ internal virtual void CreateFromStream(BinaryReader reader, int version)
         [OnDeserializing]
         private void SetBuildEventContextDefaultBeforeSerialization(StreamingContext sc)
         {
-            // Don't want to create a new one here as default all the time as that would be a lot of 
+            // Don't want to create a new one here as default all the time as that would be a lot of
             // possibly useless allocations
             buildEventContext = null;
         }
diff --git a/src/Framework/BuildEventContext.cs b/src/Framework/BuildEventContext.cs
index e27b37f3f67..0622bf45896 100644
--- a/src/Framework/BuildEventContext.cs
+++ b/src/Framework/BuildEventContext.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// Will provide location information for an event, this is especially 
+    /// Will provide location information for an event, this is especially
     /// needed in a multi processor environment
     /// </summary>
     [Serializable]
@@ -15,7 +15,7 @@ public class BuildEventContext
         #region Data
 
         /// <summary>
-        /// Node event was in 
+        /// Node event was in
         /// </summary>
         private readonly int _nodeId;
 
@@ -219,9 +219,9 @@ public override int GetHashCode()
         }
 
         /// <summary>
-        /// Compare a BuildEventContext with this BuildEventContext. 
+        /// Compare a BuildEventContext with this BuildEventContext.
         /// A build event context is compared in the following way.
-        /// 
+        ///
         /// 1. If the object references are the same the contexts are equivalent
         /// 2. If the object type is the same and the Id values in the context are the same, the contexts are equivalent
         /// </summary>
diff --git a/src/Framework/BuildMessageEventArgs.cs b/src/Framework/BuildMessageEventArgs.cs
index 23083d8cd6a..ca01f781d2f 100644
--- a/src/Framework/BuildMessageEventArgs.cs
+++ b/src/Framework/BuildMessageEventArgs.cs
@@ -304,7 +304,7 @@ public MessageImportance Importance
         public string Subcategory => subcategory;
 
         /// <summary>
-        /// Code associated with event. 
+        /// Code associated with event.
         /// </summary>
         public string Code => code;
 
@@ -314,7 +314,7 @@ public MessageImportance Importance
         public string File => file;
 
         /// <summary>
-        /// Line number of interest in associated file. 
+        /// Line number of interest in associated file.
         /// </summary>
         public int LineNumber
         {
@@ -323,7 +323,7 @@ public int LineNumber
         }
 
         /// <summary>
-        /// Column number of interest in associated file. 
+        /// Column number of interest in associated file.
         /// </summary>
         public int ColumnNumber
         {
@@ -332,12 +332,12 @@ public int ColumnNumber
         }
 
         /// <summary>
-        /// Ending line number of interest in associated file. 
+        /// Ending line number of interest in associated file.
         /// </summary>
         public int EndLineNumber => endLineNumber;
 
         /// <summary>
-        /// Ending column number of interest in associated file. 
+        /// Ending column number of interest in associated file.
         /// </summary>
         public int EndColumnNumber => endColumnNumber;
 
diff --git a/src/Framework/BuildStatusEventArgs.cs b/src/Framework/BuildStatusEventArgs.cs
index c6edef25c8a..a53b971d49b 100644
--- a/src/Framework/BuildStatusEventArgs.cs
+++ b/src/Framework/BuildStatusEventArgs.cs
@@ -5,52 +5,52 @@
 
 namespace Microsoft.Build.Framework
 {
-    /// <summary> 
+    /// <summary>
     /// Base class for build status events.  This class is meant
-    /// to be extended.  
-    /// </summary> 
-    /// <remarks> 
-    /// WARNING: marking a type [Serializable] without implementing 
-    /// ISerializable imposes a serialization contract -- it is a 
-    /// promise to never change the type's fields i.e. the type is 
-    /// immutable; adding new fields in the next version of the type 
-    /// without following certain special FX guidelines, can break both 
-    /// forward and backward compatibility 
-    /// </remarks> 
+    /// to be extended.
+    /// </summary>
+    /// <remarks>
+    /// WARNING: marking a type [Serializable] without implementing
+    /// ISerializable imposes a serialization contract -- it is a
+    /// promise to never change the type's fields i.e. the type is
+    /// immutable; adding new fields in the next version of the type
+    /// without following certain special FX guidelines, can break both
+    /// forward and backward compatibility
+    /// </remarks>
     [Serializable]
     public abstract class BuildStatusEventArgs : LazyFormattedBuildEventArgs
     {
-        /// <summary> 
-        /// Default constructor 
-        /// </summary> 
+        /// <summary>
+        /// Default constructor
+        /// </summary>
         protected BuildStatusEventArgs()
             : base()
         {
-            // do nothing 
+            // do nothing
         }
 
-        /// <summary> 
-        /// This constructor allows event data to be initialized.  
-        /// </summary> 
-        /// <param name="message">text message</param> 
-        /// <param name="helpKeyword">help keyword </param> 
-        /// <param name="senderName">name of event sender</param> 
+        /// <summary>
+        /// This constructor allows event data to be initialized.
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="senderName">name of event sender</param>
         protected BuildStatusEventArgs(
             string? message,
             string? helpKeyword,
             string? senderName)
             : this(message, helpKeyword, senderName, DateTime.UtcNow)
         {
-            // do nothing 
+            // do nothing
         }
 
 
-        /// <summary> 
+        /// <summary>
         /// This constructor allows timestamp to be set
-        /// </summary> 
-        /// <param name="message">text message</param> 
-        /// <param name="helpKeyword">help keyword </param> 
-        /// <param name="senderName">name of event sender</param> 
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="senderName">name of event sender</param>
         /// <param name="eventTimestamp">Timestamp when event was created</param>
         protected BuildStatusEventArgs(
             string? message,
@@ -62,12 +62,12 @@ protected BuildStatusEventArgs(
             // do nothing
         }
 
-        /// <summary> 
+        /// <summary>
         /// This constructor allows timestamp to be set
-        /// </summary> 
-        /// <param name="message">text message</param> 
-        /// <param name="helpKeyword">help keyword </param> 
-        /// <param name="senderName">name of event sender</param> 
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="senderName">name of event sender</param>
         /// <param name="eventTimestamp">Timestamp when event was created</param>
         /// <param name="messageArgs">Optional arguments for formatting the message string.</param>
         protected BuildStatusEventArgs(
@@ -78,7 +78,7 @@ protected BuildStatusEventArgs(
             params object[]? messageArgs)
             : base(message, helpKeyword, senderName, eventTimestamp, messageArgs)
         {
-            // do nothing 
+            // do nothing
         }
     }
 }
diff --git a/src/Framework/CriticalBuildMessageEventArgs.cs b/src/Framework/CriticalBuildMessageEventArgs.cs
index 7cac3c342f2..765e05fe857 100644
--- a/src/Framework/CriticalBuildMessageEventArgs.cs
+++ b/src/Framework/CriticalBuildMessageEventArgs.cs
@@ -107,7 +107,7 @@ public CriticalBuildMessageEventArgs(
             string senderName,
             DateTime eventTimestamp,
             params object[] messageArgs)
-            //// Force importance to High. 
+            //// Force importance to High.
             : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, MessageImportance.High, eventTimestamp, messageArgs)
         {
             // do nothing
diff --git a/src/Framework/CustomBuildEventArgs.cs b/src/Framework/CustomBuildEventArgs.cs
index a50c2edee3a..e85b1efb91e 100644
--- a/src/Framework/CustomBuildEventArgs.cs
+++ b/src/Framework/CustomBuildEventArgs.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Framework
     public abstract class CustomBuildEventArgs : LazyFormattedBuildEventArgs
     {
         /// <summary>
-        /// Default constructor 
+        /// Default constructor
         /// </summary>
         protected CustomBuildEventArgs()
             : base()
diff --git a/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs b/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs
index f4c38172a02..8b16acdb3be 100644
--- a/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs
+++ b/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs
@@ -117,7 +117,7 @@ public ExtendedCriticalBuildMessageEventArgs(
         string? senderName,
         DateTime eventTimestamp,
         params object[]? messageArgs)
-        //// Force importance to High. 
+        //// Force importance to High.
         : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp, messageArgs) => ExtendedType = type;
 
     /// <summary>
diff --git a/src/Framework/IBuildEngine2.cs b/src/Framework/IBuildEngine2.cs
index 7ffd55e9844..85f414766d3 100644
--- a/src/Framework/IBuildEngine2.cs
+++ b/src/Framework/IBuildEngine2.cs
@@ -8,7 +8,7 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// This interface extends IBuildEngine to provide a method allowing building 
+    /// This interface extends IBuildEngine to provide a method allowing building
     /// project files in parallel.
     /// </summary>
     public interface IBuildEngine2 : IBuildEngine
@@ -60,14 +60,14 @@ bool BuildProjectFile(
         /// <param name="projectFileNames">The project to build.</param>
         /// <param name="targetNames">The targets in the project to build (can be null).</param>
         /// <param name="globalProperties">An array of hashtables of additional global properties to apply
-        ///     to the child project (array entries can be null). 
+        ///     to the child project (array entries can be null).
         ///     The key and value in the hashtable should both be strings.</param>
         /// <param name="targetOutputsPerProject">The outputs of each specified target (can be null).</param>
         /// <param name="toolsVersion">A tools version recognized by the Engine that will be used during this build (can be null).</param>
         /// <param name="useResultsCache">If true the operation will only be run if the cache doesn't
         ///                               already contain the result. After the operation the result is
         ///                               stored in the cache </param>
-        /// <param name="unloadProjectsOnCompletion">If true the project will be unloaded once the 
+        /// <param name="unloadProjectsOnCompletion">If true the project will be unloaded once the
         ///                                         operation is completed </param>
         /// <returns>true, if build was successful</returns>
         bool BuildProjectFilesInParallel(
diff --git a/src/Framework/IBuildEngine3.cs b/src/Framework/IBuildEngine3.cs
index faa0459699d..591d49ec74e 100644
--- a/src/Framework/IBuildEngine3.cs
+++ b/src/Framework/IBuildEngine3.cs
@@ -9,7 +9,7 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// This interface extends IBuildEngine to provide a method allowing building 
+    /// This interface extends IBuildEngine to provide a method allowing building
     /// project files in parallel.
     /// </summary>
     public interface IBuildEngine3 : IBuildEngine2
@@ -22,12 +22,12 @@ public interface IBuildEngine3 : IBuildEngine2
         /// <remarks>
         /// 1) it is acceptable to pass null for both <c>targetNames</c> and <c>targetOutputs</c>
         /// 2) if no targets are specified, the default targets are built
-        /// 
+        ///
         /// </remarks>
         /// <param name="projectFileNames">The project to build.</param>
         /// <param name="targetNames">The targets in the project to build (can be null).</param>
         /// <param name="globalProperties">An array of hashtables of additional global properties to apply
-        ///     to the child project (array entries can be null). 
+        ///     to the child project (array entries can be null).
         ///     The key and value in the hashtable should both be strings.</param>
         /// <param name="removeGlobalProperties">A list of global properties which should be removed.</param>
         /// <param name="toolsVersion">A tools version recognized by the Engine that will be used during this build (can be null).</param>
diff --git a/src/Framework/IBuildEngine4.cs b/src/Framework/IBuildEngine4.cs
index 650c60b9760..4440a139d61 100644
--- a/src/Framework/IBuildEngine4.cs
+++ b/src/Framework/IBuildEngine4.cs
@@ -28,7 +28,7 @@ public enum RegisteredTaskObjectLifetime
     }
 
     /// <summary>
-    /// This interface extends IBuildEngine to provide a mechanism allowing tasks to 
+    /// This interface extends IBuildEngine to provide a mechanism allowing tasks to
     /// share data between task invocations.
     /// </summary>
     public interface IBuildEngine4 : IBuildEngine3
@@ -45,9 +45,9 @@ public interface IBuildEngine4 : IBuildEngine3
         /// <remarks>
         /// <para>
         /// This method may be called by tasks which need to maintain state across task invocations,
-        /// such as to cache data which may be expensive to generate but which is known not to change during the 
+        /// such as to cache data which may be expensive to generate but which is known not to change during the
         /// build.  It is strongly recommended that <paramref name="allowEarlyCollection"/> be set to true if the
-        /// object will retain any significant amount of data, as this gives MSBuild the most flexibility to 
+        /// object will retain any significant amount of data, as this gives MSBuild the most flexibility to
         /// manage limited process memory resources.
         /// </para>
         /// <para>
diff --git a/src/Framework/IEventSource.cs b/src/Framework/IEventSource.cs
index 3c2599fceba..4ba9c258238 100644
--- a/src/Framework/IEventSource.cs
+++ b/src/Framework/IEventSource.cs
@@ -75,7 +75,7 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public delegate void AnyEventHandler(object sender, BuildEventArgs e);
 
-    /// <summary> 
+    /// <summary>
     /// This interface defines the events raised by the build engine.
     /// Loggers use this interface to subscribe to the events they
     /// are interested in receiving.
diff --git a/src/Framework/ILogger.cs b/src/Framework/ILogger.cs
index 5d999b7b08d..30973514607 100644
--- a/src/Framework/ILogger.cs
+++ b/src/Framework/ILogger.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.Framework
     /// The level of detail (i.e. verbosity) of an event log is entirely controlled by the logger generating the log -- a logger
     /// will be directed to keep its verbosity at a certain level, based on user preferences, but a logger is free to choose the
     /// events it logs for each verbosity level.
-    /// 
+    ///
     /// LOGGING GUIDELINES FOR EACH VERBOSITY LEVEL:
     /// 1) Quiet -- only display a summary at the end of build
     /// 2) Minimal -- only display errors, warnings, high importance events and a build summary
@@ -22,9 +22,9 @@ namespace Microsoft.Build.Framework
     /// 4) Detailed -- display all errors, warnings, high and normal importance events, all status events, and a build summary
     /// 5) Diagnostic -- display all events, and a build summary
     /// </remarks>
-    // 
+    //
     // WARNING: VS Automation code for the Tools/Options MSBuild build verbosity setting will be broken
-    // by changes to this enum (not to mention existing MSBuild clients and vsproject code). 
+    // by changes to this enum (not to mention existing MSBuild clients and vsproject code).
     // Please make sure to talk to automation devs before changing it.
     [ComVisible(true)]
     public enum LoggerVerbosity
diff --git a/src/Framework/INodeLogger.cs b/src/Framework/INodeLogger.cs
index 4865646daf9..faf807b55cd 100644
--- a/src/Framework/INodeLogger.cs
+++ b/src/Framework/INodeLogger.cs
@@ -8,9 +8,9 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// This interface defines a "parallel aware logger" in the build system. A parallel aware logger 
+    /// This interface defines a "parallel aware logger" in the build system. A parallel aware logger
     /// will accept a cpu count and be aware that any cpu count greater than 1 means the events will
-    /// be received from the logger from each cpu as the events are logged. 
+    /// be received from the logger from each cpu as the events are logged.
     /// </summary>
     [ComVisible(true)]
     public interface INodeLogger : ILogger
diff --git a/src/Framework/IProjectElement.cs b/src/Framework/IProjectElement.cs
index d7f74708af0..1fcbbb2da5e 100644
--- a/src/Framework/IProjectElement.cs
+++ b/src/Framework/IProjectElement.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Framework
     public interface IProjectElement
     {
         /// <summary>
-        /// Gets the name of the associated element. 
+        /// Gets the name of the associated element.
         /// Useful for display in some circumstances.
         /// </summary>
         string ElementName { get; }
diff --git a/src/Framework/ITaskFactory2.cs b/src/Framework/ITaskFactory2.cs
index 14fb266c913..cd2de556f6a 100644
--- a/src/Framework/ITaskFactory2.cs
+++ b/src/Framework/ITaskFactory2.cs
@@ -9,27 +9,27 @@ namespace Microsoft.Build.Framework
 {
     /// <summary>
     /// Interface that a task factory Instance should implement if it wants to be able to
-    /// use new UsingTask parameters such as Runtime and Architecture. 
+    /// use new UsingTask parameters such as Runtime and Architecture.
     /// </summary>
     public interface ITaskFactory2 : ITaskFactory
     {
         /// <summary>
         /// Initializes this factory for instantiating tasks with a particular inline task block and a set of UsingTask parameters.  MSBuild
-        /// provides an implementation of this interface, TaskHostFactory, that uses "Runtime", with values "CLR2", "CLR4", "CurrentRuntime", 
-        /// and "*" (Any); and "Architecture", with values "x86", "x64", "CurrentArchitecture", and "*" (Any).  An implementer of ITaskFactory2 
-        /// can choose to use these pre-defined Runtime and Architecture values, or can specify new values for these parameters.  
+        /// provides an implementation of this interface, TaskHostFactory, that uses "Runtime", with values "CLR2", "CLR4", "CurrentRuntime",
+        /// and "*" (Any); and "Architecture", with values "x86", "x64", "CurrentArchitecture", and "*" (Any).  An implementer of ITaskFactory2
+        /// can choose to use these pre-defined Runtime and Architecture values, or can specify new values for these parameters.
         /// </summary>
         /// <param name="taskName">Name of the task.</param>
-        /// <param name="factoryIdentityParameters">Special parameters that the task factory can use to modify how it executes tasks, 
-        /// such as Runtime and Architecture.  The key is the name of the parameter and the value is the parameter's value. This 
+        /// <param name="factoryIdentityParameters">Special parameters that the task factory can use to modify how it executes tasks,
+        /// such as Runtime and Architecture.  The key is the name of the parameter and the value is the parameter's value. This
         /// is the set of parameters that was set on the UsingTask using e.g. the UsingTask Runtime and Architecture parameters.</param>
         /// <param name="parameterGroup">The parameter group.</param>
         /// <param name="taskBody">The task body.</param>
         /// <param name="taskFactoryLoggingHost">The task factory logging host.</param>
         /// <returns>A value indicating whether initialization was successful.</returns>
         /// <remarks>
-        /// <para>MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the 
-        /// factory can be asked whether or not task names can be created by the factory.  If a task factory implements ITaskFactory2, 
+        /// <para>MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the
+        /// factory can be asked whether or not task names can be created by the factory.  If a task factory implements ITaskFactory2,
         /// this Initialize method will be called in place of ITaskFactory.Initialize.</para>
         /// <para>
         /// The taskFactoryLoggingHost will log messages in the context of the target where the task is first used.
@@ -38,22 +38,22 @@ public interface ITaskFactory2 : ITaskFactory
         bool Initialize(string taskName, IDictionary<string, string> factoryIdentityParameters, IDictionary<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
 
         /// <summary>
-        /// Create an instance of the task to be used, with an optional set of "special" parameters set on the individual task invocation using 
-        /// the MSBuildRuntime and MSBuildArchitecture default task parameters.  MSBuild provides an implementation of this interface, 
-        /// TaskHostFactory, that uses "MSBuildRuntime", with values "CLR2", "CLR4", "CurrentRuntime", and "*" (Any); and "MSBuildArchitecture", 
-        /// with values "x86", "x64", "CurrentArchitecture", and "*" (Any).  An implementer of ITaskFactory2 can choose to use these pre-defined 
-        /// MSBuildRuntime and MSBuildArchitecture values, or can specify new values for these parameters.  
+        /// Create an instance of the task to be used, with an optional set of "special" parameters set on the individual task invocation using
+        /// the MSBuildRuntime and MSBuildArchitecture default task parameters.  MSBuild provides an implementation of this interface,
+        /// TaskHostFactory, that uses "MSBuildRuntime", with values "CLR2", "CLR4", "CurrentRuntime", and "*" (Any); and "MSBuildArchitecture",
+        /// with values "x86", "x64", "CurrentArchitecture", and "*" (Any).  An implementer of ITaskFactory2 can choose to use these pre-defined
+        /// MSBuildRuntime and MSBuildArchitecture values, or can specify new values for these parameters.
         /// </summary>
         /// <param name="taskFactoryLoggingHost">
         /// The task factory logging host will log messages in the context of the task.
         /// </param>
         /// <param name="taskIdentityParameters">
-        /// Special parameters that the task factory can use to modify how it executes tasks, such as Runtime and Architecture.  
-        /// The key is the name of the parameter and the value is the parameter's value.  This is the set of parameters that was 
-        /// set to the task invocation itself, via e.g. the special MSBuildRuntime and MSBuildArchitecture parameters.  
+        /// Special parameters that the task factory can use to modify how it executes tasks, such as Runtime and Architecture.
+        /// The key is the name of the parameter and the value is the parameter's value.  This is the set of parameters that was
+        /// set to the task invocation itself, via e.g. the special MSBuildRuntime and MSBuildArchitecture parameters.
         /// </param>
         /// <remarks>
-        /// If a task factory implements ITaskFactory2, MSBuild will call this method instead of ITaskFactory.CreateTask.  
+        /// If a task factory implements ITaskFactory2, MSBuild will call this method instead of ITaskFactory.CreateTask.
         /// </remarks>
         /// <returns>
         /// The generated task, or <c>null</c> if the task failed to be created.
diff --git a/src/Framework/ITaskHost.cs b/src/Framework/ITaskHost.cs
index 687d2c3229f..9ea5c140d18 100644
--- a/src/Framework/ITaskHost.cs
+++ b/src/Framework/ITaskHost.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// This empty interface is used to pass host objects from an IDE to individual
     /// tasks.  Depending on the task itself and what kinds parameters and functionality
-    /// it exposes, the task should define its own interface that inherits from this one, 
+    /// it exposes, the task should define its own interface that inherits from this one,
     /// and then use that interface to communicate with the host.
     /// </summary>
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
diff --git a/src/Framework/ITaskItem2.cs b/src/Framework/ITaskItem2.cs
index d9095e42038..f245353a19b 100644
--- a/src/Framework/ITaskItem2.cs
+++ b/src/Framework/ITaskItem2.cs
@@ -40,7 +40,7 @@ string EvaluatedIncludeEscaped
 
         /// <summary>
         /// Allows a piece of custom metadata to be set on the item.  Assumes that the value passed
-        /// in is unescaped, and escapes the value as necessary in order to maintain its value. 
+        /// in is unescaped, and escapes the value as necessary in order to maintain its value.
         /// </summary>
         /// <remarks>
         /// Taking the opportunity to fix the property name, although this doesn't
@@ -50,7 +50,7 @@ string EvaluatedIncludeEscaped
 
         /// <summary>
         /// ITaskItem2 implementation which returns a clone of the metadata on this object.
-        /// Values returned are in their original escaped form. 
+        /// Values returned are in their original escaped form.
         /// </summary>
         /// <returns>The cloned metadata, with values' escaping preserved.</returns>
         IDictionary CloneCustomMetadataEscaped();
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index 8d267351591..edb6e96dfc7 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -48,7 +48,7 @@ internal enum TranslationDirection
     }
 
     /// <summary>
-    /// This interface represents an object which aids objects in serializing and 
+    /// This interface represents an object which aids objects in serializing and
     /// deserializing INodePackets.
     /// </summary>
     /// <remarks>
@@ -78,7 +78,7 @@ TranslationDirection Mode
         /// Returns the binary reader.
         /// </summary>
         /// <remarks>
-        /// This should ONLY be used when absolutely necessary for translation.  It is generally unnecessary for the 
+        /// This should ONLY be used when absolutely necessary for translation.  It is generally unnecessary for the
         /// translating object to know the direction of translation.  Use one of the Translate methods instead.
         /// </remarks>
         BinaryReader Reader
@@ -90,7 +90,7 @@ BinaryReader Reader
         /// Returns the binary writer.
         /// </summary>
         /// <remarks>
-        /// This should ONLY be used when absolutely necessary for translation.  It is generally unnecessary for the 
+        /// This should ONLY be used when absolutely necessary for translation.  It is generally unnecessary for the
         /// translating object to know the direction of translation.  Use one of the Translate methods instead.
         /// </remarks>
         BinaryWriter Writer
@@ -222,11 +222,11 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref TimeSpan value);
 
-        // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext, 
-        // which is what current implementations of this method use.  However, it also does not ever need to translate 
+        // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext,
+        // which is what current implementations of this method use.  However, it also does not ever need to translate
         // BuildEventContexts, so it should be perfectly safe to compile this method out of that assembly. I am compiling
         // the method out of the interface as well, instead of just making the method empty, so that if we ever do need
-        // to translate BuildEventContexts from the CLR 3.5 task host, it will become immediately obvious, rather than 
+        // to translate BuildEventContexts from the CLR 3.5 task host, it will become immediately obvious, rather than
         // failing or misbehaving silently.
 #if !CLR2COMPATIBILITY
 
@@ -326,7 +326,7 @@ void TranslateArray<T>(ref T[] array)
         void TranslateDictionary<K, V>(ref IDictionary<K, V> dictionary, ObjectTranslator<K> keyTranslator, ObjectTranslator<V> valueTranslator, NodePacketCollectionCreator<IDictionary<K, V>> dictionaryCreator);
 
         /// <summary>
-        /// Translates a dictionary of { string, T }.  
+        /// Translates a dictionary of { string, T }.
         /// </summary>
         /// <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
         /// <param name="dictionary">The dictionary to be translated.</param>
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index 4b4dc6493a6..06c3b333aff 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -156,7 +156,7 @@ internal override void CreateFromStream(BinaryReader reader, Int32 version)
 
         /// <summary>
         /// Formats the given string using the variable arguments passed in.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -173,12 +173,12 @@ private static string FormatString(string unformatted, params object[] args)
             if ((args?.Length > 0))
             {
 #if DEBUG
-                // If you accidentally pass some random type in that can't be converted to a string, 
+                // If you accidentally pass some random type in that can't be converted to a string,
                 // FormatResourceString calls ToString() which returns the full name of the type!
                 foreach (object param in args)
                 {
                     // Check against a list of types that we know have
-                    // overridden ToString() usefully. If you want to pass 
+                    // overridden ToString() usefully. If you want to pass
                     // another one, add it here.
                     if (param != null && param.ToString() == param.GetType().FullName)
                     {
@@ -198,7 +198,7 @@ private static string FormatString(string unformatted, params object[] args)
                     // We don't have resources in this assembly, and we generally log stack for task failures so they can be fixed by the owner
                     // However, we don't want to crash the logger and stop the build.
                     // Error will look like this (it's OK to not localize subcategory). It's not too bad, although there's no file.
-                    // 
+                    //
                     //       Task "Crash"
                     //          (16,14):  error : "This message logged from a task {1} has too few formatting parameters."
                     //             at System.Text.StringBuilder.AppendFormat(IFormatProvider provider, String format, Object[] args)
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index 05e457d90ee..19d0eab57ac 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Framework
 {
     /// <summary>
     /// Exception that should be thrown by a logger when it cannot continue.
-    /// Allows a logger to force the build to stop in an explicit way, when, for example, it 
+    /// Allows a logger to force the build to stop in an explicit way, when, for example, it
     /// receives invalid parameters, or cannot write to disk.
     /// </summary>
     // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
@@ -77,7 +77,7 @@ public LoggerException(string message, Exception innerException, string errorCod
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info">Serialization info</param>
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index d30a8ec85f5..b1cb2b0d7b2 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -214,7 +214,7 @@ internal enum ProcessorArchitectures
         // 32-bit ARMv6
         ARMV6,
 
-        // PowerPC 64-bit (little-endian) 
+        // PowerPC 64-bit (little-endian)
         PPC64LE,
 
         // Who knows
@@ -1539,7 +1539,7 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
             // On posix OSes we expect console always supports VT100 coloring unless it is explicitly marked as "dumb".
             acceptAnsiColorCodes = Environment.GetEnvironmentVariable("TERM") != "dumb";
             // It wasn't redirected as tested above so we assume output is screen/console
-            outputIsScreen = true; 
+            outputIsScreen = true;
         }
         return (acceptAnsiColorCodes, outputIsScreen, originalConsoleMode);
     }
diff --git a/src/Framework/Profiler/EvaluationLocation.cs b/src/Framework/Profiler/EvaluationLocation.cs
index 9f8f95ee9a6..b4ce0636725 100644
--- a/src/Framework/Profiler/EvaluationLocation.cs
+++ b/src/Framework/Profiler/EvaluationLocation.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.Framework.Profiler
     /// Evaluation main phases used by the profiler
     /// </summary>
     /// <remarks>
-    /// Order matters since the profiler pretty printer orders profiled items from top to bottom using 
+    /// Order matters since the profiler pretty printer orders profiled items from top to bottom using
     /// the pass they belong to
     /// </remarks>
     public enum EvaluationPass : byte
diff --git a/src/Framework/ProjectFinishedEventArgs.cs b/src/Framework/ProjectFinishedEventArgs.cs
index 75e3fda981e..9308f830c2f 100644
--- a/src/Framework/ProjectFinishedEventArgs.cs
+++ b/src/Framework/ProjectFinishedEventArgs.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.Framework
     public class ProjectFinishedEventArgs : BuildStatusEventArgs
     {
         /// <summary>
-        /// Default constructor 
+        /// Default constructor
         /// </summary>
         protected ProjectFinishedEventArgs()
             : base()
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index eba6c9ac5ab..cc9d14af45a 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -31,7 +31,7 @@ public class ProjectStartedEventArgs : BuildStatusEventArgs
         #endregion
 
         /// <summary>
-        /// Default constructor 
+        /// Default constructor
         /// </summary>
         protected ProjectStartedEventArgs()
             : base()
@@ -319,8 +319,8 @@ public IEnumerable? Items
                 // the central logger in the multi-proc case.  No one uses this though, so it's probably no big deal.  In
                 // the new OM, this list of items could come directly from the BuildRequestConfiguration, which has access
                 // to the loaded project.  For distributed loggers in the multi-proc case and all loggers in the single-proc
-                // case, this access is to the live list.  For the central logger in the multi-proc case, the main node 
-                // has likely not loaded this project, and therefore the live items would not be available to them, which is 
+                // case, this access is to the live list.  For the central logger in the multi-proc case, the main node
+                // has likely not loaded this project, and therefore the live items would not be available to them, which is
                 // the same as the current functionality.
                 return items;
             }
@@ -357,9 +357,9 @@ internal override void WriteToStream(BinaryWriter writer)
             // TargetNames cannot be null as per the constructor
             writer.Write(targetNames!);
 
-            // If no properties were added to the property list 
+            // If no properties were added to the property list
             // then we have nothing to create when it is deserialized
-            // This can happen if properties is null or if none of the 
+            // This can happen if properties is null or if none of the
             // five properties were found in the property object.
             if (properties == null)
             {
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 2ed1a2a539d..f0d1f5e83d7 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -13,7 +13,7 @@
 #endif
 
 #if FEATURE_SECURITY_PERMISSIONS
-// A combination of RequestMinimum and RequestOptional causes the permissions granted to 
+// A combination of RequestMinimum and RequestOptional causes the permissions granted to
 // the assembly to only be the permission requested (like a PermitOnly). More generally
 // the equation for the PermissionSet granted at load time is:
 //
@@ -25,7 +25,7 @@
 //        ReqOpt -- the permissions that RequestOptional is specified for.
 //        ReqRefuse -- the permissions that Request refuse is specified for.
 //
-// Note that if ReqOpt is the empty set, then it is consider to be "FullTrust" and this 
+// Note that if ReqOpt is the empty set, then it is consider to be "FullTrust" and this
 // equation becomes:
 //
 //        Granted = MaxGrant - ReqRefuse
@@ -55,15 +55,15 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
 // This is the assembly-level GUID, and the GUID for the TypeLib associated with
-// this assembly.  We should specify this explicitly, as opposed to letting 
+// this assembly.  We should specify this explicitly, as opposed to letting
 // tlbexp just pick whatever it wants.
 [assembly: GuidAttribute("D8A9BA71-4724-481d-9CA7-0DA23A1D615C")]
 
 #if FEATURE_XAML_TYPES
 [assembly: XmlnsDefinition("http://schemas.microsoft.com/build/2009/properties", "Microsoft.Build.Framework.XamlTypes")]
 #endif
-// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
-// so that we don't run into known security issues with loading libraries from unsafe locations 
+// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
+// so that we don't run into known security issues with loading libraries from unsafe locations
 [assembly: DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories)]
 
 [assembly: NeutralResourcesLanguage("en")]
diff --git a/src/Framework/RequiredRuntimeAttribute.cs b/src/Framework/RequiredRuntimeAttribute.cs
index ba6b8000437..6cd509b6cbb 100644
--- a/src/Framework/RequiredRuntimeAttribute.cs
+++ b/src/Framework/RequiredRuntimeAttribute.cs
@@ -8,17 +8,17 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// When marked with the RequiredRuntimeAttribute, a task indicates that it has stricter 
-    /// runtime requirements than a regular task - this tells MSBuild that it will need to potentially 
+    /// When marked with the RequiredRuntimeAttribute, a task indicates that it has stricter
+    /// runtime requirements than a regular task - this tells MSBuild that it will need to potentially
     /// launch a separate process for that task if the current runtime does not match the version requirement.
     /// This attribute is currently non-functional since there is only one version of the CLR that is
-    /// capable of running MSBuild v2.0 or v3.5 - the runtime v2.0 
+    /// capable of running MSBuild v2.0 or v3.5 - the runtime v2.0
     /// </summary>
     [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class RequiredRuntimeAttribute : Attribute
     {
         /// <summary>
-        /// Constructor taking a version, such as "v2.0". 
+        /// Constructor taking a version, such as "v2.0".
         /// </summary>
         public RequiredRuntimeAttribute(string runtimeVersion)
         {
diff --git a/src/Framework/ReuseableStringBuilder.cs b/src/Framework/ReuseableStringBuilder.cs
index 264daffacd0..151732773cf 100644
--- a/src/Framework/ReuseableStringBuilder.cs
+++ b/src/Framework/ReuseableStringBuilder.cs
@@ -245,7 +245,7 @@ private static class ReuseableStringBuilderFactory
 
             /// <summary>
             /// Obtains a string builder which may or may not already
-            /// have been used. 
+            /// have been used.
             /// Never returns null.
             /// </summary>
             internal static StringBuilder Get(int capacity)
@@ -310,7 +310,7 @@ internal static void Release(ReuseableStringBuilder returning)
                 //
                 // If some code has a bug and forgets to return their builder
                 // (or we refuse it here because it's too big) the next user will
-                // get given a new one, and then return it soon after. 
+                // get given a new one, and then return it soon after.
                 // So the shared builder will be "replaced".
                 if (returningBuilder.Capacity > MaxBuilderSizeCapacity)
                 {
diff --git a/src/Framework/Sdk/SdkResolver.cs b/src/Framework/Sdk/SdkResolver.cs
index 7c0a662b2fc..939be3a297e 100644
--- a/src/Framework/Sdk/SdkResolver.cs
+++ b/src/Framework/Sdk/SdkResolver.cs
@@ -31,11 +31,11 @@ public abstract class SdkResolver
         /// An <see cref="SdkResult" /> containing the resolved SDKs or associated error / reason
         /// the SDK could not be resolved.  Return <see langword="null"/> if the resolver is not
         /// applicable for a particular <see cref="SdkReference"/>.
-        /// </returns>   
+        /// </returns>
         /// <remarks>
         ///  Note: You must use <see cref="SdkResultFactory"/> to return a result.
         ///  </remarks>
-        /// 
+        ///
         public abstract SdkResult Resolve(SdkReference sdkReference,
                                           SdkResolverContext resolverContext,
                                           SdkResultFactory factory);
diff --git a/src/Framework/Sdk/SdkResolverContext.cs b/src/Framework/Sdk/SdkResolverContext.cs
index 17d39ee584b..1f8c0a92810 100644
--- a/src/Framework/Sdk/SdkResolverContext.cs
+++ b/src/Framework/Sdk/SdkResolverContext.cs
@@ -43,7 +43,7 @@ public abstract class SdkResolverContext
         /// <remarks>
         ///    <format type="text/markdown"><![CDATA[
         /// ## Remarks
-        ///     
+        ///
         /// File version is informational and not equal to the assembly version.
         /// ]]></format>
         /// </remarks>
diff --git a/src/Framework/Sdk/SdkResult.cs b/src/Framework/Sdk/SdkResult.cs
index a3b354827a5..668276efc9f 100644
--- a/src/Framework/Sdk/SdkResult.cs
+++ b/src/Framework/Sdk/SdkResult.cs
@@ -35,7 +35,7 @@ public abstract class SdkResult
 
         /// <summary>
         ///     Resolved path to the SDK.
-        /// 
+        ///
         ///     Null if <see cref="Success"/> == false
         /// </summary>
         public virtual string Path { get => _path; protected set => _path = value; }
@@ -43,7 +43,7 @@ public abstract class SdkResult
         /// <summary>
         ///     Resolved version of the SDK.
         ///     Can be null or empty if the resolver did not provide a version (e.g. a path based resolver)
-        /// 
+        ///
         ///     Null if <see cref="Success"/> == false
         /// </summary>
         public virtual string Version { get => _version; protected set => _version = value; }
diff --git a/src/Framework/TargetFinishedEventArgs.cs b/src/Framework/TargetFinishedEventArgs.cs
index 5909897d5eb..454d2ce24cc 100644
--- a/src/Framework/TargetFinishedEventArgs.cs
+++ b/src/Framework/TargetFinishedEventArgs.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Framework
     public class TargetFinishedEventArgs : BuildStatusEventArgs
     {
         /// <summary>
-        /// Default constructor 
+        /// Default constructor
         /// </summary>
         protected TargetFinishedEventArgs()
             : base()
diff --git a/src/Framework/TargetStartedEventArgs.cs b/src/Framework/TargetStartedEventArgs.cs
index 27275a91205..22f162a6392 100644
--- a/src/Framework/TargetStartedEventArgs.cs
+++ b/src/Framework/TargetStartedEventArgs.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.Framework
     // promise to never change the type's fields i.e. the type is
     // immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both
-    // forward and backward compatibility    
+    // forward and backward compatibility
     [Serializable]
     public class TargetStartedEventArgs : BuildStatusEventArgs
     {
@@ -158,7 +158,7 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         public string ParentTarget => parentTarget;
 
         /// <summary>
-        /// Project file associated with event.   
+        /// Project file associated with event.
         /// </summary>
         public string ProjectFile => projectFile;
 
diff --git a/src/Framework/TaskFinishedEventArgs.cs b/src/Framework/TaskFinishedEventArgs.cs
index f1d88eb301e..4713316748d 100644
--- a/src/Framework/TaskFinishedEventArgs.cs
+++ b/src/Framework/TaskFinishedEventArgs.cs
@@ -38,7 +38,7 @@ protected TaskFinishedEventArgs()
         /// <param name="helpKeyword">help keyword </param>
         /// <param name="projectFile">project file</param>
         /// <param name="taskFile">file in which the task is defined</param>
-        /// <param name="taskName">task name</param> 
+        /// <param name="taskName">task name</param>
         /// <param name="succeeded">true indicates task succeed</param>
         public TaskFinishedEventArgs(
             string message,
@@ -59,7 +59,7 @@ public TaskFinishedEventArgs(
         /// <param name="helpKeyword">help keyword </param>
         /// <param name="projectFile">project file</param>
         /// <param name="taskFile">file in which the task is defined</param>
-        /// <param name="taskName">task name</param> 
+        /// <param name="taskName">task name</param>
         /// <param name="succeeded">true indicates task succeed</param>
         /// <param name="eventTimestamp">Timestamp when event was created</param>
         public TaskFinishedEventArgs(
@@ -127,12 +127,12 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         public bool Succeeded => succeeded;
 
         /// <summary>
-        /// Project file associated with event.   
+        /// Project file associated with event.
         /// </summary>
         public string ProjectFile => projectFile;
 
         /// <summary>
-        /// MSBuild file where this task was defined.   
+        /// MSBuild file where this task was defined.
         /// </summary>
         public string TaskFile => taskFile;
 
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index d8d17ed4534..bdf19fa080a 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -116,12 +116,12 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         public string TaskName => taskName;
 
         /// <summary>
-        /// Project file associated with event.   
+        /// Project file associated with event.
         /// </summary>
         public string ProjectFile => projectFile;
 
         /// <summary>
-        /// MSBuild file where this task was defined.   
+        /// MSBuild file where this task was defined.
         /// </summary>
         public string TaskFile => taskFile;
 
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 04b2fc90237..7fd91aa8db7 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -543,10 +543,10 @@ internal static void ThrowInternalError(string message, params object[] args)
 
         /// <summary>
         /// Formats the given string using the variable arguments passed in.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="unformatted">The string to format.</param>
@@ -563,7 +563,7 @@ internal static string FormatString(string unformatted, params object[] args)
             if ((args?.Length > 0))
             {
 #if DEBUG
-                // If you accidentally pass some random type in that can't be converted to a string, 
+                // If you accidentally pass some random type in that can't be converted to a string,
                 // FormatResourceString calls ToString() which returns the full name of the type!
                 foreach (object param in args)
                 {
diff --git a/src/Framework/XamlTypes/Argument.cs b/src/Framework/XamlTypes/Argument.cs
index d223f4287f7..ea0078c1d15 100644
--- a/src/Framework/XamlTypes/Argument.cs
+++ b/src/Framework/XamlTypes/Argument.cs
@@ -9,10 +9,10 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Represents an argument to a <see cref="BaseProperty"/>. 
+    /// Represents an argument to a <see cref="BaseProperty"/>.
     /// </summary>
-    /// <remarks> 
-    /// Functionally, it is simply a reference to another <see cref="BaseProperty"/>. Those who manually 
+    /// <remarks>
+    /// Functionally, it is simply a reference to another <see cref="BaseProperty"/>. Those who manually
     /// instantiate this class should remember to call <see cref="BeginInit"/> before setting the first
     /// property and <see cref="EndInit"/> after setting the last property of the object.
     /// </remarks>
@@ -33,7 +33,7 @@ public Argument()
         #region Properties
 
         /// <summary>
-        /// Name of the <see cref="BaseProperty"/> this argument refers to. 
+        /// Name of the <see cref="BaseProperty"/> this argument refers to.
         /// </summary>
         /// <remarks>
         /// Its value must point to a valid <see cref="BaseProperty"/>. This field is mandatory and culture invariant.
@@ -48,7 +48,7 @@ public string Property
         /// Tells if the <see cref="BaseProperty"/> pointed to by <see cref="Property"/> must be defined for the definition
         /// of the <see cref="BaseProperty"/> owning this argument to make sense.
         /// </summary>
-        /// <remarks> 
+        /// <remarks>
         /// This field is optional and is set to <c>false</c> by default.
         /// </remarks>
         public bool IsRequired
diff --git a/src/Framework/XamlTypes/BaseProperty.cs b/src/Framework/XamlTypes/BaseProperty.cs
index 258a30747bf..0160d559c8e 100644
--- a/src/Framework/XamlTypes/BaseProperty.cs
+++ b/src/Framework/XamlTypes/BaseProperty.cs
@@ -12,9 +12,9 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Represents a <see cref="Rule"/> property. 
+    /// Represents a <see cref="Rule"/> property.
     /// </summary>
-    /// <remarks> 
+    /// <remarks>
     /// <para>This represents schema information (name, allowed values, etc) of a <see cref="Rule"/> property.
     /// Since this is just schema information, there is no field like "Value" used to get/set the value of this
     /// property.</para>
@@ -71,10 +71,10 @@ protected BaseProperty()
         #region Properties
 
         /// <summary>
-        /// The name of this <see cref="BaseProperty"/>. 
+        /// The name of this <see cref="BaseProperty"/>.
         /// </summary>
         /// <remarks>
-        /// This field is mandatory and culture invariant. The value of this field cannot be set to the empty string. 
+        /// This field is mandatory and culture invariant. The value of this field cannot be set to the empty string.
         /// </remarks>
         public string Name
         {
@@ -83,10 +83,10 @@ public string Name
         }
 
         /// <summary>
-        /// The name that could be used by a prospective UI client to display this <see cref="BaseProperty"/>. 
+        /// The name that could be used by a prospective UI client to display this <see cref="BaseProperty"/>.
         /// </summary>
         /// <remarks>
-        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same 
+        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same
         /// value as the <see cref="Name"/> property (and hence, would not be localized).
         /// </remarks>
         [Localizable(true)]
@@ -104,9 +104,9 @@ public string DisplayName
         }
 
         /// <summary>
-        /// Description of this <see cref="BaseProperty"/> for use by a prospective UI client. 
+        /// Description of this <see cref="BaseProperty"/> for use by a prospective UI client.
         /// </summary>
-        /// <remarks> 
+        /// <remarks>
         /// This field is optional and is culture sensitive.
         /// </remarks>
         [Localizable(true)]
@@ -135,7 +135,7 @@ public string F1Keyword
         /// The URL of the help page for this property that will be opened when the user hits F1.
         /// </summary>
         /// <remarks>
-        /// This property is higher in priority that <see cref="HelpContext"/> + <see cref="HelpFile"/> 
+        /// This property is higher in priority that <see cref="HelpContext"/> + <see cref="HelpFile"/>
         /// (i.e., these two properties are ignored if <see cref="HelpUrl"/>
         /// is specified), but lower in priority than <see cref="F1Keyword"/>.
         /// This field is optional and is culture insensitive.
@@ -152,7 +152,7 @@ public string HelpUrl
         /// <summary>
         /// The help file to use when the user hits F1. Must specify <see cref="HelpContext"/> along with this.
         /// </summary>
-        /// <remarks> 
+        /// <remarks>
         /// This property goes along with <see cref="HelpContext"/>. <seealso cref="HelpContext"/>. This
         /// form of specifying the help page for a property takes lower precedence than both <see cref="F1Keyword"/>
         /// and <see cref="HelpUrl"/>.
@@ -169,7 +169,7 @@ public string HelpFile
         /// The help context to use when the user hits F1. Must specify <see cref="HelpFile"/> along with this.
         /// </summary>
         /// <remarks>
-        /// This property uses the <see cref="HelpFile"/> property to display the help context of the specified 
+        /// This property uses the <see cref="HelpFile"/> property to display the help context of the specified
         /// help file. This field is optional. This
         /// form of specifying the help page for a property takes lower precedence than both <see cref="F1Keyword"/>
         /// and <see cref="HelpUrl"/>.
@@ -181,17 +181,17 @@ public int HelpContext
         }
 
         /// <summary>
-        /// The name of the category to which this property belongs to. 
+        /// The name of the category to which this property belongs to.
         /// </summary>
         /// <remarks>
         /// <para>
-        /// If the value of this field  does not correspond to the <c>Name</c> 
+        /// If the value of this field  does not correspond to the <c>Name</c>
         /// property of a <see cref="Category"/> element defined in
         /// the containing <see cref="Rule"/>, a default <see cref="Category"/> with this name
-        /// is auto-generated and added to the containing <see cref="Rule"/> class. 
+        /// is auto-generated and added to the containing <see cref="Rule"/> class.
         /// </para>
         /// <para>
-        /// This field is optional and is culture invariant. 
+        /// This field is optional and is culture invariant.
         /// </para>
         /// <para>
         /// When this field is not specified, this property is added to a
@@ -215,7 +215,7 @@ public string Subcategory
         }
 
         /// <summary>
-        /// Tells if this property is a read-only property. 
+        /// Tells if this property is a read-only property.
         /// </summary>
         /// <remarks>
         /// This field is optional and its default value is "false".
@@ -276,7 +276,7 @@ public string SwitchPrefix
         /// This field is optional and culture invariant.
         /// </remarks>
         /// <example>
-        /// Example: Consider <c>/D:WIN32</c>. In this switch and value representation, ":" is the separator since its separates the switch <c>D</c> 
+        /// Example: Consider <c>/D:WIN32</c>. In this switch and value representation, ":" is the separator since its separates the switch <c>D</c>
         /// from its value <c>WIN32</c>.
         /// </example>
         public string Separator
@@ -321,7 +321,7 @@ public bool IsRequired
         }
 
         /// <summary>
-        /// Specifies the default value for this property. 
+        /// Specifies the default value for this property.
         /// </summary>
         /// <remarks>
         /// This field is optional and whether, for a <see cref="StringProperty"/>,
@@ -335,10 +335,10 @@ public string Default
         }
 
         /// <summary>
-        /// The data source where the current value of this property is stored. 
+        /// The data source where the current value of this property is stored.
         /// </summary>
         /// <remarks>
-        /// If defined, it overrides the 
+        /// If defined, it overrides the
         /// <see cref="Rule.DataSource"/> property on the containing <see cref="Rule"/>. This field is mandatory only if the parent
         /// <see cref="Rule"/> does not have the data source initialized. The getter for this property returns
         /// only the <see cref="DataSource"/> set directly on this <see cref="BaseProperty"/> instance.
@@ -350,7 +350,7 @@ public DataSource DataSource
         }
 
         /// <summary>
-        /// Additional attributes of this <see cref="BaseProperty"/>. 
+        /// Additional attributes of this <see cref="BaseProperty"/>.
         /// </summary>
         /// <remarks>
         /// This can be used as a grab bag of additional metadata of this property that are not
@@ -379,7 +379,7 @@ public List<Argument> Arguments
         }
 
         /// <summary>
-        /// List of value editors for this property. 
+        /// List of value editors for this property.
         /// </summary>
         /// <remarks>
         /// This field is optional.
@@ -395,9 +395,9 @@ public List<ValueEditor> ValueEditors
     }
 
     /// <summary>
-    /// Represents a <see cref="Rule"/> property. 
+    /// Represents a <see cref="Rule"/> property.
     /// </summary>
-    /// <remarks> 
+    /// <remarks>
     /// <para>This represents schema information (name, allowed values, etc) of a <see cref="Rule"/> property.
     /// Since this is just schema information, there is no field like "Value" used to get/set the value of this
     /// property.</para>
diff --git a/src/Framework/XamlTypes/BoolProperty.cs b/src/Framework/XamlTypes/BoolProperty.cs
index 3476db9732a..7d281fcd17e 100644
--- a/src/Framework/XamlTypes/BoolProperty.cs
+++ b/src/Framework/XamlTypes/BoolProperty.cs
@@ -13,9 +13,9 @@ public sealed class BoolProperty : BaseProperty
         #region Properties
 
         /// <summary>
-        /// Represents the logical negation of a boolean switch. 
+        /// Represents the logical negation of a boolean switch.
         /// </summary>
-        /// <example> 
+        /// <example>
         /// <para>
         /// For the VC++ CL task, <c>WholeProgramOptimization</c> is a boolean parameter. It's switch is <c>GL</c>. To
         /// disable whole program optimization, you need to pass the ReverseSwitch, which is <c>GL-</c>.
diff --git a/src/Framework/XamlTypes/Category.cs b/src/Framework/XamlTypes/Category.cs
index 7538572c08e..2a17393915b 100644
--- a/src/Framework/XamlTypes/Category.cs
+++ b/src/Framework/XamlTypes/Category.cs
@@ -10,8 +10,8 @@ namespace Microsoft.Build.Framework.XamlTypes
     /// <summary>
     /// Represents a category to which a <see cref="BaseProperty"/> can belong to.
     /// </summary>
-    /// <remarks> 
-    /// Those who manually 
+    /// <remarks>
+    /// Those who manually
     /// instantiate this class should remember to call <see cref="BeginInit"/> before setting the first
     /// property and <see cref="EndInit"/> after setting the last property of the object.
     /// </remarks>
@@ -33,7 +33,7 @@ public sealed partial class Category : CategorySchema, ISupportInitialize
         #region Properties
 
         /// <summary>
-        /// The name of this <see cref="Category"/>. 
+        /// The name of this <see cref="Category"/>.
         /// </summary>
         /// <remarks>
         /// This field is mandatory and culture invariant.
@@ -46,10 +46,10 @@ public string Name
         }
 
         /// <summary>
-        /// The name that could be used by a prospective UI client to display this <see cref="Category"/>. 
+        /// The name that could be used by a prospective UI client to display this <see cref="Category"/>.
         /// </summary>
         /// <remarks>
-        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same 
+        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same
         /// value as the <see cref="Name"/> property (and hence, would not be localized).
         /// </remarks>
         [Localizable(true)]
@@ -67,7 +67,7 @@ public string DisplayName
         }
 
         /// <summary>
-        /// Description of this <see cref="Category"/>. 
+        /// Description of this <see cref="Category"/>.
         /// </summary>
         /// <remarks>
         /// This field is optional and is culture sensitive.
@@ -93,7 +93,7 @@ public string Subtype
         }
 
         /// <summary>
-        /// Help information for this <see cref="Category"/>. 
+        /// Help information for this <see cref="Category"/>.
         /// </summary>
         /// <remarks>
         /// Maybe used to specify a help URL. This field
@@ -112,8 +112,8 @@ public string HelpString
     /// <summary>
     /// Represents a category to which a <see cref="BaseProperty"/> can belong to.
     /// </summary>
-    /// <remarks> 
-    /// Those who manually 
+    /// <remarks>
+    /// Those who manually
     /// instantiate this class should remember to call <see cref="BeginInit"/> before setting the first
     /// property and <see cref="EndInit"/> after setting the last property of the object.
     /// </remarks>
diff --git a/src/Framework/XamlTypes/ContentType.cs b/src/Framework/XamlTypes/ContentType.cs
index d8e3f8bb7ee..a3f55e6c143 100644
--- a/src/Framework/XamlTypes/ContentType.cs
+++ b/src/Framework/XamlTypes/ContentType.cs
@@ -12,7 +12,7 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Used to deserialize the content type information 
+    /// Used to deserialize the content type information
     /// </summary>
     [ContentProperty("Metadata")]
     public sealed class ContentType : ISupportInitialize, IProjectSchemaNode
diff --git a/src/Framework/XamlTypes/DynamicEnumProperty.cs b/src/Framework/XamlTypes/DynamicEnumProperty.cs
index cb4e230b993..60ff0471a59 100644
--- a/src/Framework/XamlTypes/DynamicEnumProperty.cs
+++ b/src/Framework/XamlTypes/DynamicEnumProperty.cs
@@ -43,6 +43,6 @@ public DynamicEnumProperty()
         [SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Justification = "Concrete collection types required for XAML deserialization")]
         public List<NameValuePair> ProviderSettings { get; set; }
 
-        #endregion 
+        #endregion
     }
 }
diff --git a/src/Framework/XamlTypes/EnumProperty.cs b/src/Framework/XamlTypes/EnumProperty.cs
index 749a26394b6..499881abfc7 100644
--- a/src/Framework/XamlTypes/EnumProperty.cs
+++ b/src/Framework/XamlTypes/EnumProperty.cs
@@ -42,7 +42,7 @@ public List<EnumValue> AdmissibleValues
             set;
         }
 
-        #endregion 
+        #endregion
 
         #region ISupportInitialize Methods
 
diff --git a/src/Framework/XamlTypes/EnumValue.cs b/src/Framework/XamlTypes/EnumValue.cs
index 4c90e0b947d..d2694f6fc52 100644
--- a/src/Framework/XamlTypes/EnumValue.cs
+++ b/src/Framework/XamlTypes/EnumValue.cs
@@ -44,7 +44,7 @@ public EnumValue()
         #region Properties
 
         /// <summary>
-        /// The name of this <see cref="EnumValue"/>. 
+        /// The name of this <see cref="EnumValue"/>.
         /// </summary>
         /// <remarks>
         /// This field is mandatory and culture invariant.
@@ -56,10 +56,10 @@ public string Name
         }
 
         /// <summary>
-        /// The name that could be used by a prospective UI client to display this <see cref="EnumValue"/>. 
+        /// The name that could be used by a prospective UI client to display this <see cref="EnumValue"/>.
         /// </summary>
         /// <remarks>
-        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same 
+        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same
         /// value as the <see cref="Name"/> property (and hence, would not be localized).
         /// </remarks>
         [Localizable(true)]
@@ -77,9 +77,9 @@ public string DisplayName
         }
 
         /// <summary>
-        /// Description of this <see cref="BaseProperty"/> for use by a prospective UI client. 
+        /// Description of this <see cref="BaseProperty"/> for use by a prospective UI client.
         /// </summary>
-        /// <remarks> 
+        /// <remarks>
         /// This field is optional and is culture sensitive.
         /// </remarks>
         [Localizable(true)]
@@ -90,7 +90,7 @@ public string Description
         }
 
         /// <summary>
-        /// Help information for this <see cref="EnumValue"/>. 
+        /// Help information for this <see cref="EnumValue"/>.
         /// </summary>
         /// <remarks>
         /// Maybe used to specify a help URL. This field
@@ -110,7 +110,7 @@ public string HelpString
         /// This field is optional and culture invariant.
         /// </remarks>
         /// <example> The VC compiler has an <see cref="EnumProperty"/> named <c>Optimization</c>used to specify the desired optimization type. All the
-        /// admissible values for this property have switches, e.g. <c>Disabled</c> (switch = <c>Od</c>), "MinimumSize" (switch = <c>O1</c>), 
+        /// admissible values for this property have switches, e.g. <c>Disabled</c> (switch = <c>Od</c>), "MinimumSize" (switch = <c>O1</c>),
         /// etc. </example>
         public string Switch
         {
@@ -132,7 +132,7 @@ public string SwitchPrefix
 
         /// <summary>
         /// Tells if this <see cref="EnumValue"/> is the default value for the associated
-        /// <see cref="EnumProperty"/>. 
+        /// <see cref="EnumProperty"/>.
         /// </summary>
         /// <remarks>
         /// This field is optional and the default value for this
@@ -145,7 +145,7 @@ public bool IsDefault
         }
 
         /// <summary>
-        /// Additional attributes of this <see cref="EnumValue"/>. 
+        /// Additional attributes of this <see cref="EnumValue"/>.
         /// </summary>
         /// <remarks>
         /// This can be used as a grab bag of additional metadata of this value that are not
@@ -161,7 +161,7 @@ public List<NameValuePair> Metadata
         }
 
         /// <summary>
-        /// List of arguments for this <see cref="EnumValue"/>. 
+        /// List of arguments for this <see cref="EnumValue"/>.
         /// </summary>
         /// <remarks>
         /// This field is optional.
@@ -173,6 +173,6 @@ public List<Argument> Arguments
             set;
         }
 
-        #endregion 
+        #endregion
     }
 }
diff --git a/src/Framework/XamlTypes/FileExtension.cs b/src/Framework/XamlTypes/FileExtension.cs
index 43c421f90de..77d6c3385f0 100644
--- a/src/Framework/XamlTypes/FileExtension.cs
+++ b/src/Framework/XamlTypes/FileExtension.cs
@@ -21,7 +21,7 @@ public FileExtension()
         }
 
         /// <summary>
-        /// file extension 
+        /// file extension
         /// </summary>
         public string Name
         {
diff --git a/src/Framework/XamlTypes/IntProperty.cs b/src/Framework/XamlTypes/IntProperty.cs
index a3bcf704968..8a9566e7561 100644
--- a/src/Framework/XamlTypes/IntProperty.cs
+++ b/src/Framework/XamlTypes/IntProperty.cs
@@ -13,10 +13,10 @@ public sealed class IntProperty : BaseProperty
         #region Properties
 
         /// <summary>
-        /// Minimum allowed value for this property. 
+        /// Minimum allowed value for this property.
         /// </summary>
         /// <remarks>
-        /// This field is optional. 
+        /// This field is optional.
         /// It returns null when this property is not set. The value of this
         /// property must be less than or equal to the <see cref="MaxValue"/>
         /// property (assuming that the latter is defined).
@@ -28,10 +28,10 @@ public int? MinValue
         }
 
         /// <summary>
-        /// Maximum allowed value for this property. 
+        /// Maximum allowed value for this property.
         /// </summary>
         /// <remarks>
-        /// This field is optional. 
+        /// This field is optional.
         /// It returns null when this property is not set. The value of this
         /// property must be greater than or equal to the <see cref="MinValue"/>
         /// property (assuming that the latter is defined).
diff --git a/src/Framework/XamlTypes/ItemType.cs b/src/Framework/XamlTypes/ItemType.cs
index 14a8d89c880..c1fd7f6733f 100644
--- a/src/Framework/XamlTypes/ItemType.cs
+++ b/src/Framework/XamlTypes/ItemType.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Used to deserialize the item type information 
+    /// Used to deserialize the item type information
     /// </summary>
     public sealed class ItemType : ISupportInitialize, IProjectSchemaNode
     {
diff --git a/src/Framework/XamlTypes/NameValuePair.cs b/src/Framework/XamlTypes/NameValuePair.cs
index 7de604d79f6..cdd6300d401 100644
--- a/src/Framework/XamlTypes/NameValuePair.cs
+++ b/src/Framework/XamlTypes/NameValuePair.cs
@@ -15,7 +15,7 @@ public class NameValuePair
         #region Constructor
 
         /// <summary>
-        /// Default constructor needed for 
+        /// Default constructor needed for
         /// </summary>
         public NameValuePair()
         {
diff --git a/src/Framework/XamlTypes/Rule.cs b/src/Framework/XamlTypes/Rule.cs
index b833e7b888e..ae225536085 100644
--- a/src/Framework/XamlTypes/Rule.cs
+++ b/src/Framework/XamlTypes/Rule.cs
@@ -35,9 +35,9 @@ public enum RuleOverrideMode
     }
 
     /// <summary>
-    /// Used to represent the schema information for a Tool, a Custom Build Rule, a PropertyPage, etc. 
-    /// </summary> 
-    /// <remarks> 
+    /// Used to represent the schema information for a Tool, a Custom Build Rule, a PropertyPage, etc.
+    /// </summary>
+    /// <remarks>
     /// <para>
     /// Normally represented on disk as XAML, only one instance of this class is maintained per XAML
     /// file per project engine (solution).
@@ -90,10 +90,10 @@ public Rule()
         #region Properties
 
         /// <summary>
-        /// The name of this <see cref="Rule"/>. 
+        /// The name of this <see cref="Rule"/>.
         /// </summary>
         /// <remarks>
-        /// This field is mandatory and culture invariant. The value of this field cannot be set to the empty string. 
+        /// This field is mandatory and culture invariant. The value of this field cannot be set to the empty string.
         /// </remarks>
         public string Name
         {
@@ -102,10 +102,10 @@ public string Name
         }
 
         /// <summary>
-        /// The name that could be used by a prospective UI client to display this <see cref="BaseProperty"/>. 
+        /// The name that could be used by a prospective UI client to display this <see cref="BaseProperty"/>.
         /// </summary>
         /// <remarks>
-        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same 
+        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same
         /// value as the <see cref="Name"/> property (and hence, would not be localized).
         /// </remarks>
         [Localizable(true)]
@@ -132,9 +132,9 @@ public string ToolName
         }
 
         /// <summary>
-        /// Description of this <see cref="Rule"/> for use by a prospective UI client. 
+        /// Description of this <see cref="Rule"/> for use by a prospective UI client.
         /// </summary>
-        /// <remarks> 
+        /// <remarks>
         /// This field is optional and is culture sensitive.
         /// </remarks>
         [Localizable(true)]
@@ -145,7 +145,7 @@ public string Description
         }
 
         /// <summary>
-        /// Help information for this <see cref="Rule"/>. 
+        /// Help information for this <see cref="Rule"/>.
         /// </summary>
         /// <remarks>
         /// Maybe used to specify a help URL. This field
@@ -184,7 +184,7 @@ public string SwitchPrefix
         /// This field is optional and culture invariant.
         /// </remarks>
         /// <example>
-        /// Example: Consider <c>/D:WIN32</c>. In this switch and value representation, ":" is the separator since its separates the switch <c>D</c> 
+        /// Example: Consider <c>/D:WIN32</c>. In this switch and value representation, ":" is the separator since its separates the switch <c>D</c>
         /// from its value <c>WIN32</c>.
         /// </example>
         public string Separator
@@ -194,7 +194,7 @@ public string Separator
         }
 
         /// <summary>
-        /// The UI renderer template used to display this Rule. 
+        /// The UI renderer template used to display this Rule.
         /// </summary>
         /// <remarks>
         /// The value used to set
@@ -209,7 +209,7 @@ public string PageTemplate
 
         /// <summary>
         /// The <see cref="DataSource"/> for all the properties in this <see cref="Rule"/>. This is overriden by any
-        /// data source defined locally for a property. 
+        /// data source defined locally for a property.
         /// </summary>
         /// <remarks>
         /// This field need not be specified only if all individual properties have data source defined locally.
@@ -230,7 +230,7 @@ public int Order
         }
 
         /// <summary>
-        /// This is used to specify whether multiple files need to be batched on one command line invocation. 
+        /// This is used to specify whether multiple files need to be batched on one command line invocation.
         /// </summary>
         /// <remarks>
         /// This field is optional.
@@ -337,7 +337,7 @@ public List<BaseProperty> Properties
         }
 
         /// <summary>
-        /// The list of <see cref="Category"/>s that properties in this <see cref="Rule"/> belong to. 
+        /// The list of <see cref="Category"/>s that properties in this <see cref="Rule"/> belong to.
         /// </summary>
         /// <remarks>
         /// This field is optional. Note that this field returns only the categories that were explicitly defined and do
@@ -368,9 +368,9 @@ public List<Category> Categories
     }
 
     /// <summary>
-    /// Used to represent the schema information for a Tool, a Custom Build Rule, a PropertyPage, etc. 
-    /// </summary> 
-    /// <remarks> 
+    /// Used to represent the schema information for a Tool, a Custom Build Rule, a PropertyPage, etc.
+    /// </summary>
+    /// <remarks>
     /// <para>
     /// Normally represented on disk as XAML, only one instance of this class is maintained per XAML
     /// file per project engine (solution).
@@ -413,8 +413,8 @@ public sealed partial class Rule : RuleSchema, ISupportInitialize, IProjectSchem
         #region Properties
 
         /// <summary>
-        /// This property returns the union of XAML specified <see cref="Category"/>s and auto-generated 
-        /// <see cref="Category"/>s. The latter are created from the missing categories that are being referred to by the 
+        /// This property returns the union of XAML specified <see cref="Category"/>s and auto-generated
+        /// <see cref="Category"/>s. The latter are created from the missing categories that are being referred to by the
         /// properties in this Rule. The auto-generated <see cref="Category"/>s only have their name set.
         /// </summary>
         public List<Category> EvaluatedCategories
@@ -440,7 +440,7 @@ public List<Category> EvaluatedCategories
 
         /// <summary>
         /// Returns all properties partitioned into categories. The return value is never
-        /// null. 
+        /// null.
         /// The returned list may contain auto-generated categories. Note that if a <see cref="BaseProperty"/>
         /// (or its derived classes) refer to a property that is not specified, then an new
         /// Category is generated for the same. If not category is specified for the property, then
@@ -448,7 +448,7 @@ public List<Category> EvaluatedCategories
         /// The list of categories is exactly as specified in the Xaml file. The auto-generated
         /// categories come (in no strict order) after the specified categories.
         /// </summary>
-        /// <returns> A dictionary whose keys are the <see cref="Category"/> names and 
+        /// <returns> A dictionary whose keys are the <see cref="Category"/> names and
         /// the value is the list of properties in that category. </returns>
         public OrderedDictionary GetPropertiesByCategory()
         {
diff --git a/src/Framework/XamlTypes/RuleBag.cs b/src/Framework/XamlTypes/RuleBag.cs
index 2263e46d90e..6183a331574 100644
--- a/src/Framework/XamlTypes/RuleBag.cs
+++ b/src/Framework/XamlTypes/RuleBag.cs
@@ -12,12 +12,12 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// This is a simple container for <see cref="Rule"/> instances. 
+    /// This is a simple container for <see cref="Rule"/> instances.
     /// </summary>
     /// <remarks>
     /// Note that we only deal in terms of <see cref="Rule"/>s
-    /// as far as property pages are concerned. The <see cref="RuleBag"/> is only used as a 
-    /// container for more than one <see cref="Rule"/>. The containing <see cref="Rule"/>s are 
+    /// as far as property pages are concerned. The <see cref="RuleBag"/> is only used as a
+    /// container for more than one <see cref="Rule"/>. The containing <see cref="Rule"/>s are
     /// immediately stripped off after loading of the xaml file.
     /// </remarks>
     [ContentProperty("Rules")]
@@ -48,7 +48,7 @@ public List<Rule> Rules
             set;
         }
 
-        #endregion 
+        #endregion
 
         #region ISupportInitialize Members
 
diff --git a/src/Framework/XamlTypes/StringListProperty.cs b/src/Framework/XamlTypes/StringListProperty.cs
index 7aea73e76f8..39e1d9f8f1f 100644
--- a/src/Framework/XamlTypes/StringListProperty.cs
+++ b/src/Framework/XamlTypes/StringListProperty.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Represents the schema of a list-of-strings property. 
+    /// Represents the schema of a list-of-strings property.
     /// </summary>
     /// <remarks>
     /// Note, this represents
@@ -56,7 +56,7 @@ public string RendererValueSeparator
         /// Qualifies this string property to give it a more specific classification.
         /// </summary>
         /// <remarks>
-        /// Similar to the <see cref="StringProperty.Subtype"/> property. 
+        /// Similar to the <see cref="StringProperty.Subtype"/> property.
         /// </remarks>
         public string Subtype
         {
diff --git a/src/Framework/XamlTypes/ValueEditor.cs b/src/Framework/XamlTypes/ValueEditor.cs
index f8aa2923bd7..4cd11a07958 100644
--- a/src/Framework/XamlTypes/ValueEditor.cs
+++ b/src/Framework/XamlTypes/ValueEditor.cs
@@ -12,7 +12,7 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Represents a value editor 
+    /// Represents a value editor
     /// </summary>
     [ContentProperty("Metadata")]
     public sealed class ValueEditor : ISupportInitialize
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index 1f0489284ab..16fbed5a461 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -315,7 +315,7 @@ public void PropertyMSBuildStartupDirectoryOnServer()
         </ProcessIdTask>
         <Message Text=""Server ID is $(PID)"" Importance=""High"" />
 		<Message Text="":MSBuildStartupDirectory:$(MSBuildStartupDirectory):"" Importance=""high"" />
-	</Target> 
+	</Target>
 </Project>";
 
             TransientTestFile project = _env.CreateFile("testProject.proj", reportMSBuildStartupDirectoryProperty);
diff --git a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
index 49c86fc23a8..0466b7025a5 100644
--- a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
+++ b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
@@ -20,12 +20,12 @@ namespace Microsoft.Build.UnitTests
     public class ProjectSchemaValidationHandlerTest
     {
         /***********************************************************************
-         * 
+         *
          * Test:        ProjectSchemaValidationHandlerTest.VerifyProjectSchema
-         *  
+         *
          * This calls VerifyProjectSchema to validate a project file passed, where
          * the project contents are invalid
-         * 
+         *
          **********************************************************************/
         [Fact]
         public void VerifyInvalidProjectSchema()
@@ -175,12 +175,12 @@ public void VerifyInvalidSchemaItself2()
         }
 
         /***********************************************************************
-         * 
+         *
          * Test:        ProjectSchemaValidationHandlerTest.VerifyProjectSchema
-         *  
+         *
          * This calls VerifyProjectSchema to validate a project XML
          * specified in a string, where the project passed is valid
-         * 
+         *
          **********************************************************************/
         [Fact]
         public void VerifyValidProjectSchema()
@@ -207,7 +207,7 @@ public void VerifyValidProjectSchema()
 
                 // ProjectSchemaValidationHandler.VerifyProjectSchema
                 //    (
-                //    projectFilename, 
+                //    projectFilename,
                 //    msbuildTempXsdFilenames[0],
                 //    @"c:\"
                 //    );
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index ed9f0458fba..56d5b3b22d6 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -293,7 +293,7 @@ public async Task DisplayNodesOverwritesWithNewTargetFramework()
         public void TestTerminalLoggerTogetherWithOtherLoggers()
         {
             using (TestEnvironment env = TestEnvironment.Create())
-            { 
+            {
                 string contents = @"
 <Project>
     <ItemGroup>
diff --git a/src/MSBuild/MSBuildClientApp.cs b/src/MSBuild/MSBuildClientApp.cs
index de7895a6259..3bc82973b49 100644
--- a/src/MSBuild/MSBuildClientApp.cs
+++ b/src/MSBuild/MSBuildClientApp.cs
@@ -91,7 +91,7 @@ public static MSBuildApp.ExitType Execute(
                 Enum.TryParse(exitResult.MSBuildAppExitTypeString, out MSBuildApp.ExitType MSBuildAppExitType))
             {
                 // The client successfully set up a build task for MSBuild server and received the result.
-                // (Which could be a failure as well). Return the received exit type. 
+                // (Which could be a failure as well). Return the received exit type.
                 return MSBuildAppExitType;
             }
 
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs
index d8520ec4b61..73c84728846 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.CommandLine
     internal class OutOfProcTaskAppDomainWrapper : OutOfProcTaskAppDomainWrapperBase
     {
         /// <summary>
-        /// This is an extension of the OutOfProcTaskAppDomainWrapper that is responsible 
+        /// This is an extension of the OutOfProcTaskAppDomainWrapper that is responsible
         /// for activating and executing the user task.
         /// This extension provides support for ICancellable Out-Of-Proc tasks.
         /// </summary>
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index 2290f4aa7c9..2cd1b34f072 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -35,22 +35,22 @@ internal class OutOfProcTaskAppDomainWrapperBase
         /// This is an appDomain instance if any is created for running this task
         /// </summary>
         /// <comments>
-        /// TaskAppDomain's non-serializability should never be an issue since even if we start running the wrapper 
+        /// TaskAppDomain's non-serializability should never be an issue since even if we start running the wrapper
         /// in a separate appdomain, we will not be trying to load the task on one side of the serialization
-        /// boundary and run it on the other.  
+        /// boundary and run it on the other.
         /// </comments>
         [NonSerialized]
         private AppDomain _taskAppDomain;
 #endif
 
         /// <summary>
-        /// Need to keep the build engine around in order to log from the task loader. 
+        /// Need to keep the build engine around in order to log from the task loader.
         /// </summary>
         private IBuildEngine buildEngine;
 
         /// <summary>
         /// Need to keep track of the task name also so that we can log valid information
-        /// from the task loader. 
+        /// from the task loader.
         /// </summary>
         private string taskName;
 
@@ -117,7 +117,7 @@ internal OutOfProcTaskHostTaskResult ExecuteTask(
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                // If it's a TargetInvocationException, we only care about the contents of the inner exception, 
+                // If it's a TargetInvocationException, we only care about the contents of the inner exception,
                 // so just save that instead.
                 Exception exceptionToReturn = e is TargetInvocationException ? e.InnerException : e;
 
@@ -177,11 +177,11 @@ internal void CleanupTask()
 
 #if FEATURE_APARTMENT_STATE
         /// <summary>
-        /// Execute a task on the STA thread. 
+        /// Execute a task on the STA thread.
         /// </summary>
         /// <comment>
-        /// STA thread launching code lifted from XMakeBuildEngine\BackEnd\Components\RequestBuilder\TaskBuilder.cs, ExecuteTaskInSTAThread method.  
-        /// Any bug fixes made to this code, please ensure that you also fix that code.  
+        /// STA thread launching code lifted from XMakeBuildEngine\BackEnd\Components\RequestBuilder\TaskBuilder.cs, ExecuteTaskInSTAThread method.
+        /// Any bug fixes made to this code, please ensure that you also fix that code.
         /// </comment>
         private OutOfProcTaskHostTaskResult InstantiateAndExecuteTaskInSTAThread(
                 IBuildEngine oopTaskHostNode,
@@ -260,7 +260,7 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTaskInSTAThread(
 #endif
 
         /// <summary>
-        /// Do the work of actually instantiating and running the task. 
+        /// Do the work of actually instantiating and running the task.
         /// </summary>
         private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                 IBuildEngine oopTaskHostNode,
@@ -307,8 +307,8 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
             {
                 Exception exceptionToReturn = e;
 
-                // If it's a TargetInvocationException, we only care about the contents of the inner exception, 
-                // so just save that instead. 
+                // If it's a TargetInvocationException, we only care about the contents of the inner exception,
+                // so just save that instead.
                 if (e is TargetInvocationException)
                 {
                     exceptionToReturn = e.InnerException;
@@ -347,7 +347,7 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                     return new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure);
                 }
 
-                // If it didn't crash and return before now, we're clear to go ahead and execute here. 
+                // If it didn't crash and return before now, we're clear to go ahead and execute here.
                 success = wrappedTask.Execute();
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
@@ -369,9 +369,9 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                     }
                     catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                     {
-                        // If it's not a critical exception, we assume there's some sort of problem in the parameter getter -- 
-                        // so save the exception, and we'll re-throw once we're back on the main node side of the 
-                        // communications pipe.  
+                        // If it's not a critical exception, we assume there's some sort of problem in the parameter getter --
+                        // so save the exception, and we'll re-throw once we're back on the main node side of the
+                        // communications pipe.
                         finalParameterValues[value.Name] = e;
                     }
                 }
diff --git a/src/MSBuild/ProjectSchemaValidationHandler.cs b/src/MSBuild/ProjectSchemaValidationHandler.cs
index f23360f892b..73986e71b28 100644
--- a/src/MSBuild/ProjectSchemaValidationHandler.cs
+++ b/src/MSBuild/ProjectSchemaValidationHandler.cs
@@ -25,12 +25,12 @@ internal sealed class ProjectSchemaValidationHandler
         #region Methods
 
         /// <summary>
-        /// Validates a project file against the given schema.  If no schema is given, validates 
+        /// Validates a project file against the given schema.  If no schema is given, validates
         /// against the default schema
         /// </summary>
         /// <param name="projectFile">Path of the file to validate.</param>
         /// <param name="schemaFile">Can be null.</param>
-        /// <param name="binPath">Path to the framework directory where the default schema for 
+        /// <param name="binPath">Path to the framework directory where the default schema for
         /// this ToolsVersion can be found.</param>
         /// <returns>True if the project was successfully validated against the given schema, false otherwise</returns>
         internal static void VerifyProjectSchema(
@@ -48,13 +48,13 @@ internal static void VerifyProjectSchema(
 
             if (FileSystems.Default.FileExists(schemaFile))
             {
-                // Print the schema file we're using, particularly since it can vary 
+                // Print the schema file we're using, particularly since it can vary
                 // according to the toolset being used
                 Console.WriteLine(AssemblyResources.GetString("SchemaFileLocation"), schemaFile);
             }
             else
             {
-                // If we've gotten to this point, there is no schema to validate against -- just exit. 
+                // If we've gotten to this point, there is no schema to validate against -- just exit.
                 InitializationException.Throw(
                     ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SchemaNotFoundErrorWithFile", schemaFile),
                     null); /* No associated command line switch */
@@ -159,8 +159,8 @@ private void VerifyProjectSchema(
         }
 
         /// <summary>
-        /// Given the parameters passed in, if the condition is false, builds an 
-        /// error message and throws an InitializationException with that message. 
+        /// Given the parameters passed in, if the condition is false, builds an
+        /// error message and throws an InitializationException with that message.
         /// </summary>
         private static void VerifyThrowInitializationExceptionWithResource(
                  bool condition,
@@ -186,8 +186,8 @@ private static void VerifyThrowInitializationExceptionWithResource(
         }
 
         /// <summary>
-        /// Given the parameters passed in, builds an error message and throws an 
-        /// InitializationException with that message. 
+        /// Given the parameters passed in, builds an error message and throws an
+        /// InitializationException with that message.
         /// </summary>
         private static void ThrowInitializationExceptionWithResource(
                  string projectFile,
diff --git a/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs b/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs
index 44c553bef6c..b1b05998bda 100644
--- a/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs
+++ b/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs
@@ -261,7 +261,7 @@ private bool TryPeek(out T result, bool resultUsed)
         /// <summary>
         /// Provides a multi-producer, multi-consumer thread-safe bounded segment.  When the queue is full,
         /// enqueues fail and return false.  When the queue is empty, dequeues fail and return null.
-        /// These segments are linked together to form the unbounded <see cref="ConcurrentQueue{T}"/>. 
+        /// These segments are linked together to form the unbounded <see cref="ConcurrentQueue{T}"/>.
         /// </summary>
         [DebuggerDisplay("Capacity = {Capacity}")]
         private sealed class Segment
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 148cc6b1210..7873c23f9d9 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -157,7 +157,7 @@ internal LoadedType ReflectionOnlyLoad(
         /// </summary>
         private LoadedType GetLoadedType(Concurrent.ConcurrentDictionary<TypeFilter, Concurrent.ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly)
         {
-            // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which 
+            // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which
             // will map a specific AssemblyLoadInfo to a AssemblyInfoToLoadedTypes class which knows how to find a typeName in a given assembly.
             Concurrent.ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes> loadInfoToType =
                 cache.GetOrAdd(_isDesiredType, (_) => new Concurrent.ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>());
@@ -172,14 +172,14 @@ private LoadedType GetLoadedType(Concurrent.ConcurrentDictionary<TypeFilter, Con
         /// <summary>
         /// Given a type filter and an asssemblyInfo object keep track of what types in a given assembly which match the typefilter.
         /// Also, use this information to determine if a given TypeName is in the assembly which is pointed to by the AssemblyLoadInfo object.
-        /// 
+        ///
         /// This type represents a combination of a type filter and an assemblyInfo object.
         /// </summary>
         private class AssemblyInfoToLoadedTypes
         {
             /// <summary>
             /// Lock to prevent two threads from using this object at the same time.
-            /// Since we fill up internal structures with what is in the assembly 
+            /// Since we fill up internal structures with what is in the assembly
             /// </summary>
             private readonly Object _lockObject = new Object();
 
@@ -287,7 +287,7 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)
             }
 
             /// <summary>
-            /// Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on 
+            /// Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on
             /// to find tasks, loggers, and task factories.
             /// </summary>
             private void ScanAssemblyForPublicTypes()
diff --git a/src/Package/GetBinPaths.Arm64.targets b/src/Package/GetBinPaths.Arm64.targets
index c5ad5e64b8f..21a6684a86f 100644
--- a/src/Package/GetBinPaths.Arm64.targets
+++ b/src/Package/GetBinPaths.Arm64.targets
@@ -25,7 +25,7 @@
 
       <Output TaskParameter="TargetOutputs" ItemName="%(Arm64ProjectReference.OutputItemType)" />
     </MSBuild>
-    
+
     <PropertyGroup>
       <FrameworkBinPath>@(FrameworkResolvedProjectReferencePath->'%(RootDir)%(Directory)')</FrameworkBinPath>
       <Arm64BinPath>@(MSBuildArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</Arm64BinPath>
diff --git a/src/Package/GetBinPaths.targets b/src/Package/GetBinPaths.targets
index dc99cabb70d..961b4bf13d3 100644
--- a/src/Package/GetBinPaths.targets
+++ b/src/Package/GetBinPaths.targets
@@ -47,7 +47,7 @@
 
       <Output TaskParameter="TargetOutputs" ItemName="%(X64ProjectReference.OutputItemType)" />
     </MSBuild>
-    
+
     <PropertyGroup>
       <X86BinPath>@(MSBuildResolvedProjectReferencePath->'%(RootDir)%(Directory)')</X86BinPath>
       <X64BinPath>@(MSBuildX64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</X64BinPath>
diff --git a/src/Package/NuspecProject.targets b/src/Package/NuspecProject.targets
index 157e501538d..e9b94503322 100644
--- a/src/Package/NuspecProject.targets
+++ b/src/Package/NuspecProject.targets
@@ -1,7 +1,7 @@
 <Project>
 
   <!-- Common logic for projects which create a NuGet package from a .nuspec -->
-  
+
   <PropertyGroup>
     <BeforePack>$(BeforePack);SetNuspecProperties</BeforePack>
 
diff --git a/src/Samples/PortableTask/Properties/AssemblyInfo.cs b/src/Samples/PortableTask/Properties/AssemblyInfo.cs
index 574e376635c..26be3980f3c 100644
--- a/src/Samples/PortableTask/Properties/AssemblyInfo.cs
+++ b/src/Samples/PortableTask/Properties/AssemblyInfo.cs
@@ -4,7 +4,7 @@
 using System.Reflection;
 using System.Resources;
 
-// General Information about an assembly is controlled through the following 
+// General Information about an assembly is controlled through the following
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
 [assembly: AssemblyTitle("PortableTask")]
@@ -20,11 +20,11 @@
 // Version information for an assembly consists of the following four values:
 //
 //      Major Version
-//      Minor Version 
+//      Minor Version
 //      Build Number
 //      Revision
 //
-// You can specify all the values or you can default the Build and Revision Numbers 
+// You can specify all the values or you can default the Build and Revision Numbers
 // by using the '*' as shown below:
 // [assembly: AssemblyVersion("1.0.*")]
 //[assembly: AssemblyVersion("1.0.0.0")]
diff --git a/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs b/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs
index c4f85f1ed07..f0cbe537b62 100644
--- a/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs
+++ b/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs
@@ -4,7 +4,7 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 
-// General Information about an assembly is controlled through the following 
+// General Information about an assembly is controlled through the following
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
 [assembly: AssemblyTitle("TaskUsageLogger")]
@@ -16,8 +16,8 @@
 [assembly: AssemblyTrademark("")]
 [assembly: AssemblyCulture("")]
 
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
 // COM, set the ComVisible attribute to true on that type.
 [assembly: ComVisible(false)]
 
@@ -27,11 +27,11 @@
 // Version information for an assembly consists of the following four values:
 //
 //      Major Version
-//      Minor Version 
+//      Minor Version
 //      Build Number
 //      Revision
 //
-// You can specify all the values or you can default the Build and Revision Numbers 
+// You can specify all the values or you can default the Build and Revision Numbers
 // by using the '*' as shown below:
 // [assembly: AssemblyVersion("1.0.*")]
 //[assembly: AssemblyVersion("1.0.0.0")]
diff --git a/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs b/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs
index ab5fb3ba759..134bbc75c97 100644
--- a/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs
+++ b/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs
@@ -4,7 +4,7 @@
 using System.Reflection;
 using System.Resources;
 
-// General Information about an assembly is controlled through the following 
+// General Information about an assembly is controlled through the following
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
 [assembly: AssemblyTitle("TaskWithDependency")]
@@ -20,11 +20,11 @@
 // Version information for an assembly consists of the following four values:
 //
 //      Major Version
-//      Minor Version 
+//      Minor Version
 //      Build Number
 //      Revision
 //
-// You can specify all the values or you can default the Build and Revision Numbers 
+// You can specify all the values or you can default the Build and Revision Numbers
 // by using the '*' as shown below:
 // [assembly: AssemblyVersion("1.0.*")]
 //[assembly: AssemblyVersion("1.0.0.0")]
diff --git a/src/Samples/XmlFileLogger/LogProcessNode.cs b/src/Samples/XmlFileLogger/LogProcessNode.cs
index b561addd604..5dbfe143f36 100644
--- a/src/Samples/XmlFileLogger/LogProcessNode.cs
+++ b/src/Samples/XmlFileLogger/LogProcessNode.cs
@@ -11,7 +11,7 @@
 namespace Microsoft.Build.Logging.StructuredLogger
 {
     /// <summary>
-    /// Base class to represent a log node (e.g. Project, or Target) that can contain child node sub nodes 
+    /// Base class to represent a log node (e.g. Project, or Target) that can contain child node sub nodes
     /// and properties defined at that scope. Properties defined will be inherited from the parent if possible.
     /// </summary>
     internal abstract class LogProcessNode : ILogNode
@@ -153,7 +153,7 @@ protected void WriteChildren<T>(XElement parentElement) where T : ILogNode
         /// </summary>
         /// <typeparam name="T">Generic ILogNode type</typeparam>
         /// <param name="parentElement">The parent element.</param>
-        /// <param name="subNodeFactory">Delegate to create a new element to contain children. Will not be called if 
+        /// <param name="subNodeFactory">Delegate to create a new element to contain children. Will not be called if
         /// there are no children of the specified type.</param>
         protected void WriteChildren<T>(XElement parentElement, Func<XElement> subNodeFactory) where T : ILogNode
         {
diff --git a/src/Samples/XmlFileLogger/ObjectModel/Build.cs b/src/Samples/XmlFileLogger/ObjectModel/Build.cs
index 2646251675a..58687182ffb 100644
--- a/src/Samples/XmlFileLogger/ObjectModel/Build.cs
+++ b/src/Samples/XmlFileLogger/ObjectModel/Build.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Logging.StructuredLogger
     internal sealed class Build : LogProcessNode
     {
         /// <summary>
-        /// A lookup table mapping of project identifiers to project nodes (which can be nested multiple layers). 
+        /// A lookup table mapping of project identifiers to project nodes (which can be nested multiple layers).
         /// </summary>
         private readonly ConcurrentDictionary<int, Project> _projectIdToProjectMap = new ConcurrentDictionary<int, Project>();
 
@@ -93,7 +93,7 @@ public void AddTaskParameter(BuildMessageEventArgs buildMessageEventArgs, string
         }
 
         /// <summary>
-        /// Handler for a TaskCommandLine log event. Sets the command line arguments on the appropriate task. 
+        /// Handler for a TaskCommandLine log event. Sets the command line arguments on the appropriate task.
         /// </summary>
         /// <param name="taskCommandLineEventArgs">The <see cref="TaskCommandLineEventArgs"/> instance containing the event data.</param>
         public void AddCommandLine(TaskCommandLineEventArgs taskCommandLineEventArgs)
diff --git a/src/Samples/XmlFileLogger/ObjectModel/Project.cs b/src/Samples/XmlFileLogger/ObjectModel/Project.cs
index 19081d2c14b..1f419723378 100644
--- a/src/Samples/XmlFileLogger/ObjectModel/Project.cs
+++ b/src/Samples/XmlFileLogger/ObjectModel/Project.cs
@@ -23,7 +23,7 @@ internal sealed class Project : LogProcessNode
         private string _projectFile;
 
         /// <summary>
-        /// A lookup table mapping of target names to targets. 
+        /// A lookup table mapping of target names to targets.
         /// Target names are unique to a project and the id is not always specified in the log.
         /// </summary>
         private readonly ConcurrentDictionary<string, Target> _targetNameToTargetMap = new ConcurrentDictionary<string, Target>(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs b/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs
index 72ac1de6314..8d4c6f085d6 100644
--- a/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs
+++ b/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs
@@ -4,7 +4,7 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 
-// General Information about an assembly is controlled through the following 
+// General Information about an assembly is controlled through the following
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
 [assembly: AssemblyTitle("XmlFileLogger")]
@@ -16,8 +16,8 @@
 [assembly: AssemblyTrademark("")]
 [assembly: AssemblyCulture("")]
 
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
 // COM, set the ComVisible attribute to true on that type.
 [assembly: ComVisible(false)]
 
@@ -27,11 +27,11 @@
 // Version information for an assembly consists of the following four values:
 //
 //      Major Version
-//      Minor Version 
+//      Minor Version
 //      Build Number
 //      Revision
 //
-// You can specify all the values or you can default the Build and Revision Numbers 
+// You can specify all the values or you can default the Build and Revision Numbers
 // by using the '*' as shown below:
 // [assembly: AssemblyVersion("1.0.*")]
 //[assembly: AssemblyVersion("1.0.0.0")]
diff --git a/src/Samples/XmlFileLogger/PropertyBag.cs b/src/Samples/XmlFileLogger/PropertyBag.cs
index 8a99fe50b7a..8ec88b0bdcc 100644
--- a/src/Samples/XmlFileLogger/PropertyBag.cs
+++ b/src/Samples/XmlFileLogger/PropertyBag.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.Logging.StructuredLogger
     /// <summary>
     /// This class encapsulates functionality for a collection of properties (name value pairs) in a
     /// hierarchical way. (e.g. if the parameter is defined and identical in the parent, it is not
-    /// stored in this instance). 
+    /// stored in this instance).
     /// </summary>
     internal sealed class PropertyBag
     {
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index 11e6f4bef30..6820a134454 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -18,17 +18,17 @@ namespace Microsoft.Build.Shared
     ///
     /// This is the normal schema:
     ///
-    ///  [HKLM | HKCU]\SOFTWARE\MICROSOFT\.NetFramework\ 
-    ///    v1.0.3705 
-    ///      AssemblyFoldersEx 
-    ///          Infragistics.GridControl.1.0:  
-    ///              @Default = c:\program files\infragistics\grid control\1.0\bin 
-    ///              @Description = Infragistics Grid Control for .NET version 1.0 
-    ///              9466 
-    ///                  @Default = c:\program files\infragistics\grid control\1.0sp1\bin 
-    ///                  @Description = SP1 for Infragistics Grid Control for .NET version 1.0 
+    ///  [HKLM | HKCU]\SOFTWARE\MICROSOFT\.NetFramework\
+    ///    v1.0.3705
+    ///      AssemblyFoldersEx
+    ///          Infragistics.GridControl.1.0:
+    ///              @Default = c:\program files\infragistics\grid control\1.0\bin
+    ///              @Description = Infragistics Grid Control for .NET version 1.0
+    ///              9466
+    ///                  @Default = c:\program files\infragistics\grid control\1.0sp1\bin
+    ///                  @Description = SP1 for Infragistics Grid Control for .NET version 1.0
+    ///
     ///
-    /// 
     /// The root registry path is the following:
     ///
     ///     [HKLM | HKCU]\{AssemblyFoldersBase}\{RuntimeVersion}\{AssemblyFoldersSuffix}
@@ -91,10 +91,10 @@ internal AssemblyFoldersEx(
             *                First, look in 64 bit registry location
             *                Second, look in 32 bit registry location
             *            Targeting X86 or MSIL:
-            *                First,  look in the 32 bit hive 
+            *                First,  look in the 32 bit hive
             *                Second, look in 64 bit hive
             *
-            *  32 bit OS:           
+            *  32 bit OS:
             *        32 bit process:
             *            Targeting 64 bit, or X86, or MSIL:
             *                Look in the default registry which is the 32 bit hive
@@ -317,29 +317,29 @@ private bool IsVersionInsideRange(Version v, RegistryKey keyPlatform)
         /// <summary>
         ///  The algorithm for gathering versions from the registry is as follows:
         ///     1) targetRuntimeVersion is the target framework version you are targeting
-        ///     2) versions is a string list from reading the registry, this list is in what ever order the registry returns 
+        ///     2) versions is a string list from reading the registry, this list is in what ever order the registry returns
         ///        the keys to us in, this is usually alphabetical.
-        ///     
+        ///
         ///     We will go through each version string and do the following:
         ///         1) Check to see if the string is a version
         ///             If the string is not a version we will check to see if the string starts with the framework we are targeting,
-        ///             if it does we will add it to a list which will be added at the end 
+        ///             if it does we will add it to a list which will be added at the end
         ///             of the versions list, if not it gets ignored. We do this to stay compatible to what we have been doing since whidbey.
-        ///             
+        ///
         ///             If the string is a version
-        ///                 We check to see if the version is a valid target framework version. Meaning.  It has a Maj.Minor version and may have 
+        ///                 We check to see if the version is a valid target framework version. Meaning.  It has a Maj.Minor version and may have
         ///                 build, Build is less than or equal to 255 and there is no revision. The reason the build number needs to be less than 255 is because
-        ///                 255 is the largest build number for a target framework version that visual studio 2010 supports. The build number is supposed to 
+        ///                 255 is the largest build number for a target framework version that visual studio 2010 supports. The build number is supposed to
         ///                 represent a service pack on the 4.0 framework.
-        ///                 
-        ///                 If the string is a valid target framework version we check to see we already have a dictionary entry and if not we 
-        ///                 add one. 
+        ///
+        ///                 If the string is a valid target framework version we check to see we already have a dictionary entry and if not we
+        ///                 add one.
         ///                 If the string is not a valid target framework then we will ignore the part of the version which makes it invalid
         ///                 (either the build or the revision, or both) and see where that version would fit in the dictionary as a key and
         ///                 then put the original version string into the list for that entry.
-        ///                 
+        ///
         ///         Since the dictionary is sorted in reverse order to generate the list to return we do the following:
-        ///         Go through the list of dictionary entries 
+        ///         Go through the list of dictionary entries
         ///             For each entry sort the list in reverse alphabetical order and add the entries in their internal list to the listToreturn.
         ///
         ///         This way we have a reverse sorted list of all of the version keys.
@@ -350,17 +350,17 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
             Version targetVersion = VersionUtilities.ConvertToVersion(targetRuntimeVersion);
             List<ExtensionFoldersRegistryKey> versionStrings = new List<ExtensionFoldersRegistryKey>();
 
-            // This dictionary will contain a set of target framework versions and a list of strings read from the registry which are supposed to be treated like the 
-            // target framework version stored as the key. 
+            // This dictionary will contain a set of target framework versions and a list of strings read from the registry which are supposed to be treated like the
+            // target framework version stored as the key.
             // For example:
-            //  If the target framework version is 4.0  but the registry string is v4.0.2116 then we want to treat v4.0.2116 as if it was v4.0 during the sort, 
+            //  If the target framework version is 4.0  but the registry string is v4.0.2116 then we want to treat v4.0.2116 as if it was v4.0 during the sort,
             // but when reading out of the registry
             //  we need to know the original value so we can open the correct key.
             //
-            //  The reason there needs to be a list for each target framework version is that there could be multiple keys in the registry which should be treated 
+            //  The reason there needs to be a list for each target framework version is that there could be multiple keys in the registry which should be treated
             // like v4.0 for sorting.
             //  for example lets say we had the following entries in the registry:
-            //       4.0.2116  and 4.0.2116.87  both of these are supposed to be treated like v4.0 because they are not valid target framework versions but 
+            //       4.0.2116  and 4.0.2116.87  both of these are supposed to be treated like v4.0 because they are not valid target framework versions but
             // are valid version numbers and should be searched when we are targeting 4.0.
             SortedDictionary<Version, List<string>> targetFrameworkVersionToRegistryVersions = new SortedDictionary<Version, List<string>>(ReverseVersionGenericComparer.Comparer);
 
@@ -382,7 +382,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
                     }
                     else
                     {
-                        // To be added to our dictionary our candidate version from the registry must be a valid target framework version which is less than or equal 
+                        // To be added to our dictionary our candidate version from the registry must be a valid target framework version which is less than or equal
                         // to the target version. Therefore if the candidate version is not a valid target framework version we will pretend it is and sort it in its correct form.
 
                         Version replacementVersion;
@@ -402,7 +402,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
                             replacementVersion = candidateVersion;
                         }
 
-                        // If the target version is null then we need to do a partial version match 
+                        // If the target version is null then we need to do a partial version match
                         bool addToListDueToPartialNameMatch = false;
                         if (targetVersion == null)
                         {
@@ -439,7 +439,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
                 }
             }
 
-            // The additional tolerated keys are added onto the end of the versions list in what ever order they came from the 
+            // The additional tolerated keys are added onto the end of the versions list in what ever order they came from the
             // registry in.
             foreach (string key in additionalToleratedKeys)
             {
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index c63b0ff90a1..f29b9e8e443 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -193,7 +193,7 @@ internal static AssemblyNameExtension GetAssemblyNameEx(string path)
             {
                 // Its pretty hard to get here, you need an assembly that contains a valid reference
                 // to a dependent assembly that, in turn, throws a FileLoadException during GetAssemblyName.
-                // Still it happened once, with an older version of the CLR. 
+                // Still it happened once, with an older version of the CLR.
             }
             catch (FileNotFoundException)
             {
@@ -483,7 +483,7 @@ internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag
         /// <returns></returns>
         internal new int GetHashCode()
         {
-            // Ok, so this isn't a great hashing algorithm. However, basenames with different 
+            // Ok, so this isn't a great hashing algorithm. However, basenames with different
             // versions or PKTs are relatively uncommon and so collisions should be low.
             // Hashing on FullName is wrong because the order of tuple fields is undefined.
             int hash = StringComparer.OrdinalIgnoreCase.GetHashCode(this.Name);
diff --git a/src/Shared/AssemblyNameReverseVersionComparer.cs b/src/Shared/AssemblyNameReverseVersionComparer.cs
index 4d4ad07c589..3265413e089 100644
--- a/src/Shared/AssemblyNameReverseVersionComparer.cs
+++ b/src/Shared/AssemblyNameReverseVersionComparer.cs
@@ -19,10 +19,10 @@ internal sealed class AssemblyNameReverseVersionComparer : IComparer<AssemblyNam
 
         /// <summary>
         /// Compare x and y by version only.
-        /// 
+        ///
         /// Change the return value to sort the values in reverse order.
-        /// 
-        /// If x is greater than y  return -1 indicating x is less than y. 
+        ///
+        /// If x is greater than y  return -1 indicating x is less than y.
         /// If x is less than y  return 1 indicating x is greater than  y.
         /// If x and y are equal return 0.
         /// </summary>
diff --git a/src/Shared/AwaitExtensions.cs b/src/Shared/AwaitExtensions.cs
index c6280524b0a..72e14fda550 100644
--- a/src/Shared/AwaitExtensions.cs
+++ b/src/Shared/AwaitExtensions.cs
@@ -147,7 +147,7 @@ internal static Task<int> ToTask(this WaitHandle[] handles, int timeout = Timeou
         }
 
         /// <summary>
-        /// A class which acts as a task scheduler and ensures each scheduled task gets its 
+        /// A class which acts as a task scheduler and ensures each scheduled task gets its
         /// own STA thread.
         /// </summary>
         private class OneSTAThreadPerTaskScheduler : TaskScheduler
diff --git a/src/Shared/BuildEventFileInfo.cs b/src/Shared/BuildEventFileInfo.cs
index 33cb0d694cc..050a48d88c5 100644
--- a/src/Shared/BuildEventFileInfo.cs
+++ b/src/Shared/BuildEventFileInfo.cs
@@ -23,7 +23,7 @@ internal sealed class BuildEventFileInfo
         /// Filename may be an empty string, if there is truly no file associated.
         /// This overload may also be used if there is a file but truly no line/column,
         /// for example when failing to load a project file.
-        /// 
+        ///
         /// IF AN IELEMENTLOCATION IS AVAILABLE, USE THE OVERLOAD ACCEPTING THAT INSTEAD.
         /// </summary>
         /// <param name="file"></param>
@@ -46,7 +46,7 @@ internal BuildEventFileInfo(IElementLocation location)
 
         /// <summary>
         /// Creates an instance of this class using the given filename/path and a line/column of interest in the file.
-        /// 
+        ///
         /// IF AN IELEMENTLOCATION IS AVAILABLE, USE THE OVERLOAD ACCEPTING THAT INSTEAD.
         /// </summary>
         /// <param name="file"></param>
@@ -60,7 +60,7 @@ internal BuildEventFileInfo(string file, int line, int column)
 
         /// <summary>
         /// Creates an instance of this class using the given filename/path and a range of lines/columns of interest in the file.
-        /// 
+        ///
         /// IF AN IELEMENTLOCATION IS AVAILABLE, USE THE OVERLOAD ACCEPTING THAT INSTEAD.
         /// </summary>
         /// <param name="file"></param>
diff --git a/src/Shared/CollectionHelpers.cs b/src/Shared/CollectionHelpers.cs
index e88ef106fc6..17265682d2a 100644
--- a/src/Shared/CollectionHelpers.cs
+++ b/src/Shared/CollectionHelpers.cs
@@ -36,7 +36,7 @@ internal static List<T> RemoveNulls<T>(List<T> inputs)
         }
 
         /// <summary>
-        /// Extension method -- combines a TryGet with a check to see that the value is equal. 
+        /// Extension method -- combines a TryGet with a check to see that the value is equal.
         /// </summary>
         internal static bool ContainsValueAndIsEqual(this Dictionary<string, string> dictionary, string key, string value, StringComparison comparer)
         {
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 73d009c2f01..10bdc82790e 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -12,12 +12,12 @@ namespace Microsoft.Build.Shared
 {
     /// <summary>
     /// This class contains only static methods, which are useful throughout many
-    /// of the MSBuild classes and don't really belong in any specific class.   
+    /// of the MSBuild classes and don't really belong in any specific class.
     /// </summary>
     internal static class ConversionUtilities
     {
         /// <summary>
-        /// Converts a string to a bool.  We consider "true/false", "on/off", and 
+        /// Converts a string to a bool.  We consider "true/false", "on/off", and
         /// "yes/no" to be valid boolean representations in the XML.
         /// </summary>
         /// <param name="parameterValue">The string to convert.</param>
diff --git a/src/Shared/FileSystem/WindowsNative.cs b/src/Shared/FileSystem/WindowsNative.cs
index 8df4a0b2a2c..5bf3f713c17 100644
--- a/src/Shared/FileSystem/WindowsNative.cs
+++ b/src/Shared/FileSystem/WindowsNative.cs
@@ -71,7 +71,7 @@ public static class DwFlags
             public const int PmsfMultiple = 0x1;
 
             /// <summary>
-            /// If PMSF_NORMAL is used, ignore leading spaces in the string pointed to by pszSpec. If PMSF_MULTIPLE is used, 
+            /// If PMSF_NORMAL is used, ignore leading spaces in the string pointed to by pszSpec. If PMSF_MULTIPLE is used,
             /// ignore leading spaces in each file type contained in the string pointed to by pszSpec. This flag can be combined with PMSF_NORMAL and PMSF_MULTIPLE.
             /// </summary>
             public const int PmsfDontStripSpaces = 0x00010000;
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index 650942be1e5..76e283a1a2a 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -10,7 +10,7 @@ namespace Microsoft.Build.Shared
     /// <summary>
     /// This class contains utility methods for file IO.
     /// Separate from FileUtilities because some assemblies may only need the patterns.
-    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in 
+    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in
     /// each class get pulled into the resulting assembly.
     /// </summary>
     internal static class FileUtilitiesRegex
diff --git a/src/Shared/INodeEndpoint.cs b/src/Shared/INodeEndpoint.cs
index 024dee437dc..373250acce2 100644
--- a/src/Shared/INodeEndpoint.cs
+++ b/src/Shared/INodeEndpoint.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BackEnd
     internal delegate void LinkStatusChangedDelegate(INodeEndpoint endpoint, LinkStatus status);
 
     /// <summary>
-    /// Used to receive data from a node 
+    /// Used to receive data from a node
     /// </summary>
     /// <param name="endpoint">The endpoint invoking the delegate.</param>
     /// <param name="packet">The packet received.</param>
@@ -34,7 +34,7 @@ internal enum LinkStatus
         Inactive,
 
         /// <summary>
-        /// The connection is active, the most recent data has been successfully sent, and the 
+        /// The connection is active, the most recent data has been successfully sent, and the
         /// node is responding to pings.
         /// </summary>
         Active,
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index 52d335944af..42b6a8d6ab6 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -15,7 +15,7 @@ internal enum NodePacketType : byte
         /// Notifies the Node to set a configuration for a particular build.  This is sent before
         /// any BuildRequests are made and will not be sent again for a particular build.  This instructs
         /// the node to prepare to receive build requests.
-        /// 
+        ///
         /// Contains:
         /// Build ID
         /// Environment variables
@@ -30,11 +30,11 @@ internal enum NodePacketType : byte
         NodeConfiguration,
 
         /// <summary>
-        /// A BuildRequestConfiguration object.  
+        /// A BuildRequestConfiguration object.
         /// When sent TO a node, this informs the node of a build configuration.
         /// When sent FROM a node, this requests a BuildRequestConfigurationResponse to map the configuration to the
         /// appropriate global configuration ID.
-        /// 
+        ///
         /// Contents:
         /// Configuration ID
         /// Project Filename
@@ -45,7 +45,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// A response to a request to map a build configuration
-        /// 
+        ///
         /// Contents:
         /// Node Configuration ID
         /// Global Configuration ID
@@ -54,7 +54,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// Information about a project that has been loaded by a node.
-        /// 
+        ///
         /// Contents:
         /// Global Configuration ID
         /// Initial Targets
@@ -64,7 +64,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// Packet used to inform the scheduler that a node's active build request is blocked.
-        /// 
+        ///
         /// Contents:
         /// Build Request ID
         /// Active Targets
@@ -75,7 +75,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// Packet used to unblocked a blocked request on a node.
-        /// 
+        ///
         /// Contents:
         /// Build Request ID
         /// Build Results for child requests, if any.
@@ -84,7 +84,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// A BuildRequest object
-        /// 
+        ///
         /// Contents:
         /// Build Request ID
         /// Configuration ID
@@ -95,7 +95,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// A BuildResult object
-        /// 
+        ///
         /// Contents:
         /// Build ID
         /// Project Instance ID
@@ -107,7 +107,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// A logging message.
-        /// 
+        ///
         /// Contents:
         /// Build Event Type
         /// Build Event Args
@@ -115,8 +115,8 @@ internal enum NodePacketType : byte
         LogMessage,
 
         /// <summary>
-        /// Informs the node that the build is complete.  
-        /// 
+        /// Informs the node that the build is complete.
+        ///
         /// Contents:
         /// Prepare For Reuse
         /// </summary>
@@ -125,21 +125,21 @@ internal enum NodePacketType : byte
         /// <summary>
         /// Reported by the node (or node provider) when a node has terminated.  This is the final packet that will be received
         /// from a node.
-        /// 
+        ///
         /// Contents:
         /// Reason
         /// </summary>
         NodeShutdown,
 
         /// <summary>
-        /// Notifies the task host to set the task-specific configuration for a particular task execution. 
+        /// Notifies the task host to set the task-specific configuration for a particular task execution.
         /// This is sent in place of NodeConfiguration and gives the task host all the information it needs
-        /// to set itself up and execute the task that matches this particular configuration. 
-        /// 
+        /// to set itself up and execute the task that matches this particular configuration.
+        ///
         /// Contains:
-        /// Node ID (of parent MSBuild node, to make the logging work out) 
+        /// Node ID (of parent MSBuild node, to make the logging work out)
         /// Startup directory
-        /// Environment variables 
+        /// Environment variables
         /// UI Culture information
         /// App Domain Configuration XML
         /// Task name
@@ -149,12 +149,12 @@ internal enum NodePacketType : byte
         TaskHostConfiguration,
 
         /// <summary>
-        /// Informs the parent node that the task host has finished executing a 
-        /// particular task.  Does not need to contain identifying information 
-        /// about the task, because the task host will only ever be connected to 
-        /// one parent node at a a time, and will only ever be executing one task 
-        /// for that node at any one time.  
-        /// 
+        /// Informs the parent node that the task host has finished executing a
+        /// particular task.  Does not need to contain identifying information
+        /// about the task, because the task host will only ever be connected to
+        /// one parent node at a a time, and will only ever be executing one task
+        /// for that node at any one time.
+        ///
         /// Contents:
         /// Task result (success / failure)
         /// Resultant parameter values (for output gathering)
@@ -162,11 +162,11 @@ internal enum NodePacketType : byte
         TaskHostTaskComplete,
 
         /// <summary>
-        /// Message sent from the node to its paired task host when a task that 
-        /// supports ICancellableTask is cancelled.  
-        /// 
+        /// Message sent from the node to its paired task host when a task that
+        /// supports ICancellableTask is cancelled.
+        ///
         /// Contents:
-        /// (nothing) 
+        /// (nothing)
         /// </summary>
         TaskHostTaskCancelled,
 
@@ -213,13 +213,13 @@ internal enum NodePacketType : byte
         ServerNodeBuildResult = 0xF1,
 
         /// <summary>
-        /// Info about server console activity. 
+        /// Info about server console activity.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
         /// </summary>
         ServerNodeConsoleWrite = 0xF2,
 
         /// <summary>
-        /// Command to cancel ongoing build. 
+        /// Command to cancel ongoing build.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
         /// </summary>
         ServerNodeBuildCancel = 0xF3,
diff --git a/src/Shared/InprocTrackingNativeMethods.cs b/src/Shared/InprocTrackingNativeMethods.cs
index 493c4f68490..fd8293d841d 100644
--- a/src/Shared/InprocTrackingNativeMethods.cs
+++ b/src/Shared/InprocTrackingNativeMethods.cs
@@ -199,7 +199,7 @@ private static class FileTrackerDllStub
             #region Initialization code
 
             /// <summary>
-            /// Loads FileTracker.dll into a handle that we can use subsequently to grab the exported methods we're interested in. 
+            /// Loads FileTracker.dll into a handle that we can use subsequently to grab the exported methods we're interested in.
             /// </summary>
             private static void LoadFileTrackerDll()
             {
@@ -227,8 +227,8 @@ private static void LoadFileTrackerDll()
             }
 
             /// <summary>
-            /// Generic code to grab the function pointer for a function exported by FileTracker.dll, given 
-            /// that function's name, and transform that function pointer into a callable delegate. 
+            /// Generic code to grab the function pointer for a function exported by FileTracker.dll, given
+            /// that function's name, and transform that function pointer into a callable delegate.
             /// </summary>
             [SecurityCritical]
             private static DT CreateDelegate<DT>(String entryPointName)
@@ -244,7 +244,7 @@ private static DT CreateDelegate<DT>(String entryPointName)
             }
 
             /// <summary>
-            /// Actually generate all of the delegates that will be called by our public (or rather, internal) surface area methods.  
+            /// Actually generate all of the delegates that will be called by our public (or rather, internal) surface area methods.
             /// </summary>
             private static void InitDelegates()
             {
@@ -264,7 +264,7 @@ private static void InitDelegates()
 
             /// <summary>
             /// Static constructor -- generates the delegates for all of the export methods from
-            /// FileTracker.dll that we care about. 
+            /// FileTracker.dll that we care about.
             /// </summary>
             [SecuritySafeCritical]
             static FileTrackerDllStub()
@@ -275,7 +275,7 @@ static FileTrackerDllStub()
 
             #endregion  // Initialization code
 #pragma warning restore format
-            // Specialized handle to make sure we free FileTracker.dll 
+            // Specialized handle to make sure we free FileTracker.dll
             [SecurityCritical]
             private class SafeLibraryHandle : SafeHandle
             {
@@ -296,8 +296,8 @@ public override bool IsInvalid
                 [SecurityCritical]
                 protected override bool ReleaseHandle()
                 {
-                    // FileTracker expects to continue to exist even through ExitProcess -- if we forcibly unload it now, 
-                    // bad things can happen when the CLR attempts to call the (still detoured?) ExitProcess.  
+                    // FileTracker expects to continue to exist even through ExitProcess -- if we forcibly unload it now,
+                    // bad things can happen when the CLR attempts to call the (still detoured?) ExitProcess.
                     return true;
                 }
             }  // private class SafeLibraryHandle
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 8513d60cee5..307cc68bdc9 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -117,10 +117,10 @@ public override String ReadString()
                         int length = (int)memoryStream.Length;
                         n = (rawPosition + readLength) < length ? readLength : length - rawPosition;
 
-                        // Attempt to track down an intermittent failure -- n should not ever be negative, but 
-                        // we're occasionally seeing it when we do the decoder.GetChars below -- by providing 
+                        // Attempt to track down an intermittent failure -- n should not ever be negative, but
+                        // we're occasionally seeing it when we do the decoder.GetChars below -- by providing
                         // a bit more information when we do hit the error, in the place where (by code inspection)
-                        // the actual error seems most likely to be occurring. 
+                        // the actual error seems most likely to be occurring.
                         if (n < 0)
                         {
                             ErrorUtilities.ThrowInternalError("From calculating based on the memorystream, about to read n = {0}. length = {1}, rawPosition = {2}, readLength = {3}, stringLength = {4}, currPos = {5}.", n, length, rawPosition, readLength, stringLength, currPos);
@@ -201,7 +201,7 @@ internal static BinaryReaderFactory CreateSharedBuffer()
         /// </summary>
         /// <remarks>
         /// Lifetime of the pooled buffer is managed by InterningBinaryReader (tied to BinaryReader lifetime wrapping the buffer)
-        /// </remarks> 
+        /// </remarks>
         internal static BinaryReaderFactory PoolingBuffer => NullBuffer.Instance;
 
         /// <summary>
@@ -251,7 +251,7 @@ private static BinaryReader Create(Stream stream, BinaryReaderFactory sharedBuff
         }
 
         /// <summary>
-        /// Holds thepreallocated buffer. 
+        /// Holds thepreallocated buffer.
         /// </summary>
         private class Buffer : BinaryReaderFactory
         {
diff --git a/src/Shared/LanguageParser/CSharptokenCharReader.cs b/src/Shared/LanguageParser/CSharptokenCharReader.cs
index 9b3d77a6525..ebbb6163b29 100644
--- a/src/Shared/LanguageParser/CSharptokenCharReader.cs
+++ b/src/Shared/LanguageParser/CSharptokenCharReader.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Shared.LanguageParser
     /*
      * Class:   CSharpTokenCharReader
      *
-     * Reads over the contents of a C# source file (in the form of a string). 
+     * Reads over the contents of a C# source file (in the form of a string).
      * Provides utility functions for dealing with C#-specific tokens.
      *
      */
@@ -19,7 +19,7 @@ internal sealed class CSharpTokenCharReader : TokenCharReader
     {
         /*
          * Method:  CSharpTokenCharReader
-         * 
+         *
          * Construct
          */
         internal CSharpTokenCharReader(Stream binaryStream, bool forceANSI)
@@ -29,8 +29,8 @@ internal CSharpTokenCharReader(Stream binaryStream, bool forceANSI)
 
         /*
          * Method:  SinkLongIntegerSuffix
-         * 
-         * Skip C# integer literal long suffix: L, U, l, u, ul, etc.                    
+         *
+         * Skip C# integer literal long suffix: L, U, l, u, ul, etc.
          */
         internal bool SinkLongIntegerSuffix()
         {
@@ -57,7 +57,7 @@ internal bool SinkLongIntegerSuffix()
 
         /*
          * Method:  SinkOperatorOrPunctuator
-         * 
+         *
          * Determine whether this is a C# operator or punctuator
          */
         internal bool SinkOperatorOrPunctuator()
@@ -73,7 +73,7 @@ internal bool SinkOperatorOrPunctuator()
 
         /*
          * Method:  SinkStringEscape
-         * 
+         *
          * Determine whether this is a valid escape character for strings?
          */
         internal bool SinkStringEscape()
@@ -102,7 +102,7 @@ internal bool SinkStringEscape()
 
         /*
          * Method:  MatchRegularStringLiteral
-         * 
+         *
          * Determine whether this is a regular C# string literal character
          */
         internal bool MatchRegularStringLiteral()
@@ -117,7 +117,7 @@ internal bool MatchRegularStringLiteral()
 
         /*
          * Method:  SinkMultipleWhiteSpace
-         * 
+         *
          * Sink some C# whitespace
          */
         internal bool SinkMultipleWhiteSpace()
diff --git a/src/Shared/LanguageParser/CSharptokenEnumerator.cs b/src/Shared/LanguageParser/CSharptokenEnumerator.cs
index 1e3e70f5c03..c9937439716 100644
--- a/src/Shared/LanguageParser/CSharptokenEnumerator.cs
+++ b/src/Shared/LanguageParser/CSharptokenEnumerator.cs
@@ -22,7 +22,7 @@ internal sealed class CSharpTokenEnumerator : TokenEnumerator
 
         /*
         * Method:  TokenEnumerator
-        * 
+        *
         * Construct
         */
         internal CSharpTokenEnumerator(Stream binaryStream, bool forceANSI)
@@ -32,7 +32,7 @@ internal CSharpTokenEnumerator(Stream binaryStream, bool forceANSI)
 
         /*
         * Method:  FindNextToken
-        * 
+        *
         * Find the next token. Return 'true' if one was found. False, otherwise.
         */
         internal override bool FindNextToken()
@@ -77,14 +77,14 @@ internal override bool FindNextToken()
                 {
                     if (_reader.Sink("\\"))
                     {
-                        /* reader.Skip the escape sequence. 
+                        /* reader.Skip the escape sequence.
                             This isn't exactly right. We should detect:
-                            
-                            simple-escape-sequence: one of 
-                            \' \" \\ \0 \a \b \f \n \r \t \v 
-                            
-                            hexadecimal-escape-sequence: 
-                            \x   hex-digit   hex-digit[opt]   hex-digit[opt]  hex-digit[opt]                                
+
+                            simple-escape-sequence: one of
+                            \' \" \\ \0 \a \b \f \n \r \t \v
+
+                            hexadecimal-escape-sequence:
+                            \x   hex-digit   hex-digit[opt]   hex-digit[opt]  hex-digit[opt]
                         */
                     }
 
@@ -110,7 +110,7 @@ internal override bool FindNextToken()
                 }
                 while (!_reader.EndOfLines && _reader.SinkCharacter() != '\"');
 
-                // Can't end a file inside a string 
+                // Can't end a file inside a string
                 if (_reader.EndOfLines)
                 {
                     current = new EndOfFileInsideStringToken();
@@ -134,12 +134,12 @@ internal override bool FindNextToken()
                         if (_reader.SinkStringEscape())
                         {
                             // This isn't nearly right. We just do barely enough to make a string
-                            // with an embedded escape sequence return _some_ string whose start and 
+                            // with an embedded escape sequence return _some_ string whose start and
                             // end match the real bounds of the string.
                         }
                         else
                         {
-                            // This is a compiler error. 
+                            // This is a compiler error.
                             _reader.SinkCharacter();
                             current = new CSharpTokenizer.UnrecognizedStringEscapeToken();
                             return true;
@@ -181,7 +181,7 @@ internal override bool FindNextToken()
                     return true;
                 }
 
-                // Sink the rest of the identifier.                     
+                // Sink the rest of the identifier.
                 while (_reader.SinkIdentifierPart())
                 {
                 }
@@ -241,7 +241,7 @@ internal override bool FindNextToken()
                     return true;
                 }
 
-                // Skip the L, U, l, u, ul, etc.                    
+                // Skip the L, U, l, u, ul, etc.
                 _reader.SinkLongIntegerSuffix();
 
                 current = new HexIntegerLiteralToken();
@@ -250,7 +250,7 @@ internal override bool FindNextToken()
             // Decimal integer literal
             else if (_reader.SinkMultipleDecimalDigits())
             {
-                // reader.Skip the L, U, l, u, ul, etc.                    
+                // reader.Skip the L, U, l, u, ul, etc.
                 _reader.SinkLongIntegerSuffix();
 
                 current = new DecimalIntegerLiteralToken();
@@ -283,7 +283,7 @@ internal override bool FindNextToken()
                 return true;
             }
 
-            // We didn't recognize the token, so this is a syntax error. 
+            // We didn't recognize the token, so this is a syntax error.
             _reader.SinkCharacter();
             current = new UnrecognizedToken();
             return true;
@@ -310,7 +310,7 @@ internal override bool FindNextToken()
 
         /*
         * Method:  Reader
-        * 
+        *
         * Return the token char reader.
         */
         internal override TokenCharReader Reader
diff --git a/src/Shared/LanguageParser/CSharptokenizer.cs b/src/Shared/LanguageParser/CSharptokenizer.cs
index 06519da0616..c3a00a698ef 100644
--- a/src/Shared/LanguageParser/CSharptokenizer.cs
+++ b/src/Shared/LanguageParser/CSharptokenizer.cs
@@ -51,7 +51,7 @@ internal CSharpTokenizer(Stream binaryStream, bool forceANSI)
 
         /*
          * Method:  GetEnumerator
-         * 
+         *
          * Return a new token enumerator.
          */
         public IEnumerator GetEnumerator()
diff --git a/src/Shared/LanguageParser/StreamMappedString.cs b/src/Shared/LanguageParser/StreamMappedString.cs
index c4cfd631df9..8b41bba6e84 100644
--- a/src/Shared/LanguageParser/StreamMappedString.cs
+++ b/src/Shared/LanguageParser/StreamMappedString.cs
@@ -25,7 +25,7 @@ internal sealed class StreamMappedString
         private StreamReader _reader;
 
         /// <summary>
-        /// When false, try to guess the encoding of binaryStream. When true, force the 
+        /// When false, try to guess the encoding of binaryStream. When true, force the
         /// encoding to ANSI.
         /// </summary>
         private bool _forceANSI;
@@ -110,7 +110,7 @@ private void RestartReader()
                 _reader = new StreamReader( // HIGHCHAR: Falling back to ANSI for VB source files.
                     _binaryStream,
 #if FEATURE_ENCODING_DEFAULT
-                    Encoding.Default,    // Default means ANSI. 
+                    Encoding.Default,    // Default means ANSI.
 #else
                     Encoding.ASCII,
 #endif
diff --git a/src/Shared/LanguageParser/VisualBasictokenCharReader.cs b/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
index 63d10a29c91..e493c4c32ed 100644
--- a/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
+++ b/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Shared.LanguageParser
     /*
      * Class:   VisualBasicTokenCharReader
      *
-     * Reads over the contents of a vb source file (in the form of a string). 
+     * Reads over the contents of a vb source file (in the form of a string).
      * Provides utility functions for dealing with VB-specific tokens.
      *
      */
@@ -19,7 +19,7 @@ internal sealed class VisualBasicTokenCharReader : TokenCharReader
     {
         /*
          * Method:  VisualBasicTokenCharReader
-         * 
+         *
          * Construct
          */
         internal VisualBasicTokenCharReader(Stream binaryStream, bool forceANSI)
@@ -29,7 +29,7 @@ internal VisualBasicTokenCharReader(Stream binaryStream, bool forceANSI)
 
         /*
          * Method:  SinkSeparatorCharacter
-         * 
+         *
          * Matches a vb separator character.
          */
         internal bool SinkSeparatorCharacter()
@@ -55,7 +55,7 @@ internal bool SinkSeparatorCharacter()
 
         /*
          * Method:  SinkLineContinuationCharacter
-         * 
+         *
          * Matches a vb line continuation character.
          */
         internal bool SinkLineContinuationCharacter()
@@ -73,7 +73,7 @@ internal bool SinkLineContinuationCharacter()
 
         /*
          * Method:  SinkLineCommentStart
-         * 
+         *
          * Matches a vb start of comment indicator
          */
         internal bool SinkLineCommentStart()
@@ -103,7 +103,7 @@ internal bool SinkLineCommentStart()
 
         /*
          * Method:  SinkHexIntegerPrefix
-         * 
+         *
          * Matches a vb hex integer prefix
          */
         internal bool SinkHexIntegerPrefix()
@@ -118,7 +118,7 @@ internal bool SinkHexIntegerPrefix()
 
         /*
          * Method:  SinkOctalIntegerPrefix
-         * 
+         *
          * Matches a vb octal integer prefix
          */
         internal bool SinkOctalIntegerPrefix()
@@ -133,7 +133,7 @@ internal bool SinkOctalIntegerPrefix()
 
         /*
          * Method:  SinkWhiteSpace
-         * 
+         *
          * Sink a single whitespace character.
          * In vb, newlines are not considered whitespace.
          */
@@ -149,7 +149,7 @@ internal bool SinkWhiteSpace()
 
         /*
          * Method:  SinkIntegerSuffix
-         * 
+         *
          * Sink a vb integer suffix.
          */
         internal bool SinkIntegerSuffix()
@@ -170,7 +170,7 @@ internal bool SinkIntegerSuffix()
 
         /*
          * Method:  SinkDecimalIntegerSuffix
-         * 
+         *
          * Sink a vb decimal integer suffix.
          * Couldn't find this documented anywhere, but a decimal (as opposed to hex or octal)
          * is also allowed a trailing '@', '!', '#' or '&'
@@ -200,7 +200,7 @@ internal bool SinkDecimalIntegerSuffix()
 
         /*
          * Method:  SinkOctalDigits
-         * 
+         *
          * Sink multiple octal digits.
          */
         internal bool SinkMultipleOctalDigits()
@@ -211,12 +211,12 @@ internal bool SinkMultipleOctalDigits()
                 ++count;
                 Skip();
             }
-            return count > 0;     // Must match at least one  
+            return count > 0;     // Must match at least one
         }
 
         /*
          * Method:  SinkOperator
-         * 
+         *
          * Determine whether this is a vb operator.
          */
         internal bool SinkOperator()
@@ -232,7 +232,7 @@ internal bool SinkOperator()
 
         /*
          * Method:  SinkTypeCharacter
-         * 
+         *
          * Identifiers in vb can end with a special character to indicate type:
          *   IntegerTypeCharacter ::= %
          *   LongTypeCharacter ::= &
diff --git a/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs b/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs
index 589f4ae3707..0752bb5549f 100644
--- a/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs
+++ b/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs
@@ -21,7 +21,7 @@ internal sealed class VisualBasicTokenEnumerator : TokenEnumerator
 
         /*
         * Method:  TokenEnumerator
-        * 
+        *
         * Construct
         */
         internal VisualBasicTokenEnumerator(Stream binaryStream, bool forceANSI)
@@ -31,7 +31,7 @@ internal VisualBasicTokenEnumerator(Stream binaryStream, bool forceANSI)
 
         /*
         * Method:  FindNextToken
-        * 
+        *
         * Find the next token. Return 'true' if one was found. False, otherwise.
         */
         internal override bool FindNextToken()
@@ -185,7 +185,7 @@ internal override bool FindNextToken()
                     return true;
                 }
 
-                // Sink a suffix if there is one.                    
+                // Sink a suffix if there is one.
                 _reader.SinkIntegerSuffix();
 
                 current = new HexIntegerLiteralToken();
@@ -200,7 +200,7 @@ internal override bool FindNextToken()
                     return true;
                 }
 
-                // Sink a suffix if there is one.                    
+                // Sink a suffix if there is one.
                 _reader.SinkIntegerSuffix();
 
                 current = new VisualBasicTokenizer.OctalIntegerLiteralToken();
@@ -209,7 +209,7 @@ internal override bool FindNextToken()
             // Is it a decimal integer?
             else if (_reader.SinkMultipleDecimalDigits())
             {
-                // Sink a suffix if there is one.                    
+                // Sink a suffix if there is one.
                 _reader.SinkDecimalIntegerSuffix();
 
                 current = new DecimalIntegerLiteralToken();
@@ -259,7 +259,7 @@ internal override bool FindNextToken()
                 }
                 while (!_reader.EndOfLines && _reader.SinkCharacter() != '\"');
 
-                // Can't end a file inside a string 
+                // Can't end a file inside a string
                 if (_reader.EndOfLines)
                 {
                     current = new EndOfFileInsideStringToken();
@@ -271,7 +271,7 @@ internal override bool FindNextToken()
             }
 
 
-            // We didn't recognize the token, so this is a syntax error. 
+            // We didn't recognize the token, so this is a syntax error.
             _reader.SinkCharacter();
             current = new UnrecognizedToken();
             return true;
@@ -317,7 +317,7 @@ internal override bool FindNextToken()
 
         /*
         * Method:  Reader
-        * 
+        *
         * Return the token char reader.
         */
         internal override TokenCharReader Reader
diff --git a/src/Shared/LanguageParser/VisualBasictokenizer.cs b/src/Shared/LanguageParser/VisualBasictokenizer.cs
index 59b51bbb49b..eb58148a2c6 100644
--- a/src/Shared/LanguageParser/VisualBasictokenizer.cs
+++ b/src/Shared/LanguageParser/VisualBasictokenizer.cs
@@ -38,7 +38,7 @@ internal class ExpectedValidOctalDigitToken : SyntaxErrorToken { }
 
         /*
          * Method:  VisualBasicTokenizer
-         * 
+         *
          * Construct
          */
         internal VisualBasicTokenizer(Stream binaryStream, bool forceANSI)
@@ -49,7 +49,7 @@ internal VisualBasicTokenizer(Stream binaryStream, bool forceANSI)
 
         /*
          * Method:  GetEnumerator
-         * 
+         *
          * Return a new token enumerator.
          */
         public IEnumerator GetEnumerator()
diff --git a/src/Shared/LanguageParser/token.cs b/src/Shared/LanguageParser/token.cs
index 2ce67719e5c..62f089b34bf 100644
--- a/src/Shared/LanguageParser/token.cs
+++ b/src/Shared/LanguageParser/token.cs
@@ -22,7 +22,7 @@ internal abstract class Token
 
         /*
          * Method:  InnerText
-         * 
+         *
          * Get or set the InnerText for this token
          */
         internal string InnerText
@@ -33,7 +33,7 @@ internal string InnerText
 
         /*
          * Method:  Line
-         * 
+         *
          * Get or set the Line for this token
          */
         internal int Line
@@ -50,7 +50,7 @@ internal int Line
 
         /*
          * Method:  EqualsIgnoreCase
-         * 
+         *
          * Return true if the given string equals the content of this token
          */
         internal bool EqualsIgnoreCase(string compareTo)
diff --git a/src/Shared/LanguageParser/tokenChar.cs b/src/Shared/LanguageParser/tokenChar.cs
index 9d9e99eb67e..0cd62ff96e9 100644
--- a/src/Shared/LanguageParser/tokenChar.cs
+++ b/src/Shared/LanguageParser/tokenChar.cs
@@ -23,7 +23,7 @@ internal static bool IsNewLine(char c)
             return c == 0x000d        // Carriage return
                     || c == 0x000a        // Linefeed
                     || c == 0x2028        // Line separator
-                    || c == 0x2029        // Paragraph separator                       
+                    || c == 0x2029        // Paragraph separator
                         ;
         }
 
@@ -103,7 +103,7 @@ internal static bool IsCombining(char c)
             // combining-character:
             if (
                     cat == UnicodeCategory.NonSpacingMark // Mn
-                    || cat == UnicodeCategory.SpacingCombiningMark)  // Mc 
+                    || cat == UnicodeCategory.SpacingCombiningMark)  // Mc
             {
                 return true;
             }
diff --git a/src/Shared/LanguageParser/tokenCharReader.cs b/src/Shared/LanguageParser/tokenCharReader.cs
index 2d23ec90339..51a6978d0b8 100644
--- a/src/Shared/LanguageParser/tokenCharReader.cs
+++ b/src/Shared/LanguageParser/tokenCharReader.cs
@@ -11,13 +11,13 @@ namespace Microsoft.Build.Shared.LanguageParser
     /*
      * Class:   TokenCharReader
      *
-     * Reads over the contents of a source file (in the form of a string). 
+     * Reads over the contents of a source file (in the form of a string).
      * Provides utility functions for skipping and checking the value of characters.
      *
      */
     internal class TokenCharReader
     {
-        // The sources 
+        // The sources
         private StreamMappedString _sources;
         // Current character offset within sources.
         private int _position;
@@ -26,7 +26,7 @@ internal class TokenCharReader
 
         /*
          * Method:  TokenCharReader
-         * 
+         *
          * Construct
          */
         internal TokenCharReader(Stream binaryStream, bool forceANSI)
@@ -37,7 +37,7 @@ internal TokenCharReader(Stream binaryStream, bool forceANSI)
 
         /*
          * Method:  Reset
-         * 
+         *
          * Reset to the top of the sources.
          */
         internal void Reset()
@@ -48,8 +48,8 @@ internal void Reset()
 
         /*
          * Method:  CurrentLine
-         * 
-         * The current line number   
+         *
+         * The current line number
          */
         internal int CurrentLine
         {
@@ -58,7 +58,7 @@ internal int CurrentLine
 
         /*
          * Method:  Position
-         * 
+         *
          * The character offset within the sources.
          */
         internal int Position
@@ -74,7 +74,7 @@ internal int Position
 
         /*
          * Method:  Skip
-         * 
+         *
          * Skip to the next character.
          */
         protected void Skip()
@@ -86,9 +86,9 @@ protected void Skip()
             ++_position;
         }
 
-        /* 
+        /*
          * Method:  Skip (overload)
-         * 
+         *
          * Skip the next n characters.
          */
         protected void Skip(int n)
@@ -101,7 +101,7 @@ protected void Skip(int n)
 
         /*
          * Method:  CurrentCharacter
-         * 
+         *
          * Get the current character.
          */
         internal char CurrentCharacter
@@ -111,7 +111,7 @@ internal char CurrentCharacter
 
         /*
          * Method:  EndOfLines
-         * 
+         *
          * Return true if we've reached the end of sources.
          */
         internal bool EndOfLines
@@ -121,7 +121,7 @@ internal bool EndOfLines
 
         /*
          * Method:  GetCurrentMatchedString
-         * 
+         *
          * Get the string that starts with the given start position and ends with this.position.
          */
         internal string GetCurrentMatchedString(int startPosition)
@@ -131,7 +131,7 @@ internal string GetCurrentMatchedString(int startPosition)
 
         /*
          * Method:  Sink
-         * 
+         *
          * See if the next characters match the given string. If they do,
          * sink this string.
          */
@@ -172,7 +172,7 @@ private bool Sink(string match, bool ignoreCase)
 
         /*
          * Method:  SinkCharacter
-         * 
+         *
          * Sink and return one character.
          */
         internal char SinkCharacter()
@@ -184,7 +184,7 @@ internal char SinkCharacter()
 
         /*
          * Method:  SinkIgnoreCase
-         * 
+         *
          * See if the next characters match the given string without case.
          */
         internal bool SinkIgnoreCase(string match)
@@ -194,7 +194,7 @@ internal bool SinkIgnoreCase(string match)
 
         /*
          * Method:  MatchNextIdentifierStart
-         * 
+         *
          * Determine whether a given character is a C# or VB identifier start character.
          * Both languages agree on this format.
          */
@@ -211,7 +211,7 @@ internal bool MatchNextIdentifierStart()
 
         /*
          * Method:  SinkIdentifierStart
-         * 
+         *
          * Determine whether a given character is a C# or VB identifier start character.
          * Both languages agree on this format.
          */
@@ -227,7 +227,7 @@ internal bool SinkIdentifierStart()
 
         /*
          * Method:  SinkIdentifierPart
-         * 
+         *
          * Determine whether a given character is a C# or VB identifier part character
          * Both languages agree on this format.
          */
@@ -250,7 +250,7 @@ internal bool SinkIdentifierPart()
 
         /*
          * Method:  SinkNewLine
-         * 
+         *
          * Sink a newline.
          */
         internal bool SinkNewLine()
@@ -281,7 +281,7 @@ internal bool SinkNewLine()
 
         /*
          * Method:  SinkToEndOfLine
-         * 
+         *
          * Sink from the current position to the first end-of-line.
          */
         internal bool SinkToEndOfLine()
@@ -290,12 +290,12 @@ internal bool SinkToEndOfLine()
             {
                 Skip();
             }
-            return true;    // Matching zero characters is ok.        
+            return true;    // Matching zero characters is ok.
         }
 
         /*
          * Method:  SinkUntil
-         * 
+         *
          * Sink until the given string is found. Match including the given string.
          */
         internal bool SinkUntil(string find)
@@ -318,7 +318,7 @@ internal bool SinkUntil(string find)
 
         /*
          * Method:  SinkMultipleHexDigits
-         * 
+         *
          * Sink multiple hex digits.
          */
         internal bool SinkMultipleHexDigits()
@@ -329,12 +329,12 @@ internal bool SinkMultipleHexDigits()
                 ++count;
                 Skip();
             }
-            return count > 0;     // Must match at least one  
+            return count > 0;     // Must match at least one
         }
 
         /*
          * Method:  SinkMultipleDecimalDigits
-         * 
+         *
          * Sink multiple decimal digits.
          */
         internal bool SinkMultipleDecimalDigits()
@@ -345,7 +345,7 @@ internal bool SinkMultipleDecimalDigits()
                 ++count;
                 Skip();
             }
-            return count > 0;     // Must match at least one 
+            return count > 0;     // Must match at least one
         }
     }
 }
diff --git a/src/Shared/LanguageParser/tokenEnumerator.cs b/src/Shared/LanguageParser/tokenEnumerator.cs
index 673b5a8a933..3ae025d91b4 100644
--- a/src/Shared/LanguageParser/tokenEnumerator.cs
+++ b/src/Shared/LanguageParser/tokenEnumerator.cs
@@ -27,7 +27,7 @@ internal abstract class TokenEnumerator : IEnumerator
 
         /*
         * Method:  MoveNext
-        * 
+        *
         * Declare the MoveNext method required by IEnumerator
         */
         public bool MoveNext()
@@ -59,7 +59,7 @@ public bool MoveNext()
 
         /*
         * Method:  Reset
-        * 
+        *
         * Declare the Reset method required by IEnumerator
         */
         public void Reset()
@@ -70,7 +70,7 @@ public void Reset()
 
         /*
         * Method:  Current
-        * 
+        *
         * Declare the Current property required by IEnumerator
         */
         public object Current
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 474de6dc063..92cc46106f0 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -249,14 +249,14 @@ internal abstract class LogMessagePacketBase : INodePacket
         private static object s_lockObject = new Object();
 
         /// <summary>
-        /// Delegate for translating targetfinished events. 
+        /// Delegate for translating targetfinished events.
         /// </summary>
         private TargetFinishedTranslator _targetFinishedTranslator = null;
 
         #region Data
 
         /// <summary>
-        /// The event type of the buildEventArg based on the 
+        /// The event type of the buildEventArg based on the
         /// LoggingEventType enumeration
         /// </summary>
         private LoggingEventType _eventType = LoggingEventType.Invalid;
@@ -339,8 +339,8 @@ internal KeyValuePair<int, BuildEventArgs>? NodeBuildEvent
         }
 
         /// <summary>
-        /// The event type of the wrapped buildEventArg 
-        /// based on the LoggingEventType enumeration 
+        /// The event type of the wrapped buildEventArg
+        /// based on the LoggingEventType enumeration
         /// </summary>
         internal LoggingEventType EventType
         {
@@ -413,7 +413,7 @@ or EnvironmentVariableReadEventArgs
 
                 if (eventCanSerializeItself)
                 {
-                    // 3.5 or later -- we have custom serialization methods, so let's use them.  
+                    // 3.5 or later -- we have custom serialization methods, so let's use them.
                     ArgsWriterDelegate writerMethod = (ArgsWriterDelegate)CreateDelegateRobust(typeof(ArgsWriterDelegate), _buildEvent, methodInfo);
                     writerMethod(translator.Writer);
 
@@ -449,8 +449,8 @@ internal void ReadFromStream(ITranslator translator)
             {
                 _buildEvent = GetBuildEventArgFromId();
 
-                // The other side is telling us whether the event knows how to log itself, or whether we're going to have 
-                // to do it manually 
+                // The other side is telling us whether the event knows how to log itself, or whether we're going to have
+                // to do it manually
                 int packetVersion = s_defaultPacketVersion;
                 translator.Translate(ref packetVersion);
 
@@ -538,9 +538,9 @@ internal void ReadFromStream(ITranslator translator)
         /// Wrapper for Delegate.CreateDelegate with retries.
         /// </summary>
         /// <comment>
-        /// TODO:  Investigate if it would be possible to use one of the overrides of CreateDelegate 
-        /// that doesn't force the delegate to be closed over its first argument, so that we can 
-        /// only create the delegate once per event type and cache it.  
+        /// TODO:  Investigate if it would be possible to use one of the overrides of CreateDelegate
+        /// that doesn't force the delegate to be closed over its first argument, so that we can
+        /// only create the delegate once per event type and cache it.
         /// </comment>
         private static Delegate CreateDelegateRobust(Type type, Object firstArgument, MethodInfo methodInfo)
         {
@@ -769,8 +769,8 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
         }
 
         /// <summary>
-        /// Given a build event that is presumed to be 2.0 (due to its lack of a "WriteToStream" method) and its 
-        /// LoggingEventType, serialize that event to the stream. 
+        /// Given a build event that is presumed to be 2.0 (due to its lack of a "WriteToStream" method) and its
+        /// LoggingEventType, serialize that event to the stream.
         /// </summary>
         private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType eventType, ITranslator translator)
         {
@@ -915,7 +915,7 @@ private void WriteTaskCommandLineEventToStream(TaskCommandLineEventArgs taskComm
         }
 
         /// <summary>
-        /// Write a "standard" Message Log the translator 
+        /// Write a "standard" Message Log the translator
         /// </summary>
         private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEventArgs, ITranslator translator)
         {
@@ -1144,8 +1144,8 @@ private void WriteMetadata(object metadataContainer, BinaryWriter writer)
         #region Reads from Stream
 
         /// <summary>
-        /// Given a build event that is presumed to be 2.0 (due to its lack of a "ReadFromStream" method) and its 
-        /// LoggingEventType, read that event from the stream. 
+        /// Given a build event that is presumed to be 2.0 (due to its lack of a "ReadFromStream" method) and its
+        /// LoggingEventType, read that event from the stream.
         /// </summary>
         private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslator translator)
         {
@@ -1307,7 +1307,7 @@ private TaskCommandLineEventArgs ReadTaskCommandLineEventFromStream(ITranslator
         }
 
         /// <summary>
-        /// Read and reconstruct a BuildMessageEventArgs from the stream 
+        /// Read and reconstruct a BuildMessageEventArgs from the stream
         /// </summary>
         private BuildMessageEventArgs ReadBuildMessageEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
         {
diff --git a/src/Shared/MetadataConversionUtilities.cs b/src/Shared/MetadataConversionUtilities.cs
index a6c121a1f52..a932217e7bc 100644
--- a/src/Shared/MetadataConversionUtilities.cs
+++ b/src/Shared/MetadataConversionUtilities.cs
@@ -10,14 +10,14 @@ namespace Microsoft.Build.Shared
 {
     /// <summary>
     /// This class contains only static methods, which are useful throughout many
-    /// of the XMake classes and don't really belong in any specific class.   
+    /// of the XMake classes and don't really belong in any specific class.
     /// </summary>
     internal static class MetadataConversionUtilities
     {
         /// <summary>
         /// Convert a task item metadata to bool. Throw an exception if the string is badly formed and can't
         /// be converted.
-        /// 
+        ///
         /// If the metadata is not found, then set metadataFound to false and then return false.
         /// </summary>
         /// <param name="item">The item that contains the metadata.</param>
@@ -50,7 +50,7 @@ internal static bool TryConvertItemMetadataToBool(
         /// <summary>
         /// Convert a task item metadata to bool. Throw an exception if the string is badly formed and can't
         /// be converted.
-        /// 
+        ///
         /// If the attribute is not found, then return false.
         /// </summary>
         /// <param name="item">The item that contains the metadata.</param>
diff --git a/src/Shared/Modifiers.cs b/src/Shared/Modifiers.cs
index 785e7c42ce1..a6c203525d2 100644
--- a/src/Shared/Modifiers.cs
+++ b/src/Shared/Modifiers.cs
@@ -27,11 +27,11 @@ internal static class ItemSpecModifiers
 #if DEBUG
             /// <summary>
             /// Whether to dump when a modifier is in the "wrong" (slow) casing
-            /// </summary>       
+            /// </summary>
             private static readonly bool s_traceModifierCasing = (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDTRACEMODIFIERCASING")));
 #endif
 
-            // NOTE: If you add an item here that starts with a new letter, you need to update the case 
+            // NOTE: If you add an item here that starts with a new letter, you need to update the case
             // statements in IsItemSpecModifier and IsDerivableItemSpecModifier.
             internal const string FullPath = "FullPath";
             internal const string RootDir = "RootDir";
@@ -83,21 +83,21 @@ internal static bool IsItemSpecModifier(string name)
                 }
 
 
-                /* 
+                /*
                  * What follows requires some explanation.
-                 * 
-                 * This function is called many times and slowness here will be amplified 
+                 *
+                 * This function is called many times and slowness here will be amplified
                  * in critical performance scenarios.
-                 * 
+                 *
                  * The following switch statement attempts to identify item spec modifiers that
-                 * have the exact case that our constants in ItemSpecModifiers have. This is the 
+                 * have the exact case that our constants in ItemSpecModifiers have. This is the
                  * 99% case.
-                 * 
+                 *
                  * Further, the switch statement can identify certain cases in which there is
                  * definitely no chance that 'name' is an item spec modifier. For example, a
                  * 7 letter 'name' that doesn't start with 'r' or 'R' can't be RootDir and
                  * therefore is not an item spec modifier.
-                 * 
+                 *
                  */
                 switch (name.Length)
                 {
@@ -245,8 +245,8 @@ internal static bool IsItemSpecModifier(string name)
             }
 
             /// <summary>
-            /// Indicates if the given name is reserved for one of the specific subset of itemspec 
-            /// modifiers to do with the defining project of the item. 
+            /// Indicates if the given name is reserved for one of the specific subset of itemspec
+            /// modifiers to do with the defining project of the item.
             /// </summary>
             internal static bool IsDefiningProjectModifier(string name)
             {
@@ -321,7 +321,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
                     {
                         if (name[0] == 'R' || name[0] == 'r')
                         {
-                            // The only 12 letter ItemSpecModifier that starts with 'R' is 'RecursiveDir' 
+                            // The only 12 letter ItemSpecModifier that starts with 'R' is 'RecursiveDir'
                             return false;
                         }
                     }
@@ -342,7 +342,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
 
             /// <summary>
             /// Performs path manipulations on the given item-spec as directed.
-            /// 
+            ///
             /// Supported modifiers:
             ///     %(FullPath)         = full path of item
             ///     %(RootDir)          = root directory of item
@@ -355,7 +355,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
             ///     %(ModifiedTime)     = last write time of item
             ///     %(CreatedTime)      = creation time of item
             ///     %(AccessedTime)     = last access time of item
-            /// 
+            ///
             /// NOTES:
             /// 1) This method always returns an empty string for the %(RecursiveDir) modifier because it does not have enough
             ///    information to compute it -- only the BuildItem class can compute this modifier.
@@ -366,10 +366,10 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
             /// 1) successive slashes are combined into 1 slash
             /// 2) trailing periods are discarded
             /// 3) forward slashes are changed to back-slashes
-            /// 
+            ///
             /// As a result, we cannot rely on any file-spec that has passed through a Path method to remain the same. We will
             /// therefore not bother preserving slashes and periods when file-specs are transformed.
-            /// 
+            ///
             /// Never returns null.
             /// </remarks>
             /// <param name="currentDirectory">The root directory for relative item-specs. When called on the Engine thread, this is the project directory. When called as part of building a task, it is null, indicating that the current directory should be used.</param>
@@ -531,7 +531,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         }
                         else
                         {
-                            // File does not exist, or path is a directory                        
+                            // File does not exist, or path is a directory
                             modifiedItemSpec = String.Empty;
                         }
                     }
@@ -547,7 +547,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         }
                         else
                         {
-                            // File does not exist, or path is a directory                        
+                            // File does not exist, or path is a directory
                             modifiedItemSpec = String.Empty;
                         }
                     }
diff --git a/src/Shared/NodeBuildComplete.cs b/src/Shared/NodeBuildComplete.cs
index 50c62b7cfd0..25aa30675f7 100644
--- a/src/Shared/NodeBuildComplete.cs
+++ b/src/Shared/NodeBuildComplete.cs
@@ -8,7 +8,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// The NodeBuildComplete packet is used to indicate to a node that it should clean up its current build and 
+    /// The NodeBuildComplete packet is used to indicate to a node that it should clean up its current build and
     /// possibly prepare for node reuse.
     /// </summary>
     internal class NodeBuildComplete : INodePacket
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index f9abb54236e..76705f4a6cb 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -220,7 +220,7 @@ internal void InternalConstruct(string pipeName = null)
                 // Restrict access to just this account.  We set the owner specifically here, and on the
                 // pipe client side they will check the owner against this one - they must have identical
                 // SIDs or the client will reject this server.  This is used to avoid attacks where a
-                // hacked server creates a less restricted pipe in an attempt to lure us into using it and 
+                // hacked server creates a less restricted pipe in an attempt to lure us into using it and
                 // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
                 PipeAccessRule rule = new PipeAccessRule(identifier, PipeAccessRights.ReadWrite, AccessControlType.Allow);
                 security.AddAccessRule(rule);
@@ -516,7 +516,7 @@ private void PacketPumpProc()
         private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
             ConcurrentQueue<INodePacket> localPacketQueue, AutoResetEvent localPacketAvailable, AutoResetEvent localTerminatePacketPump)
         {
-            // Ordering of the wait handles is important.  The first signalled wait handle in the array 
+            // Ordering of the wait handles is important.  The first signalled wait handle in the array
             // will be returned by WaitAny if multiple wait handles are signalled.  We prefer to have the
             // terminate event triggered so that we cannot get into a situation where packets are being
             // spammed to the endpoint and it never gets an opportunity to shutdown.
diff --git a/src/Shared/OutOfProcTaskHostTaskResult.cs b/src/Shared/OutOfProcTaskHostTaskResult.cs
index f1f86a48ac6..87d40fbdce1 100644
--- a/src/Shared/OutOfProcTaskHostTaskResult.cs
+++ b/src/Shared/OutOfProcTaskHostTaskResult.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Shared
     internal class OutOfProcTaskHostTaskResult
     {
         /// <summary>
-        /// Constructor 
+        /// Constructor
         /// </summary>
         internal OutOfProcTaskHostTaskResult(TaskCompleteType result)
             : this(result, null /* no final parameters */, null /* no exception */, null /* no exception message */, null /* and no args to go with it */)
@@ -56,8 +56,8 @@ internal OutOfProcTaskHostTaskResult(TaskCompleteType result, Exception taskExce
         /// </summary>
         internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary<string, Object> finalParams, Exception taskException, string exceptionMessage, string[] exceptionMessageArgs)
         {
-            // If we're returning a crashing result, we should always also be returning the exception that caused the crash, although 
-            // we may not always be returning an accompanying message. 
+            // If we're returning a crashing result, we should always also be returning the exception that caused the crash, although
+            // we may not always be returning an accompanying message.
             if (result == TaskCompleteType.CrashedDuringInitialization ||
                 result == TaskCompleteType.CrashedDuringExecution ||
                 result == TaskCompleteType.CrashedAfterExecution)
@@ -87,7 +87,7 @@ internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary<string
         }
 
         /// <summary>
-        /// The overall result of the task execution. 
+        /// The overall result of the task execution.
         /// </summary>
         public TaskCompleteType Result
         {
@@ -105,8 +105,8 @@ public IDictionary<string, Object> FinalParameterValues
         }
 
         /// <summary>
-        /// The exception thrown by the task during initialization or execution, 
-        /// if any. 
+        /// The exception thrown by the task during initialization or execution,
+        /// if any.
         /// </summary>
         public Exception TaskException
         {
@@ -115,8 +115,8 @@ public Exception TaskException
         }
 
         /// <summary>
-        /// The name of the resource representing the message to be logged along with the 
-        /// above exception. 
+        /// The name of the resource representing the message to be logged along with the
+        /// above exception.
         /// </summary>
         public string ExceptionMessage
         {
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index 226a7780017..18b9b361e3b 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -13,7 +13,7 @@
 namespace Microsoft.Build.Shared
 {
     /// <summary>
-    /// This class contains only static methods, which are used in both the 
+    /// This class contains only static methods, which are used in both the
     /// tasks and graph projects in order for two projects to negotiate which platform a projectreference
     /// should be built as.
     /// </summary>
@@ -83,7 +83,7 @@ internal static string GetNearestPlatform(string overridePlatformValue, string r
             }
             else
             {
-                // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
+                // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine
                 // Platform/PlatformTarget when this is the case.
                 log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", projectPath);
             }
diff --git a/src/Shared/ProcessExtensions.cs b/src/Shared/ProcessExtensions.cs
index d384a07e32b..362a8b0a8c1 100644
--- a/src/Shared/ProcessExtensions.cs
+++ b/src/Shared/ProcessExtensions.cs
@@ -32,7 +32,7 @@ public static void KillTree(this Process process, int timeoutMilliseconds)
                 throw new System.NotSupportedException();
             }
 #endif
-            // wait until the process finishes exiting/getting killed. 
+            // wait until the process finishes exiting/getting killed.
             // We don't want to wait forever here because the task is already supposed to be dieing, we just want to give it long enough
             // to try and flush what it can and stop. If it cannot do that in a reasonable time frame then we will just ignore it.
             process.WaitForExit(timeoutMilliseconds);
diff --git a/src/Shared/ProjectErrorUtilities.cs b/src/Shared/ProjectErrorUtilities.cs
index cfcb32e793a..a7c9fce240a 100644
--- a/src/Shared/ProjectErrorUtilities.cs
+++ b/src/Shared/ProjectErrorUtilities.cs
@@ -239,11 +239,11 @@ internal static void VerifyThrowInvalidProject<T1, T2, T3, T4>(bool condition, s
 
         /// <summary>
         /// Throws an InvalidProjectFileException using the given data.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
-        /// 
+        ///
         /// </summary>
         /// <param name="errorSubCategoryResourceName">The resource string for the
         /// error sub-category (can be null).</param>
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index c6875603ce0..ddb67234b5b 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -17,7 +17,7 @@ internal static class ProjectFileErrorUtilities
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -35,7 +35,7 @@ internal static void ThrowInvalidProjectFile(
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -55,7 +55,7 @@ internal static void ThrowInvalidProjectFile(
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -75,7 +75,7 @@ internal static void VerifyThrowInvalidProjectFile(
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -95,7 +95,7 @@ internal static void ThrowInvalidProjectFile(
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -117,7 +117,7 @@ internal static void VerifyThrowInvalidProjectFile(
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
diff --git a/src/Shared/PropertyParser.cs b/src/Shared/PropertyParser.cs
index 8144cc22191..a9e1c29d72c 100644
--- a/src/Shared/PropertyParser.cs
+++ b/src/Shared/PropertyParser.cs
@@ -20,8 +20,8 @@ namespace Microsoft.Build.Tasks
     internal static class PropertyParser
     {
         /// <summary>
-        /// Given a string of semi-colon delimited name=value pairs, this method parses it and creates 
-        /// a hash table containing the property names as keys and the property values as values.  
+        /// Given a string of semi-colon delimited name=value pairs, this method parses it and creates
+        /// a hash table containing the property names as keys and the property values as values.
         /// </summary>
         /// <returns>true on success, false on failure.</returns>
         internal static bool GetTable(TaskLoggingHelper log, string parameterName, string[] propertyList, out Dictionary<string, string> propertiesTable)
@@ -43,9 +43,9 @@ internal static bool GetTable(TaskLoggingHelper log, string parameterName, strin
                     int indexOfEqualsSign = propertyNameValuePair.IndexOf('=');
 
                     // If we found one, then grab the stuff before it and put it into "propertyName",
-                    // and grab the stuff after it and put it into "propertyValue".  But trim the 
-                    // whitespace from beginning and end of both name and value.  (When authoring a 
-                    // project/targets file, people like to use whitespace and newlines to pretty up 
+                    // and grab the stuff after it and put it into "propertyValue".  But trim the
+                    // whitespace from beginning and end of both name and value.  (When authoring a
+                    // project/targets file, people like to use whitespace and newlines to pretty up
                     // the file format.)
                     if (indexOfEqualsSign != -1)
                     {
@@ -63,7 +63,7 @@ internal static bool GetTable(TaskLoggingHelper log, string parameterName, strin
                     }
 
                     // Bag the property and its value.  Trim whitespace from beginning and end of
-                    // both name and value.  (When authoring a project/targets file, people like to 
+                    // both name and value.  (When authoring a project/targets file, people like to
                     // use whitespace and newlines to pretty up the file format.)
                     propertiesTable[propertyName] = propertyValue;
                 }
@@ -73,9 +73,9 @@ internal static bool GetTable(TaskLoggingHelper log, string parameterName, strin
         }
 
         /// <summary>
-        /// Given a string of semi-colon delimited name=value pairs, this method parses it and creates 
-        /// a hash table containing the property names as keys and the property values as values.  
-        /// This method escapes any special characters found in the property values, in case they 
+        /// Given a string of semi-colon delimited name=value pairs, this method parses it and creates
+        /// a hash table containing the property names as keys and the property values as values.
+        /// This method escapes any special characters found in the property values, in case they
         /// are going to be passed to a method (such as that expects the appropriate escaping to have happened
         /// already.
         /// </summary>
@@ -99,9 +99,9 @@ internal static bool GetTableWithEscaping(TaskLoggingHelper log, string paramete
                     if (indexOfEqualsSign != -1)
                     {
                         // If we found one, then grab the stuff before it and put it into "propertyName",
-                        // and grab the stuff after it and put it into "propertyValue".  But trim the 
-                        // whitespace from beginning and end of both name and value.  (When authoring a 
-                        // project/targets file, people like to use whitespace and newlines to pretty up 
+                        // and grab the stuff after it and put it into "propertyValue".  But trim the
+                        // whitespace from beginning and end of both name and value.  (When authoring a
+                        // project/targets file, people like to use whitespace and newlines to pretty up
                         // the file format.)
                         string propertyName = propertyNameValueString.Substring(0, indexOfEqualsSign).Trim();
                         string propertyValue = EscapingUtilities.Escape(propertyNameValueString.Substring(indexOfEqualsSign + 1).Trim());
diff --git a/src/Shared/QuotingUtilities.cs b/src/Shared/QuotingUtilities.cs
index eb25b416f0a..17ca8a419db 100644
--- a/src/Shared/QuotingUtilities.cs
+++ b/src/Shared/QuotingUtilities.cs
@@ -11,34 +11,34 @@
 namespace Microsoft.Build.Shared
 {
     /// <summary>
-    /// This class implements some static methods to assist with command-line parsing of 
+    /// This class implements some static methods to assist with command-line parsing of
     /// parameters that could be quoted, and thus could contain nested escaped quotes.
     /// </summary>
     internal static class QuotingUtilities
     {
         /*
          * Quoting Rules:
-         * 
+         *
          * A string is considered quoted if it is enclosed in double-quotes. A double-quote can be escaped with a backslash, or it
          * is automatically escaped if it is the last character in an explicitly terminated quoted string. A backslash itself can
          * be escaped with another backslash IFF it precedes a double-quote, otherwise it is interpreted literally.
-         * 
+         *
          * e.g.
          *      abc"cde"xyz         --> "cde" is quoted
          *      abc"xyz             --> "xyz" is quoted (the terminal double-quote is assumed)
          *      abc"xyz"            --> "xyz" is quoted (the terminal double-quote is explicit)
-         * 
+         *
          *      abc\"cde"xyz        --> "xyz" is quoted (the terminal double-quote is assumed)
          *      abc\\"cde"xyz       --> "cde" is quoted
          *      abc\\\"cde"xyz      --> "xyz" is quoted (the terminal double-quote is assumed)
-         * 
+         *
          *      abc"""xyz           --> """ is quoted
          *      abc""""xyz          --> """ and "xyz" are quoted (the terminal double-quote is assumed)
          *      abc"""""xyz         --> """ is quoted
          *      abc""""""xyz        --> """ and """ are quoted
          *      abc"cde""xyz        --> "cde"" is quoted
          *      abc"xyz""           --> "xyz"" is quoted (the terminal double-quote is explicit)
-         * 
+         *
          *      abc""xyz            --> nothing is quoted
          *      abc""cde""xyz       --> nothing is quoted
          */
diff --git a/src/Shared/ReadOnlyCollection.cs b/src/Shared/ReadOnlyCollection.cs
index d7e5c12ce5a..c3a13f5e58a 100644
--- a/src/Shared/ReadOnlyCollection.cs
+++ b/src/Shared/ReadOnlyCollection.cs
@@ -29,9 +29,9 @@ internal sealed class ReadOnlyCollection<T> : ICollection<T>, ICollection
         private IEnumerable<T> _backing;
 
         /// <summary>
-        /// Construct a read only wrapper around the current contents 
-        /// of the IEnumerable, or around the backing collection if the 
-        /// IEnumerable is in fact a collection. 
+        /// Construct a read only wrapper around the current contents
+        /// of the IEnumerable, or around the backing collection if the
+        /// IEnumerable is in fact a collection.
         /// </summary>
         internal ReadOnlyCollection(IEnumerable<T> backing)
         {
@@ -114,8 +114,8 @@ public void Clear()
         /// </summary>
         public bool Contains(T item)
         {
-            // UNDONE: IEnumerable.Contains<T>() does the ICollection check, 
-            // so we could just use IEnumerable.Contains<T>() here.  
+            // UNDONE: IEnumerable.Contains<T>() does the ICollection check,
+            // so we could just use IEnumerable.Contains<T>() here.
             if (!(_backing is ICollection<T>))
             {
                 return _backing.Contains<T>(item);
diff --git a/src/Shared/RegisteredTaskObjectCacheBase.cs b/src/Shared/RegisteredTaskObjectCacheBase.cs
index 7677de76590..d7d25b7d962 100644
--- a/src/Shared/RegisteredTaskObjectCacheBase.cs
+++ b/src/Shared/RegisteredTaskObjectCacheBase.cs
@@ -44,7 +44,7 @@ static RegisteredTaskObjectCacheBase()
 
         #region IRegisteredTaskObjectCache
 
-        /// <summary> 
+        /// <summary>
         /// Disposes of all of the cached objects registered with the specified lifetime.
         /// </summary>
         public void DisposeCacheObjects(RegisteredTaskObjectLifetime lifetime)
diff --git a/src/Shared/RegistryHelper.cs b/src/Shared/RegistryHelper.cs
index 43b846f2478..c86163701ac 100644
--- a/src/Shared/RegistryHelper.cs
+++ b/src/Shared/RegistryHelper.cs
@@ -18,7 +18,7 @@ internal static class RegistryHelper
         /// </summary>
         /// <param name="baseKey">The base registry key.</param>
         /// <param name="subkey">The subkey</param>
-        /// <returns>An enumeration of strings.</returns>        
+        /// <returns>An enumeration of strings.</returns>
         internal static IEnumerable<string>? GetSubKeyNames(RegistryKey baseKey, string subkey)
         {
             IEnumerable<string>? subKeys = null;
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index 2e2fec9ad0f..deaf884e4d5 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -24,7 +24,7 @@ namespace Microsoft.Build.Shared
     internal static class ResourceUtilities
     {
         /// <summary>
-        /// Extracts the message code (if any) prefixed to the given string. 
+        /// Extracts the message code (if any) prefixed to the given string.
         /// <![CDATA[
         /// MSBuild codes match "^\s*(?<CODE>MSB\d\d\d\d):\s*(?<MESSAGE>.*)$"
         /// Arbitrary codes match "^\s*(?<CODE>[A-Za-z]+\d+):\s*(?<MESSAGE>.*)$"
@@ -154,7 +154,7 @@ internal static string GetResourceString(string resourceName)
         /// <summary>
         /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they too are returned.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -182,7 +182,7 @@ internal static string FormatResourceString(string resourceName)
         /// <summary>
         /// Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they are discarded.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -213,10 +213,10 @@ internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceN
 
         /// <summary>
         /// Formats the given string using the variable arguments passed in.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="unformatted">The string to format.</param>
@@ -230,7 +230,7 @@ internal static string FormatString(string unformatted, params object[] args)
             if ((args?.Length > 0))
             {
 #if DEBUG
-                // If you accidentally pass some random type in that can't be converted to a string, 
+                // If you accidentally pass some random type in that can't be converted to a string,
                 // FormatResourceString calls ToString() which returns the full name of the type!
                 foreach (object param in args)
                 {
diff --git a/src/Shared/SolutionConfiguration.cs b/src/Shared/SolutionConfiguration.cs
index a271f2645f4..78ed1652105 100644
--- a/src/Shared/SolutionConfiguration.cs
+++ b/src/Shared/SolutionConfiguration.cs
@@ -52,11 +52,11 @@ public SolutionConfiguration(string xmlString)
                     string projectGuid = xmlElement.GetAttribute(ProjectAttribute);
                     string projectAbsolutePath = xmlElement.GetAttribute(AbsolutePathAttribute);
 
-                    // What we really want here is the normalized path, like we'd get with an item's "FullPath" metadata.  However, 
-                    // if there's some bogus full path in the solution configuration (e.g. a website with a "full path" of c:\solutiondirectory\http://localhost) 
-                    // we do NOT want to throw -- chances are extremely high that that's information that will never actually be used.  So resolve the full path 
-                    // but just swallow any IO-related exceptions that result.  If the path is bogus, the method will return null, so we'll just quietly fail 
-                    // to cache it below. 
+                    // What we really want here is the normalized path, like we'd get with an item's "FullPath" metadata.  However,
+                    // if there's some bogus full path in the solution configuration (e.g. a website with a "full path" of c:\solutiondirectory\http://localhost)
+                    // we do NOT want to throw -- chances are extremely high that that's information that will never actually be used.  So resolve the full path
+                    // but just swallow any IO-related exceptions that result.  If the path is bogus, the method will return null, so we'll just quietly fail
+                    // to cache it below.
                     projectAbsolutePath = FileUtilities.GetFullPathNoThrow(projectAbsolutePath);
 
                     if (!string.IsNullOrEmpty(projectGuid))
diff --git a/src/Shared/StrongNameHelpers.cs b/src/Shared/StrongNameHelpers.cs
index 102681f6050..ac9476181eb 100644
--- a/src/Shared/StrongNameHelpers.cs
+++ b/src/Shared/StrongNameHelpers.cs
@@ -521,12 +521,12 @@ int StrongNameTokenFromPublicKey(
 
     /// <summary>
     /// This is a managed wrapper for the IClrStrongName interface defined in metahost.idl
-    /// This is very similar to the standard RCWs provided in 
+    /// This is very similar to the standard RCWs provided in
     /// ndp/fx/src/hosting/interop/microsoft/runtime/hosting/interop, but we don't want to
     /// reference that assembly (part of the SDK only, not .NET redist).  Also, our version
     /// is designed specifically for easy migration from the old mscoree APIs, for example
     /// all APIs return HResults rather than throw exceptions.
-    /// </summary> 
+    /// </summary>
     [System.Security.SecurityCritical]
     [ComImport]
     [ComConversionLoss]
diff --git a/src/Shared/TaskEngineAssemblyResolver.cs b/src/Shared/TaskEngineAssemblyResolver.cs
index 6f8cf5157d8..44b243ab0f0 100644
--- a/src/Shared/TaskEngineAssemblyResolver.cs
+++ b/src/Shared/TaskEngineAssemblyResolver.cs
@@ -42,10 +42,10 @@ internal void Initialize(string taskAssemblyFileToResolve)
         }
 
         /// <summary>
-        /// Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain, 
+        /// Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain,
         /// so it's possible to create an AppDomain, create an instance of this class in it and use this method to install
         /// an event handler in that AppDomain. Since the event handler instance is stored internally, this method
-        /// should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do 
+        /// should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do
         /// anything else).
         /// </summary>
         internal void InstallHandler()
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index d60ce982546..9a9c199f732 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -13,7 +13,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// TaskHostConfiguration contains information needed for the task host to 
+    /// TaskHostConfiguration contains information needed for the task host to
     /// configure itself for to execute a particular task.
     /// </summary>
     internal class TaskHostConfiguration : INodePacket
@@ -45,23 +45,23 @@ internal class TaskHostConfiguration : INodePacket
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// The AppDomainSetup that we may want to use on AppDomainIsolated tasks. 
+        /// The AppDomainSetup that we may want to use on AppDomainIsolated tasks.
         /// </summary>
         private AppDomainSetup _appDomainSetup;
 #endif
 
         /// <summary>
-        /// Line number where the instance of this task is defined. 
+        /// Line number where the instance of this task is defined.
         /// </summary>
         private int _lineNumberOfTask;
 
         /// <summary>
-        /// Column number where the instance of this task is defined. 
+        /// Column number where the instance of this task is defined.
         /// </summary>
         private int _columnNumberOfTask;
 
         /// <summary>
-        /// Project file where the instance of this task is defined. 
+        /// Project file where the instance of this task is defined.
         /// </summary>
         private string _projectFileOfTask;
 
@@ -71,12 +71,12 @@ internal class TaskHostConfiguration : INodePacket
         private bool _continueOnError;
 
         /// <summary>
-        /// Name of the task to be executed on the task host. 
+        /// Name of the task to be executed on the task host.
         /// </summary>
         private string _taskName;
 
         /// <summary>
-        /// Location of the assembly containing the task to be executed. 
+        /// Location of the assembly containing the task to be executed.
         /// </summary>
         private string _taskLocation;
 
@@ -86,7 +86,7 @@ internal class TaskHostConfiguration : INodePacket
         private bool _isTaskInputLoggingEnabled;
 
         /// <summary>
-        /// The set of parameters to apply to the task prior to execution.  
+        /// The set of parameters to apply to the task prior to execution.
         /// </summary>
         private Dictionary<string, TaskParameter> _taskParameters;
 
@@ -209,7 +209,7 @@ public TaskHostConfiguration(
         }
 
         /// <summary>
-        /// Constructor for deserialization. 
+        /// Constructor for deserialization.
         /// </summary>
         private TaskHostConfiguration()
         {
@@ -268,7 +268,7 @@ public CultureInfo UICulture
 #if FEATURE_APPDOMAIN
         /// <summary>
         /// The AppDomain configuration bytes that we may want to use to initialize
-        /// AppDomainIsolated tasks. 
+        /// AppDomainIsolated tasks.
         /// </summary>
         public AppDomainSetup AppDomainSetup
         {
@@ -279,7 +279,7 @@ public AppDomainSetup AppDomainSetup
 #endif
 
         /// <summary>
-        /// Line number where the instance of this task is defined. 
+        /// Line number where the instance of this task is defined.
         /// </summary>
         public int LineNumberOfTask
         {
@@ -289,7 +289,7 @@ public int LineNumberOfTask
         }
 
         /// <summary>
-        /// Column number where the instance of this task is defined. 
+        /// Column number where the instance of this task is defined.
         /// </summary>
         public int ColumnNumberOfTask
         {
@@ -309,7 +309,7 @@ public bool ContinueOnError
         }
 
         /// <summary>
-        /// Project file where the instance of this task is defined. 
+        /// Project file where the instance of this task is defined.
         /// </summary>
         public string ProjectFileOfTask
         {
@@ -319,7 +319,7 @@ public string ProjectFileOfTask
         }
 
         /// <summary>
-        /// Name of the task to execute. 
+        /// Name of the task to execute.
         /// </summary>
         public string TaskName
         {
@@ -329,7 +329,7 @@ public string TaskName
         }
 
         /// <summary>
-        /// Path to the assembly to load the task from. 
+        /// Path to the assembly to load the task from.
         /// </summary>
         public string TaskLocation
         {
@@ -349,7 +349,7 @@ public bool IsTaskInputLoggingEnabled
         }
 
         /// <summary>
-        /// Parameters to set on the instantiated task prior to execution. 
+        /// Parameters to set on the instantiated task prior to execution.
         /// </summary>
         public Dictionary<string, TaskParameter> TaskParameters
         {
diff --git a/src/Shared/TaskHostTaskCancelled.cs b/src/Shared/TaskHostTaskCancelled.cs
index d357e55b94a..f56e61a34d9 100644
--- a/src/Shared/TaskHostTaskCancelled.cs
+++ b/src/Shared/TaskHostTaskCancelled.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// TaskHostTaskCancelled informs the task host that the task it is 
+    /// TaskHostTaskCancelled informs the task host that the task it is
     /// currently executing has been canceled.
     /// </summary>
     internal class TaskHostTaskCancelled : INodePacket
@@ -32,7 +32,7 @@ public NodePacketType Type
         /// <param name="translator">The translator to use.</param>
         public void Translate(ITranslator translator)
         {
-            // Do nothing -- this packet doesn't contain any parameters. 
+            // Do nothing -- this packet doesn't contain any parameters.
         }
 
         /// <summary>
diff --git a/src/Shared/TaskHostTaskComplete.cs b/src/Shared/TaskHostTaskComplete.cs
index 6e5a9029b6e..4979b8da24a 100644
--- a/src/Shared/TaskHostTaskComplete.cs
+++ b/src/Shared/TaskHostTaskComplete.cs
@@ -29,8 +29,8 @@ internal enum TaskCompleteType
         Failure,
 
         /// <summary>
-        /// Task crashed during initialization steps -- loading the task, 
-        /// validating or setting the parameters, etc. 
+        /// Task crashed during initialization steps -- loading the task,
+        /// validating or setting the parameters, etc.
         /// </summary>
         CrashedDuringInitialization,
 
@@ -47,7 +47,7 @@ internal enum TaskCompleteType
     }
 
     /// <summary>
-    /// TaskHostTaskComplete contains all the information the parent node 
+    /// TaskHostTaskComplete contains all the information the parent node
     /// needs from the task host on completion of task execution.
     /// </summary>
     internal class TaskHostTaskComplete : INodePacket
@@ -57,30 +57,30 @@ internal class TaskHostTaskComplete : INodePacket
 #endif
 
         /// <summary>
-        /// Result of the task's execution. 
+        /// Result of the task's execution.
         /// </summary>
         private TaskCompleteType _taskResult;
 
         /// <summary>
-        /// If the task threw an exception during its initialization or execution, 
-        /// save it here. 
+        /// If the task threw an exception during its initialization or execution,
+        /// save it here.
         /// </summary>
         private Exception _taskException;
 
         /// <summary>
-        /// If there's an additional message that should be attached to the error 
-        /// logged beyond "task X failed unexpectedly", save it here.  May be null. 
+        /// If there's an additional message that should be attached to the error
+        /// logged beyond "task X failed unexpectedly", save it here.  May be null.
         /// </summary>
         private string _taskExceptionMessage;
 
         /// <summary>
-        /// If the message saved in taskExceptionMessage requires arguments, save 
-        /// them here. May be null. 
+        /// If the message saved in taskExceptionMessage requires arguments, save
+        /// them here. May be null.
         /// </summary>
         private string[] _taskExceptionMessageArgs;
 
         /// <summary>
-        /// The set of parameters / values from the task after it finishes execution. 
+        /// The set of parameters / values from the task after it finishes execution.
         /// </summary>
         private Dictionary<string, TaskParameter> _taskOutputParameters = null;
 
@@ -153,8 +153,8 @@ public TaskCompleteType TaskResult
         }
 
         /// <summary>
-        /// If the task threw an exception during its initialization or execution, 
-        /// save it here. 
+        /// If the task threw an exception during its initialization or execution,
+        /// save it here.
         /// </summary>
         public Exception TaskException
         {
@@ -164,8 +164,8 @@ public Exception TaskException
         }
 
         /// <summary>
-        /// If there's an additional message that should be attached to the error 
-        /// logged beyond "task X failed unexpectedly", put it here.  May be null. 
+        /// If there's an additional message that should be attached to the error
+        /// logged beyond "task X failed unexpectedly", put it here.  May be null.
         /// </summary>
         public string TaskExceptionMessage
         {
@@ -175,8 +175,8 @@ public string TaskExceptionMessage
         }
 
         /// <summary>
-        /// If there are arguments that need to be formatted into the message being 
-        /// sent, set them here.  May be null. 
+        /// If there are arguments that need to be formatted into the message being
+        /// sent, set them here.  May be null.
         /// </summary>
         public string[] TaskExceptionMessageArgs
         {
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index b74e7ce01d8..ea170a16a08 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -23,7 +23,7 @@ internal static class TaskLoader
 #endif
 
         /// <summary>
-        /// Delegate for logging task loading errors. 
+        /// Delegate for logging task loading errors.
         /// </summary>
         internal delegate void LogError(string taskLocation, int taskLine, int taskColumn, string message, params object[] messageArgs);
 
@@ -39,7 +39,7 @@ internal static bool IsTaskClass(Type type, object unused)
         }
 
         /// <summary>
-        /// Creates an ITask instance and returns it.  
+        /// Creates an ITask instance and returns it.
         /// </summary>
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
         internal static ITask CreateTask(
@@ -116,7 +116,7 @@ bool isOutOfProc
                             taskAppDomain.Load(loadedType.LoadedAssemblyName);
                         }
 
-                        // Hook up last minute dumping of any exceptions 
+                        // Hook up last minute dumping of any exceptions
                         taskAppDomain.UnhandledException += ExceptionHandling.UnhandledExceptionHandler;
                         appDomainCreated?.Invoke(taskAppDomain);
                     }
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 4e0c4548bd7..da848678ded 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -127,7 +127,7 @@ protected IBuildEngine BuildEngine
         {
             get
             {
-                // If the task instance does not equal null then use its build engine because 
+                // If the task instance does not equal null then use its build engine because
                 // the task instances build engine can be changed for example during tests. This changing of the engine on the same task object is not expected to happen
                 // during normal operation.
                 if (_taskInstance != null)
@@ -187,10 +187,10 @@ public string ExtractMessageCode(string message, out string messageWithoutCodePr
         /// <summary>
         /// Loads the specified resource string and optionally formats it using the given arguments. The current thread's culture
         /// is used for formatting.
-        /// 
+        ///
         /// Requires the owner task to have registered its resources either via the Task (or TaskMarshalByRef) base
         /// class constructor, or the Task.TaskResources (or AppDomainIsolatedTask.TaskResources) property.
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="resourceName">The name of the string resource to load.</param>
@@ -792,14 +792,14 @@ public void LogErrorFromResources(
         }
 
         /// <summary>
-        /// Logs an error using the specified resource string. 
+        /// Logs an error using the specified resource string.
         /// If the message has an error code prefixed to it, the code is extracted and logged with the message. If a help keyword
         /// prefix has been provided, a help keyword for the host IDE is also logged with the message. The help keyword is
         /// composed by appending the string resource name to the prefix.
-        /// 
+        ///
         /// A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
         /// Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="messageResourceName">The name of the string resource to load.</param>
@@ -811,14 +811,14 @@ public void LogErrorWithCodeFromResources(string messageResourceName, params obj
         }
 
         /// <summary>
-        /// Logs an error using the specified resource string and other error details. 
+        /// Logs an error using the specified resource string and other error details.
         /// If the message has an error code prefixed, the code is extracted and logged with the message. If a
         /// help keyword prefix has been provided, a help keyword for the host IDE is also logged with the message. The help
         /// keyword is composed by appending the error message resource string name to the prefix.
-        /// 
+        ///
         /// A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
         /// Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="subcategoryResourceName">The name of the string resource that describes the error type (can be null).</param>
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index a71f01f150d..87b3a3b7e67 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Internal
     /// </summary>
     internal static class Tracing
     {
-        // Disabling warning about unused fields -- this is effectively a 
+        // Disabling warning about unused fields -- this is effectively a
         // debug-only class, so these fields cause a build break in RET
 #pragma warning disable 649
         /// <summary>
@@ -44,7 +44,7 @@ internal static class Tracing
 
         /// <summary>
         /// Short name of the current assembly - to distinguish statics when this type is shared into different assemblies
-        /// </summary> 
+        /// </summary>
         private static string s_currentAssemblyName;
 #pragma warning restore 649
 
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 37150f3f85a..f9426436f8d 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -191,7 +191,7 @@ private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo as
             string path = assemblyLoadInfo.AssemblyFile;
             string[] localAssemblies = Directory.GetFiles(Path.GetDirectoryName(path), "*.dll");
 
-            // Deduplicate between MSBuild assemblies and task dependencies. 
+            // Deduplicate between MSBuild assemblies and task dependencies.
             Dictionary<string, string> assembliesDictionary = new(localAssemblies.Length + runtimeAssemblies.Length);
             foreach (string localPath in localAssemblies)
             {
@@ -240,7 +240,7 @@ internal LoadedType ReflectionOnlyLoad(
         /// </summary>
         private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly, bool useTaskHost)
         {
-            // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which 
+            // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which
             // will map a specific AssemblyLoadInfo to a AssemblyInfoToLoadedTypes class which knows how to find a typeName in a given assembly.
             ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes> loadInfoToType =
                 cache.GetOrAdd(_isDesiredType, (_) => new ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>());
@@ -255,7 +255,7 @@ private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>,
         /// <summary>
         /// Given a type filter and an asssemblyInfo object keep track of what types in a given assembly which match the type filter.
         /// Also, use this information to determine if a given TypeName is in the assembly which is pointed to by the AssemblyLoadInfo object.
-        /// 
+        ///
         /// This type represents a combination of a type filter and an assemblyInfo object.
         /// </summary>
         [DebuggerDisplay("Types in {_assemblyLoadInfo} matching {_isDesiredType}")]
@@ -263,7 +263,7 @@ private class AssemblyInfoToLoadedTypes
         {
             /// <summary>
             /// Lock to prevent two threads from using this object at the same time.
-            /// Since we fill up internal structures with what is in the assembly 
+            /// Since we fill up internal structures with what is in the assembly
             /// </summary>
             private readonly Object _lockObject = new Object();
 
@@ -405,7 +405,7 @@ private LoadedType GetLoadedTypeFromTypeNameUsingMetadataLoadContext(string type
             }
 
             /// <summary>
-            /// Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on 
+            /// Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on
             /// to find tasks, loggers, and task factories.
             /// </summary>
             private void ScanAssemblyForPublicTypes()
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index 5efa28ce676..1114e941ff9 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -319,7 +319,7 @@ public void CompareBaseNameRealCase1()
 
         /// <summary>
         /// Verify an exception is thrown when the simple name is not in the itemspec.
-        /// 
+        ///
         /// </summary>
         [Fact]
         public void CreateAssemblyNameExtensionWithNoSimpleName()
@@ -648,7 +648,7 @@ public void VerifyAssemblyNameComparers()
 
 
         /// <summary>
-        /// Make sure the reverse version comparer will compare the version in a way that would sort them in reverse order. 
+        /// Make sure the reverse version comparer will compare the version in a way that would sort them in reverse order.
         /// </summary>
         [Fact]
         public void VerifyReverseVersionComparer()
diff --git a/src/Shared/UnitTests/BuildEventArgsExtension.cs b/src/Shared/UnitTests/BuildEventArgsExtension.cs
index eb492bbecd7..4ccf2f47b5c 100644
--- a/src/Shared/UnitTests/BuildEventArgsExtension.cs
+++ b/src/Shared/UnitTests/BuildEventArgsExtension.cs
@@ -17,7 +17,7 @@ internal static class BuildEventArgsExtension
     {
         /// <summary>
         /// Extension method to help our tests without adding shipping code.
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="args">The 'this' object</param>
@@ -82,7 +82,7 @@ public static bool IsEquivalent(this BuildEventArgs args, BuildEventArgs other)
 
         /// <summary>
         /// Extension method to help our tests without adding shipping code.
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="args">The 'this' object</param>
@@ -114,7 +114,7 @@ public static bool IsEquivalent(this BuildMessageEventArgs args, BuildMessageEve
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -160,7 +160,7 @@ public static bool IsEquivalent(this BuildErrorEventArgs args, BuildErrorEventAr
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -206,7 +206,7 @@ public static bool IsEquivalent(this BuildWarningEventArgs args, BuildWarningEve
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -227,7 +227,7 @@ public static bool IsEquivalent(ProjectStartedEventArgs args, ProjectStartedEven
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -248,7 +248,7 @@ public static bool IsEquivalent(ExternalProjectStartedEventArgs args, ExternalPr
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -269,7 +269,7 @@ public static bool IsEquivalent(ProjectFinishedEventArgs args, ProjectFinishedEv
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -290,7 +290,7 @@ public static bool IsEquivalent(ExternalProjectFinishedEventArgs args, ExternalP
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -320,7 +320,7 @@ public static bool IsEquivalent(TargetStartedEventArgs args, TargetStartedEventA
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -385,7 +385,7 @@ public static bool IsEquivalent(TargetFinishedEventArgs args, TargetFinishedEven
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -411,7 +411,7 @@ public static bool IsEquivalent(TaskStartedEventArgs args, TaskStartedEventArgs
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
diff --git a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
index 8beef1b543f..32101d5d60e 100644
--- a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
+++ b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.UnitTests.OM.Collections
 {
     /// <summary>
-    /// Tests for the CopyOnWriteDictionary 
+    /// Tests for the CopyOnWriteDictionary
     /// </summary>
     public class CopyOnWriteDictionary_Tests
     {
@@ -109,7 +109,7 @@ public void EqualityComparer()
         }
 
         /// <summary>
-        /// Cloning sees the same values 
+        /// Cloning sees the same values
         /// </summary>
         [Fact]
         public void CloneVisibility()
@@ -125,7 +125,7 @@ public void CloneVisibility()
         }
 
         /// <summary>
-        /// Clone uses same comparer 
+        /// Clone uses same comparer
         /// </summary>
         [Fact]
         public void CloneComparer()
diff --git a/src/Shared/UnitTests/EngineTestEnvironment.cs b/src/Shared/UnitTests/EngineTestEnvironment.cs
index c06703a4a66..87be4933bc4 100644
--- a/src/Shared/UnitTests/EngineTestEnvironment.cs
+++ b/src/Shared/UnitTests/EngineTestEnvironment.cs
@@ -88,7 +88,7 @@ public TransientProjectCollection CreateProjectCollection()
         /// <param name="projectFileName">Name of the project file with extension to be created.</param>
         /// <param name="projectContents">Contents of the project file to be created.</param>
         /// <param name="files">Files to be created.</param>
-        /// <param name="relativePathFromRootToProject">Path for the specified files to be created in relative to 
+        /// <param name="relativePathFromRootToProject">Path for the specified files to be created in relative to
         /// the root of the project directory.</param>
         public TransientTestProjectWithFiles CreateTestProjectWithFiles(string projectFileName, string projectContents, string[] files = null, string relativePathFromRootToProject = ".")
             => WithTransientTestState(new TransientTestProjectWithFiles(projectFileName, projectContents, files, relativePathFromRootToProject));
@@ -99,7 +99,7 @@ public TransientTestProjectWithFiles CreateTestProjectWithFiles(string projectFi
         /// </summary>
         /// <param name="projectContents">Contents of the project file to be created.</param>
         /// <param name="files">Files to be created.</param>
-        /// <param name="relativePathFromRootToProject">Path for the specified files to be created in relative to 
+        /// <param name="relativePathFromRootToProject">Path for the specified files to be created in relative to
         /// the root of the project directory.</param>
         public TransientTestProjectWithFiles CreateTestProjectWithFiles(string projectContents, string[] files = null, string relativePathFromRootToProject = ".")
             => CreateTestProjectWithFiles("build.proj", projectContents, files, relativePathFromRootToProject);
diff --git a/src/Shared/UnitTests/MockEngine.cs b/src/Shared/UnitTests/MockEngine.cs
index 7797ba2dadf..a0dfb0c644e 100644
--- a/src/Shared/UnitTests/MockEngine.cs
+++ b/src/Shared/UnitTests/MockEngine.cs
@@ -19,18 +19,18 @@
 namespace Microsoft.Build.UnitTests
 {
     /***************************************************************************
-     * 
+     *
      * Class:       MockEngine
-     * 
+     *
      * In order to execute tasks, we have to pass in an Engine object, so the
      * task can log events.  It doesn't have to be the real Engine object, just
      * something that implements the IBuildEngine4 interface.  So, we mock up
      * a fake engine object here, so we're able to execute tasks from the unit tests.
-     * 
+     *
      * The unit tests could have instantiated the real Engine object, but then
      * we would have had to take a reference onto the Microsoft.Build.Engine assembly, which
      * is somewhat of a no-no for task assemblies.
-     * 
+     *
      **************************************************************************/
     internal sealed class MockEngine : IBuildEngine7
     {
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index df21aa2f2e6..38ac661d845 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -176,9 +176,9 @@ internal string FullLog
 
         /*
          * Property:    Parameters
-         * 
+         *
          * The mock logger does not take parameters.
-         * 
+         *
          */
         public string Parameters { get; set; }
 
@@ -223,9 +223,9 @@ public void ClearLog()
 
         /*
          * Method:  Shutdown
-         * 
+         *
          * The mock logger does not need to release any resources.
-         * 
+         *
          */
         public void Shutdown()
         {
diff --git a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
index fc4c92ed88b..fefbe339983 100644
--- a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
+++ b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
@@ -110,7 +110,7 @@ public void GetLastWriteDirectoryUtcTimeReturnsMinValueForFile()
 
         /// <summary>
         /// Verifies that NativeMethodsShared.SetCurrentDirectory(), when called on a nonexistent
-        /// directory, will not set the current directory to that location. 
+        /// directory, will not set the current directory to that location.
         /// </summary>
         [Fact]
         public void SetCurrentDirectoryDoesNotSetNonexistentFolder()
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index 4f206d425b9..a63894695da 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -225,7 +225,7 @@ private void CheckIfCorrectAssemblyLoaded(string scriptOutput, string expectedAs
 
 #if FEATURE_ASSEMBLY_LOCATION
         /// <summary>
-        /// Make sure that when we load multiple types out of the same assembly with different type filters that both the fullyqualified name matching and the 
+        /// Make sure that when we load multiple types out of the same assembly with different type filters that both the fullyqualified name matching and the
         /// partial name matching still work.
         /// </summary>
         [Fact]
@@ -245,7 +245,7 @@ public void Regress640476PartialName()
         }
 
         /// <summary>
-        /// Make sure that when we load multiple types out of the same assembly with different type filters that both the fullyqualified name matching and the 
+        /// Make sure that when we load multiple types out of the same assembly with different type filters that both the fullyqualified name matching and the
         /// partial name matching still work.
         /// </summary>
         [Fact]
diff --git a/src/Shared/UnitTests/XmlUtilities_Tests.cs b/src/Shared/UnitTests/XmlUtilities_Tests.cs
index c8dd9ccdac6..5860d3ae110 100644
--- a/src/Shared/UnitTests/XmlUtilities_Tests.cs
+++ b/src/Shared/UnitTests/XmlUtilities_Tests.cs
@@ -40,7 +40,7 @@ public void InvalidNameErrorLocation()
         }
 
         /// <summary>
-        /// Helper for invalid name error location test 
+        /// Helper for invalid name error location test
         /// </summary>
         /// <param name="name"></param>
         /// <param name="badChar"></param>
diff --git a/src/Shared/VersionUtilities.cs b/src/Shared/VersionUtilities.cs
index 399f1871b85..91c4721f00c 100644
--- a/src/Shared/VersionUtilities.cs
+++ b/src/Shared/VersionUtilities.cs
@@ -25,7 +25,7 @@ internal static Version ConvertToVersion(string version)
         }
 
         /// <summary>
-        /// Go though an enumeration and create a sorted list of strings which can be parsed as versions. Keep around the original 
+        /// Go though an enumeration and create a sorted list of strings which can be parsed as versions. Keep around the original
         /// string because it may contain a v and this would be required to create the correct path on disk if the string was part of a path.
         /// </summary>
         internal static SortedDictionary<Version, List<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions)
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index cf101e49ced..a188590d6fa 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -163,7 +163,7 @@ internal static bool IsValidMSBuildArchitectureValue(string architecture)
         }
 
         /// <summary>
-        /// Compares two members of MSBuildRuntimeValues, returning true if they count as a match, and false otherwise.  
+        /// Compares two members of MSBuildRuntimeValues, returning true if they count as a match, and false otherwise.
         /// </summary>
         internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
         {
@@ -171,7 +171,7 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
 
             if (runtimeA == null || runtimeB == null)
             {
-                // neither one cares, or only one cares, so they match by default. 
+                // neither one cares, or only one cares, so they match by default.
                 return true;
             }
 
@@ -183,7 +183,7 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
 
             if (runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase) || runtimeB.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase))
             {
-                // one or both explicitly don't care -- still a match. 
+                // one or both explicitly don't care -- still a match.
                 return true;
             }
 
@@ -199,14 +199,14 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
         }
 
         /// <summary>
-        /// Given two MSBuildRuntime values, returns the concrete result of merging the two.  If the merge fails, the merged runtime 
-        /// string is returned null, and the return value of the method is false.  Otherwise, if the merge succeeds, the method returns 
-        /// true with the merged runtime value.  E.g.: 
+        /// Given two MSBuildRuntime values, returns the concrete result of merging the two.  If the merge fails, the merged runtime
+        /// string is returned null, and the return value of the method is false.  Otherwise, if the merge succeeds, the method returns
+        /// true with the merged runtime value.  E.g.:
         /// "CLR4" + "CLR2" = null (false)
         /// "CLR2" + "don't care" = "CLR2" (true)
-        /// "current runtime" + "CLR4" = "CLR4" (true) 
+        /// "current runtime" + "CLR4" = "CLR4" (true)
         /// "current runtime" + "don't care" = "CLR4" (true)
-        /// If both specify "don't care", then defaults to the current runtime -- CLR4. 
+        /// If both specify "don't care", then defaults to the current runtime -- CLR4.
         /// A null or empty string is interpreted as "don't care".
         /// </summary>
         internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out string mergedRuntime)
@@ -226,7 +226,7 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
 
             string actualCurrentRuntime = GetCurrentMSBuildRuntime();
 
-            // if they're equal, then there's no problem -- just return the equivalent runtime.  
+            // if they're equal, then there's no problem -- just return the equivalent runtime.
             if (runtimeA.Equals(runtimeB, StringComparison.OrdinalIgnoreCase))
             {
                 if (runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
@@ -243,7 +243,7 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
             }
 
             // if both A and B are one of actual-current-runtime, don't care or current,
-            // then the end result will be current-runtime no matter what.  
+            // then the end result will be current-runtime no matter what.
             if (
                 (
                  runtimeA.Equals(actualCurrentRuntime, StringComparison.OrdinalIgnoreCase) ||
@@ -258,9 +258,9 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 return true;
             }
 
-            // If A doesn't care, then it's B -- and we can say B straight out, because if B were one of the 
-            // special cases (current runtime or don't care) then it would already have been caught in the 
-            // previous clause. 
+            // If A doesn't care, then it's B -- and we can say B straight out, because if B were one of the
+            // special cases (current runtime or don't care) then it would already have been caught in the
+            // previous clause.
             if (runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase))
             {
                 mergedRuntime = runtimeB;
@@ -274,13 +274,13 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 return true;
             }
 
-            // and now we've run out of things that it could be -- all the remaining options are non-matches.  
+            // and now we've run out of things that it could be -- all the remaining options are non-matches.
             mergedRuntime = null;
             return false;
         }
 
         /// <summary>
-        /// Compares two members of MSBuildArchitectureValues, returning true if they count as a match, and false otherwise.  
+        /// Compares two members of MSBuildArchitectureValues, returning true if they count as a match, and false otherwise.
         /// </summary>
         internal static bool ArchitectureValuesMatch(string architectureA, string architectureB)
         {
@@ -288,7 +288,7 @@ internal static bool ArchitectureValuesMatch(string architectureA, string archit
 
             if (architectureA == null || architectureB == null)
             {
-                // neither one cares, or only one cares, so they match by default. 
+                // neither one cares, or only one cares, so they match by default.
                 return true;
             }
 
@@ -300,7 +300,7 @@ internal static bool ArchitectureValuesMatch(string architectureA, string archit
 
             if (architectureA.Equals(MSBuildArchitectureValues.any, StringComparison.OrdinalIgnoreCase) || architectureB.Equals(MSBuildArchitectureValues.any, StringComparison.OrdinalIgnoreCase))
             {
-                // one or both explicitly don't care -- still a match. 
+                // one or both explicitly don't care -- still a match.
                 return true;
             }
 
@@ -318,9 +318,9 @@ internal static bool ArchitectureValuesMatch(string architectureA, string archit
 
         /// <summary>
         /// Given an MSBuildRuntime value that may be non-explicit -- e.g. "CurrentRuntime" or "Any" --
-        /// return the specific MSBuildRuntime value that it would map to in this case. If it does not map 
-        /// to any known runtime, just return it as is -- maybe someone else knows what to do with it; if 
-        /// not, they'll certainly have more context on logging or throwing the error. 
+        /// return the specific MSBuildRuntime value that it would map to in this case. If it does not map
+        /// to any known runtime, just return it as is -- maybe someone else knows what to do with it; if
+        /// not, they'll certainly have more context on logging or throwing the error.
         /// </summary>
         internal static string GetExplicitMSBuildRuntime(string runtime)
         {
@@ -333,21 +333,21 @@ internal static string GetExplicitMSBuildRuntime(string runtime)
             }
             else
             {
-                // either it's already a valid, specific runtime, or we don't know what to do with it.  Either way, return. 
+                // either it's already a valid, specific runtime, or we don't know what to do with it.  Either way, return.
                 return runtime;
             }
         }
 
         /// <summary>
-        /// Given two MSBuildArchitecture values, returns the concrete result of merging the two.  If the merge fails, the merged architecture 
-        /// string is returned null, and the return value of the method is false.  Otherwise, if the merge succeeds, the method returns 
-        /// true with the merged architecture value.  E.g.: 
+        /// Given two MSBuildArchitecture values, returns the concrete result of merging the two.  If the merge fails, the merged architecture
+        /// string is returned null, and the return value of the method is false.  Otherwise, if the merge succeeds, the method returns
+        /// true with the merged architecture value.  E.g.:
         /// "x86" + "x64" = null (false)
         /// "x86" + "don't care" = "x86" (true)
         /// "current architecture" + "x86" = "x86" (true) on a 32-bit process, and null (false) on a 64-bit process
         /// "current architecture" + "don't care" = "x86" (true) on a 32-bit process, and "x64" (true) on a 64-bit process
         /// A null or empty string is interpreted as "don't care".
-        /// If both specify "don't care", then defaults to whatever the current process architecture is.  
+        /// If both specify "don't care", then defaults to whatever the current process architecture is.
         /// </summary>
         internal static bool TryMergeArchitectureValues(string architectureA, string architectureB, out string mergedArchitecture)
         {
@@ -366,7 +366,7 @@ internal static bool TryMergeArchitectureValues(string architectureA, string arc
 
             string currentArchitecture = GetCurrentMSBuildArchitecture();
 
-            // if they're equal, then there's no problem -- just return the equivalent runtime.  
+            // if they're equal, then there's no problem -- just return the equivalent runtime.
             if (architectureA.Equals(architectureB, StringComparison.OrdinalIgnoreCase))
             {
                 if (architectureA.Equals(MSBuildArchitectureValues.currentArchitecture, StringComparison.OrdinalIgnoreCase) ||
@@ -382,7 +382,7 @@ internal static bool TryMergeArchitectureValues(string architectureA, string arc
                 return true;
             }
 
-            // if both A and B are one of CLR4, don't care, or current, then the end result will be CLR4 no matter what.  
+            // if both A and B are one of CLR4, don't care, or current, then the end result will be CLR4 no matter what.
             if (
                 (
                  architectureA.Equals(currentArchitecture, StringComparison.OrdinalIgnoreCase) ||
@@ -397,9 +397,9 @@ internal static bool TryMergeArchitectureValues(string architectureA, string arc
                 return true;
             }
 
-            // If A doesn't care, then it's B -- and we can say B straight out, because if B were one of the 
-            // special cases (current runtime or don't care) then it would already have been caught in the 
-            // previous clause. 
+            // If A doesn't care, then it's B -- and we can say B straight out, because if B were one of the
+            // special cases (current runtime or don't care) then it would already have been caught in the
+            // previous clause.
             if (architectureA.Equals(MSBuildArchitectureValues.any, StringComparison.OrdinalIgnoreCase))
             {
                 mergedArchitecture = architectureB;
@@ -413,16 +413,16 @@ internal static bool TryMergeArchitectureValues(string architectureA, string arc
                 return true;
             }
 
-            // and now we've run out of things that it could be -- all the remaining options are non-matches.  
+            // and now we've run out of things that it could be -- all the remaining options are non-matches.
             mergedArchitecture = null;
             return false;
         }
 
         /// <summary>
-        /// Returns the MSBuildArchitecture value corresponding to the current process' architecture. 
+        /// Returns the MSBuildArchitecture value corresponding to the current process' architecture.
         /// </summary>
         /// <comments>
-        /// Revisit if we ever run on something other than Intel.  
+        /// Revisit if we ever run on something other than Intel.
         /// </comments>
         internal static string GetCurrentMSBuildArchitecture()
         {
@@ -453,7 +453,7 @@ internal static string GetCurrentMSBuildArchitecture()
         }
 
         /// <summary>
-        /// Returns the MSBuildRuntime value corresponding to the current process' runtime. 
+        /// Returns the MSBuildRuntime value corresponding to the current process' runtime.
         /// </summary>
         internal static string GetCurrentMSBuildRuntime()
         {
@@ -466,9 +466,9 @@ internal static string GetCurrentMSBuildRuntime()
 
         /// <summary>
         /// Given an MSBuildArchitecture value that may be non-explicit -- e.g. "CurrentArchitecture" or "Any" --
-        /// return the specific MSBuildArchitecture value that it would map to in this case.  If it does not map 
-        /// to any known architecture, just return it as is -- maybe someone else knows what to do with it; if 
-        /// not, they'll certainly have more context on logging or throwing the error. 
+        /// return the specific MSBuildArchitecture value that it would map to in this case.  If it does not map
+        /// to any known architecture, just return it as is -- maybe someone else knows what to do with it; if
+        /// not, they'll certainly have more context on logging or throwing the error.
         /// </summary>
         internal static string GetExplicitMSBuildArchitecture(string architecture)
         {
@@ -481,7 +481,7 @@ internal static string GetExplicitMSBuildArchitecture(string architecture)
             }
             else
             {
-                // either it's already a valid, specific architecture, or we don't know what to do with it.  Either way, return. 
+                // either it's already a valid, specific architecture, or we don't know what to do with it.  Either way, return.
                 return architecture;
             }
         }
diff --git a/src/Shared/XamlUtilities.cs b/src/Shared/XamlUtilities.cs
index aad30eaa8b7..ffdecbf00e8 100644
--- a/src/Shared/XamlUtilities.cs
+++ b/src/Shared/XamlUtilities.cs
@@ -362,7 +362,7 @@ internal void Validate(this Rule type)
                 category.Validate();
             }
 
-            // If the DataSource property is not defined on this Rule, check that a DataSource is 
+            // If the DataSource property is not defined on this Rule, check that a DataSource is
             // specified locally on every property.
             if (null == type.DataSource)
             {
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index 27e32d603cb..35a48f18c71 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -129,8 +129,8 @@ internal static bool IsValidElementName(string name)
         }
 
         /// <summary>
-        /// Finds the location of the first invalid character, if any, in the name of an 
-        /// item, property, or piece of metadata. Returns the location of the first invalid character, or -1 if there are none. 
+        /// Finds the location of the first invalid character, if any, in the name of an
+        /// item, property, or piece of metadata. Returns the location of the first invalid character, or -1 if there are none.
         /// Valid names must match this pattern:  [A-Za-z_][A-Za-z_0-9\-.]*
         /// Note, this is a subset of all possible valid XmlElement names: we use a subset because we also
         /// have to match this same set in our regular expressions, and allowing all valid XmlElement name
diff --git a/src/StringTools/WeakStringCacheInterner.cs b/src/StringTools/WeakStringCacheInterner.cs
index dbf21b00b33..2eb3fd23231 100644
--- a/src/StringTools/WeakStringCacheInterner.cs
+++ b/src/StringTools/WeakStringCacheInterner.cs
@@ -119,7 +119,7 @@ public string InternableToString(ref InternableString candidate)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         public void EnableStatistics()
         {
diff --git a/src/Tasks.UnitTests/AspNetCompiler_Tests.cs b/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
index d0bbb4b1df0..bcc0f7c464b 100644
--- a/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
+++ b/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
@@ -239,7 +239,7 @@ public void AllParameters()
         }
 
         /// <summary>
-        /// Make sure AspNetCompiler sends ExternalProjectStarted/Finished events properly. The tasks will fail since 
+        /// Make sure AspNetCompiler sends ExternalProjectStarted/Finished events properly. The tasks will fail since
         /// the project files don't exist, but we only care about the events anyway.
         /// </summary>
         [Fact]
diff --git a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
index 49a843cbd54..5f0d4ad6f1a 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
@@ -32,7 +32,7 @@ public FilePrimary(ITestOutputHelper output) : base(output)
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -261,7 +261,7 @@ public void ExistsPromotedDependencyInTheDenyList()
         /// <summary>
         /// In this case,
         /// - A single primary file reference to assembly version 1.0.0.0 was passed in.
-        /// - An app.config was passed in that promotes a *different* assembly version name from 
+        /// - An app.config was passed in that promotes a *different* assembly version name from
         ///   1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of the file exists.
         /// - Version 2.0.0.0 of the file exists.
@@ -318,7 +318,7 @@ public void ExistsDifferentName()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -369,7 +369,7 @@ public void ExistsOldVersionRange()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -419,7 +419,7 @@ public void HighVersionDoesntExist()
         /// -- The resulting assembly returned should be 2.0.0.0.
         /// Rationale:
         /// There's no way for the resolve algorithm to determine that the file reference corresponds
-        /// to a particular AssemblyName. Because of this, there's no way to determine that we want to 
+        /// to a particular AssemblyName. Because of this, there's no way to determine that we want to
         /// promote from 0.5.0.0 to 2.0.0.0. In this case, just use the assembly name that was passed in.
         /// </summary>
         [Fact]
diff --git a/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs
index 33ab353147d..230080b2f31 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs
@@ -40,7 +40,7 @@ public NonSpecificVersionStrictPrimary(ITestOutputHelper output) : base(output)
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -87,7 +87,7 @@ public void Exists()
         /// <summary>
         /// In this case,
         /// - A single primary non-version-strict reference was passed in to assembly version 1.0.0.0
-        /// - An app.config was passed in that promotes a *different* assembly version name from 
+        /// - An app.config was passed in that promotes a *different* assembly version name from
         ///   1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of the file exists.
         /// - Version 2.0.0.0 of the file exists.
@@ -146,7 +146,7 @@ public void ExistsDifferentName()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -198,7 +198,7 @@ public void ExistsOldVersionRange()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -250,7 +250,7 @@ public void HighVersionDoesntExist()
         /// Rationale:
         /// Primary references are never unified--even those that don't exist on disk. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
index 1f29749f3b3..a27434df16c 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
@@ -32,7 +32,7 @@ public SpecificVersionPrimary(ITestOutputHelper output) : base(output)
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -84,7 +84,7 @@ public void Exists()
         /// <list type="bullet">
         /// <item>A single primary version-strict reference was passed in to assembly version 1.0.0.0</item>
         /// <item>
-        /// An app.config was passed in that promotes a *different* assembly version name from 
+        /// An app.config was passed in that promotes a *different* assembly version name from
         /// 1.0.0.0 to 2.0.0.0
         /// </item>
         /// <item>Version 1.0.0.0 of the file exists.</item>
@@ -99,7 +99,7 @@ public void Exists()
         /// <list type="number">
         /// <item>
         /// The user expects that a primary reference will be respected.</item>
-        /// <item>When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// <item>When FindDependencies is false and AutoUnify is true, we'd have to find all
         /// dependencies anyway to make things work consistently. This would be a significant
         /// perf hit when loading large solutions.
         /// </item>
@@ -153,7 +153,7 @@ public void ExistsDifferentName()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -205,7 +205,7 @@ public void ExistsOldVersionRange()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -257,7 +257,7 @@ public void HighVersionDoesntExist()
         /// Rationale:
         /// Primary references are never unified--even those that don't exist on disk. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
index 1960dba7a0b..1ef6412f355 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
@@ -95,7 +95,7 @@ public void Exists()
         /// - This should be an unresolved reference, we shouldn't fallback to the old version.
         /// Rationale:
         /// The fusion loader is going to want to respect the unified-to assembly. There's no point in
-        /// feeding it the wrong version, and the drawback is that builds would be different from 
+        /// feeding it the wrong version, and the drawback is that builds would be different from
         /// machine-to-machine.
         /// </summary>
         [Fact]
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
index d971ece54a5..eff546bcd3d 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
@@ -42,7 +42,7 @@ public StronglyNamedDependencyAutoUnify(ITestOutputHelper output) : base(output)
         /// Expected:
         /// - There should be exactly one UnifyMe dependency returned and it should be version 2.0.0.0.
         /// Rationale:
-        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly 
+        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly
         /// dependency seen.
         /// </summary>
         /// <param name="rarSimulationMode"></param>
@@ -100,11 +100,11 @@ internal void ExistsImpl(RARSimulationMode rarSimulationMode = RARSimulationMode
         /// - The AutoUnify flag is set to 'true'.
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        ///   - DependsOnUnified 2.0.0.0 is on the deny list. 
+        ///   - DependsOnUnified 2.0.0.0 is on the deny list.
         /// Expected:
         /// - There should be exactly one UnifyMe dependency returned and it should be version 1.0.0.0.
         /// Rationale:
-        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly 
+        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly
         /// dependency seen. However if the higher assembly is a dependency of an assembly in the deny list it should not be considered during unification.
         /// </summary>
         [Fact]
@@ -183,7 +183,7 @@ public void ExistsWithPrimaryReferenceOnDenyList()
         /// - There should be exactly one UnifyMe dependency returned and it should be version 1.0.0.0.
         ///  Also there should be a warning about the primary reference DependsOnUnified 2.0.0.0 having a dependency which was in the deny list.
         /// Rationale:
-        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly 
+        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly
         /// dependency seen. However if the higher assembly is a dependency of an assembly in the deny list it should not be considered during unification.
         /// </summary>
         [Fact]
@@ -260,7 +260,7 @@ public void ExistsPromotedDependencyInTheDenyList()
         /// - Version 2.0.0.0 of UnifyMe exists.
         ///   - UnifyMe 2.0.0.0 is on the deny list because it is higher than what is in the redist list, 1.0.0.0 is also in a deny list because it is not in the subset but is in the redist list.
         /// Expected:
-        /// - There should be no UnifyMe dependency returned 
+        /// - There should be no UnifyMe dependency returned
         /// There should be a warning indicating the primary reference DependsOnUnified 1.0.0.0 has a dependency that in the deny list
         /// There should be a warning indicating the primary reference DependsOnUnified 2.0.0.0 has a dependency that in the deny list
         /// </summary>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
index e7219ac8973..9ab178efbb5 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
@@ -19,7 +19,7 @@
 namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
 {
     /// <summary>
-    /// Unit tests for the ResolveAssemblyReference task that involve, among other things, checking suggested redirects 
+    /// Unit tests for the ResolveAssemblyReference task that involve, among other things, checking suggested redirects
     /// </summary>
     public sealed class SuggestedRedirects : ResolveAssemblyReferenceTestFixture
     {
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index 915bf102943..e26e33a7668 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -175,7 +175,7 @@ public void DoubleDot()
 
         /// <summary>
         /// If an item has a "DependentUpon" who's base name matches exactly, then just assume this
-        /// is a resource and form that happen to have an embedded culture. That is, don't assign a 
+        /// is a resource and form that happen to have an embedded culture. That is, don't assign a
         /// culture to these.
         /// </summary>
         [Fact]
diff --git a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
index f4fa9b32284..21d76883bf3 100644
--- a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
+++ b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
@@ -37,7 +37,7 @@ public void NoItems()
         }
 
         /// <summary>
-        /// AssignLinkMetadata should behave nicely when there is an item with an 
+        /// AssignLinkMetadata should behave nicely when there is an item with an
         /// itemspec that contains invalid path characters.
         /// </summary>
         [Fact]
@@ -76,14 +76,14 @@ public void Basic()
             Assert.Single(t.OutputItems);
             Assert.Equal(item.ItemSpec, t.OutputItems[0].ItemSpec);
 
-            // Link metadata should have been added by the task, and OriginalItemSpec was added by the copy 
+            // Link metadata should have been added by the task, and OriginalItemSpec was added by the copy
             Assert.Equal(item.MetadataCount + 2, t.OutputItems[0].MetadataCount);
             Assert.Equal(Path.Combine("SubFolder", "a.cs"), t.OutputItems[0].GetMetadata("Link"));
         }
 
         /// <summary>
-        /// AssignLinkMetadata should behave nicely when there is an item with an 
-        /// itemspec that contains invalid path characters, and still successfully 
+        /// AssignLinkMetadata should behave nicely when there is an item with an
+        /// itemspec that contains invalid path characters, and still successfully
         /// output any items that aren't problematic.
         /// </summary>
         [Fact]
@@ -103,7 +103,7 @@ public void InvalidItemPathWithOtherValidItem()
             Assert.Single(t.OutputItems);
             Assert.Equal(item2.ItemSpec, t.OutputItems[0].ItemSpec);
 
-            // Link metadata should have been added by the task, and OriginalItemSpec was added by the copy 
+            // Link metadata should have been added by the task, and OriginalItemSpec was added by the copy
             Assert.Equal(item2.MetadataCount + 2, t.OutputItems[0].MetadataCount);
             Assert.Equal(Path.Combine("SubFolder", "a.cs"), t.OutputItems[0].GetMetadata("Link"));
         }
@@ -128,7 +128,7 @@ public void DontOverrideLink()
         }
 
         /// <summary>
-        /// AssignLinkMetadata should not set Link if the item is outside the 
+        /// AssignLinkMetadata should not set Link if the item is outside the
         /// defining project's cone
         /// </summary>
         [Fact]
diff --git a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
index 9965648369b..4b0c881cead 100644
--- a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
+++ b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
@@ -192,7 +192,7 @@ public void KeyFileWithSpaces()
         }
 
         /// <summary>
-        /// Tests the SdkToolsPath property:  Should log an error if it's null or a bad path.  
+        /// Tests the SdkToolsPath property:  Should log an error if it's null or a bad path.
         /// </summary>
         [Fact]
         public void SdkToolsPath()
@@ -226,7 +226,7 @@ public void SdkToolsPath()
         }
 
         /// <summary>
-        /// Tests the ToolPath property:  Should log an error if it's null or a bad path.  
+        /// Tests the ToolPath property:  Should log an error if it's null or a bad path.
         /// </summary>
         [Fact]
         public void ToolPath()
@@ -286,13 +286,13 @@ public void TaskFailsWhenImproperlySigned()
                 t.KeyFile = tempKeyFile;
                 Utilities.ExecuteTaskAndVerifyLogContainsErrorFromResource(t, "AxTlbBaseTask.CannotSpecifyBothKeyFileAndKeyContainer");
 
-                // All the inputs are correct, but the KeyContainer passed in is bad            
+                // All the inputs are correct, but the KeyContainer passed in is bad
                 t.DelaySign = false;
                 t.KeyContainer = tempKeyContainer;
                 t.KeyFile = null;
                 Utilities.ExecuteTaskAndVerifyLogContainsErrorFromResource(t, "AxTlbBaseTask.StrongNameUtils.NoKeyPairInContainer", t.KeyContainer);
 
-                // All the inputs are correct, but the KeyFile passed in is bad            
+                // All the inputs are correct, but the KeyFile passed in is bad
                 t.KeyContainer = null;
                 t.KeyFile = tempKeyFile;
                 Utilities.ExecuteTaskAndVerifyLogContainsErrorFromResource(t, "AxTlbBaseTask.StrongNameUtils.NoKeyPairInFile", t.KeyFile);
@@ -316,7 +316,7 @@ internal sealed class Utilities
         /// <summary>
         /// Given an instance of an AxImp task, executes that task (assuming all necessary parameters
         /// have been set ahead of time) and verifies that the execution log contains the error
-        /// corresponding to the resource name passed in. 
+        /// corresponding to the resource name passed in.
         /// </summary>
         /// <param name="t">The task to execute and check</param>
         /// <param name="errorResource">The name of the resource string to check the log for</param>
@@ -349,7 +349,7 @@ internal static void VerifyLogContainsErrorFromResource(MockEngine e, TaskLoggin
         /// <summary>
         /// Given an instance of an AxImp task, executes that task (assuming all necessary parameters
         /// have been set ahead of time) and verifies that the execution log does not contain the error
-        /// corresponding to the resource name passed in. 
+        /// corresponding to the resource name passed in.
         /// </summary>
         /// <param name="t">The task to execute and check</param>
         /// <param name="errorResource">The name of the resource string to check the log for</param>
diff --git a/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs b/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
index abcd1bfa727..ffcc07f3f19 100644
--- a/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
+++ b/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
@@ -289,7 +289,7 @@ public void PreprocessorControllingTwoNamespaces()
 namespace n1
 #else
 namespace n2
-#endif    
+#endif
 { class c {} }
                 ", "n2.c");
         }
@@ -328,7 +328,7 @@ namespace n1
 #else
 using a=b;
 namespace n2
-#endif    
+#endif
 { class c {} }", "n2.c")]
         [InlineData(@"
 #if (false)
@@ -336,7 +336,7 @@ namespace n1;
 #else
 using a=b;
 namespace n2;
-#endif    
+#endif
 { class c {} }", "n1.n2.c")]
         public void PreprocessorControllingTwoNamespacesWithInterveningKeyword(string fileContents, string expected)
         {
@@ -345,23 +345,23 @@ public void PreprocessorControllingTwoNamespacesWithInterveningKeyword(string fi
 
         [Theory]
         [InlineData(@"
-#if MY_CONSTANT                
-namespace i 
+#if MY_CONSTANT
+namespace i
 {
     #region Put the class in a region
-    class a 
+    class a
     {
-    }     
+    }
     #endregion
 }
 #endif // MY_CONSTANT ")]
         [InlineData(@"
-#if MY_CONSTANT                
+#if MY_CONSTANT
 namespace i;
     #region Put the class in a region
-    class a 
+    class a
     {
-    }     
+    }
     #endregion
 #endif // MY_CONSTANT")]
         public void Preprocessor(string fileContents)
@@ -374,15 +374,15 @@ public void PreprocessorNamespaceInFalsePreprocessorBlock()
         {
             AssertParse(
                 @"
-#if (false)             
-namespace i 
+#if (false)
+namespace i
 {
 #endif
-    class a 
+    class a
     {
-    }     
-#if (false)             
-namespace i 
+    }
+#if (false)
+namespace i
 }
 #endif
                 ", "a");
diff --git a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
index f9613d173c6..23adb6a34b1 100644
--- a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
+++ b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
@@ -40,7 +40,7 @@ public sealed class CSharpTokenizerTests
             Special whitespace handling.
                 Horizontal tab character (U+0009)
                 Vertical tab character (U+000B)
-                Form feed character (U+000C)  
+                Form feed character (U+000C)
         */
         [Fact]
         public void SpecialWhitespace() { AssertTokenize("\x09\x0b\x0c\x0d", ".Whitespace"); }
@@ -75,15 +75,15 @@ Form feed character (U+000C)
         [Fact]
         public void LeftHalfOfUnbalanceMultilineCommentWithStuff() { AssertTokenize("/* unbalanced\x0d", ".EndOfFileInsideComment"); }
 
-        // If the last character of the source file is a Control-Z character (U+001A), this character is deleted. 
+        // If the last character of the source file is a Control-Z character (U+001A), this character is deleted.
         [Fact]
         public void NothingPlustControlZatEOF() { AssertTokenize("\x1A", "", "", 0); }
         [Fact]
         public void SomethingPlusControlZatEOF() { AssertTokenize("// My comment\x1A", "// My comment\x0d", ".Comment.Whitespace"); }
 
-        // A carriage-return character (U+000D) is added to the end of the source file if that source file is non-empty and if the last character 
-        // of the source file is not a carriage return (U+000D), a line feed (U+000A), a line separator (U+2028), or a paragraph separator 
-        // (U+2029). 
+        // A carriage-return character (U+000D) is added to the end of the source file if that source file is non-empty and if the last character
+        // of the source file is not a carriage return (U+000D), a line feed (U+000A), a line separator (U+2028), or a paragraph separator
+        // (U+2029).
         [Fact]
         public void NoEOLatEOF() { AssertTokenize("// My comment", "// My comment\x0d", ".Comment.Whitespace"); }
         [Fact]
@@ -110,7 +110,7 @@ public void NamespacePlusClass()
              ".Keyword.Whitespace.Identifier.Whitespace.OpenScope.Whitespace.Keyword.Whitespace.Identifier.Whitespace.OpenScope.CloseScope.Whitespace.CloseScope.Whitespace");
         }
 
-        // If a keyword has '@' in front, then its treated as an identifier. 
+        // If a keyword has '@' in front, then its treated as an identifier.
         [Fact]
         public void EscapedKeywordMakesIdentifier()
         {
@@ -138,7 +138,7 @@ public void EscapedKeywordMakesIdentifier()
         [Fact]
         public void InvalidHexIntegerWithNoneValid() { AssertTokenize("0xG\x0d", ".ExpectedValidHexDigit"); }
 
-        // Hex literal long suffix: U u L l UL Ul uL ul LU Lu lU lu 
+        // Hex literal long suffix: U u L l UL Ul uL ul LU Lu lU lu
         [Fact]
         public void HexIntegerLiteralUpperU() { AssertTokenize("0x123FU\x0d", ".HexIntegerLiteral.Whitespace"); }
         [Fact]
@@ -162,7 +162,7 @@ public void EscapedKeywordMakesIdentifier()
         [Fact]
         public void HexIntegerLiteralLowerLLowerU() { AssertTokenize("0x123Flu\x0d", ".HexIntegerLiteral.Whitespace"); }
 
-        // Decimal literal long suffix: U u L l UL Ul uL ul LU Lu lU lu 
+        // Decimal literal long suffix: U u L l UL Ul uL ul LU Lu lU lu
         [Fact]
         public void DecimalIntegerLiteralUpperU() { AssertTokenize("1234U\x0d", ".DecimalIntegerLiteral.Whitespace"); }
         [Fact]
@@ -241,9 +241,9 @@ public void EscapedKeywordMakesIdentifier()
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated 
+        * Also, the source must be regenerated exactly when the tokens are concatenated
         * back together,
         */
         private static void AssertTokenize(string source, string expectedTokenKey)
@@ -254,9 +254,9 @@ private static void AssertTokenize(string source, string expectedTokenKey)
 
         /*
         * Method:  AssertTokenizeUnicode
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated 
+        * Also, the source must be regenerated exactly when the tokens are concatenated
         * back together,
         */
         private static void AssertTokenizeUnicode(string source, string expectedTokenKey)
@@ -267,9 +267,9 @@ private static void AssertTokenizeUnicode(string source, string expectedTokenKey
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated 
+        * Also, the source must be regenerated exactly when the tokens are concatenated
         * back together,
         */
         private static void AssertTokenize(
@@ -283,9 +283,9 @@ private static void AssertTokenize(
 
         /*
         * Method:  AssertTokenizeUnicode
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated 
+        * Also, the source must be regenerated exactly when the tokens are concatenated
         * back together,
         */
         private static void AssertTokenizeUnicode(
@@ -299,7 +299,7 @@ private static void AssertTokenizeUnicode(
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
         * Also compare the source that is regenerated by concatenating all of the tokens
         * to 'expectedSource'.
@@ -315,7 +315,7 @@ private static void AssertTokenize(
 
         /*
         * Method:  AssertTokenizeUnicode
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
         * Also compare the source that is regenerated by concatenating all of the tokens
         * to 'expectedSource'.
@@ -331,7 +331,7 @@ private static void AssertTokenizeUnicode(
 
         /*
         * Method:  AssertTokenizeUnicode
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
         * Also compare the source that is regenerated by concatenating all of the tokens
         * to 'expectedSource'.
@@ -351,7 +351,7 @@ private static void AssertTokenizeUnicode(
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
         * Also compare the source that is regenerated by concatenating all of the tokens
         * to 'expectedSource'.
@@ -363,7 +363,7 @@ private static void AssertTokenize(
            int expectedLastLineNumber)
         {
             // This version of AssertTokenize tests several different encodings.
-            // The reason is that we want to be sure each of these works in the 
+            // The reason is that we want to be sure each of these works in the
             // various encoding formats supported by C#
             AssertTokenizeStream(StreamHelpers.StringToStream(source), expectedSource, expectedTokenKey, expectedLastLineNumber);
             AssertTokenizeStream(StreamHelpers.StringToStream(source, System.Text.Encoding.Unicode), expectedSource, expectedTokenKey, expectedLastLineNumber);
@@ -375,7 +375,7 @@ private static void AssertTokenize(
 
         /*
          * Method:  AssertTokenizeStream
-         * 
+         *
          * Tokenize a string ('source') and compare it to the expected set of tokens.
          * Also compare the source that is regenerated by concatenating all of the tokens
          * to 'expectedSource'.
diff --git a/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs b/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
index 689a15dbb70..8630c8025fb 100644
--- a/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
+++ b/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
@@ -186,7 +186,7 @@ public void IgnoreKnownOleTypes()
 
             // We don't check for this type in the ComDependencyWalker, so it doesn't get counted as a known OLE type.
             // It's too late in the Dev10 cycle to add it to shipping code without phenomenally good reason, but we should
-            // re-examine this in Dev11.  
+            // re-examine this in Dev11.
             // oleTypeLib.AddTypeInfo(new MockTypeInfo(TYPEKIND.TKIND_ENUM));
 
             foreach (MockTypeInfo typeInfo in oleTypeLib.ContainedTypeInfos)
@@ -296,7 +296,7 @@ private void RunDependencyWalkerFaultInjection(MockTypeLibrariesFailurePoints fa
             walker.AnalyzeTypeLibrary(mainTypeLib);
 
             // Did the current failure point get hit for this test? If not then no point in checking anything
-            // The previous test (FaultInjectionMainLib) ensures that all defined failure points actually 
+            // The previous test (FaultInjectionMainLib) ensures that all defined failure points actually
             // cause some sort of trouble
             if (walker.EncounteredProblems.Count > 0)
             {
diff --git a/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs b/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
index 97b019804eb..e60d67c1f9e 100644
--- a/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
+++ b/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
@@ -18,7 +18,7 @@ public sealed class CommandLineBuilderExtensionTest
         /*
         * Method:   AppendItemWithInvalidBooleanAttribute
         *
-        * When appending an ITaskItem[] where some of the flags are 'bool', it's possible that 
+        * When appending an ITaskItem[] where some of the flags are 'bool', it's possible that
         * the boolean flag has a string value that cannot be converted to a boolean. In this
         * case we expect an exception.
         */
diff --git a/src/Tasks.UnitTests/CommandLine_Support.cs b/src/Tasks.UnitTests/CommandLine_Support.cs
index 36ca55794f3..97a7d57f2ec 100644
--- a/src/Tasks.UnitTests/CommandLine_Support.cs
+++ b/src/Tasks.UnitTests/CommandLine_Support.cs
@@ -102,7 +102,7 @@ internal static int ValidateHasParameter(ToolTaskExtension t, string parameter,
         }
 
         /// <summary>
-        /// Validates that the given ToolTaskExtension's command line does not contain 
+        /// Validates that the given ToolTaskExtension's command line does not contain
         /// any parameter starting with the given string.
         /// </summary>
         /// <param name="t">task to get the command line from</param>
@@ -114,7 +114,7 @@ internal static void ValidateNoParameterStartsWith(ToolTaskExtension t, string s
         }
 
         /// <summary>
-        /// Validates that the given ToolTaskExtension's command line does not contain 
+        /// Validates that the given ToolTaskExtension's command line does not contain
         /// any parameter starting with the given string.
         /// </summary>
         /// <param name="t">task to get the command line from</param>
@@ -125,7 +125,7 @@ internal static void ValidateNoParameterStartsWith(ToolTaskExtension t, string s
         }
 
         /// <summary>
-        /// Validates that the given ToolTaskExtension's command line does not contain 
+        /// Validates that the given ToolTaskExtension's command line does not contain
         /// any parameter starting with the given string.
         /// </summary>
         /// <param name="t">task to get the command line from</param>
@@ -137,7 +137,7 @@ internal static void ValidateNoParameterStartsWith(ToolTaskExtension t, string s
         }
 
         /// <summary>
-        /// Validates that the given ToolTaskExtension's command line does not contain 
+        /// Validates that the given ToolTaskExtension's command line does not contain
         /// any parameter starting with the given string.
         /// </summary>
         /// <param name="t">task to get the command line from</param>
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index ab9c9fbc182..fd10c03db4b 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -756,7 +756,7 @@ namespace ClassLibrary2
 namespace ClassLibrary3
 #endif
 {
-    class MyForm 
+    class MyForm
     {
     }
 }"),
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index 884509b1b86..d22cd676005 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -41,8 +41,8 @@ public void Basic()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -67,8 +67,8 @@ public void RelativeDependentUpon()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace TestNamespace 
-    Class TestClass 
+Namespace TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -93,8 +93,8 @@ public void AbsoluteDependentUpon()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -119,8 +119,8 @@ public void DependentWithCulture()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -146,8 +146,8 @@ public void DependentWithCultureMetadata()
                     culture: "en-GB",
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -172,8 +172,8 @@ public void DependentWithCultureAndRootNamespace()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -198,8 +198,8 @@ public void DependentWithEmbeddedCulture()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -417,8 +417,8 @@ private Stream CreateFileStream(string path, FileMode mode, FileAccess access)
             {
                 return StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 ");
@@ -454,7 +454,7 @@ public void Regress419591()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-    Class MyForm 
+    Class MyForm
     End Class
 "),
                     log: null);
@@ -492,8 +492,8 @@ Namespace ClassLibrary1
 Namespace ClassLibrary2
 #else
 Namespace ClassLibrary3
-#end if 
-    Class MyForm 
+#end if
+    Class MyForm
     End Class
 End Namespace
 "),
diff --git a/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs b/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
index 569192d3c57..acf917a4483 100644
--- a/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
+++ b/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
@@ -253,8 +253,8 @@ public void ErrorFromResources()
         }
 
         /// <summary>
-        /// If a "Code" is passed to the task, use it to override the code 
-        /// (if any) defined in the error message. 
+        /// If a "Code" is passed to the task, use it to override the code
+        /// (if any) defined in the error message.
         /// </summary>
         [Fact]
         public void ErrorFromResourcesWithOverriddenCode()
@@ -281,7 +281,7 @@ public void ErrorFromResourcesWithOverriddenCode()
         }
 
         /// <summary>
-        /// Simple case of logging a resource-based error that takes 
+        /// Simple case of logging a resource-based error that takes
         /// arguments
         /// </summary>
         [Fact]
@@ -308,8 +308,8 @@ public void ErrorFromResourcesWithArguments()
         }
 
         /// <summary>
-        /// If invalid arguments are passed to the task, it should still 
-        /// log an error informing the user of that. 
+        /// If invalid arguments are passed to the task, it should still
+        /// log an error informing the user of that.
         /// </summary>
         [Fact]
         public void ErrorFromResourcesWithInvalidArguments()
@@ -335,8 +335,8 @@ public void ErrorFromResourcesWithInvalidArguments()
         }
 
         /// <summary>
-        /// If no resource string is passed to ErrorFromResources, we should error 
-        /// because a required parameter is missing. 
+        /// If no resource string is passed to ErrorFromResources, we should error
+        /// because a required parameter is missing.
         /// </summary>
         [Fact]
         public void ErrorFromResourcesNoResources()
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index cb468a6ccea..586126a3f94 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -896,7 +896,7 @@ public void ConsoleToMSBuild()
         }
 
         /// <summary>
-        /// Test the CanEncode method with and without ANSI characters to determine if they can be encoded 
+        /// Test the CanEncode method with and without ANSI characters to determine if they can be encoded
         /// in the current system encoding.
         /// </summary>
         [WindowsOnlyFact]
diff --git a/src/Tasks.UnitTests/FormatUrl_Tests.cs b/src/Tasks.UnitTests/FormatUrl_Tests.cs
index 5260d22e642..26fabaf9db5 100644
--- a/src/Tasks.UnitTests/FormatUrl_Tests.cs
+++ b/src/Tasks.UnitTests/FormatUrl_Tests.cs
@@ -107,7 +107,7 @@ public void UncPathTest()
 
         /// <summary>
         /// The URL to format is a local absolute file path.
-        /// This test uses Environment.CurrentDirectory to have a file path value appropriate to the current OS/filesystem. 
+        /// This test uses Environment.CurrentDirectory to have a file path value appropriate to the current OS/filesystem.
         /// </summary>
         [Fact]
         public void LocalAbsolutePathTest()
@@ -122,7 +122,7 @@ public void LocalAbsolutePathTest()
 
         /// <summary>
         /// The URL to format is a local relative file path.
-        /// This test uses Environment.CurrentDirectory to have a file path value appropriate to the current OS/filesystem. 
+        /// This test uses Environment.CurrentDirectory to have a file path value appropriate to the current OS/filesystem.
         /// </summary>
         [Fact]
         public void LocalRelativePathTest()
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index 30545d61a74..a417cabd783 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -151,7 +151,7 @@ public void GenerateBindingRedirectsFromTwoDependentAssemblySections()
 
         /// <summary>
         /// In this case,
-        /// - An app.config is passed in that has dependentAssembly section with probing element but without 
+        /// - An app.config is passed in that has dependentAssembly section with probing element but without
         ///   assemblyIdentity or bindingRedirect elements.
         /// Expected:
         /// - No warning
@@ -165,7 +165,7 @@ public void AppConfigWithProbingPathAndWithoutDependentAssemblyShouldNotProduceW
             // Arrange
             string appConfigFile = WriteAppConfigRuntimeSection(
 @"<assemblyBinding xmlns=""urn:schemas-microsoft-com:asm.v1"">
-   <probing privatePath = 'bin;bin2\subbin;bin3'/>  
+   <probing privatePath = 'bin;bin2\subbin;bin3'/>
 </assemblyBinding>");
             TaskItemMock redirect = new TaskItemMock("System, Version=10.0.0.0, Culture=Neutral, PublicKeyToken='b77a5c561934e089'", "40.0.0.0");
 
@@ -191,7 +191,7 @@ public void AppConfigWithEmptyAssemblyBindingShouldNotProduceWarnings()
         {
             // Arrange
             string appConfigFile = WriteAppConfigRuntimeSection(
-@"<assemblyBinding xmlns=""urn:schemas-microsoft-com:asm.v1"" appliesTo=""v1.0.3705""> 
+@"<assemblyBinding xmlns=""urn:schemas-microsoft-com:asm.v1"" appliesTo=""v1.0.3705"">
 </assemblyBinding>");
             TaskItemMock redirect = new TaskItemMock("System, Version=10.0.0.0, Culture=Neutral, PublicKeyToken='b77a5c561934e089'", "40.0.0.0");
 
diff --git a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
index ad5535b8991..040199f9fb9 100644
--- a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
+++ b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
@@ -84,7 +84,7 @@ private static string MakeFakeSDKStructure()
                     Path.Combine(
                         new[] { tempPath, "Windows", "NotAVersion", "ExtensionSDKs", "Assembly", "1.0" }));
 
-                // Good but are in a different target platform 
+                // Good but are in a different target platform
                 // Doors does not have an sdk manifest but does have extensionsdks under it so they should be found
                 // when we are targeting doors
                 Directory.CreateDirectory(
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index f8dcf89bbfe..ad1ab81787a 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -498,7 +498,7 @@ public void DifferentGlobalPropertiesWithDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -556,7 +556,7 @@ public void DifferentGlobalPropertiesWithoutDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -612,7 +612,7 @@ public void DifferentGlobalPropertiesWithBlanks()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -667,7 +667,7 @@ public void DifferentGlobalPropertiesInvalid()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -716,7 +716,7 @@ public void DifferentAdditionalPropertiesWithDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyPropG)'=='1'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyPropA)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -771,7 +771,7 @@ public void DifferentAdditionalPropertiesWithGlobalProperties()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyPropG)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyPropA)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -829,7 +829,7 @@ public void DifferentAdditionalPropertiesWithoutDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyPropG)'=='1'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyPropA)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -1375,7 +1375,7 @@ public void TargetNameIsCaseInsensitive()
                 ");
 
             string projectFile2 = ObjectModelHelpers.CreateTempFileOnDisk(@"
-                <Project DefaultTargets=`t` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>                  
+                <Project DefaultTargets=`t` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <Target Name=`t`>
                         <MSBuild Projects=`" + projectFile1 + @"` Targets=`BUILD`>
                             <Output TaskParameter=`TargetOutputs` ItemName=`out`/>
@@ -1468,7 +1468,7 @@ public void MSBuildTaskPassesTaskIdToSpawnedBuilds()
                 <Project>
                     <Target Name=`Build`>
                         <MSBuild Projects=`" + projectFile1 + @"` Targets=`Build` />
-                    </Target>	
+                    </Target>
                 </Project>");
 
             try
diff --git a/src/Tasks.UnitTests/MockTypeInfo.cs b/src/Tasks.UnitTests/MockTypeInfo.cs
index aabf7050f11..140e6f596ca 100644
--- a/src/Tasks.UnitTests/MockTypeInfo.cs
+++ b/src/Tasks.UnitTests/MockTypeInfo.cs
@@ -47,7 +47,7 @@ public TYPEDESC CreateTypeDesc(IntPtr finalTypeHRef, MockUnmanagedMemoryHelper m
         }
 
         /// <summary>
-        /// Defer to the base element to get the final type info - this will eventually terminate at a MockTypeInfo node 
+        /// Defer to the base element to get the final type info - this will eventually terminate at a MockTypeInfo node
         /// which returns itself
         /// </summary>
         /// <returns></returns>
@@ -282,7 +282,7 @@ void IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out IFixedTypeInfo ppTI)
             }
         }
 
-        #endregion 
+        #endregion
 
         #region Implemented ITypeInfo members
 
diff --git a/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs b/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs
index 5adffb71e6e..4d561e798b0 100644
--- a/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs
+++ b/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs
@@ -17,7 +17,7 @@ public class MockUnmanagedMemoryHelper
     {
         private List<IntPtr> _allocatedHandles;
 
-        // Zero if we're allocating independent chunks of memory; 
+        // Zero if we're allocating independent chunks of memory;
         // Something else if we're allocating connected chunks of memory that we'll want to release with one ReleaseHandle
         private IntPtr _mainAllocationHandle = IntPtr.Zero;
 
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index 5c14b9ad86a..ca8bee21b50 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -302,8 +302,8 @@ public void MoveOverExistingFileDestinationWriteable()
         /// <summary>
         /// Move should overwrite any destination file even if it's not r/o
         /// if OverwriteReadOnlyFiles is set.
-        /// 
-        /// This is a regression test for bug 814744 where a move operation with OverwriteReadonlyFiles = true on a destination file with the readonly 
+        ///
+        /// This is a regression test for bug 814744 where a move operation with OverwriteReadonlyFiles = true on a destination file with the readonly
         /// flag not set caused the readonly flag to be set before the move which caused the move to fail.
         /// </summary>
         [Fact]
@@ -411,7 +411,7 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
         }
 
         /// <summary>
-        /// MovedFiles should only include files that were successfully moved 
+        /// MovedFiles should only include files that were successfully moved
         /// (or skipped), not files for which there was an error.
         /// </summary>
         [WindowsOnlyFact(additionalMessage: "Under Unix all filenames are valid and this test is not useful.")]
@@ -777,7 +777,7 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
 
         /// <summary>
         /// If the destination path is too long, the task should not bubble up
-        /// the System.IO.PathTooLongException 
+        /// the System.IO.PathTooLongException
         /// </summary>
         [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
@@ -813,7 +813,7 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
 
         /// <summary>
         /// If the source path is too long, the task should not bubble up
-        /// the System.IO.PathTooLongException 
+        /// the System.IO.PathTooLongException
         /// </summary>
         [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
diff --git a/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs b/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
index f7b76379327..689c4f7f1aa 100644
--- a/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
+++ b/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
@@ -64,9 +64,9 @@ public void Basic()
         }
 
         /// <summary>
-        /// Write one line, read one line, where the line contains MSBuild-escapable characters.  
-        /// The file should contain the *unescaped* lines, but no escaping information should be 
-        /// lost when read. 
+        /// Write one line, read one line, where the line contains MSBuild-escapable characters.
+        /// The file should contain the *unescaped* lines, but no escaping information should be
+        /// lost when read.
         /// </summary>
         [Fact]
         public void Escaping()
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 2bce4b5064f..47fb7e3c853 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -85,7 +85,7 @@ public void TestSerializationAndDeserialization()
 
         /*
          * Method:  CheckComReferenceAttributeVerificationForNameItems
-         * 
+         *
          * Checks if verification of Com reference item metadata works properly
          */
         [Fact]
@@ -148,7 +148,7 @@ public void CheckComReferenceMetadataVerificationForNameItems()
 
         /*
          * Method:  CheckComReferenceAttributeInitializationForNameItems
-         * 
+         *
          * Checks if missing optional attributes for COM name references get initialized correctly
          */
         [Fact]
@@ -181,7 +181,7 @@ public void CheckComReferenceMetadataInitializationForNameItems()
 
         /*
          * Method:  CheckComReferenceAttributeInitializationForFileItems
-         * 
+         *
          * Checks if missing optional attributes for COM file references get initialized correctly
          */
         [Fact]
@@ -395,7 +395,7 @@ public void CheckIsExistingDependencyReference()
             retValue = rcr.IsExistingDependencyReference(notInProjectAttr, out referenceInfo);
             Assert.True(!retValue && referenceInfo == null); // "not in project ref should not be found"
 
-            // Now, try to resolve a non-existent ComAssemblyReference. 
+            // Now, try to resolve a non-existent ComAssemblyReference.
             string path;
             IComReferenceResolver resolver = (IComReferenceResolver)rcr;
             Assert.False(resolver.ResolveComAssemblyReference("MyAssembly", out path));
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index fd2d6460e19..f0733ffb15c 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -3733,7 +3733,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists()
                 APPX ='AppxLocation'
                 SDKType ='External'
                 DisplayName = 'AnotherSDkWithManifest 2.0'
-                CopyRedistToSubDirectory='SomeOtherRedistDirectory'> 
+                CopyRedistToSubDirectory='SomeOtherRedistDirectory'>
                 <File WinMD = 'AnotherSDkWithManifest.Sprint, Version=8.0' />
                 <File AssemblyName = 'Assembly1, Version=8.0' />
                 <DependsOn Identity='Windows SDK, Version 8.0'/>
@@ -3755,7 +3755,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists()
                  <PropertyGroup>
                      <Configuration>CAT</Configuration>" +
                     @"<OutputPath>" + testDirectoryRoot + "</OutputPath>" +
-                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier> 
+                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier>
                     <TargetPlatformVersion>8.0</TargetPlatformVersion>
                  </PropertyGroup>
                  <Import Project=""$(MSBuildBinPath)\Microsoft.Common.targets""/>
@@ -3896,7 +3896,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists2()
                  <PropertyGroup>
                      <Configuration>CAT</Configuration>" +
                     @"<OutputPath>" + testDirectoryRoot + "</OutputPath>" +
-                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier> 
+                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier>
                     <TargetPlatformVersion>8.0</TargetPlatformVersion>
                  </PropertyGroup>
                  <Import Project=""$(MSBuildBinPath)\Microsoft.Common.targets""/>
@@ -4018,7 +4018,7 @@ public void GatherSDKOutputGroupsTargetArchitectureDoesNotExists()
                  <PropertyGroup>
                       <Configuration>CAT</Configuration>" +
                     @"<OutputPath>" + testDirectoryRoot + "</OutputPath>" +
-                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier> 
+                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier>
                     <TargetPlatformVersion>8.0</TargetPlatformVersion>
                  </PropertyGroup>
                  <Import Project=""$(MSBuildBinPath)\Microsoft.Common.targets""/>
@@ -4123,7 +4123,7 @@ public void CheckDefaultingOfTargetConfigAndArchitecture()
                  <PropertyGroup>
                     <Configuration>CAT</Configuration>" +
                     @"<OutputPath>" + testDirectoryRoot + "</OutputPath>" +
-                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier> 
+                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier>
                     <TargetPlatformVersion>8.0</TargetPlatformVersion>
                  </PropertyGroup>
                  <Import Project=""$(MSBuildBinPath)\Microsoft.Common.targets""/>
@@ -4262,7 +4262,7 @@ public void CheckAttributesFromManifestArePassedToResolvedAssemblies()
                  <PropertyGroup>
                     <Configuration>CAT</Configuration>" +
                     @"<OutputPath>" + testDirectoryRoot + "</OutputPath>" +
-                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier> 
+                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier>
                     <TargetPlatformVersion>8.0</TargetPlatformVersion>
                  </PropertyGroup>
                  <Import Project=""$(MSBuildBinPath)\Microsoft.Common.targets""/>
diff --git a/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs
index 4364e17ff36..cad5a044c90 100644
--- a/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs
@@ -32,9 +32,9 @@ internal void VerifyVCProjectOutputs(string vcProjectContents, bool useOverride,
             if (useOverride)
             {
                 string overrideContents = @"<?xml version=`1.0`?>
-                <VisualStudioPropertySheet 
-	                ProjectType=`Visual C++` 
-	                Version=`8.00` 
+                <VisualStudioPropertySheet
+	                ProjectType=`Visual C++`
+	                Version=`8.00`
 	                Name=`VCOverride` OutputDirectory=`Outputs\$(ConfigurationName)`
 	                >
                 </VisualStudioPropertySheet>";
@@ -79,7 +79,7 @@ internal void VerifyVCProjectOutputs(string vcProjectContents, bool useOverride,
         [Test]
         public void OverrideOutputDirectory()
         {
-            string vcProjectContents =  
+            string vcProjectContents =
             #region VC project contents
             @"<?xml version=`1.0` encoding=`Windows-1252`?>
                 <VisualStudioProject
@@ -345,7 +345,7 @@ public void OverrideOutputDirectory()
                 </VisualStudioProject>";
             #endregion
 
-            VerifyVCProjectOutputs(vcProjectContents, true, "Debug|Win32", 
+            VerifyVCProjectOutputs(vcProjectContents, true, "Debug|Win32",
                 @"Outputs\Debug\CppProj.dll", null);
         }
 
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 9b1bf4943dc..64ac383d4c2 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -231,12 +231,12 @@ Imports System.Linq
 Imports System.Text
 
 Namespace InlineCode
-    
+
     Public Class {TaskName}
         Inherits Microsoft.Build.Utilities.Task
-        
+
         Private _Success As Boolean = true
-        
+
         Public Overridable Property Success() As Boolean
             Get
                 Return _Success
@@ -245,7 +245,7 @@ End Get
                 _Success = value
             End Set
         End Property
-        
+
         Public Overrides Function Execute() As Boolean
 {fragment}
             Return Success
@@ -302,12 +302,12 @@ Imports System.Linq
 Imports System.Text
 
 Namespace InlineCode
-    
+
     Public Class {TaskName}
         Inherits Microsoft.Build.Utilities.Task
-        
+
         Private _Parameter1 As String
-        
+
         Public Overridable Property Parameter1() As String
             Get
                 Return _Parameter1
@@ -316,9 +316,9 @@ End Get
                 _Parameter1 = value
             End Set
         End Property
-        
+
         Private _Parameter2 As String
-        
+
         Public Overridable Property Parameter2() As String
             Get
                 Return _Parameter2
@@ -327,9 +327,9 @@ End Get
                 _Parameter2 = value
             End Set
         End Property
-        
+
         Private _Parameter3 As String
-        
+
         Public Overridable Property Parameter3() As String
             Get
                 Return _Parameter3
@@ -338,9 +338,9 @@ End Get
                 _Parameter3 = value
             End Set
         End Property
-        
+
         Private _Parameter4 As Microsoft.Build.Framework.ITaskItem
-        
+
         Public Overridable Property Parameter4() As Microsoft.Build.Framework.ITaskItem
             Get
                 Return _Parameter4
@@ -349,9 +349,9 @@ End Get
                 _Parameter4 = value
             End Set
         End Property
-        
+
         Private _Parameter5() As Microsoft.Build.Framework.ITaskItem
-        
+
         Public Overridable Property Parameter5() As Microsoft.Build.Framework.ITaskItem()
             Get
                 Return _Parameter5
@@ -360,9 +360,9 @@ End Get
                 _Parameter5 = value
             End Set
         End Property
-        
+
         Private _Success As Boolean = true
-        
+
         Public Overridable Property Success() As Boolean
             Get
                 Return _Success
@@ -371,7 +371,7 @@ End Get
                 _Success = value
             End Set
         End Property
-        
+
         Public Overrides Function Execute() As Boolean
 {fragment}
             Return Success
@@ -423,10 +423,10 @@ Imports System.Linq
 Imports System.Text
 
 Namespace InlineCode
-    
+
     Public Class {TaskName}
         Inherits Microsoft.Build.Utilities.Task
-        
+
 {method}
     End Class
 End Namespace
@@ -529,12 +529,12 @@ namespace InlineCode {{
     using System.IO;
     using System.Linq;
     using System.Text;
-    
-    
+
+
     public class {TaskName} : Microsoft.Build.Utilities.Task {{
-        
+
         private bool _Success = true;
-        
+
         public virtual bool Success {{
             get {{
                 return _Success;
@@ -543,7 +543,7 @@ public virtual bool Success {{
                 _Success = value;
             }}
         }}
-        
+
         public override bool Execute() {{
 {fragment}
             return Success;
@@ -591,12 +591,12 @@ namespace InlineCode {{
     using System.IO;
     using System.Linq;
     using System.Text;
-    
-    
+
+
     public class {TaskName} : Microsoft.Build.Utilities.Task {{
-        
+
         private string _Parameter1;
-        
+
         public virtual string Parameter1 {{
             get {{
                 return _Parameter1;
@@ -605,9 +605,9 @@ public virtual string Parameter1 {{
                 _Parameter1 = value;
             }}
         }}
-        
+
         private string _Parameter2;
-        
+
         public virtual string Parameter2 {{
             get {{
                 return _Parameter2;
@@ -616,9 +616,9 @@ public virtual string Parameter2 {{
                 _Parameter2 = value;
             }}
         }}
-        
+
         private string _Parameter3;
-        
+
         public virtual string Parameter3 {{
             get {{
                 return _Parameter3;
@@ -627,9 +627,9 @@ public virtual string Parameter3 {{
                 _Parameter3 = value;
             }}
         }}
-        
+
         private Microsoft.Build.Framework.ITaskItem _Parameter4;
-        
+
         public virtual Microsoft.Build.Framework.ITaskItem Parameter4 {{
             get {{
                 return _Parameter4;
@@ -638,9 +638,9 @@ public virtual Microsoft.Build.Framework.ITaskItem Parameter4 {{
                 _Parameter4 = value;
             }}
         }}
-        
+
         private Microsoft.Build.Framework.ITaskItem[] _Parameter5;
-        
+
         public virtual Microsoft.Build.Framework.ITaskItem[] Parameter5 {{
             get {{
                 return _Parameter5;
@@ -649,9 +649,9 @@ public virtual Microsoft.Build.Framework.ITaskItem[] Parameter5 {{
                 _Parameter5 = value;
             }}
         }}
-        
+
         private bool _Success = true;
-        
+
         public virtual bool Success {{
             get {{
                 return _Success;
@@ -660,7 +660,7 @@ public virtual bool Success {{
                 _Success = value;
             }}
         }}
-        
+
         public override bool Execute() {{
 {fragment}
             return Success;
@@ -704,10 +704,10 @@ namespace InlineCode {{
     using System.IO;
     using System.Linq;
     using System.Text;
-    
-    
+
+
     public class MyInlineTask : Microsoft.Build.Utilities.Task {{
-        
+
 {method}
     }}
 }}
@@ -775,12 +775,12 @@ namespace InlineCode {{
     using System.IO;
     using System.Linq;
     using System.Text;
-    
-    
+
+
     public class {TaskName} : Microsoft.Build.Utilities.Task {{
-        
+
         private bool _Success = true;
-        
+
         public virtual bool Success {{
             get {{
                 return _Success;
@@ -789,7 +789,7 @@ public virtual bool Success {{
                 _Success = value;
             }}
         }}
-        
+
         public override bool Execute() {{
 {sourceCodeFileContents}
             return Success;
@@ -835,10 +835,10 @@ namespace InlineCode {{
     using System.IO;
     using System.Linq;
     using System.Text;
-    
-    
+
+
     public class MyInlineTask : Microsoft.Build.Utilities.Task {{
-        
+
 {sourceCodeFileContents}
     }}
 }}
diff --git a/src/Tasks.UnitTests/StreamHelpers.cs b/src/Tasks.UnitTests/StreamHelpers.cs
index ca3b5410d1a..b28c8a5c319 100644
--- a/src/Tasks.UnitTests/StreamHelpers.cs
+++ b/src/Tasks.UnitTests/StreamHelpers.cs
@@ -11,7 +11,7 @@ internal sealed class StreamHelpers
     {
         /*
          * Method:  StringToStream (overload)
-         * 
+         *
          * Take a string and convert it into a Stream.
          * Use the default encoding which means this machine's ANSI codepage.
          */
@@ -26,7 +26,7 @@ internal static Stream StringToStream(string value)
 
         /*
          * Method:  StringToStream (overload)
-         * 
+         *
          * Take a string and convert it into a Stream.
          * Takes an alternate encoding type
          */
diff --git a/src/Tasks.UnitTests/StreamMappedString_Tests.cs b/src/Tasks.UnitTests/StreamMappedString_Tests.cs
index c91b7901458..2830548cab6 100644
--- a/src/Tasks.UnitTests/StreamMappedString_Tests.cs
+++ b/src/Tasks.UnitTests/StreamMappedString_Tests.cs
@@ -24,7 +24,7 @@ public void Regress_Mutation_ForceANSIWorks_RelatedTo172107()
 
             // Instead, directly write the ANSI character into the memory buffer.
             sourcesStream.Seek(11, SeekOrigin.Begin);
-            sourcesStream.WriteByte(0xc3);    // Plug the '' in 
+            sourcesStream.WriteByte(0xc3);    // Plug the '' in
             sourcesStream.Seek(0, SeekOrigin.Begin);
 
             // Should not throw an exception because we force ANSI.
diff --git a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
index ced85ee1368..e904909c4b0 100644
--- a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
+++ b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
@@ -27,7 +27,7 @@ public void TestResourceAccess()
 
             t.BuildEngine = engine;
 
-            // No need to actually check the outputted strings. We only care that this doesn't throw, which means that 
+            // No need to actually check the outputted strings. We only care that this doesn't throw, which means that
             // the resource strings were reachable.
 
             // Normal CSC messages first, from private XMakeTasks resources. They should be accessible with t.Log
diff --git a/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs b/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
index e87890fb8ff..2d16e27f677 100644
--- a/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
+++ b/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
@@ -54,7 +54,7 @@ public void NestedNamespace()
                 @"
     Namespace Goofy
         Namespace Mickey
-            <DefaultInstanceProperty(&qtGetInstance&qt)> Public Class Form1      
+            <DefaultInstanceProperty(&qtGetInstance&qt)> Public Class Form1
                 ",
                 "Goofy.Mickey.Form1");
         }
@@ -68,7 +68,7 @@ public void NestedAndEndedNamespace()
     Namespace Goofy
         Namespace Mickey
         End Namespace ' Just finished with the namespace, about to make a class
-        <DefaultInstanceProperty(&qtthis propert is a class name&qt)> PuBlic Class Form1      
+        <DefaultInstanceProperty(&qtthis propert is a class name&qt)> PuBlic Class Form1
                 ",
                 "Goofy.Form1");
         }
diff --git a/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs b/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
index 31bd707bd57..2629109eef0 100644
--- a/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
+++ b/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
@@ -207,9 +207,9 @@ public void Regress_Mutation_x0dx0aIsASingleLine()
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated 
+        * Also, the source must be regenerated exactly when the tokens are concatenated
         * back together,
         */
         private static void AssertTokenize(string source, string expectedTokenKey)
@@ -220,7 +220,7 @@ private static void AssertTokenize(string source, string expectedTokenKey)
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
         * Also compare the source that is regenerated by concatenating all of the tokens
         * to 'expectedSource'.
diff --git a/src/Tasks.UnitTests/WinMDExp_Tests.cs b/src/Tasks.UnitTests/WinMDExp_Tests.cs
index 5a86a08b22b..7e7106554af 100644
--- a/src/Tasks.UnitTests/WinMDExp_Tests.cs
+++ b/src/Tasks.UnitTests/WinMDExp_Tests.cs
@@ -16,7 +16,7 @@ public sealed class WinMDExpTests
     {
         /// <summary>
         /// Tests the "References" parameter on the winmdexp task, and confirms that it sets
-        /// the /reference switch on the command-line correctly.  
+        /// the /reference switch on the command-line correctly.
         /// </summary>
         [Fact]
         public void References()
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index d5495b9dfab..633d6ef0435 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -71,7 +71,7 @@ public void Encoding()
 
                 File.Delete(file);
 
-                // Write ANSI .. that won't work! 
+                // Write ANSI .. that won't work!
                 a = new WriteLinesToFile
                 {
                     BuildEngine = new MockEngine(_output),
diff --git a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
index c298b8c75f2..7c9e56fd374 100644
--- a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
@@ -43,7 +43,7 @@ public void TestLoadXml()
         }
 
         /// <summary>
-        /// Tests the TaskName property. 
+        /// Tests the TaskName property.
         /// Should get "CL" back for this specific case.
         /// </summary>
         [Fact]
@@ -235,7 +235,7 @@ public void TestBasicNonReversibleBooleanSwitch()
         }
 
         /// <summary>
-        /// Tests a basic non-reversible booleans switch that has a default value set. 
+        /// Tests a basic non-reversible booleans switch that has a default value set.
         /// </summary>
         [Fact]
         public void TestBasicNonReversibleBooleanSwitch_WithDefault()
@@ -286,8 +286,8 @@ public void TestBasicEnumProperty()
         }
 
         /// <summary>
-        /// Tests XamlTaskFactory support for DynamicEnumProperties.  These are primarily of use as a visualization in the property pages; as far as the 
-        /// XamlTaskFactory and XamlDataDrivenToolTask are concerned, they are treated as StringProperties.  
+        /// Tests XamlTaskFactory support for DynamicEnumProperties.  These are primarily of use as a visualization in the property pages; as far as the
+        /// XamlTaskFactory and XamlDataDrivenToolTask are concerned, they are treated as StringProperties.
         /// </summary>
         [Fact]
         public void TestDynamicEnumProperty()
@@ -308,7 +308,7 @@ public void TestDynamicEnumProperty()
         }
 
         /// <summary>
-        /// Tests a simple string property. 
+        /// Tests a simple string property.
         /// </summary>
         [Fact]
         public void TestBasicStringProperty()
@@ -361,7 +361,7 @@ public void TestLoadAndParseFromAbsoluteFilePath()
         }
 
         /// <summary>
-        /// Tests a simple string array property. 
+        /// Tests a simple string array property.
         /// </summary>
         [Fact]
         public void TestBasicStringArrayProperty()
@@ -384,7 +384,7 @@ public void TestBasicStringArrayProperty()
         }
 
         /// <summary>
-        /// Tests a simple string array property. 
+        /// Tests a simple string array property.
         /// </summary>
         [Fact]
         public void TestStringArrayPropertyWithDataSource()
@@ -411,7 +411,7 @@ public void TestStringArrayPropertyWithDataSource()
         }
 
         /// <summary>
-        /// Tests a simple string array property. 
+        /// Tests a simple string array property.
         /// </summary>
         [Fact]
         public void TestStringArrayPropertyWithDataSource_DataSourceIsItem()
@@ -485,7 +485,7 @@ public void TestGenerateCodeToStream()
                 cp.ReferencedAssemblies.Add(Path.Combine(XamlTestHelpers.PathToMSBuildBinaries, "Microsoft.Build.Framework.dll"));
                 cp.ReferencedAssemblies.Add("System.Data.dll");
 
-                // Generate an executable instead of 
+                // Generate an executable instead of
                 // a class library.
                 cp.GenerateExecutable = false;
                 // Set the assembly file name to generate.
@@ -541,7 +541,7 @@ public void TestGenerateToFile()
                 cp.ReferencedAssemblies.Add(Path.Combine(XamlTestHelpers.PathToMSBuildBinaries, "Microsoft.Build.Framework.dll"));
                 cp.ReferencedAssemblies.Add("System.Data.dll");
 
-                // Generate an executable instead of 
+                // Generate an executable instead of
                 // a class library.
                 cp.GenerateExecutable = false;
                 // Set the assembly file name to generate.
diff --git a/src/Tasks.UnitTests/XamlTestHelpers.cs b/src/Tasks.UnitTests/XamlTestHelpers.cs
index 15e4609b432..8ce7aaddc48 100644
--- a/src/Tasks.UnitTests/XamlTestHelpers.cs
+++ b/src/Tasks.UnitTests/XamlTestHelpers.cs
@@ -38,7 +38,7 @@ internal static class XamlTestHelpers
                                               <StringProperty Name=`BasicFileWOSwitch` />
                                               <StringProperty Name=`BasicDirectory` />
                                               <DynamicEnumProperty Name=`BasicDynamicEnum` />
-                                              
+
                                               <!-- More Complex types -->
                                               <BoolProperty Name=`ComplexReversible` Switch=`/Cr:CT` ReverseSwitch=`/Cr:CF` Separator=`:` />
                                               <BoolProperty Name=`ComplexNonreversibleWArgument` Switch=`/Cnrwa`>
@@ -54,7 +54,7 @@ internal static class XamlTestHelpers
                                               <IntProperty Name=`ComplexInteger` Switch=`/Ci` MinValue=`64` MaxValue=`255` />
 
                                               <!-- Dependencies, fallbacks, and so on -->
-                                              <BoolProperty Name=`OtherNonreversible` Switch=`/Onr`> 
+                                              <BoolProperty Name=`OtherNonreversible` Switch=`/Onr`>
                                                 <Argument IsRequired=`true` Property=`ComplexFileNoDefault` />
                                               </BoolProperty>
                                               <StringProperty Name=`ComplexDirectory` />
@@ -89,7 +89,7 @@ internal static class XamlTestHelpers
         private static string s_pathToMSBuildBinaries = null;
 
         /// <summary>
-        /// Returns the path to the MSBuild binaries 
+        /// Returns the path to the MSBuild binaries
         /// </summary>
         public static string PathToMSBuildBinaries
         {
@@ -147,7 +147,7 @@ public static Assembly SetupGeneratedCode(string xml)
                 cp.ReferencedAssemblies.Add(Path.Combine(PathToMSBuildBinaries, "Microsoft.Build.Utilities.Core.dll"));
                 cp.ReferencedAssemblies.Add(Path.Combine(PathToMSBuildBinaries, "Microsoft.Build.Tasks.Core.dll"));
 
-                // Generate an executable instead of 
+                // Generate an executable instead of
                 // a class library.
                 cp.GenerateExecutable = false;
                 // Set the assembly file name to generate.
diff --git a/src/Tasks/AspNetCompiler.cs b/src/Tasks/AspNetCompiler.cs
index 3570cc44010..8beb3fc3a9f 100644
--- a/src/Tasks/AspNetCompiler.cs
+++ b/src/Tasks/AspNetCompiler.cs
@@ -52,7 +52,7 @@ is always enabled when targetDir is specified.
             -keycontainer Specifies a strong name key container.
             -aptca        If specified, the strong-name assembly will allow partially
                           trusted callers.
-            -delaysign    If specified, the assemblly is not fully signed when created. 
+            -delaysign    If specified, the assemblly is not fully signed when created.
             -fixednames   If specified, the compiled assemblies will be given fixed names.
             -nologo       Suppress compiler copyright message.
 
@@ -79,7 +79,7 @@ The following command compiles the application /MyApp in-place. The effect is
         public bool AllowPartiallyTrustedCallers { get; set; }
 
         /// <summary>
-        /// If specified, the assemblly is not fully signed when created. 
+        /// If specified, the assemblly is not fully signed when created.
         /// </summary>
         public bool DelaySign { get; set; }
 
@@ -107,7 +107,7 @@ public string KeyFile
         }
 
         /// <summary>
-        /// The full IIS metabase path of the application. This switch 
+        /// The full IIS metabase path of the application. This switch
         /// cannot be combined with the virtualPath or PhysicalDir option.
         /// </summary>
         public string MetabasePath
@@ -128,7 +128,7 @@ public string PhysicalPath
 
         /// <summary>
         /// The physical path to which the application is compiled. If not
-        /// specified, the application is precompiled in-place. 
+        /// specified, the application is precompiled in-place.
         /// </summary>
         public string TargetPath
         {
@@ -173,8 +173,8 @@ public string VirtualPath
         public bool Clean { get; set; }
 
         /// <summary>
-        /// The TargetFrameworkMoniker indicating which .NET Framework version of 
-        /// aspnet_compiler.exe should be used.  Only accepts .NET Framework monikers. 
+        /// The TargetFrameworkMoniker indicating which .NET Framework version of
+        /// aspnet_compiler.exe should be used.  Only accepts .NET Framework monikers.
         /// </summary>
         public string TargetFrameworkMoniker
         {
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index 51df4d81cad..49ba2302654 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -214,7 +214,7 @@ public override bool Resolve(
                         {
                             string candidatePath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, assemblyFolder.DirectoryPath, assembliesConsideredAndRejected);
 
-                            // We have a full path returned 
+                            // We have a full path returned
                             if (candidatePath != null)
                             {
                                 if (resolvedPath == null)
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index 2268765cfbf..4208cf4c72e 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -182,7 +182,7 @@ public override bool Resolve(
                         {
                             string candidatePath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, assemblyFolder.DirectoryPath, assembliesConsideredAndRejected);
 
-                            // We have a full path returned 
+                            // We have a full path returned
                             if (candidatePath != null)
                             {
                                 if (resolvedPath == null)
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 2a247374d79..9875f701dde 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -149,7 +149,7 @@ public AssemblyNameExtension[] Dependencies
         }
 
         /// <summary>
-        /// Get the scatter files from the assembly metadata. 
+        /// Get the scatter files from the assembly metadata.
         /// </summary>
         public string[] Files
         {
@@ -193,7 +193,7 @@ public FrameworkName FrameworkNameAttribute
         }
 
         /// <summary>
-        /// Given an assembly name, crack it open and retrieve the list of dependent 
+        /// Given an assembly name, crack it open and retrieve the list of dependent
         /// assemblies and  the list of scatter files.
         /// </summary>
         /// <param name="path">Path to the assembly.</param>
@@ -544,7 +544,7 @@ private static List<string> GetFixedStringArguments(MetadataReader reader, Custo
 
 #if !FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
-        /// Release interface pointers on Dispose(). 
+        /// Release interface pointers on Dispose().
         /// </summary>
         protected override void DisposeUnmanagedResources()
         {
@@ -583,7 +583,7 @@ internal static string GetRuntimeVersion(string path)
 
                 unsafe
                 {
-                    // Allocate an initial buffer 
+                    // Allocate an initial buffer
                     char* runtimeVersion = stackalloc char[bufferLength];
 
                     // Run GetFileVersion, this should succeed using the initial buffer.
@@ -782,7 +782,7 @@ private static IntPtr AllocAsmMeta()
         }
 
         /// <summary>
-        /// Construct assembly name. 
+        /// Construct assembly name.
         /// </summary>
         /// <param name="asmMetaPtr">Assembly metadata structure</param>
         /// <param name="asmNameBuf">Buffer containing the name</param>
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index 0d6ba23d997..74488931e7a 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.Tasks
     ///
     ///     [path-to-frameworks]\System.Xml.dll
     ///
-    /// 
+    ///
     /// </summary>
     internal static class AssemblyResolution
     {
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs b/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs
index 08b6e6f6df5..0ba5dff6661 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs
@@ -11,27 +11,27 @@ namespace Microsoft.Build.Tasks
     internal static class AssemblyResolutionConstants
     {
         /// <summary>
-        /// Special hintpath indicator. May be passed in where SearchPaths are taken. 
+        /// Special hintpath indicator. May be passed in where SearchPaths are taken.
         /// </summary>
         public const string hintPathSentinel = "{hintpathfromitem}";
 
         /// <summary>
-        /// Special AssemblyFolders indicator. May be passed in where SearchPaths are taken. 
+        /// Special AssemblyFolders indicator. May be passed in where SearchPaths are taken.
         /// </summary>
         public const string assemblyFoldersSentinel = "{assemblyfolders}";
 
         /// <summary>
-        /// Special CandidateAssemblyFiles indicator. May be passed in where SearchPaths are taken. 
+        /// Special CandidateAssemblyFiles indicator. May be passed in where SearchPaths are taken.
         /// </summary>
         public const string candidateAssemblyFilesSentinel = "{candidateassemblyfiles}";
 
         /// <summary>
-        /// Special GAC indicator. May be passed in where SearchPaths are taken. 
+        /// Special GAC indicator. May be passed in where SearchPaths are taken.
         /// </summary>
         public const string gacSentinel = "{gac}";
 
         /// <summary>
-        /// Special Framework directory indicator. May be passed in where SearchPaths are taken. 
+        /// Special Framework directory indicator. May be passed in where SearchPaths are taken.
         /// </summary>
         public const string frameworkPathSentinel = "{targetframeworkdirectory}";
 
@@ -42,12 +42,12 @@ internal static class AssemblyResolutionConstants
         public const string rawFileNameSentinel = "{rawfilename}";
 
         /// <summary>
-        /// Special AssemblyFoldersEx indicator.  May be passed in where SearchPaths are taken. 
+        /// Special AssemblyFoldersEx indicator.  May be passed in where SearchPaths are taken.
         /// </summary>
         public const string assemblyFoldersExSentinel = "{registry:";
 
         /// <summary>
-        /// Special AssemblyFoldersFromConfig indicator.  May be passed in where SearchPaths are taken. 
+        /// Special AssemblyFoldersFromConfig indicator.  May be passed in where SearchPaths are taken.
         /// </summary>
         public const string assemblyFoldersFromConfigSentinel = "{assemblyfoldersfromconfig:";
     }
diff --git a/src/Tasks/AssemblyDependency/ConflictLossReason.cs b/src/Tasks/AssemblyDependency/ConflictLossReason.cs
index b54e87f56de..e47cdf801c4 100644
--- a/src/Tasks/AssemblyDependency/ConflictLossReason.cs
+++ b/src/Tasks/AssemblyDependency/ConflictLossReason.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// If this reference lost in a conflict with another reference, this reason explains 
+    /// If this reference lost in a conflict with another reference, this reason explains
     /// why.
     /// </summary>
     internal enum ConflictLossReason
@@ -27,8 +27,8 @@ internal enum ConflictLossReason
         InsolubleConflict,
 
         /// <summary>
-        /// In this case, this reference was a dependency and the other reference was 
-        /// primary (specified in the project file). 
+        /// In this case, this reference was a dependency and the other reference was
+        /// primary (specified in the project file).
         /// </summary>
         WasNotPrimary,
 
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index 1a4670806eb..c5d26772cfe 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -110,7 +110,7 @@ internal static bool IsCopyLocal(CopyLocalState state)
                     //
                     //   ErrorUtilities.VerifyThrow(false, "Unexpected CopyLocal flag.");
                     //
-                    // but this popped up constantly when debugging because its call 
+                    // but this popped up constantly when debugging because its call
                     // directly by a property accessor in Reference.
             }
         }
diff --git a/src/Tasks/AssemblyDependency/DisposableBase.cs b/src/Tasks/AssemblyDependency/DisposableBase.cs
index 264ebe75d59..6568d1122aa 100644
--- a/src/Tasks/AssemblyDependency/DisposableBase.cs
+++ b/src/Tasks/AssemblyDependency/DisposableBase.cs
@@ -21,7 +21,7 @@ protected DisposableBase()
         }
 
         // Use C# destructor syntax for finalization code.
-        // This destructor will run only if the Dispose method 
+        // This destructor will run only if the Dispose method
         // does not get called.
         // It gives your base class the opportunity to finalize.
         // Do not provide destructors in types derived from this class.
@@ -40,7 +40,7 @@ public void Dispose()
         {
             // This object will be cleaned up by the Dispose method.
             // Therefore, you should call GC.SupressFinalize to
-            // take this object off the finalization queue 
+            // take this object off the finalization queue
             // and prevent finalization code for this object
             // from executing a second time.
             Dispose(true);
@@ -51,15 +51,15 @@ public void Dispose()
         // If disposing equals true, the method has been called directly
         // or indirectly by a user's code. Managed and unmanaged resources
         // can be disposed.
-        // If disposing equals false, the method has been called by the 
-        // runtime from inside the finalizer and you should not reference 
+        // If disposing equals false, the method has been called by the
+        // runtime from inside the finalizer and you should not reference
         // other objects. Only unmanaged resources can be disposed.
         private void Dispose(bool disposing)
         {
             // Check to see if Dispose has already been called.
             if (!_disposed)
             {
-                // If disposing equals true, dispose all managed 
+                // If disposing equals true, dispose all managed
                 // and unmanaged resources.
                 if (disposing)
                 {
@@ -67,9 +67,9 @@ private void Dispose(bool disposing)
                     DisposeManagedResources();
                 }
 
-                // Call the appropriate methods to clean up 
+                // Call the appropriate methods to clean up
                 // unmanaged resources here.
-                // If disposing is false, 
+                // If disposing is false,
                 // only the following code is executed.
                 DisposeUnmanagedResources();
             }
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index 3ac6302c964..330b6b50d49 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -138,7 +138,7 @@ private static SortedDictionary<Version, SortedDictionary<AssemblyNameExtension,
                         // Get the runtime version from the found assembly.
                         string runtimeVersionRaw = getRuntimeVersion(assemblyPath);
 
-                        // Convert the runtime string to a version so we can properly compare them as per version object comparison rules. 
+                        // Convert the runtime string to a version so we can properly compare them as per version object comparison rules.
                         // We will accept version which are less than or equal to the targeted runtime.
                         Version runtimeVersion = VersionUtilities.ConvertToVersion(runtimeVersionRaw);
 
@@ -212,7 +212,7 @@ internal static string RetrievePathFromFusionName(string strongName)
         }
 
         /// <summary>
-        /// If we know we have a full fusion name we can skip enumerating the gac and just query for the path. This will 
+        /// If we know we have a full fusion name we can skip enumerating the gac and just query for the path. This will
         /// not check the runtime version of the assembly.
         /// </summary>
         private static string CheckForFullFusionNameInGac(AssemblyNameExtension assemblyName, string targetProcessorArchitecture, GetPathFromFusionName getPathFromFusionName)
diff --git a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
index 0ab3a0a47f3..d9803997df2 100644
--- a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
+++ b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
@@ -66,7 +66,7 @@ internal void GetInfo(
                 return;
             }
 
-            // Dont allow downgrading of reference version due to redist unification because this is automatic rather than something like an appconfig which 
+            // Dont allow downgrading of reference version due to redist unification because this is automatic rather than something like an appconfig which
             // has to be manually set. However if the major version is 255 then we do want to unify down the version number.
             if (assemblyName.Version <= highestVersionFromRedistList.AssemblyNameExtension.Version || assemblyName.Version.Major == 255)
             {
@@ -94,7 +94,7 @@ internal AssemblyNameExtension RemapAssemblyExtension(AssemblyNameExtension asse
         /// <returns>Key value pair, K: Assembly entry of highest value in the redist list. V: AssemblyNameExtension with the version information or null if the name could not be found</returns>
         internal AssemblyEntry FindHighestVersionInRedistList(AssemblyNameExtension assemblyName)
         {
-            // The assembly we are looking for is not listed in a redist list which contains framework assemblies. We do not want to find 
+            // The assembly we are looking for is not listed in a redist list which contains framework assemblies. We do not want to find
             // find non framework assembly entries.
             if (!FrameworkAssemblyEntryInRedist(assemblyName))
             {
diff --git a/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs b/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
index 55287a96840..be987ee1335 100644
--- a/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
+++ b/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
@@ -9,7 +9,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// There reference is not a well-formed fusion name *and* its not a file 
+    /// There reference is not a well-formed fusion name *and* its not a file
     /// that exists on disk.
     /// </summary>
     [Serializable]
diff --git a/src/Tasks/AssemblyDependency/NoMatchReason.cs b/src/Tasks/AssemblyDependency/NoMatchReason.cs
index 3ac36b9b12e..7041fba1223 100644
--- a/src/Tasks/AssemblyDependency/NoMatchReason.cs
+++ b/src/Tasks/AssemblyDependency/NoMatchReason.cs
@@ -26,7 +26,7 @@ internal enum NoMatchReason
         FusionNamesDidNotMatch,
 
         /// <summary>
-        /// The file was found, but it didn't have a fusion name. 
+        /// The file was found, but it didn't have a fusion name.
         /// </summary>
         TargetHadNoFusionName,
 
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index d6636913a1f..0f47667effb 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -318,7 +318,7 @@ internal ReferenceTable(
             _ignoreFrameworkAttributeVersionMismatch = ignoreFrameworkAttributeVersionMismatch;
             _assemblyMetadataCache = assemblyMetadataCache;
 
-            // Set condition for when to check assembly version against the target framework version 
+            // Set condition for when to check assembly version against the target framework version
             _checkAssemblyVersionAgainstTargetFrameworkVersion = unresolveFrameworkAssembliesFromHigherFrameworks || ((_projectTargetFramework ?? ReferenceTable.s_targetFrameworkVersion_40) <= ReferenceTable.s_targetFrameworkVersion_40);
 
             // Convert the list of installed SDK's to a dictionary for faster lookup
@@ -577,7 +577,7 @@ private Exception SetPrimaryAssemblyReferenceItem(
             reference.MakePrimaryAssemblyReference(referenceAssemblyName, wantSpecificVersion, executableExtension);
 
             // Escape simple names.
-            // 1) If the itemSpec for the task is already a simple name 
+            // 1) If the itemSpec for the task is already a simple name
             // 2) We have found the metadata and it is specifically set to false
             if (assemblyName != null && (isSimpleName || (foundSpecificVersionMetadata && !wantSpecificVersion)))
             {
@@ -907,7 +907,7 @@ private void FindRelatedFiles(
         {
             string baseName = reference.FullPathWithoutExtension;
 
-            // Look for companion files like pdbs and xmls that ride along with 
+            // Look for companion files like pdbs and xmls that ride along with
             // assemblies.
             foreach (string companionExtension in _relatedFileExtensions)
             {
@@ -976,7 +976,7 @@ private void FindSatellites(
                         string satelliteAssembly = Path.Combine(subDirectory, sateliteFilename);
                         if (_fileExists(satelliteAssembly))
                         {
-                            // This is valid satellite assembly. 
+                            // This is valid satellite assembly.
                             reference.AddSatelliteFile(Path.Combine(cultureName, sateliteFilename));
                         }
                     }
@@ -999,7 +999,7 @@ private void FindSerializationAssemblies(
             string serializationAssemblyPath = Path.Combine(reference.DirectoryName, serializationAssemblyFilename);
             if (_fileExists(serializationAssemblyPath))
             {
-                // This is valid serialization assembly. 
+                // This is valid serialization assembly.
                 reference.AddSerializationAssemblyFile(serializationAssemblyFilename);
             }
         }
@@ -1101,7 +1101,7 @@ private void FindDependenciesAndScatterFiles(
             Reference reference,
             List<KeyValuePair<AssemblyNameExtension, Reference>> newEntries)
         {
-            // Before checking for dependencies check to see if the reference itself exists. 
+            // Before checking for dependencies check to see if the reference itself exists.
             // Even though to get to this point the reference must be resolved
             // the reference may not exist on disk if the reference is a project to project reference.
             if (!_fileExists(reference.FullPath))
@@ -1276,7 +1276,7 @@ private void ResolveReference(
             // A list of assemblies that might have been matches but weren't
             var assembliesConsideredAndRejected = new List<ResolutionSearchLocation>();
 
-            // First, look for the dependency in the parents' directories. Unless they are resolved from the GAC or assemblyFoldersEx then 
+            // First, look for the dependency in the parents' directories. Unless they are resolved from the GAC or assemblyFoldersEx then
             // we should make sure we use the GAC and assemblyFolders resolvers themserves rather than a directory resolver to find the reference.
             // This way we dont get assemblies pulled from the GAC or AssemblyFolders but dont have the marking that they were pulled form there.
             var parentReferenceFolders = new List<string>();
@@ -1410,7 +1410,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                         }
                     }
 
-                    // A Primary reference can also be dependency of other references. This means there may be other primary reference which depend on 
+                    // A Primary reference can also be dependency of other references. This means there may be other primary reference which depend on
                     // the current primary reference and they need to be removed.
                     ICollection<ITaskItem> dependees = assemblyReference.GetSourceItems();
 
@@ -1419,7 +1419,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     {
                         // Does the assembly have specific version true, or does any of its primary parent references have specific version true.
                         // This is checked because, if an assembly is in the deny list, the only way it can possibly be allowed is if
-                        // ANY of the primary references which caused it have specific version set to true. To see if any primary references have the metadata we pass true to the method indicating 
+                        // ANY of the primary references which caused it have specific version set to true. To see if any primary references have the metadata we pass true to the method indicating
                         // we want to know if any primary references have specific version set to true.
                         bool hasSpecificVersionTrue = assemblyReference.CheckForSpecificVersionMetadataOnParentsReference(true);
 
@@ -1443,7 +1443,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     }
                 }
 
-                // Go through each of the reference which were removed from the reference list and make sure that we get rid of all of the assemblies which were 
+                // Go through each of the reference which were removed from the reference list and make sure that we get rid of all of the assemblies which were
                 // dependencies of them.
                 foreach (Reference reference in removedReferences)
                 {
@@ -1463,7 +1463,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
         /// </summary>
         private static void AddToDependencyGraph(Dictionary<Reference, List<ReferenceAssemblyExtensionPair>> dependencyGraph, AssemblyNameExtension assemblyName, Reference assemblyReference)
         {
-            // Find the references who the current reference is a dependency for 
+            // Find the references who the current reference is a dependency for
             foreach (Reference dependee in assemblyReference.GetDependees())
             {
                 // For a dependee see if we already have a list started
@@ -1484,7 +1484,7 @@ private static void AddToDependencyGraph(Dictionary<Reference, List<ReferenceAss
         private void RemoveDependencyMarkedForExclusion(LogExclusionReason logExclusionReason, bool removeOnlyNoWarning, string subsetName, Dictionary<AssemblyNameExtension, Reference> goodReferences, List<Reference> removedReferences, AssemblyNameExtension assemblyName, Reference assemblyReference)
         {
             // For a dependency we would like to remove the primary references which caused this dependency to be found.
-            // Source Items is the list of primary itemspecs which lead to the current reference being discovered. 
+            // Source Items is the list of primary itemspecs which lead to the current reference being discovered.
             ICollection<ITaskItem> dependees = assemblyReference.GetSourceItems();
             foreach (ITaskItem dependee in dependees)
             {
@@ -1573,13 +1573,13 @@ private static void RemoveDependencies(Reference removedReference, Dictionary<As
                 return;
             }
 
-            // Go through each of the dependency assemblies and remove the removedReference from the 
+            // Go through each of the dependency assemblies and remove the removedReference from the
             // dependee list.
             foreach (ReferenceAssemblyExtensionPair dependency in dependencies)
             {
                 Reference reference = dependency.Key;
 
-                // Remove the referenceToRemove from the dependee list, this will "unlink" them, in that the dependency reference will no longer know that 
+                // Remove the referenceToRemove from the dependee list, this will "unlink" them, in that the dependency reference will no longer know that
                 // referenceToRemove had a dependency on it
                 reference.RemoveDependee(removedReference);
 
@@ -1704,7 +1704,7 @@ private bool FindAssociatedFiles()
 
                         foreach (string frameworkPath in _frameworkPaths)
                         {
-                            // frameworkPath is guaranteed to have a trailing slash, because 
+                            // frameworkPath is guaranteed to have a trailing slash, because
                             // ResolveAssemblyReference.Execute takes care of adding it.
 
                             if (string.Equals(referenceDirectoryName, frameworkPath, StringComparison.OrdinalIgnoreCase))
@@ -1718,7 +1718,7 @@ private bool FindAssociatedFiles()
                         {
                             if (!reference.ExternallyResolved)
                             {
-                                // Look for companion files like pdbs and xmls that ride along with 
+                                // Look for companion files like pdbs and xmls that ride along with
                                 // assemblies.
                                 if (_findRelatedFiles)
                                 {
@@ -1943,14 +1943,14 @@ internal void ResolveConflicts(
         /// <summary>
         /// If a reference is a higher version than what exists in the redist list of the target framework then
         /// this reference needs to be marked as excluded so that it is not allowed to be referenced.
-        /// 
+        ///
         /// If the user needs this reference then they need to set specific version to true.
         /// </summary>
         internal bool MarkReferencesExcludedDueToOtherFramework(AssemblyNameExtension assemblyName, Reference reference)
         {
             bool haveMarkedReference = false;
 
-            // If the reference was not resolved from the GAC or AssemblyFolders then 
+            // If the reference was not resolved from the GAC or AssemblyFolders then
             // we do not need to check it if came from another framework
             string resolvedSearchPath = reference.ResolvedSearchPath;
             bool resolvedFromGAC = resolvedSearchPath.Equals(AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase);
@@ -1964,7 +1964,7 @@ internal bool MarkReferencesExcludedDueToOtherFramework(AssemblyNameExtension as
             // Check against target framework version if projectTargetFramework is null or less than 4.5, also when flag to force check is set to true
             if (_checkAssemblyVersionAgainstTargetFrameworkVersion)
             {
-                // Did the assembly name get resolved from a GlobalLocation, GAC or AssemblyFolders and is it in the frameworkList.xml for the 
+                // Did the assembly name get resolved from a GlobalLocation, GAC or AssemblyFolders and is it in the frameworkList.xml for the
                 // highest version of the currently targeted framework identifier.
                 bool inLaterRedistListAndFromGlobalLocation = InLatestRedistList(assemblyName);
 
@@ -2021,7 +2021,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
 
                         string otherFrameworkName = null;
 
-                        // The latestTargetFrameworkDirectories can be passed into RAR, if they are then use those directories rather than 
+                        // The latestTargetFrameworkDirectories can be passed into RAR, if they are then use those directories rather than
                         // getting a list by looking at the file system.
                         if (_latestTargetFrameworkDirectories?.Length > 0)
                         {
@@ -2122,7 +2122,7 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFramework(AssemblyN
             {
                 // Check assemblies versions when target framework version is less than 4.5
 
-                // Make sure the version is higher than the version in the redist. 
+                // Make sure the version is higher than the version in the redist.
                 bool higherThanCurrentRedistList = reference.ReferenceVersion != null && reference.ExclusionListLoggingProperties.HighestVersionInRedist != null
                                                    && reference.ReferenceVersion.CompareTo(reference.ExclusionListLoggingProperties.HighestVersionInRedist) > 0;
 
@@ -2151,7 +2151,7 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(
                 return false;
             }
 
-            // Make sure the version is higher than the version in the redist. 
+            // Make sure the version is higher than the version in the redist.
             // If the identifier are not equal we do not check since we are not trying to catch cross framework incompatibilities.
             bool higherThanCurrentFramework = reference.FrameworkNameAttribute != null
                                               && _targetFrameworkMoniker != null
@@ -2185,7 +2185,7 @@ private Dictionary<string, List<AssemblyNameReference>> BuildSimpleNameTable()
                 AssemblyNameReference assemblyReference = AssemblyNameReference.Create(assemblyName, reference);
 
                 // Notice that unresolved assemblies are still added to the table.
-                // This is because an unresolved assembly may have a different version 
+                // This is because an unresolved assembly may have a different version
                 // which would influence unification. We want to report this to the user.
                 string baseName = assemblyName.Name;
 
@@ -2366,8 +2366,8 @@ private static int ResolveAssemblyNameConflict(AssemblyNameReference assemblyRef
                 string leftConflictFusionName = assemblyReference0.assemblyName.FullName;
                 string rightConflictFusionName = assemblyReference1.assemblyName.FullName;
 
-                // If both assemblies being compared are primary references, the caller should pass in a zero-flag 
-                // (non-unified) for both. (This conforms to the C# assumption that two direct references are meant to be 
+                // If both assemblies being compared are primary references, the caller should pass in a zero-flag
+                // (non-unified) for both. (This conforms to the C# assumption that two direct references are meant to be
                 // SxS.)
                 bool isNonUnified = leftConflictReference.IsPrimary && rightConflictReference.IsPrimary;
                 bool leftConflictLegacyUnified = !isNonUnified && assemblyReference0.reference.IsPrimary;
@@ -2683,7 +2683,7 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
             // If there was a primary source item, then forward metadata from it.
             // It's important that the metadata from the primary source item
             // win over the same metadata from other source items, so that's
-            // why we put this first.  (CopyMetadataTo will never override an 
+            // why we put this first.  (CopyMetadataTo will never override an
             // already existing metadata.)  For example, if this reference actually
             // came directly from an item declared in the project file, we'd
             // want to use the metadata from it, not some other random item in
@@ -3163,8 +3163,8 @@ internal bool MarkReferencesForExclusion(Dictionary<string, string> exclusionLis
 
                 MarkReferenceWithHighestVersionInCurrentRedistList(assemblyName, reference);
 
-                // If CheckForSpecificVersionMetadataOnParentsReference is passed true then we will return true if any parent primary reference has the specific 
-                // version metadata set to true, 
+                // If CheckForSpecificVersionMetadataOnParentsReference is passed true then we will return true if any parent primary reference has the specific
+                // version metadata set to true,
                 // If false is passed in we will return true ONLY if all parent primary references have the metadata set to true.
                 if (!reference.CheckForSpecificVersionMetadataOnParentsReference(false))
                 {
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index 667493a611d..0e831bd3aa6 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -208,7 +208,7 @@ protected bool FileMatchesAssemblyName(
                 {
                     // Its pretty hard to get here, you need an assembly that contains a valid reference
                     // to a dependent assembly that, in turn, throws a FileLoadException during GetAssemblyName.
-                    // Still it happened once, with an older version of the CLR. 
+                    // Still it happened once, with an older version of the CLR.
 
                     // ...falling through and relying on the targetAssemblyName==null behavior below...
                 }
@@ -330,7 +330,7 @@ protected string ResolveFromDirectory(
                         throw new InvalidParameterValueException("SearchPaths", directory + (directory.EndsWith("\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : "\\") + baseName, e.Message);
                     }
 
-                    // We have a full path returned 
+                    // We have a full path returned
                     if (ResolveAsFile(fullPath, assemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected))
                     {
                         if (candidateFullPath == null)
@@ -340,10 +340,10 @@ protected string ResolveFromDirectory(
 
                         /*
                          * After finding a file we now will check to see if it matches the type of processor architecture we want to return. The rules are as follows
-                         * 
+                         *
                          * If targeting AMD64 / X86 / IA64 / ARM /NONE we will return the first assembly which has a matching processor architecture OR is an assembly with a processor architecture of MSIL or NONE
-                         * 
-                         * If targeting MSIL we will first look through all of the assemblies, if an MSIL assembly is found we will return that. If no MSIL assembly is found we will return 
+                         *
+                         * If targeting MSIL we will first look through all of the assemblies, if an MSIL assembly is found we will return that. If no MSIL assembly is found we will return
                          * the first assembly which matches reguardless of its processor architecture.
                          */
 
diff --git a/src/Tasks/AssemblyFolder.cs b/src/Tasks/AssemblyFolder.cs
index 3d9bf146499..3258cfe21fc 100644
--- a/src/Tasks/AssemblyFolder.cs
+++ b/src/Tasks/AssemblyFolder.cs
@@ -91,7 +91,7 @@ private static void AddFoldersFromRegistryKey(
                 key,
                 directories);
 
-            // Then add the local machine.            
+            // Then add the local machine.
             AddFoldersFromRegistryKey(
                 Registry.LocalMachine,
                 key,
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index 2ff7b10261f..f55d2fd6268 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -16,18 +16,18 @@ namespace Microsoft.Build.Tasks
 {
     /// <summary>
     /// Class: AssignCulture
-    /// 
+    ///
     /// This task takes a list of resource file names and sets an attribute that
     /// contains the culture name embedded in the file name:
-    /// 
+    ///
     ///      MyResources.fr.resx     ==> Culture='fr'
-    /// 
+    ///
     /// The task can also return a list of "Culture-neutral" file names, like:
-    /// 
+    ///
     ///      MyGlyph.fr.bmp          ==> MyGlyph.bmp [Culture='fr']
-    /// 
+    ///
     /// This is because embedded resources are referred to this way.
-    /// 
+    ///
     /// There are plenty of corner cases with this task. See the unit test for
     /// more details.
     /// </summary>
@@ -43,13 +43,13 @@ public class AssignCulture : TaskExtension
 
         /// <summary>
         /// This outgoing list of files is exactly the same as the incoming Files
-        /// list except that an attribute name "Culture" will have been added if 
+        /// list except that an attribute name "Culture" will have been added if
         /// the particular file name is in the form:
-        /// 
+        ///
         ///      MyResource.&lt;any-valid-culture-id&gt;.resx
-        /// 
+        ///
         /// The value of Culture will be "&lt;any-valid-culture-id&gt;".
-        /// 
+        ///
         /// If the incoming item from Files already has a Culture attribute then
         /// that original attribute is used instead.
         /// </summary>
@@ -62,9 +62,9 @@ public class AssignCulture : TaskExtension
         /// already had a Culture in the incoming Files list as well as items
         /// that were assigned a Culture because they had a valid culture ID
         /// embedded in their file name.
-        /// 
+        ///
         /// The following is always true:
-        /// 
+        ///
         ///      AssignedFiles = AssignedFilesWithCulture + AssignedFilesWithNoCulture
         /// </summary>
         [Output]
@@ -72,10 +72,10 @@ public class AssignCulture : TaskExtension
 
         /// <summary>
         /// This is a subset of AssignedFiles that has all of the items that
-        /// ended up with no Culture assigned to them. 
-        /// 
+        /// ended up with no Culture assigned to them.
+        ///
         /// The following is always true:
-        /// 
+        ///
         ///      AssignedFiles = AssignedFilesWithCulture + AssignedFilesWithNoCulture
         /// </summary>
         [Output]
@@ -84,27 +84,27 @@ public class AssignCulture : TaskExtension
         /// <summary>
         /// This list has the same number of items as the Files list or the
         /// AssignedFiles list.
-        /// 
+        ///
         /// Items in this list have the file name from Files or AssignedFiles
         /// but with the culture stripped if it was embedded in the file name.
-        /// 
+        ///
         /// So for example, if the incoming item in Files was:
-        /// 
+        ///
         ///      MyBitmap.fr.bmp
-        /// 
+        ///
         /// then the corresponding file in CultureNeutralAssignedFiles will be:
-        /// 
+        ///
         ///      MyBitmap.bmp
-        /// 
+        ///
         /// The culture will only be stripped if it is a valid culture identifier.
         /// So for example,
-        /// 
+        ///
         ///      MyDifferentFile.XX.txt
-        /// 
+        ///
         /// will result in exactly the same file name:
-        /// 
+        ///
         ///      MyDifferentFile.XX.txt
-        /// 
+        ///
         /// because 'XX' is not a valid culture identifier.
         /// </summary>
         [Output]
diff --git a/src/Tasks/AssignLinkMetadata.cs b/src/Tasks/AssignLinkMetadata.cs
index 55a043eefc7..717a2fb1eae 100644
--- a/src/Tasks/AssignLinkMetadata.cs
+++ b/src/Tasks/AssignLinkMetadata.cs
@@ -28,11 +28,11 @@ public class AssignLinkMetadata : TaskExtension
         public ITaskItem[] OutputItems { get; set; }
 
         /// <summary>
-        /// Sets "Link" metadata on any item where the project file in which they 
-        /// were defined is different from the parent project file to a sane default: 
-        /// the relative directory compared to the defining file.  
-        /// 
-        /// Does NOT overwrite Link metadata if it's already defined. 
+        /// Sets "Link" metadata on any item where the project file in which they
+        /// were defined is different from the parent project file to a sane default:
+        /// the relative directory compared to the defining file.
+        ///
+        /// Does NOT overwrite Link metadata if it's already defined.
         /// </summary>
         public override bool Execute()
         {
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 74894b3aa5e..ba5062c1ce5 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -18,7 +18,7 @@ public class AssignProjectConfiguration : ResolveProjectBase
         #region Properties
 
         /// <summary>
-        /// A special XML string containing a project configuration for each project - we need to simply 
+        /// A special XML string containing a project configuration for each project - we need to simply
         /// match the projects and assign the appropriate configuration names to them
         /// </summary>
         public string SolutionConfigurationContents { get; set; }
@@ -31,7 +31,7 @@ public class AssignProjectConfiguration : ResolveProjectBase
 
         /// <summary>
         /// String containing a semicolon-delimited list of mappings from the platform names used
-        /// by most VS types to those used by .vcxprojs.  
+        /// by most VS types to those used by .vcxprojs.
         /// </summary>
         /// <remarks>
         /// E.g.  "AnyCPU=Win32"
@@ -56,7 +56,7 @@ public string DefaultToVcxPlatformMapping
 
         /// <summary>
         /// String containing a semicolon-delimited list of mappings from .vcxproj platform names
-        /// to the platform names use by most other VS project types.  
+        /// to the platform names use by most other VS project types.
         /// </summary>
         /// <remarks>
         /// E.g.  "Win32=AnyCPU"
@@ -115,12 +115,12 @@ public string VcxToDefaultPlatformMapping
         public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { get; set; } = false;
 
         // Whether to set the project reference's GlobalPropertiesToRemove metadata to contain
-        // Configuration and Platform. 
+        // Configuration and Platform.
 
         /// <summary>
         /// Whether to set the GlobalPropertiesToRemove metadata on the project reference such that
-        /// on an MSBuild call, the Configuration and Platform metadata will be unset, allowing the 
-        /// child project to build in its default configuration / platform. 
+        /// on an MSBuild call, the Configuration and Platform metadata will be unset, allowing the
+        /// child project to build in its default configuration / platform.
         /// </summary>
         public bool ShouldUnsetParentConfigurationAndPlatform { get; set; } = false;
 
@@ -205,9 +205,9 @@ public override bool Execute()
                     }
                     else
                     {
-                        // If the reference was unresolved, we want to undefine the Configuration and Platform 
+                        // If the reference was unresolved, we want to undefine the Configuration and Platform
                         // global properties, so that the project will build using its default Configuration and
-                        // Platform rather than that of its parent. 
+                        // Platform rather than that of its parent.
                         if (ShouldUnsetParentConfigurationAndPlatform)
                         {
                             string globalPropertiesToRemove = projectRef.GetMetadata("GlobalPropertiesToRemove");
@@ -253,7 +253,7 @@ public override bool Execute()
         #region Methods
 
         /// <summary>
-        /// Given a project reference task item and an XML document containing project configurations, 
+        /// Given a project reference task item and an XML document containing project configurations,
         /// find the configuration for that task item.
         /// </summary>
         /// <returns>true if resolved successfully</returns>
@@ -333,14 +333,14 @@ internal static void SetBuildInProjectAndReferenceOutputAssemblyMetadata(bool on
         {
             if (projectConfigurationElement != null && resolvedProjectWithConfiguration != null && onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)
             {
-                // The value of the specified attribute. An empty string is returned if a matching attribute is not found or if the attribute does not have a specified or default value. 
+                // The value of the specified attribute. An empty string is returned if a matching attribute is not found or if the attribute does not have a specified or default value.
                 string buildProjectInSolution = projectConfigurationElement.GetAttribute(SolutionConfiguration.BuildProjectInSolutionAttribute);
 
-                // We could not parse out what was in the attribute, act as if it was not set in the first place. 
+                // We could not parse out what was in the attribute, act as if it was not set in the first place.
                 if (bool.TryParse(buildProjectInSolution, out bool buildProject))
                 {
-                    // If we do not want to build references disabled in the solution configuration blob   
-                    // and the solution configuration indicates the build for this project is disabled 
+                    // If we do not want to build references disabled in the solution configuration blob
+                    // and the solution configuration indicates the build for this project is disabled
                     // We need to set the BuildReferenceMetadata to false and the ReferenceOutputAssembly to false (if they are not already set to anything)
                     if (!buildProject)
                     {
@@ -362,8 +362,8 @@ internal static void SetBuildInProjectAndReferenceOutputAssemblyMetadata(bool on
         }
 
         /// <summary>
-        /// Given the contents of VcxToDefaultPlatformMapping and DefaultToVcxPlatformMapping properties, 
-        /// fill out the maps that will be used to translate between the two.  
+        /// Given the contents of VcxToDefaultPlatformMapping and DefaultToVcxPlatformMapping properties,
+        /// fill out the maps that will be used to translate between the two.
         /// </summary>
         private void SetupDefaultPlatformMappings()
         {
@@ -384,7 +384,7 @@ private void SetupDefaultPlatformMappings()
         }
 
         /// <summary>
-        /// Given a dictionary to populate and a string of the format "a=b;c=d", populate the 
+        /// Given a dictionary to populate and a string of the format "a=b;c=d", populate the
         /// dictionary with the given pairs.
         /// </summary>
         private void PopulateMappingDictionary(IDictionary<string, string> map, string mappingList)
diff --git a/src/Tasks/AxImp.cs b/src/Tasks/AxImp.cs
index fd0b6ccd2ae..14eeb123d8c 100644
--- a/src/Tasks/AxImp.cs
+++ b/src/Tasks/AxImp.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.Tasks
     public sealed partial class ResolveComReference
     {
         /// <summary>
-        /// Defines the "AxImp" MSBuild task, which enables using AxImp.exe 
+        /// Defines the "AxImp" MSBuild task, which enables using AxImp.exe
         /// to generate Windows Forms wrappers for ActiveX controls.
         /// </summary>
         internal class AxImp : AxTlbBaseTask
diff --git a/src/Tasks/AxReference.cs b/src/Tasks/AxReference.cs
index 81a24df2d8e..d159d9f9fd7 100644
--- a/src/Tasks/AxReference.cs
+++ b/src/Tasks/AxReference.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.Tasks
 {
     /*
      * Class:   AxReference
-     * 
+     *
      * COM reference wrapper class for the ActiveX controls.
      *
      */
diff --git a/src/Tasks/AxTlbBaseReference.cs b/src/Tasks/AxTlbBaseReference.cs
index 6ac34233207..60a81c310e8 100644
--- a/src/Tasks/AxTlbBaseReference.cs
+++ b/src/Tasks/AxTlbBaseReference.cs
@@ -16,12 +16,12 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Common abstract base for aximp and tlbimp COM reference wrapper classes. 
+    /// Common abstract base for aximp and tlbimp COM reference wrapper classes.
     /// They share the resolution method and only differ in constructing the wrapper file name.
     /// </summary>
     internal abstract class AxTlbBaseReference : ComReference
     {
-        #region Constructors	
+        #region Constructors
         /// <summary>
         /// internal constructor
         /// </summary>
@@ -85,9 +85,9 @@ internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IC
         protected bool DelaySign { get; set; }
 
         /// <summary>
-        /// Property to allow multitargeting of ResolveComReferences:  If true, tlbimp.exe and 
+        /// Property to allow multitargeting of ResolveComReferences:  If true, tlbimp.exe and
         /// aximp.exe from the appropriate target framework will be run out-of-proc to generate
-        /// the necessary wrapper assemblies.  
+        /// the necessary wrapper assemblies.
         /// </summary>
         protected bool ExecuteAsTool { get; set; }
 
@@ -100,12 +100,12 @@ internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IC
 
         /// <summary>
         /// Environment variables to pass to the tool.
-        /// </summary>        
+        /// </summary>
         protected string[] EnvironmentVariables { get; set; }
 
         /// <summary>
-        /// If ExecuteAsTool is true, this must be set to the SDK 
-        /// tools path for the framework version being targeted. 
+        /// If ExecuteAsTool is true, this must be set to the SDK
+        /// tools path for the framework version being targeted.
         /// </summary>
         protected string ToolPath { get; set; }
 
@@ -119,7 +119,7 @@ internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IC
         #region Methods
 
         /// <summary>
-        /// Checks if there's a preexisting wrapper for this reference. 
+        /// Checks if there's a preexisting wrapper for this reference.
         /// </summary>
         internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperInfo, DateTime componentTimestamp)
         {
@@ -164,7 +164,7 @@ protected virtual bool IsWrapperUpToDate(ComReferenceWrapperInfo wrapperInfo, Da
                 return false;
             }
 
-            // Compare our the existing wrapper's strong name state to the one we are requesting. 
+            // Compare our the existing wrapper's strong name state to the one we are requesting.
             if (!SigningRequirementsMatchExistingWrapper(wrapperInfo))
             {
                 return false;
@@ -185,7 +185,7 @@ protected virtual bool IsWrapperUpToDate(ComReferenceWrapperInfo wrapperInfo, Da
         }
 
         /// <summary>
-        /// Constructs the wrapper file path. 
+        /// Constructs the wrapper file path.
         /// </summary>
         internal string GetWrapperPath()
         {
@@ -203,11 +203,11 @@ internal string GetWrapperFileName()
 
         /*
          * Method:  GetWrapperFileName
-         * 
-         * 
+         *
+         *
          */
         /// <summary>
-        /// Constructs the wrapper file name from a type library name. Specialized wrappers must override it if 
+        /// Constructs the wrapper file name from a type library name. Specialized wrappers must override it if
         /// they want to use the Resolve method from this class.
         /// </summary>
         protected abstract string GetWrapperFileNameInternal(string typeLibName);
@@ -245,8 +245,8 @@ internal static string GetWrapperFileName(string interopDllHeader, string typeLi
         }
 
         /// <summary>
-        /// Given our KeyFile, KeyContainer, and DelaySign parameters, generate the public / private 
-        /// key pair and validate that it exists to the extent needed.  
+        /// Given our KeyFile, KeyContainer, and DelaySign parameters, generate the public / private
+        /// key pair and validate that it exists to the extent needed.
         /// </summary>
         internal void GetAndValidateStrongNameKey(out StrongNameKeyPair keyPair, out byte[] publicKey)
         {
@@ -254,7 +254,7 @@ internal void GetAndValidateStrongNameKey(out StrongNameKeyPair keyPair, out byt
             // get key pair/public key
             StrongNameUtils.GetStrongNameKey(Log, KeyFile, KeyContainer, out keyPair, out publicKey);
 
-            // make sure we give as much data to the typelib converter as necessary but not more, or we might end up 
+            // make sure we give as much data to the typelib converter as necessary but not more, or we might end up
             // with something we didn't want
             if (DelaySign)
             {
@@ -290,7 +290,7 @@ internal void GetAndValidateStrongNameKey(out StrongNameKeyPair keyPair, out byt
         }
 
         /// <summary>
-        /// Compare the strong name signing state of the existing wrapper to the signing 
+        /// Compare the strong name signing state of the existing wrapper to the signing
         /// state we are requesting in this run of the task. Return true if they match (e.g.
         /// from a signing perspective, the wrapper is up-to-date) or false otherwise.
         /// </summary>
diff --git a/src/Tasks/AxTlbBaseTask.cs b/src/Tasks/AxTlbBaseTask.cs
index 227a4efc86e..e058cd21a99 100644
--- a/src/Tasks/AxTlbBaseTask.cs
+++ b/src/Tasks/AxTlbBaseTask.cs
@@ -17,9 +17,9 @@ internal abstract class AxTlbBaseTask : ToolTaskExtension
         #region Private Data
 
         /// <summary>
-        /// True if the keyfile only contains the public key data, and thus 
+        /// True if the keyfile only contains the public key data, and thus
         /// we should pass the file using the /publickey: parameter instead of
-        /// /keyfile. 
+        /// /keyfile.
         /// </summary>
         private bool _delaySigningAndKeyFileOnlyContainsPublicKey;
 
@@ -68,7 +68,7 @@ public string SdkToolsPath
 
         /// <summary>
         /// Returns the name of the tool to execute.  AxTlbBaseTask is not
-        /// executable, so return null for the ToolName -- And make sure that 
+        /// executable, so return null for the ToolName -- And make sure that
         /// Execute() logs an error!
         /// </summary>
         protected override string ToolName { get; } = null;
@@ -91,7 +91,7 @@ public override bool Execute()
         }
 
         /// <summary>
-        /// Adds commands for the tool being executed, that cannot be put in a response file.  
+        /// Adds commands for the tool being executed, that cannot be put in a response file.
         /// </summary>
         /// <param name="commandLine">The CommandLineBuilderExtension to add the commands to</param>
         protected internal override void AddCommandLineCommands(CommandLineBuilderExtension commandLine)
@@ -123,7 +123,7 @@ protected override string GenerateFullPathToTool()
         /// <returns>True if parameters are valid</returns>
         protected override bool ValidateParameters()
         {
-            // Verify that a path for the tool exists -- if the tool doesn't exist in it 
+            // Verify that a path for the tool exists -- if the tool doesn't exist in it
             // we'll worry about that later
             if ((String.IsNullOrEmpty(ToolPath) || !FileSystems.Default.DirectoryExists(ToolPath)) &&
                 (String.IsNullOrEmpty(SdkToolsPath) || !FileSystems.Default.DirectoryExists(SdkToolsPath)))
@@ -134,7 +134,7 @@ protected override bool ValidateParameters()
 
             if (ValidateStrongNameParameters())
             {
-                // Allow the base class to do any validation it thinks necessary -- as far 
+                // Allow the base class to do any validation it thinks necessary -- as far
                 // as we're concerned, parameters check out properly
                 return base.ValidateParameters();
             }
@@ -142,7 +142,7 @@ protected override bool ValidateParameters()
         }
 
         /// <summary>
-        /// Adds options involving strong name signing -- syntax is the same between 
+        /// Adds options involving strong name signing -- syntax is the same between
         /// AxImp and TlbImp
         /// </summary>
         /// <param name="commandLine">The command line to add options to</param>
@@ -151,10 +151,10 @@ private void AddStrongNameOptions(CommandLineBuilderExtension commandLine)
             commandLine.AppendWhenTrue("/delaysign", Bag, "DelaySign");
 
             // If we're delay-signing, we only need the public key, but if we use the /publickey
-            // switch, it will consume the entire key file, assume that's just the public key, and 
+            // switch, it will consume the entire key file, assume that's just the public key, and
             // throw an error.
-            // 
-            // So use /publickey if that's all our KeyFile contains, but KeyFile otherwise. 
+            //
+            // So use /publickey if that's all our KeyFile contains, but KeyFile otherwise.
             if (_delaySigningAndKeyFileOnlyContainsPublicKey)
             {
                 commandLine.AppendSwitchIfNotNull("/publickey:", KeyFile);
@@ -207,7 +207,7 @@ private bool ValidateStrongNameParameters()
                 return false;
             }
 
-            // If KeyFile or KeyContainer is specified, verify that a key pair exists (or if delay-signed, 
+            // If KeyFile or KeyContainer is specified, verify that a key pair exists (or if delay-signed,
             // even just a public key)
             if (keyFileExists || keyContainerSpecified)
             {
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index b60f7b01d4a..0b296e958ca 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -52,7 +52,7 @@ public class BootstrapperBuilder : IBootstrapperBuilder
 
         private const string ENGINE_PATH = "Engine"; // relative to bootstrapper path
         private const string SCHEMA_PATH = "Schemas"; // relative to bootstrapper path
-        private const string PACKAGE_PATH = "Packages"; // relative to bootstrapper path 
+        private const string PACKAGE_PATH = "Packages"; // relative to bootstrapper path
         private const string RESOURCES_PATH = "";
 
         private const string BOOTSTRAPPER_NAMESPACE = "http://schemas.microsoft.com/developer/2004/01/bootstrapper";
@@ -202,7 +202,7 @@ public BuildResults Build(BuildSettings settings)
                     configElement.AppendChild(applicationElement);
                 }
 
-                // Key: File hash, Value: A DictionaryEntry whose Key is "EULAx" and value is a 
+                // Key: File hash, Value: A DictionaryEntry whose Key is "EULAx" and value is a
                 // fully qualified path to a eula. It can be any eula that matches the hash.
                 var eulas = new Dictionary<string, KeyValuePair<string, string>>(StringComparer.Ordinal);
 
@@ -760,7 +760,7 @@ private void OrderProducts(Dictionary<string, Product> availableProducts, Dictio
                 }
 
                 // If we could not remove any products and there are still products in the queue
-                // there must be a loop in it. We'll break the loop by removing the dependencies 
+                // there must be a loop in it. We'll break the loop by removing the dependencies
                 // of the first project in the queue;
                 if (buildQueue.Count > 0 && productsToRemove.Count == 0)
                 {
@@ -1018,7 +1018,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement, st
                                             ReplacePackageFileAttributes(langElement, EULA_ATTRIBUTE, packageFilesNode, "PackageFile", "OldName", "SourcePath");
                                         }
 
-                                        // in general, we prefer the attributes of the language document over the 
+                                        // in general, we prefer the attributes of the language document over the
                                         //  attributes of the base document.  Copy attributes from the lang to the merged,
                                         //  and then merge all unique elements into merge
                                         foreach (XmlAttribute attribute in langElement.Attributes)
@@ -1240,12 +1240,12 @@ private void CombineElements(XmlElement langElement, XmlElement baseElement, str
             XmlNode baseNode = baseElement.SelectSingleNode(BOOTSTRAPPER_PREFIX + ":" + strNodeName, _xmlNamespaceManager);
 
             // There are 4 basic cases to be dealt with:
-            // Case #    1       2       3       4      
+            // Case #    1       2       3       4
             // base      null    null    present present
             // lang      null    present null    present
             // Result    null    lang    base    combine
             //
-            // Cases 1 - 3 are pretty trivial.  
+            // Cases 1 - 3 are pretty trivial.
             if (baseNode == null)
             {
                 if (langNode != null)
@@ -2038,27 +2038,27 @@ private static void DumpXmlToFile(XmlNode node, string fileName)
                 }
                 catch (IOException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (UnauthorizedAccessException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (ArgumentException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (NotSupportedException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (XmlException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
             }
@@ -2077,22 +2077,22 @@ private static void DumpStringToFile(string text, string fileName, bool append)
                 }
                 catch (IOException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (UnauthorizedAccessException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (ArgumentException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (NotSupportedException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
             }
@@ -2242,12 +2242,12 @@ private static Dictionary<string, Product> GetIncludedProducts(Product product)
         {
             var includedProducts = new Dictionary<string, Product>(StringComparer.OrdinalIgnoreCase)
             {
-                // Add in this product in case there is a circular includes: 
+                // Add in this product in case there is a circular includes:
                 // we won't continue to explore this product.  It will be removed later.
                 { product.ProductCode, product }
             };
 
-            // Recursively add included products 
+            // Recursively add included products
             foreach (Product p in product.Includes)
             {
                 AddIncludedProducts(p, includedProducts);
diff --git a/src/Tasks/BootstrapperUtil/Interfaces.cs b/src/Tasks/BootstrapperUtil/Interfaces.cs
index 33f04d5c548..2214a9f69c4 100644
--- a/src/Tasks/BootstrapperUtil/Interfaces.cs
+++ b/src/Tasks/BootstrapperUtil/Interfaces.cs
@@ -316,7 +316,7 @@ public enum BuildMessageSeverity
     public enum ComponentsLocation
     {
         /// <summary>
-        /// Products will be found according to the redist vendor's designated URL 
+        /// Products will be found according to the redist vendor's designated URL
         /// </summary>
         HomeSite,
         /// <summary>
diff --git a/src/Tasks/CallTarget.cs b/src/Tasks/CallTarget.cs
index 0b64787bf00..74acb20e7c3 100644
--- a/src/Tasks/CallTarget.cs
+++ b/src/Tasks/CallTarget.cs
@@ -27,7 +27,7 @@ public class CallTarget : TaskExtension
         /// </summary>
         /// <value>Array of target names.</value>
         /// <remarks>
-        /// This is a required parameter. If you want to build the 
+        /// This is a required parameter. If you want to build the
         /// default targets, use the &lt;MSBuild&gt; task and pass in Projects=$(MSBuildProjectFile).
         /// </remarks>
         public string[] Targets { get; set; }
@@ -68,8 +68,8 @@ public override bool Execute()
             }
 
             // This is a list of string[].  That is, each element in the list is a string[].  Each
-            // string[] represents a set of target names to build.  Depending on the value 
-            // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
+            // string[] represents a set of target names to build.  Depending on the value
+            // of the RunEachTargetSeparately parameter, we each just call the engine to run all
             // the targets together, or we call the engine separately for each target.
             List<string[]> targetLists = MSBuild.CreateTargetLists(Targets, RunEachTargetSeparately);
 
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 522b4de5c81..4c076939d98 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -855,17 +855,17 @@ private List<string> CombineReferencedAssemblies()
 
             // Set some default references:
 
-            // Loading with the partial name is fine for framework assemblies -- we'll always get the correct one 
+            // Loading with the partial name is fine for framework assemblies -- we'll always get the correct one
             // through the magic of unification
             foreach (string defaultReference in s_defaultReferencedFrameworkAssemblyNames)
             {
                 AddReferenceAssemblyToReferenceList(finalReferenceList, defaultReference);
             }
 
-            // We also want to add references to two MSBuild assemblies: Microsoft.Build.Framework.dll and 
-            // Microsoft.Build.Utilities.Core.dll.  If we just let the CLR unify the simple name, it will 
-            // pick the highest version on the machine, which means that in hosts with restrictive binding 
-            // redirects, or no binding redirects, we'd end up creating an inline task that could not be 
+            // We also want to add references to two MSBuild assemblies: Microsoft.Build.Framework.dll and
+            // Microsoft.Build.Utilities.Core.dll.  If we just let the CLR unify the simple name, it will
+            // pick the highest version on the machine, which means that in hosts with restrictive binding
+            // redirects, or no binding redirects, we'd end up creating an inline task that could not be
             // run.  Instead, to make sure that we can actually use what we're building, just use the Framework
             // and Utilities currently loaded into this process -- Since we're in Microsoft.Build.Tasks.Core.dll
             // right now, by definition both of them are always already loaded.
diff --git a/src/Tasks/ComDependencyWalker.cs b/src/Tasks/ComDependencyWalker.cs
index f998d3be668..a0cdd95b2cd 100644
--- a/src/Tasks/ComDependencyWalker.cs
+++ b/src/Tasks/ComDependencyWalker.cs
@@ -13,7 +13,7 @@
 
 namespace Microsoft.Build.Tasks
 {
-    // Abstract the method for releasing COM objects for unit testing. 
+    // Abstract the method for releasing COM objects for unit testing.
     // Our mocks are not actually COM objects and they would blow up if passed to the real Marshal.ReleaseComObject.
     internal delegate int MarshalReleaseComObject(object o);
 
@@ -217,7 +217,7 @@ private static bool CanSkipType(ITypeInfo typeInfo, ITypeLib typeLib, TYPEATTR t
                 return true;
             }
 
-            // Is this the Guid type? If so we should be using the corresponding .NET type. 
+            // Is this the Guid type? If so we should be using the corresponding .NET type.
             if (typeLibAttributes.guid == NativeMethods.IID_StdOle)
             {
                 typeInfo.GetDocumentation(-1, out string typeName, out _, out _, out _);
@@ -399,7 +399,7 @@ internal ICollection<string> GetAnalyzedTypeNames()
         }
 
         /// <summary>
-        /// Clear the dependency list so we can read dependencies incrementally but still have the advantage of 
+        /// Clear the dependency list so we can read dependencies incrementally but still have the advantage of
         /// not scanning previously seen types
         /// </summary>
         internal void ClearDependencyList()
@@ -408,8 +408,8 @@ internal void ClearDependencyList()
         }
 
         /// <summary>
-        /// Clear the analyzed type cache.  This is necessary if we have to resolve dependencies that are also 
-        /// COM references in the project, or we may get an inaccurate view of what their dependencies are. 
+        /// Clear the analyzed type cache.  This is necessary if we have to resolve dependencies that are also
+        /// COM references in the project, or we may get an inaccurate view of what their dependencies are.
         /// </summary>
         internal void ClearAnalyzedTypeCache()
         {
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index 95d63adb880..340be0e84b1 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -13,7 +13,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Abstract base class for COM reference wrappers providing common functionality. 
+    /// Abstract base class for COM reference wrappers providing common functionality.
     /// This class hierarchy is used by the ResolveComReference task.Every class deriving from ComReference
     /// provides functionality for wrapping Com type libraries in a given way(for example AxReference, or PiaReference).
     /// </summary>
@@ -57,7 +57,7 @@ internal ComReference(TaskLoggingHelper taskLoggingHelper, bool silent, ComRefer
         protected internal TaskLoggingHelper Log { get; }
 
         /// <summary>
-        /// True if this class should only log errors, but no messages or warnings.  
+        /// True if this class should only log errors, but no messages or warnings.
         /// </summary>
         protected internal bool Silent { get; }
 
@@ -87,7 +87,7 @@ internal static bool Ado27Installed
                 }
                 catch (COMException ex)
                 {
-                    // it's not registered. 
+                    // it's not registered.
                     ado27Installed = false;
                     ado27ErrorMessage = ex.Message;
                 }
@@ -231,7 +231,7 @@ internal static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex,
         }
 
         /// <summary>
-        /// Gets the name of given type library. 
+        /// Gets the name of given type library.
         /// </summary>
         internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silent, ITypeLib typeLib, string typeLibId, out string typeLibName)
         {
@@ -245,12 +245,12 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
             }
 
             // Get the custom attribute.  If anything fails then just return the
-            // type library name.  
+            // type library name.
             try
             {
                 typeLib2.GetCustData(ref NativeMethods.GUID_TYPELIB_NAMESPACE, out object data);
 
-                // if returned namespace is null or its type is not System.String, fall back to the default 
+                // if returned namespace is null or its type is not System.String, fall back to the default
                 // way of getting the type lib name (just to be safe)
                 if (data == null || !string.Equals(data.GetType().ToString(), "system.string", StringComparison.OrdinalIgnoreCase))
                 {
@@ -439,13 +439,13 @@ private static string GetModuleFileName(IntPtr handle)
         internal static bool GetPathOfTypeLib(TaskLoggingHelper log, bool silent, ref TYPELIBATTR typeLibAttr, out string typeLibPath)
         {
             // Get which file the type library resides in.  If the appropriate
-            // file cannot be found then a blank string is returned.  
+            // file cannot be found then a blank string is returned.
             typeLibPath = "";
 
             try
             {
                 // Get the path from the registry
-                // This call has known issues. See http://msdn.microsoft.com/en-us/library/ms221436.aspx for the method and 
+                // This call has known issues. See http://msdn.microsoft.com/en-us/library/ms221436.aspx for the method and
                 // here for the fix http://support.microsoft.com/kb/982110. Most users from Win7 or Win2008R2 should have already received this post Win7SP1.
                 // In Summary: The issue is about calls to The QueryPathOfRegTypeLib function not returning the correct path for a 32-bit version of a
                 // registered type library in a 64-bit edition of Windows 7 or in Windows Server 2008 R2. It either returns the 64bit path or null.
diff --git a/src/Tasks/ComReferenceInfo.cs b/src/Tasks/ComReferenceInfo.cs
index 7ba6eff1a9f..c813f7a2e0b 100644
--- a/src/Tasks/ComReferenceInfo.cs
+++ b/src/Tasks/ComReferenceInfo.cs
@@ -23,7 +23,7 @@ internal class ComReferenceInfo
         #region Properties
 
         /// <summary>
-        /// ITypeLib pointer 
+        /// ITypeLib pointer
         /// </summary>
         internal ITypeLib typeLibPointer;
 
@@ -40,14 +40,14 @@ internal class ComReferenceInfo
 
         /// <summary>
         /// path to the reference, with typelibrary number stripped, if any (so ref1.dll\2 becomes ref1.dll).
-        /// The full path is only used for loading the type library, and it's not necessary 
+        /// The full path is only used for loading the type library, and it's not necessary
         /// to do it after the interface pointer is cached in this object.
         /// </summary>
         internal string strippedTypeLibPath;
 
         /// <summary>
-        /// When using TlbImp.exe, we need to make sure that we keep track of the non-stripped typelib path, 
-        /// because that's what we need to pass to TlbImp.  
+        /// When using TlbImp.exe, we need to make sure that we keep track of the non-stripped typelib path,
+        /// because that's what we need to pass to TlbImp.
         /// </summary>
         internal string fullTypeLibPath;
 
@@ -67,12 +67,12 @@ internal class ComReferenceInfo
         internal ComReferenceWrapperInfo resolvedWrapper;
 
         /// <summary>
-        /// List of the paths to COM wrapper assemblies that this reference is dependent upon. 
+        /// List of the paths to COM wrapper assemblies that this reference is dependent upon.
         /// </summary>
         internal List<string> dependentWrapperPaths;
 
         /// <summary>
-        /// Reference to the ITaskItem generated from the resolved reference, if any. 
+        /// Reference to the ITaskItem generated from the resolved reference, if any.
         /// </summary>
         internal ITaskItem referencePathItem;
 
@@ -125,12 +125,12 @@ internal bool InitializeWithTypeLibAttrs(TaskLoggingHelper log, bool silent, TYP
             }
 
             // Now that we have the path, we can call InitializeWithPath to get the correct TYPELIBATTR set up
-            // and the correct ITypeLib pointer. 
+            // and the correct ITypeLib pointer.
             return InitializeWithPath(log, silent, this.fullTypeLibPath, originalTaskItem, targetProcessorArchitecture);
         }
 
         /// <summary>
-        /// Initialize the object with a type library path 
+        /// Initialize the object with a type library path
         /// </summary>
         internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path, ITaskItem originalTaskItem, string targetProcessorArchitecture)
         {
@@ -139,12 +139,12 @@ internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path
             this.taskItem = originalTaskItem;
 
             // Note that currently we DO NOT remap file ADO references. This is because when pointing to a file on disk,
-            // it seems unnatural to remap it to something else - a file reference means "use THIS component". 
+            // it seems unnatural to remap it to something else - a file reference means "use THIS component".
             // This is still under debate though, and may be revised later.
 
             // save both the stripped and full path in our object -- for the most part we just need the stripped path, but if
-            // we're using tlbimp.exe, we need to pass the full path w/ type lib number to it, or it won't generate the interop 
-            // assembly correctly. 
+            // we're using tlbimp.exe, we need to pass the full path w/ type lib number to it, or it won't generate the interop
+            // assembly correctly.
             this.fullTypeLibPath = path;
             this.strippedTypeLibPath = ComReference.StripTypeLibNumberFromPath(path, File.Exists);
 
diff --git a/src/Tasks/ComReferenceResolutionException.cs b/src/Tasks/ComReferenceResolutionException.cs
index 60839797eea..6f8e13d8c66 100644
--- a/src/Tasks/ComReferenceResolutionException.cs
+++ b/src/Tasks/ComReferenceResolutionException.cs
@@ -9,7 +9,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Internal exception thrown when there's an unrecoverable failure resolving a COM reference and we should 
+    /// Internal exception thrown when there's an unrecoverable failure resolving a COM reference and we should
     /// move on to the next one, if it makes sense.
     /// </summary>
     // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
diff --git a/src/Tasks/CommandLineBuilderExtension.cs b/src/Tasks/CommandLineBuilderExtension.cs
index b5ab47e0073..02f5ec2f8ef 100644
--- a/src/Tasks/CommandLineBuilderExtension.cs
+++ b/src/Tasks/CommandLineBuilderExtension.cs
@@ -195,7 +195,7 @@ internal void AppendSwitchWithSplitting(string switchName, string parameter, str
         }
 
         /// <summary>
-        /// Returns true if the parameter is empty in spirits, 
+        /// Returns true if the parameter is empty in spirits,
         /// even if it contains the separators and white space only
         /// Split on the characters provided.
         /// </summary>
diff --git a/src/Tasks/ConvertToAbsolutePath.cs b/src/Tasks/ConvertToAbsolutePath.cs
index 099f6560c31..985dd77a979 100644
--- a/src/Tasks/ConvertToAbsolutePath.cs
+++ b/src/Tasks/ConvertToAbsolutePath.cs
@@ -51,7 +51,7 @@ public override bool Execute()
             {
                 try
                 {
-                    // Only call Path.GetFullPath if the path is not rooted to avoid 
+                    // Only call Path.GetFullPath if the path is not rooted to avoid
                     // going to disk when it is not necessary
                     if (!Path.IsPathRooted(path.ItemSpec))
                     {
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 606677f3305..cdb28ee4dc9 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -81,9 +81,9 @@ public Copy()
         private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
-        /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since 
-        /// normally there's no point, but occasionally things get into a bad state temporarily, and retrying does actually 
-        /// succeed.  So keeping around a secret environment variable to allow forcing that behavior if necessary.  
+        /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since
+        /// normally there's no point, but occasionally things get into a bad state temporarily, and retrying does actually
+        /// succeed.  So keeping around a secret environment variable to allow forcing that behavior if necessary.
         /// </summary>
         private static bool s_alwaysRetryCopy = Environment.GetEnvironmentVariable(AlwaysRetryEnvVar) != null;
 
@@ -197,7 +197,7 @@ private static bool IsMatchingSizeAndTimeStamp(
 
         /// <summary>
         /// INTERNAL FOR UNIT-TESTING ONLY
-        /// 
+        ///
         /// We've got several environment variables that we read into statics since we don't expect them to ever
         /// reasonably change, but we need some way of refreshing their values so that we can modify them for
         /// unit testing purposes.
@@ -208,8 +208,8 @@ internal static void RefreshInternalEnvironmentValues()
         }
 
         /// <summary>
-        /// If MSBUILDALWAYSRETRY is set, also log useful diagnostic information -- as 
-        /// a warning, so it's easily visible. 
+        /// If MSBUILDALWAYSRETRY is set, also log useful diagnostic information -- as
+        /// a warning, so it's easily visible.
         /// </summary>
         private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, params object[] messageArgs)
         {
@@ -220,7 +220,7 @@ private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, p
         }
 
         /// <summary>
-        /// Copy one file from source to destination. Create the target directory if necessary and 
+        /// Copy one file from source to destination. Create the target directory if necessary and
         /// leave the file read-write.
         /// </summary>
         /// <returns>Return true to indicate success, return false to indicate failure and NO retry, return NULL to indicate retry.</returns>
@@ -268,7 +268,7 @@ private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, p
                     }
                 }
 
-                // It's very common for a lot of files to be copied to the same folder. 
+                // It's very common for a lot of files to be copied to the same folder.
                 // Eg., "c:\foo\a"->"c:\bar\a", "c:\foo\b"->"c:\bar\b" and so forth.
                 // We don't want to check whether this folder exists for every single file we copy. So store which we've checked.
                 _directoriesKnownToExist.TryAdd(destinationFolder, true);
@@ -414,7 +414,7 @@ internal bool Execute(
                 return false;
             }
 
-            // Environment variable stomps on user-requested value if it's set. 
+            // Environment variable stomps on user-requested value if it's set.
             if (Environment.GetEnvironmentVariable(AlwaysOverwriteReadOnlyFilesEnvVar) != null)
             {
                 OverwriteReadOnlyFiles = true;
@@ -456,7 +456,7 @@ private bool CopySingleThreaded(
             destinationFilesSuccessfullyCopied = new List<ITaskItem>(DestinationFiles.Length);
 
             // Set of files we actually copied and the location from which they were originally copied.  The purpose
-            // of this collection is to let us skip copying duplicate files.  We will only copy the file if it 
+            // of this collection is to let us skip copying duplicate files.  We will only copy the file if it
             // either has never been copied to this destination before (key doesn't exist) or if we have copied it but
             // from a different location (value is different.)
             // { dest -> source }
@@ -720,8 +720,8 @@ private bool InitializeDestinationFiles()
                     }
 
                     // Initialize the destinationFolder item.
-                    // ItemSpec is unescaped, and the TaskItem constructor expects an escaped input, so we need to 
-                    // make sure to re-escape it here. 
+                    // ItemSpec is unescaped, and the TaskItem constructor expects an escaped input, so we need to
+                    // make sure to re-escape it here.
                     DestinationFiles[i] = new TaskItem(EscapingUtilities.Escape(destinationFile));
 
                     // Copy meta-data from source to destinationFolder.
@@ -832,10 +832,10 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                                 // ERROR_ACCESS_DENIED can either mean there's an ACL preventing us, or the file has the readonly bit set.
                                 // In either case, that's likely not a race, and retrying won't help.
                                 // Retrying is mainly for ERROR_SHARING_VIOLATION, where someone else is using the file right now.
-                                // However, there is a limited set of circumstances where a copy failure will show up as access denied due 
-                                // to a failure to reset the readonly bit properly, in which case retrying will succeed.  This seems to be 
+                                // However, there is a limited set of circumstances where a copy failure will show up as access denied due
+                                // to a failure to reset the readonly bit properly, in which case retrying will succeed.  This seems to be
                                 // a pretty edge scenario, but since some of our internal builds appear to be hitting it, provide a secret
-                                // environment variable to allow overriding the default behavior and forcing retries in this circumstance as well. 
+                                // environment variable to allow overriding the default behavior and forcing retries in this circumstance as well.
                                 if (!s_alwaysRetryCopy)
                                 {
                                     throw;
@@ -873,7 +873,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                             destinationFileState.Name, retries, RetryDelayMilliseconds, e.Message,
                             GetLockedFileMessage(destinationFileState.Name));
 
-                        // if we have to retry for some reason, wipe the state -- it may not be correct anymore. 
+                        // if we have to retry for some reason, wipe the state -- it may not be correct anymore.
                         destinationFileState.Reset();
 
                         Thread.Sleep(RetryDelayMilliseconds);
@@ -899,7 +899,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                         destinationFileState.Name, retries, RetryDelayMilliseconds, String.Empty /* no details */,
                         GetLockedFileMessage(destinationFileState.Name));
 
-                    // if we have to retry for some reason, wipe the state -- it may not be correct anymore. 
+                    // if we have to retry for some reason, wipe the state -- it may not be correct anymore.
                     destinationFileState.Reset();
 
                     Thread.Sleep(RetryDelayMilliseconds);
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index f45169c4d12..7af1e8d5105 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -49,8 +49,8 @@ protected override string CreateManifestName(
 
             /*
                 Actual implementation is in a static method called CreateManifestNameImpl.
-                The reason is that CreateManifestName can't be static because it is an 
-                override of a method declared in the base class, but its convenient 
+                The reason is that CreateManifestName can't be static because it is an
+                override of a method declared in the base class, but its convenient
                 to expose a static version anyway for unittesting purposes.
             */
             return CreateManifestNameImpl(
@@ -88,7 +88,7 @@ internal static string CreateManifestNameImpl(
             bool prependCultureAsDirectory, // true by default
             string rootNamespace, // May be null
             string dependentUponFileName, // May be null
-            string culture, // may be null 
+            string culture, // may be null
             Stream binaryStream, // File contents binary stream, may be null
             TaskLoggingHelper log,
             bool treatAsCultureNeutral = false)
@@ -103,7 +103,7 @@ internal static string CreateManifestNameImpl(
             dependentUponFileName = FileUtilities.FixFilePath(dependentUponFileName);
             Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(embeddedFileName, dependentUponFileName, treatAsCultureNeutral);
 
-            // If the item has a culture override, respect that. 
+            // If the item has a culture override, respect that.
             if (!string.IsNullOrEmpty(culture))
             {
                 info.culture = culture;
@@ -112,7 +112,7 @@ internal static string CreateManifestNameImpl(
             var manifestName = StringBuilderCache.Acquire();
             if (binaryStream != null)
             {
-                // Resource depends on a form. Now, get the form's class name fully 
+                // Resource depends on a form. Now, get the form's class name fully
                 // qualified with a namespace.
                 ExtractedClassName result = CSharpParserUtilities.GetFirstClassNameFullyQualified(binaryStream);
 
@@ -125,7 +125,7 @@ internal static string CreateManifestNameImpl(
                 {
                     manifestName.Append(result.Name);
 
-                    // Append the culture if there is one.        
+                    // Append the culture if there is one.
                     if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append('.').Append(info.culture);
@@ -134,7 +134,7 @@ internal static string CreateManifestNameImpl(
             }
 
             // If there's no manifest name at this point, then fall back to using the
-            // RootNamespace+Filename_with_slashes_converted_to_dots         
+            // RootNamespace+Filename_with_slashes_converted_to_dots
             if (manifestName.Length == 0)
             {
                 // If Rootnamespace was null, then it wasn't set from the project resourceFile.
@@ -169,7 +169,7 @@ internal static string CreateManifestNameImpl(
                     manifestName.Replace(Path.DirectorySeparatorChar, '.');
                     manifestName.Replace(Path.AltDirectorySeparatorChar, '.');
 
-                    // Append the culture if there is one.        
+                    // Append the culture if there is one.
                     if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append('.').Append(info.culture);
@@ -196,7 +196,7 @@ internal static string CreateManifestNameImpl(
 
                     if (prependCultureAsDirectory)
                     {
-                        // Prepend the culture as a subdirectory if there is one.        
+                        // Prepend the culture as a subdirectory if there is one.
                         if (!string.IsNullOrEmpty(info.culture))
                         {
                             manifestName.Insert(0, Path.DirectorySeparatorChar);
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index 78f30146616..46c8bd99c20 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -29,7 +29,7 @@ public class CreateItem : TaskExtension
         public bool PreserveExistingMetadata { get; set; } = false;
 
         /// <summary>
-        /// A list of metadata name/value pairs to apply to the output items.  
+        /// A list of metadata name/value pairs to apply to the output items.
         /// A typical input: "metadataname1=metadatavalue1", "metadataname2=metadatavalue2", ...
         /// </summary>
         /// <remarks>
@@ -38,7 +38,7 @@ public class CreateItem : TaskExtension
         ///     The fact that this is a `string[]` makes the following illegal:
         ///         `<CreateItem AdditionalMetadata="TargetPath=@(OutputPathItem)" />`
         ///     The engine fails on this because it doesn't like item lists being concatenated with string
-        ///     constants when the data is being passed into an array parameter.  So the workaround is to 
+        ///     constants when the data is being passed into an array parameter.  So the workaround is to
         ///     write this in the project file:
         ///         `<CreateItem AdditionalMetadata="@(OutputPathItem-&gt;'TargetPath=%(Identity)')" />`
         ///     ]]>
@@ -118,7 +118,7 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab
                             {
                                 if (FileUtilities.ItemSpecModifiers.IsItemSpecModifier(nameAndValue.Key))
                                 {
-                                    // Explicitly setting built-in metadata, is not allowed. 
+                                    // Explicitly setting built-in metadata, is not allowed.
                                     Log.LogErrorWithCodeFromResources("CreateItem.AdditionalMetadataError", nameAndValue.Key);
                                     break;
                                 }
diff --git a/src/Tasks/CreateManifestResourceName.cs b/src/Tasks/CreateManifestResourceName.cs
index 4d67448ef78..818e984b1fb 100644
--- a/src/Tasks/CreateManifestResourceName.cs
+++ b/src/Tasks/CreateManifestResourceName.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Base class for task that determines the appropriate manifest resource name to 
+    /// Base class for task that determines the appropriate manifest resource name to
     /// assign to a given resx or other resource.
     /// </summary>
     public abstract class CreateManifestResourceName : TaskExtension
@@ -229,8 +229,8 @@ internal bool Execute(
                     ResourceFilesWithManifestResourceNames[i].SetMetadata("ManifestResourceName", manifestName);
 
                     // Add a LogicalName metadata to Non-Resx resources
-                    // LogicalName isn't used for Resx resources because the ManifestResourceName metadata determines the filename of the 
-                    // .resources file which then is used as the embedded resource manifest name                    
+                    // LogicalName isn't used for Resx resources because the ManifestResourceName metadata determines the filename of the
+                    // .resources file which then is used as the embedded resource manifest name
                     if (string.IsNullOrEmpty(ResourceFilesWithManifestResourceNames[i].GetMetadata("LogicalName")) &&
                         string.Equals(ResourceFilesWithManifestResourceNames[i].GetMetadata("Type"), "Non-Resx", StringComparison.OrdinalIgnoreCase))
                     {
@@ -291,7 +291,7 @@ private static bool IsValidEverettIdChar(char c)
         }
 
         /// <summary>
-        /// Make a folder subname into an Everett-compatible identifier 
+        /// Make a folder subname into an Everett-compatible identifier
         /// </summary>
         private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)
         {
diff --git a/src/Tasks/CreateProperty.cs b/src/Tasks/CreateProperty.cs
index a06e4b5a384..7980feb2d14 100644
--- a/src/Tasks/CreateProperty.cs
+++ b/src/Tasks/CreateProperty.cs
@@ -19,19 +19,19 @@ public class CreateProperty : TaskExtension
         /// <remarks>
         /// So ... why is this a string[] instead of a string?
         /// Basically if the project author passed in:
-        /// 
+        ///
         ///         CreateProperty Value="Clean;Build"
         ///             Output TaskParameter="Value" PropertyName="MyTargetsToBuild"
         ///         /CreateProperty
-        /// 
+        ///
         /// We need to respect the semicolon that they put in the value, and need to treat
         /// this exactly as if they had done:
-        /// 
+        ///
         ///         PropertyGroup
         ///             MyTargetsToBuild="Clean;Build"
         ///         /PropertyGroup
-        /// 
-        /// If we make this parameter a "string", then the engine will escape the 
+        ///
+        /// If we make this parameter a "string", then the engine will escape the
         /// value on the way out from the task back to the engine, creating a property
         /// that is set to "Clean%3BBuild", which is not what the user wanted.
         /// </remarks>
@@ -39,7 +39,7 @@ public class CreateProperty : TaskExtension
         public string[] Value { get; set; }
 
         /// <summary>
-        /// This is to fool MSBuild into not doing its little TLDA trick whereby even if 
+        /// This is to fool MSBuild into not doing its little TLDA trick whereby even if
         /// a target is up-to-date, it will still set the properties that were meant to
         /// be set using the CreateProperty task.  This is because MSBuild is smart enough
         /// to figure out the value of the output property without running the task.
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 9b02e0109bc..b73a9a9f41d 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -48,8 +48,8 @@ protected override string CreateManifestName(
 
             /*
                 Actual implementation is in a static method called CreateManifestNameImpl.
-                The reason is that CreateManifestName can't be static because it is an 
-                override of a method declared in the base class, but its convenient 
+                The reason is that CreateManifestName can't be static because it is an
+                override of a method declared in the base class, but its convenient
                 to expose a static version anyway for unittesting purposes.
             */
             return CreateManifestNameImpl(
@@ -101,7 +101,7 @@ internal static string CreateManifestNameImpl(
 
             Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(embeddedFileName, dependentUponFileName, treatAsCultureNeutral);
 
-            // If the item has a culture override, respect that. 
+            // If the item has a culture override, respect that.
             if (!string.IsNullOrEmpty(culture))
             {
                 info.culture = culture;
@@ -110,7 +110,7 @@ internal static string CreateManifestNameImpl(
             var manifestName = StringBuilderCache.Acquire();
             if (binaryStream != null)
             {
-                // Resource depends on a form. Now, get the form's class name fully 
+                // Resource depends on a form. Now, get the form's class name fully
                 // qualified with a namespace.
                 ExtractedClassName result = VisualBasicParserUtilities.GetFirstClassNameFullyQualified(binaryStream);
 
@@ -129,7 +129,7 @@ internal static string CreateManifestNameImpl(
                     manifestName.Append(result.Name);
 
 
-                    // Append the culture if there is one.        
+                    // Append the culture if there is one.
                     if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append('.').Append(info.culture);
@@ -159,7 +159,7 @@ internal static string CreateManifestNameImpl(
                 {
                     manifestName.Append(Path.GetFileNameWithoutExtension(info.cultureNeutralFilename));
 
-                    // Append the culture if there is one.        
+                    // Append the culture if there is one.
                     if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append('.').Append(info.culture);
@@ -177,7 +177,7 @@ internal static string CreateManifestNameImpl(
 
                     if (prependCultureAsDirectory)
                     {
-                        // Prepend the culture as a subdirectory if there is one.        
+                        // Prepend the culture as a subdirectory if there is one.
                         if (!string.IsNullOrEmpty(info.culture))
                         {
                             manifestName.Insert(0, Path.DirectorySeparatorChar);
diff --git a/src/Tasks/DataDriven/DataDrivenToolTask.cs b/src/Tasks/DataDriven/DataDrivenToolTask.cs
index 49e1f88988a..444f2f6dba0 100644
--- a/src/Tasks/DataDriven/DataDrivenToolTask.cs
+++ b/src/Tasks/DataDriven/DataDrivenToolTask.cs
@@ -80,7 +80,7 @@ protected Dictionary<string, ToolSwitch> ActiveToolSwitches
                 return activeToolSwitches;
             }
         }
-        
+
         /// <summary>
         /// The additional options that have been set. These are raw switches that
         /// go last on the command line.
@@ -98,13 +98,13 @@ public string AdditionalOptions
         }
 
         /// <summary>
-        /// Overridden to use UTF16, which works better than UTF8 for older versions of CL, LIB, etc. 
+        /// Overridden to use UTF16, which works better than UTF8 for older versions of CL, LIB, etc.
         /// </summary>
         protected override Encoding ResponseFileEncoding
         {
-            get 
-            { 
-                return Encoding.Unicode; 
+            get
+            {
+                return Encoding.Unicode;
             }
         }
 
@@ -155,7 +155,7 @@ protected override string GenerateFullPathToTool()
         /// <returns></returns>
         override protected bool ValidateParameters()
         {
-            return !logPrivate.HasLoggedErrors && !Log.HasLoggedErrors; 
+            return !logPrivate.HasLoggedErrors && !Log.HasLoggedErrors;
         }
 
 #if WHIDBEY_BUILD
@@ -174,7 +174,7 @@ protected void DeleteTempFile(string fileName)
             {
                 if (ExceptionHandling.NotExpectedException(e))
                     throw;
-                // Warn only -- occasionally temp files fail to delete because of virus checkers; we 
+                // Warn only -- occasionally temp files fail to delete because of virus checkers; we
                 // don't want the build to fail in such cases
                 Log.LogWarningWithCodeFromResources("Shared.FailedDeletingTempFile", fileName, e.Message);
             }
@@ -187,7 +187,7 @@ protected void DeleteTempFile(string fileName)
         /// Returns the generated command line
         /// </summary>
         /// <returns></returns>
-        internal string GetCommandLine_ForUnitTestsOnly() 
+        internal string GetCommandLine_ForUnitTestsOnly()
         {
             return GenerateResponseFileCommands();
         }
@@ -209,7 +209,7 @@ protected override string GenerateCommandLineCommands()
         /// Creates the command line and returns it as a string by:
         /// 1. Adding all switches with the default set to the active switch list
         /// 2. Customizing the active switch list (overridden in derived classes)
-        /// 3. Iterating through the list and appending switches 
+        /// 3. Iterating through the list and appending switches
         /// </summary>
         /// <returns></returns>
         protected override string GenerateResponseFileCommands()
@@ -242,7 +242,7 @@ protected virtual bool VerifyRequiredArgumentsArePresent(ToolSwitch property, bo
         /// <returns></returns>
         protected virtual bool VerifyDependenciesArePresent(ToolSwitch property)
         {
-            // check the dependency 
+            // check the dependency
             if (property.Parents.Count > 0)
             {
                 // has a dependency, now check to see whether at least one parent is set
@@ -435,11 +435,11 @@ private string GenerateCommands()
         }
 
         /// <summary>
-        /// Checks to see if the argument is required and whether an argument exists, and returns the 
+        /// Checks to see if the argument is required and whether an argument exists, and returns the
         /// argument or else fallback argument if it exists.
-        /// 
+        ///
         /// These are the conditions to look at:
-        /// 
+        ///
         /// ArgumentRequired    ArgumentParameter   FallbackArgumentParameter   Result
         /// true                isSet               NA                          The value in ArgumentParameter gets returned
         /// true                isNotSet            isSet                       The value in FallbackArgumentParamter gets returned
@@ -452,7 +452,7 @@ private string GenerateCommands()
         /// <returns></returns>
         protected virtual string GetEffectiveArgumentsValues(ToolSwitch toolSwitch)
         {
-            //if (!toolSwitch.ArgumentRequired && !IsPropertySet(toolSwitch.ArgumentParameter) && 
+            //if (!toolSwitch.ArgumentRequired && !IsPropertySet(toolSwitch.ArgumentParameter) &&
             //    !IsPropertySet(toolSwitch.FallbackArgumentParameter))
             //{
             //    return String.Empty;
@@ -519,7 +519,7 @@ private static void EmitFileSwitch(CommandLineBuilder clb, ToolSwitch toolSwitch
                         str += "\"";
                 }
 
-                //we want quotes always, AppendSwitchIfNotNull will add them on as needed bases 
+                //we want quotes always, AppendSwitchIfNotNull will add them on as needed bases
                 clb.AppendSwitchUnquotedIfNotNull(toolSwitch.SwitchValue + toolSwitch.Separator, str);
             }
         }
@@ -552,10 +552,10 @@ private void EmitIntegerSwitch(CommandLineBuilder clb, ToolSwitch toolSwitch)
         /// The switch may be empty.
         /// </summary>
         /// <remarks>For stringarray switches (e.g., Sources), the toolSwitchName (if it exists) is emitted
-        /// along with each and every one of the file names separately (if no separator is included), or with all of the 
+        /// along with each and every one of the file names separately (if no separator is included), or with all of the
         /// file names separated by the separator.
         /// e.g., AdditionalIncludeDirectores = "@(Files)" where Files has File1, File2, and File3, the switch
-        /// /IFile1 /IFile2 /IFile3 or the switch /IFile1;File2;File3 is emitted (the latter case has a separator 
+        /// /IFile1 /IFile2 /IFile3 or the switch /IFile1;File2;File3 is emitted (the latter case has a separator
         /// ";" specified)</remarks>
         /// <param name="clb"></param>
         /// <param name="toolSwitch"></param>
@@ -564,7 +564,7 @@ private static void EmitStringArraySwitch(CommandLineBuilder clb, ToolSwitch too
             string[] ArrTrimStringList = new string [toolSwitch.StringList.Length];
             for (int i=0; i<toolSwitch.StringList.Length; ++i)
             {
-                //Make sure the file doesn't contain escaped " (\") 
+                //Make sure the file doesn't contain escaped " (\")
                 if (toolSwitch.StringList[i].StartsWith("\"") && toolSwitch.StringList[i].EndsWith("\""))
                 {
                     ArrTrimStringList[i] = toolSwitch.StringList[i].Substring(1, toolSwitch.StringList[i].Length - 2);
@@ -589,7 +589,7 @@ private static void EmitStringArraySwitch(CommandLineBuilder clb, ToolSwitch too
         }
 
         /// <summary>
-        /// Generates the switches for switches that either have literal strings appended, or have 
+        /// Generates the switches for switches that either have literal strings appended, or have
         /// different switches based on what the property is set to.
         /// </summary>
         /// <remarks>The string switch emits a switch that depends on what the parameter is set to, with and
@@ -601,7 +601,7 @@ private void EmitStringSwitch(CommandLineBuilder clb, ToolSwitch toolSwitch)
         {
             String strSwitch = String.Empty;
             strSwitch += toolSwitch.SwitchValue + toolSwitch.Separator;
-            
+
             StringBuilder val = new StringBuilder(GetEffectiveArgumentsValues(toolSwitch));
             String str = toolSwitch.Value;
 
@@ -625,7 +625,7 @@ private void EmitStringSwitch(CommandLineBuilder clb, ToolSwitch toolSwitch)
                 return;
 
             clb.AppendSwitchUnquotedIfNotNull(strSwitch, val.ToString());
-            
+
         }
 
         /// <summary>
@@ -655,7 +655,7 @@ private void EmitBooleanSwitch(CommandLineBuilder clb, ToolSwitch toolSwitch)
         /// <summary>
         /// Generates the command line for switches that are reversible
         /// </summary>
-        /// <remarks>A reversible boolean switch will emit a certain switch if set to true, but emit that 
+        /// <remarks>A reversible boolean switch will emit a certain switch if set to true, but emit that
         /// exact same switch with a flag appended on the end if set to false.
         /// e.g., GlobalOptimizations = "true" will emit /Og, and GlobalOptimizations = "false" will emit /Og-</remarks>
         /// <param name="clb"></param>
@@ -710,9 +710,9 @@ protected bool ValidateInteger(string switchName, int min, int max, int value)
                 logPrivate.LogErrorFromResources("ArgumentOutOfRange", switchName, value);
                 return false;
             }
-           
+
             return true;
-            
+
         }
 
         /// <summary>
@@ -785,7 +785,7 @@ protected bool IsExplicitlySetToFalse(string propertyName)
                 return false;
             }
         }
-        
+
         /// <summary>
         /// Checks to see if the switch name is empty
         /// </summary>
diff --git a/src/Tasks/Delegate.cs b/src/Tasks/Delegate.cs
index f3c37bd0023..b315d29426b 100644
--- a/src/Tasks/Delegate.cs
+++ b/src/Tasks/Delegate.cs
@@ -80,7 +80,7 @@ namespace Microsoft.Build.Tasks
     internal delegate string GetPathFromFusionName(string strongName);
 
     /// <summary>
-    /// Delegate. Given an assembly name, crack it open and retrieve the list of dependent 
+    /// Delegate. Given an assembly name, crack it open and retrieve the list of dependent
     /// assemblies and  the list of scatter files.
     /// </summary>
     /// <param name="path">Path to the assembly.</param>
@@ -106,7 +106,7 @@ internal delegate void GetAssemblyMetadata(
     internal delegate string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, System.Reflection.ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, bool fullFusionName, bool specificVersion);
 
     /// <summary>
-    /// Determines if a assembly is an winmd file 
+    /// Determines if a assembly is an winmd file
     /// </summary>
     internal delegate bool IsWinMDFile(string fullpath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, out string imageRuntimeVersion, out bool isManagedWinmd);
 
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index 9908267c4a8..a5a2c3ec528 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -25,7 +25,7 @@ internal class DependencyFile
         // Filename
         internal string filename;
 
-        // Date and time the file was last modified           
+        // Date and time the file was last modified
         internal DateTime lastModified;
 
         // Whether the file exists or not.
diff --git a/src/Tasks/ErrorFromResources.cs b/src/Tasks/ErrorFromResources.cs
index b143db2d35e..a95a8ca2fd6 100644
--- a/src/Tasks/ErrorFromResources.cs
+++ b/src/Tasks/ErrorFromResources.cs
@@ -33,7 +33,7 @@ public sealed class ErrorFromResources : TaskExtension
 
         /// <summary>
         /// Relevant file if any.
-        /// If none is provided, the file containing the Error 
+        /// If none is provided, the file containing the Error
         /// task will be used.
         /// </summary>
         public string File { get; set; }
@@ -52,7 +52,7 @@ public override bool Execute()
             {
                 string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, Log.FormatResourceString(Resource, Arguments), out string errorCode);
 
-                // If the user specifies a code, that should override. 
+                // If the user specifies a code, that should override.
                 Code ??= errorCode;
 
                 Log.LogError(null, Code, HelpKeyword, File, 0, 0, 0, 0, message);
diff --git a/src/Tasks/FileIO/ReadLinesFromFile.cs b/src/Tasks/FileIO/ReadLinesFromFile.cs
index ead4981ecfe..86b5ca17068 100644
--- a/src/Tasks/FileIO/ReadLinesFromFile.cs
+++ b/src/Tasks/FileIO/ReadLinesFromFile.cs
@@ -57,7 +57,7 @@ public override bool Execute()
                             if (trimmedTextLine.Length > 0)
                             {
                                 // The lines were written to the file in unescaped form, so we need to escape them
-                                // before passing them to the TaskItem. 
+                                // before passing them to the TaskItem.
                                 nonEmptyLines.Add(new TaskItem(EscapingUtilities.Escape(trimmedTextLine)));
                             }
                         }
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index 4e00e4af725..17cb7ca702c 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.Tasks
 {
     /// <summary>
     /// CopyFile delegate
-    /// 
+    ///
     /// returns  Success = true, Failure = false; Retry = null
     /// </summary>
     /// <param name="source">Source file</param>
@@ -26,7 +26,7 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     /// <remarks>
     /// Uses PInvoke rather than FileInfo because the latter does all kinds of expensive checks.
-    /// 
+    ///
     /// Deficiency: some of the properties eat some or all exceptions. If they are called first, they will
     /// trigger the population and eat. Subsequent calls will then not throw, but instead eg return zero.
     /// This could be fixed by storing the exception from the population, and throwing no matter who does
@@ -92,7 +92,7 @@ public FileDirInfo(string filename)
                     // THIS COPIED FROM THE BCL:
                     //
                     // For floppy drives, normally the OS will pop up a dialog saying
-                    // there is no disk in drive A:, please insert one.  We don't want that. 
+                    // there is no disk in drive A:, please insert one.  We don't want that.
                     // SetErrorMode will let us disable this, but we should set the error
                     // mode back, since this may have wide-ranging effects.
                     NativeMethodsShared.SetThreadErrorMode(1 /* ErrorModes.SEM_FAILCRITICALERRORS */, out oldMode);
diff --git a/src/Tasks/FindInList.cs b/src/Tasks/FindInList.cs
index 6ce91dcfd3b..214d4dccebc 100644
--- a/src/Tasks/FindInList.cs
+++ b/src/Tasks/FindInList.cs
@@ -57,7 +57,7 @@ public ITaskItem[] List
         public bool CaseSensitive { get; set; }
 
         /// <summary>
-        /// Whether or not to return the last match, instead of 
+        /// Whether or not to return the last match, instead of
         /// the first one
         /// </summary>
         public bool FindLastMatch { get; set; }
diff --git a/src/Tasks/FindInvalidProjectReferences.cs b/src/Tasks/FindInvalidProjectReferences.cs
index 7342f60e6f4..791ac147af6 100644
--- a/src/Tasks/FindInvalidProjectReferences.cs
+++ b/src/Tasks/FindInvalidProjectReferences.cs
@@ -62,7 +62,7 @@ public class FindInvalidProjectReferences : TaskExtension
         public string TargetPlatformIdentifier { get; set; }
 
         /// <summary>
-        /// Invalid references to be unresolved 
+        /// Invalid references to be unresolved
         /// </summary>
         [Output]
         public ITaskItem[] InvalidReferences { get; private set; }
@@ -87,7 +87,7 @@ public override bool Execute()
                     string referenceIdentity = item.ItemSpec;
                     string referencePlatformMoniker = item.GetMetadata(ReferencePlatformMonikerMetadata);
 
-                    // For each moniker, compare version, issue localized message if the referenced project targets 
+                    // For each moniker, compare version, issue localized message if the referenced project targets
                     // a platform with version higher than the current project and make the reference invalid by adding it to
                     // an invalid reference list output
                     if (ParseMoniker(referencePlatformMoniker, out _, out Version version))
diff --git a/src/Tasks/GenerateApplicationManifest.cs b/src/Tasks/GenerateApplicationManifest.cs
index 56424601861..1c32b6feb36 100644
--- a/src/Tasks/GenerateApplicationManifest.cs
+++ b/src/Tasks/GenerateApplicationManifest.cs
@@ -383,7 +383,7 @@ protected internal override bool ValidateInputs()
 
         private bool BuildResolvedSettings(ApplicationManifest manifest)
         {
-            // Note: if changing the logic in this function, please update the logic in 
+            // Note: if changing the logic in this function, please update the logic in
             //  GenerateDeploymentManifest.BuildResolvedSettings as well.
             if (Product != null)
             {
diff --git a/src/Tasks/GenerateBootstrapper.cs b/src/Tasks/GenerateBootstrapper.cs
index 241ca0a4610..28c019d7ef9 100644
--- a/src/Tasks/GenerateBootstrapper.cs
+++ b/src/Tasks/GenerateBootstrapper.cs
@@ -98,12 +98,12 @@ public override bool Execute()
 
             if (BootstrapperItems != null)
             {
-                // The bootstrapper items may not be in the correct order, because XMake saves 
-                // items in alphabetical order.  So we will attempt to put items into the correct 
-                // order, according to the Products order in the search.  To do this, we add all 
-                // the items we are told to build into a hashtable, then go through our products 
-                // in order, looking to see if the item is built.  If it is, remove the item from 
-                // the hashtable.  All remaining items in the table can not be built, so errors 
+                // The bootstrapper items may not be in the correct order, because XMake saves
+                // items in alphabetical order.  So we will attempt to put items into the correct
+                // order, according to the Products order in the search.  To do this, we add all
+                // the items we are told to build into a hashtable, then go through our products
+                // in order, looking to see if the item is built.  If it is, remove the item from
+                // the hashtable.  All remaining items in the table can not be built, so errors
                 // will be issued.
                 var items = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
 
diff --git a/src/Tasks/GenerateDeploymentManifest.cs b/src/Tasks/GenerateDeploymentManifest.cs
index 729deffab5c..897ba49d15f 100644
--- a/src/Tasks/GenerateDeploymentManifest.cs
+++ b/src/Tasks/GenerateDeploymentManifest.cs
@@ -125,7 +125,7 @@ public int UpdateInterval
 
         private bool BuildResolvedSettings(DeployManifest manifest)
         {
-            // Note: if changing the logic in this function, please update the logic in 
+            // Note: if changing the logic in this function, please update the logic in
             //  GenerateApplicationManifest.BuildResolvedSettings as well.
             if (Product != null)
             {
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index daec24f865d..c66e8542878 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Performs SetPlatform negotiation for all project references when opted
     /// in via the EnableDynamicPlatformResolution property.
-    /// 
+    ///
     /// See ProjectReference-Protocol.md for details.
     /// </summary>
     public class GetCompatiblePlatform : TaskExtension
@@ -23,7 +23,7 @@ public class GetCompatiblePlatform : TaskExtension
         public ITaskItem[] AnnotatedProjects { get; set; }
 
         /// <summary>
-        /// The platform the current project is building as. 
+        /// The platform the current project is building as.
         /// </summary>
         [Required]
         public string CurrentProjectPlatform { get; set; }
diff --git a/src/Tasks/GetReferenceAssemblyPaths.cs b/src/Tasks/GetReferenceAssemblyPaths.cs
index 08f3821f66c..621291acdac 100644
--- a/src/Tasks/GetReferenceAssemblyPaths.cs
+++ b/src/Tasks/GetReferenceAssemblyPaths.cs
@@ -107,7 +107,7 @@ public string[] FullFrameworkReferenceAssemblyPaths
         /// to ensure that certain runtime frameworks are installed depending on the
         /// target framework.
         /// set BypassFrameworkInstallChecks to true in order to bypass those checks.
-        /// </summary>        
+        /// </summary>
         public bool BypassFrameworkInstallChecks { get; set; }
 
         /// <summary>
@@ -146,7 +146,7 @@ public override bool Execute()
             FrameworkNameVersioning moniker;
             FrameworkNameVersioning monikerWithNoProfile = null;
 
-            // Are we targeting a profile. 
+            // Are we targeting a profile.
             bool targetingProfile;
 
             try
@@ -154,7 +154,7 @@ public override bool Execute()
                 moniker = new FrameworkNameVersioning(TargetFrameworkMoniker);
                 targetingProfile = !String.IsNullOrEmpty(moniker.Profile);
 
-                // If we are targeting a profile we need to generate a set of reference assembly paths which describe where the full framework 
+                // If we are targeting a profile we need to generate a set of reference assembly paths which describe where the full framework
                 //  exists, to do so we need to get the reference assembly location without the profile as part of the moniker.
                 if (targetingProfile)
                 {
@@ -216,7 +216,7 @@ public override bool Execute()
             }
             catch (Exception e)
             {
-                // The reason we need to do exception E here is because we are in a task and have the ability to log the message and give the user 
+                // The reason we need to do exception E here is because we are in a task and have the ability to log the message and give the user
                 // feedback as to its cause, tasks if at all possible should not have exception leave them.
                 Log.LogErrorWithCodeFromResources("GetReferenceAssemblyPaths.ProblemGeneratingReferencePaths", TargetFrameworkMoniker, e.Message);
 
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index c5bc3724e33..2af5faaf3b8 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -247,7 +247,7 @@ internal bool Execute(GetAssemblyName getAssemblyName, GetAssemblyRuntimeVersion
 
             try
             {
-                // Filter out all references tagged as RuntimeReferenceOnly 
+                // Filter out all references tagged as RuntimeReferenceOnly
                 IEnumerable<ITaskItem> filteredResolvedSDKReferences = ResolvedSDKReferences.Where(
                     sdkReference => !MetadataConversionUtilities.TryConvertItemMetadataToBool(sdkReference, "RuntimeReferenceOnly"));
 
@@ -791,7 +791,7 @@ public bool Equals(ResolvedReferenceAssembly other)
                 }
 
                 // We only care about the file name and not the path because if they have the same file name but different paths then they will likely contain
-                // the same namespaces and the compiler does not like to have two references with the same namespace passed at once without aliasing and 
+                // the same namespaces and the compiler does not like to have two references with the same namespace passed at once without aliasing and
                 // we have no way to do aliasing per assembly since we are grabbing a bunch of files at once.)
                 return String.Equals(FileName, other.FileName, StringComparison.OrdinalIgnoreCase);
             }
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index 23615f93af7..ea271573fd0 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -121,8 +121,8 @@ public override bool Execute()
 
         private HashAlgorithm CreateHashAlgorithm()
         {
-            return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) ? 
-                SHA256.Create() : 
+            return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) ?
+                SHA256.Create() :
 #pragma warning disable CA5350
                 // Kept for back compatibility reasons when chnange wave is opted-out
                 SHA1.Create();
diff --git a/src/Tasks/IComReferenceResolver.cs b/src/Tasks/IComReferenceResolver.cs
index b8682a8eb22..579dc330f9b 100644
--- a/src/Tasks/IComReferenceResolver.cs
+++ b/src/Tasks/IComReferenceResolver.cs
@@ -31,8 +31,8 @@ internal interface IComReferenceResolver
 
         /*
          * Method:  ResolveComAssemblyReference
-         * 
-         * 
+         *
+         *
          */
         /// <summary>
         /// Resolves a COM wrapper assembly reference based on the COM references resolved so far. This method is necessary
diff --git a/src/Tasks/IVbcHostObjectFreeThreaded.cs b/src/Tasks/IVbcHostObjectFreeThreaded.cs
index c6a763f3224..994bac7ea92 100644
--- a/src/Tasks/IVbcHostObjectFreeThreaded.cs
+++ b/src/Tasks/IVbcHostObjectFreeThreaded.cs
@@ -10,10 +10,10 @@ namespace Microsoft.Build.Tasks.Hosting
     /// <summary>
     /// Defines a free threaded interface for the Vbc task to communicate with the IDE.  In particular,
     /// the Vbc task will delegate the actual compilation to the IDE, rather than shelling
-    /// out to the command-line compilers. 
+    /// out to the command-line compilers.
     /// This particular version of Compile (unlike the IVbcHostObject::Compile) is not marshalled back to the UI
     /// thread. The implementor of the interface is responsible for any marshalling.
-    /// This was added to allow some of the implementors code to run on the BG thread from which VBC Task is being 
+    /// This was added to allow some of the implementors code to run on the BG thread from which VBC Task is being
     /// called from.
     /// </summary>
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
diff --git a/src/Tasks/ListOperators/FindUnderPath.cs b/src/Tasks/ListOperators/FindUnderPath.cs
index b4e08b145e8..836ec12b0f0 100644
--- a/src/Tasks/ListOperators/FindUnderPath.cs
+++ b/src/Tasks/ListOperators/FindUnderPath.cs
@@ -94,7 +94,7 @@ public override bool Execute()
                 {
                     // If we should use the absolute path, update the item contents
                     // Since ItemSpec, which fullPath comes from, is unescaped, re-escape when setting
-                    // item.ItemSpec, since the setter for ItemSpec expects an escaped value. 
+                    // item.ItemSpec, since the setter for ItemSpec expects an escaped value.
                     if (UpdateToAbsolutePaths)
                     {
                         item.ItemSpec = EscapingUtilities.Escape(fullPath);
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index e158a09f092..3def6381e12 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -279,17 +279,17 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
                 //
                 // Obtain the list of affected applications/services.
                 //
-                // NOTE: Restart Manager returns the results into the buffer allocated by the caller. The first call to 
-                // RmGetList() will return the size of the buffer (i.e. nProcInfoNeeded) the caller needs to allocate. 
-                // The caller then needs to allocate the buffer (i.e. rgAffectedApps) and make another RmGetList() 
-                // call to ask Restart Manager to write the results into the buffer. However, since Restart Manager 
-                // refreshes the list every time RmGetList()is called, it is possible that the size returned by the first 
-                // RmGetList()call is not sufficient to hold the results discovered by the second RmGetList() call. Therefore, 
+                // NOTE: Restart Manager returns the results into the buffer allocated by the caller. The first call to
+                // RmGetList() will return the size of the buffer (i.e. nProcInfoNeeded) the caller needs to allocate.
+                // The caller then needs to allocate the buffer (i.e. rgAffectedApps) and make another RmGetList()
+                // call to ask Restart Manager to write the results into the buffer. However, since Restart Manager
+                // refreshes the list every time RmGetList()is called, it is possible that the size returned by the first
+                // RmGetList()call is not sufficient to hold the results discovered by the second RmGetList() call. Therefore,
                 // it is recommended that the caller follows the following practice to handle this race condition:
                 //
-                //    Use a loop to call RmGetList() in case the buffer allocated according to the size returned in previous 
+                //    Use a loop to call RmGetList() in case the buffer allocated according to the size returned in previous
                 //    call is not enough.
-                // 
+                //
                 uint pnProcInfo = 0;
                 RM_PROCESS_INFO[] rgAffectedApps = null;
                 int retry = 0;
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index b2c28967c6b..9e78a48daf4 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Tasks
 {
     /// <remarks>
     /// This class implements the "MSBuild" task, which hands off child project files to the MSBuild engine to be built.
-    /// Marked RunInMTA because there is no reason MSBuild tasks should run on a thread other than that of the 
+    /// Marked RunInMTA because there is no reason MSBuild tasks should run on a thread other than that of the
     /// RequestBuilder which spawned them.
     /// </remarks>
     [RunInMTA]
@@ -56,8 +56,8 @@ private enum SkipNonExistentProjectsBehavior
         private SkipNonExistentProjectsBehavior _skipNonExistentProjects = SkipNonExistentProjectsBehavior.Undefined;
 
         /// <summary>
-        /// A list of property name/value pairs to apply as global properties to 
-        /// the child project.  
+        /// A list of property name/value pairs to apply as global properties to
+        /// the child project.
         /// A typical input: "propname1=propvalue1", "propname2=propvalue2", "propname3=propvalue3".
         /// </summary>
         /// <remarks>
@@ -66,7 +66,7 @@ private enum SkipNonExistentProjectsBehavior
         ///     The fact that this is a `string[]` makes the following illegal:
         ///         `<MSBuild Properties="TargetPath=@(OutputPathItem)" />`
         ///     The engine fails on this because it doesn't like item lists being concatenated with string
-        ///     constants when the data is being passed into an array parameter.  So the workaround is to 
+        ///     constants when the data is being passed into an array parameter.  So the workaround is to
         ///     write this in the project file:
         ///         `<MSBuild Properties="@(OutputPathItem-&gt;'TargetPath=%(Identity)')" />`
         ///     ]]>
@@ -124,7 +124,7 @@ private enum SkipNonExistentProjectsBehavior
         public string ToolsVersion { get; set; }
 
         /// <summary>
-        /// When this is true we call the engine with all the projects at once instead of 
+        /// When this is true we call the engine with all the projects at once instead of
         /// calling the engine once per project
         /// </summary>
         public bool BuildInParallel { get; set; }
@@ -182,7 +182,7 @@ public string SkipNonexistentProjects
 
         /// <summary>
         /// Unescape Targets, Properties (including Properties and AdditionalProperties as Project item metadata)
-        /// will be un-escaped before processing. e.g. %3B (an escaped ';') in the string for any of them will 
+        /// will be un-escaped before processing. e.g. %3B (an escaped ';') in the string for any of them will
         /// be treated as if it were an un-escaped ';'
         /// </summary>
         public string[] TargetAndPropertyListSeparators { get; set; }
@@ -229,7 +229,7 @@ public override bool Execute()
             }
 
             bool isRunningMultipleNodes = BuildEngine2.IsRunningMultipleNodes;
-            // If we are in single proc mode and stopOnFirstFailure is true, we cannot build in parallel because 
+            // If we are in single proc mode and stopOnFirstFailure is true, we cannot build in parallel because
             // building in parallel sends all of the projects to the engine at once preventing us from not sending
             // any more projects after the first failure. Therefore, to preserve compatibility with whidbey if we are in this situation disable buildInParallel.
             if (!isRunningMultipleNodes && StopOnFirstFailure && BuildInParallel)
@@ -249,8 +249,8 @@ public override bool Execute()
             }
 
             // This is a list of string[].  That is, each element in the list is a string[].  Each
-            // string[] represents a set of target names to build.  Depending on the value 
-            // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
+            // string[] represents a set of target names to build.  Depending on the value
+            // of the RunEachTargetSeparately parameter, we each just call the engine to run all
             // the targets together, or we call the engine separately for each target.
             List<string[]> targetLists = CreateTargetLists(Targets, RunEachTargetSeparately);
 
@@ -286,7 +286,7 @@ public override bool Execute()
                     // Inform the user that we skipped the remaining projects because StopOnFirstFailure=true.
                     Log.LogMessageFromResources(MessageImportance.Low, "MSBuild.SkippingRemainingProjects");
 
-                    // We have encountered a failure.  Caller has requested that we not 
+                    // We have encountered a failure.  Caller has requested that we not
                     // continue with remaining projects.
                     break;
                 }
@@ -451,8 +451,8 @@ private void ExpandAllTargetsAndProperties()
         internal static List<string[]> CreateTargetLists(string[] targets, bool runEachTargetSeparately)
         {
             // This is a list of string[].  That is, each element in the list is a string[].  Each
-            // string[] represents a set of target names to build.  Depending on the value 
-            // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
+            // string[] represents a set of target names to build.  Depending on the value
+            // of the RunEachTargetSeparately parameter, we each just call the engine to run all
             // the targets together, or we call the engine separately for each target.
             var targetLists = new List<string[]>(runEachTargetSeparately ? targets.Length : 1);
             if (runEachTargetSeparately && targets.Length > 0)
@@ -596,12 +596,12 @@ internal static bool ExecuteTargets(
                     // Inform the user that we skipped the remaining targets StopOnFirstFailure=true.
                     log.LogMessageFromResources(MessageImportance.Low, "MSBuild.SkippingRemainingTargets");
 
-                    // We have encountered a failure.  Caller has requested that we not 
+                    // We have encountered a failure.  Caller has requested that we not
                     // continue with remaining targets.
                     break;
                 }
 
-                // Send the project off to the build engine.  By passing in null to the 
+                // Send the project off to the build engine.  By passing in null to the
                 // first param, we are indicating that the project to build is the same
                 // as the *calling* project file.
 
@@ -625,7 +625,7 @@ internal static bool ExecuteTargets(
                             {
                                 foreach (ITaskItem outputItemFromTarget in outputItemsFromTarget)
                                 {
-                                    // No need to rebase if the calling project is the same as the callee project 
+                                    // No need to rebase if the calling project is the same as the callee project
                                     // (project == null).  Also no point in trying to copy item metadata either,
                                     // because no items were passed into the Projects parameter!
                                     if (projects[i] != null)
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 8f16267ee8d..081762e8b84 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -267,7 +267,7 @@ public string OSSupportUrl
         /// Gets or sets the minimum OS version required by the application.
         /// </summary>
         /// <remarks>
-        /// An example value is "5.1.2600.0" for Windows XP.        
+        /// An example value is "5.1.2600.0" for Windows XP.
         /// If you don't specify a value, a default value is used.
         /// The default value is the minimum supported OS of the .NET Framework, which is "4.10.0.0" for Windows 98 Second Edition.
         /// However, if the application contains any native or Reg-Free COM references, then the default is the Windows XP version, which is "5.1.2600.0".
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index bd2716e8f49..64af947c9d1 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -276,7 +276,7 @@ public static AssemblyIdentity FromManagedAssembly(string path)
                     }
                     catch (ArgumentException e) when (e.HResult == unchecked((int)0x80070057))
                     {
-                        // 0x80070057 - "Value does not fall within the expected range." is returned from 
+                        // 0x80070057 - "Value does not fall within the expected range." is returned from
                         // GetAssemblyIdentityFromFile for WinMD components
                     }
                 }
diff --git a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
index 45fcf658329..500731b2ac1 100644
--- a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
@@ -108,12 +108,12 @@ public AssemblyReference Find(AssemblyIdentity identity)
             {
                 AssemblyIdentity listItemIdentity = a.AssemblyIdentity;
 
-                // if the item in our list doesn't have an identity but is a managed assembly, 
+                // if the item in our list doesn't have an identity but is a managed assembly,
                 //  we calculate it by reading the file from disk to find its identity.
                 //
                 // note that this is here specifically to deal with the scenario when we are being
-                //  asked to find a reference to one of our sentinel assemblies which are known to 
-                //  be managed assemblies. doing this ensures that our sentinel assemblies do not 
+                //  asked to find a reference to one of our sentinel assemblies which are known to
+                //  be managed assemblies. doing this ensures that our sentinel assemblies do not
                 //  show up twice in the manifest.
                 //
                 // we are assuming the incoming identity for the sentinel assembly really is the
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index 2dc0e2cb4b1..3ccb3de31b9 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -8,9 +8,9 @@
 //     * The assembly must be built with <GenerateAssemblyRefs>true</GenerateAssemblyRefs>
 //     * The ECDSA methods are not available
 
-// There are cases where we have multiple assemblies that are going to import this file and 
+// There are cases where we have multiple assemblies that are going to import this file and
 // if they are going to also have InternalsVisibleTo between them, there will be a compiler warning
-// that the type is found both in the source and in a referenced assembly. The compiler will prefer 
+// that the type is found both in the source and in a referenced assembly. The compiler will prefer
 // the version of the type defined in the source
 //
 // In order to disable the warning for this type we are disabling this warning for this entire file.
@@ -523,7 +523,7 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
         {
             Debug.Assert(typeof(T).Name == algorithmName);
 
-            // Load System.Core.dll and load the appropriate extension class 
+            // Load System.Core.dll and load the appropriate extension class
             // (one of
             //    System.Security.Cryptography.X509Certificates.RSACertificateExtensions
             //    System.Security.Cryptography.X509Certificates.DSACertificateExtensions
@@ -543,7 +543,7 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
             }
 
             // Now, find the api we want to call:
-            //   
+            //
             // (one of
             //     GetRSAPublicKey(this X509Certificate2 c)
             //     GetRSAPrivateKey(this X509Certificate2 c)
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index be7ce4a1d6c..50eb4971144 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -129,7 +129,7 @@ private void DiscoverCompatibleFrameworks(FrameworkNameVersioning frameworkName)
         }
 
         /// <summary>
-        /// codes from GetInstallableFrameworkForTargetFxInternal in 
+        /// codes from GetInstallableFrameworkForTargetFxInternal in
         /// env/vscore/package/FxMultiTargeting/FrameworkMultiTargetingInternal.cs
         /// </summary>
         private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkNameVersioning frameworkName)
@@ -153,7 +153,7 @@ private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkName
                 }
             }
 
-            // If the installable framework value is not in the redist, there was no redist, or no matching FX we return the sent TFM,  
+            // If the installable framework value is not in the redist, there was no redist, or no matching FX we return the sent TFM,
             // this means frameworks that are installable themselves don't need to specify this property
             // and that all unknown frameworks are assumed to be installable.
             if (installableFramework == null)
@@ -276,7 +276,7 @@ private static string PatchCLRVersion(string version)
             }
             catch (OverflowException)
             {
-                // continue 
+                // continue
             }
 
             return version;
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index 28d4f6131df..938c839fd47 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -385,7 +385,7 @@ internal static void UpdateEntryPoint(string inputPath, string outputPath, strin
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
             AssemblyIdentity appManifest = AssemblyIdentity.FromManifest(applicationManifestPath);
 
-            // update path to application manifest            
+            // update path to application manifest
             XmlNode codeBaseNode = null;
             foreach (string xpath in XPaths.codebasePaths)
             {
@@ -695,7 +695,7 @@ private bool IsMismatchedPlatform(AssemblyReference assembly)
                     }
                 }
 
-                // Either we are looking at the entry point assembly or the assembly is not platform neutral. 
+                // Either we are looking at the entry point assembly or the assembly is not platform neutral.
                 // We need to compare the application's platform to the component's platform,
                 // if they don't match then flag component as a mismatch...
                 return !String.Equals(AssemblyIdentity.ProcessorArchitecture, assembly.AssemblyIdentity.ProcessorArchitecture, StringComparison.OrdinalIgnoreCase);
diff --git a/src/Tasks/ManifestUtil/ManifestWriter.cs b/src/Tasks/ManifestUtil/ManifestWriter.cs
index 23c43ee0e02..562cc1f1c0f 100644
--- a/src/Tasks/ManifestUtil/ManifestWriter.cs
+++ b/src/Tasks/ManifestUtil/ManifestWriter.cs
@@ -84,7 +84,7 @@ public static void WriteManifest(Manifest manifest, Stream output)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="manifest"></param>
         /// <param name="output"></param>
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 3ff93e72a18..9951399b793 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -617,7 +617,7 @@ public static void SignFile(string certPath, SecureString certPassword, Uri time
         private static bool UseSha256Algorithm(X509Certificate2 cert)
         {
             Oid oid = cert.SignatureAlgorithm;
-            // Issue 6732: Clickonce does not support sha384/sha512 file hash so we default to sha256 
+            // Issue 6732: Clickonce does not support sha384/sha512 file hash so we default to sha256
             // for certs with that signature algorithm.
             return string.Equals(oid.FriendlyName, "sha256RSA", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(oid.FriendlyName, "sha384RSA", StringComparison.OrdinalIgnoreCase) ||
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index d3e38a5fd5d..ecc02c975a7 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -203,7 +203,7 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
             // <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
             //      <!--
             //          UAC Manifest Options
-            //          If you want to change the Windows User Account Control level replace the 
+            //          If you want to change the Windows User Account Control level replace the
             //          requestedExecutionLevel node with one of the following .
             //          <requestedExecutionLevel  level="asInvoker" />
             //          <requestedExecutionLevel  level="requireAdministrator" />
@@ -234,8 +234,8 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
             //
             if (inputRequestedPrivilegeElement == null)
             {
-                // If UAC requestedPrivilege node is missing (possibly due to upgraded project) then automatically 
-                //  add a default UAC requestedPrivilege node with a default requestedExecutionLevel node set to 
+                // If UAC requestedPrivilege node is missing (possibly due to upgraded project) then automatically
+                //  add a default UAC requestedPrivilege node with a default requestedExecutionLevel node set to
                 //  the expected ClickOnce level (asInvoker) with uiAccess as false
                 //
                 executionLevelString = Constants.UACAsInvoker;
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 5e96abc3314..4d6b6ca09ea 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -599,7 +599,7 @@ public static string WriteTempFile(string s)
             return path;
         }
 
-        #region ItemComparer 
+        #region ItemComparer
         private static readonly ItemComparer s_itemComparer = new ItemComparer();
         private class ItemComparer : IComparer
         {
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 3b19aee2b1e..df887fcbd6c 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -758,7 +758,7 @@ private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManife
             // Add an enveloped and an Exc-C14N transform.
             reference.AddTransform(new XmlDsigEnvelopedSignatureTransform());
 #if (false) // BUGBUG: LTA transform complaining about issuer node not found.
-            reference.AddTransform(new XmlLicenseTransform()); 
+            reference.AddTransform(new XmlLicenseTransform());
 #endif
             reference.AddTransform(new XmlDsigExcC14NTransform());
 
diff --git a/src/Tasks/Message.cs b/src/Tasks/Message.cs
index 2b16f5bcd27..befd8c9883d 100644
--- a/src/Tasks/Message.cs
+++ b/src/Tasks/Message.cs
@@ -57,7 +57,7 @@ public override bool Execute()
             {
                 try
                 {
-                    // Parse the raw importance string into a strongly typed enumeration.  
+                    // Parse the raw importance string into a strongly typed enumeration.
                     messageImportance = (MessageImportance)Enum.Parse(typeof(MessageImportance), Importance, true /* case-insensitive */);
                 }
                 catch (ArgumentException)
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index bcf0e99af18..316a44681b9 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -488,8 +488,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <PublishDir Condition="'$(PublishDir)'==''">$(OutputPath)app.publish\</PublishDir>
   </PropertyGroup>
 
-  <!-- 
-    ClickOncePublishDir property is the output location used by all ClickOnce publish targets. This should be same as PublishDir except 
+  <!--
+    ClickOncePublishDir property is the output location used by all ClickOnce publish targets. This should be same as PublishDir except
     for a trailing slash. PublishDir when specified as a global property on the command line cannot be changed to add a trailing slash.
   -->
   <PropertyGroup>
@@ -1511,7 +1511,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <Target Name="AfterResolveReferences"/>
-  
+
   <!--
     ============================================================
                                         IgnoreJavaScriptOutputAssembly
@@ -1823,7 +1823,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         SkipNonexistentTargets="true">
       <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
     </MSBuild>
-    
+
     <!--
        SetPlatform negotiation requires the 'GetTargetFrameworks' MSBuild call to NOT pass global properties. This is to verify
        whether or not the referenced project would build as the same platform as the current project by default. The above
@@ -1897,7 +1897,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <SetRidAgnosticValueForProjects Projects="@(AnnotatedProjects)">
       <Output ItemName="UpdatedAnnotatedProjects" TaskParameter="UpdatedProjects" />
     </SetRidAgnosticValueForProjects>
-    
+
     <ItemGroup>
       <AnnotatedProjects Remove="@(AnnotatedProjects)" />
       <AnnotatedProjects Include="@(UpdatedAnnotatedProjects)" />
@@ -1998,7 +1998,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
              SelfContained and RuntimeIdentifier should not flow across project references.  The IsRidAgnostic metadata value is consumed in the
              _GetProjectReferenceTargetFrameworkProperties target, where those properties are added to a project's UndefineProperties if
              IsRidAgnostic is set.
-        
+
              Generally we set the IsRidAgnostic metadata based on the IsRidAgnostic property set by the .NET SDK.  If that's not set, then the
              fallback logic here will be that the project is RID agnostic if it doesn't have RuntimeIdentifier or RuntimeIdentifiers properties set. -->
         <IsRidAgnostic>$(IsRidAgnostic)</IsRidAgnostic>
@@ -2525,7 +2525,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_NewGenerateBindingRedirectsIntermediateAppConfig Condition="Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')">true</_NewGenerateBindingRedirectsIntermediateAppConfig>
       <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
-    
+
     <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
@@ -4444,8 +4444,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_ClickOnceTransitiveContentItems Include="@(_ClickOnceTransitiveContentItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
 
       <!--
-        For .NET>=5, we need to check if we need to publish any copylocal items from None group. For such items to be published, they either 
-        have .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection. 
+        For .NET>=5, we need to check if we need to publish any copylocal items from None group. For such items to be published, they either
+        have .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
         The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
       -->
       <!-- Include items from None group for publishing -->
diff --git a/src/Tasks/Move.cs b/src/Tasks/Move.cs
index 746ce275be7..e0a628370f8 100644
--- a/src/Tasks/Move.cs
+++ b/src/Tasks/Move.cs
@@ -26,7 +26,7 @@ public class Move : TaskExtension, ICancelableTask, IIncrementalTask
     {
         /// <summary>
         /// Flags for MoveFileEx.
-        /// 
+        ///
         /// </summary>
         private const NativeMethods.MoveFileFlags Flags = NativeMethods.MoveFileFlags.MOVEFILE_WRITE_THROUGH |    // Do not return until the Move is complete
                                                           NativeMethods.MoveFileFlags.MOVEFILE_REPLACE_EXISTING | // Replace any existing target
@@ -250,7 +250,7 @@ private bool MoveFileWithLogging(
 
             if (!result)
             {
-                // It failed so we need a nice error message. Unfortunately 
+                // It failed so we need a nice error message. Unfortunately
                 // Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error()); and
                 // throw new IOException((new Win32Exception(error)).Message)
                 // do not produce great error messages (eg., "The operation succeeded" (!)).
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 86faefd4fb7..59e9f6c1ba5 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -108,7 +108,7 @@ internal interface IMetaDataDispenser
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
     internal interface IMetaDataImport
     {
-        // PreserveSig because this method is an exception that 
+        // PreserveSig because this method is an exception that
         // actually returns void, not HRESULT.
         [PreserveSig]
         void CloseEnum();
@@ -279,7 +279,7 @@ internal interface IMetaDataAssemblyImport
         void GetAssemblyFromScope(out UInt32 mdAsm);
         void FindExportedTypeByName();
         void FindManifestResourceByName();
-        // PreserveSig because this method is an exception that 
+        // PreserveSig because this method is an exception that
         // actually returns void, not HRESULT.
         [PreserveSig]
         void CloseEnum([In] IntPtr phEnum);
@@ -1028,7 +1028,7 @@ internal static extern int CreateAssemblyNameObject(
         /// <param name="cacheFlags">Value that indicates the source of the cached assembly.</param>
         /// <param name="cachePath">The returned pointer to the path.</param>
         /// <param name="pcchPath">The requested maximum length of CachePath, and upon return, the actual length of CachePath.</param>
-        /// 
+        ///
         [DllImport("fusion.dll", CharSet = CharSet.Unicode)]
         [SupportedOSPlatform("windows")]
         internal static extern unsafe int GetCachePath(AssemblyCacheFlags cacheFlags, [Out] char* cachePath, ref int pcchPath);
@@ -1141,13 +1141,13 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                     IntPtr attrDataPostProlog = attrData + preReadOffset;
 
                     int strLen;
-                    // Get the offset at which the uncompressed data starts, and the 
+                    // Get the offset at which the uncompressed data starts, and the
                     // length of the uncompressed data.
                     attrDataOffset = CorSigUncompressData(attrDataPostProlog, out strLen);
 
                     if (strLen != -1)
                     {
-                        // the full size of the blob we were passed in should be sufficient to 
+                        // the full size of the blob we were passed in should be sufficient to
                         // cover the prolog, compressed string length, and actual string.
                         if (attrDataSize >= preReadOffset + attrDataOffset + strLen)
                         {
@@ -1159,7 +1159,7 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                                 bytes[i] = Marshal.ReadByte(attrDataPostProlog, attrDataOffset + i);
                             }
 
-                            // And convert it to the output string. 
+                            // And convert it to the output string.
                             strValue = new String(Encoding.UTF8.GetChars(bytes));
                         }
                         else
@@ -1175,11 +1175,11 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
             }
             catch (AccessViolationException)
             {
-                // The Marshal.ReadXXXX functions throw AVs when they're fed an invalid pointer, and very occasionally, 
-                // for some reason, on what seem to be otherwise perfectly valid assemblies (it must be 
+                // The Marshal.ReadXXXX functions throw AVs when they're fed an invalid pointer, and very occasionally,
+                // for some reason, on what seem to be otherwise perfectly valid assemblies (it must be
                 // intermittent given that otherwise the user would be completely unable to use the reference
-                // manager), the pointer that we generate to look up the AssemblyTitle is apparently invalid, 
-                // or for some reason Marshal.ReadByte thinks it is.  
+                // manager), the pointer that we generate to look up the AssemblyTitle is apparently invalid,
+                // or for some reason Marshal.ReadByte thinks it is.
                 //
                 return false;
             }
@@ -1209,19 +1209,19 @@ internal static unsafe int CorSigUncompressData(IntPtr data, out int uncompresse
             byte* bytes = (byte*)(data);
             uncompressedDataLength = 0;
 
-            // Smallest.    
-            if ((*bytes & 0x80) == 0x00)       // 0??? ????    
+            // Smallest.
+            if ((*bytes & 0x80) == 0x00)       // 0??? ????
             {
                 uncompressedDataLength = *bytes;
                 count = 1;
             }
-            // Medium.  
-            else if ((*bytes & 0xC0) == 0x80)  // 10?? ????    
+            // Medium.
+            else if ((*bytes & 0xC0) == 0x80)  // 10?? ????
             {
                 uncompressedDataLength = (int)((*bytes & 0x3f) << 8 | *(bytes + 1));
                 count = 2;
             }
-            else if ((*bytes & 0xE0) == 0xC0)      // 110? ????    
+            else if ((*bytes & 0xE0) == 0xC0)      // 110? ????
             {
                 uncompressedDataLength = (int)((*bytes & 0x1f) << 24 | *(bytes + 1) << 16 | *(bytes + 2) << 8 | *(bytes + 3));
                 count = 4;
diff --git a/src/Tasks/PiaReference.cs b/src/Tasks/PiaReference.cs
index f98a07f512d..b16590ab98e 100644
--- a/src/Tasks/PiaReference.cs
+++ b/src/Tasks/PiaReference.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// COM reference wrapper class for the tlbimp tool using a PIA. 
+    /// COM reference wrapper class for the tlbimp tool using a PIA.
     /// </summary>
     internal sealed class PiaReference : ComReference
     {
@@ -62,7 +62,7 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
                         path = uri.LocalPath,
                         assembly = assembly,
 
-                        // We need to remember the original assembly name of this PIA in case it gets redirected to a newer 
+                        // We need to remember the original assembly name of this PIA in case it gets redirected to a newer
                         // version and other COM components use that name to reference the PIA. assembly.FullName wouldn't
                         // work here since we'd get the redirected assembly name.
                         originalPiaName = new AssemblyNameExtension(AssemblyName.GetAssemblyName(uri.LocalPath))
@@ -78,8 +78,8 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
                         path = assembly.Location,
                         assembly = assembly,
 
-                        // We need to remember the original assembly name of this PIA in case it gets redirected to a newer 
-                        // version and other COM components use that name to reference the PIA. 
+                        // We need to remember the original assembly name of this PIA in case it gets redirected to a newer
+                        // version and other COM components use that name to reference the PIA.
                         originalPiaName = new AssemblyNameExtension(asmName, true)
                     };
                 }
@@ -87,12 +87,12 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
             catch (FileNotFoundException)
             {
                 // This means that assembly file cannot be found.
-                // We don't need to do anything here; wrapperInfo is not set 
+                // We don't need to do anything here; wrapperInfo is not set
                 // and we'll assume that the assembly doesn't exist.
             }
             catch (BadImageFormatException)
             {
-                // Similar case as above, except we should additionally warn the user that the assembly file 
+                // Similar case as above, except we should additionally warn the user that the assembly file
                 // is not really a valid assembly file.
                 if (!Silent)
                 {
diff --git a/src/Tasks/RCWForCurrentContext.cs b/src/Tasks/RCWForCurrentContext.cs
index 83e90765226..bc7a4373e35 100644
--- a/src/Tasks/RCWForCurrentContext.cs
+++ b/src/Tasks/RCWForCurrentContext.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Tasks.InteropUtilities
 {
     /// <summary>
-    /// Create an RCW for the current context/apartment. 
+    /// Create an RCW for the current context/apartment.
     /// This improves performance of cross apartment calls as the CLR will only
     /// cache marshalled pointers for an RCW created in the current context.
     /// </summary>
@@ -33,8 +33,8 @@ internal class RCWForCurrentContext<T> : IDisposable where T : class
         /// <param name="rcw">The RCW created in the original context.</param>
         public RCWForCurrentContext(T rcw)
         {
-            // To improve performance we create a new RCW for the current context so we get 
-            // the caching behaviour of the marshaled pointer. 
+            // To improve performance we create a new RCW for the current context so we get
+            // the caching behaviour of the marshaled pointer.
             // See RCW::GetComIPForMethodTableFromCache in ndp\clr\src\VM\RuntimeCallableWrapper.cpp
             IntPtr iunknownPtr = Marshal.GetIUnknownForObject(rcw);
             Object objInCurrentCtx;
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index dd5c9123649..c46d663bbb7 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -271,7 +271,7 @@ private static RedistList GetFrameworkListFromReferenceAssembliesPath(TargetDotN
             string referenceAssembliesPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(version);
 
             // On dogfood build machines, v3.5 is not formally installed, so this returns null.
-            // We don't use redist lists in this case.            
+            // We don't use redist lists in this case.
             string[] redistListPaths = (referenceAssembliesPath == null) ? Array.Empty<string>() : GetRedistListPathsFromDisk(referenceAssembliesPath);
 
             var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
@@ -558,7 +558,7 @@ internal Dictionary<string, string> GenerateDenyList(AssemblyTableInfo[] allowLi
                     // we do not get a "redist name is null or empty" error when in actual fact it was a file not found error.
                     int errorsBeforeReadCall = allowListErrors.Count;
 
-                    // Read in the subset list file. 
+                    // Read in the subset list file.
                     string redistName = ReadFile(info, allowListAssembliesReadIn, allowListErrors, allowListErrorFileNames, null);
 
                     // Get the client subset name which has been read in.
@@ -846,7 +846,7 @@ private static AssemblyEntry ReadFileListEntry(AssemblyTableInfo assemblyTableIn
             attributes.TryGetValue("IsRedistRoot", out string isRedistRoot);
             if (!bool.TryParse(inGAC, out bool inGACFlag))
             {
-                inGACFlag = true;                           // true by default 
+                inGACFlag = true;                           // true by default
             }
 
             // The retargetable flag is Yes or No for some reason
@@ -912,9 +912,9 @@ public int Compare(AssemblyEntry firstEntry, AssemblyEntry secondEntry)
 
                 // We now want to sort based on the version number
                 // The compare method is expected to return the following values:
-                // Less than zero = right instance is less than left. 
-                // Zero  = right instance is equal to left. 
-                // Greater than zero  = right instance is greater than left. 
+                // Less than zero = right instance is less than left.
+                // Zero  = right instance is equal to left.
+                // Greater than zero  = right instance is greater than left.
 
                 // Want the greater version number to be on top in a list so we need to reverse the comparison
                 int returnValue = firstAssemblyName.Version.CompareTo(secondAssemblyName.Version);
@@ -1023,14 +1023,14 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
             {
                 lock (s_subsetListPathCacheLock)
                 {
-                    // We want to cache the paths to the subset files so that we do not have to hit the disk and check for the files 
+                    // We want to cache the paths to the subset files so that we do not have to hit the disk and check for the files
                     // each time RAR is called within the appdomain.
                     if (s_subsetListPathCache == null)
                     {
                         s_subsetListPathCache = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
                     }
 
-                    // TargetFrameworkDirectory is not unique enough because a different invocation could ask for a different 
+                    // TargetFrameworkDirectory is not unique enough because a different invocation could ask for a different
                     // set of subset files from the same TargetFrameworkDirectory
                     string concatenatedSubsetListNames = String.Join(";", _subsetToSearchFor);
 
@@ -1044,7 +1044,7 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
 
                         var subsetFilesForFrameworkDirectory = new List<string>();
 
-                        // Go through each of the subsets and see if it is in the target framework subset directory 
+                        // Go through each of the subsets and see if it is in the target framework subset directory
                         foreach (string subsetName in _subsetToSearchFor)
                         {
                             string subsetFilePath = Path.Combine(subsetDirectory, subsetName + ".xml");
@@ -1054,7 +1054,7 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
                             }
                         }
 
-                        // Note, even if the array is empty we still want to add it to the cache, because some 
+                        // Note, even if the array is empty we still want to add it to the cache, because some
                         // target framework directories may never contain a subset file (for example 2.05727 and 3.0)
                         // for this reason we should not check them everytime if the files are not found.
                         s_subsetListPathCache[key] = subsetFilesForFrameworkDirectory.ToArray();
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index 542e2a8f08b..46999b37715 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -222,7 +222,7 @@ private bool Register(string assemblyPath, string typeLibPath)
 
             try
             {
-                // Load the specified assembly. 
+                // Load the specified assembly.
                 Assembly asm = Assembly.UnsafeLoadFrom(assemblyPath);
 
                 var comRegistrar = new RegistrationServices();
@@ -230,8 +230,8 @@ private bool Register(string assemblyPath, string typeLibPath)
                 // Register the assembly
                 if (!comRegistrar.RegisterAssembly(asm, CreateCodeBase ? AssemblyRegistrationFlags.SetCodeBase : AssemblyRegistrationFlags.None))
                 {
-                    // If the assembly doesn't contain any types that could be registered for COM interop, 
-                    // warn the user about it.  
+                    // If the assembly doesn't contain any types that could be registered for COM interop,
+                    // warn the user about it.
                     Log.LogWarningWithCodeFromResources("RegisterAssembly.NoValidTypes", assemblyPath);
                 }
 
diff --git a/src/Tasks/RequiresFramework35SP1Assembly.cs b/src/Tasks/RequiresFramework35SP1Assembly.cs
index 068315c907c..4714f818e73 100644
--- a/src/Tasks/RequiresFramework35SP1Assembly.cs
+++ b/src/Tasks/RequiresFramework35SP1Assembly.cs
@@ -145,7 +145,7 @@ private static bool HasExcludedFileOrSP1File(ITaskItem[] candidateFiles)
         /// <summary>
         /// Is this file's IncludeHash set to false?
         /// Is this file System.Data.Entity.dll?
-        /// Is this file Client Sentinel Assembly? 
+        /// Is this file Client Sentinel Assembly?
         /// </summary>
         private static bool IsExcludedFileOrSP1File(ITaskItem candidateFile)
         {
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 731c376b5e2..5bce63d6e60 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -27,7 +27,7 @@ namespace Microsoft.Build.Tasks
     public sealed partial class GenerateResource : TaskExtension
     {
         /// <summary>
-        /// Defines the "ResGen" MSBuild task, which enables using ResGen.exe 
+        /// Defines the "ResGen" MSBuild task, which enables using ResGen.exe
         /// to generate strongly-typed resource classes and convert resource
         /// files from one format to another.
         /// </summary>
@@ -67,34 +67,34 @@ embedding it into an assembly.
                         version of a type will use the one in this assembly, when set.
         /define:A[,B]   For #ifdef support in .ResText files, pass a comma-separated
                         list of symbols.  ResText files can use "#ifdef A" or "#if !B".
-        
+
         Miscellaneous:
         @<file>         Read response file for more options. At most one response file
                         may be specified, and its entries must be line-separated.
-        
+
         .restext & .txt files have this format:
-        
+
             # Use # at the beginning of a line for a comment character.
             name=value
             more elaborate name=value
-        
+
         Example response file contents:
-        
+
             # Use # at the beginning of a line for a comment character.
             /useSourcePath
             /compile
             file1.resx,file1.resources
             file2.resx,file2.resources
-        
+
 
         Language names valid for the /str:<language> option are:
         c#, cs, csharp, vb, vbs, visualbasic, vbscript, js, jscript, javascript, vj#, vjs, vjsharp, c++, mc, cpp
          */
 
             /// <summary>
-            /// Files being passed to ResGen.exe to be converted to a different resource format.  
-            /// If a strongly typed resource class is being created, only one file may be 
-            /// passed to InputFiles at a time. 
+            /// Files being passed to ResGen.exe to be converted to a different resource format.
+            /// If a strongly typed resource class is being created, only one file may be
+            /// passed to InputFiles at a time.
             /// </summary>
             public ITaskItem[] InputFiles
             {
@@ -104,7 +104,7 @@ public ITaskItem[] InputFiles
 
             /// <summary>
             /// Should be the same length as InputFiles or null.  If null, the files output
-            /// by ResGen.exe will be named "inputFiles[i].resources".  Otherwise, the 
+            /// by ResGen.exe will be named "inputFiles[i].resources".  Otherwise, the
             /// extensions on the output filesnames indicate which format the corresponding
             /// input file will be translated to.
             /// </summary>
@@ -202,11 +202,11 @@ public bool UseSourcePath
             protected override string ToolName => "resgen.exe";
 
             /// <summary>
-            /// Tracker.exe wants Unicode response files, and ResGen.exe doesn't care, 
-            /// so make them Unicode across the board. 
+            /// Tracker.exe wants Unicode response files, and ResGen.exe doesn't care,
+            /// so make them Unicode across the board.
             /// </summary>
             /// <comment>
-            /// We no longer use Tracker.exe in ResGen, but given that as ResGen doesn't care, 
+            /// We no longer use Tracker.exe in ResGen, but given that as ResGen doesn't care,
             /// there doesn't really seem to be a particular reason to change it back, either...
             /// </comment>
             protected override Encoding ResponseFileEncoding => Encoding.Unicode;
@@ -270,7 +270,7 @@ public override bool Execute()
                 {
                     ITaskItem outputFile = OutputFiles[0];
 
-                    // if the resource generation was unsuccessful, check to see that the resource file 
+                    // if the resource generation was unsuccessful, check to see that the resource file
                     // was in fact generated
                     if (!success)
                     {
@@ -296,14 +296,14 @@ public override bool Execute()
                         }
                         catch (System.Configuration.ConfigurationException)
                         {
-                            // If the language can't be found, then ResGen.exe will already have 
-                            // logged an appropriate error.  
+                            // If the language can't be found, then ResGen.exe will already have
+                            // logged an appropriate error.
                             return false;
                         }
                         catch (System.Security.SecurityException)
                         {
-                            // If the language can't be found, then ResGen.exe will already have 
-                            // logged an appropriate error.  
+                            // If the language can't be found, then ResGen.exe will already have
+                            // logged an appropriate error.
                             return false;
                         }
 
@@ -316,7 +316,7 @@ public override bool Execute()
 
             /// <summary>
             /// Fills the provided CommandLineBuilderExtension with all the command line options used when
-            /// executing this tool that can go into a response file.  
+            /// executing this tool that can go into a response file.
             /// </summary>
             /// <comments>
             /// ResGen 3.5 and earlier doesn't support response files, but ResGen 4.0 and later does.
@@ -344,8 +344,8 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
                 }
                 else
                 {
-                    // return nothing -- if it's not 4.0, or if we're building strongly typed resources, we assume that, 
-                    // as far as ToolTask is concerned at least, response files are not supported. 
+                    // return nothing -- if it's not 4.0, or if we're building strongly typed resources, we assume that,
+                    // as far as ToolTask is concerned at least, response files are not supported.
                 }
             }
 
@@ -355,7 +355,7 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
             /// </summary>
             /// <comments>
             /// Has to be command line commands because ResGen 3.5 and earlier don't know about
-            /// response files. 
+            /// response files.
             /// </comments>
             /// <param name="commandLine">Gets filled with command line options</param>
             protected internal override void AddCommandLineCommands(CommandLineBuilderExtension commandLine)
@@ -372,12 +372,12 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
                     !pathToResGen.Equals(NativeMethodsShared.GetLongFilePath(ToolLocationHelper.GetPathToDotNetFrameworkSdkFile("resgen.exe", TargetDotNetFrameworkVersion.Version35)), StringComparison.OrdinalIgnoreCase) &&
                     String.IsNullOrEmpty(StronglyTypedLanguage))
                 {
-                    // 4.0 resgen.exe does support response files (at least as long as you're not building an STR), so we can 
+                    // 4.0 resgen.exe does support response files (at least as long as you're not building an STR), so we can
                     // make use of them here by returning nothing!
                 }
                 else
                 {
-                    // otherwise, the toolname is ResGen.exe and we just need the resgen arguments in CommandLineCommands. 
+                    // otherwise, the toolname is ResGen.exe and we just need the resgen arguments in CommandLineCommands.
                     commandLine.AppendTextUnquoted(resGenArguments.ToString());
                 }
             }
@@ -412,7 +412,7 @@ protected override bool ValidateParameters()
                 if (!String.IsNullOrEmpty(StronglyTypedLanguage))
                 {
                     // Only a single Sources is allowed if you are generating STR.
-                    // Otherwise, each STR class overwrites the previous one. In theory we could generate separate 
+                    // Otherwise, each STR class overwrites the previous one. In theory we could generate separate
                     // STR classes for each input, but then the class name and file name parameters would have to be vectors.
                     if (InputFiles.Length != 1)
                     {
@@ -427,14 +427,14 @@ protected override bool ValidateParameters()
                         !String.IsNullOrEmpty(StronglyTypedNamespace) ||
                         !String.IsNullOrEmpty(StronglyTypedFileName))
                     {
-                        // We have no language to generate a STR, but nevertheless the user passed us a class, 
+                        // We have no language to generate a STR, but nevertheless the user passed us a class,
                         // namespace, and/or filename. Let them know that they probably wanted to pass a language too.
                         Log.LogErrorWithCodeFromResources("ResGen.STRClassNamespaceOrFilenameWithoutLanguage");
                         return false;
                     }
                 }
 
-                // Verify that the ToolPath exists -- if the tool doesn't exist in it 
+                // Verify that the ToolPath exists -- if the tool doesn't exist in it
                 // we'll worry about that later
                 if ((String.IsNullOrEmpty(ToolPath) || !FileSystems.Default.DirectoryExists(ToolPath)) &&
                     (String.IsNullOrEmpty(SdkToolsPath) || !FileSystems.Default.DirectoryExists(SdkToolsPath)))
@@ -451,7 +451,7 @@ protected override bool ValidateParameters()
             #region Helper methods
 
             /// <summary>
-            /// Checks a string array for null or length zero.  Does not check if 
+            /// Checks a string array for null or length zero.  Does not check if
             /// individual members are null
             /// </summary>
             /// <param name="value">The string array to check</param>
@@ -490,7 +490,7 @@ private void GenerateOutputFileNames()
             }
 
             /// <summary>
-            /// Generates the full path to ResGen.exe.  
+            /// Generates the full path to ResGen.exe.
             /// </summary>
             /// <returns>The path to ResGen.exe, or null.</returns>
             private string GenerateResGenFullPath()
@@ -510,7 +510,7 @@ private string GenerateResGenFullPath()
                         }
                     }
 
-                    // If it still hasn't been found, try to generate the appropriate path. 
+                    // If it still hasn't been found, try to generate the appropriate path.
                     if (pathToTool == null)
                     {
                         pathToTool = SdkToolsPathUtility.GeneratePathToTool(
@@ -524,8 +524,8 @@ private string GenerateResGenFullPath()
                         pathToTool = NativeMethodsShared.GetLongFilePath(pathToTool);
                     }
 
-                    // And then set it for future reference.  If it's still null, there's nothing else 
-                    // we can do, and we've already logged an appropriate error. 
+                    // And then set it for future reference.  If it's still null, there's nothing else
+                    // we can do, and we've already logged an appropriate error.
                     Bag["ToolPathWithFile"] = pathToTool;
                 }
 
@@ -533,7 +533,7 @@ private string GenerateResGenFullPath()
             }
 
             /// <summary>
-            /// Generate the command line to be passed to resgen.exe, sans the path to the tool. 
+            /// Generate the command line to be passed to resgen.exe, sans the path to the tool.
             /// </summary>
             private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments, bool useForResponseFile)
             {
@@ -555,8 +555,8 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                 {
                     foreach (ITaskItem reference in References)
                     {
-                        // ResGen.exe response files frown on quotes in filenames, even if there are 
-                        // spaces in the names of the files.  
+                        // ResGen.exe response files frown on quotes in filenames, even if there are
+                        // spaces in the names of the files.
                         if (useForResponseFile && reference != null)
                         {
                             resGenArguments.AppendTextUnquoted("/r:");
@@ -585,8 +585,8 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                         {
                             if (useForResponseFile)
                             {
-                                // ResGen.exe response files frown on quotes in filenames, even if there are 
-                                // spaces in the names of the files.  
+                                // ResGen.exe response files frown on quotes in filenames, even if there are
+                                // spaces in the names of the files.
                                 if (inputFiles[i] != null && outputFiles[i] != null)
                                 {
                                     resGenArguments.AppendTextUnquoted(inputFiles[i].ItemSpec);
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 706899188d7..72713bb21ce 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -66,7 +66,7 @@ internal string BaseLinkedFileDirectory
                 {
                     // Ok, this is slightly complicated.  Changing the base directory in any manner may
                     // result in changes to how we find .resx files.  Therefore, we must clear our out
-                    // cache whenever the base directory changes.  
+                    // cache whenever the base directory changes.
                     resXFiles.Clear();
                     _isDirty = true;
                     baseLinkedFileDirectory = value;
@@ -78,7 +78,7 @@ internal bool UseSourcePath
         {
             set
             {
-                // Ensure that the cache is properly initialized with respect to how resgen will 
+                // Ensure that the cache is properly initialized with respect to how resgen will
                 // resolve linked files within .resx files.  ResGen has two different
                 // ways for resolving relative file-paths in linked files. The way
                 // that ResGen resolved relative paths before Whidbey was always to
@@ -126,7 +126,7 @@ internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader, Ta
             // First, try to retrieve the resx information from our hashtable.
             if (!resXFiles.TryGetValue(resxFile, out ResXFile retVal))
             {
-                // Ok, the file wasn't there.  Add it to our cache and return it to the caller.  
+                // Ok, the file wasn't there.  Add it to our cache and return it to the caller.
                 retVal = AddResxFile(resxFile, useMSBuildResXReader, log, logWarningForBinaryFormatter);
             }
             else
@@ -157,7 +157,7 @@ private ResXFile AddResxFile(string file, bool useMSBuildResXReader, TaskLogging
 
         internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
         {
-            // First, try to retrieve the portable library information from our hashtable.  
+            // First, try to retrieve the portable library information from our hashtable.
             portableLibraries.TryGetValue(libraryPath, out PortableLibraryFile retVal);
 
             // The file is in our cache.  Make sure it's up to date.  If not, discard
@@ -198,7 +198,7 @@ internal static ResGenDependencies DeserializeCache(string stateFile, bool useSo
         {
             var retVal = DeserializeCache<ResGenDependencies>(stateFile, log) ?? new ResGenDependencies();
 
-            // Ensure that the cache is properly initialized with respect to how resgen will 
+            // Ensure that the cache is properly initialized with respect to how resgen will
             // resolve linked files within .resx files.  ResGen has two different
             // ways for resolving relative file-paths in linked files. The way
             // that ResGen resolved relative paths before Whidbey was always to
@@ -314,9 +314,9 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
         }
 
         /// <remarks>
-        /// Represents a single assembly in the dependency cache, which may produce 
+        /// Represents a single assembly in the dependency cache, which may produce
         /// 0 to many ResW files.
-        /// 
+        ///
         /// Must be serializable because instances may be marshaled cross-AppDomain, see <see cref="ProcessResourceFiles.PortableLibraryCacheInfo"/>.
         /// </remarks>
 #if FEATURE_APPDOMAIN
diff --git a/src/Tasks/ResolveCodeAnalysisRuleSet.cs b/src/Tasks/ResolveCodeAnalysisRuleSet.cs
index 3bcb41882e1..8c1f481d630 100644
--- a/src/Tasks/ResolveCodeAnalysisRuleSet.cs
+++ b/src/Tasks/ResolveCodeAnalysisRuleSet.cs
@@ -53,7 +53,7 @@ public override bool Execute()
 
         /// <summary>
         /// Computes the resolved rule set path.
-        /// 
+        ///
         /// There are four cases: null, file name, relative path, and full path.
         ///
         /// If we were given no value for the ruleset, simply return null.
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index a9fcee543f6..b3a1bca439a 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -84,12 +84,12 @@ internal interface IResolveComReferenceTaskContract
         bool NoClassMembers { get; set; }
 
         /// <summary>
-        /// If true, do not log messages or warnings.  Default is false. 
+        /// If true, do not log messages or warnings.  Default is false.
         /// </summary>
         bool Silent { get; set; }
 
         /// <summary>
-        /// The preferred target processor architecture. Passed to tlbimp.exe /machine flag after translation. 
+        /// The preferred target processor architecture. Passed to tlbimp.exe /machine flag after translation.
         /// Should be a member of Microsoft.Build.Utilities.ProcessorArchitecture.
         /// </summary>
         string TargetProcessorArchitecture { get; set; }
@@ -188,7 +188,7 @@ public ResolveComReference()
         public string TargetFrameworkVersion { get; set; } = String.Empty;
 
         #endregion
-#pragma warning restore format 
+#pragma warning restore format
     }
 
 #else
@@ -316,7 +316,7 @@ public override bool Execute()
 
             if (!ComputePathToAxImp() || !ComputePathToTlbImp())
             {
-                // unable to compute the path to tlbimp.exe, aximp.exe, or both and that is necessary to 
+                // unable to compute the path to tlbimp.exe, aximp.exe, or both and that is necessary to
                 // continue forward, so return now.
                 return false;
             }
@@ -356,7 +356,7 @@ public override bool Execute()
 
                 // Process each task item. If one of them fails we still process the rest of them, but
                 // remember that the task should return failure.
-                // DESIGN CHANGE: we no longer fail the task when one or more references fail to resolve. 
+                // DESIGN CHANGE: we no longer fail the task when one or more references fail to resolve.
                 // Unless we experience a catastrophic failure, we'll log warnings for those refs and proceed
                 // (and return success)
                 var moduleList = new List<ITaskItem>();
@@ -396,7 +396,7 @@ public override bool Execute()
                             catch (FileLoadException ex)
                             {
                                 // This exception is thrown when we try to load a delay signed assembly without disabling
-                                // strong name verification first. So print a nice information if we're generating 
+                                // strong name verification first. So print a nice information if we're generating
                                 // delay signed wrappers, otherwise rethrow, since it's an unexpected exception.
                                 if (DelaySign)
                                 {
@@ -415,7 +415,7 @@ public override bool Execute()
                             catch (ArgumentException ex)
                             {
                                 // This exception is thrown when we try to convert some of the Metadata from the project
-                                // file and the conversion fails.  Most likely, the user needs to correct a type in the 
+                                // file and the conversion fails.  Most likely, the user needs to correct a type in the
                                 // project file.
                                 Log.LogErrorWithCodeFromResources("General.InvalidArgument", ex.Message);
                                 return false;
@@ -435,8 +435,8 @@ public override bool Execute()
                 ResolvedModules = moduleList.ToArray();
                 ResolvedFiles = resolvedReferenceList.ToArray();
 
-                // The Logs from AxImp and TlbImp aren't part of our log, but if the task failed, it will return false from 
-                // GenerateWrapper, which should get passed all the way back up here.  
+                // The Logs from AxImp and TlbImp aren't part of our log, but if the task failed, it will return false from
+                // GenerateWrapper, which should get passed all the way back up here.
                 return allReferencesResolvedSuccessfully && !Log.HasLoggedErrors;
             }
             finally
@@ -477,7 +477,7 @@ internal void SetFrameworkVersionFromString(string version)
         }
 
         /// <summary>
-        /// Computes the path to TlbImp.exe for use in logging and for passing to the 
+        /// Computes the path to TlbImp.exe for use in logging and for passing to the
         /// nested TlbImp task.
         /// </summary>
         /// <returns>True if the path is found (or it doesn't matter because we're executing in memory), false otherwise</returns>
@@ -517,7 +517,7 @@ private bool ComputePathToTlbImp()
         }
 
         /// <summary>
-        /// Computes the path to AxImp.exe for use in logging and for passing to the 
+        /// Computes the path to AxImp.exe for use in logging and for passing to the
         /// nested AxImp task.
         /// </summary>
         /// <returns>True if the path is found, false otherwise</returns>
@@ -530,12 +530,12 @@ private bool ComputePathToAxImp()
             {
                 // In certain cases -- such as trying to build a Dev10 project on a machine that only has Dev11 installed --
                 // it's possible to have ExecuteAsTool set to false (e.g. "use the current CLR") but still have SDKToolsPath
-                // be empty (because it's referencing the 7.0A SDK in the registry, which doesn't exist).  In that case, we 
-                // want to look for VersionLatest.  However, if ExecuteAsTool is true (default value) and SDKToolsPath is 
+                // be empty (because it's referencing the 7.0A SDK in the registry, which doesn't exist).  In that case, we
+                // want to look for VersionLatest.  However, if ExecuteAsTool is true (default value) and SDKToolsPath is
                 // empty, then we can safely assume that we want to get the 3.5 version of the tool.
                 TargetDotNetFrameworkVersion targetAxImpVersion = ExecuteAsTool ? TargetDotNetFrameworkVersion.Version35 : TargetDotNetFrameworkVersion.Latest;
 
-                // We want to use the copy of AxImp corresponding to our targeted architecture if possible.  
+                // We want to use the copy of AxImp corresponding to our targeted architecture if possible.
                 _aximpPath = GetPathToSDKFileWithCurrentlyTargetedArchitecture("AxImp.exe", targetAxImpVersion, VisualStudioVersion.VersionLatest);
 
                 if (_aximpPath == null)
@@ -559,7 +559,7 @@ private bool ComputePathToAxImp()
         }
 
         /// <summary>
-        /// Try to get the path to the tool in the Windows SDK with the given .NET Framework version and 
+        /// Try to get the path to the tool in the Windows SDK with the given .NET Framework version and
         /// of the same architecture as we were currently given for TargetProcessorArchitecture.
         /// </summary>
         private string GetPathToSDKFileWithCurrentlyTargetedArchitecture(string file, TargetDotNetFrameworkVersion targetFrameworkVersion, VisualStudioVersion visualStudioVersion)
@@ -617,7 +617,7 @@ private void Cleanup()
 
         /*
          * Method:  VerifyAndInitializeInputs
-         * 
+         *
          * Helper method. Verifies the input task items have correct metadata and initializes optional ones with
          * default values if they're not present.
          */
@@ -687,7 +687,7 @@ private bool VerifyAndInitializeInputs()
 
         /*
          * Method:  ConvertAttrReferencesToComReferenceInfo
-         * 
+         *
          * Helper method. Converts TypeLibAttr references to ComReferenceInfo objects.
          * This method cannot fail, since we want to proceed with the task even if some references won't load.
          */
@@ -725,7 +725,7 @@ private void ConvertAttrReferencesToComReferenceInfo(List<ComReferenceInfo> proj
 
         /*
          * Method:  ConvertFileReferencesToComReferenceInfo
-         * 
+         *
          * Helper method. Converts TypeLibFiles references to ComReferenceInfo objects
          * This method cannot fail, since we want to proceed with the task even if some references won't load.
          */
@@ -881,8 +881,8 @@ private bool ResolveReferenceAndAddToList(
 
         /*
          * Method:  ResolveReference
-         * 
-         * Helper COM resolution method. Creates an appropriate helper class for the given tool and calls 
+         *
+         * Helper COM resolution method. Creates an appropriate helper class for the given tool and calls
          * the Resolve method on it.
          */
         internal bool ResolveReference(ComDependencyWalker dependencyWalker, ComReferenceInfo referenceInfo, string outputDirectory, out ITaskItem referencePathItem)
@@ -936,7 +936,7 @@ internal bool ResolveReference(ComDependencyWalker dependencyWalker, ComReferenc
 
         /*
          * Method:  IsExistingProjectReference
-         * 
+         *
          * If given typelib attributes are already a project reference, return that reference.
          */
         internal bool IsExistingProjectReference(TYPELIBATTR typeLibAttr, string neededRefType, out ComReferenceInfo referenceInfo)
@@ -977,7 +977,7 @@ internal bool IsExistingProjectReference(TYPELIBATTR typeLibAttr, string neededR
 
         /*
          * Method:  IsExistingDependencyReference
-         * 
+         *
          * If given typelib attributes are already a dependency reference (that is, was already
          * processed) return that reference.
          */
@@ -999,7 +999,7 @@ internal bool IsExistingDependencyReference(TYPELIBATTR typeLibAttr, out ComRefe
 
         /*
          * Method:  ResolveComClassicReference
-         * 
+         *
          * Resolves a COM classic reference given the type library attributes and the type of wrapper to use.
          * If wrapper type is not specified, this method will first look for an existing reference in the project,
          * fall back to looking for a PIA and finally try to generate a regular tlbimp wrapper.
@@ -1050,7 +1050,7 @@ internal bool ResolveComClassicReference(ComReferenceInfo referenceInfo, string
 
         /*
          * Method:  ResolveComClassicReference
-         * 
+         *
          * Resolves a COM classic reference given the type library attributes and the type of wrapper to use.
          * If wrapper type is not specified, this method will first look for an existing reference in the project,
          * fall back to looking for a PIA and finally try to generate a regular tlbimp wrapper.
@@ -1076,7 +1076,7 @@ bool IComReferenceResolver.ResolveComClassicReference(TYPELIBATTR typeLibAttr, s
             // find an existing ref in the project (taking the desired wrapperType into account, if any)
             if (IsExistingProjectReference(typeLibAttr, wrapperType, out ComReferenceInfo referenceInfo))
             {
-                // IsExistingProjectReference should not return null... 
+                // IsExistingProjectReference should not return null...
                 Debug.Assert(referenceInfo != null, "IsExistingProjectReference should not return null");
                 topLevelRef = true;
                 wrapperType = referenceInfo.taskItem.GetMetadata(ComReferenceItemMetadataNames.wrapperTool);
@@ -1145,7 +1145,7 @@ bool IComReferenceResolver.ResolveComClassicReference(TYPELIBATTR typeLibAttr, s
 
         /*
          * Method:  ResolveNetAssemblyReference
-         * 
+         *
          * Resolves a .NET assembly reference using the list of resolved managed references supplied to the task.
          *
          * This is the method available for references to call back to resolve their dependencies
@@ -1177,9 +1177,9 @@ bool IComReferenceResolver.ResolveNetAssemblyReference(string assemblyName, out
 
         /*
          * Method:  ResolveComAssemblyReference
-         * 
+         *
          * Resolves a COM wrapper assembly reference based on the COM references resolved so far. This method is necessary
-         * for Ax wrappers only, so all necessary references will be resolved by then (since we resolve them in 
+         * for Ax wrappers only, so all necessary references will be resolved by then (since we resolve them in
          * the following order: pia, tlbimp, aximp)
          *
          * This is the method available for references to call back to resolve their dependencies
@@ -1292,7 +1292,7 @@ internal bool ResolveComReferencePia(ComReferenceInfo referenceInfo, string refN
         }
 
         /// <summary>
-        /// Return the set of item specs for the resolved assembly references. 
+        /// Return the set of item specs for the resolved assembly references.
         /// </summary>
         /// <returns></returns>
         internal IEnumerable<string> GetResolvedAssemblyReferenceItemSpecs()
@@ -1433,7 +1433,7 @@ internal bool ResolveComReferenceAx(ComReferenceInfo referenceInfo, string outpu
 
         /*
          * Method:  VerifyReferenceMetadataForNameItem
-         * 
+         *
          * Verifies that all required metadata on the COM reference item are there.
          */
         internal static bool VerifyReferenceMetadataForNameItem(ITaskItem reference, out string missingOrInvalidMetadata)
@@ -1507,7 +1507,7 @@ internal static bool VerifyReferenceMetadataForNameItem(ITaskItem reference, out
 
         /*
          * Method:  InitializeDefaultMetadataForNameItem
-         * 
+         *
          * Initializes optional metadata on given name item to their default values if they're not present
          */
         internal static void InitializeDefaultMetadataForNameItem(ITaskItem reference)
@@ -1527,7 +1527,7 @@ internal static void InitializeDefaultMetadataForNameItem(ITaskItem reference)
 
         /*
          * Method:  InitializeDefaultMetadataForFileItem
-         * 
+         *
          * Initializes optional metadata on given file item to their default values if they're not present
          */
         internal static void InitializeDefaultMetadataForFileItem(ITaskItem reference)
@@ -1541,7 +1541,7 @@ internal static void InitializeDefaultMetadataForFileItem(ITaskItem reference)
 
         /*
          * Method:  CheckForConflictingReferences
-         * 
+         *
          * Checks if we have any conflicting references.
          */
         internal bool CheckForConflictingReferences()
@@ -1629,7 +1629,7 @@ internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTa
 
                 string privateMetadata = taskItem.GetMetadata(ItemMetadataNames.privateMetadata);
 
-                // if Private is not set on the original item, we set CopyLocal to false for GAC items 
+                // if Private is not set on the original item, we set CopyLocal to false for GAC items
                 // and true for non-GAC items
                 if (string.IsNullOrEmpty(privateMetadata))
                 {
@@ -1652,7 +1652,7 @@ internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTa
 
         /// <summary>
         /// Scan all the dependencies of the main project references and preresolve them
-        /// so that when we get asked about a previously unknown dependency in the form of a .NET assembly 
+        /// so that when we get asked about a previously unknown dependency in the form of a .NET assembly
         /// we know what to do with it.
         /// </summary>
         private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependencyWalker, ComReferenceInfo reference)
@@ -1684,13 +1684,13 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
 
             foreach (TYPELIBATTR dependencyTypeLibAttr in dependentAttrs)
             {
-                // We don't need to even try to resolve if the dependency reference is ourselves. 
+                // We don't need to even try to resolve if the dependency reference is ourselves.
                 if (!ComReference.AreTypeLibAttrEqual(dependencyTypeLibAttr, reference.attr))
                 {
                     if (IsExistingProjectReference(dependencyTypeLibAttr, null, out ComReferenceInfo existingReference))
                     {
                         // If we're resolving another project reference, empty out the type cache -- if the dependencies are buried,
-                        // caching the analyzed types can make it so that we don't recognize our dependencies' dependencies. 
+                        // caching the analyzed types can make it so that we don't recognize our dependencies' dependencies.
                         dependencyWalker.ClearAnalyzedTypeCache();
 
                         if (ResolveReference(dependencyWalker, existingReference, WrapperOutputDirectory, out ITaskItem resolvedItem))
@@ -1698,7 +1698,7 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
                             // Add the resolved dependency
                             dependentPaths.Add(resolvedItem.ItemSpec);
 
-                            // and anything it depends on 
+                            // and anything it depends on
                             foreach (string dependentPath in existingReference.dependentWrapperPaths)
                             {
                                 dependentPaths.Add(dependentPath);
@@ -1733,7 +1733,7 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
 
         /*
          * Method:  TaskItemToTypeLibAttr
-         * 
+         *
          * Gets the TLIBATTR structure based on the reference we have.
          * Sets guid, versions major & minor, lcid.
          */
@@ -1761,7 +1761,7 @@ internal static TYPELIBATTR TaskItemToTypeLibAttr(ITaskItem taskItem)
         }
 
         #endregion
-#pragma warning restore format 
+#pragma warning restore format
     }
 
 #endif
diff --git a/src/Tasks/ResolveComReferenceCache.cs b/src/Tasks/ResolveComReferenceCache.cs
index 2972c86df93..ee7b4577a9c 100644
--- a/src/Tasks/ResolveComReferenceCache.cs
+++ b/src/Tasks/ResolveComReferenceCache.cs
@@ -14,13 +14,13 @@ namespace Microsoft.Build.Tasks
     /// Stores timestamps of COM components processed in the last run. The problem here is that installing/uninstalling
     /// COM components does not update their timestamps with the current time (for a good reason). So if you revert to
     /// an earlier revision of a COM component, its timestamp can go back in time and we still need to regenerate its
-    /// wrapper. So in ResolveComReference we compare the stored timestamp with the current component timestamp, and if 
+    /// wrapper. So in ResolveComReference we compare the stored timestamp with the current component timestamp, and if
     /// they are different, we regenerate the wrapper.
     /// </remarks>
     internal sealed class ResolveComReferenceCache : StateFileBase, ITranslatable
     {
         /// <summary>
-        /// Component timestamps. 
+        /// Component timestamps.
         /// Key: Component path on disk
         /// Value: DateTime struct
         /// </summary>
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 484401442be..f67cab5f410 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -232,7 +232,7 @@ internal bool ExtractFromManifest(
                 }
 
                 bool isClickOnceApp = manifest is ApplicationManifest applicationManifest && applicationManifest.IsClickOnceManifest;
-                // ClickOnce application manifest should not be added as native reference, but we should open and process it.        
+                // ClickOnce application manifest should not be added as native reference, but we should open and process it.
                 if (!containingReferenceFilesTable.ContainsKey(path) && !isClickOnceApp)
                 {
                     ITaskItem itemNativeReferenceFile = new TaskItem();
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index d279d8fd9e2..0e458a48807 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -202,7 +202,7 @@ public string TargetPlatformVersion
         public ITaskItem[] DisallowedSDKDependencies { get; set; }
 
         /// <summary>
-        /// List of dependencies passed from the targets file that will have the metadata RuntimeReferenceOnly set as true. 
+        /// List of dependencies passed from the targets file that will have the metadata RuntimeReferenceOnly set as true.
         /// For instance "VCLibs 11" should have such a metadata set to true in projects targeting Win 8.1 or higher.
         /// </summary>
         public ITaskItem[] RuntimeReferenceOnlySDKDependencies { get; set; }
@@ -220,7 +220,7 @@ public string TargetPlatformVersion
         public string TargetedSDKArchitecture { get; set; }
 
         /// <summary>
-        /// Enables warning when MaxPlatformVersion is not present in the manifest and the ESDK platform version (from its path) 
+        /// Enables warning when MaxPlatformVersion is not present in the manifest and the ESDK platform version (from its path)
         /// is different than the target platform version (from the project)
         /// </summary>
         public bool WarnOnMissingPlatformVersion { get; set; }
@@ -306,7 +306,7 @@ public override bool Execute()
                 }
             }
 
-            // We need to check to see if there are any SDKNames on any of the reference items in the project. If there are 
+            // We need to check to see if there are any SDKNames on any of the reference items in the project. If there are
             // then we do not want those SDKs to expand their reference assemblies by default because we are going to use RAR to look inside of them for certain reference assemblies only.
             var sdkNamesOnReferenceItems = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
             if (References != null)
@@ -333,14 +333,14 @@ public override bool Execute()
             // Set of sdks which are not compatible with other sdks of the same product famuily or with the same sdk name
             var sdksNotCompatibleWithOtherSDKs = new HashSet<SDKReference>();
 
-            // Go through each reference passed in and determine if it is in the set of installed SDKs. 
+            // Go through each reference passed in and determine if it is in the set of installed SDKs.
             // Also create new output items if the item is in an installed SDK and set the metadata correctly.
             foreach (ITaskItem referenceItem in SDKReferences)
             {
                 // Parse the SDK reference item include. The name could have been added by a user and may have extra spaces or be not well formatted.
                 SDKReference reference = ParseSDKReference(referenceItem);
 
-                // Could not parse the reference, lets skip over this reference item. An error would have been logged in the ParseSDKReference method to tell the 
+                // Could not parse the reference, lets skip over this reference item. An error would have been logged in the ParseSDKReference method to tell the
                 // user why the parsing did not happen.
                 if (reference == null)
                 {
@@ -1002,7 +1002,7 @@ private static string GetItemMetadataTrimmed(ITaskItem item, string metadataName
             /// <summary>
             /// After resolving a reference we need to check to see if there is a SDKManifest file in the root directory and if there is we need to extract the frameworkidentity.
             /// We ignore other attributes to leave room for expansion of the file format.
-            /// 
+            ///
             /// </summary>
             private void GetSDKManifestAttributes()
             {
@@ -1281,7 +1281,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                 }
 
                 // The SDKManifest may have had a number of frameworkidentity entries inside of it. We want to match the one
-                // which has the correct configuration and architecture. If a perfect match cannot be found 
+                // which has the correct configuration and architecture. If a perfect match cannot be found
                 // then we will look for ones that declare only the configuration. If that cannot be found we just try and find an element that only is "FrameworkIdentity".
                 if (String.IsNullOrEmpty(FrameworkIdentity))
                 {
@@ -1385,7 +1385,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                                 bool containsKey = architectureLocations.TryGetValue(architectureComponent, out string architectureLocation);
 
-                                // If we have not seen this architecture before (and it has a compatible configuration with what we are targeting) then add it. 
+                                // If we have not seen this architecture before (and it has a compatible configuration with what we are targeting) then add it.
                                 // Also, replace the entry if we have already added an entry for a non configuration specific entry and we now have a configuration specific entry that matches what we are targeting.
                                 if ((configurationComponent == null && !containsKey) || (configurationComponent?.Equals(sdkConfiguration, StringComparison.OrdinalIgnoreCase) == true))
                                 {
diff --git a/src/Tasks/SGen.cs b/src/Tasks/SGen.cs
index 8ed872450f0..743cbf2eaf8 100644
--- a/src/Tasks/SGen.cs
+++ b/src/Tasks/SGen.cs
@@ -305,7 +305,7 @@ protected override string GenerateFullPathToTool()
         {
             string pathToTool = null;
 
-            // If COMPLUS_InstallRoot\COMPLUS_Version are set (the dogfood world), we want to find it there, instead of 
+            // If COMPLUS_InstallRoot\COMPLUS_Version are set (the dogfood world), we want to find it there, instead of
             // the SDK, which may or may not be installed. The following will look there.
             if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("COMPLUS_InstallRoot")) || !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("COMPLUS_Version")))
             {
@@ -401,7 +401,7 @@ protected override string GenerateCommandLineCommands()
                 // The arguments to the "/compiler" switch are themselves switches to be passed to
                 // the compiler when generating the serialization assembly.
 
-                // Add the compiler command switches for strong naming on the serialization assembly          
+                // Add the compiler command switches for strong naming on the serialization assembly
                 if (KeyFile != null)
                 {
                     commandLineBuilder.AppendNestedSwitch("/compiler:", "/keyfile:", KeyFile);
diff --git a/src/Tasks/SdkToolsPathUtility.cs b/src/Tasks/SdkToolsPathUtility.cs
index 35e2efb656e..bba221c57cb 100644
--- a/src/Tasks/SdkToolsPathUtility.cs
+++ b/src/Tasks/SdkToolsPathUtility.cs
@@ -109,7 +109,7 @@ internal static string GeneratePathToTool(FileExists fileExists, string currentA
                 }
             }
 
-            // Fall back and see if we can find it with the toolsLocation helper methods. This is not optimal because 
+            // Fall back and see if we can find it with the toolsLocation helper methods. This is not optimal because
             // the location they are looking at is based on when the Microsoft.Build.Utilities.dll was compiled
             // but it is better than nothing.
             if (pathToTool == null || !fileExists(pathToTool))
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 96a4e7d7ce8..7e1e971b48d 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -116,7 +116,7 @@ internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log) w
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                // The deserialization process seems like it can throw just about 
+                // The deserialization process seems like it can throw just about
                 // any exception imaginable.  Catch them all here.
                 // Not being able to deserialize the cache is not an error, but we let the user know anyway.
                 // Don't want to hold up processing just because we couldn't read the file.
diff --git a/src/Tasks/StrongNameUtils.cs b/src/Tasks/StrongNameUtils.cs
index 7c2fa1a52fd..7e615bbe4b7 100644
--- a/src/Tasks/StrongNameUtils.cs
+++ b/src/Tasks/StrongNameUtils.cs
@@ -79,7 +79,7 @@ internal static void ReadKeyFile(TaskLoggingHelper log, string keyFile, out Stro
                 publicKey = snp.PublicKey;
 
                 // If we didn't throw up to this point then we have a valid public/private key pair,
-                // so assign the object just created above to the out parameter.  
+                // so assign the object just created above to the out parameter.
                 keyPair = snp;
             }
             catch (ArgumentException)
@@ -280,7 +280,7 @@ private static uint GetCor20HeaderRva(IntPtr ntHeadersPtr)
 
             // cor20DataDirectoryLong is really a IMAGE_DATA_DIRECTORY structure which I had to pack into an ulong
             // (see comments for IMAGE_OPTIONAL_HEADER32/64 in NativeMethods.cs)
-            // this code extracts the virtualAddress (uint) and size (uint) fields from the ulong by doing simple 
+            // this code extracts the virtualAddress (uint) and size (uint) fields from the ulong by doing simple
             // bit masking/shifting ops
             uint virtualAddress = (uint)(cor20DataDirectoryLong & 0x00000000ffffffff);
             // uint size = (uint)(cor20DataDirectoryLong >> 32);
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 8774ba6773b..dd09094f7d1 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -48,21 +48,21 @@ internal sealed class SystemState : StateFileBase, ITranslatable
 
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
-        /// cache this for long periods of time since there's no way (without actually 
+        /// cache this for long periods of time since there's no way (without actually
         /// calling File.GetLastWriteTimeUtc) to tell whether the cache is out-of-date.
         /// </summary>
         private Dictionary<string, DateTime> instanceLocalLastModifiedCache = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// DirectoryExists information is purely instance-local. It doesn't make sense to
-        /// cache this for long periods of time since there's no way (without actually 
+        /// cache this for long periods of time since there's no way (without actually
         /// calling Directory.Exists) to tell whether the cache is out-of-date.
         /// </summary>
         private Dictionary<string, bool> instanceLocalDirectoryExists = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// GetDirectories information is also purely instance-local. This information
-        /// is only considered good for the lifetime of the task (or whatever) that owns 
+        /// is only considered good for the lifetime of the task (or whatever) that owns
         /// this instance.
         /// </summary>
         private Dictionary<string, string[]> instanceLocalDirectories = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
@@ -298,7 +298,7 @@ internal void SetGetLastWriteTime(GetLastWriteTime getLastWriteTimeValue)
         }
 
         /// <summary>
-        /// Cache the results of a GetAssemblyName delegate. 
+        /// Cache the results of a GetAssemblyName delegate.
         /// </summary>
         /// <param name="getAssemblyNameValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
@@ -309,7 +309,7 @@ internal GetAssemblyName CacheDelegate(GetAssemblyName getAssemblyNameValue)
         }
 
         /// <summary>
-        /// Cache the results of a GetAssemblyMetadata delegate. 
+        /// Cache the results of a GetAssemblyMetadata delegate.
         /// </summary>
         /// <param name="getAssemblyMetadataValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
@@ -320,7 +320,7 @@ internal GetAssemblyMetadata CacheDelegate(GetAssemblyMetadata getAssemblyMetada
         }
 
         /// <summary>
-        /// Cache the results of a FileExists delegate. 
+        /// Cache the results of a FileExists delegate.
         /// </summary>
         /// <returns>Cached version of the delegate.</returns>
         internal FileExists CacheDelegate()
@@ -335,7 +335,7 @@ public DirectoryExists CacheDelegate(DirectoryExists directoryExistsValue)
         }
 
         /// <summary>
-        /// Cache the results of a GetDirectories delegate. 
+        /// Cache the results of a GetDirectories delegate.
         /// </summary>
         /// <param name="getDirectoriesValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
@@ -346,7 +346,7 @@ internal GetDirectories CacheDelegate(GetDirectories getDirectoriesValue)
         }
 
         /// <summary>
-        /// Cache the results of a GetAssemblyRuntimeVersion delegate. 
+        /// Cache the results of a GetAssemblyRuntimeVersion delegate.
         /// </summary>
         /// <param name="getAssemblyRuntimeVersion">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
@@ -483,7 +483,7 @@ private AssemblyNameExtension GetAssemblyName(string path)
                 fileState.Assembly = getAssemblyName(path);
 
                 // Certain assemblies, like mscorlib may not have metadata.
-                // Avoid continuously calling getAssemblyName on these files by 
+                // Avoid continuously calling getAssemblyName on these files by
                 // recording these as having an empty name.
                 if (fileState.Assembly == null)
                 {
@@ -523,7 +523,7 @@ private string GetRuntimeVersion(string path)
         }
 
         /// <summary>
-        /// Cached implementation. Given an assembly name, crack it open and retrieve the list of dependent 
+        /// Cached implementation. Given an assembly name, crack it open and retrieve the list of dependent
         /// assemblies and  the list of scatter files.
         /// </summary>
         /// <param name="path">Path to the assembly.</param>
@@ -649,7 +649,7 @@ private string[] GetDirectories(string path, string pattern)
                 return cached;
             }
 
-            // This path is currently uncalled. Use assert to tell the dev that adds a new code-path 
+            // This path is currently uncalled. Use assert to tell the dev that adds a new code-path
             // that this is an unoptimized path.
             Debug.Assert(false, "Using slow-path in SystemState.GetDirectories, was this intentional?");
 
diff --git a/src/Tasks/TlbImp.cs b/src/Tasks/TlbImp.cs
index 1c9bc7c6228..db367d81977 100644
--- a/src/Tasks/TlbImp.cs
+++ b/src/Tasks/TlbImp.cs
@@ -273,7 +273,7 @@ protected override bool ValidateParameters()
                     return false;
                 }
 
-                // Verify that an allowed combination of TlbImpTransformFlags has been 
+                // Verify that an allowed combination of TlbImpTransformFlags has been
                 // passed to the Transform property.
                 if (!ValidateTransformFlags())
                 {
diff --git a/src/Tasks/TlbReference.cs b/src/Tasks/TlbReference.cs
index 12a00027180..9334ab87fbb 100644
--- a/src/Tasks/TlbReference.cs
+++ b/src/Tasks/TlbReference.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Tasks
 {
     /*
      * Class:   TlbReference
-     * 
+     *
      * COM reference wrapper class for the tlbimp tool.
      *
      */
@@ -85,7 +85,7 @@ internal TlbReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComRefe
 
         /*
          * Method:  GetWrapperFileName
-         * 
+         *
          * Constructs the wrapper file name from a type library name.
          */
         protected override string GetWrapperFileNameInternal(string typeLibName)
@@ -122,7 +122,7 @@ internal static string GetWrapperFileName(string typeLibName, bool includeTypeLi
 
         /*
          * Method:  FindExistingWrapper
-         * 
+         *
          * Checks if there's a preexisting wrapper for this reference.
          */
         internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperInfo, DateTime componentTimestamp)
@@ -139,7 +139,7 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
 
         /*
          * Method:  GenerateWrapper
-         * 
+         *
          * Generates a wrapper for this reference.
          */
         internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
@@ -298,7 +298,7 @@ internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
 
         /*
          * Method:  WriteWrapperToDisk
-         * 
+         *
          * Writes the generated wrapper out to disk. Should only be called for permanent wrappers.
          */
         private void WriteWrapperToDisk(AssemblyBuilder assemblyBuilder, string wrapperPath)
@@ -341,12 +341,12 @@ private void WriteWrapperToDisk(AssemblyBuilder assemblyBuilder, string wrapperP
                     case UtilitiesProcessorArchitecture.MSIL:
                     default:
                         // If no target processor architecture was passed, we assume MSIL; calling Save
-                        // with no parameters should be equivalent to saving as ILOnly.  
+                        // with no parameters should be equivalent to saving as ILOnly.
                         assemblyBuilder.Save(wrapperFile.Name);
                         break;
                 }
 
-                // AssemblyBuilder doesn't always throw when it's supposed to write stuff to a non-writable 
+                // AssemblyBuilder doesn't always throw when it's supposed to write stuff to a non-writable
                 // network path. Make sure that the assembly actually got written to where we wanted it to.
                 File.GetLastWriteTime(wrapperPath);
             }
@@ -367,8 +367,8 @@ private void WriteWrapperToDisk(AssemblyBuilder assemblyBuilder, string wrapperP
 
         /*
          * Method:  ITypeLibImporterNotifySink.ResolveRef
-         * 
-         * Implementation of ITypeLibImporterNotifySink.ResolveRef - this method is called by the NDP type lib converter 
+         *
+         * Implementation of ITypeLibImporterNotifySink.ResolveRef - this method is called by the NDP type lib converter
          * to resolve dependencies.
          * We should never return null here - it's not documented as the proper way of failing dependency resolution.
          * Instead, we use an exception to abort the conversion process.
@@ -408,7 +408,7 @@ Assembly ITypeLibImporterNotifySink.ResolveRef(object objTypeLib)
 
         /*
          * Method:  ITypeLibImporterNotifySink.ReportEvent
-         * 
+         *
          * Implementation of ITypeLibImporterNotifySink.ReportEvent - this method gets called by NDP type lib converter
          * to report various messages (like "type blahblah converted" or "failed to convert type blahblah").
          */
diff --git a/src/Tasks/Touch.cs b/src/Tasks/Touch.cs
index 75d00478679..5e2cf4883f8 100644
--- a/src/Tasks/Touch.cs
+++ b/src/Tasks/Touch.cs
@@ -97,8 +97,8 @@ internal bool ExecuteImpl(
                     continue;
                 }
 
-                // Touch the file.  If the file was touched successfully then add it to our array of 
-                // touched items. 
+                // Touch the file.  If the file was touched successfully then add it to our array of
+                // touched items.
                 if
                 (
                     TouchFile(
@@ -123,7 +123,7 @@ internal bool ExecuteImpl(
             }
 
             // Now, set the property that indicates which items we touched.  Note that we
-            // touch all the items 
+            // touch all the items
             TouchedFiles = touchedItems.ToArray();
             return retVal;
         }
@@ -233,7 +233,7 @@ private bool TouchFile(
                 Log.LogMessageFromResources(messageImportance, "Touch.Touching", file);
             }
 
-            // If the file is read only then we must either issue an error, or, if the user so 
+            // If the file is read only then we must either issue an error, or, if the user so
             // specified, make the file temporarily not read only.
             bool needToRestoreAttributes = false;
             FileAttributes faOriginal = fileGetAttributes(file);
@@ -271,7 +271,7 @@ private bool TouchFile(
             {
                 if (needToRestoreAttributes)
                 {
-                    // Attempt to restore the attributes.  If we fail here, then there is 
+                    // Attempt to restore the attributes.  If we fail here, then there is
                     // not much we can do.
                     try
                     {
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 6721625deb5..6060fb33b8e 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -158,7 +158,7 @@ private bool Unregister(string assemblyPath, string typeLibPath)
             {
                 try
                 {
-                    // Load the specified assembly. 
+                    // Load the specified assembly.
                     Assembly asm = Assembly.UnsafeLoadFrom(assemblyPath);
 
                     var comRegistrar = new RegistrationServices();
@@ -170,7 +170,7 @@ private bool Unregister(string assemblyPath, string typeLibPath)
                         // Unregister the assembly
                         if (!comRegistrar.UnregisterAssembly(asm))
                         {
-                            // If the assembly doesn't contain any types that could be registered for COM interop, 
+                            // If the assembly doesn't contain any types that could be registered for COM interop,
                             // warn the user about it
                             Log.LogWarningWithCodeFromResources("UnregisterAssembly.NoValidTypes", assemblyPath);
                         }
diff --git a/src/Tasks/WinMDExp.cs b/src/Tasks/WinMDExp.cs
index 280b5dcb55c..24fdc5dbff8 100644
--- a/src/Tasks/WinMDExp.cs
+++ b/src/Tasks/WinMDExp.cs
@@ -269,7 +269,7 @@ protected override bool SkipTaskExecution()
                 var outputWriteTime = NativeMethodsShared.GetLastWriteFileUtcTime(OutputWindowsMetadataFile);
                 var winMDModuleWriteTime = NativeMethodsShared.GetLastWriteFileUtcTime(WinMDModule);
 
-                // If the last write time of the input file is less than the last write time of the output file 
+                // If the last write time of the input file is less than the last write time of the output file
                 // then the output is newer then the input so we do not need to re-run the tool.
                 if (outputWriteTime > winMDModuleWriteTime)
                 {
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index 19692a2fec9..c97bcb45557 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -642,8 +642,8 @@ private void GenerateStandardCommandLine(CommandLineBuilder builder, bool allOpt
         /// </summary>
         private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
         {
-            // Match all instances of [asdf], where "asdf" can be any combination of any 
-            // characters *except* a [ or an ]. i.e., if "[ [ sdf ]" is passed, then we will 
+            // Match all instances of [asdf], where "asdf" can be any combination of any
+            // characters *except* a [ or an ]. i.e., if "[ [ sdf ]" is passed, then we will
             // match "[ sdf ]"
             string matchString = @"\[[^\[\]]+\]";
             Regex regex = new Regex(matchString, RegexOptions.ECMAScript);
@@ -658,32 +658,32 @@ private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
                 }
 
                 // Because we match non-greedily, in the case where we have input such as "[[[[[foo]", the match will
-                // be "[foo]".  However, if there are multiple '[' in a row, we need to do some escaping logic, so we 
-                // want to know what the first *consecutive* square bracket was.  
+                // be "[foo]".  However, if there are multiple '[' in a row, we need to do some escaping logic, so we
+                // want to know what the first *consecutive* square bracket was.
                 int indexOfFirstBracketInMatch = match.Index;
 
-                // Indexing using "indexOfFirstBracketInMatch - 1" is safe here because it will always be 
-                // greater than indexOfEndOfLastSubstitution, which will always be 0 or greater. 
+                // Indexing using "indexOfFirstBracketInMatch - 1" is safe here because it will always be
+                // greater than indexOfEndOfLastSubstitution, which will always be 0 or greater.
                 while (indexOfFirstBracketInMatch > indexOfEndOfLastSubstitution && CommandLineTemplate[indexOfFirstBracketInMatch - 1].Equals('['))
                 {
                     indexOfFirstBracketInMatch--;
                 }
 
-                // Append everything we know we want to add -- everything between where the last substitution ended and 
-                // this match (including previous '[' that were not initially technically part of the match) begins. 
+                // Append everything we know we want to add -- everything between where the last substitution ended and
+                // this match (including previous '[' that were not initially technically part of the match) begins.
                 if (indexOfFirstBracketInMatch != indexOfEndOfLastSubstitution)
                 {
                     builder.AppendTextUnquoted(CommandLineTemplate.Substring(indexOfEndOfLastSubstitution, indexOfFirstBracketInMatch - indexOfEndOfLastSubstitution));
                 }
 
-                // Now replace every "[[" with a literal '['.  We can do this by simply counting the number of '[' between 
-                // the first one and the start of the match, since by definition everything in between is an '['.  
-                // + 1 because match.Index is also a bracket. 
+                // Now replace every "[[" with a literal '['.  We can do this by simply counting the number of '[' between
+                // the first one and the start of the match, since by definition everything in between is an '['.
+                // + 1 because match.Index is also a bracket.
                 int openBracketsInARow = match.Index - indexOfFirstBracketInMatch + 1;
 
                 if (openBracketsInARow % 2 == 0)
                 {
-                    // even number -- they all go away and the rest of the match is appended literally. 
+                    // even number -- they all go away and the rest of the match is appended literally.
                     for (int i = 0; i < openBracketsInARow / 2; i++)
                     {
                         builder.AppendTextUnquoted("[");
@@ -693,7 +693,7 @@ private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
                 }
                 else
                 {
-                    // odd number -- all but one get merged two at a time, and the rest of the match is substituted. 
+                    // odd number -- all but one get merged two at a time, and the rest of the match is substituted.
                     for (int i = 0; i < (openBracketsInARow - 1) / 2; i++)
                     {
                         builder.AppendTextUnquoted("[");
@@ -726,8 +726,8 @@ private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
                     }
                     else if (!PropertyExists(propertyName))
                     {
-                        // If the thing enclosed in square brackets is not in fact a property, we 
-                        // don't want to replace it. 
+                        // If the thing enclosed in square brackets is not in fact a property, we
+                        // don't want to replace it.
                         builder.AppendTextUnquoted('[' + propertyName + ']');
                     }
                 }
diff --git a/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs b/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs
index a1abf73861f..ba932ea9239 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs
@@ -26,7 +26,7 @@ public enum CommandLineToolSwitchType
 
         /// <summary>
         /// The integer switch is used for properties that have several different integer values,
-        /// and depending on the value the property is set to, appends an integer to the end 
+        /// and depending on the value the property is set to, appends an integer to the end
         /// of a certain switch
         /// e.g. WarningLevel = "0" is /W0, WarningLevel = "2" is /W2
         /// </summary>
@@ -42,7 +42,7 @@ public enum CommandLineToolSwitchType
         String = 2,
 
         /// <summary>
-        /// The stringarray switch is used for properties that may have more 
+        /// The stringarray switch is used for properties that may have more
         /// than one string appended to the end of the switch
         /// e.g. InjectPrecompiledHeaderReference = myfile is /Ylmyfile
         /// </summary>
@@ -199,15 +199,15 @@ public CommandLineToolSwitch(CommandLineToolSwitchType toolType)
 
         /// <summary>
         /// The separator indicates the characters that go between the switch and the string
-        /// in the string typed case, the characters that go between each name for the 
-        /// string array case, or the characters that go between the switch and the 
+        /// in the string typed case, the characters that go between each name for the
+        /// string array case, or the characters that go between the switch and the
         /// appendage for the boolean case.
         /// </summary>
         public string Separator { get; set; } = String.Empty;
 
         /// <summary>
         /// The Fallback attribute is used to specify which property to look at in the
-        /// case that the argument property is not set, or if the file that the 
+        /// case that the argument property is not set, or if the file that the
         /// argument property indicates is nonexistent.
         /// </summary>
         public string FallbackArgumentParameter { get; set; } = String.Empty;
diff --git a/src/Tasks/XamlTaskFactory/Property.cs b/src/Tasks/XamlTaskFactory/Property.cs
index e035df86c4c..bd7a04313e3 100644
--- a/src/Tasks/XamlTaskFactory/Property.cs
+++ b/src/Tasks/XamlTaskFactory/Property.cs
@@ -93,22 +93,22 @@ internal class Property
 
         /// <summary>
         /// The max integer value an integer typed switch can have
-        /// An exception should be thrown in the number the user specifies is 
+        /// An exception should be thrown in the number the user specifies is
         /// larger than the max
         /// </summary>
         public string Max { get; set; } = String.Empty;
 
         /// <summary>
         /// The minimum integer value an integer typed switch can have
-        /// An exception should be thrown in the number the user specifies is 
+        /// An exception should be thrown in the number the user specifies is
         /// less than the minimum
         /// </summary>
         public string Min { get; set; } = String.Empty;
 
         /// <summary>
         /// The separator indicates the characters that go between the switch and the string
-        /// in the string typed case, the characters that go between each name for the 
-        /// string array case, or the characters that go between the switch and the 
+        /// in the string typed case, the characters that go between each name for the
+        /// string array case, or the characters that go between the switch and the
         /// appendage for the boolean case.
         /// </summary>
         public string Separator { get; set; } = String.Empty;
@@ -132,7 +132,7 @@ internal class Property
 
         /// <summary>
         /// The Fallback attribute is used to specify which property to look at in the
-        /// case that the argument property is not set, or if the file that the 
+        /// case that the argument property is not set, or if the file that the
         /// argument property indicates is nonexistent.
         /// </summary>
         public string Fallback { get; set; } = String.Empty;
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index 8ef3dee1bf3..6a119d563f2 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -529,7 +529,7 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
                 child = child.NextSibling;
             }
 
-            // We've read any enumerated values and any dependencies, so we just 
+            // We've read any enumerated values and any dependencies, so we just
             // have to add the switchRelations
             switchRelationsList.Add(switchRelationsToAdd.SwitchValue, switchRelationsToAdd);
             return true;
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index 394daa631bd..38a2a4562e5 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -396,7 +396,7 @@ internal CodeCompileUnit GenerateCode()
                 // generate the constructor for this class
                 GenerateConstructor(taskClass);
 
-                // generate the property for ToolName 
+                // generate the property for ToolName
                 GenerateToolNameProperty(taskClass);
 
                 // generate all of the properties
@@ -760,7 +760,7 @@ private void GenerateIntegers(Property property, CodeMemberProperty propertyName
             // set statments
             GenerateCommon(property, propertyName, TypeInteger, typeof(Int32), NumberProperty);
 
-            // if a min or max exists, check those boundaries        
+            // if a min or max exists, check those boundaries
             CodeExpression[] parameters;
             string name = property.SwitchName != String.Empty ? property.Prefix + property.SwitchName : property.Name;
             if (!String.IsNullOrEmpty(property.Min) && !String.IsNullOrEmpty(property.Max))
@@ -835,7 +835,7 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
                 {
                     if (ContainsCurrentPlatform(val.SwitchName))
                     {
-                        // Create the array of argument expressions.                        
+                        // Create the array of argument expressions.
                         var argumentInitializers = new List<CodeObjectCreateExpression>(val.Arguments.Count);
                         foreach (Argument arg in val.Arguments)
                         {
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index af2ba073221..bd9f1aa2185 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -401,14 +401,14 @@ private bool ParseParameter(XamlTypes.BaseProperty baseProperty, LinkedList<Prop
                 argumentDependencyLookup.Add(propertyToAdd.Name, propertyToAdd);
             }
 
-            // We've read any enumerated values and any dependencies, so we just 
+            // We've read any enumerated values and any dependencies, so we just
             // have to add the property
             propertyList.AddLast(propertyToAdd);
             return true;
         }
 
         /// <summary>
-        /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for 
+        /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for
         /// this parameter group
         /// </summary>
         private static Property ObtainAttributes(XamlTypes.BaseProperty baseProperty, Property parameterGroup)
diff --git a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
index 783513727fa..90cc37b5e18 100644
--- a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
+++ b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
@@ -31,7 +31,7 @@ public abstract class XamlDataDrivenToolTask : ToolTask
         private TaskLoggingHelper _logPrivate;
 
         /// <summary>
-        /// The command line for this task. 
+        /// The command line for this task.
         /// </summary>
         private string _commandLine;
 
@@ -85,12 +85,12 @@ protected XamlDataDrivenToolTask(string[] switchOrderList, ResourceManager taskR
         protected internal Dictionary<string, CommandLineToolSwitch> ActiveToolSwitches { get; } = new Dictionary<string, CommandLineToolSwitch>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
-        /// Overridden to use UTF16, which works better than UTF8 for older versions of CL, LIB, etc. 
+        /// Overridden to use UTF16, which works better than UTF8 for older versions of CL, LIB, etc.
         /// </summary>
         protected override Encoding ResponseFileEncoding { get; } = Encoding.Unicode;
 
         /// <summary>
-        /// Made a property to abstract out the "if null, call GenerateCommands()" logic. 
+        /// Made a property to abstract out the "if null, call GenerateCommands()" logic.
         /// </summary>
         private string CommandLine
         {
@@ -107,7 +107,7 @@ public bool IsPropertySet(string propertyName)
         }
 
         /// <summary>
-        /// Replace an existing switch with the specifed one of the same name. 
+        /// Replace an existing switch with the specifed one of the same name.
         /// </summary>
         public void ReplaceToolSwitch(CommandLineToolSwitch switchToAdd)
         {
@@ -263,7 +263,7 @@ internal void ValidateOverrides()
         /// Creates the command line and returns it as a string by:
         /// 1. Adding all switches with the default set to the active switch list
         /// 2. Customizing the active switch list (overridden in derived classes)
-        /// 3. Iterating through the list and appending switches 
+        /// 3. Iterating through the list and appending switches
         /// </summary>
         protected override string GenerateResponseFileCommands()
         {
@@ -290,7 +290,7 @@ protected override bool HandleTaskExecutionErrors()
                 return true;
             }
 
-            // We don't want to use ToolTask's implementation because it doesn't report the command line that failed. 
+            // We don't want to use ToolTask's implementation because it doesn't report the command line that failed.
             if (ExitCode == NativeMethods.SE_ERR_ACCESSDENIED)
             {
                 _logPrivate.LogErrorWithCodeFromResources("Xaml.CommandFailedAccessDenied", CommandLine, ExitCode);
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 66e6834174c..4094d25b62e 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -115,7 +115,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
             // MSBuildToolsDirectoryRoot is the canonical location for MSBuild dll's.
             string pathToMSBuildBinaries = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;
 
-            // create the code generator options    
+            // create the code generator options
             // Since we are running msbuild 12.0 these had better load.
             var compilerParameters = new CompilerParameters(
                 new[]
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index f5e09078922..2f255f143cc 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -350,7 +350,7 @@ internal class XsltInput
             private readonly XslModes _xslMode;
 
             /// <summary>
-            /// Contains the raw XSLT 
+            /// Contains the raw XSLT
             /// or the path to XSLT file
             /// or the path to compiled XSLT dll.
             /// </summary>
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 7b9fbd54b77..6f6bf7f491e 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -40,11 +40,11 @@
   Plan for the future:
   Ideally we will be able to change the property getters here to use a
   resource index calculated at build time, being the x'th resource in the
-  .resources file.  We would then call something like 
+  .resources file.  We would then call something like
   ResourceManager.LookupResourceByIndex().  This would avoid some string
   comparisons during resource lookup.
 
-  This would require work from ResourceReader and/or ResourceWriter (or 
+  This would require work from ResourceReader and/or ResourceWriter (or
   a standalone, separate utility with duplicated code) to calculate the
   id's.  It would also require that all satellite assemblies use the same
   resource ID's as the main assembly.  This would require dummy entries
@@ -172,7 +172,7 @@ private static CodeCompileUnit InternalCreate(Dictionary<String, ResourceData> r
                 throw new ArgumentException(SR.GetString(SR.InvalidIdentifier, className));
             }
 
-            // If we have a namespace, verify the namespace is legal, 
+            // If we have a namespace, verify the namespace is legal,
             // attempting to fix it up if needed.
             if (!String.IsNullOrEmpty(generatedCodeNamespace))
             {
@@ -441,8 +441,8 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
               // try/finally, we'll avoid our double lock pattern here.
               // This will only hurt perf when we get two threads racing through
               // this method the first time.  Unfortunate, but not a big deal.
-              // Also, the .NET Compact Framework doesn't support 
-              // Thread.MemoryBarrier (they only run on processors w/ a strong 
+              // Also, the .NET Compact Framework doesn't support
+              // Thread.MemoryBarrier (they only run on processors w/ a strong
               // memory model, and who knows about IA64...)
               // Once we have Interlocked.CompareExchange<T>, we should use it here.
               if (_resMgr == null) {
@@ -500,7 +500,7 @@ private static string TruncateAndFormatCommentStringForOutput(string commentStri
                     commentString = SR.GetString(SR.StringPropertyTruncatedComment, commentString.Substring(0, DocCommentLengthThreshold));
                 }
 
-                // Encode the comment so it is safe for xml.  SecurityElement.Escape is the only method I've found to do this. 
+                // Encode the comment so it is safe for xml.  SecurityElement.Escape is the only method I've found to do this.
                 commentString = System.Security.SecurityElement.Escape(commentString);
             }
 
@@ -514,7 +514,7 @@ private static string TruncateAndFormatCommentStringForOutput(string commentStri
         //          return (Point) obj; }
         // }
         // Special cases static vs. non-static, as well as internal vs. internal.
-        // Also note the resource name could contain spaces, etc, while the 
+        // Also note the resource name could contain spaces, etc, while the
         // property name has to be a valid language identifier.
         [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
         private static bool DefineResourceFetchingProperty(String propertyName, String resourceName, ResourceData data, CodeTypeDeclaration srClass, bool internalClass, bool useStatic)
@@ -534,14 +534,14 @@ private static bool DefineResourceFetchingProperty(String propertyName, String r
 
                 // Ensure type is internalally visible.  This is necessary to ensure
                 // users can access classes via a base type.  Imagine a class like
-                // Image or Stream as a internalally available base class, then an 
-                // internal type like MyBitmap or __UnmanagedMemoryStream as an 
-                // internal implementation for that base class.  For internalally 
-                // available strongly typed resource classes, we must return the 
-                // internal type.  For simplicity, we'll do that for internal strongly 
+                // Image or Stream as a internalally available base class, then an
+                // internal type like MyBitmap or __UnmanagedMemoryStream as an
+                // internal implementation for that base class.  For internalally
+                // available strongly typed resource classes, we must return the
+                // internal type.  For simplicity, we'll do that for internal strongly
                 // typed resource classes as well.  Ideally we'd also like to check
                 // for interfaces like IList, but I don't know how to do that without
-                // special casing collection interfaces & ignoring serialization 
+                // special casing collection interfaces & ignoring serialization
                 // interfaces or IDisposable.
                 while (!type.IsPublic)
                 {
@@ -694,7 +694,7 @@ private static String VerifyResourceName(String key, CodeDomProvider provider, b
                 return key;
             }
 
-            // Now try fixing up keywords like "for".  
+            // Now try fixing up keywords like "for".
             key = provider.CreateValidIdentifier(key);
             if (provider.IsValidIdentifier(key))
             {
@@ -728,7 +728,7 @@ private static SortedList<string, ResourceData> VerifyResourceNames(
             {
                 String key = entry.Key;
 
-                // Disallow a property named ResourceManager or Culture - we add 
+                // Disallow a property named ResourceManager or Culture - we add
                 // those.  (Any other properties we add also must be listed here)
                 // Also disallow resource values of type Void.
                 if (String.Equals(key, ResMgrPropertyName) ||
@@ -758,7 +758,7 @@ private static SortedList<string, ResourceData> VerifyResourceNames(
                         continue;
                     }
 
-                    // Now see if we've already mapped another key to the 
+                    // Now see if we've already mapped another key to the
                     // same name.
                     if (reverseFixupTable.TryGetValue(newKey, out string oldDuplicateKey))
                     {
@@ -783,7 +783,7 @@ private static SortedList<string, ResourceData> VerifyResourceNames(
                 else
                 {
                     // There was a case-insensitive conflict between two keys.
-                    // Or possibly one key was fixed up in a way that conflicts 
+                    // Or possibly one key was fixed up in a way that conflicts
                     // with another key (ie, "A B" and "A_B").
                     if (reverseFixupTable.TryGetValue(key, out string fixedUp))
                     {
diff --git a/src/Utilities.UnitTests/MockEngine.cs b/src/Utilities.UnitTests/MockEngine.cs
index e5b5986bee8..8b6c48c541e 100644
--- a/src/Utilities.UnitTests/MockEngine.cs
+++ b/src/Utilities.UnitTests/MockEngine.cs
@@ -14,18 +14,18 @@
 namespace Microsoft.Build.UnitTests
 {
     /***************************************************************************
-     * 
+     *
      * Class:       MockEngine
-     * 
+     *
      * In order to execute tasks, we have to pass in an Engine object, so the
      * task can log events.  It doesn't have to be the real Engine object, just
      * something that implements the IBuildEngine2 interface.  So, we mock up
      * a fake engine object here, so we're able to execute tasks from the unit tests.
-     * 
+     *
      * The unit tests could have instantiated the real Engine object, but then
      * we would have had to take a reference onto the Microsoft.Build.Engine assembly, which
      * is somewhat of a no-no for task assemblies.
-     * 
+     *
      **************************************************************************/
     internal sealed class MockEngine : IBuildEngine3
     {
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index ffd146c0d17..c8ed9e9832c 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -299,8 +299,8 @@ public void CreateEmptyNamedMetadata()
             });
         }
         /// <summary>
-        /// Create a TaskItem with a null metadata value -- this is allowed, but 
-        /// internally converted to the empty string. 
+        /// Create a TaskItem with a null metadata value -- this is allowed, but
+        /// internally converted to the empty string.
         /// </summary>
         [Fact]
         public void CreateTaskItemWithNullMetadata()
@@ -313,8 +313,8 @@ public void CreateTaskItemWithNullMetadata()
         }
 
         /// <summary>
-        /// Set metadata value to null value -- this is allowed, but 
-        /// internally converted to the empty string. 
+        /// Set metadata value to null value -- this is allowed, but
+        /// internally converted to the empty string.
         /// </summary>
         [Fact]
         public void SetNullMetadataValue()
@@ -345,7 +345,7 @@ public void ImplementsIMetadataContainer()
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// Test that task items can be successfully constructed based on a task item from another appdomain.  
+        /// Test that task items can be successfully constructed based on a task item from another appdomain.
         /// </summary>
         [Fact]
         public void RemoteTaskItem()
@@ -407,7 +407,7 @@ public void RemoteTaskItem()
         }
 
         /// <summary>
-        /// Miniature class to be remoted to another appdomain that just creates some TaskItems and makes them available for returning. 
+        /// Miniature class to be remoted to another appdomain that just creates some TaskItems and makes them available for returning.
         /// </summary>
         private sealed class TaskItemCreator
 #if FEATURE_APPDOMAIN
@@ -424,7 +424,7 @@ public ITaskItem[] CreatedTaskItems
             }
 
             /// <summary>
-            /// Creates task items 
+            /// Creates task items
             /// </summary>
             public void Run(string[] includes, IDictionary<string, string> metadataToAdd)
             {
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 308a4915321..1c359273b56 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -853,7 +853,7 @@ public void SetsTerminationTimeoutCorrectly(int timeout, bool isInvalidValid)
             task.ValidateParameters().ShouldBe(!isInvalidValid);
             task.TerminationTimeout.ShouldBe(timeout);
         }
-		
+
 		/// <summary>
         /// Verifies that a ToolTask instance can return correct results when executed multiple times with timeout.
         /// </summary>
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index 22a0dae0bf4..d9db9e78b7b 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -79,7 +79,7 @@ public FileTrackerTests()
 
         public void Dispose()
         {
-            // Reset PATH to its original value. 
+            // Reset PATH to its original value.
             if (s_oldPath != null)
             {
                 Environment.SetEnvironmentVariable("PATH", s_oldPath);
@@ -123,8 +123,8 @@ public void FileTrackerNoUIDll()
                     Directory.Delete(testDirectory, true);
                 }
 
-                // create an empty directory and copy Tracker.exe -- BUT NOT TrackerUI.dll -- to 
-                // that directory. 
+                // create an empty directory and copy Tracker.exe -- BUT NOT TrackerUI.dll -- to
+                // that directory.
                 Directory.CreateDirectory(testDirectory);
                 File.Copy(s_defaultTrackerPath, testTrackerPath);
 
@@ -132,14 +132,14 @@ public void FileTrackerNoUIDll()
 
                 Assert.Equal(9, exit);
                 // It's OK to look for the English message since that's all we're capable of printing when we can't find
-                // our resource dll. 
+                // our resource dll.
                 Assert.Contains("FileTracker : ERROR : Could not load UI satellite dll 'TrackerUI.dll'", log);
             }
             finally
             {
-                // Doesn't delete the directory itself, but deletes its contents.  If you try to delete the directory, 
-                // even after calling this method, it sometimes throws IO exceptions due to not recognizing that the 
-                // contents have been deleted yet. 
+                // Doesn't delete the directory itself, but deletes its contents.  If you try to delete the directory,
+                // even after calling this method, it sometimes throws IO exceptions due to not recognizing that the
+                // contents have been deleted yet.
                 ObjectModelHelpers.DeleteDirectory(testDirectory);
             }
         }
@@ -303,11 +303,11 @@ class Program
         static void Main(string[] args)
         {
             File.GetAttributes(Directory.GetCurrentDirectory());
-            GetFileAttributes(Directory.GetCurrentDirectory()); 
+            GetFileAttributes(Directory.GetCurrentDirectory());
         }
 
         [DllImport(""Kernel32.dll"", SetLastError = true, CharSet = CharSet.Unicode)]
-        private extern static uint GetFileAttributes(string FileName); 
+        private extern static uint GetFileAttributes(string FileName);
     }
 }";
 
@@ -344,7 +344,7 @@ static void Main(string[] args)
                 Console.WriteLine("");
                 Assert.Equal(0, exit);
 
-                // With '/a', should *not* track GetFileAttributes on directories, even though we do so on files. 
+                // With '/a', should *not* track GetFileAttributes on directories, even though we do so on files.
                 FileTrackerTestHelper.AssertDidntFindStringInTLog("GetFileAttributesExW:" + FileUtilities.EnsureTrailingSlash(Directory.GetCurrentDirectory()).ToUpperInvariant(), "directoryattributes.read.1.tlog");
                 FileTrackerTestHelper.AssertDidntFindStringInTLog("GetFileAttributesW:" + FileUtilities.EnsureTrailingSlash(Directory.GetCurrentDirectory()).ToUpperInvariant(), "directoryattributes.read.1.tlog");
 
@@ -382,7 +382,7 @@ static void Main(string[] args)
                 Console.WriteLine("");
                 Assert.Equal(0, exit);
 
-                // With '/a', should *not* track GetFileAttributes on directories, even though we do so on files. 
+                // With '/a', should *not* track GetFileAttributes on directories, even though we do so on files.
                 FileTrackerTestHelper.AssertDidntFindStringInTLog(FileUtilities.EnsureTrailingSlash(Directory.GetCurrentDirectory()).ToUpperInvariant(), "directoryattributes.read.1.tlog");
 
                 File.Delete("directoryattributes.read.1.tlog");
@@ -470,12 +470,12 @@ public void FileTrackerDoNotRecordWriteAsRead()
                 writeFile = Path.Combine(testDirectory, "test.out");
                 string codeFile = Path.Combine(testDirectory, "code.cs");
                 string codeContent = @"
-using System.IO; 
+using System.IO;
 using System.Runtime.InteropServices;
-class X 
-{ 
-    static void Main() 
-    { 
+class X
+{
+    static void Main()
+    {
         FileStream f = File.Open(@""" + writeFile + @""", FileMode.CreateNew, FileAccess.ReadWrite, FileShare.ReadWrite);
         f.WriteByte(8);
         f.Close();
@@ -501,9 +501,9 @@ static void Main()
             }
             finally
             {
-                // Doesn't delete the directory itself, but deletes its contents.  If you try to delete the directory, 
-                // even after calling this method, it sometimes throws IO exceptions due to not recognizing that the 
-                // contents have been deleted yet. 
+                // Doesn't delete the directory itself, but deletes its contents.  If you try to delete the directory,
+                // even after calling this method, it sometimes throws IO exceptions due to not recognizing that the
+                // contents have been deleted yet.
                 ObjectModelHelpers.DeleteDirectory(testDirectory);
             }
 
@@ -1381,7 +1381,7 @@ public void InProcTrackingStartProcessFindStrIn()
             }
             Console.WriteLine("");
             Assert.Equal(0, exit);
-            // This line is the problem.  It seems to have been reliable in MSTest 
+            // This line is the problem.  It seems to have been reliable in MSTest
             // but in xunit when run with other tests (NOT by itself), filetracker
             // puts a PID in the path, so this tries to open the wrong file and throws.
             FileTrackerTestHelper.AssertFoundStringInTLog(Path.GetFullPath("test.in").ToUpperInvariant(), "InProcTrackingStartProcessFindStrIn-findstr.read.1.tlog");
@@ -2239,7 +2239,7 @@ public void LaunchMultipleOfSameTool_ToolLaunchesOthers()
 
                 Directory.CreateDirectory(testDir);
 
-                // File to run findstr against. 
+                // File to run findstr against.
                 string tempFilePath = Path.Combine(testDir, "bar.txt");
                 File.WriteAllText(tempFilePath, "");
 
@@ -2430,7 +2430,7 @@ private static void LaunchDuplicateToolsAndVerifyTlogExistsForEach(string tlogPa
 
                 // make sure the disk write gets time for NTFS to recognize its existence.  Estimate time needed to sleep based
                 // roughly on the number of tlogs that we're looking for (presumably roughly proportional to the number of tlogs
-                // being written. 
+                // being written.
                 Thread.Sleep(Math.Max(200, 250 * tlogCount));
 
                 // Item1: The pattern the tlog name should follow
diff --git a/src/Utilities.UnitTests/TrackedDependencies/MockEngine.cs b/src/Utilities.UnitTests/TrackedDependencies/MockEngine.cs
index ffc7f3d824a..43618e32960 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/MockEngine.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/MockEngine.cs
@@ -11,18 +11,18 @@
 namespace Microsoft.Build.UnitTests.TrackedDependencies
 {
     /***************************************************************************
-     * 
+     *
      * Class:       MockEngine
-     * 
+     *
      * In order to execute tasks, we have to pass in an Engine object, so the
      * task can log events.  It doesn't have to be the real Engine object, just
      * something that implements the IBuildEngine2 interface.  So, we mock up
      * a fake engine object here, so we're able to execute tasks from the unit tests.
-     * 
+     *
      * The unit tests could have instantiated the real Engine object, but then
      * we would have had to take a reference onto the Microsoft.Build.Engine assembly, which
      * is somewhat of a no-no for task assemblies.
-     * 
+     *
      **************************************************************************/
     internal sealed class MockEngine : IBuildEngine2
     {
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index 913ccfc7098..0ba128f9f33 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -75,9 +75,9 @@ public TrackedDependenciesTests()
         }
 
         /// <summary>
-        /// Tests DependencyTableCache.FormatNormalizedTlogRootingMarker, which should do effectively the same 
+        /// Tests DependencyTableCache.FormatNormalizedTlogRootingMarker, which should do effectively the same
         /// thing as FileTracker.FormatRootingMarker, except with some extra initial normalization to get rid of
-        /// pesky PIDs and TIDs in the tlog names. 
+        /// pesky PIDs and TIDs in the tlog names.
         /// </summary>
         [Fact]
         public void FormatNormalizedRootingMarkerTests()
@@ -2076,7 +2076,7 @@ public void OutputMultipleCanonicalCLSubrootMisMatch()
                                     new TaskItem(Path.GetFullPath(Path.Combine("TestFiles", "eight.cpp"))),
                                     new TaskItem(Path.GetFullPath(Path.Combine("TestFiles", "three.cpp"))) };
 
-            // Do note sources2Match and source2 is missing three.cpp.  It is to test if the RootContainsAllSubRootComponents can handle the case. 
+            // Do note sources2Match and source2 is missing three.cpp.  It is to test if the RootContainsAllSubRootComponents can handle the case.
 
             // Prepare files
             Thread.Sleep(_sleepTimeMilliseconds); // need to wait since the timestamp check needs some time to register
@@ -3431,7 +3431,7 @@ public void FlatTrackingExcludeDirectories()
         {
             Console.WriteLine("Test: FlatTrackingExcludeDirectories");
 
-            // Prepare files 
+            // Prepare files
             if (!Directory.Exists(Path.Combine("TestFiles", "ToBeExcluded")))
             {
                 Directory.CreateDirectory(Path.Combine("TestFiles", "ToBeExcluded"));
diff --git a/src/Utilities/ApiContract.cs b/src/Utilities/ApiContract.cs
index 15213d41e2f..f107dfe5d6a 100644
--- a/src/Utilities/ApiContract.cs
+++ b/src/Utilities/ApiContract.cs
@@ -34,14 +34,14 @@ private ApiContract(string name, string version)
         }
 
         /// <summary>
-        /// Returns true if this element is a "ContainedApiContracts" element. 
+        /// Returns true if this element is a "ContainedApiContracts" element.
         /// </summary>
         internal static bool IsContainedApiContractsElement(string elementName) => string.Equals(elementName, Elements.ContainedApiContracts, StringComparison.Ordinal);
 
         internal static bool IsVersionedContentElement(string elementName) => string.Equals(elementName, Elements.VersionedContent, StringComparison.Ordinal);
 
         /// <summary>
-        /// Given an XML element containing API contracts, read out all contracts within that element. 
+        /// Given an XML element containing API contracts, read out all contracts within that element.
         /// </summary>
         internal static void ReadContractsElement(XmlElement element, ICollection<ApiContract> apiContracts)
         {
diff --git a/src/Utilities/CommandLineBuilder.cs b/src/Utilities/CommandLineBuilder.cs
index 7db0be0b667..b777f8b7022 100644
--- a/src/Utilities/CommandLineBuilder.cs
+++ b/src/Utilities/CommandLineBuilder.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Utilities
 {
     /// <summary>
     /// (1) Make sure values containing hyphens are quoted (RC at least requires this)
-    /// (2) Escape any embedded quotes. 
+    /// (2) Escape any embedded quotes.
     ///     -- Literal double quotes should be written in the form \" not ""
     ///     -- Backslashes falling just before doublequotes must be doubled.
     ///     -- Literal double quotes can only occur in pairs (you cannot pass a single literal double quote)
@@ -23,38 +23,38 @@ namespace Microsoft.Build.Utilities
     /// 	    in switches like /Dname=value.
     /// </summary>
     /// <remarks>
-    /// 
+    ///
     /// Below are some quoting experiments, using the /D switch with the CL and RC preprocessor.
     /// The /D switch is a little more tricky than most switches, because it has a name=value pair.
     /// The table below contains what the preprocessor actually embeds when passed the switch in the
     /// first column:
-    /// 
+    ///
     ///                      CL via cmd line         CL via response file       RC
-    ///     /DFOO="A"                A                   A   
+    ///     /DFOO="A"                A                   A
     ///     /D"FOO="A""              A                   A                       A
-    ///     /DFOO=A                  A                   A   
-    ///     /D"FOO=A"                A                   A   
+    ///     /DFOO=A                  A                   A
+    ///     /D"FOO=A"                A                   A
     ///     /DFOO=""A""              A                   A                       A
-    ///         
+    ///
     ///     /DFOO=\"A\"             "A"                                         "A"
     ///     /DFOO="""A"""           "A"                broken                   "A"
     ///     /D"FOO=\"A\""           "A"                                         "A"
     ///     /D"FOO=""A"""           "A"                                         "A"
-    ///         
-    ///     /DFOO="A B"             A B                 A B 
-    ///     /D"FOO=A B"             A B                 A B 
-    ///         
-    ///     /D"FOO="A B""          broken      
-    ///     /DFOO=\"A B\"          broken      
+    ///
+    ///     /DFOO="A B"             A B                 A B
+    ///     /D"FOO=A B"             A B                 A B
+    ///
+    ///     /D"FOO="A B""          broken
+    ///     /DFOO=\"A B\"          broken
     ///     /D"FOO=\"A B\""        "A B"               "A B"                   "A B"
     ///     /D"FOO=""A B"""        "A B"               broken                  broken
     ///
-    /// From my experiments (with CL and RC only) it seems that 
+    /// From my experiments (with CL and RC only) it seems that
     ///    -- Literal double quotes are most reliably written in the form \" not ""
     ///    -- Backslashes falling just before doublequotes must be doubled.
     ///    -- Values containing literal double quotes must be quoted.
     ///    -- Literal double quotes can only occur in pairs (you cannot pass a single literal double quote)
-    ///    -- For /Dname=value style switches, functional double quotes (for example to handle spaces) are best put around both 
+    ///    -- For /Dname=value style switches, functional double quotes (for example to handle spaces) are best put around both
     ///           name and value (in other words, these kinds of switches don't need special treatment for their '=' signs).
     ///    -- Values containing hyphens should be quoted; RC requires this, and CL does not mind.
     /// </remarks>
@@ -136,10 +136,10 @@ public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparat
         private readonly bool _useNewLineSeparator;
 
         /// <summary>
-        /// Instead of defining which characters must be quoted, define 
+        /// Instead of defining which characters must be quoted, define
         /// which characters we know its safe to not quote. This way leads
-        /// to more false-positives (which still work, but don't look as 
-        /// nice coming out of the logger), but is less likely to leave a 
+        /// to more false-positives (which still work, but don't look as
+        /// nice coming out of the logger), but is less likely to leave a
         /// security hole.
         /// </summary>
         private Regex _allowedUnquoted;
@@ -311,7 +311,7 @@ public void AppendTextUnquoted(string textToAppend)
         }
 
         /// <summary>
-        /// Appends a file name. Quotes are added if they are needed. 
+        /// Appends a file name. Quotes are added if they are needed.
         /// If the first character of the file name is a dash, ".\" is prepended to avoid confusing the file name with a switch
         /// This method does not append a space to the command line before executing.
         /// </summary>
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 715cbe2d753..2fcc5d9cf02 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -12,44 +12,44 @@
 namespace Microsoft.Build.Utilities
 {
     /// <summary>
-    /// This is a multiplexing logger. The purpose of this logger is to allow the registration and deregistration of 
+    /// This is a multiplexing logger. The purpose of this logger is to allow the registration and deregistration of
     /// multiple loggers during the build. This is to support the VS IDE scenario where loggers are registered and unregistered
     /// for each project system's build request. This means one physical build may have multiple logical builds
-    /// each with their own set of loggers. 
-    /// 
-    /// The Mux logger will register itself with the build manager as a regular central /l style logger. 
+    /// each with their own set of loggers.
+    ///
+    /// The Mux logger will register itself with the build manager as a regular central /l style logger.
     /// It will be responsible for receiving messages from the build manager and route them to the correct
     /// logger based on the logical build the message came from.
-    /// 
+    ///
     /// Requirements:
     ///     1) Multiplexing logger will be registered at the beginning of the build manager's Begin build
     ///         Any loggers registered before the build manager actually started building will get the build started event at the same time as the MUX logger
-    ///         Any loggers registered after the build manager starts the build will get a synthesised build started event. The event cannot be cached because the 
+    ///         Any loggers registered after the build manager starts the build will get a synthesised build started event. The event cannot be cached because the
     ///         timestamp of the build started event is determined when the event is created, caching the event would give incorrect build times in the loggers registered to the MUX.
-    ///         
+    ///
     ///     2) The MUX logger will be initialized by the build manager.
     ///         The mux will listen to all events on the event source from the build manager and will route events correctly to the registered loggers.
-    ///     
+    ///
     ///     3) The MUX logger will be shutdown when the build is finished in end build . At this time it will un-register any loggers attached to it.
-    ///     
+    ///
     ///     4) The MUX logger will log the build finished event when the project finished event for the first project started event is seen for each logger.
-    ///    
+    ///
     /// Registering Loggers:
-    /// 
+    ///
     /// The multiplexing logger will function in the following way:
     ///     A logger will be passed to the MUX Register logger method with a submission ID which will be used to route a the message to the correct logger.
     ///     A new event source will be created so that the logger passed in can be registered to that event source
     ///     If the build started event has already been logged the MUX logger will create a new BuildStartedEvent and send that to the event source.
-    ///     
+    ///
     /// UnregisterLoggers:
     ///     When a build submission is completed the UnregisterLoggers method will be called with the submission ID.
     ///     At this point we will look up the success state of the project finished event for the submission ID and log a build finished event to the logger.
     ///     The event source will be cleaned up.  This may be interesting because the unregister will come from a thread other than what is doing the logging.
     ///     This may create a Synchronization issue, if unregister is called while events are being logged.
     /// </summary>
-    // 
+    //
     // UNDONE: If we can use ErrorUtilities, replace all InvalidOperation and Argument exceptions with the appropriate calls.
-    // 
+    //
     public class MuxLogger : INodeLogger
     {
         /// <summary>
@@ -380,8 +380,8 @@ private class SubmissionRecord :
             private bool _shutdown;
             #endregion
 
-            // Keep instance of event handlers so they can be unregistered at the end of the submissionID. 
-            // If we wait for the entire build to finish we will leak the handlers until we unregister ALL of the handlers from the 
+            // Keep instance of event handlers so they can be unregistered at the end of the submissionID.
+            // If we wait for the entire build to finish we will leak the handlers until we unregister ALL of the handlers from the
             // event source on the build manager.
             #region RegisteredHandlers
             /// <summary>
@@ -536,8 +536,8 @@ internal SubmissionRecord(int submissionId, IEventSource buildEventSource, Build
             public event CustomBuildEventHandler CustomEventRaised;
 
             /// <summary>
-            /// this event is raised to log build status events, such as 
-            /// build/project/target/task started/stopped 
+            /// this event is raised to log build status events, such as
+            /// build/project/target/task started/stopped
             /// </summary>
             public event BuildStatusEventHandler StatusEventRaised;
 
@@ -854,7 +854,7 @@ private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs bui
 
                     if (_firstProjectStartedEventContext == null)
                     {
-                        // Capture the build event context for the first project started event so we can make sure we know when to fire the 
+                        // Capture the build event context for the first project started event so we can make sure we know when to fire the
                         // build finished event (in the case of loggers on the mux logger this is on the last project finished event for the submission
                         _firstProjectStartedEventContext = buildEvent.BuildEventContext;
 
@@ -1250,7 +1250,7 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                     }
 
                     // If this project finished event matches our first project started event, then send build finished.
-                    // Because of the way the event source works, we actually have to process this here rather than in project finished because if the 
+                    // Because of the way the event source works, we actually have to process this here rather than in project finished because if the
                     // logger is registered without a ProjectFinished handler, but does have an Any handler (as the mock logger does) then we would end up
                     // sending the BuildFinished event before the ProjectFinished event got processed in the Any handler.
                     ProjectFinishedEventArgs projectFinishedEvent = buildEvent as ProjectFinishedEventArgs;
diff --git a/src/Utilities/PlatformManifest.cs b/src/Utilities/PlatformManifest.cs
index fef6aa41a1b..653fc4c18d8 100644
--- a/src/Utilities/PlatformManifest.cs
+++ b/src/Utilities/PlatformManifest.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.Utilities
     internal class PlatformManifest
     {
         /// <summary>
-        /// Location of Platform.xml 
+        /// Location of Platform.xml
         /// </summary>
         private readonly string _pathToManifest;
 
@@ -49,7 +49,7 @@ public PlatformManifest(string pathToManifest)
         public string PlatformVersion { get; private set; }
 
         /// <summary>
-        /// The platforms that this platform depends on.  
+        /// The platforms that this platform depends on.
         /// Item1: Platform name
         /// Item2: Platform version
         /// </summary>
@@ -80,7 +80,7 @@ public PlatformManifest(string pathToManifest)
         private void LoadManifestFile()
         {
             /*
-               Platform.xml format: 
+               Platform.xml format:
 
                <ApplicationPlatform name="UAP" friendlyName="Universal Application Platform" version="1.0.0.0">
                   <DependentPlatform name="UAP" version="1.0.0.0" />
@@ -170,7 +170,7 @@ internal struct DependentPlatform
             internal readonly string Name;
 
             /// <summary>
-            /// Version of the platform on which this platform depends 
+            /// Version of the platform on which this platform depends
             /// </summary>
             internal readonly string Version;
 
@@ -190,7 +190,7 @@ internal DependentPlatform(string name, string version)
         private static class Elements
         {
             /// <summary>
-            /// Root element 
+            /// Root element
             /// </summary>
             public const string ApplicationPlatform = "ApplicationPlatform";
 
diff --git a/src/Utilities/SDKManifest.cs b/src/Utilities/SDKManifest.cs
index e4403e10a83..d5a4322a928 100644
--- a/src/Utilities/SDKManifest.cs
+++ b/src/Utilities/SDKManifest.cs
@@ -257,7 +257,7 @@ private void LoadManifestFile()
                     TargetPlatform="UAP"
                     TargetPlatformMinVersion="1.0.0.0"
                     TargetPlatformVersion="1.0.0.0"
-                    SDKType = "Platform" | "Framework" | "External" 
+                    SDKType = "Platform" | "Framework" | "External"
                     DisplayName = ""My SDK""
                     ProductFamilyName = ""UnitTest SDKs""
                     FrameworkIdentity-Debug = ""Name=MySDK.10.Debug, MinVersion=1.0.0.0""
@@ -273,7 +273,7 @@ private void LoadManifestFile()
                     AppX-Debug-ARM = "".\AppX\Debug\ARM\Microsoft.MySDK.ARM.Debug.1.0.appx""
                     AppX-Retail-x86 = "".\AppX\Retail\x86\Microsoft.MySDK.x86.1.0.appx""
                     AppX-Retail-x64 = "".\AppX\Retail\x64\Microsoft.MySDK.x64.1.0.appx""
-                    AppX-Retail-ARM = "".\AppX\Retail\ARM\Microsoft.MySDK.ARM.1.0.appx"" 
+                    AppX-Retail-ARM = "".\AppX\Retail\ARM\Microsoft.MySDK.ARM.1.0.appx""
                     CopyRedistToSubDirectory = "".""
                     DependsOn = ""SDKB, version=2.0""
                     MoreInfo = ""http://msdn.microsoft.com/MySDK""
@@ -292,7 +292,7 @@ private void LoadManifestFile()
                         <ToolboxItems VSCategory = ""Toolbox.Default"" />
                     </File>
                 </FileList>
-               
+
                Platform SDK Manifest:
                 <FileList
                     DisplayName = ""Windows""
@@ -606,7 +606,7 @@ public static class Attributes
         private static class Elements
         {
             /// <summary>
-            /// Root element 
+            /// Root element
             /// </summary>
             public const string FileList = "FileList";
         }
diff --git a/src/Utilities/TargetPlatformSDK.cs b/src/Utilities/TargetPlatformSDK.cs
index 9db364374cf..be16c5f63a4 100644
--- a/src/Utilities/TargetPlatformSDK.cs
+++ b/src/Utilities/TargetPlatformSDK.cs
@@ -109,23 +109,23 @@ public string Path
         }
 
         /// <summary>
-        /// The SDK's display name, or null if one is not defined. 
+        /// The SDK's display name, or null if one is not defined.
         /// </summary>
         public string DisplayName => Manifest?.DisplayName;
 
         /// <summary>
-        /// Extension sdks within this platform, 
+        /// Extension sdks within this platform,
         /// </summary>
         internal Dictionary<string, string> ExtensionSDKs { get; }
 
         /// <summary>
-        /// Set of platforms supported by this SDK. 
+        /// Set of platforms supported by this SDK.
         /// </summary>
         internal Dictionary<string, string> Platforms { get; }
 
         /// <summary>
         /// Reference to manifest object
-        /// Makes it is instantiated only once 
+        /// Makes it is instantiated only once
         /// </summary>
         private SDKManifest Manifest
         {
@@ -178,7 +178,7 @@ public bool Equals(TargetPlatformSDK other)
         }
 
         /// <summary>
-        /// Returns true if this SDK supports the given platform, or false otherwise. 
+        /// Returns true if this SDK supports the given platform, or false otherwise.
         /// </summary>
         public bool ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion)
         {
@@ -187,7 +187,7 @@ public bool ContainsPlatform(string targetPlatformIdentifier, string targetPlatf
         }
 
         /// <summary>
-        /// Given an identifier and version, construct a string to use as a key for that combination. 
+        /// Given an identifier and version, construct a string to use as a key for that combination.
         /// </summary>
         internal static string GetSdkKey(string sdkIdentifier, string sdkVersion) => string.Format(CultureInfo.InvariantCulture, "{0}, Version={1}", sdkIdentifier, sdkVersion);
     }
diff --git a/src/Utilities/Task.cs b/src/Utilities/Task.cs
index 1793515ef44..2c16effe9f1 100644
--- a/src/Utilities/Task.cs
+++ b/src/Utilities/Task.cs
@@ -58,7 +58,7 @@ protected Task(ResourceManager taskResources, string helpKeywordPrefix)
         /// <value>The build engine interface available to tasks.</value>
         public IBuildEngine BuildEngine { get; set; }
 
-        // The casts below are always possible because this class is built against the 
+        // The casts below are always possible because this class is built against the
         // Orcas Framework assembly or later, so the version of MSBuild that does not
         // know about IBuildEngine2 will never load it.
         // No setters needed; the Engine always sets through the BuildEngine setter
@@ -115,7 +115,7 @@ protected Task(ResourceManager taskResources, string helpKeywordPrefix)
         /// <summary>
         /// Gets an instance of a TaskLoggingHelper class containing task logging methods.
         /// The taskLoggingHelper is a MarshallByRef object which needs to have MarkAsInactive called
-        /// if the parent task is making the appdomain and marshaling this object into it. If the appdomain is not unloaded at the end of 
+        /// if the parent task is making the appdomain and marshaling this object into it. If the appdomain is not unloaded at the end of
         /// the task execution and the MarkAsInactive method is not called this will result in a leak of the task instances in the appdomain the task was created within.
         /// </summary>
         /// <value>The logging helper object.</value>
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 858b35eb892..f4e818e278e 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -21,9 +21,9 @@ namespace Microsoft.Build.Utilities
     /// This class represents a single item of the project, as it is passed into a task. TaskItems do not exactly correspond to
     /// item elements in project files, because then tasks would have access to data that wasn't explicitly passed into the task
     /// via the project file. It's not a security issue, but more just an issue with project file clarity and transparency.
-    /// 
+    ///
     /// Note: This class has to be sealed.  It has to be sealed because the engine instantiates it's own copy of this type and
-    /// thus if someone were to extend it, they would not get the desired behavior from the engine.  
+    /// thus if someone were to extend it, they would not get the desired behavior from the engine.
     /// </summary>
     /// <comment>
     /// Surprisingly few of these Utilities TaskItems are created: typically several orders of magnitude fewer than the number of engine TaskItems.
@@ -37,7 +37,7 @@ public sealed class TaskItem :
     {
         #region Member Data
 
-        // This is the final evaluated item specification.  Stored in escaped form. 
+        // This is the final evaluated item specification.  Stored in escaped form.
         private string _itemSpec;
 
         // These are the user-defined metadata on the item, specified in the
@@ -50,8 +50,8 @@ public sealed class TaskItem :
         private string _fullPath;
 
         /// <summary>
-        /// May be defined if we're copying this item from a pre-existing one.  Otherwise, 
-        /// we simply don't know enough to set it properly, so it will stay null. 
+        /// May be defined if we're copying this item from a pre-existing one.  Otherwise,
+        /// we simply don't know enough to set it properly, so it will stay null.
         /// </summary>
         private readonly string _definingProject;
 
@@ -144,9 +144,9 @@ public TaskItem(
         /// Gets or sets the item-spec.
         /// </summary>
         /// <comments>
-        /// This one is a bit tricky.  Orcas assumed that the value being set was escaped, but 
+        /// This one is a bit tricky.  Orcas assumed that the value being set was escaped, but
         /// that the value being returned was unescaped.  Maintain that behaviour here.  To get
-        /// the escaped value, use ITaskItem2.EvaluatedIncludeEscaped. 
+        /// the escaped value, use ITaskItem2.EvaluatedIncludeEscaped.
         /// </comments>
         /// <value>The item-spec string.</value>
         public string ItemSpec
@@ -212,9 +212,9 @@ public ICollection MetadataNames
 
         /// <summary>
         /// Gets the metadata dictionary
-        /// Property is required so that we can access the metadata dictionary in an item from 
-        /// another appdomain, as the CLR has implemented remoting policies that disallow accessing 
-        /// private fields in remoted items. 
+        /// Property is required so that we can access the metadata dictionary in an item from
+        /// another appdomain, as the CLR has implemented remoting policies that disallow accessing
+        /// private fields in remoted items.
         /// </summary>
         private CopyOnWriteDictionary<string> Metadata
         {
@@ -249,7 +249,7 @@ public void RemoveMetadata(string metadataName)
         /// Sets one of the arbitrary metadata on the item.
         /// </summary>
         /// <comments>
-        /// Assumes that the value being passed in is in its escaped form. 
+        /// Assumes that the value being passed in is in its escaped form.
         /// </comments>
         /// <param name="metadataName">Name of metadata to set or change.</param>
         /// <param name="metadataValue">Value of metadata.</param>
@@ -274,7 +274,7 @@ public void SetMetadata(
         /// If not found, returns empty string.
         /// </summary>
         /// <comments>
-        /// Returns the unescaped value of the metadata requested. 
+        /// Returns the unescaped value of the metadata requested.
         /// </comments>
         /// <param name="metadataName">The name of the metadata to retrieve.</param>
         /// <returns>The metadata value.</returns>
@@ -370,8 +370,8 @@ public void CopyMetadataTo(ITaskItem destinationItem)
         /// 2) writing to this dictionary should not be reflected in the underlying item.
         /// </remarks>
         /// <comments>
-        /// Returns an UNESCAPED version of the custom metadata. For the escaped version (which 
-        /// is how it is stored internally), call ITaskItem2.CloneCustomMetadataEscaped. 
+        /// Returns an UNESCAPED version of the custom metadata. For the escaped version (which
+        /// is how it is stored internally), call ITaskItem2.CloneCustomMetadataEscaped.
         /// </comments>
         public IDictionary CloneCustomMetadata()
         {
@@ -449,13 +449,13 @@ string ITaskItem2.GetMetadataValueEscaped(string metadataName)
         /// Sets the escaped value of the metadata with the specified name.
         /// </summary>
         /// <comments>
-        /// Assumes the value is passed in unescaped. 
+        /// Assumes the value is passed in unescaped.
         /// </comments>
         void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) => SetMetadata(metadataName, EscapingUtilities.Escape(metadataValue));
 
         /// <summary>
         /// ITaskItem2 implementation which returns a clone of the metadata on this object.
-        /// Values returned are in their original escaped form. 
+        /// Values returned are in their original escaped form.
         /// </summary>
         /// <returns>The cloned metadata.</returns>
         IDictionary ITaskItem2.CloneCustomMetadataEscaped() => _metadata == null
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index e419870cbe7..61d80f07220 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -1025,7 +1025,7 @@ private static string[] GetLegacyTargetPlatformReferences(string targetPlatformI
 
             try
             {
-                // TODO: Add caching so that we only have to read all this stuff in once. 
+                // TODO: Add caching so that we only have to read all this stuff in once.
                 string sdkRoot = GetPlatformSDKLocation(targetPlatformIdentifier, targetPlatformVersion, diskRoots, registryRoot);
                 string winmdLocation = null;
 
@@ -1839,7 +1839,7 @@ public static string GetPathToStandardLibraries(string targetFrameworkIdentifier
                     return FileUtilities.EnsureNoTrailingSlash(legacyMsCorlib20Path);
                 }
 
-                // If for some reason the 2.0 framework is not installed in its default location then maybe someone is using the ".net 4.0" reference assembly 
+                // If for some reason the 2.0 framework is not installed in its default location then maybe someone is using the ".net 4.0" reference assembly
                 // location, if so then we can just use what ever version they passed in because it should be MSIL now and not bit specific.
             }
 
@@ -2236,7 +2236,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
                 if (string.IsNullOrEmpty(frameworkName.Profile)) // profiles are always in new locations
                 {
                     // If the identifier is ".NET Framework" and the version is a well know legacy version. Manually generate the list of reference assembly paths
-                    // based on the known chaining order. Pass null in for the two delegates so we call the static methods rather than require the creation and calling 
+                    // based on the known chaining order. Pass null in for the two delegates so we call the static methods rather than require the creation and calling
                     // of two delegates
                     dotNetFrameworkReferenceAssemblies = HandleLegacyDotNetFrameworkReferenceAssemblyPaths(
                         null,
@@ -2292,7 +2292,7 @@ public static string GetDisplayNameForTargetFrameworkDirectory(string targetFram
                 }
             }
 
-            // Still don't have one. 
+            // Still don't have one.
             // Probably it's 3.5 or earlier: make something reasonable.
             // VS uses the same algorithm to find something to display
             StringBuilder displayNameBuilder = new StringBuilder();
@@ -2545,7 +2545,7 @@ internal static void GatherExtensionSDKs(DirectoryInfo extensionSdksDirectory, T
                     ErrorUtilities.DebugTraceMessage("GatherExtensionSDKs", "Parsed sdk version folder '{0}' under '{1}'", sdkVersionDirectory.Name, sdkVersionDirectory.FullName);
                     if (Version.TryParse(sdkVersionDirectory.Name, out Version _))
                     {
-                        // Create SDK name based on the folder structure. We could open the manifest here and read the display name, but that would 
+                        // Create SDK name based on the folder structure. We could open the manifest here and read the display name, but that would
                         // add complexity and since things are supposed to be in a certain structure I don't think that is needed at this point.
                         string SDKKey = TargetPlatformSDK.GetSdkKey(sdkNameFolders.Name, sdkVersionDirectory.Name);
 
@@ -2644,7 +2644,7 @@ internal static void GatherSDKListFromDirectory(List<string> diskroots, Dictiona
                                 targetPlatformSDK.Path = platformSDKDirectory;
                             }
 
-                            // Gather the set of platforms supported by this SDK if it's a valid one. 
+                            // Gather the set of platforms supported by this SDK if it's a valid one.
                             if (!string.IsNullOrEmpty(targetPlatformSDK.Path))
                             {
                                 GatherPlatformsForSdk(targetPlatformSDK);
@@ -2686,7 +2686,7 @@ internal static void GatherSDKsFromRegistryImpl(Dictionary<TargetPlatformSDK, Ta
             {
                 ErrorUtilities.DebugTraceMessage("GatherSDKsFromRegistryImpl", "Gathering SDKS from registryRoot '{0}', Hive '{1}', View '{2}'", registryKeyRoot, registryHive, registryView);
 
-                // Attach the target platform to the registry root. This should give us something like 
+                // Attach the target platform to the registry root. This should give us something like
                 // SOFTWARE\MICROSOFT\Microsoft SDKs\Windows
 
                 // Get all of the platform identifiers
@@ -2764,7 +2764,7 @@ internal static void GatherSDKsFromRegistryImpl(Dictionary<TargetPlatformSDK, Ta
                                 targetPlatformSDK.Path = platformSDKDirectory;
                             }
 
-                            // Gather the set of platforms supported by this SDK if it's a valid one. 
+                            // Gather the set of platforms supported by this SDK if it's a valid one.
                             if (!string.IsNullOrEmpty(targetPlatformSDK.Path))
                             {
                                 GatherPlatformsForSdk(targetPlatformSDK);
@@ -2877,7 +2877,7 @@ private static void GatherSDKListFromRegistry(string registryRoot, Dictionary<Ta
             // Under WOW64 the HKEY_CURRENT_USER\SOFTWARE key is shared. This means the values are the same in the 64 bit and 32 bit views. This means we only need to get one view of this key.
             GatherSDKsFromRegistryImpl(platformMonikers, registryRoot, RegistryView.Default, RegistryHive.CurrentUser, getSubkeyNames, getRegistrySubKeyDefaultValue, openBaseKey, fileExists);
 
-            // Since SDKS can contain multiple architecture it makes sense to register both 32 bit and 64 bit in one location, but if for some reason that 
+            // Since SDKS can contain multiple architecture it makes sense to register both 32 bit and 64 bit in one location, but if for some reason that
             // is not possible then we need to look at both hives. Choosing the 32 bit one first because is where we expect to find them usually.
             if (is64bitOS)
             {
@@ -3036,7 +3036,7 @@ private static void GatherPlatformsForSdk(TargetPlatformSDK sdk)
                     DirectoryInfo[] platformIdentifiers = platformsRootInfo.GetDirectories();
                     ErrorUtilities.DebugTraceMessage("GatherPlatformsForSdk", "Found '{0}' platform identifier directories under '{1}'", platformIdentifiers.Length, platformsRoot);
 
-                    // Iterate through all identifiers 
+                    // Iterate through all identifiers
                     foreach (DirectoryInfo platformIdentifier in platformIdentifiers)
                     {
                         DirectoryInfo[] platformVersions = platformIdentifier.GetDirectories();
@@ -3108,7 +3108,7 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
                 }
             }
 
-            // Read in the redist list at the specified path, and return 
+            // Read in the redist list at the specified path, and return
             // the display name and the "include framework" value for chaining.
             // If display name is not available, returns empty string.
             // If include framework is not available, returns null.
@@ -3205,7 +3205,7 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
                 if (!string.IsNullOrEmpty(includeFramework))
                 {
                     // Take the path which should point to something like  c:\ProgramFiles\ReferenceAssemblies\Framework\.NETFramework\v4.1
-                    // We will take the path, to "up" a directory then append the name found in the redist. For example if the redist list had v4.0 
+                    // We will take the path, to "up" a directory then append the name found in the redist. For example if the redist list had v4.0
                     // the path which would be expected would be c:\ProgramFiles\ReferenceAssemblies\Framework\.NETFramework\v4.0
                     pathToReturn = path;
                     pathToReturn = Directory.GetParent(pathToReturn).FullName;
@@ -3407,7 +3407,7 @@ internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture
                         NativeMethodsShared.ProcessorArchitectures.IA64 => ProcessorArchitecture.IA64,
                         NativeMethodsShared.ProcessorArchitectures.ARM64 => ProcessorArchitecture.ARM64,
                         // Error, OK, we're trying to get the 64-bit path on a 32-bit machine.
-                        // That ... doesn't make sense. 
+                        // That ... doesn't make sense.
                         NativeMethodsShared.ProcessorArchitectures.X86 => null,
                         NativeMethodsShared.ProcessorArchitectures.ARM => null,
                         // unknown architecture? return null
@@ -3741,7 +3741,7 @@ private static SharedDotNetFrameworkArchitecture ConvertToSharedDotNetFrameworkA
                     sharedArchitecture = SharedDotNetFrameworkArchitecture.Bitness64;
                     break;
                 default:
-                    // Should never reach here -- If any new values are added to the DotNetFrameworkArchitecture enum, they should be added here as well.  
+                    // Should never reach here -- If any new values are added to the DotNetFrameworkArchitecture enum, they should be added here as well.
                     ErrorUtilities.ThrowInternalErrorUnreachable();
                     break;
             }
@@ -3885,7 +3885,7 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
                 }
             }
 
-            // sort in ascending order of the version numbers, this is important as later when we search for assemblies in other methods 
+            // sort in ascending order of the version numbers, this is important as later when we search for assemblies in other methods
             // we should be looking in ascending order of the framework version folders on disk
             frameworkVersions.Sort(VersionComparer.Instance);
 
@@ -3955,7 +3955,7 @@ private static IList<string> GetFx35AndEarlierVersions(string frameworkReference
 
             if (dotNetFx35Path != null)
             {
-                // .NetFx35 is installed  
+                // .NetFx35 is installed
 
                 // check v20
                 string dotNetFx20Path = GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20);
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index f687076fbfb..c196b0afcc8 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -952,8 +952,8 @@ public void RemoveEntriesForSource(ITaskItem[] source)
         }
 
         /// <summary>
-        /// Remove the entry in the input dependency graph corresponding to the rooting marker 
-        /// passed in. 
+        /// Remove the entry in the input dependency graph corresponding to the rooting marker
+        /// passed in.
         /// </summary>
         /// <param name="rootingMarker">The root to remove</param>
         public void RemoveEntryForSourceRoot(string rootingMarker) => DependencyTable.Remove(rootingMarker);
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index ef1ad5bfa5e..5a94ceeb1ad 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -259,13 +259,13 @@ private void ConstructOutputTable()
 
         /// <summary>
         /// Given a set of sources, removes from the dependency graph any roots that share
-        /// the same outputs as the rooting marker constructed from the given set of sources. 
+        /// the same outputs as the rooting marker constructed from the given set of sources.
         /// </summary>
         /// <comment>
-        /// Used when there's a possibility that more than one set of inputs may produce the 
-        /// same output -- this is a way to invalidate any other roots that produce that same 
-        /// outputs, so that the next time the task is run with that other set of inputs, it 
-        /// won't incorrectly believe that it is up-to-date.  
+        /// Used when there's a possibility that more than one set of inputs may produce the
+        /// same output -- this is a way to invalidate any other roots that produce that same
+        /// outputs, so that the next time the task is run with that other set of inputs, it
+        /// won't incorrectly believe that it is up-to-date.
         /// </comment>
         /// <param name="sources">The set of sources that form the rooting marker whose outputs
         /// should not be shared by any other rooting marker.</param>
@@ -279,15 +279,15 @@ public string[] RemoveRootsWithSharedOutputs(ITaskItem[] sources)
 
             if (DependencyTable.TryGetValue(currentRoot, out Dictionary<string, DateTime> currentOutputs))
             {
-                // This is O(n*m), but in most cases, both n (the number of roots in the file) and m (the number 
-                // of outputs per root) should be fairly small. 
+                // This is O(n*m), but in most cases, both n (the number of roots in the file) and m (the number
+                // of outputs per root) should be fairly small.
                 // UNDONE: Can we make this faster?
                 foreach (KeyValuePair<string, Dictionary<string, DateTime>> root in DependencyTable)
                 {
                     if (!currentRoot.Equals(root.Key, StringComparison.Ordinal))
                     {
-                        // If the current entry contains any of the outputs of the rooting marker we have sources for, 
-                        // then we want to remove it from the dependency table. 
+                        // If the current entry contains any of the outputs of the rooting marker we have sources for,
+                        // then we want to remove it from the dependency table.
                         foreach (string output in currentOutputs.Keys)
                         {
                             if (root.Value.ContainsKey(output))
@@ -299,7 +299,7 @@ public string[] RemoveRootsWithSharedOutputs(ITaskItem[] sources)
                     }
                 }
 
-                // Now actually remove the markers that we intend to remove. 
+                // Now actually remove the markers that we intend to remove.
                 foreach (string removedMarker in removedMarkers)
                 {
                     DependencyTable.Remove(removedMarker);
diff --git a/src/Utilities/TrackedDependencies/DependencyTableCache.cs b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
index f18ba533556..818d9122a1f 100644
--- a/src/Utilities/TrackedDependencies/DependencyTableCache.cs
+++ b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
@@ -79,9 +79,9 @@ internal static DependencyTableCacheEntry GetCachedEntry(string tLogRootingMarke
         }
 
         /// <summary>
-        /// Given a set of TLog names, formats a rooting marker from them, that additionally replaces 
-        /// all PIDs and TIDs with "[ID]" so the cache doesn't get overloaded with entries 
-        /// that should be basically the same but have different PIDs or TIDs in the name. 
+        /// Given a set of TLog names, formats a rooting marker from them, that additionally replaces
+        /// all PIDs and TIDs with "[ID]" so the cache doesn't get overloaded with entries
+        /// that should be basically the same but have different PIDs or TIDs in the name.
         /// </summary>
         /// <param name="tlogFiles">The set of tlogs to format</param>
         /// <returns>The normalized rooting marker based on that set of tlogs</returns>
@@ -101,26 +101,26 @@ internal static string FormatNormalizedTlogRootingMarker(ITaskItem[] tlogFiles)
         }
 
         /// <summary>
-        /// Given a TLog path, replace all PIDs and TIDs with "[ID]" in the filename, where 
+        /// Given a TLog path, replace all PIDs and TIDs with "[ID]" in the filename, where
         /// the typical format of a filename is "tool[.PID][-tool].read/write/command/delete.TID.tlog"
         /// </summary>
         /// <comments>
         /// The algorithm used finds all instances of .\d+. and .\d+- in the filename and translates them
-        /// to .[ID]. and .[ID]- respectively, where "filename" is defined as the part of the path following 
-        /// the final '\' in the path.  
-        /// 
-        /// In the VS 2010 C++ project system, there are artificially constructed tlogs that instead follow the 
-        /// pattern "ProjectName.read/write.1.tlog", which means that one result of this change is that such 
+        /// to .[ID]. and .[ID]- respectively, where "filename" is defined as the part of the path following
+        /// the final '\' in the path.
+        ///
+        /// In the VS 2010 C++ project system, there are artificially constructed tlogs that instead follow the
+        /// pattern "ProjectName.read/write.1.tlog", which means that one result of this change is that such
         /// tlogs, should the project name also contain this pattern (e.g. ClassLibrary.1.csproj), will also end up
-        /// with [ID] being substituted for digits in the project name itself -- so the tlog name would end up being 
-        /// ClassLibrary.[ID].read.[ID].tlog, rather than ClassLibrary.1.read.[ID].tlog.  This could potentially 
-        /// cause issues if there are multiple projects differentiated only by the digits in their names; however 
-        /// we believe this is not an interesting scenario to watch for and support, given that the resultant rooting 
-        /// marker is constructed from full paths, so either: 
-        /// - The project directories are also different, and are never substituted, leading to different full paths (e.g. 
+        /// with [ID] being substituted for digits in the project name itself -- so the tlog name would end up being
+        /// ClassLibrary.[ID].read.[ID].tlog, rather than ClassLibrary.1.read.[ID].tlog.  This could potentially
+        /// cause issues if there are multiple projects differentiated only by the digits in their names; however
+        /// we believe this is not an interesting scenario to watch for and support, given that the resultant rooting
+        /// marker is constructed from full paths, so either:
+        /// - The project directories are also different, and are never substituted, leading to different full paths (e.g.
         ///   C:\ClassLibrary.1\Debug\ClassLibrary.[ID].read.[ID].tlog and C:\ClassLibrary.2\Debug\ClassLibrary.[ID].read.[ID].tlog)
-        /// - The project directories are the same, in which case there are two projects that share the same intermediate 
-        ///   directory, which has a host of other problems and is explicitly NOT a supported scenario.  
+        /// - The project directories are the same, in which case there are two projects that share the same intermediate
+        ///   directory, which has a host of other problems and is explicitly NOT a supported scenario.
         /// </comments>
         /// <param name="tlogPath">The tlog path to normalize</param>
         /// <returns>The normalized path</returns>
@@ -128,8 +128,8 @@ private static string NormalizeTlogPath(string tlogPath)
         {
             if (tlogPath.IndexOfAny(s_numerals) == -1)
             {
-                // no reason to make modifications if there aren't any numerical IDs in the 
-                // log filename to begin with. 
+                // no reason to make modifications if there aren't any numerical IDs in the
+                // log filename to begin with.
                 return tlogPath;
             }
             else
@@ -137,10 +137,10 @@ private static string NormalizeTlogPath(string tlogPath)
                 int i;
                 StringBuilder normalizedTlogFilename = new StringBuilder();
 
-                // We're walking the filename backwards since once we hit the final '\', we know we can stop parsing. 
-                // So as to avoid allocating more memory and/or forcing StringBuilder to do more character copies 
-                // than necessary, we append the reversed filename character by character to its own StringBuilder, 
-                // and then reverse it again when constructing the final normalized path.  
+                // We're walking the filename backwards since once we hit the final '\', we know we can stop parsing.
+                // So as to avoid allocating more memory and/or forcing StringBuilder to do more character copies
+                // than necessary, we append the reversed filename character by character to its own StringBuilder,
+                // and then reverse it again when constructing the final normalized path.
                 for (i = tlogPath.Length - 1; i >= 0 && tlogPath[i] != '\\'; i--)
                 {
                     // final character in the pattern can be either '.' or '-'
@@ -166,7 +166,7 @@ private static string NormalizeTlogPath(string tlogPath)
                     }
                     else
                     {
-                        // append this character -- it's not interesting. 
+                        // append this character -- it's not interesting.
                         normalizedTlogFilename.Append(tlogPath[i]);
                     }
                 }
@@ -199,8 +199,8 @@ private static string NormalizeTlogPath(string tlogPath)
         private class TaskItemItemSpecIgnoreCaseComparer : IEqualityComparer<ITaskItem>
         {
             /// <summary>
-            /// Returns whether the two ITaskItems are equal, where they are judged to be 
-            /// equal as long as the itemspecs, compared case-insensitively, are equal. 
+            /// Returns whether the two ITaskItems are equal, where they are judged to be
+            /// equal as long as the itemspecs, compared case-insensitively, are equal.
             /// </summary>
             public bool Equals(ITaskItem x, ITaskItem y)
             {
@@ -219,8 +219,8 @@ public bool Equals(ITaskItem x, ITaskItem y)
 
             /// <summary>
             /// Returns the hashcode of this ITaskItem.  Given that equality is judged solely based
-            /// on the itemspec, the hash code for this particular comparer also only uses the 
-            /// itemspec to make its determination. 
+            /// on the itemspec, the hash code for this particular comparer also only uses the
+            /// itemspec to make its determination.
             /// </summary>
             public int GetHashCode(ITaskItem obj) => obj == null ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(obj.ItemSpec);
         }
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index 8012c69c886..be62498f6ee 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -50,7 +50,7 @@ public enum ExecutableType
         Managed64Bit = 4,
 
         /// <summary>
-        /// Use the same bitness as the currently running executable. 
+        /// Use the same bitness as the currently running executable.
         /// </summary>
         SameAsCurrentProcess = 5,
 
@@ -94,7 +94,7 @@ public static class FileTracker
         // The path to LocalApplicationData (is equal to %USERPROFILE%\Local Settings\Application Data folder in Windows XP and %USERPROFILE%\AppData\Local in Vista and later).
         private static readonly string s_localApplicationDataPath = FileUtilities.EnsureTrailingSlash(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData).ToUpperInvariant());
 
-        // The path to the LocalLow folder. In Vista and later, user application data is organized across %USERPROFILE%\AppData\LocalLow,  %USERPROFILE%\AppData\Local (%LOCALAPPDATA%) 
+        // The path to the LocalLow folder. In Vista and later, user application data is organized across %USERPROFILE%\AppData\LocalLow,  %USERPROFILE%\AppData\Local (%LOCALAPPDATA%)
         // and %USERPROFILE%\AppData\Roaming (%APPDATA%). The LocalLow folder is not present in XP.
         private static readonly string s_localLowApplicationDataPath = FileUtilities.EnsureTrailingSlash(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "AppData\\LocalLow").ToUpperInvariant());
 
@@ -154,64 +154,64 @@ private static List<string> InitializeCommonApplicationDataPaths()
         #region Native method wrappers
 
         /// <summary>
-        /// Stops tracking file accesses.  
+        /// Stops tracking file accesses.
         /// </summary>
         public static void EndTrackingContext() => InprocTrackingNativeMethods.EndTrackingContext();
 
         /// <summary>
-        /// Resume tracking file accesses in the current tracking context. 
+        /// Resume tracking file accesses in the current tracking context.
         /// </summary>
         public static void ResumeTracking() => InprocTrackingNativeMethods.ResumeTracking();
 
         /// <summary>
-        /// Set the global thread count, and assign that count to the current thread. 
+        /// Set the global thread count, and assign that count to the current thread.
         /// </summary>
         public static void SetThreadCount(int threadCount) => InprocTrackingNativeMethods.SetThreadCount(threadCount);
 
         /// <summary>
-        /// Starts tracking file accesses. 
+        /// Starts tracking file accesses.
         /// </summary>
         /// <param name="intermediateDirectory">The directory into which to write the tracking log files</param>
-        /// <param name="taskName">The name of the task calling this function, used to determine the 
+        /// <param name="taskName">The name of the task calling this function, used to determine the
         /// names of the tracking log files</param>
         public static void StartTrackingContext(string intermediateDirectory, string taskName) => InprocTrackingNativeMethods.StartTrackingContext(intermediateDirectory, taskName);
 
         /// <summary>
-        /// Starts tracking file accesses, using the rooting marker in the response file provided.  To 
-        /// automatically generate a response file given a rooting marker, call 
-        /// FileTracker.CreateRootingMarkerResponseFile. 
+        /// Starts tracking file accesses, using the rooting marker in the response file provided.  To
+        /// automatically generate a response file given a rooting marker, call
+        /// FileTracker.CreateRootingMarkerResponseFile.
         /// </summary>
         /// <param name="intermediateDirectory">The directory into which to write the tracking log files</param>
-        /// <param name="taskName">The name of the task calling this function, used to determine the 
+        /// <param name="taskName">The name of the task calling this function, used to determine the
         /// names of the tracking log files</param>
         /// <param name="rootMarkerResponseFile">The path to the root marker response file.</param>
         public static void StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarkerResponseFile)
             => InprocTrackingNativeMethods.StartTrackingContextWithRoot(intermediateDirectory, taskName, rootMarkerResponseFile);
 
         /// <summary>
-        /// Stop tracking file accesses and get rid of the current tracking contexts. 
+        /// Stop tracking file accesses and get rid of the current tracking contexts.
         /// </summary>
         public static void StopTrackingAndCleanup() => InprocTrackingNativeMethods.StopTrackingAndCleanup();
 
         /// <summary>
-        /// Temporarily suspend tracking of file accesses in the current tracking context. 
+        /// Temporarily suspend tracking of file accesses in the current tracking context.
         /// </summary>
         public static void SuspendTracking() => InprocTrackingNativeMethods.SuspendTracking();
 
         /// <summary>
-        /// Write tracking logs for all contexts and threads. 
+        /// Write tracking logs for all contexts and threads.
         /// </summary>
         /// <param name="intermediateDirectory">The directory into which to write the tracking log files</param>
-        /// <param name="taskName">The name of the task calling this function, used to determine the 
+        /// <param name="taskName">The name of the task calling this function, used to determine the
         /// names of the tracking log files</param>
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLogs", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public static void WriteAllTLogs(string intermediateDirectory, string taskName) => InprocTrackingNativeMethods.WriteAllTLogs(intermediateDirectory, taskName);
 
         /// <summary>
-        /// Write tracking logs corresponding to the current tracking context.  
+        /// Write tracking logs corresponding to the current tracking context.
         /// </summary>
         /// <param name="intermediateDirectory">The directory into which to write the tracking log files</param>
-        /// <param name="taskName">The name of the task calling this function, used to determine the 
+        /// <param name="taskName">The name of the task calling this function, used to determine the
         /// names of the tracking log files</param>
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLogs", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public static void WriteContextTLogs(string intermediateDirectory, string taskName) => InprocTrackingNativeMethods.WriteContextTLogs(intermediateDirectory, taskName);
@@ -244,7 +244,7 @@ public static bool FileIsExcludedFromDependencies(string fileName)
             // 3. Files under %USERPROFILE%\AppData\LocalLow in Vista and later.
             // 4. Files that are in the TEMP directory (Since on XP, temp files are not
             //    located under AppData, they would not be compacted out correctly otherwise).
-            // 5. Files under the common ("All Users") Application Data location -- C:\Documents and Settings\All Users\Application Data 
+            // 5. Files under the common ("All Users") Application Data location -- C:\Documents and Settings\All Users\Application Data
             //    on XP and either C:\Users\All Users\Application Data or C:\ProgramData on Vista+
 
             return FileIsUnderPath(fileName, s_applicationDataPath) ||
@@ -334,7 +334,7 @@ public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] output
 
         /// <summary>
         /// Given a set of source files in the form of ITaskItem, creates a temporary response
-        /// file containing the rooting marker that corresponds to those sources. 
+        /// file containing the rooting marker that corresponds to those sources.
         /// </summary>
         /// <param name="sources">
         /// ITaskItem array of primary sources.
@@ -343,7 +343,7 @@ public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] output
         public static string CreateRootingMarkerResponseFile(ITaskItem[] sources) => CreateRootingMarkerResponseFile(FormatRootingMarker(sources));
 
         /// <summary>
-        /// Given a rooting marker, creates a temporary response file with that rooting marker 
+        /// Given a rooting marker, creates a temporary response file with that rooting marker
         /// in it.
         /// </summary>
         /// <param name="rootMarker">The rooting marker to put in the response file.</param>
@@ -358,7 +358,7 @@ public static string CreateRootingMarkerResponseFile(string rootMarker)
 
         /// <summary>
         /// Prepends the path to the appropriate FileTracker assembly to the PATH
-        /// environment variable.  Used for inproc tracking, or when the .NET Framework may 
+        /// environment variable.  Used for inproc tracking, or when the .NET Framework may
         /// not be on the PATH.
         /// </summary>
         /// <returns>The old value of PATH</returns>
@@ -366,7 +366,7 @@ public static string CreateRootingMarkerResponseFile(string rootMarker)
 
         /// <summary>
         /// Prepends the path to the appropriate FileTracker assembly to the PATH
-        /// environment variable.  Used for inproc tracking, or when the .NET Framework may 
+        /// environment variable.  Used for inproc tracking, or when the .NET Framework may
         /// not be on the PATH.
         /// </summary>
         /// <param name="rootPath">The root path for FileTracker.dll.  Overrides the toolType if specified.</param>
@@ -385,8 +385,8 @@ public static string EnsureFileTrackerOnPath(string rootPath)
         }
 
         /// <summary>
-        /// Searches %PATH% for the location of Tracker.exe, and returns the first 
-        /// path that matches. 
+        /// Searches %PATH% for the location of Tracker.exe, and returns the first
+        /// path that matches.
         /// </summary>
         /// <returns>The full path to Tracker.exe, or <see langword="null" /> if a matching path is not found.</returns>
         public static string FindTrackerOnPath()
@@ -410,7 +410,7 @@ public static string FindTrackerOnPath()
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
-                    // ignore this path and move on -- it's just bad for some reason. 
+                    // ignore this path and move on -- it's just bad for some reason.
                 }
             }
 
@@ -419,14 +419,14 @@ public static string FindTrackerOnPath()
         }
 
         /// <summary>
-        /// Determines whether we must track out-of-proc, or whether inproc tracking will work. 
+        /// Determines whether we must track out-of-proc, or whether inproc tracking will work.
         /// </summary>
         /// <param name="toolType">The executable type for the tool being tracked</param>
         /// <returns>True if we need to track out-of-proc, false if inproc tracking is OK</returns>
         public static bool ForceOutOfProcTracking(ExecutableType toolType) => ForceOutOfProcTracking(toolType, null, null);
 
         /// <summary>
-        /// Determines whether we must track out-of-proc, or whether inproc tracking will work. 
+        /// Determines whether we must track out-of-proc, or whether inproc tracking will work.
         /// </summary>
         /// <param name="toolType">The executable type for the tool being tracked</param>
         /// <param name="dllName">An optional assembly name.</param>
@@ -438,7 +438,7 @@ public static bool ForceOutOfProcTracking(ExecutableType toolType, string dllNam
 
             if (cancelEventName != null)
             {
-                // If we have a cancel event, we must track out-of-proc. 
+                // If we have a cancel event, we must track out-of-proc.
                 trackOutOfProc = true;
             }
             else if (dllName != null)
@@ -455,34 +455,34 @@ public static bool ForceOutOfProcTracking(ExecutableType toolType, string dllNam
         }
 
         /// <summary>
-        /// Given the ExecutableType of the tool being wrapped and information that we 
+        /// Given the ExecutableType of the tool being wrapped and information that we
         /// know about our current bitness, figures out and returns the path to the correct
-        /// Tracker.exe. 
+        /// Tracker.exe.
         /// </summary>
         /// <param name="toolType">The <see cref="ExecutableType"/> of the tool being wrapped</param>
         public static string GetTrackerPath(ExecutableType toolType) => GetTrackerPath(toolType, null);
 
         /// <summary>
-        /// Given the ExecutableType of the tool being wrapped and information that we 
+        /// Given the ExecutableType of the tool being wrapped and information that we
         /// know about our current bitness, figures out and returns the path to the correct
-        /// Tracker.exe. 
+        /// Tracker.exe.
         /// </summary>
         /// <param name="toolType">The <see cref="ExecutableType"/> of the tool being wrapped</param>
         /// <param name="rootPath">The root path for Tracker.exe.  Overrides the toolType if specified.</param>
         public static string GetTrackerPath(ExecutableType toolType, string rootPath) => GetPath(s_TrackerFilename, toolType, rootPath);
 
         /// <summary>
-        /// Given the ExecutableType of the tool being wrapped and information that we 
+        /// Given the ExecutableType of the tool being wrapped and information that we
         /// know about our current bitness, figures out and returns the path to the correct
-        /// FileTracker.dll. 
+        /// FileTracker.dll.
         /// </summary>
         /// <param name="toolType">The <see cref="ExecutableType"/> of the tool being wrapped</param>
         public static string GetFileTrackerPath(ExecutableType toolType) => GetFileTrackerPath(toolType, null);
 
         /// <summary>
-        /// Given the ExecutableType of the tool being wrapped and information that we 
+        /// Given the ExecutableType of the tool being wrapped and information that we
         /// know about our current bitness, figures out and returns the path to the correct
-        /// FileTracker.dll. 
+        /// FileTracker.dll.
         /// </summary>
         /// <param name="toolType">The <see cref="ExecutableType"/> of the tool being wrapped</param>
         /// <param name="rootPath">The root path for FileTracker.dll.  Overrides the toolType if specified.</param>
@@ -490,7 +490,7 @@ public static bool ForceOutOfProcTracking(ExecutableType toolType, string dllNam
 
         /// <summary>
         /// Given a filename (only really meant to support either Tracker.exe or FileTracker.dll), returns
-        /// the appropriate path for the appropriate file type. 
+        /// the appropriate path for the appropriate file type.
         /// </summary>
         /// <param name="filename"></param>
         /// <param name="toolType"></param>
@@ -521,16 +521,16 @@ private static string GetPath(string filename, ExecutableType toolType, string r
         }
 
         /// <summary>
-        /// Given a filename (currently only Tracker.exe and FileTracker.dll are supported), return 
-        /// the path to that file. 
+        /// Given a filename (currently only Tracker.exe and FileTracker.dll are supported), return
+        /// the path to that file.
         /// </summary>
         /// <param name="filename"></param>
         /// <param name="bitness"></param>
         /// <returns></returns>
         private static string GetPath(string filename, DotNetFrameworkArchitecture bitness)
         {
-            // Make sure that if someone starts passing the wrong thing to this method we don't silently 
-            // eat it and do something possibly unexpected. 
+            // Make sure that if someone starts passing the wrong thing to this method we don't silently
+            // eat it and do something possibly unexpected.
             ErrorUtilities.VerifyThrow(
                                        s_TrackerFilename.Equals(filename, StringComparison.OrdinalIgnoreCase) ||
                                        s_FileTrackerFilename.Equals(filename, StringComparison.OrdinalIgnoreCase),
@@ -649,7 +649,7 @@ public static string TrackerArguments(string command, string arguments, string d
         #region StartProcess methods
 
         /// <summary>
-        /// Start the process; tracking the command.  
+        /// Start the process; tracking the command.
         /// </summary>
         /// <param name="command">The command to track</param>
         /// <param name="arguments">The command to track's arguments</param>
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index b9c6288db79..e778ff04f3b 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -382,7 +382,7 @@ private void ConstructFileTable()
 
                 // We may have stored the dependency table in the cache, but all the other information
                 // (newest file time, number of missing files, etc.) has been reset to default.  Refresh
-                // the data.  
+                // the data.
                 UpdateFileEntryDetails();
 
                 // Log information about what we're using
@@ -396,8 +396,8 @@ private void ConstructFileTable()
 
             FileTracker.LogMessageFromResources(_log, MessageImportance.Low, "Tracking_TrackingLogs");
             // Now we need to construct the rest of the table from the TLOG files
-            // If there are any errors in the tlogs, we want to warn, stop parsing tlogs, and empty 
-            // out the dependency table, essentially forcing a rebuild.  
+            // If there are any errors in the tlogs, we want to warn, stop parsing tlogs, and empty
+            // out the dependency table, essentially forcing a rebuild.
             bool encounteredInvalidTLogContents = false;
             string invalidTLogName = null;
             foreach (ITaskItem tlogFileName in TlogFiles)
@@ -476,8 +476,8 @@ private void ConstructFileTable()
 
             lock (DependencyTableCache.DependencyTable)
             {
-                // There were problems with the tracking logs -- we've already warned or errored; now we want to make 
-                // sure that we essentially force a rebuild of this particular root. 
+                // There were problems with the tracking logs -- we've already warned or errored; now we want to make
+                // sure that we essentially force a rebuild of this particular root.
                 if (encounteredInvalidTLogContents)
                 {
                     DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
@@ -655,7 +655,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
         }
 
         /// <summary>
-        /// Returns cached value for last write time of file. Update the cache if it is the first 
+        /// Returns cached value for last write time of file. Update the cache if it is the first
         /// time someone asking for that file
         /// </summary>
         public DateTime GetLastWriteTimeUtc(string file)
@@ -734,7 +734,7 @@ public static bool IsUpToDate(TaskLoggingHelper Log, UpToDateCheckType upToDateC
             if (!inputs.TlogsAvailable || !outputs.TlogsAvailable || inputs.DependencyTable.Count == 0)
             {
                 // 1) The TLogs are somehow missing, which means we need to build
-                // 2) Because we are flat tracking, there are no roots which means that all the input file information 
+                // 2) Because we are flat tracking, there are no roots which means that all the input file information
                 //    comes from the input Tlogs, if they are empty then we must build.
                 Log.LogMessageFromResources(MessageImportance.Low, "Tracking_LogFilesNotAvailable");
             }
@@ -878,7 +878,7 @@ public static void FinalizeTLogs(bool trackedOperationsSucceeded, ITaskItem[] re
                 }
                 else
                 {
-                    // Compact the write tlog                        
+                    // Compact the write tlog
                     outputs.SaveTlog();
 
                     // Compact the read tlog
