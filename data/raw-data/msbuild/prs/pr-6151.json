{
  "number": 6151,
  "title": "Optimize glob evaluation",
  "body": "Fixes #6069 \r\n\r\n### Context\r\nGlob expansion has been identified as one of the performance bottlenecks when building .NET Core projects. The cost is not negligible with a simple Hello World project and gets progressively worse when the project directory (transitively) contains more files, be it source files or completely unrelated files. Since glob expansion is part of project evaluation, it directly impacts Visual Studio performance as well, especially solution load performance.\r\n\r\n### Changes Made\r\nThis PR is a collection of several changes to the globbing logic aiming to make .NET Core project evaluation faster.\r\n\r\n- Refactor, simplify, and micro-optimize hot code paths,\r\n- Eliminate exclude patterns early if it's clear that they don't intersect with the include,\r\n- Optimize most common glob patterns to match without regex (building a typical .NET Core app now does not instantiate a single regex for glob matching),\r\n- Cache the results of all filesystem enumeration calls, not just directories.\r\n\r\n### Testing\r\nExisting unit tests for correctness, ETL traces for performance.\r\n\r\nPerformance:\r\n\r\nThe wins in terms of the Microsoft-Build/ExpandGlob event duration range from 16% (Hello World project built with `MSBuild.exe`) to 48% (Hello World project with ~4000 files in ~600 folders, all non-.cs and non-.resx, built with `dotnet build`). These numbers were measured with incremental build on the command line, the project was a .NET Core project in all cases, just with a different build engine. Here's a table with all numbers:\r\n\r\nProject | MSBuild.exe | dotnet build\r\n--- | --- | ---\r\nHello World (no extra files) | 16% | 29%\r\nHello World (4000 extra files) | 35% | 48%\r\n\r\nIn terms of the overall build time, we're looking at a 1-2% improvement for a Hello World project and 8-10% for a project with thousands of extra files in the source tree.\r\n\r\n### Notes\r\nThis PR is recommended to be reviewed commit by commit. `FileMatcher` is a complex class and there is non-trivial breaking potential as projects may depend on all kinds of corner case behavior. Which is the primary reason for not rewriting the entire thing. The most impactful change in this PR - caching files to avoid repeated filesystem API calls - is behind a change wave condition, just in case.",
  "state": "MERGED",
  "createdAt": "2021-02-12T11:01:11Z",
  "updatedAt": "2021-05-31T16:33:51Z",
  "closedAt": "2021-03-03T09:57:18Z",
  "mergedAt": "2021-03-03T09:57:18Z",
  "additions": 382,
  "deletions": 222,
  "changedFiles": 7,
  "headRefName": "6069-globbing-improvements",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "b9858fb27ea4aec025343f01d5ce1e52b00cc9d9",
          "message": "Code cleanup in FileMatcher.cs and MSBuildGlob.cs",
          "committedDate": "2021-03-03T08:20:16Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "28c9b7d31f81b94493e1df57e0516d83318a9fee",
          "message": "Simplify Normalize and SkipCharacters",
          "committedDate": "2021-03-03T08:20:16Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f5ebb26361a8b8c42fac76d60d1b71970062e762",
          "message": "Optimize globbing by ignoring excludes that cannot match anything",
          "committedDate": "2021-03-03T08:20:16Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e93ccdfa1695c2ddf364bda67d8961b6d587027c",
          "message": "Remove unused method",
          "committedDate": "2021-03-03T08:20:16Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b841cdd09f4431ab5a5ea9d07ab1c652b9fff2af",
          "message": "Remove unused parameter from IsMatch",
          "committedDate": "2021-03-03T08:20:16Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "601d097f5b3bf065585789071ac5be2cbf7a97d8",
          "message": "Don't use regex to match patterns similar to **/.*/**",
          "committedDate": "2021-03-03T08:20:17Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f700993d2f878d21886dde021b29b3777bb3585d",
          "message": "Micro-optimize IsMatch::CompareIgnoreCase",
          "committedDate": "2021-03-03T08:20:17Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f9c5c08e1b788c37abc97b2b77855d4dc36429c7",
          "message": "Optimize FileSpecMatcherTester to match common patterns without regex'es",
          "committedDate": "2021-03-03T08:20:17Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "52b84e9887736bfeb11e5a7afbefda9ed76df6c6",
          "message": "Don't build regex string if regex is not needed",
          "committedDate": "2021-03-03T08:20:17Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6a0ccba9b6f3193634907116959c5149fd2bb649",
          "message": "Don't create temporary and redundant ImmutableArray<string>",
          "committedDate": "2021-03-03T08:20:18Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6a51a75fb2ec3c3dc72d648f283381aedd910dec",
          "message": "Cache all files and directories",
          "committedDate": "2021-03-03T08:20:18Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "da0124592459d5193981038268c7c1a6facfb277",
          "message": "Materialize enumerable early (except where guaranteed only one enumeration)",
          "committedDate": "2021-03-03T08:20:18Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5afa7c8d54f16596eb849e4affca7d2ff28654a",
          "message": "Back-compat workaround",
          "committedDate": "2021-03-03T08:20:18Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Hey, folks, could this be related to https://github.com/dotnet/sdk/issues/17976? Could someone please take a look?",
        "createdAt": "2021-05-31T16:33:51Z",
        "author": {
          "login": "ForNeVeR"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "@cdmihai may I please get your opinion on this? Glob matching on Linux is currently sometimes case-sensitive and sometimes case-insensitive depending on which code path we happen to take in this function.\r\n\r\nIn this PR I am optimizing globbing and without the hack/workaround a couple of test cases fail on Linux because they expect certain behavior w.r.t. case sensitivity. These assumptions are encoded very explicitly:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/6bad8ea6a27fc23621ee8a41fd941dff01976de1/src/Shared/UnitTests/FileMatcher_Tests.cs#L112-L120\r\n\r\nand for example:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/6bad8ea6a27fc23621ee8a41fd941dff01976de1/src/Shared/UnitTests/FileMatcher_Tests.cs#L219\r\n\r\nHow would you feel about fixing Linux to be consistent, so most likely case-insensitive like other platforms, by changing file enumeration calls to pass [EnumerationOptions ](https://docs.microsoft.com/en-us/dotnet/api/system.io.enumerationoptions?view=net-5.0) with `MatchCasing=false`? Technically a breaking change, yes, but the current state makes it hard to innovate and has us write ugly hacks like this one.",
              "createdAt": "2021-02-12T15:11:45Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1012,10 +1032,27 @@ struct RecursionState\n             {\n                 return Enumerable.Empty<string>();\n             }\n+\n+            // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending\n+            // on the NeedsToProcessEachFile flag. If the flag is false and matching is done within the _getFileSystemEntries call,\n+            // it is case sensitive. If the flag is true and matching is handled with MatchFileRecursionStep, it is case-insensitive.\n+            // TODO: Can we fix this by using case-insensitive file I/O on Linux?\n+            bool forceFileProcessing = false;\n+            string filespec;\n+            if (NativeMethodsShared.IsLinux && recursionState.SearchData.DirectoryPattern != null)\n+            {\n+                filespec = \"*.*\";\n+                forceFileProcessing = true;\n+            }\n+            else\n+            {\n+                filespec = recursionState.SearchData.Filespec;\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Not completely relevant, but a bit of a discussion happened on linux case sensitivity here: https://github.com/dotnet/msbuild/issues/5658",
              "createdAt": "2021-02-12T22:10:31Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1012,10 +1032,27 @@ struct RecursionState\n             {\n                 return Enumerable.Empty<string>();\n             }\n+\n+            // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending\n+            // on the NeedsToProcessEachFile flag. If the flag is false and matching is done within the _getFileSystemEntries call,\n+            // it is case sensitive. If the flag is true and matching is handled with MatchFileRecursionStep, it is case-insensitive.\n+            // TODO: Can we fix this by using case-insensitive file I/O on Linux?\n+            bool forceFileProcessing = false;\n+            string filespec;\n+            if (NativeMethodsShared.IsLinux && recursionState.SearchData.DirectoryPattern != null)\n+            {\n+                filespec = \"*.*\";\n+                forceFileProcessing = true;\n+            }\n+            else\n+            {\n+                filespec = recursionState.SearchData.Filespec;\n+            }",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Here's a simple example where we are inconsistent today.\r\n\r\nSource tree:\r\n```\r\n.\r\n\u251c\u2500\u2500 abc\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 File\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 file\r\n\u2514\u2500\u2500 repro.proj\r\n```\r\n\r\nrepro.proj:\r\n```xml\r\n<Project>\r\n  <ItemGroup>\r\n    <Item1 Include=\"a*/f*\" />\r\n    <Item2 Include=\"abc/f*\" />\r\n  </ItemGroup>\r\n\r\n  <Target Name=\"Build\">\r\n    <Message Text=\"@(Item1)\" />\r\n    <Message Text=\"@(Item2)\" />\r\n  </Target>\r\n</Project>\r\n```\r\n\r\n```sh\r\n$ dotnet build repro.proj /v:n\r\n```\r\n\r\nPrints:\r\n```\r\n  abc/File;abc/file\r\n  abc/file\r\n```\r\n\r\ni.e. the first glob matched both ```file``` and ```File``` while the second one did not.",
              "createdAt": "2021-02-16T12:56:59Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1012,10 +1032,27 @@ struct RecursionState\n             {\n                 return Enumerable.Empty<string>();\n             }\n+\n+            // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending\n+            // on the NeedsToProcessEachFile flag. If the flag is false and matching is done within the _getFileSystemEntries call,\n+            // it is case sensitive. If the flag is true and matching is handled with MatchFileRecursionStep, it is case-insensitive.\n+            // TODO: Can we fix this by using case-insensitive file I/O on Linux?\n+            bool forceFileProcessing = false;\n+            string filespec;\n+            if (NativeMethodsShared.IsLinux && recursionState.SearchData.DirectoryPattern != null)\n+            {\n+                filespec = \"*.*\";\n+                forceFileProcessing = true;\n+            }\n+            else\n+            {\n+                filespec = recursionState.SearchData.Filespec;\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Case sensitivity is part of a long standing undesigned area of MSBuild: path representation. See #781 and #1024. It's pretty much a can of worms.\r\n\r\nHowever way we change it, we'll probably break *somebody* and [as noted before](https://github.com/dotnet/msbuild/issues/1024#issuecomment-549564420), it's probably of minimal user benefit.\r\nThat being said, it would be interesting to test these assumptions and hardcode casing to case insensitive, provided that an escape hatch to old behaviour is provided. Unfortunately the escape hatch would keep the messy code, but we could at least give it a year or so to hear any complaints before deleting it.\r\n\r\nIf you do choose to embark on this journey, I'd prefer the following:\r\n- design it and take the other aspects of #781 and #1024 into account, even if just as placeholders for future design. Then make it an official spec on docs.microsoft.com on how msbuild handles file system configurations.\r\n- make all the msbuild codebase uniform to the new spec, not just the globbing code\r\n- have a central place in the codebase that decides file system configuration policies (similar to how [BuildEnvironment](https://github.com/dotnet/msbuild/blob/f0eebf2872d76ab0cd43fdc4153ba636232b222f/src/Shared/BuildEnvironmentHelper.cs#L497) centralizes msbuild file and assembly structure) instead of having it duplicated all over the place. One policy would be the `Legacy` policy, which is the behaviour today. Hopefully we can delete it in 1-2 years if nothing really critical breaks.",
              "createdAt": "2021-02-16T22:03:37Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1012,10 +1032,27 @@ struct RecursionState\n             {\n                 return Enumerable.Empty<string>();\n             }\n+\n+            // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending\n+            // on the NeedsToProcessEachFile flag. If the flag is false and matching is done within the _getFileSystemEntries call,\n+            // it is case sensitive. If the flag is true and matching is handled with MatchFileRecursionStep, it is case-insensitive.\n+            // TODO: Can we fix this by using case-insensitive file I/O on Linux?\n+            bool forceFileProcessing = false;\n+            string filespec;\n+            if (NativeMethodsShared.IsLinux && recursionState.SearchData.DirectoryPattern != null)\n+            {\n+                filespec = \"*.*\";\n+                forceFileProcessing = true;\n+            }\n+            else\n+            {\n+                filespec = recursionState.SearchData.Filespec;\n+            }",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Thank you for the details. It sounds like changing the behavior should be done separately so I am keeping the Linux workaround and this PR overall strives for 100% back compat.",
              "createdAt": "2021-02-17T11:48:14Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1012,10 +1032,27 @@ struct RecursionState\n             {\n                 return Enumerable.Empty<string>();\n             }\n+\n+            // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending\n+            // on the NeedsToProcessEachFile flag. If the flag is false and matching is done within the _getFileSystemEntries call,\n+            // it is case sensitive. If the flag is true and matching is handled with MatchFileRecursionStep, it is case-insensitive.\n+            // TODO: Can we fix this by using case-insensitive file I/O on Linux?\n+            bool forceFileProcessing = false;\n+            string filespec;\n+            if (NativeMethodsShared.IsLinux && recursionState.SearchData.DirectoryPattern != null)\n+            {\n+                filespec = \"*.*\";\n+                forceFileProcessing = true;\n+            }\n+            else\n+            {\n+                filespec = recursionState.SearchData.Filespec;\n+            }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What was the reason for removing the parameter from IsMatch? That all the calls to it were passing true?",
              "createdAt": "2021-02-12T21:40:08Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1611,8 +1647,7 @@ internal Result()\n         /// </summary>\n         /// <param name=\"input\">String which is matched against the pattern.</param>\n         /// <param name=\"pattern\">Pattern against which string is matched.</param>\n-        /// <param name=\"ignoreCase\">Determines whether ignoring case when comparing two characters</param>\n-        internal static bool IsMatch(string input, string pattern, bool ignoreCase)\n+        internal static bool IsMatch(string input, string pattern)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Yes, all calls were passing true. After implementing a few more optimizations, I suspect I may need to put the parameter back, though, for back compat on Linux.",
              "createdAt": "2021-02-16T09:35:16Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1611,8 +1647,7 @@ internal Result()\n         /// </summary>\n         /// <param name=\"input\">String which is matched against the pattern.</param>\n         /// <param name=\"pattern\">Pattern against which string is matched.</param>\n-        /// <param name=\"ignoreCase\">Determines whether ignoring case when comparing two characters</param>\n-        internal static bool IsMatch(string input, string pattern, bool ignoreCase)\n+        internal static bool IsMatch(string input, string pattern)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "It looks like I ended up not needing the parameter.",
              "createdAt": "2021-02-16T21:49:09Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1611,8 +1647,7 @@ internal Result()\n         /// </summary>\n         /// <param name=\"input\">String which is matched against the pattern.</param>\n         /// <param name=\"pattern\">Pattern against which string is matched.</param>\n-        /// <param name=\"ignoreCase\">Determines whether ignoring case when comparing two characters</param>\n-        internal static bool IsMatch(string input, string pattern, bool ignoreCase)\n+        internal static bool IsMatch(string input, string pattern)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Stranger, looking at https://github.com/dotnet/msbuild/pull/2572, where it was introduced, it looks like the third parameter was only ever used in tests.",
              "createdAt": "2021-02-18T18:27:08Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1611,8 +1647,7 @@ internal Result()\n         /// </summary>\n         /// <param name=\"input\">String which is matched against the pattern.</param>\n         /// <param name=\"pattern\">Pattern against which string is matched.</param>\n-        /// <param name=\"ignoreCase\">Determines whether ignoring case when comparing two characters</param>\n-        internal static bool IsMatch(string input, string pattern, bool ignoreCase)\n+        internal static bool IsMatch(string input, string pattern)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Bonus points for the example \ud83d\udc4d",
              "createdAt": "2021-02-12T21:43:55Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2458,6 +2520,19 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent\n             }\n         }\n \n+        /// <summary>\n+        /// Returns true if the last component of the given directory path (assumed to not have any trailing slashes)\n+        /// matches the given pattern.\n+        /// </summary>\n+        /// <param name=\"directoryPath\">The path to test.</param>\n+        /// <param name=\"pattern\">The pattern to test against.</param>\n+        /// <returns>True in case of a match (e.g. directoryPath = \"dir/subdir\" and pattern = \"s*\"), false otherwise.</returns>",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this an area that can be span-ified?",
              "createdAt": "2021-02-12T21:47:49Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2042,18 +2076,45 @@ enum SearchAction\n                 return SearchAction.ReturnEmptyList;\n             }\n \n+            string directoryPattern = null;\n+            if (wildcardDirectoryPart.Length > 0)\n+            {\n+                // If the wildcard directory part looks like \"**/{pattern}/**\", we are essentially looking for files that have\n+                // a matching directory anywhere on their path. This is commonly used when excluding hidden directories using\n+                // \"**/.*/**\" for example, and is worth special-casing so it doesn't fall into the slow regex logic.\n+                string wildcard = wildcardDirectoryPart.TrimTrailingSlashes();",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Yes, I think that there are opportunities to optimize by using `Span<>` in this code, although most of it is not low-hanging fruit and doesn't have to be addressed with priority. This particular line, for example, runs only a handful of times per project so no biggie if it allocates.",
              "createdAt": "2021-02-16T09:33:15Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2042,18 +2076,45 @@ enum SearchAction\n                 return SearchAction.ReturnEmptyList;\n             }\n \n+            string directoryPattern = null;\n+            if (wildcardDirectoryPart.Length > 0)\n+            {\n+                // If the wildcard directory part looks like \"**/{pattern}/**\", we are essentially looking for files that have\n+                // a matching directory anywhere on their path. This is commonly used when excluding hidden directories using\n+                // \"**/.*/**\" for example, and is worth special-casing so it doesn't fall into the slow regex logic.\n+                string wildcard = wildcardDirectoryPart.TrimTrailingSlashes();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could you explain how you came to this micro-optimization?",
              "createdAt": "2021-02-12T22:00:23Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1672,13 +1672,15 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)\n                 // We will mostly be comparing ASCII characters, check this first\n                 if (inputChar < 128 && patternChar < 128)\n                 {\n-                    if (inputChar >= 'A' && inputChar <= 'Z' && patternChar >= 'a' && patternChar <= 'z')\n+                    if (inputChar >= 'A' && inputChar <= 'Z')\n                     {\n-                        return inputChar + 32 == patternChar;\n+                        // Evaluates to true if patternChar is equal to inputChar or to the lower-case counter-part.\n+                        return inputChar == (patternChar & ~0x20);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "The original code had to do 4 comparisons here: 2 to make sure that `inputChar` is in range and 2 to make sure that `patternChar` is in the corresponding range also. Then it compared them knowing that pattern, being lower-case, needs to have its ASCII value 32 more than input for them to match.\r\n\r\nI simplified the condition to check only one side, in this case `inputChar`. And instead of adding/subtracting 32 I am setting/clearing the corresponding bit, making the check work regardless of what the value of `patternChar` is.\r\n\r\nExample: If `inputChar` is `A` and `patternChar` is `A` then clearing the bit does nothing as upper case characters don't have it set so the result will be `true`, i.e. they are the same. If `inputChar` is `A` and `patternChar` is `a` then clearing the bit on `patternChar` turns it into `A` and again, the check works.\r\n\r\nThis line could equivalently be written as:\r\n\r\n```C#\r\nreturn (inputChar | 0x20) == patternChar;\r\n```\r\n\r\nA micro benchmark for `CompareIgnoreCase` showed ~10% perf improvement with this change in the common case where the input are letters from the English alphabet.",
              "createdAt": "2021-02-16T09:29:07Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1672,13 +1672,15 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)\n                 // We will mostly be comparing ASCII characters, check this first\n                 if (inputChar < 128 && patternChar < 128)\n                 {\n-                    if (inputChar >= 'A' && inputChar <= 'Z' && patternChar >= 'a' && patternChar <= 'z')\n+                    if (inputChar >= 'A' && inputChar <= 'Z')\n                     {\n-                        return inputChar + 32 == patternChar;\n+                        // Evaluates to true if patternChar is equal to inputChar or to the lower-case counter-part.\n+                        return inputChar == (patternChar & ~0x20);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "NIT: Branches are expensive (when we talk about micro optimization) I would eliminate one by storing normalized value in local variable:\r\n```C#\r\nchar inputCharUpper = (char)(inputChar & ~0x20);\r\nif (inputCharUpper >= 'A' && inputCharUpper <= 'Z')\r\n{\r\n    return inputCharUpper == (patternChar & ~0x20);\r\n}\r\n\r\nreturn inputChar == patternChar;\r\n```\r\n\r\nLet me please have some fun and benchmark it...",
              "createdAt": "2021-02-18T15:50:40Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1672,13 +1672,15 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)\n                 // We will mostly be comparing ASCII characters, check this first\n                 if (inputChar < 128 && patternChar < 128)\n                 {\n-                    if (inputChar >= 'A' && inputChar <= 'Z' && patternChar >= 'a' && patternChar <= 'z')\n+                    if (inputChar >= 'A' && inputChar <= 'Z')\n                     {\n-                        return inputChar + 32 == patternChar;\n+                        // Evaluates to true if patternChar is equal to inputChar or to the lower-case counter-part.\n+                        return inputChar == (patternChar & ~0x20);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Here we go:\r\n![image](https://user-images.githubusercontent.com/25249058/108383653-43f06700-720a-11eb-81da-cbadf0a85f46.png)\r\n",
              "createdAt": "2021-02-18T15:56:43Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1672,13 +1672,15 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)\n                 // We will mostly be comparing ASCII characters, check this first\n                 if (inputChar < 128 && patternChar < 128)\n                 {\n-                    if (inputChar >= 'A' && inputChar <= 'Z' && patternChar >= 'a' && patternChar <= 'z')\n+                    if (inputChar >= 'A' && inputChar <= 'Z')\n                     {\n-                        return inputChar + 32 == patternChar;\n+                        // Evaluates to true if patternChar is equal to inputChar or to the lower-case counter-part.\n+                        return inputChar == (patternChar & ~0x20);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Thank you, that's a great point! I have pushed your suggestion, just with `inputCharLower = ` as it's a bit easier to read than `x & ~y`.",
              "createdAt": "2021-02-22T12:19:08Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1672,13 +1672,15 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)\n                 // We will mostly be comparing ASCII characters, check this first\n                 if (inputChar < 128 && patternChar < 128)\n                 {\n-                    if (inputChar >= 'A' && inputChar <= 'Z' && patternChar >= 'a' && patternChar <= 'z')\n+                    if (inputChar >= 'A' && inputChar <= 'Z')\n                     {\n-                        return inputChar + 32 == patternChar;\n+                        // Evaluates to true if patternChar is equal to inputChar or to the lower-case counter-part.\n+                        return inputChar == (patternChar & ~0x20);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "very minor: could this be readonly as it's instantiated in the .ctor?\r\nHowever, readonly gives the impression of immutability after instantiation, not the case for collections.",
              "createdAt": "2021-02-16T11:50:17Z",
              "path": "src/Build/Evaluation/Context/EvaluationContext.cs",
              "diffHunk": "@@ -48,7 +48,7 @@ public enum SharingPolicy\n         /// <summary>\n         /// Key to file entry list. Example usages: cache glob expansion and intermediary directory expansions during glob expansion.\n         /// </summary>\n-        private ConcurrentDictionary<string, ImmutableArray<string>> FileEntryExpansionCache { get; }\n+        private ConcurrentDictionary<string, IReadOnlyList<string>> FileEntryExpansionCache { get; }",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "It's a property and defining only `get;` actually makes it read-only. The `readonly` keyword would not be valid here.",
              "createdAt": "2021-02-16T13:57:31Z",
              "path": "src/Build/Evaluation/Context/EvaluationContext.cs",
              "diffHunk": "@@ -48,7 +48,7 @@ public enum SharingPolicy\n         /// <summary>\n         /// Key to file entry list. Example usages: cache glob expansion and intermediary directory expansions during glob expansion.\n         /// </summary>\n-        private ConcurrentDictionary<string, ImmutableArray<string>> FileEntryExpansionCache { get; }\n+        private ConcurrentDictionary<string, IReadOnlyList<string>> FileEntryExpansionCache { get; }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "not a change in the PR.  It's difficult to infer normalizedInput's type.",
              "createdAt": "2021-02-16T11:52:12Z",
              "path": "src/Build/Globbing/MSBuildGlob.cs",
              "diffHunk": "@@ -117,23 +117,20 @@ public MatchInfoResult MatchInfo(string stringToMatch)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(stringToMatch, nameof(stringToMatch));\n \n-            if (FileUtilities.PathIsInvalid(stringToMatch) ||\n-                !IsLegal)\n+            if (FileUtilities.PathIsInvalid(stringToMatch) || !IsLegal)\n             {\n                 return MatchInfoResult.Empty;\n             }\n \n             var normalizedInput = NormalizeMatchInput(stringToMatch);",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Fixed.",
              "createdAt": "2021-02-16T16:30:14Z",
              "path": "src/Build/Globbing/MSBuildGlob.cs",
              "diffHunk": "@@ -117,23 +117,20 @@ public MatchInfoResult MatchInfo(string stringToMatch)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(stringToMatch, nameof(stringToMatch));\n \n-            if (FileUtilities.PathIsInvalid(stringToMatch) ||\n-                !IsLegal)\n+            if (FileUtilities.PathIsInvalid(stringToMatch) || !IsLegal)\n             {\n                 return MatchInfoResult.Empty;\n             }\n \n             var normalizedInput = NormalizeMatchInput(stringToMatch);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: is 4 out parameters better than a new encapsulation of the same state?",
              "createdAt": "2021-02-16T11:53:08Z",
              "path": "src/Build/Globbing/MSBuildGlob.cs",
              "diffHunk": "@@ -117,23 +117,20 @@ public MatchInfoResult MatchInfo(string stringToMatch)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(stringToMatch, nameof(stringToMatch));\n \n-            if (FileUtilities.PathIsInvalid(stringToMatch) ||\n-                !IsLegal)\n+            if (FileUtilities.PathIsInvalid(stringToMatch) || !IsLegal)\n             {\n                 return MatchInfoResult.Empty;\n             }\n \n             var normalizedInput = NormalizeMatchInput(stringToMatch);\n \n-            bool isMatch;\n-            string fixedDirectoryPart, wildcardDirectoryPart, filenamePart;\n             FileMatcher.GetRegexMatchInfo(\n                 normalizedInput,\n                 _state.Value.Regex,\n-                out isMatch,\n-                out fixedDirectoryPart,\n-                out wildcardDirectoryPart,\n-                out filenamePart);\n+                out bool isMatch,",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "This might be restating what you suggested, but could we change GetRegexMatchInfo to output a MatchInfoResult?",
              "createdAt": "2021-02-18T01:28:16Z",
              "path": "src/Build/Globbing/MSBuildGlob.cs",
              "diffHunk": "@@ -117,23 +117,20 @@ public MatchInfoResult MatchInfo(string stringToMatch)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(stringToMatch, nameof(stringToMatch));\n \n-            if (FileUtilities.PathIsInvalid(stringToMatch) ||\n-                !IsLegal)\n+            if (FileUtilities.PathIsInvalid(stringToMatch) || !IsLegal)\n             {\n                 return MatchInfoResult.Empty;\n             }\n \n             var normalizedInput = NormalizeMatchInput(stringToMatch);\n \n-            bool isMatch;\n-            string fixedDirectoryPart, wildcardDirectoryPart, filenamePart;\n             FileMatcher.GetRegexMatchInfo(\n                 normalizedInput,\n                 _state.Value.Regex,\n-                out isMatch,\n-                out fixedDirectoryPart,\n-                out wildcardDirectoryPart,\n-                out filenamePart);\n+                out bool isMatch,",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Unfortunately cannot do what you're suggesting as `GetRegexMatchInfo` lives in src/shared, `MSBuildGlob` in src/Build, and `MatchInfoResult` is a public type so it can't be easily moved. I'd say 4 output parameters, while a minor readability hit, is borderline acceptable. There are two calls to `GetRegexMatchInfo`, both populating their own structure with the returned data. Adding another representation just for the purpose of returning it from the method would IMO be an overkill.",
              "createdAt": "2021-02-22T12:14:39Z",
              "path": "src/Build/Globbing/MSBuildGlob.cs",
              "diffHunk": "@@ -117,23 +117,20 @@ public MatchInfoResult MatchInfo(string stringToMatch)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(stringToMatch, nameof(stringToMatch));\n \n-            if (FileUtilities.PathIsInvalid(stringToMatch) ||\n-                !IsLegal)\n+            if (FileUtilities.PathIsInvalid(stringToMatch) || !IsLegal)\n             {\n                 return MatchInfoResult.Empty;\n             }\n \n             var normalizedInput = NormalizeMatchInput(stringToMatch);\n \n-            bool isMatch;\n-            string fixedDirectoryPart, wildcardDirectoryPart, filenamePart;\n             FileMatcher.GetRegexMatchInfo(\n                 normalizedInput,\n                 _state.Value.Regex,\n-                out isMatch,\n-                out fixedDirectoryPart,\n-                out wildcardDirectoryPart,\n-                out filenamePart);\n+                out bool isMatch,",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "this would allow white space to pass the test, right?",
              "createdAt": "2021-02-16T11:53:36Z",
              "path": "src/Build/Globbing/MSBuildGlob.cs",
              "diffHunk": "@@ -145,7 +142,7 @@ private string NormalizeMatchInput(string stringToMatch)\n \n             // Degenerate case when the string to match is empty.\n             // Ensure trailing slash because the fixed directory part has a trailing slash.\n-            if (stringToMatch == string.Empty)\n+            if (string.IsNullOrEmpty(stringToMatch))",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "No, `IsNullOrEmpty` really tests only for `null` and empty string. There's also `IsNullOrWhiteSpace` which is more permissive.",
              "createdAt": "2021-02-16T13:59:56Z",
              "path": "src/Build/Globbing/MSBuildGlob.cs",
              "diffHunk": "@@ -145,7 +142,7 @@ private string NormalizeMatchInput(string stringToMatch)\n \n             // Degenerate case when the string to match is empty.\n             // Ensure trailing slash because the fixed directory part has a trailing slash.\n-            if (stringToMatch == string.Empty)\n+            if (string.IsNullOrEmpty(stringToMatch))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: no need to assert other parameters validity?",
              "createdAt": "2021-02-16T11:55:08Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -12,54 +12,85 @@ namespace Microsoft.Build.Internal\n     {\n         private readonly string _currentDirectory;\n         private readonly string _unescapedFileSpec;\n+        private readonly string _filenamePattern;\n         private readonly Regex _regex;\n         \n-        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex)\n+        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(unescapedFileSpec));\n \n             _currentDirectory = currentDirectory;\n             _unescapedFileSpec = unescapedFileSpec;\n+            _filenamePattern = filenamePattern;",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Yes, added a `currentDirectory` validity check as well. Thank you.",
              "createdAt": "2021-02-22T12:20:06Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -12,54 +12,85 @@ namespace Microsoft.Build.Internal\n     {\n         private readonly string _currentDirectory;\n         private readonly string _unescapedFileSpec;\n+        private readonly string _filenamePattern;\n         private readonly Regex _regex;\n         \n-        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex)\n+        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(unescapedFileSpec));\n \n             _currentDirectory = currentDirectory;\n             _unescapedFileSpec = unescapedFileSpec;\n+            _filenamePattern = filenamePattern;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: counterintuitive type inference.",
              "createdAt": "2021-02-16T11:56:04Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -12,54 +12,85 @@ namespace Microsoft.Build.Internal\n     {\n         private readonly string _currentDirectory;\n         private readonly string _unescapedFileSpec;\n+        private readonly string _filenamePattern;\n         private readonly Regex _regex;\n         \n-        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex)\n+        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(unescapedFileSpec));\n \n             _currentDirectory = currentDirectory;\n             _unescapedFileSpec = unescapedFileSpec;\n+            _filenamePattern = filenamePattern;\n             _regex = regex;\n         }\n \n         public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec)\n         {\n             string unescapedFileSpec = EscapingUtilities.UnescapeAll(fileSpec);\n-            Regex regex = EngineFileUtilities.FilespecHasWildcards(fileSpec) ? CreateRegex(unescapedFileSpec, currentDirectory) : null;\n+            string filenamePattern = null;\n+            Regex regex = null;\n \n-            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, regex);\n+            if (EngineFileUtilities.FilespecHasWildcards(fileSpec))\n+            {\n+                CreateRegexOrFilenamePattern(unescapedFileSpec, currentDirectory, out filenamePattern, out regex);\n+            }\n+\n+            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n-            // check if there is a regex matching the file\n+            // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.\n             if (_regex != null)\n             {\n                 var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return _regex.IsMatch(normalizedFileToMatch);\n             }\n \n+            if (_filenamePattern != null)\n+            {\n+                // Check file name first as it's more likely to not match.\n+                string filename = Path.GetFileName(fileToMatch);\n+                if (!FileMatcher.IsMatch(filename, _filenamePattern))\n+                {\n+                    return false;\n+                }\n+\n+                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Agreed and fixed, thanks!",
              "createdAt": "2021-02-16T16:29:57Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -12,54 +12,85 @@ namespace Microsoft.Build.Internal\n     {\n         private readonly string _currentDirectory;\n         private readonly string _unescapedFileSpec;\n+        private readonly string _filenamePattern;\n         private readonly Regex _regex;\n         \n-        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex)\n+        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(unescapedFileSpec));\n \n             _currentDirectory = currentDirectory;\n             _unescapedFileSpec = unescapedFileSpec;\n+            _filenamePattern = filenamePattern;\n             _regex = regex;\n         }\n \n         public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec)\n         {\n             string unescapedFileSpec = EscapingUtilities.UnescapeAll(fileSpec);\n-            Regex regex = EngineFileUtilities.FilespecHasWildcards(fileSpec) ? CreateRegex(unescapedFileSpec, currentDirectory) : null;\n+            string filenamePattern = null;\n+            Regex regex = null;\n \n-            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, regex);\n+            if (EngineFileUtilities.FilespecHasWildcards(fileSpec))\n+            {\n+                CreateRegexOrFilenamePattern(unescapedFileSpec, currentDirectory, out filenamePattern, out regex);\n+            }\n+\n+            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n-            // check if there is a regex matching the file\n+            // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.\n             if (_regex != null)\n             {\n                 var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return _regex.IsMatch(normalizedFileToMatch);\n             }\n \n+            if (_filenamePattern != null)\n+            {\n+                // Check file name first as it's more likely to not match.\n+                string filename = Path.GetFileName(fileToMatch);\n+                if (!FileMatcher.IsMatch(filename, _filenamePattern))\n+                {\n+                    return false;\n+                }\n+\n+                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: consider referencing the System.StringComparison namespace",
              "createdAt": "2021-02-16T11:56:38Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -12,54 +12,85 @@ namespace Microsoft.Build.Internal\n     {\n         private readonly string _currentDirectory;\n         private readonly string _unescapedFileSpec;\n+        private readonly string _filenamePattern;\n         private readonly Regex _regex;\n         \n-        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex)\n+        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(unescapedFileSpec));\n \n             _currentDirectory = currentDirectory;\n             _unescapedFileSpec = unescapedFileSpec;\n+            _filenamePattern = filenamePattern;\n             _regex = regex;\n         }\n \n         public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec)\n         {\n             string unescapedFileSpec = EscapingUtilities.UnescapeAll(fileSpec);\n-            Regex regex = EngineFileUtilities.FilespecHasWildcards(fileSpec) ? CreateRegex(unescapedFileSpec, currentDirectory) : null;\n+            string filenamePattern = null;\n+            Regex regex = null;\n \n-            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, regex);\n+            if (EngineFileUtilities.FilespecHasWildcards(fileSpec))\n+            {\n+                CreateRegexOrFilenamePattern(unescapedFileSpec, currentDirectory, out filenamePattern, out regex);\n+            }\n+\n+            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n-            // check if there is a regex matching the file\n+            // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.\n             if (_regex != null)\n             {\n                 var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return _regex.IsMatch(normalizedFileToMatch);\n             }\n \n+            if (_filenamePattern != null)\n+            {\n+                // Check file name first as it's more likely to not match.\n+                string filename = Path.GetFileName(fileToMatch);\n+                if (!FileMatcher.IsMatch(filename, _filenamePattern))\n+                {\n+                    return false;\n+                }\n+\n+                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n+                return normalizedFileToMatch.StartsWith(_currentDirectory, System.StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Done, thanks!",
              "createdAt": "2021-02-16T16:29:41Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -12,54 +12,85 @@ namespace Microsoft.Build.Internal\n     {\n         private readonly string _currentDirectory;\n         private readonly string _unescapedFileSpec;\n+        private readonly string _filenamePattern;\n         private readonly Regex _regex;\n         \n-        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex)\n+        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(unescapedFileSpec));\n \n             _currentDirectory = currentDirectory;\n             _unescapedFileSpec = unescapedFileSpec;\n+            _filenamePattern = filenamePattern;\n             _regex = regex;\n         }\n \n         public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec)\n         {\n             string unescapedFileSpec = EscapingUtilities.UnescapeAll(fileSpec);\n-            Regex regex = EngineFileUtilities.FilespecHasWildcards(fileSpec) ? CreateRegex(unescapedFileSpec, currentDirectory) : null;\n+            string filenamePattern = null;\n+            Regex regex = null;\n \n-            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, regex);\n+            if (EngineFileUtilities.FilespecHasWildcards(fileSpec))\n+            {\n+                CreateRegexOrFilenamePattern(unescapedFileSpec, currentDirectory, out filenamePattern, out regex);\n+            }\n+\n+            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n-            // check if there is a regex matching the file\n+            // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.\n             if (_regex != null)\n             {\n                 var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return _regex.IsMatch(normalizedFileToMatch);\n             }\n \n+            if (_filenamePattern != null)\n+            {\n+                // Check file name first as it's more likely to not match.\n+                string filename = Path.GetFileName(fileToMatch);\n+                if (!FileMatcher.IsMatch(filename, _filenamePattern))\n+                {\n+                    return false;\n+                }\n+\n+                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n+                return normalizedFileToMatch.StartsWith(_currentDirectory, System.StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I am switching over from `ImmutableArray<string>` to `IReadOnlyList<string>` because the former is ~4x more expensive to construct from an `IEnumerable`. We don't really use the immutable functionality here as we never \"mutate\" the collection after it's created.",
              "createdAt": "2021-02-16T21:52:05Z",
              "path": "src/Build/Evaluation/Context/EvaluationContext.cs",
              "diffHunk": "@@ -3,7 +3,7 @@\n \n using System;\n using System.Collections.Concurrent;\n-using System.Collections.Immutable;\n+using System.Collections.Generic;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is an unintentional change, will remove next time I update the PR.",
              "createdAt": "2021-02-17T11:50:32Z",
              "path": "src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs",
              "diffHunk": "@@ -338,9 +338,9 @@ public static IEnumerable<object[]> ContextDisambiguatesRelativeGlobsData\n                     new[]\n                     {\n                         new[] {\"0.cs\"}, // first project\n-                        new[] {\"0.cs\", \"1.cs\"}, // second project\n+                        new[] {\"0.cs\", \"1.cs\" }, // second project",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please materialize this ienumerable to avoid multiple enumerations.\r\nI would suggest to materialize into ReadOnlyList as soon as possible to avoid such issues and use IEnumerable only when lazy or partial enumeration is used in code.",
              "createdAt": "2021-02-18T14:56:19Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -509,9 +529,10 @@ GetFileSystemEntries getFileSystemEntries\n                     else\n                     {\n                         // getFileSystemEntries(...) returns an empty array if longPath doesn't exist.\n-                        ImmutableArray<string> entries = getFileSystemEntries(FileSystemEntity.FilesAndDirectories, longPath, parts[i], null, false);\n+                        IEnumerable<string> entries = getFileSystemEntries(FileSystemEntity.FilesAndDirectories, longPath, parts[i], null, false);\n \n-                        if (0 == entries.Length)\n+                        int entriesCount = entries.Count();",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Thank you, yes, that's a great point. I have re-added materialization calls except for places where keeping the `IEnumerable<>` clearly has benefits.",
              "createdAt": "2021-02-22T13:25:29Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -509,9 +529,10 @@ GetFileSystemEntries getFileSystemEntries\n                     else\n                     {\n                         // getFileSystemEntries(...) returns an empty array if longPath doesn't exist.\n-                        ImmutableArray<string> entries = getFileSystemEntries(FileSystemEntity.FilesAndDirectories, longPath, parts[i], null, false);\n+                        IEnumerable<string> entries = getFileSystemEntries(FileSystemEntity.FilesAndDirectories, longPath, parts[i], null, false);\n \n-                        if (0 == entries.Length)\n+                        int entriesCount = entries.Count();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you have numbers on how common this case is versus others? I would guess this is most common, but I'm wondering if something like `<path>\\**.*` might also be common enough to be worth it.",
              "createdAt": "2021-02-18T18:22:10Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2363,7 +2363,25 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n                     }\n                     else\n                     {\n-                        searchesToExclude.Add(excludeState);\n+                        // Optimization: ignore excludes whose file names can never match our filespec. For example, if we're looking\n+                        // for \"**/*.cs\", we don't have to worry about excluding \"{anything}/*.sln\" as the intersection of the two will\n+                        // always be empty.\n+                        string includeFilespec = state.SearchData.Filespec ?? string.Empty;\n+                        string excludeFilespec = excludeState.SearchData.Filespec ?? string.Empty;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The work here was driven by what the .NET SDK uses when building common applications. The full list is in the description of #6069. I'm not sure what you mean by `*.`, is it literally `*.`, so files ending with a dot?\r\n",
              "createdAt": "2021-02-22T13:29:01Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2363,7 +2363,25 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n                     }\n                     else\n                     {\n-                        searchesToExclude.Add(excludeState);\n+                        // Optimization: ignore excludes whose file names can never match our filespec. For example, if we're looking\n+                        // for \"**/*.cs\", we don't have to worry about excluding \"{anything}/*.sln\" as the intersection of the two will\n+                        // always be empty.\n+                        string includeFilespec = state.SearchData.Filespec ?? string.Empty;\n+                        string excludeFilespec = excludeState.SearchData.Filespec ?? string.Empty;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Sorry\u2014it formatted the markdown to look like *., but that wasn't what I'd intended to put.",
              "createdAt": "2021-02-22T15:41:55Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2363,7 +2363,25 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n                     }\n                     else\n                     {\n-                        searchesToExclude.Add(excludeState);\n+                        // Optimization: ignore excludes whose file names can never match our filespec. For example, if we're looking\n+                        // for \"**/*.cs\", we don't have to worry about excluding \"{anything}/*.sln\" as the intersection of the two will\n+                        // always be empty.\n+                        string includeFilespec = state.SearchData.Filespec ?? string.Empty;\n+                        string excludeFilespec = excludeState.SearchData.Filespec ?? string.Empty;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm also wondering how common the case you're looking at here is. My gut tells me it's less common than the last case you considered. Also, could we allow slashes in the interior if we also fix them to be a common form and disallow wild cards?",
              "createdAt": "2021-02-18T19:00:14Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2042,18 +2076,45 @@ enum SearchAction\n                 return SearchAction.ReturnEmptyList;\n             }\n \n+            string directoryPattern = null;\n+            if (wildcardDirectoryPart.Length > 0)\n+            {\n+                // If the wildcard directory part looks like \"**/{pattern}/**\", we are essentially looking for files that have\n+                // a matching directory anywhere on their path. This is commonly used when excluding hidden directories using\n+                // \"**/.*/**\" for example, and is worth special-casing so it doesn't fall into the slow regex logic.\n+                string wildcard = wildcardDirectoryPart.TrimTrailingSlashes();\n+                int wildcardLength = wildcard.Length;\n+                if (wildcardLength > 6 &&\n+                    wildcard[0] == '*' &&\n+                    wildcard[1] == '*' &&\n+                    FileUtilities.IsAnySlash(wildcard[2]) &&\n+                    FileUtilities.IsAnySlash(wildcard[wildcardLength - 3]) &&\n+                    wildcard[wildcardLength - 2] == '*' &&\n+                    wildcard[wildcardLength - 1] == '*')\n+                {\n+                    // Check that there are no other slashes in the wildcard.\n+                    if (wildcard.IndexOfAny(FileUtilities.Slashes, 3, wildcardLength - 6) == -1)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "In .NET SDK, this is the `**/.*/**` pattern used for excluding files from hidden directories, such as `.git`. If we allow slashes in the interior, it's no longer going to be \"do we have a directory on the path matching {some pattern}?\" and things get more complicated because we can't simply check a directory when we're descending into it. I'm actually fine letting this fall into the slow regex case because it's not used in the SDK.",
              "createdAt": "2021-02-22T13:42:22Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2042,18 +2076,45 @@ enum SearchAction\n                 return SearchAction.ReturnEmptyList;\n             }\n \n+            string directoryPattern = null;\n+            if (wildcardDirectoryPart.Length > 0)\n+            {\n+                // If the wildcard directory part looks like \"**/{pattern}/**\", we are essentially looking for files that have\n+                // a matching directory anywhere on their path. This is commonly used when excluding hidden directories using\n+                // \"**/.*/**\" for example, and is worth special-casing so it doesn't fall into the slow regex logic.\n+                string wildcard = wildcardDirectoryPart.TrimTrailingSlashes();\n+                int wildcardLength = wildcard.Length;\n+                if (wildcardLength > 6 &&\n+                    wildcard[0] == '*' &&\n+                    wildcard[1] == '*' &&\n+                    FileUtilities.IsAnySlash(wildcard[2]) &&\n+                    FileUtilities.IsAnySlash(wildcard[wildcardLength - 3]) &&\n+                    wildcard[wildcardLength - 2] == '*' &&\n+                    wildcard[wildcardLength - 1] == '*')\n+                {\n+                    // Check that there are no other slashes in the wildcard.\n+                    if (wildcard.IndexOfAny(FileUtilities.Slashes, 3, wildcardLength - 6) == -1)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels a little like a hammer to me. Maybe a separate method that handles small cases without slashes or complicated wildcards might do? If not, this should work.",
              "createdAt": "2021-02-18T19:26:53Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -13,54 +13,85 @@ namespace Microsoft.Build.Internal\n     {\n         private readonly string _currentDirectory;\n         private readonly string _unescapedFileSpec;\n+        private readonly string _filenamePattern;\n         private readonly Regex _regex;\n         \n-        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex)\n+        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(unescapedFileSpec));\n \n             _currentDirectory = currentDirectory;\n             _unescapedFileSpec = unescapedFileSpec;\n+            _filenamePattern = filenamePattern;\n             _regex = regex;\n         }\n \n         public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec)\n         {\n             string unescapedFileSpec = EscapingUtilities.UnescapeAll(fileSpec);\n-            Regex regex = EngineFileUtilities.FilespecHasWildcards(fileSpec) ? CreateRegex(unescapedFileSpec, currentDirectory) : null;\n+            string filenamePattern = null;\n+            Regex regex = null;\n \n-            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, regex);\n+            if (EngineFileUtilities.FilespecHasWildcards(fileSpec))\n+            {\n+                CreateRegexOrFilenamePattern(unescapedFileSpec, currentDirectory, out filenamePattern, out regex);\n+            }\n+\n+            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n-            // check if there is a regex matching the file\n+            // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.\n             if (_regex != null)\n             {\n                 string normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return _regex.IsMatch(normalizedFileToMatch);\n             }\n \n+            if (_filenamePattern != null)\n+            {\n+                // Check file name first as it's more likely to not match.\n+                string filename = Path.GetFileName(fileToMatch);\n+                if (!FileMatcher.IsMatch(filename, _filenamePattern))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`_filenamePattern` may have complicated wildcards so using `FileMatcher.IsMatch` is a good match (pun intended), as far as I can tell. Feel free to unresolve this comment if I misunderstood.",
              "createdAt": "2021-02-22T13:55:32Z",
              "path": "src/Build/Utilities/FileSpecMatchTester.cs",
              "diffHunk": "@@ -13,54 +13,85 @@ namespace Microsoft.Build.Internal\n     {\n         private readonly string _currentDirectory;\n         private readonly string _unescapedFileSpec;\n+        private readonly string _filenamePattern;\n         private readonly Regex _regex;\n         \n-        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex)\n+        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(unescapedFileSpec));\n \n             _currentDirectory = currentDirectory;\n             _unescapedFileSpec = unescapedFileSpec;\n+            _filenamePattern = filenamePattern;\n             _regex = regex;\n         }\n \n         public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec)\n         {\n             string unescapedFileSpec = EscapingUtilities.UnescapeAll(fileSpec);\n-            Regex regex = EngineFileUtilities.FilespecHasWildcards(fileSpec) ? CreateRegex(unescapedFileSpec, currentDirectory) : null;\n+            string filenamePattern = null;\n+            Regex regex = null;\n \n-            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, regex);\n+            if (EngineFileUtilities.FilespecHasWildcards(fileSpec))\n+            {\n+                CreateRegexOrFilenamePattern(unescapedFileSpec, currentDirectory, out filenamePattern, out regex);\n+            }\n+\n+            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);\n         }\n \n         public bool IsMatch(string fileToMatch)\n         {\n             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));\n \n-            // check if there is a regex matching the file\n+            // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.\n             if (_regex != null)\n             {\n                 string normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));\n                 return _regex.IsMatch(normalizedFileToMatch);\n             }\n \n+            if (_filenamePattern != null)\n+            {\n+                // Check file name first as it's more likely to not match.\n+                string filename = Path.GetFileName(fileToMatch);\n+                if (!FileMatcher.IsMatch(filename, _filenamePattern))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "tiny nit:\r\nIf you give this true as a default value, you don't have to reassign it for the first case.",
              "createdAt": "2021-02-18T19:29:36Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1062,10 +1062,27 @@ struct RecursionState\n             {\n                 return Enumerable.Empty<string>();\n             }\n+\n+            // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending\n+            // on the NeedsToProcessEachFile flag. If the flag is false and matching is done within the _getFileSystemEntries call,\n+            // it is case sensitive. If the flag is true and matching is handled with MatchFileRecursionStep, it is case-insensitive.\n+            // TODO: Can we fix this by using case-insensitive file I/O on Linux?\n+            bool forceFileProcessing = false;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Actually, let's remove the local altogether and use the existing `NeedsToProcessEachFile` field on the struct.",
              "createdAt": "2021-02-22T13:24:06Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1062,10 +1062,27 @@ struct RecursionState\n             {\n                 return Enumerable.Empty<string>();\n             }\n+\n+            // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending\n+            // on the NeedsToProcessEachFile flag. If the flag is false and matching is done within the _getFileSystemEntries call,\n+            // it is case sensitive. If the flag is true and matching is handled with MatchFileRecursionStep, it is case-insensitive.\n+            // TODO: Can we fix this by using case-insensitive file I/O on Linux?\n+            bool forceFileProcessing = false;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit:\r\nUse $\" to prevent intermediate allocation?",
              "createdAt": "2021-02-18T19:35:18Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -110,21 +110,51 @@ internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemE\n \n             _getFileSystemEntries = getFileSystemDirectoryEntriesCache == null\n                 ? getFileSystemEntries\n-                : (type, path, pattern, directory, projectDirectory) =>\n+                : (type, path, pattern, directory, stripProjectDirectory) =>\n                 {\n-                    // Cache only directories, for files we won't hit the cache because the file name patterns tend to be unique\n-                    if (type == FileSystemEntity.Directories)\n+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))\n                     {\n-                        return getFileSystemDirectoryEntriesCache.GetOrAdd(\n-                            $\"{path};{pattern ?? \"*\"}\",\n-                            s => getFileSystemEntries(\n-                                type,\n-                                path,\n-                                pattern,\n-                                directory,\n-                                projectDirectory).ToArray());\n+                        // New behavior:\n+                        // Always hit the filesystem with \"*\" pattern, cache the results, and do the filtering here.\n+                        string cacheKey = type switch\n+                        {\n+                            FileSystemEntity.Files => \"F\",\n+                            FileSystemEntity.Directories => \"D\",\n+                            FileSystemEntity.FilesAndDirectories => \"A\",\n+                            _ => throw new NotImplementedException()\n+                        } + \";\" + path;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The compiler generates a call to `String.Concat(string, string, string)` in both cases: https://sharplab.io/#v2:C4LglgNgPgAgTARgLACgYGYAE9MGFMDeqmJ2WMCADJgLIIAUF1AzggDTZWbNwCUhxUkJgB2bgkwBqTACIA3DKnc4cwSQC+qNWU7UacRl1Ycmy/kRRDhYgCQyCrdXIdx187ZpTqgA\r\n\r\nIn cases where most of the expression is literal, I find `$\"` useful, e.g. `$\"Hello {name}, how are you?\"`. Otherwise, when there's only a little literal string and there's no perf impact, I prefer the good old `+`.",
              "createdAt": "2021-02-22T13:19:34Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -110,21 +110,51 @@ internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemE\n \n             _getFileSystemEntries = getFileSystemDirectoryEntriesCache == null\n                 ? getFileSystemEntries\n-                : (type, path, pattern, directory, projectDirectory) =>\n+                : (type, path, pattern, directory, stripProjectDirectory) =>\n                 {\n-                    // Cache only directories, for files we won't hit the cache because the file name patterns tend to be unique\n-                    if (type == FileSystemEntity.Directories)\n+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))\n                     {\n-                        return getFileSystemDirectoryEntriesCache.GetOrAdd(\n-                            $\"{path};{pattern ?? \"*\"}\",\n-                            s => getFileSystemEntries(\n-                                type,\n-                                path,\n-                                pattern,\n-                                directory,\n-                                projectDirectory).ToArray());\n+                        // New behavior:\n+                        // Always hit the filesystem with \"*\" pattern, cache the results, and do the filtering here.\n+                        string cacheKey = type switch\n+                        {\n+                            FileSystemEntity.Files => \"F\",\n+                            FileSystemEntity.Directories => \"D\",\n+                            FileSystemEntity.FilesAndDirectories => \"A\",\n+                            _ => throw new NotImplementedException()\n+                        } + \";\" + path;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "RegularExpressionFromFileSpec starts by checking whether IsLegalFileSpec(...). It's private and hardly used. Could we pull that out here so we don't check that twice?",
              "createdAt": "2021-02-18T19:47:18Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1486,12 +1479,18 @@ private static int LastIndexOfDirectoryOrRecursiveSequence(string str, int start\n             out bool isLegalFileSpec)\n         {\n             GetFileSpecInfo(filespec,\n-                out _, out _, out _,\n-                out string matchFileExpression, out needsRecursion, out isLegalFileSpec);\n-            \n-            regexFileMatch = isLegalFileSpec\n-                ? new Regex(matchFileExpression, DefaultRegexOptions)\n-                : null;\n+                out string fixedDirectoryPart, out string wildcardDirectoryPart, out string filenamePart,\n+                out needsRecursion, out isLegalFileSpec);\n+\n+            if (isLegalFileSpec)\n+            {\n+                string matchFileExpression = RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Actually, I think you can just delete it. It seems to be checked before every call.",
              "createdAt": "2021-02-18T19:48:42Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1486,12 +1479,18 @@ private static int LastIndexOfDirectoryOrRecursiveSequence(string str, int start\n             out bool isLegalFileSpec)\n         {\n             GetFileSpecInfo(filespec,\n-                out _, out _, out _,\n-                out string matchFileExpression, out needsRecursion, out isLegalFileSpec);\n-            \n-            regexFileMatch = isLegalFileSpec\n-                ? new Regex(matchFileExpression, DefaultRegexOptions)\n-                : null;\n+                out string fixedDirectoryPart, out string wildcardDirectoryPart, out string filenamePart,\n+                out needsRecursion, out isLegalFileSpec);\n+\n+            if (isLegalFileSpec)\n+            {\n+                string matchFileExpression = RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The check is already gone, were you maybe looking at an older version of the PR. Thanks!",
              "createdAt": "2021-02-22T13:22:25Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -1486,12 +1479,18 @@ private static int LastIndexOfDirectoryOrRecursiveSequence(string str, int start\n             out bool isLegalFileSpec)\n         {\n             GetFileSpecInfo(filespec,\n-                out _, out _, out _,\n-                out string matchFileExpression, out needsRecursion, out isLegalFileSpec);\n-            \n-            regexFileMatch = isLegalFileSpec\n-                ? new Regex(matchFileExpression, DefaultRegexOptions)\n-                : null;\n+                out string fixedDirectoryPart, out string wildcardDirectoryPart, out string filenamePart,\n+                out needsRecursion, out isLegalFileSpec);\n+\n+            if (isLegalFileSpec)\n+            {\n+                string matchFileExpression = RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It would be nice to add / find existing tests that hits this condition on a couple of cases:\r\n- non empty text after last wildcard\r\n- empty text after last wildcard",
              "createdAt": "2021-02-20T02:28:07Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2363,7 +2363,25 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n                     }\n                     else\n                     {\n-                        searchesToExclude.Add(excludeState);\n+                        // Optimization: ignore excludes whose file names can never match our filespec. For example, if we're looking\n+                        // for \"**/*.cs\", we don't have to worry about excluding \"{anything}/*.sln\" as the intersection of the two will\n+                        // always be empty.\n+                        string includeFilespec = state.SearchData.Filespec ?? string.Empty;\n+                        string excludeFilespec = excludeState.SearchData.Filespec ?? string.Empty;\n+                        int compareLength = Math.Min(\n+                            includeFilespec.Length - includeFilespec.LastIndexOfAny(s_wildcardCharacters) - 1,\n+                            excludeFilespec.Length - excludeFilespec.LastIndexOfAny(s_wildcardCharacters) - 1);\n+                        if (string.Compare(",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Great point, added two new `GetFilesComplexGlobbingMatchingInfo`'s exercising this code path.",
              "createdAt": "2021-02-22T15:38:05Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2363,7 +2363,25 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n                     }\n                     else\n                     {\n-                        searchesToExclude.Add(excludeState);\n+                        // Optimization: ignore excludes whose file names can never match our filespec. For example, if we're looking\n+                        // for \"**/*.cs\", we don't have to worry about excluding \"{anything}/*.sln\" as the intersection of the two will\n+                        // always be empty.\n+                        string includeFilespec = state.SearchData.Filespec ?? string.Empty;\n+                        string excludeFilespec = excludeState.SearchData.Filespec ?? string.Empty;\n+                        int compareLength = Math.Min(\n+                            includeFilespec.Length - includeFilespec.LastIndexOfAny(s_wildcardCharacters) - 1,\n+                            excludeFilespec.Length - excludeFilespec.LastIndexOfAny(s_wildcardCharacters) - 1);\n+                        if (string.Compare(",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What if there's multiple directory patterns like `**/{pattern1}/**/{pattern2}/**`",
              "createdAt": "2021-02-20T02:34:25Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -764,6 +766,11 @@ bool needsRecursion\n             /// </summary>\n             public string Filespec { get; }\n             /// <summary>\n+            /// Holds the directory pattern for globs like **/{pattern}/**, i.e. when we're looking for a matching directory name",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Oh, as directory traversal descends one FilesSearchData instance will have it set to `pattern1`, then a later instance will have it set to `pattern2`, right? Remembering this code brings up some PTSD :P",
              "createdAt": "2021-02-20T02:41:37Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -764,6 +766,11 @@ bool needsRecursion\n             /// </summary>\n             public string Filespec { get; }\n             /// <summary>\n+            /// Holds the directory pattern for globs like **/{pattern}/**, i.e. when we're looking for a matching directory name",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I am not optimizing `**/{pattern1}/**/{pattern2}/**` in this PR. This one I'm fine being handled by the slow regex path because it's not used by the .NET SDK and overall doesn't feel like something common (I have no data to back it up, just a gut feeling).\r\n\r\nI think that you're right that it could be done without regex'es, although I'm sure there are many gotchas that prevent it from working simply by peeling the path components one by one as we're descending. For example, the `**` should not do eager matching so you still generally need a \"lookahead\". It may happen that you've descended multiple levels and everything matched but then you find a mismatch that could have been prevented by going back and changing your mind about a component matching against `**` or not.",
              "createdAt": "2021-02-22T14:05:39Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -764,6 +766,11 @@ bool needsRecursion\n             /// </summary>\n             public string Filespec { get; }\n             /// <summary>\n+            /// Holds the directory pattern for globs like **/{pattern}/**, i.e. when we're looking for a matching directory name",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Might help to make the comment more explicit that the field is only applicable for that particular optimization and it's not part of the general flow",
              "createdAt": "2021-02-22T23:50:33Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -764,6 +766,11 @@ bool needsRecursion\n             /// </summary>\n             public string Filespec { get; }\n             /// <summary>\n+            /// Holds the directory pattern for globs like **/{pattern}/**, i.e. when we're looking for a matching directory name",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Done, thank you.",
              "createdAt": "2021-02-23T12:35:17Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -764,6 +766,11 @@ bool needsRecursion\n             /// </summary>\n             public string Filespec { get; }\n             /// <summary>\n+            /// Holds the directory pattern for globs like **/{pattern}/**, i.e. when we're looking for a matching directory name",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Add / find tests that hit the newly added conditions.",
              "createdAt": "2021-02-20T02:47:03Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -892,6 +910,12 @@ struct RecursionState\n                 newRecursionState.BaseDirectory = subdir;\n                 newRecursionState.RemainingWildcardDirectory = nextStep.RemainingWildcardDirectory;\n \n+                if (newRecursionState.IsLookingForMatchingDirectory &&",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "This is well covered with `RecursiveDirRecursive` and more.\r\n\r\nhttps://github.com/dotnet/msbuild/blob/f0eebf2872d76ab0cd43fdc4153ba636232b222f/src/Shared/UnitTests/FileMatcher_Tests.cs#L1021-L1033",
              "createdAt": "2021-02-22T15:56:31Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -892,6 +910,12 @@ struct RecursionState\n                 newRecursionState.BaseDirectory = subdir;\n                 newRecursionState.RemainingWildcardDirectory = nextStep.RemainingWildcardDirectory;\n \n+                if (newRecursionState.IsLookingForMatchingDirectory &&",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "no Hoho :)",
              "createdAt": "2021-02-22T23:58:01Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2457,6 +2457,10 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n                             // The suffix is the same so there is a possibility that the two will match the same files.\n                             searchesToExclude.Add(excludeState);\n                         }\n+                        else\n+                        {\n+                            Console.Write(\"Hoho\");",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "And now you know how I debug my code :D Removed!",
              "createdAt": "2021-02-23T12:36:56Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2457,6 +2457,10 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n                             // The suffix is the same so there is a possibility that the two will match the same files.\n                             searchesToExclude.Add(excludeState);\n                         }\n+                        else\n+                        {\n+                            Console.Write(\"Hoho\");",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}