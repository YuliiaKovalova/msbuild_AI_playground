{
  "number": 5853,
  "title": "Improve performance of projects with large numbers of consecutive item updates without wildcards Fixes #5776",
  "body": "This PR changed the process of applying consecutive UpdateOperations on distinct fragments without wildcards.\r\n\r\nPreviously, each one was applied individually, so if there were a large number of items and a large number of updates, this would take time proportional to the product of the two. Now, those update operations are batched together in a dictionary such that we only have to make one pass to apply all the update operations at once. In other words, time would then be proportional to the number of items but not the number of updates.\r\n\r\nNote that this is very specific to update operations in sequence without wildcards or other characters indicating that we might need to expand them. Interleaving RemoveOperations, for instance, would effectively run the older, unoptimized code. This is because the UpdateOperations are added to the batch in sequence, but if an operation that cannot be added to the batch is next, it pauses to evaluate all the operations in the batch. This ensures we respect ordering of operations.\r\n\r\nUpdating the same fragment twice isn't permitted in a single batch because then we would have to keep track of whether the second update would overwrite the first or not, and if so, apply them in the correct order.\r\n\r\nTime to add/delete a class decreased to 1-3 seconds, thus fixing #5776",
  "state": "MERGED",
  "createdAt": "2020-11-03T23:08:15Z",
  "updatedAt": "2021-01-09T01:16:30Z",
  "closedAt": "2021-01-09T01:16:29Z",
  "mergedAt": "2021-01-09T01:16:29Z",
  "additions": 265,
  "deletions": 43,
  "changedFiles": 8,
  "headRefName": "winform-perf",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "1cc6fd005435bd394d4dfd04d46070aa76d1ff6f",
          "message": "Use a dictionary to store update operations that don't include wild cards and perform them in mini-batches.\n\nPerforming all item updates at the end breaks the ordering guarantee, both between update operations (if some included globs or wild cards) and between update operations and other operations. This retains that by pausing to perform the relevant updates between non-batchable updates and other operations.",
          "committedDate": "2020-11-04T16:27:32Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "68d8d327c63be96a97526fb66209fe2877bbf6a3",
          "message": "Add tests\n\nTests that mixing items with globs as they're updated either as a group of individually applies all updates correctly (even when mixed with Includes) and follows the order in which they're updated.",
          "committedDate": "2020-11-04T16:39:19Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2128721594c6e55cd6034bb052a3990909f4e51e",
          "message": "PR feedback",
          "committedDate": "2020-11-05T22:01:23Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b69cf223b57531ac9fe14feba74abd05e9e41047",
          "message": "Another test",
          "committedDate": "2020-11-05T22:01:30Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e4816f225d8466e7eadf6fef7b1fe401fc7b8abe",
          "message": "Make case-insensitive?\n\nThis isn't the cleanest change; if it works, I should change it.",
          "committedDate": "2020-11-06T21:16:04Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2f91f98cc24ad20cac6183badd5b47a37ffe9b2a",
          "message": "stringcomparison",
          "committedDate": "2020-11-06T21:42:52Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c4763c09ec283b029a701243665d49da19b4c607",
          "message": "Should ALWAYS be case-insensitive",
          "committedDate": "2020-11-11T00:55:38Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fa1eb3bc13b31c31256c9217a575de348855ae25",
          "message": "Update src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs\n\nCo-authored-by: Ben Villalobos <4691428+BenVillalobos@users.noreply.github.com>",
          "committedDate": "2020-11-16T16:56:28Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d6a7a463da9759969ed99ff24958fff1d2444448",
          "message": "Clean up case-insensitive path comparison slightly",
          "committedDate": "2020-11-25T00:50:11Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "afd6a699e80cd879289e009d54ebb884319c7998",
          "message": "comments and error",
          "committedDate": "2020-11-25T01:02:59Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "78419149e19ff728c71d6cb38ae81386e03b892c",
          "message": "Apply suggestions from code review",
          "committedDate": "2020-12-04T23:51:08Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "61b9ecad9120a56f8a3026c8dcda5b1f59d1468e",
          "message": "Merge https://github.com/dotnet/msbuild into winform-perf",
          "committedDate": "2020-12-07T21:14:49Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9e5fe73e1764906f1cb4678e78e360e11a3d50ce",
          "message": "Update Win32.Registry version",
          "committedDate": "2020-12-07T21:33:00Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "07d392739ce8de347d13f2778453ffd771a1623d",
          "message": "Simplify assert",
          "committedDate": "2020-12-11T00:19:59Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e0bf4618a27177a3a089238c5a0f0bf353d2cb9c",
          "message": "update name and undo package update",
          "committedDate": "2021-01-09T00:13:46Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Within an ItemGroup, you can have things like `<whatever Include=\"thing\" />`, and Include can be replaced by Remove or Update. This is at that step when figuring out, after putting them all together, what should be in the Item and what its metadata should be.\r\n\r\nAny particular points you think need comments?",
        "createdAt": "2020-11-20T15:53:33Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "RPS in progress:\r\nhttps://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequest/295246?_a=overview",
        "createdAt": "2020-12-30T23:36:13Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "It's a very strong convention in .NET that names like `IWhatever` are interfaces.\r\n\r\n```suggestion\r\n            internal ItemSpec<P, I> ItemSpec => _itemSpec;\r\n```\r\n\r\nOr even just `Spec`?",
              "createdAt": "2020-11-03T23:11:23Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs",
              "diffHunk": "@@ -30,7 +30,7 @@ private abstract class LazyItemOperation : IItemOperation\n             //  This is used only when evaluating an expression, which instantiates\n             //  the items and then removes them\n             protected readonly IItemFactory<I, I> _itemFactory;\n-\n+            internal ItemSpec<P, I> ISpec => _itemSpec;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I tried ItemSpec when I first introduced ISpec but quickly realized that's a type hence not reusable. I can change it to Spec.",
              "createdAt": "2020-11-05T18:14:37Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs",
              "diffHunk": "@@ -30,7 +30,7 @@ private abstract class LazyItemOperation : IItemOperation\n             //  This is used only when evaluating an expression, which instantiates\n             //  the items and then removes them\n             protected readonly IItemFactory<I, I> _itemFactory;\n-\n+            internal ItemSpec<P, I> ISpec => _itemSpec;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Deleted to avoid merge conflict.",
              "createdAt": "2020-11-04T19:27:41Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -16,7 +16,6 @@\n using Shouldly;\n using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;\n using Xunit;\n-using System.Runtime.InteropServices;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why did this need to change?",
              "createdAt": "2020-11-04T19:45:36Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -151,15 +151,15 @@ public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initial\n \n         private class MemoizedOperation : IItemOperation\n         {\n-            public IItemOperation Operation { get; }\n+            public LazyItemOperation Operation { get; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I initially made the change when I wanted to batch different types of operations, since that would mean I could have a map from string to LazyItemOperation more easily. When I switched to only batching Update, I didn't see any reason to change it back. Is there one?",
              "createdAt": "2020-11-05T18:17:34Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -151,15 +151,15 @@ public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initial\n \n         private class MemoizedOperation : IItemOperation\n         {\n-            public IItemOperation Operation { get; }\n+            public LazyItemOperation Operation { get; }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it interesting to have an interleaving in another test where you update `i/a` and `i/b`, then capture `@(i)` then update `i/c` and make sure the captured one doesn't have that update?",
              "createdAt": "2020-11-05T17:53:24Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -2607,6 +2606,141 @@ public void LastUpdateWins()\n             ObjectModelHelpers.AssertItemHasMetadata(expectedUpdate, items[0]);\n         }\n \n+        [Theory]\n+        [InlineData(\"abc\", \"def\", \"abc\")]\n+        [InlineData(\"abc\", \"de*\", \"abc\")]\n+        [InlineData(\"a*c\", \"def\", \"abc\")]\n+        [InlineData(\"abc\", \"def\", \"*bc\")]\n+        [InlineData(\"abc\", \"d*f\", \"*bc\")]\n+        [InlineData(\"*c\", \"d*f\", \"*bc\")]\n+        [InlineData(\"a*\", \"d*\", \"abc\")]\n+        public void UpdatesProceedInOrder(string first, string second, string third)\n+        {\n+            string contents = $@\"\n+<i Include='abc'>\n+    <m1>m1_contents</m1>\n+</i>\n+<j Include='def'>\n+    <m1>m1_contents</m1>\n+</j>\n+<i Update='{first}'>\n+    <m1>first</m1>\n+</i>\n+<j Update='{second}'>\n+    <m1>second</m1>\n+</j>\n+<i Update='{third}'>\n+    <m1>third</m1>\n+</i>\n+\";\n+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(contents, allItems: true);\n+            Dictionary<string, string> expectedUpdatei = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"third\" }\n+            };\n+            Dictionary<string, string> expectedUpdatej = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"second\" }\n+            };\n+\n+            ObjectModelHelpers.AssertItemHasMetadata(expectedUpdatei, items[0]);\n+            ObjectModelHelpers.AssertItemHasMetadata(expectedUpdatej, items[1]);\n+        }\n+\n+        [Fact]\n+        public void UpdatingIndividualItemsProceedsInOrder()\n+        {\n+            string contents = @\"\n+<i Include='a;b;c'>\n+    <m1>m1_contents</m1>\n+</i>\n+<i Update='a'>\n+    <m1>second</m1>\n+</i>\n+<i Update='b'>\n+    <m1>third</m1>\n+</i>\n+<i Update='c'>\n+    <m1>fourth</m1>\n+</i>\n+<afterFirst Include='@(i)' />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'd say that's captured by `AfterThirdc`, which has the result after updating `i/b` but before updating `i/c` and therefore shouldn't have that update.",
              "createdAt": "2020-11-05T21:52:26Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -2607,6 +2606,141 @@ public void LastUpdateWins()\n             ObjectModelHelpers.AssertItemHasMetadata(expectedUpdate, items[0]);\n         }\n \n+        [Theory]\n+        [InlineData(\"abc\", \"def\", \"abc\")]\n+        [InlineData(\"abc\", \"de*\", \"abc\")]\n+        [InlineData(\"a*c\", \"def\", \"abc\")]\n+        [InlineData(\"abc\", \"def\", \"*bc\")]\n+        [InlineData(\"abc\", \"d*f\", \"*bc\")]\n+        [InlineData(\"*c\", \"d*f\", \"*bc\")]\n+        [InlineData(\"a*\", \"d*\", \"abc\")]\n+        public void UpdatesProceedInOrder(string first, string second, string third)\n+        {\n+            string contents = $@\"\n+<i Include='abc'>\n+    <m1>m1_contents</m1>\n+</i>\n+<j Include='def'>\n+    <m1>m1_contents</m1>\n+</j>\n+<i Update='{first}'>\n+    <m1>first</m1>\n+</i>\n+<j Update='{second}'>\n+    <m1>second</m1>\n+</j>\n+<i Update='{third}'>\n+    <m1>third</m1>\n+</i>\n+\";\n+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(contents, allItems: true);\n+            Dictionary<string, string> expectedUpdatei = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"third\" }\n+            };\n+            Dictionary<string, string> expectedUpdatej = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"second\" }\n+            };\n+\n+            ObjectModelHelpers.AssertItemHasMetadata(expectedUpdatei, items[0]);\n+            ObjectModelHelpers.AssertItemHasMetadata(expectedUpdatej, items[1]);\n+        }\n+\n+        [Fact]\n+        public void UpdatingIndividualItemsProceedsInOrder()\n+        {\n+            string contents = @\"\n+<i Include='a;b;c'>\n+    <m1>m1_contents</m1>\n+</i>\n+<i Update='a'>\n+    <m1>second</m1>\n+</i>\n+<i Update='b'>\n+    <m1>third</m1>\n+</i>\n+<i Update='c'>\n+    <m1>fourth</m1>\n+</i>\n+<afterFirst Include='@(i)' />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this the right approach, or should it be a dictionary of lists of operations? This basically falls back to the current behavior, right?",
              "createdAt": "2020-11-05T18:01:33Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(FileUtilities.GetIsFileSystemCaseSensitive() ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.ISpec.Fragments.Count; i++)\n+                        {\n+                            ItemSpecFragment frag = op.ISpec.Fragments[i];\n+                            if (MSBuildConstants.CharactersForExpansion.Any(frag.TextFragment.Contains))\n+                            {\n+                                // Fragment contains wild cards, items, or properties. Cannot batch over it using a dictionary.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+\n+                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);\n+                            if (itemsWithNoWildcards.ContainsKey(fullPath))\n+                            {\n+                                // Another update will already happen on this path. Make that happen before evaluating this one.\n+                                addToBatch = false;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I think a dictionary of lists of operations would be asymptotically better, but with exactly 0 evidence, it feels unusual to have a large number of item updates to the same fragment in a row with nothing between them. Note that each time this happens, it resets, so we evaluate the current batch and move on; it doesn't prevent another mini-batch later. Having lists of operations would also be more complicated and noticeably increase allocations (a list for every fragment without a wildcard in an update operation), so I don't think it's worth it. I could do something in-between and immediately evaluate the mini-batch when I see a duplicate and add it to the next mini-batch, but I'm not sure it's worth it. (If I'm wrong about how common this sort of thing is, I'd be happy to make the change.)",
              "createdAt": "2020-11-05T21:58:55Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(FileUtilities.GetIsFileSystemCaseSensitive() ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.ISpec.Fragments.Count; i++)\n+                        {\n+                            ItemSpecFragment frag = op.ISpec.Fragments[i];\n+                            if (MSBuildConstants.CharactersForExpansion.Any(frag.TextFragment.Contains))\n+                            {\n+                                // Fragment contains wild cards, items, or properties. Cannot batch over it using a dictionary.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+\n+                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);\n+                            if (itemsWithNoWildcards.ContainsKey(fullPath))\n+                            {\n+                                // Another update will already happen on this path. Make that happen before evaluating this one.\n+                                addToBatch = false;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This reasoning feels fine to me--leave as is.",
              "createdAt": "2020-11-16T17:48:45Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(FileUtilities.GetIsFileSystemCaseSensitive() ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.ISpec.Fragments.Count; i++)\n+                        {\n+                            ItemSpecFragment frag = op.ISpec.Fragments[i];\n+                            if (MSBuildConstants.CharactersForExpansion.Any(frag.TextFragment.Contains))\n+                            {\n+                                // Fragment contains wild cards, items, or properties. Cannot batch over it using a dictionary.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+\n+                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);\n+                            if (itemsWithNoWildcards.ContainsKey(fullPath))\n+                            {\n+                                // Another update will already happen on this path. Make that happen before evaluating this one.\n+                                addToBatch = false;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this correct? Is a check like this elsewhere what causes #5749, which seems to be a regression?",
              "createdAt": "2020-11-05T18:03:37Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(FileUtilities.GetIsFileSystemCaseSensitive() ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Now you mention it, I'm actually surprised this works. I put this in after [this test](https://github.com/dotnet/msbuild/blob/4f8cdfdc331b5700826be2c192b94f16034b9905/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs#L2819-L2840) failed, but I initially misread it as saying it should be case-sensitive on linux and case-insensitive on windows, and then it apparently passed. I should add another test to make this fail, then correct this line.",
              "createdAt": "2020-11-05T18:30:08Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(FileUtilities.GetIsFileSystemCaseSensitive() ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are these fragments coming from multiple different elements, or a single one? The way I read it this applies to like `<I Update=\"a;b;c*;d\" />` so I don't see how it applies to `<I Update=\"a\" /><I Update=\"b\" /><I Update=\"c*\" /><I Update=\"d\" />`. Misunderstanding on my part?",
              "createdAt": "2020-11-05T18:06:52Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(FileUtilities.GetIsFileSystemCaseSensitive() ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.ISpec.Fragments.Count; i++)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "No, you're right. It applies to `<I Update=\"a;b;c*;d\" />`, but then if there aren't any globs, it doesn't do anything else, just goes to the next operation. If the next operation also happens to be an Update and not have any globs, then the two are batched together in the dictionary. For your second case, this loop would run once for `a`, then run for `b`, then try to run for `c*` but realize it has a glob, quickly do the update for (a and b), do the update for c*, then proceed with d, possibly doing the update immediately or including it in a future batch depending on if there are other Updates without wildcards after it.",
              "createdAt": "2020-11-05T18:25:03Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(FileUtilities.GetIsFileSystemCaseSensitive() ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.ISpec.Fragments.Count; i++)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels off to me but I can't articulate why so it's probably fine.",
              "createdAt": "2020-11-05T18:08:38Z",
              "path": "src/Shared/Constants.cs",
              "diffHunk": "@@ -97,6 +97,7 @@ internal static class MSBuildConstants\n         internal static readonly char[] ForwardSlash = { '/' };\n         internal static readonly char[] ForwardSlashBackslash = { '/', '\\\\' };\n         internal static readonly char[] WildcardChars = { '*', '?' };\n+        internal static readonly string[] CharactersForExpansion = { \"*\", \"?\", \"$(\", \"@(\", \"%\" };",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It would probably be more robust to explicitly (try to) expand every item spec fragment and see if it changed from the original, but at that point, I'm doing a nontrivial amount of the work for the whole operation, which felt undesirable from a perf perspective.",
              "createdAt": "2020-11-05T18:20:53Z",
              "path": "src/Shared/Constants.cs",
              "diffHunk": "@@ -97,6 +97,7 @@ internal static class MSBuildConstants\n         internal static readonly char[] ForwardSlash = { '/' };\n         internal static readonly char[] ForwardSlashBackslash = { '/', '\\\\' };\n         internal static readonly char[] WildcardChars = { '*', '?' };\n+        internal static readonly string[] CharactersForExpansion = { \"*\", \"?\", \"$(\", \"@(\", \"%\" };",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This can possibly break linux here. If on disk, you have both `a` and `A`, this will break matching them properly there.",
              "createdAt": "2020-11-07T19:59:25Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -338,7 +338,7 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n-                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(FileUtilities.GetIsFileSystemCaseSensitive() ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);\n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "I believe it should be case-insensitive on any platform. There's a bug about that [here](https://github.com/dotnet/msbuild/issues/5749).",
              "createdAt": "2020-11-10T16:05:19Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -338,7 +338,7 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n-                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(FileUtilities.GetIsFileSystemCaseSensitive() ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);\n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit:\r\n```suggestion\r\n            internal ItemSpec<P, I> Spec => _itemSpec;\r\n            \r\n            protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)\r\n```",
              "createdAt": "2020-11-13T17:35:02Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs",
              "diffHunk": "@@ -30,7 +30,7 @@ private abstract class LazyItemOperation : IItemOperation\n             //  This is used only when evaluating an expression, which instantiates\n             //  the items and then removes them\n             protected readonly IItemFactory<I, I> _itemFactory;\n-\n+            internal ItemSpec<P, I> Spec => _itemSpec;\n             protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Double checking my own review of this file, it looks like the only changes made here are caching the items needed to update and reorganizing some code into functions?",
              "createdAt": "2020-11-13T20:00:23Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs",
              "diffHunk": "@@ -15,6 +15,9 @@ internal partial class LazyItemEvaluator<P, I, M, D>\n         class UpdateOperation : LazyItemOperation\n         {\n             private readonly ImmutableList<ProjectMetadataElement> _metadata;\n+            private ImmutableList<ItemBatchingContext>.Builder _itemsToUpdate = null;\n+            private ItemSpecMatchesItem _matchItemSpec = null;\n+            private bool? _needToExpandMetadataForEachItem = null;",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Also: +10 points for general code cleanup of legacy code.",
              "createdAt": "2020-11-13T20:03:53Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs",
              "diffHunk": "@@ -15,6 +15,9 @@ internal partial class LazyItemEvaluator<P, I, M, D>\n         class UpdateOperation : LazyItemOperation\n         {\n             private readonly ImmutableList<ProjectMetadataElement> _metadata;\n+            private ImmutableList<ItemBatchingContext>.Builder _itemsToUpdate = null;\n+            private ItemSpecMatchesItem _matchItemSpec = null;\n+            private bool? _needToExpandMetadataForEachItem = null;",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Yep, pretty much. I should note that I didn't do the caching part because of expected perf gains but because I wanted to access these from different functions.",
              "createdAt": "2020-11-16T16:25:51Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs",
              "diffHunk": "@@ -15,6 +15,9 @@ internal partial class LazyItemEvaluator<P, I, M, D>\n         class UpdateOperation : LazyItemOperation\n         {\n             private readonly ImmutableList<ProjectMetadataElement> _metadata;\n+            private ImmutableList<ItemBatchingContext>.Builder _itemsToUpdate = null;\n+            private ItemSpecMatchesItem _matchItemSpec = null;\n+            private bool? _needToExpandMetadataForEachItem = null;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm having a bit of trouble parsing why this is needed. Could you explain this with a small example of what happens here? You iterate through all fragments until you find one that's already going to be updated, then remove everything that came before it? I think my issue is I can't picture what exactly these fragments are. ie. is `**` a fragment, is a filename a fragment, etc.",
              "createdAt": "2020-11-13T20:01:37Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.Spec.Fragments.Count; i++)\n+                        {\n+                            ItemSpecFragment frag = op.Spec.Fragments[i];\n+                            if (MSBuildConstants.CharactersForExpansion.Any(frag.TextFragment.Contains))\n+                            {\n+                                // Fragment contains wild cards, items, or properties. Cannot batch over it using a dictionary.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+\n+                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);\n+                            if (itemsWithNoWildcards.ContainsKey(fullPath))\n+                            {\n+                                // Another update will already happen on this path. Make that happen before evaluating this one.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+                            else\n+                            {\n+                                itemsWithNoWildcards.Add(fullPath, op);\n+                            }\n+                        }\n+                        if (!addToBatch)\n+                        {\n+                            // Remove items added before realizing we couldn't skip the item list\n+                            for (int j = 0; j < i; j++)\n+                            {\n+                                itemsWithNoWildcards.Remove(currentList._memoizedOperation.Operation.Spec.Fragments[j].TextFragment);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "This is a (minor) perf optimization and also a minor correctness fix. There can be lists of fragments with some having wildcards and some not having wildcards. If I see some without wildcards first, I add them to a larger batch to be processed later. The normal UpdateOperation, when applied, includes all fragments, so if we added some to a batch to be processed later, then discover we can't add the rest to a batch, we'll have to do all the fragments in that item anyway when we apply it. (I haven't added anything to only do a partial update at this point\u2014that would require a more complicated change to UpdateOperation.) That means first that there's no reason to apply the fragments that we added if we're about to do it anyway, and it's also best to avoid applying a single update twice. This removes the fragments we added to the batch from the item operation currently being processed that, it turns out, can't be processed as part of a batch. Does that make sense? ",
              "createdAt": "2020-11-16T16:54:47Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.Spec.Fragments.Count; i++)\n+                        {\n+                            ItemSpecFragment frag = op.Spec.Fragments[i];\n+                            if (MSBuildConstants.CharactersForExpansion.Any(frag.TextFragment.Contains))\n+                            {\n+                                // Fragment contains wild cards, items, or properties. Cannot batch over it using a dictionary.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+\n+                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);\n+                            if (itemsWithNoWildcards.ContainsKey(fullPath))\n+                            {\n+                                // Another update will already happen on this path. Make that happen before evaluating this one.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+                            else\n+                            {\n+                                itemsWithNoWildcards.Add(fullPath, op);\n+                            }\n+                        }\n+                        if (!addToBatch)\n+                        {\n+                            // Remove items added before realizing we couldn't skip the item list\n+                            for (int j = 0; j < i; j++)\n+                            {\n+                                itemsWithNoWildcards.Remove(currentList._memoizedOperation.Operation.Spec.Fragments[j].TextFragment);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this call necessary?",
              "createdAt": "2020-11-13T20:02:00Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -359,9 +404,26 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);\n                 }\n \n+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Definitely. If the last operation were an update operation without wildcards, omitting this would make it have no effect.",
              "createdAt": "2020-11-16T16:56:03Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -359,9 +404,26 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);\n                 }\n \n+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I'd add a comment saying as much.",
              "createdAt": "2020-11-21T00:22:19Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -359,9 +404,26 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);\n                 }\n \n+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Emphasizing this.",
              "createdAt": "2020-12-04T17:15:33Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -359,9 +404,26 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);\n                 }\n \n+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you name this more explicitly?",
              "createdAt": "2020-11-16T17:46:11Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -2842,6 +2976,25 @@ public void UpdateFromReferencedItemShouldBeCaseInsensitive()\n             ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataA, items[1]);\n         }\n \n+        [Fact]\n+        public void UpdateFromReferencedItemShouldBeCaseInsensitive2()",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm concerned about this removal. Isn't it a behavior change?",
              "createdAt": "2020-11-16T17:47:20Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -3180,28 +3333,15 @@ public void UpdateAndRemoveShouldUseCaseInsensitiveMatching()\n \n             IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content);\n \n-            if (FileUtilities.GetIsFileSystemCaseSensitive())",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes, but we decided this was best. See https://github.com/dotnet/msbuild/pull/5888#issuecomment-733239622",
              "createdAt": "2021-01-08T23:15:10Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -3180,28 +3333,15 @@ public void UpdateAndRemoveShouldUseCaseInsensitiveMatching()\n \n             IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content);\n \n-            if (FileUtilities.GetIsFileSystemCaseSensitive())",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Thinking out loud: Should this function check if `itemsWithNoWildcards` somehow mistakenly receives an item with a wildcard? It should be fine considering it's a private function.",
              "createdAt": "2020-11-20T04:02:08Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -359,9 +404,26 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);\n                 }\n \n+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);\n+\n                 return items;\n             }\n \n+            private static void ProcessNonWildCardItemUpdates(Dictionary<string, UpdateOperation> itemsWithNoWildcards, ImmutableList<ItemData>.Builder items)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "It could...I don't have a strong opinion. If there is a fragment with a wild card, I'd suggest failing hard, but it's a private method that I don't anticipate being used elsewhere with a very clear name (NoWildcards) so we shouldn't have a problem. It would also be a perf hit, since we'd be checking every fragment. On the other hand, safe is generally better than sorry, and someone could theoretically mangle this in the future.",
              "createdAt": "2020-11-20T15:50:33Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -359,9 +404,26 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);\n                 }\n \n+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);\n+\n                 return items;\n             }\n \n+            private static void ProcessNonWildCardItemUpdates(Dictionary<string, UpdateOperation> itemsWithNoWildcards, ImmutableList<ItemData>.Builder items)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does applying the operation here prevent it from eventually getting called on line 404?\r\n\r\nSome comments in the code would really make things easier to review, this area in particular seems to be lacking some comments. If you have a fresh understanding of some of these functions/classes (ie, MemoizedOperation, what `currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);` does vs `op.UpdateItem(items[i])` and how they're similar/different they would be **greatly** appreciated.",
              "createdAt": "2020-11-20T04:36:37Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -359,9 +404,26 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);\n                 }\n \n+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);\n+\n                 return items;\n             }\n \n+            private static void ProcessNonWildCardItemUpdates(Dictionary<string, UpdateOperation> itemsWithNoWildcards, ImmutableList<ItemData>.Builder items)\n+            {\n+                if (itemsWithNoWildcards.Count > 0)\n+                {\n+                    for (int i = 0; i < items.Count; i++)\n+                    {\n+                        if (itemsWithNoWildcards.TryGetValue(FileUtilities.GetFullPath(items[i].Item.EvaluatedInclude, items[i].Item.ProjectDirectory), out UpdateOperation op))\n+                        {\n+                            items[i] = op.UpdateItem(items[i]);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Sorta, but it's a little more complicated. (I'm sure that's exactly what you wanted to hear, right? \ud83d\ude04 )\r\n\r\nIf it's determined that the operation doesn't have things that expand like wildcards, it will hit the continue statement on line 386. That prevents line 404 from running for that operation. Additionally, at that point, it would have been \"addedToBatch,\" meaning it's in the dictionary that will be passed to this function next time we determine that we can't just add more. This function should always be called if the dictionary is nonempty at such a point (or, in reality, at all other times, but it does ~nothing if it's empty), so the real dependency here is that if an item has no fragments with wildcards, and it's an update operation, it will eventually get here, and line 404 doesn't run, but they don't affect each other directly.\r\n\r\nN.B.: One of the restrictions here is that it only affects UpdateOperations. That's mostly because that's the easy way to do it\u2014they get replaced in a 1:1 way. Other operations (Remove) could be included as well, but I wanted to try to keep this fairly simple. I didn't see a good reason to make it more complicated without any obvious benefit.",
              "createdAt": "2020-11-20T15:46:24Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -359,9 +404,26 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);\n                 }\n \n+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);\n+\n                 return items;\n             }\n \n+            private static void ProcessNonWildCardItemUpdates(Dictionary<string, UpdateOperation> itemsWithNoWildcards, ImmutableList<ItemData>.Builder items)\n+            {\n+                if (itemsWithNoWildcards.Count > 0)\n+                {\n+                    for (int i = 0; i < items.Count; i++)\n+                    {\n+                        if (itemsWithNoWildcards.TryGetValue(FileUtilities.GetFullPath(items[i].Item.EvaluatedInclude, items[i].Item.ProjectDirectory), out UpdateOperation op))\n+                        {\n+                            items[i] = op.UpdateItem(items[i]);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                #if DEBUG\r\n                throw error if wildcards\r\n                #endif\r\n                if (itemsWithNoWildcards.Count > 0)\r\n```",
              "createdAt": "2020-11-20T17:08:57Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -359,9 +404,26 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);\n                 }\n \n+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);\n+\n                 return items;\n             }\n \n+            private static void ProcessNonWildCardItemUpdates(Dictionary<string, UpdateOperation> itemsWithNoWildcards, ImmutableList<ItemData>.Builder items)\n+            {\n+                if (itemsWithNoWildcards.Count > 0)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd add a quick description here or at the call site. Preferably here.",
              "createdAt": "2020-11-21T00:12:02Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs",
              "diffHunk": "@@ -43,23 +46,69 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I\n                     return;\n                 }\n \n-                ItemSpecMatchesItem matchItemspec;\n-                bool? needToExpandMetadataForEachItem = null;\n+                SetMatchItemSpec();\n+                _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();\n+                _itemsToUpdate.Clear();\n \n+                for (int i = 0; i < listBuilder.Count; i++)\n+                {\n+                    var itemData = listBuilder[i];\n+\n+                    var matchResult = _matchItemSpec(_itemSpec, itemData.Item);\n+\n+                    if (matchResult.IsMatch)\n+                    {\n+                        listBuilder[i] = UpdateItem(listBuilder[i], matchResult.CapturedItemsFromReferencedItemTypes);\n+                    }\n+                }\n+\n+                DecorateItemsWithMetadata(_itemsToUpdate.ToImmutableList(), _metadata, _needToExpandMetadataForEachItem);\n+            }\n+\n+            internal ItemData UpdateItem(ItemData item)\n+            {\n+                if (_conditionResult)\n+                {\n+                    SetMatchItemSpec();\n+                    _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();\n+                    _itemsToUpdate.Clear();\n+                    MatchResult matchResult = _matchItemSpec(_itemSpec, item.Item);\n+                    if (matchResult.IsMatch)\n+                    {\n+                        ItemData clonedData = UpdateItem(item, matchResult.CapturedItemsFromReferencedItemTypes);\n+                        DecorateItemsWithMetadata(_itemsToUpdate.ToImmutableList(), _metadata, _needToExpandMetadataForEachItem);\n+                        return clonedData;\n+                    }\n+                }\n+                return item;\n+            }\n+\n+            private ItemData UpdateItem(ItemData item, Dictionary<string, I> capturedItemsFromReferencedItemTypes)\n+            {\n+                // items should be deep immutable, so clone and replace items before mutating them\n+                // otherwise, with GetItems caching enabled, the mutations would leak into the cache causing\n+                // future operations to mutate the state of past operations\n+                ItemData clonedData = item.Clone(_itemFactory, _itemElement);\n+                _itemsToUpdate.Add(new ItemBatchingContext(clonedData.Item, capturedItemsFromReferencedItemTypes));\n+                return clonedData;\n+            }\n+\n+            private void SetMatchItemSpec()",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nice to have while you're here: A comment here suggesting what's happening, ideally with a small example. Something like: \"see if, for example, *.cs matches somefilename.cs\" ( don't use this example \ud83d\ude42)",
              "createdAt": "2020-11-21T00:13:32Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs",
              "diffHunk": "@@ -43,23 +46,69 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I\n                     return;\n                 }\n \n-                ItemSpecMatchesItem matchItemspec;\n-                bool? needToExpandMetadataForEachItem = null;\n+                SetMatchItemSpec();\n+                _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();\n+                _itemsToUpdate.Clear();\n \n+                for (int i = 0; i < listBuilder.Count; i++)\n+                {\n+                    var itemData = listBuilder[i];\n+\n+                    var matchResult = _matchItemSpec(_itemSpec, itemData.Item);",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Definitely summarize this method since it's internal. \r\nA very rough idea:\r\n\"Set the item spec, do X with _itemsToUpdate, and return the cloned matching item\"",
              "createdAt": "2020-11-21T00:15:03Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs",
              "diffHunk": "@@ -43,23 +46,69 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I\n                     return;\n                 }\n \n-                ItemSpecMatchesItem matchItemspec;\n-                bool? needToExpandMetadataForEachItem = null;\n+                SetMatchItemSpec();\n+                _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();\n+                _itemsToUpdate.Clear();\n \n+                for (int i = 0; i < listBuilder.Count; i++)\n+                {\n+                    var itemData = listBuilder[i];\n+\n+                    var matchResult = _matchItemSpec(_itemSpec, itemData.Item);\n+\n+                    if (matchResult.IsMatch)\n+                    {\n+                        listBuilder[i] = UpdateItem(listBuilder[i], matchResult.CapturedItemsFromReferencedItemTypes);\n+                    }\n+                }\n+\n+                DecorateItemsWithMetadata(_itemsToUpdate.ToImmutableList(), _metadata, _needToExpandMetadataForEachItem);\n+            }\n+\n+            internal ItemData UpdateItem(ItemData item)",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't you call the private `UpdateItem` method here?",
              "createdAt": "2020-11-21T00:15:25Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs",
              "diffHunk": "@@ -43,23 +46,69 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I\n                     return;\n                 }\n \n-                ItemSpecMatchesItem matchItemspec;\n-                bool? needToExpandMetadataForEachItem = null;\n+                SetMatchItemSpec();\n+                _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();\n+                _itemsToUpdate.Clear();\n \n+                for (int i = 0; i < listBuilder.Count; i++)\n+                {\n+                    var itemData = listBuilder[i];\n+\n+                    var matchResult = _matchItemSpec(_itemSpec, itemData.Item);\n+\n+                    if (matchResult.IsMatch)\n+                    {\n+                        listBuilder[i] = UpdateItem(listBuilder[i], matchResult.CapturedItemsFromReferencedItemTypes);\n+                    }\n+                }\n+\n+                DecorateItemsWithMetadata(_itemsToUpdate.ToImmutableList(), _metadata, _needToExpandMetadataForEachItem);\n+            }\n+\n+            internal ItemData UpdateItem(ItemData item)\n+            {\n+                if (_conditionResult)\n+                {\n+                    SetMatchItemSpec();\n+                    _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();\n+                    _itemsToUpdate.Clear();\n+                    MatchResult matchResult = _matchItemSpec(_itemSpec, item.Item);\n+                    if (matchResult.IsMatch)\n+                    {\n+                        ItemData clonedData = UpdateItem(item, matchResult.CapturedItemsFromReferencedItemTypes);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "What do you mean? That's what it's doing.",
              "createdAt": "2020-11-23T19:01:56Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs",
              "diffHunk": "@@ -43,23 +46,69 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I\n                     return;\n                 }\n \n-                ItemSpecMatchesItem matchItemspec;\n-                bool? needToExpandMetadataForEachItem = null;\n+                SetMatchItemSpec();\n+                _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();\n+                _itemsToUpdate.Clear();\n \n+                for (int i = 0; i < listBuilder.Count; i++)\n+                {\n+                    var itemData = listBuilder[i];\n+\n+                    var matchResult = _matchItemSpec(_itemSpec, itemData.Item);\n+\n+                    if (matchResult.IsMatch)\n+                    {\n+                        listBuilder[i] = UpdateItem(listBuilder[i], matchResult.CapturedItemsFromReferencedItemTypes);\n+                    }\n+                }\n+\n+                DecorateItemsWithMetadata(_itemsToUpdate.ToImmutableList(), _metadata, _needToExpandMetadataForEachItem);\n+            }\n+\n+            internal ItemData UpdateItem(ItemData item)\n+            {\n+                if (_conditionResult)\n+                {\n+                    SetMatchItemSpec();\n+                    _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();\n+                    _itemsToUpdate.Clear();\n+                    MatchResult matchResult = _matchItemSpec(_itemSpec, item.Item);\n+                    if (matchResult.IsMatch)\n+                    {\n+                        ItemData clonedData = UpdateItem(item, matchResult.CapturedItemsFromReferencedItemTypes);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd add a summary here.",
              "createdAt": "2020-11-21T00:15:57Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -151,15 +151,15 @@ public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initial\n \n         private class MemoizedOperation : IItemOperation",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "That's out of scope in my opinion.",
              "createdAt": "2020-11-23T19:02:43Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -151,15 +151,15 @@ public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initial\n \n         private class MemoizedOperation : IItemOperation",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "If you gained enough context on this class I'd still suggest writing a summary, but it is out of scope. I don't feel too strongly about it.",
              "createdAt": "2020-11-24T01:27:43Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -151,15 +151,15 @@ public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initial\n \n         private class MemoizedOperation : IItemOperation",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Consider adding a high level comment summarizing what `ComputeItems` does.\r\n\r\nBecause this is a beefier function, here's an idea. For the summary:\r\n// Compute items does some stuff.\r\n// 1. Does A because B\r\n// 2. Does C because D\r\n\r\nThen in the code, when A or C happens you can place another comment:\r\n// 1. Here is some more detail on what A is.\r\n\r\nand later when C is happening\r\n//2. Perform C to do a thing.",
              "createdAt": "2020-11-21T00:18:51Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -315,13 +315,9 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                     //  If this is a remove operation, then add any globs that will be removed",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Emphasizing this comment.",
              "createdAt": "2020-12-04T17:14:45Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -315,13 +315,9 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                     //  If this is a remove operation, then add any globs that will be removed",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Adding a comment for an example of what a fragment would be here would be awesome.",
              "createdAt": "2020-11-21T00:19:35Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.Spec.Fragments.Count; i++)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Emphasizing this.",
              "createdAt": "2020-12-04T17:14:43Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.Spec.Fragments.Count; i++)",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just a slightly more descriptive idea.\r\n```suggestion\r\n                            // We found an item with a wildcard, remove all fragments from the current list so we don't process them yet.\r\n```",
              "createdAt": "2020-11-21T00:21:55Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.Spec.Fragments.Count; i++)\n+                        {\n+                            ItemSpecFragment frag = op.Spec.Fragments[i];\n+                            if (MSBuildConstants.CharactersForExpansion.Any(frag.TextFragment.Contains))\n+                            {\n+                                // Fragment contains wild cards, items, or properties. Cannot batch over it using a dictionary.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+\n+                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);\n+                            if (itemsWithNoWildcards.ContainsKey(fullPath))\n+                            {\n+                                // Another update will already happen on this path. Make that happen before evaluating this one.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+                            else\n+                            {\n+                                itemsWithNoWildcards.Add(fullPath, op);\n+                            }\n+                        }\n+                        if (!addToBatch)\n+                        {\n+                            // Remove items added before realizing we couldn't skip the item list",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Emphasizing this one.",
              "createdAt": "2020-12-04T17:14:39Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +338,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.Spec.Fragments.Count; i++)\n+                        {\n+                            ItemSpecFragment frag = op.Spec.Fragments[i];\n+                            if (MSBuildConstants.CharactersForExpansion.Any(frag.TextFragment.Contains))\n+                            {\n+                                // Fragment contains wild cards, items, or properties. Cannot batch over it using a dictionary.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+\n+                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);\n+                            if (itemsWithNoWildcards.ContainsKey(fullPath))\n+                            {\n+                                // Another update will already happen on this path. Make that happen before evaluating this one.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+                            else\n+                            {\n+                                itemsWithNoWildcards.Add(fullPath, op);\n+                            }\n+                        }\n+                        if (!addToBatch)\n+                        {\n+                            // Remove items added before realizing we couldn't skip the item list",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            /// Applies uncached item operations (include, remove, update) in order. Since Remove effectively overwrites Include or Update,\r\n            /// Remove operations are preprocessed (adding to globsToIgnore) to create a longer list of globs we don't need to process\r\n            /// properly because we know they will be removed. Update operations are batched as much as possible, meaning rather\r\n            /// than being applied immediately, they are combined into a dictionary of UpdateOperations that need to be applied. This\r\n            /// is to optimize the case in which as series of UpdateOperations, each of which affects a single ItemSpec, are applied to all\r\n            /// items in the list, leading to a quadratic-time operation.\r\n```",
              "createdAt": "2020-12-04T23:38:31Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -291,6 +291,9 @@ public ImmutableList<ItemData>.Builder GetItemData(ImmutableHashSet<string> glob\n                 }\n             }\n \n+            /// <summary>\n+            /// Applies uncached item operations (include, remove, update) in order.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                        // The TextFragments are things like abc.def or x*y.*z.\r\n                        for (i = 0; i < op.Spec.Fragments.Count; i++)\r\n```",
              "createdAt": "2020-12-04T23:45:35Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +341,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.Spec.Fragments.Count; i++)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                // We finished looping through the operations. Now process the final batch if necessary.\r\n                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);\r\n```",
              "createdAt": "2020-12-04T23:46:49Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -359,9 +407,29 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);\n                 }\n \n+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                            // We found a wildcard. Remove any fragments associated with the current operation and process them later.\r\n```",
              "createdAt": "2020-12-04T23:50:05Z",
              "path": "src/Build/Evaluation/LazyItemEvaluator.cs",
              "diffHunk": "@@ -342,15 +341,64 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte\n \n                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();\n \n+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);\n+                bool addedToBatch = false;\n+\n                 //  Walk back down the stack of item lists applying operations\n                 while (itemListStack.Count > 0)\n                 {\n                     var currentList = itemListStack.Pop();\n \n+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)\n+                    {\n+                        bool addToBatch = true;\n+                        int i;\n+                        for (i = 0; i < op.Spec.Fragments.Count; i++)\n+                        {\n+                            ItemSpecFragment frag = op.Spec.Fragments[i];\n+                            if (MSBuildConstants.CharactersForExpansion.Any(frag.TextFragment.Contains))\n+                            {\n+                                // Fragment contains wild cards, items, or properties. Cannot batch over it using a dictionary.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+\n+                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);\n+                            if (itemsWithNoWildcards.ContainsKey(fullPath))\n+                            {\n+                                // Another update will already happen on this path. Make that happen before evaluating this one.\n+                                addToBatch = false;\n+                                break;\n+                            }\n+                            else\n+                            {\n+                                itemsWithNoWildcards.Add(fullPath, op);\n+                            }\n+                        }\n+                        if (!addToBatch)\n+                        {\n+                            // Remove items added before realizing we couldn't skip the current item list",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should AssertItemHasMetadata have an overload that accepts a tuple name-value, so you can eliminate all these dictionaries in the test?",
              "createdAt": "2020-12-08T05:05:10Z",
              "path": "src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs",
              "diffHunk": "@@ -2604,6 +2604,141 @@ public void LastUpdateWins()\n             ObjectModelHelpers.AssertItemHasMetadata(expectedUpdate, items[0]);\n         }\n \n+        [Theory]\n+        [InlineData(\"abc\", \"def\", \"abc\")]\n+        [InlineData(\"abc\", \"de*\", \"abc\")]\n+        [InlineData(\"a*c\", \"def\", \"abc\")]\n+        [InlineData(\"abc\", \"def\", \"*bc\")]\n+        [InlineData(\"abc\", \"d*f\", \"*bc\")]\n+        [InlineData(\"*c\", \"d*f\", \"*bc\")]\n+        [InlineData(\"a*\", \"d*\", \"abc\")]\n+        public void UpdatesProceedInOrder(string first, string second, string third)\n+        {\n+            string contents = $@\"\n+<i Include='abc'>\n+    <m1>m1_contents</m1>\n+</i>\n+<j Include='def'>\n+    <m1>m1_contents</m1>\n+</j>\n+<i Update='{first}'>\n+    <m1>first</m1>\n+</i>\n+<j Update='{second}'>\n+    <m1>second</m1>\n+</j>\n+<i Update='{third}'>\n+    <m1>third</m1>\n+</i>\n+\";\n+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(contents, allItems: true);\n+            Dictionary<string, string> expectedUpdatei = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"third\" }\n+            };\n+            Dictionary<string, string> expectedUpdatej = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"second\" }\n+            };\n+\n+            ObjectModelHelpers.AssertItemHasMetadata(expectedUpdatei, items[0]);\n+            ObjectModelHelpers.AssertItemHasMetadata(expectedUpdatej, items[1]);\n+        }\n+\n+        [Fact]\n+        public void UpdatingIndividualItemsProceedsInOrder()\n+        {\n+            string contents = @\"\n+<i Include='a;b;c'>\n+    <m1>m1_contents</m1>\n+</i>\n+<i Update='a'>\n+    <m1>second</m1>\n+</i>\n+<i Update='b'>\n+    <m1>third</m1>\n+</i>\n+<i Update='c'>\n+    <m1>fourth</m1>\n+</i>\n+<afterFirst Include='@(i)' />\n+<i Update='*'>\n+    <m1>sixth</m1>\n+</i>\n+<afterSecond Include='@(i)' />\n+<i Update='b'>\n+    <m1>seventh</m1>\n+</i>\n+<afterThird Include='@(i)' />\n+<i Update='c'>\n+    <m1>eighth</m1>\n+</i>\n+<afterFourth Include='@(i)' />\n+\";\n+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(contents, allItems: true);\n+            Dictionary<string, string> expectedAfterFirsta = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"second\" }\n+            };\n+            Dictionary<string, string> expectedAfterFirstb = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"third\" }\n+            };\n+            Dictionary<string, string> expectedAfterFirstc = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"fourth\" }\n+            };\n+            Dictionary<string, string> expectedAfterSeconda = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"sixth\" }\n+            };\n+            Dictionary<string, string> expectedAfterSecondb = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"sixth\" }\n+            };\n+            Dictionary<string, string> expectedAfterSecondc = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"sixth\" }\n+            };\n+            Dictionary<string, string> expectedAfterThirda = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"sixth\" }\n+            };\n+            Dictionary<string, string> expectedAfterThirdb = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"seventh\" }\n+            };\n+            Dictionary<string, string> expectedAfterThirdc = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"sixth\" }\n+            };\n+            Dictionary<string, string> expectedAfterFourtha = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"sixth\" }\n+            };\n+            Dictionary<string, string> expectedAfterFourthb = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"seventh\" }\n+            };\n+            Dictionary<string, string> expectedAfterFourthc = new Dictionary<string, string>\n+            {\n+                {\"m1\", \"eighth\" }\n+            };\n+\n+            ObjectModelHelpers.AssertItemHasMetadata(expectedAfterFirsta, items[3]);",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's up with this change?",
              "createdAt": "2020-12-18T17:21:59Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -9,7 +9,7 @@\n     <PackageReference Update=\"Microsoft.Net.Compilers.Toolset\" Version=\"$(MicrosoftNetCompilersToolsetVersion)\" />\n     <PackageReference Update=\"Microsoft.VisualStudio.SDK.EmbedInteropTypes\" Version=\"15.0.15\" />\n     <PackageReference Update=\"Microsoft.VisualStudio.Setup.Configuration.Interop\" Version=\"1.16.30\" />\n-    <PackageReference Update=\"Microsoft.Win32.Registry\" Version=\"4.3.0\" />\n+    <PackageReference Update=\"Microsoft.Win32.Registry\" Version=\"4.6.0\" />",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}