{
  "number": 10820,
  "title": "Keep duplicates logging issue 9585",
  "body": "Fixes #9585\r\n\r\n### Context\r\nLogging of items within target affected by the \"RemoveDuplicates\" attribute was somewhat confusing as these were logged while including the soon-to-be-removed duplicates.\r\n\r\n### Changes Made\r\nMoved the logger invocation inside of the function that is doing the duplicate removal to properly reflect it.\r\n\r\n### Testing\r\n\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2024-10-15T15:11:44Z",
  "updatedAt": "2024-11-04T08:51:41Z",
  "closedAt": "2024-11-04T08:44:39Z",
  "mergedAt": "2024-11-04T08:44:39Z",
  "additions": 63,
  "deletions": 16,
  "changedFiles": 3,
  "headRefName": "KeepDuplicates-logging-issue-9585",
  "isDraft": false,
  "author": {
    "login": "SimaTian"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "a8b81cda7d2f0cd6208cf7c83f8f020a2531d247",
          "message": "fixing logging of duplicates for KeepDuplicates=false option. optimizing portion of the code by using a hashset. implementing review comments",
          "committedDate": "2024-10-29T18:10:53Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "62123b3a395d514f8b4d209c81eb72c2719c84a2",
          "message": "Merge branch 'main' into KeepDuplicates-logging-issue-9585",
          "committedDate": "2024-10-30T09:40:37Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "028fdb5db432e268bdda780177a027b2735b5e99",
          "message": "removing if branch as per discussion with Kyrill",
          "committedDate": "2024-11-01T08:28:29Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "e493eb5d77a78f28ee06f845db70f67eca2c6716",
          "message": "Merge branch 'KeepDuplicates-logging-issue-9585' of https://github.com/dotnet/msbuild into KeepDuplicates-logging-issue-9585",
          "committedDate": "2024-11-01T08:29:00Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "5ee349c97e8e0257d4a7bb0fac86f2ec3e062381",
          "message": "Merge branch 'main' into KeepDuplicates-logging-issue-9585",
          "committedDate": "2024-11-01T08:30:03Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tom.bartonek@volny.cz"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "More of a discussion opener. If you've got a better idea about how to handle the logging please let me know.\r\n\r\nA follow up question: the only affected functionality is the binary log. Say I wanted to add another thing to the current list of possible operations which is currently handled via TaskParameterMessageKind. e.g. something like addItemSkipped to indicate that yes, we hit the item in description but we removed all the listings due to them being duplicates. (currently there is an empty item there, which works I suppose. But for the sake of argument let's say I wanted to be more explicit).\r\nIs extending the enum enough or are there some gotchas like needing to update the binary log reader as well?",
        "createdAt": "2024-10-15T15:20:18Z",
        "author": {
          "login": "SimaTian"
        }
      },
      {
        "body": "> More of a discussion opener. If you've got a better idea about how to handle the logging please let me know.\r\n> \r\n> A follow up question: the only affected functionality is the binary log. Say I wanted to add another thing to the current list of possible operations which is currently handled via TaskParameterMessageKind. e.g. something like addItemSkipped to indicate that yes, we hit the item in description but we removed all the listings due to them being duplicates. (currently there is an empty item there, which works I suppose. But for the sake of argument let's say I wanted to be more explicit). Is extending the enum enough or are there some gotchas like needing to update the binary log reader as well?\r\n\r\nTechnically - adding to an enum is a breaking change. It can potentially be breaking downstream consumers (other then just binlog viewer).\r\nThat being said - let's not conclude untill (if) there is a concrete case of need for that :-)",
        "createdAt": "2024-10-15T16:17:43Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "I'd say let's add a unit-test for this scenario and also be clear about whether we're going to return a lazy collection or allocate. ",
        "createdAt": "2024-10-17T06:25:20Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I apologize for adding work, but this needs to be rewritten from scratch, likely using a HashSet:\r\nhttps://github.com/dotnet/msbuild/blob/adb4394981ec9c44f59dfa9fbc903670eddf6be6/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs#L661-L669\r\n\r\n@rainersigwald did you see this? ^^",
        "createdAt": "2024-10-17T06:45:09Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Interesting rabbit hole.\r\n\r\nYes, thanks for pointing out that I've dropped the logging conditions. I will add them, if we decide to go through with the logging. \r\n\r\nI've done some bare bones benchmarking via a simple test case:\r\n```\r\n<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>\r\n<Target Name='t'>\r\n<ItemGroup>\r\n<item1 Include='x0;x0;x0;x0' KeepDuplicates=\"false\"/>\r\n<item1 Include='x1;x1;x1;x1' KeepDuplicates=\"false\"/>\r\n<item1 Include='x2;x2;x2;x2' KeepDuplicates=\"false\"/>\r\n<item1 Include='x3;x3;x3;x3' KeepDuplicates=\"false\"/>\r\n...\r\n<item1 Include='x9999;x9999;x9999;x9999' KeepDuplicates=\"false\"/>\r\n</ItemGroup>\r\n</Target></Project>\r\n ```\r\nAnd the same but without the KeepDuplicates option.\r\nThat I then loaded via unit test to run, profile, etc.\r\n\r\nThis is a pathological scenario targeted at making the pain point as pronounced as possible even for a case that should have similar complexity for both KeepDuplicates variations. I've chosen a \"narrow\" structure of the item - e.g. from the \"eyes see\" perspective, there shouldn't be too large of a difference between a work when removing the duplicates and when keeping them intact to make the variations comparable\r\n\r\nThat being said\r\n - the time without KeepDuplicates was ~3.3s\r\n - the time with KeepDuplicates was ~8.5s\r\n - the time with KeepDuplicates and updated logging was ~12-14s\r\n\r\nso apparently, the ToList() is quite costly when we hit the affected path. The ToList conversion has to happen unless we do some refactoring around that. I will take a look at the options.\r\n\r\n\r\nsince you pointed out, I took a closer look at the doNotAddDuplicates section\r\n```\r\nif (doNotAddDuplicates)\r\n{\r\n    // Remove duplicates from the inputs.\r\n    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\r\n\r\n    // Ensure we don't also add any that already exist.\r\n    var existingItems = GetItems(itemType);\r\n    if (existingItems.Count > 0)\r\n    {\r\n        itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\r\n    }\r\n}\r\n```\r\n- GetItems looks like an extensive method\r\n  - it does a lot of heavy lifting, especially if we have many scopes etc.\r\n  - would there be a way to cache it or do something similar at least across items within same scope? (or at least for items within same item group?) The scope should be ~identical and this seems like a lot of work to do repeatedly.\r\n- Contains is linear, so this is easily a hidden n^2 cost if we add a bunch of values into a single item in sequence for some reason.\r\n\r\nThere were some more things that I was confused about, I will try to dive a bit deeper and consider some potential optimizations.\r\n\r\nThis will also need some evaluation on a \"normal\"-ish project to see an impact outside the targeted scenario - how much will it help? (or to look at it from a different perspective, how often is KeepDuplicates used  within a large-sized project?)\r\n\r\n\r\n",
        "createdAt": "2024-10-17T15:36:32Z",
        "author": {
          "login": "SimaTian"
        }
      },
      {
        "body": "Yes, O(n^2) is a big concern here.\r\n\r\nThere are only 8 usages of KeepDuplicates in common targets:\r\n![image](https://github.com/user-attachments/assets/9ca0d9ba-ab1f-4810-8d99-66a8c0a32004)\r\n\r\nHowever they are on a hot path, because copy to output directory contains a large number of items (transitively), so I think we've uncovered a big perf problem.\r\n\r\nI think this whole area just snowballed from a tiny bugfix to a larger refactoring, so you decide whether this is a can of worms worth opening now. ",
        "createdAt": "2024-10-17T19:44:36Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I think you can search any binlog for a project that copies a bunch of files to output for `$additem _SourceItemsToCopyToOutputDirectory`, this will give you a real world example of a typical item list. We can then use this data in a unit-test, which will also be good for profiling.\r\n\r\nThis feels like a good case for Benchmark.NET.",
        "createdAt": "2024-10-17T19:49:13Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I added a simple HashTable for now to do an initial performance evaluation. \r\nFor the case where \r\n```\r\n<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>\r\n<Target Name='t'>\r\n<ItemGroup>\r\n    <item1 Include='x0;x1 ... x1999'>\r\n    ... 100 times in total\r\n    <item1 Include='x0;x1 ... x1999'>\r\n</ItemGroup>\r\n</Target></Project>\r\n```\r\nthe time went down from ~20-25s to 9s and the KeepDuplicates disappeared from the critical path in the profiler run.\r\nI will start a performance run to see if it is ok like this and do some more poking around to see if we want to introduce some cutoff for a number of items where we might not want to do the dictionary creation.\r\n\r\nAt the same time, when doing this test, the .ToList() call here:\r\n```\r\n            if (doNotAddDuplicates)\r\n            {\r\n                logFunction?.Invoke(itemsToAdd.ToList());\r\n            }\r\n            else {\r\n                var groupAsList = group as List<ProjectItemInstance>;\r\n                logFunction?.Invoke(groupAsList ?? group.ToList());  \r\n            }\r\n```\r\nis not noticeable anymore(performance wise).\r\nI will check for smaller table sizes. But if we have enough time for a .ToHashSet() call on every pre-existing item I would say we also have time for one more .ToList() call. Please correct me if I'm wrong.\r\n\r\nSecondary note @KirillOsenkov, what is your reason for wanting to remove the ?? operator please? \r\nI can replace\r\n```\r\nvar groupAsList = group as List<ProjectItemInstance>;\r\nlogFunction?.Invoke(groupAsList ?? group.ToList());\r\n```\r\nwith something like\r\n```\r\nvar groupAsList = group as List<ProjectItemInstance>;\r\nif (groupAsList !=null) \r\n{\r\n    logFunction?.Invoke(groupAsList);\r\n}\r\nelse\r\n{\r\n    logFunction?.Invoke(group.ToList());\r\n}\r\n```\r\nHowever it looks somewhat unwieldy. \r\nOr did you have something else in mind please?\r\n\r\n\r\n",
        "createdAt": "2024-10-22T14:52:51Z",
        "author": {
          "login": "SimaTian"
        }
      },
      {
        "body": "Let's add a unit-test that hits this codepath if we don't have one yet. It will make further experiments easier.",
        "createdAt": "2024-10-22T19:00:38Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "There is already a bunch of simple unit tests for all three cases that we're touching here:\r\n - two duplicates in one item are [covered here](https://github.com/dotnet/msbuild/blob/69b3e7a43fb2fb26812b20807333cf6ca62167f2/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs#L359)\r\n - duplicate not being added in a separate item tag is [covered here](https://github.com/dotnet/msbuild/blob/69b3e7a43fb2fb26812b20807333cf6ca62167f2/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs#L298)\r\n - and there are bunch of other cases for similar things.\r\n\r\nOf course, if we decide to add a split for creating a hash table vs not creating one, we can add an additional test.\r\nAlso the new deduplication you proposed probably wants a separate codepath to make sure that adding a duplicate in one item doesn't stop working suddenly.",
        "createdAt": "2024-10-23T08:43:09Z",
        "author": {
          "login": "SimaTian"
        }
      },
      {
        "body": "Appreciate your patience as we work through the feedback!",
        "createdAt": "2024-10-29T22:32:30Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "[celebrate]     Yuliia Kovalova reacted to your message:\r\n________________________________\r\nFrom: Tomas Bartonek ***@***.***>\r\nSent: Monday, November 4, 2024 8:45:01 AM\r\nTo: dotnet/msbuild ***@***.***>\r\nCc: Yuliia Kovalova ***@***.***>; Review requested ***@***.***>\r\nSubject: Re: [dotnet/msbuild] Keep duplicates logging issue 9585 (PR #10820)\r\n\r\n\r\nMerged #10820<https://github.com/dotnet/msbuild/pull/10820> into main.\r\n\r\n\u2014\r\nReply to this email directly, view it on GitHub<https://github.com/dotnet/msbuild/pull/10820#event-15100026186>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AWYM53TDJIRSBQ7Y4RBJAB3Z64XY3AVCNFSM6AAAAABP7MVGUCVHI2DSMVQWIX3LMV45UABCJFZXG5LFIV3GK3TUJZXXI2LGNFRWC5DJN5XDWMJVGEYDAMBSGYYTQNQ>.\r\nYou are receiving this because your review was requested.Message ID: ***@***.***>\r\n",
        "createdAt": "2024-11-04T08:51:40Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "It feels like we'd be allocating unnecesarily in majority of the cases. Can we just reuse the incomming structure if it wasn't changed?\r\n\r\n```suggestion\r\n            logFunction?.Invoke(doNotAddDuplicates ? itemsToAdd.ToList() : itemsToAdd);\r\n```",
              "createdAt": "2024-10-15T16:32:12Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n                 }\n             }\n+            logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "There is a question if it isn't kind of dangerous though:\r\nthe function signature allows for any ICollection to be passed. Currently, we're only passing a list (or a list-like collection) that shouldn't have an issue with this. However it seems somewhat iffy to assume that this will always be the case.",
              "createdAt": "2024-10-16T08:00:29Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n                 }\n             }\n+            logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Maybe even worse now after a second look: the logger is expecting Ilist, itemsToAdd is an IEnumerable so as suggested I think it won't work.\r\nGoing one step further to use\r\n ```ogFunction?.Invoke(doNotAddDuplicates ? itemsToAdd.ToList() : List<ProjectItemInstance>group);```\r\nwill work - for now, since we're passing only List things to the function call that uses the lambda. However it is not future proof/safe I think.",
              "createdAt": "2024-10-16T14:19:05Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n                 }\n             }\n+            logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "also please keep in mind that this is the most allocation heavy part of MSBuild so every allocated byte needs to be carefully reasoned about. Items take up the most memory and are a noticeable part of why MSBuild is slow.",
              "createdAt": "2024-10-16T16:11:42Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n                 }\n             }\n+            logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "stylistically I strongly prefer an if statement here instead of a null coalescing operator",
              "createdAt": "2024-10-17T06:21:33Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n                 }\n             }\n+            logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "> this is the most allocation heavy part of MSBuild so every allocated byte needs to be carefully reasoned about\r\n\r\n~I have slightly less concern since this is at execution time rather than eval, but of course that's no reason not to think about and improve allocations.~\r\n\r\nOh no, Lookup is used during eval isn't it? I was looking at the current PR which affects only the intrinsic.",
              "createdAt": "2024-10-17T18:55:21Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n                 }\n             }\n+            logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "ooof, now that I'm reading this this is returning an enumerable that will evaluate every time you enumerate it. This is not good. I think this whole method needs to be carefully reviewed (and we'll likely have to allocate to eagerly realize the collection once, because keeping it lazy will have multiple consumers each iterating on it)",
              "createdAt": "2024-10-17T06:20:53Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "wait, how does that Contains method work? Is that O(n)?\r\n\r\nThe more I look the more perf questions I have. The whole method looks super sketchy now. Distinct is expensive, GetItems is expensive, we don't use a Hashtable (??) and we potentially double-enumerate the itemsToAdd\r\n\r\nI think the whole method needs to be carefully revisited and we probably need to measure allocations before and after",
              "createdAt": "2024-10-17T06:32:52Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Do we care about the allocations only due to performance constraints or is there a memory reason as well please?\r\nBecause if we only care about the performance, then removing the O(n^2) easily justifies an extra hash table allocation. If this would still be an issue, I would probably have to rewrite GetItems() so that it can return a HashSet instead of the current Linked list if required. (Or we would have to really carefully check if we can just return a HashSet every time although that sounds risky)",
              "createdAt": "2024-10-22T15:05:49Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "We always want to use less memory, since GC overhead is a big factor in .NET performance. But that's in service of wall-clock-time improvements, so if there's a \"create temporary data structure to avoid a whole bunch of CPU time\" option as here it's definitely worth considering.",
              "createdAt": "2024-10-22T15:10:40Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Understood, thanks for the clarification.\r\nThen the question is:\r\nShould I rewrite significant portion of the `GetItems` method to directly return a HashSet to save the allocation in this specific case?\r\n(I'm not sure if my understanding is correct, but since ProjectItemInstance is a reference-based object, it should be a hash set with an overhead number of items * pointer size or something which is something but maybe not enough considering the size of the ProjectItemInstances we operate with)\r\n\r\nI can do it and I'm fairly sure I now have the context for the change. However it will be fairly decent chunk of code that is affected which is also something to consider. ",
              "createdAt": "2024-10-22T15:19:40Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -668,6 +669,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n                     itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Interesting tidbit here, I got burned by my lack of C# familiarity:\r\n```var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);```\r\nalongside the foreach few lines lower\r\n\r\nThis looks weird, however it was a way to force the collection to act as a HashSet instead of falling back to the Enumerable interface(and underlying generic collection implementation) which uses a linear lookup for .Contain call. Even if the underlying collection is a dictionary.\r\n\r\nOr if there is a nicer way to achieve the same, please let me know.",
              "createdAt": "2024-10-22T15:09:01Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -663,12 +664,32 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "open curly goes on a new line",
              "createdAt": "2024-10-22T18:51:40Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -663,12 +663,32 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+                \n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+                    \n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd) {\n+                        if (!existingItemsHashSet.Contains(item)) {",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "never two consecutive empty lines in C#",
              "createdAt": "2024-10-22T18:51:55Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -663,12 +663,32 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+                \n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+                    \n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd) {\n+                        if (!existingItemsHashSet.Contains(item)) {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                   itemsToAdd = deduplicatedItemsToAdd;\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());\n+            }\n+            else {\n+                var groupAsList = group as List<ProjectItemInstance>;\n+                logFunction?.Invoke(groupAsList ?? group.ToList());  \n+            }\n+           \n+",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "let's not hardcode `List<T>` and instead just do `Action<IList>` since `IList` is what's needed by the consumer.",
              "createdAt": "2024-10-22T18:54:26Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs",
              "diffHunk": "@@ -215,21 +215,27 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke\n                 FileSystems.Default,\n                 LoggingContext);\n \n+            Action<List<ProjectItemInstance>> logFunction = null;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "this no longer deduplicates if the itemsToAdd has duplicates.\r\n\r\nInstead, you can do:\r\n```csharp\r\nif (existingItemsHasSet.Add(item))\r\n{\r\n    deduplicatedItemsToAdd.Add(item);\r\n}\r\n```",
              "createdAt": "2024-10-22T18:57:36Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -663,12 +663,32 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+                \n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+                    \n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd) {\n+                        if (!existingItemsHashSet.Contains(item)) {\n+                            deduplicatedItemsToAdd.Add(item);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "HashSet.Add returns false if the item was already there",
              "createdAt": "2024-10-22T18:58:02Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -663,12 +663,32 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+                \n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+                    \n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd) {\n+                        if (!existingItemsHashSet.Contains(item)) {\n+                            deduplicatedItemsToAdd.Add(item);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "There is still this few lines above so the itemsToAdd has no duplicates.\r\n`itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);`\r\nHowever your construct looks cleaner. Thanks for the suggestion.\r\n\r\n",
              "createdAt": "2024-10-23T08:20:27Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -663,12 +663,32 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+                \n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+                    \n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd) {\n+                        if (!existingItemsHashSet.Contains(item)) {\n+                            deduplicatedItemsToAdd.Add(item);",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "With your construct we can skip the Distinct altogether, saving one extra pass over the collection I think.",
              "createdAt": "2024-10-23T08:21:20Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -663,12 +663,32 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+                \n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+                    \n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd) {\n+                        if (!existingItemsHashSet.Contains(item)) {\n+                            deduplicatedItemsToAdd.Add(item);",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Still needed if the list is empty, in the \"compute everything case\" I removed it and used your construct.",
              "createdAt": "2024-10-23T09:01:25Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -663,12 +663,32 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+                \n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+                    \n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd) {\n+                        if (!existingItemsHashSet.Contains(item)) {\n+                            deduplicatedItemsToAdd.Add(item);",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: for new code I super strongly prefer using [raw string literals](https://learn.microsoft.com/dotnet/csharp/programming-guide/strings/#raw-string-literals) which read much cleaner.",
              "createdAt": "2024-10-23T21:51:26Z",
              "path": "src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs",
              "diffHunk": "@@ -314,6 +314,26 @@ public void ItemKeepDuplicatesFalse()\n             Assert.Single(group);\n         }\n \n+        [Fact]\n+        public void ItemKeepDuplicatesFalseTwoDuplicatesAtOnce()\n+        {\n+            string content = ObjectModelHelpers.CleanupFileContents(@\"",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "agreed, let's convert to raw string literals",
              "createdAt": "2024-10-27T23:40:44Z",
              "path": "src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs",
              "diffHunk": "@@ -314,6 +314,26 @@ public void ItemKeepDuplicatesFalse()\n             Assert.Single(group);\n         }\n \n+        [Fact]\n+        public void ItemKeepDuplicatesFalseTwoDuplicatesAtOnce()\n+        {\n+            string content = ObjectModelHelpers.CleanupFileContents(@\"",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "there shouldn't be an empty line after a `{` or before a `}`",
              "createdAt": "2024-10-27T23:31:22Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n ",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think there's no need to differentiate between the two cases (Count > 0). Let's remove the if and the else block, and just use the body of the if.",
              "createdAt": "2024-10-27T23:33:03Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "in one case we are adding both to ExistingItemsHashSet(which started empty due to Count == 0 and to the DeduplicatedItemsToAdd.\r\nin the other case, we are only building one HashSet via the .Distincs call.\r\nAlso, we're guaranteed to hit the == 0 case at least once for every item we see so if we care about the memory allocations, I would say that this makes sense to be kept. ",
              "createdAt": "2024-10-29T17:56:28Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Actually this only helps if we're not doing logging. Becase when we're doing loggin, we create the HashSet and the .ToList() so the count is same. Only when logging is disabled, this would result in an additional allocation.\r\nI think that this should be fine. Ok, I'll remove the if block.",
              "createdAt": "2024-11-01T08:17:11Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If there is another statement after `}` there should be an empty line after it. ",
              "createdAt": "2024-10-27T23:33:46Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`{` on the new line please",
              "createdAt": "2024-10-27T23:33:59Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());\n+            }\n+            else {",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The problem with these `?`-heavy expressions is that they're hard to debug. You can't put a breakpoint in one branch to see whether it gets hit. Regular if statements are much better even if they take more lines. They're also straightforward and easy to read.",
              "createdAt": "2024-10-27T23:35:01Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());\n+            }\n+            else {\n+                var groupAsList = group as List<ProjectItemInstance>;\n+                logFunction?.Invoke(groupAsList ?? group.ToList());  ",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "also GitHub doesn't show this, but there are two unnecessary spaces at the end of this line, let's remove them. ",
              "createdAt": "2024-10-27T23:55:16Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());\n+            }\n+            else {\n+                var groupAsList = group as List<ProjectItemInstance>;\n+                logFunction?.Invoke(groupAsList ?? group.ToList());  ",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I thought about this and this particular case of ?? seems fine. \r\n\r\nI'd maybe consider extracting the null check for logFunction to a separate if statement:\r\n`if (logFunction != null) { ... }` this way the groupAsList cast doesn't have to run when the logFunction is null",
              "createdAt": "2024-10-28T00:03:46Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());\n+            }\n+            else {\n+                var groupAsList = group as List<ProjectItemInstance>;\n+                logFunction?.Invoke(groupAsList ?? group.ToList());  ",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "extracted the null check.",
              "createdAt": "2024-10-29T17:57:52Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());\n+            }\n+            else {\n+                var groupAsList = group as List<ProjectItemInstance>;\n+                logFunction?.Invoke(groupAsList ?? group.ToList());  ",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "ToList() is not necessary here. We already know exactly that the list is created by us so there's no need to reallocate it.\r\n\r\nAs I said before, this is an extremely sensitive path allocation-wise, so every allocation needs to be reasoned about. When working with MSBuild, the scale is always bigger than what you think it is. This is going to allocate terabytes and terabytes of memory and burn gigawatts of energy worldwide.",
              "createdAt": "2024-10-27T23:38:52Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "```\r\n  if (doNotAddDuplicates)\r\n            {\r\n                logFunction?.Invoke(itemsToAdd.ToList());\r\n```\r\nitemsToAdd is a HashSet due to the optimization we just introduced.\r\nIn the other branch, we're using the `asList` check to avoid allocation whenever possible.\r\nis there anything I missed please?",
              "createdAt": "2024-10-29T18:00:05Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Yes, there's some confusion: itemsToAdd is never a HashSet. It is assigned from deduplicatedItemsToAdd (which is a List) on line 678.\r\n\r\nIn the case where existingItems is empty you're allocating an empty HashSet via a ToHashSet call, and then calling Distinct, which is another hidden allocation of a HashSet. I want to avoid this double allocation.\r\n\r\nLet's unify both branches (there's no need to differentiate based on existingItems.Count), this will only allocate a single HashSet for all cases, and we can remove the ToList() in the call to logFunction.",
              "createdAt": "2024-10-29T22:32:14Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Ah, sorry, my bad.\r\nThere is still the[ this question](https://github.com/dotnet/msbuild/pull/10820#discussion_r1821312034): \r\ndon't we introduce another duplication(although at a different place) if we remove the if branch due to both building the list and hash set instead of just doing the .Distinct call (which only builds the hash set)?\r\n",
              "createdAt": "2024-10-30T09:49:23Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "As per my comment to the linked question.",
              "createdAt": "2024-11-01T11:29:46Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "will this group ever be a List<T>? or never? or sometimes?",
              "createdAt": "2024-10-27T23:39:41Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());\n+            }\n+            else {\n+                var groupAsList = group as List<ProjectItemInstance>;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I double-checked, and this function is only called in two places, and in both of them it gets passed a `List<T>`:\r\nhttps://source.dot.net/#Microsoft.Build/BackEnd/Components/RequestBuilder/Lookup.cs,35477908c518ae2a,references\r\n\r\nI also debugged and verified that it's List<T> in both cases (ExpandIntoItemsLeaveEscaped always allocates and returns a `List<T>`). \r\n\r\nSo in theory we could remove the cast and type check, but I'd still keep it just in case things change in the future. But for our purposes today it's helpful to know that the `group` is always a `List<T>`.",
              "createdAt": "2024-10-28T00:10:20Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());\n+            }\n+            else {\n+                var groupAsList = group as List<ProjectItemInstance>;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "yes. I meant it there as a future proofing since the function does not guarantee that it will only ever be a list so it could introduce an annoying bug down the line.",
              "createdAt": "2024-10-29T18:01:12Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+\n+                    var deduplicatedItemsToAdd = new List<ProjectItemInstance>();\n+                    foreach (var item in itemsToAdd)\n+                    {\n+                        if (existingItemsHashSet.Add(item))\n+                        {\n+                            deduplicatedItemsToAdd.Add(item);\n+                        }\n+                    }\n+                    itemsToAdd = deduplicatedItemsToAdd;\n+                }\n+                else\n+                {\n+                    // Remove the duplicates in case we're not concerned with the existing items.\n+                    itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n                 }\n             }\n \n+            if (doNotAddDuplicates)\n+            {\n+                logFunction?.Invoke(itemsToAdd.ToList());\n+            }\n+            else {\n+                var groupAsList = group as List<ProjectItemInstance>;",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "There's no need for ToolsVersion and xmlns, let's remove these and keep the tests minimal",
              "createdAt": "2024-10-27T23:41:03Z",
              "path": "src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs",
              "diffHunk": "@@ -314,6 +314,26 @@ public void ItemKeepDuplicatesFalse()\n             Assert.Single(group);\n         }\n \n+        [Fact]\n+        public void ItemKeepDuplicatesFalseTwoDuplicatesAtOnce()\n+        {\n+            string content = ObjectModelHelpers.CleanupFileContents(@\"\n+            <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "remove this empty line too",
              "createdAt": "2024-10-27T23:47:51Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -658,17 +659,41 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst\n             IEnumerable<ProjectItemInstance> itemsToAdd = group;\n             if (doNotAddDuplicates)\n             {\n-                // Remove duplicates from the inputs.\n-                itemsToAdd = itemsToAdd.Distinct(ProjectItemInstance.EqualityComparer);\n \n                 // Ensure we don't also add any that already exist.\n                 var existingItems = GetItems(itemType);\n+              \n+                var existingItemsHashSet = existingItems.ToHashSet(ProjectItemInstance.EqualityComparer);\n+\n                 if (existingItems.Count > 0)\n                 {\n-                    itemsToAdd = itemsToAdd.Where(item => !existingItems.Contains(item, ProjectItemInstance.EqualityComparer));\n+",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      }
    ]
  }
}